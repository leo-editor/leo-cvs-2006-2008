<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="9728" clone_windows="0"/>
<globals body_outline_ratio="0.513905683192">
	<global_window_position top="61" left="348" height="827" width="819"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20040803072955.58,ekr.20031218072017.3077,ekr.20040803072955.58,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="ekr.20060514170725"><vh>4.4.1 projects</vh>
<v t="ekr.20060514170854"><vh>Fixed bugs</vh>
<v t="ekr.20060514164817"><vh>Fixed crasher in searchbox plugin</vh>
<v t="ekr.20060514164817.1"><vh>Report</vh></v>
</v>
<v t="ekr.20060529083409"><vh>Fixed bug in toGuiIndex</vh>
<v t="ekr.20060528172956"><vh>toGuiIndex &amp; toPythonIndex</vh></v>
</v>
<v t="ekr.20060522101202"><vh>Fixed problems reported by Check bindings script.</vh></v>
<v t="ekr.20060530100259"><vh>Auto-indent now words with multiple editors</vh>
<v t="ekr.20051125080855"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
</v>
</v>
<v t="ekr.20060522103446"><vh>New features</vh>
<v t="ekr.20060512101324"><vh>(Support for new colorizer)</vh>
<v t="ekr.20060512101324.1"><vh>What I did</vh></v>
<v t="ekr.20060129052538.1"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh>
<v t="ekr.20060321105403"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20060321105403.1"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20060321105403.2"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20060321105403.3"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
</v>
<v t="ekr.20060309065445"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20060129052538.2"><vh>masterClickHandler</vh></v>
<v t="ekr.20060131084938"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20060128090219"><vh>masterMenuHandler</vh></v>
</v>
<v t="ekr.20040803072955.128"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2954"><vh>c.redraw and c.redraw_now</vh></v>
<v t="ekr.20031218072017.3963"><vh>put (leoTkinterFrame:statusLineClass)</vh></v>
<v t="ekr.20040803072955.58" a="M"><vh>tree.redraw_now &amp; helper</vh>
<v t="ekr.20040803072955.59"><vh>redrawHelper</vh></v>
</v>
</v>
<v t="ekr.20060519003651.1"><vh>Added debug command</vh>
<v t="ekr.20060519003651"><vh>debug</vh>
<v t="ekr.20060521140213"><vh>&lt;&lt; find a debugger or return &gt;&gt;</vh></v>
<v t="ekr.20060521140213.1"><vh>&lt;&lt; find the target file &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060522083716"><vh>Run Idle in a separate process</vh>
<v t="ekr.20031218072017.2932"><vh>openPythonWindow (Dave Hein)</vh>
<v t="ekr.20060522102610"><vh>&lt;&lt; open idle in a separate process &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2933"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2934"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="ekr.20031218072017.2936"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2935"><vh>&lt;&lt; Try to open idle in Python 2.2 systems&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2937"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="ekr.20060522082833"><vh>Added Debug button to scripting plugin</vh>
<v t="ekr.20060519003651"><vh>debug</vh>
<v t="ekr.20060521140213"><vh>&lt;&lt; find a debugger or return &gt;&gt;</vh></v>
<v t="ekr.20060521140213.1"><vh>&lt;&lt; find the target file &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20050505104140"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
<v t="EKR.20040614071102.1"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050211100535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
<v t="ekr.20050506084734"><vh>writeFromString</vh></v>
<v t="ekr.20041005105605.15"><vh>initWriteIvars</vh>
<v t="ekr.20041005105605.16"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.157"><vh>writeOpenFile</vh></v>
</v>
<v t="ekr.20060224104109"><vh>Improved searches</vh>
<v t="ekr.20031218072017.4074"><vh>Indices (Tk)</vh>
<v t="ekr.20060528172956"><vh>toGuiIndex &amp; toPythonIndex</vh></v>
<v t="ekr.20031218072017.4075"><vh>firstIndex</vh></v>
<v t="ekr.20031218072017.4076"><vh>lastIndex</vh></v>
<v t="ekr.20031218072017.4077"><vh>moveIndexBackward</vh></v>
<v t="ekr.20031218072017.4078"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20031218072017.4079"><vh>compareIndices</vh></v>
<v t="ekr.20031218072017.4080"><vh>getindex</vh></v>
</v>
<v t="ekr.20050315073003"><vh> Index utilities...</vh>
<v t="ekr.20050314140957"><vh>g.convertPythonIndexToRowCol  &amp; test</vh>
<v t="ekr.20050314140957.1"><vh>bruteForceConvertPythonIndexToRowCol</vh></v>
<v t="ekr.20050314140957.2"><vh>test_g_convertPythonIndexToRowCol</vh></v>
</v>
<v t="ekr.20050315071727"><vh>g.convertRowColToPythonIndex &amp; test</vh>
<v t="ekr.20050315072239"><vh>test_g_convertPythonIndexToRowCol</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3070"><vh>changeSelection</vh>
<v t="ekr.20060526201951"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20051023094009"><vh>Search classes</vh>
<v t="ekr.20060123125256"><vh>class minibufferFind (the findHandler)</vh>
<v t="ekr.20060123125317.2"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20060124140114"><vh> Options</vh>
<v t="ekr.20060124123133"><vh>setFindScope</vh></v>
<v t="ekr.20060124122844"><vh>setOption</vh></v>
<v t="ekr.20060125082510"><vh>getOption</vh></v>
<v t="ekr.20060125074939"><vh>showFindOptions</vh></v>
<v t="ekr.20060124135401"><vh>toggleOption</vh></v>
<v t="ekr.20060205105950"><vh>setupChangePattern</vh></v>
<v t="ekr.20060125091234"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20060210180352"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20060210164421"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20060128080201"><vh>cloneFindAll</vh></v>
<v t="ekr.20060204120158"><vh>findAgain</vh></v>
<v t="ekr.20060209064140"><vh>findAll</vh></v>
<v t="ekr.20060205105950.1"><vh>generalChangeHelper</vh></v>
<v t="ekr.20060124181213.4"><vh>generalSearchHelper</vh></v>
<v t="ekr.20060210174441"><vh>lastStateHelper</vh></v>
<v t="ekr.20050920084036.113"><vh>replaceString</vh></v>
<v t="ekr.20060124140224.3"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060124140224.1"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060125093807"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060124134356"><vh>setupArgs</vh></v>
<v t="ekr.20060210173041"><vh>stateZeroHelper</vh></v>
<v t="ekr.20060224171851"><vh>updateChange/FindList</vh></v>
<v t="ekr.20060124140224.2"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__</vh>
<v t="ekr.20051020120306.12"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051020120306.13"><vh>createFrame (findTab)</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.19"><vh>find.init</vh>
<v t="ekr.20051020120306.20"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020120306.21"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020120306.22"><vh>find.update_ivars</vh></v>
<v t="ekr.20060221074900"><vh>Callbacks</vh>
<v t="ekr.20060221074900.1"><vh>findButtonCallback</vh></v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
</v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20060209064832"><vh>findAllCommand</vh></v>
<v t="ekr.20060204120158.1"><vh>findAgainCommand</vh></v>
<v t="ekr.20060128075225"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.27"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020120306.28"><vh>Tkinter wrappers</vh></v>
<v t="ekr.20051020120306.1"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020120306.2"><vh>__init__</vh>
<v t="ekr.20051020120306.3"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.4"><vh>bindHotKey</vh></v>
<v t="ekr.20051020120306.5"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20060123131421"><vh>Top-level methods</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>Find Tab commands</vh></v>
<v t="ekr.20060124115801"><vh>getHandler</vh></v>
<v t="ekr.20060123115459"><vh>Find options wrappers</vh></v>
<v t="ekr.20060124093828"><vh>Find wrappers</vh></v>
<v t="ekr.20060204120158.2"><vh>findAgain</vh></v>
</v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20060420144640"><vh>iSearchBackspace</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
<v t="ekr.20060203072636"><vh>endSearch</vh></v>
</v>
</v>
</v>
<v t="ekr.20060527065935"><vh>Switching finds to changes</vh>
<v t="ekr.20060527065935.1"><vh>From minibuffer find handler</vh>
<v t="ekr.20060123125317.2"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20060124134356"><vh>setupArgs</vh></v>
<v t="ekr.20060124140224.1"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060124140224.3"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060125093807"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060210173041"><vh>stateZeroHelper</vh></v>
<v t="ekr.20050920084036.113"><vh>replaceString</vh></v>
</v>
<v t="ekr.20050920085536.62"><vh>getArg</vh>
<v t="ekr.20050928092516"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh>
<v t="ekr.20060321105403"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20060321105403.1"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20060321105403.2"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20060321105403.3"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
</v>
<v t="ekr.20060309065445"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20060128081317"><vh>shortcutFromSetting</vh>
<v t="ekr.20060201065809"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060215104239"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060128103640.1"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060128103640.2"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060128103640.4"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3077" a="M"><vh>search &amp; helpers</vh>
<v t="ekr.20060526140328"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20060526081931"><vh>Search helpers...</vh>
<v t="ekr.20060526092203"><vh>regexHelper</vh></v>
<v t="ekr.20060526140744"><vh>backwardsHelper</vh></v>
<v t="ekr.20060526093531"><vh>plainHelper</vh></v>
<v t="ekr.20060526140744.1"><vh>matchWord</vh></v>
</v>
</v>
</v>
<v t="ekr.20060214072931"><vh>Added run-unit-test command</vh></v>
<v t="ekr.20060527182907"><vh>Support multiple editors in the body pane</vh>
<v t="ekr.20031218072017.2182"><vh>tkBody. __init__</vh></v>
<v t="ekr.20031218072017.3998"><vh>tkBody.createControl</vh></v>
<v t="ekr.20060528100747.3"><vh>tkBody.createTextWidget</vh></v>
<v t="ekr.20060528100747"><vh>Editors</vh>
<v t="ekr.20060528100747.1"><vh>addEditor</vh>
<v t="ekr.20060528110922"><vh>&lt;&lt; create label and text widgets &gt;&gt;</vh></v>
</v>
<v t="ekr.20060528170438"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20060528113806"><vh>deleteEditor</vh></v>
<v t="ekr.20060528104554"><vh>onFocusIn</vh></v>
<v t="ekr.20060528132829"><vh>selectMainEditor</vh></v>
<v t="ekr.20060528131618"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20040803072955.128"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060528173539"><vh>Created gui.toPythonIndex &amp; gui.toGuiIndex</vh></v>
<v t="ekr.20060515060803"><vh>Allow idle-time redraw</vh>
<v t="ekr.20060515060803.1"><vh>Report</vh></v>
<v t="ekr.20040803072955.16"><vh>__init__ (tkTree)</vh>
<v t="ekr.20040803072955.17"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20040803072955.18"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040803072955.19"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.35"><vh>Drawing... (tkTree)</vh>
<v t="ekr.20051216155728"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20040803072955.58" a="M"><vh>tree.redraw_now &amp; helper</vh>
<v t="ekr.20040803072955.59"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20040803072955.61"><vh>idle_second_redraw</vh></v>
<v t="ekr.20051105073850"><vh>drawX...</vh>
<v t="ekr.20040803072955.36"><vh>drawBox</vh></v>
<v t="ekr.20040803072955.37"><vh>drawClickBox</vh></v>
<v t="ekr.20040803072955.39"><vh>drawIcon</vh>
<v t="ekr.20040803072955.40"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.41"><vh>drawLine</vh></v>
<v t="ekr.20040803072955.42"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040803072955.43"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20040803072955.44"><vh>drawText</vh></v>
<v t="ekr.20040803072955.46"><vh>drawUserIcons</vh></v>
<v t="ekr.20040803072955.47"><vh>drawUserIcon</vh>
<v t="ekr.20040803072955.48"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20040803072955.49"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20040803072955.50"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20040803072955.51"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.52"><vh>drawTopTree</vh></v>
<v t="ekr.20040803072955.53"><vh>drawTree</vh></v>
</v>
<v t="ekr.20040803072955.62"><vh>Helpers...</vh>
<v t="ekr.20040803072955.63"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20040803072955.64"><vh>getIconImage</vh></v>
<v t="ekr.20040803072955.65"><vh>scrollTo</vh>
<v t="ekr.20040803072955.66"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040803072955.67"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.68"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20040803072955.70"><vh>yoffset</vh></v>
</v>
</v>
</v>
<v t="ekr.20060419101401"><vh>Completed transition to 'end-1c'</vh>
<v t="ekr.20060529091202.1"><vh>Changes</vh>
<v t="ekr.20031218072017.4028"><vh>tkBody.getAllText</vh></v>
<v t="ekr.20031218072017.4091"><vh>g.app.gui.getAllText</vh></v>
<v t="ekr.20051023132350"><vh>getLabel</vh></v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
<v t="ekr.20060417183606.1"><vh>moveLinesUp (works, except for selection point when last line selected)</vh></v>
<v t="ekr.20060204120158.1"><vh>findAgainCommand</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
</v>
<v t="ekr.20060529091202"><vh>Replaced gui.setTextSelection (t,"1.0","end-1c") by gui.selectAllText</vh>
<v t="ekr.20060529092645"><vh>selectAllText (new in 4.4.1)</vh></v>
<v t="ekr.20031218072017.3907"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
</v>
</v>
<v t="ekr.20051121070552"><vh>Finished Cmds menu</vh>
<v t="ekr.20060529161541"><vh>regex patterns</vh></v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20050921103230"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060117095212.5"><vh>defineCmdsMenuCenterTable</vh></v>
<v t="ekr.20060117095212.4"><vh>defineCmdsMenuChangeCaseTable</vh></v>
<v t="ekr.20060529170949"><vh>defineCmdsMenuHelpTable</vh></v>
<v t="ekr.20060117095212.6"><vh>defineCmdsMenuIndentTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20060117095212.3"><vh>defineCmdsMenuSortTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
</v>
</v>
<v t="ekr.20060529195042"><vh>Added docstrings for all commands</vh></v>
<v t="ekr.20060529175453"><vh>Improved show-fonts command</vh></v>
<v t="ekr.20060529230636"><vh>Improved formatting of output of the help-for-command command</vh>
<v t="ekr.20060417203717"><vh>helpForCommand</vh></v>
</v>
<v t="ekr.20051012062458.1"><vh>Strip quotes from color, font settings.</vh></v>
<v t="ekr.20060202235215.1"><vh>Warn about invalid Enter and Leave key bindings</vh>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060530084936"><vh>&lt;&lt; give warning and return if we try to bind to Enter or Leave &gt;&gt;</vh></v>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20060527190049" a="V"><vh>Before 4.4.1b1</vh>
<v t="ekr.20060211093935"><vh>Support for on-enter-mode in mode declarations</vh>
<v t="ekr.20060122184114"><vh>Support the execution of a command when entering a mode</vh></v>
</v>
<v t="ekr.20041029083459"><vh>Remember Import directory</vh></v>
<v t="ekr.20041130103128"><vh>killcolor also kills autoindenting</vh></v>
<v t="ekr.20060529130603"><vh>Fix all reported problems with plugins</vh>
<v t="ekr.20060529130603.1"><vh>Reports</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"
marks="ekr.20031218072017.3077,"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"
marks="ekr.20040803072955.58,"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040612215018">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i &lt; j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1</t>
<t tx="EKR.20040614071102.1">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script</t>
<t tx="EKR.20040627100424">if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()</t>
<t tx="ekr.20031218072017.1329"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = g.app.gui.getAllText(bodyCtrl) # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText))
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        g.trace('newText:',repr(newText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        &lt;&lt; recolor the body &gt;&gt;
        if not c.changed: c.setChanged(True)
        self.updateEditors()
        &lt;&lt; redraw the screen if necessary &gt;&gt;</t>
<t tx="ekr.20031218072017.2140">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    &lt;&lt; redirect output &gt;&gt;
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    g.es("end of script",color="purple")
            except Exception:
                &lt;&lt; handle an exception in the script &gt;&gt;
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        &lt;&lt; unredirect output &gt;&gt;</t>
<t tx="ekr.20031218072017.2143">if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr</t>
<t tx="ekr.20031218072017.2182">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterBody")
    
    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)
    
    c = self.c
    self.editor_name = None
    self.editor_v = None
    self.editorWidgets = {} # keys are pane names, values are Tk.Text widgets

    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.bodyCtrl = self.createControl(frame,parentFrame)
    self.colorizer = leoColor.colorizer(c)</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2932">def openPythonWindow (self,event=None):
    
    '''Open Python's Idle debugger in a separate process.'''
    
    if 1:
        &lt;&lt; open idle in a separate process &gt;&gt;
    else:
        if sys.platform == "linux2":
            &lt;&lt; open idle in Linux &gt;&gt;
        else:
            &lt;&lt; open idle in Windows &gt;&gt;</t>
<t tx="ekr.20031218072017.2933"># 09-SEP-2002 DHEIN: Open Python window under linux

try:
    pathToLeo = g.os_path_join(g.app.loadDir,"leo.py")
    sys.argv = [pathToLeo]
    from idlelib import idle
    if g.app.idle_imported:
        reload(idle)
    g.app.idle_imported = True
except:
    try:
        g.es("idlelib could not be imported.")
        g.es("Probably IDLE is not installed.")
        g.es("Run Tools/idle/setup.py to build idlelib.")
        g.es("Can not import idle")
        g.es_exception() # This can fail!!
    except: pass
</t>
<t tx="ekr.20031218072017.2934"># Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo"] # ,"-t","Leo"]

ok = False
if g.CheckVersion(sys.version,"2.3"):
    &lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;
else:
    &lt;&lt; Try to open idle in Python 2.2 systems &gt;&gt;

if not ok:
    g.es("Can not import idle")
    if idle_dir and idle_dir not in sys.path:
        g.es("Please add '%s' to sys.path" % idle_dir)</t>
<t tx="ekr.20031218072017.2935">try:
    executable_dir = g.os_path_dirname(sys.executable)
    idle_dir = g.os_path_join(executable_dir,"Tools","idle")

    # 1/29/04: sys.path doesn't handle unicode in 2.2.
    idle_dir = str(idle_dir) # May throw an exception.

    # 1/29/04: must add idle_dir to sys.path even when using importFromPath.
    if idle_dir not in sys.path:
        sys.path.insert(0,idle_dir)

    if 1:
        import PyShell
    else: # Works, but is not better than import.
        PyShell = g.importFromPath("PyShell",idle_dir)

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    if 1: # Mostly works, but causes problems when opening other .leo files.
        PyShell.main()
    else: # Doesn't work: destroys all of Leo when Idle closes.
        self.leoPyShellMain()
    ok = True
except ImportError:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20031218072017.2936">try:
    idle_dir = None
    
    import idlelib.PyShell

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    idlelib.PyShell.main()
    ok = True

except:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20031218072017.2937">@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work well.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

if 0:

    def leoPyShellMain(self):
        
        import PyShell
        root = g.app.root
        PyShell.fixwordbreaks(root)
        flist = PyShell.PyShellFileList(root)
        shell = PyShell.PyShell(flist)
        flist.pyshell = shell
        shell.begin()</t>
<t tx="ekr.20031218072017.2954">def redraw (self):
    c = self
    c.beginUpdate()
    c.endUpdate()

def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    if 0: # Interferes with new colorizer.
        c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
force_redraw = redraw_now</t>
<t tx="ekr.20031218072017.3070"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text
    
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    change_text = change_text.replace('\\n','\n').replace('\\t','\t')
                
    gui.replaceSelectionRangeWithText(t,          start,end,change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
</t>
<t tx="ekr.20031218072017.3077">def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.
    
    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl ; gui = g.app.gui
    index = gui.getInsertPoint(w)
    s = gui.getAllText(w)
    index = gui.toPythonIndex(s,w,index)
    stopindex = g.choose(self.reverse,0,len(s))
    while 1:
        pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
            backwards=self.reverse,nocase=self.ignore_case,
            regexp=self.pattern_match,word=self.whole_word)
        if pos == -1: return None,None
        pos    = gui.toGuiIndex(s,w,pos)
        newpos = gui.toGuiIndex(s,w,newpos)
        &lt;&lt; fail if we are passed the wrap point &gt;&gt;
        gui.setTextSelection(w,pos,newpos,insert=newpos)
        return pos, newpos</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3907">def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()

    c.widgetWantsFocusNow(t)
    gui.selectAllText(t)</t>
<t tx="ekr.20031218072017.3963">def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(s,g.callers())
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    ##### t.update_idletasks() # interferes with coloring.</t>
<t tx="ekr.20031218072017.3998">def createControl (self,frame,parentFrame):
    
    c = self.c
    
    # New in 4.4.1: make the parent frame a Pmw.PanedWidget.
    self.numberOfEditors = 1
   
    self.pb = pb = Pmw.PanedWidget(parentFrame,orient='horizontal')
    parentFrame = pb.add('1')
    pb.pack(expand=1,fill='both') # Must be done after the first page created.
   
    w = self.createTextWidget(frame,parentFrame,name=None,p=None)
    self.editorWidgets[None] = w
    return w</t>
<t tx="ekr.20031218072017.4028">def getAllText (self):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get("1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4074"></t>
<t tx="ekr.20031218072017.4075">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20031218072017.4076">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20031218072017.4077">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20031218072017.4078">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20031218072017.4079">def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False</t>
<t tx="ekr.20031218072017.4080">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20031218072017.4091">def getAllText (self,t):
    
    """Return all the text of Tk.Text widget t converted to unicode."""

    s = t.get("1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 final, build %s, May 11, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040803072955.16">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    trace = c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace('tkTree')
    
    # Configuration and debugging settings.
    self.expanded_click_area    = c.config.getBool('expanded_click_area')
    self.gc_before_redraw       = c.config.getBool('gc_before_redraw')
    self.idle_redraw            = c.config.getBool('idle_redraw')
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')

    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')
    self.trace_select           = c.config.getBool('trace_select')
    self.trace_stats            = c.config.getBool('show_tree_stats')
 
    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []</t>
<t tx="ekr.20040803072955.17">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20040803072955.18"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20040803072955.19"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20040803072955.35"></t>
<t tx="ekr.20040803072955.36">def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId</t>
<t tx="ekr.20040803072955.37">def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)</t>
<t tx="ekr.20040803072955.39">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20040803072955.40">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20040803072955.41">def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
</t>
<t tx="ekr.20040803072955.42">def drawNode(self,p,x,y):
    
    c = self.c
    
    # g.trace(x,y,p,id(self.canvas))
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20040803072955.43">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20040803072955.44">def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)
   
    self.configureTextState(p)

    return self.line_height</t>
<t tx="ekr.20040803072955.46">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20040803072955.47">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20040803072955.48">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20040803072955.49">pass</t>
<t tx="ekr.20040803072955.50">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p
    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20040803072955.51">pass</t>
<t tx="ekr.20040803072955.52">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        self.redrawCount += 1
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())
        
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)

    if self.trace_stats: self.showStats()
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20040803072955.53">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20040803072955.58"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20040803072955.59">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20040803072955.61">def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        g.trace(self.redrawCount)</t>
<t tx="ekr.20040803072955.62"></t>
<t tx="ekr.20040803072955.63">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20040803072955.64">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20040803072955.65">def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.</t>
<t tx="ekr.20040803072955.66">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20040803072955.67">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20040803072955.68">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20040803072955.70">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c):
        # g.trace('does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20040803072955.128">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('does not exist',p.headString())
        return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                else:
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.after(100,scrollCallback)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.</t>
<t tx="ekr.20040803072955.129"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20040803072955.130"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20040803072955.131"># c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20040803072955.132"># The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!</t>
<t tx="ekr.20040803072955.133">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

c.frame.body.selectMainEditor() # New in Leo 4.4.1.

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()</t>
<t tx="ekr.20041005105605.15">def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    &lt;&lt; init ivars for writing &gt;&gt;
    
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)
    
    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)
    
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'
    
    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []</t>
<t tx="ekr.20041005105605.16">@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""</t>
<t tx="ekr.20041005105605.157"># New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""
    
    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()</t>
<t tx="ekr.20041029083459">By: Kent Tenney - ktenney
Import to @file request  
2004-10-28 11:27
Howdy, 
 
Please ignore if this is a difficult feature to implement. 
 
File-&gt;Import-&gt;Import to @file  
always starts in .../leo/src 
 
I would prefer if it opened to the last directory from 
which a file was imported. 
 
I often find myself importing several files from the same area of the directory tree, and repeatedly navigating there from leo/src gets tiresome. 
 
Thanks, 
Kent
</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041130103128">By: Roger Erens - rogererens
@
2004-11-25 09:14
On leo4.2, winXP, my default language is Python and smart_auto_indent=0. 
Normally, after ending a line with a colon, the next line gets indented by 1 tab, also in comment-sections. 
When using an @killcolor directive in a node, the line following one that ends with a colon starts at column zero.

I think it is unreasonable for @killcolor to interfere with indenting.</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20050211100535">def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)</t>
<t tx="ekr.20050314140957">def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl &gt; -1
            return row,i-prevNl-1</t>
<t tx="ekr.20050314140957.1">def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i &lt; total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total</t>
<t tx="ekr.20050314140957.2">def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'

    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = g.convertPythonIndexToRowCol(s,i)
        rowCol_2 = g.bruteForceConvertPythonIndexToRowCol(s,i)
        if g.app.unitTesting:
            assert i == len(s) or rowCol_1 == rowCol_2
        else:
            print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
            print rowCol_1,rowCol_2</t>
<t tx="ekr.20050315071727">def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row &gt;= len(lines):
        return len(s)
        
    col = min(col, len(lines[row]))

    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col</t>
<t tx="ekr.20050315072239">def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = g.convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1</t>
<t tx="ekr.20050315073003"></t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050505104140">g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "&lt;string&gt;":
    c.goToScriptLineNumber(p,script,n)

&lt;&lt; dump the lines near the error &gt;&gt;</t>
<t tx="ekr.20050506084734"># This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True,useSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline, but don't change the focus!

    at.initWriteIvars(root,"&lt;string-file&gt;",
        nosentinels=not useSentinels,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=not useSentinels,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050920084036.113">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.stack = [] # A stack of previous matches.
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-tab-find-all':                    self.findAll,
        
        # Thin wrappers on Find tab
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k ; w = self.w
    
    self.forward = forward
    self.regexp = regexp
    
    old_i = w.index('insert')
    old_p = c.currentPosition()
    self.stack = [g.Bunch(insert=old_i,p=old_p)]

    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    c = self.c ; k = self.k ; w = self.w
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    stopindex = g.choose(self.forward,'end','1.0')
    startindex = g.choose(self.forward,'1.0','end')
    p1 = c.currentPosition() ; p = p1.copy() ; old_p = p.copy()
    old_ins = w.index('insert') # This must *not* be changed in the loop.
    w.mark_set('insert',startindex)
    while 1:
        try:
            i = w.search(pattern,old_ins,backwards=not self.forward,stopindex=stopindex,regexp=self.regexp)
            # Don't call endSearch here.  We'll do that when the user hits return.
            g.trace(repr(i))
            if not i.isspace():
                w.mark_set('insert',i)
                # if self.forward:
                    # w.mark_set('insert',i)
                # else:
                    # w.mark_set('insert',i+'-%dc'%(len(pattern)))
                w.see('insert')
                self.stack.append(g.Bunch(insert=old_ins,p=old_p,pattern=pattern[:-1]))
                # g.trace('found',old_ins,i)
                return   
        except: pass # g.es_exception()
        # old_p = p.copy()
        if self.forward: p.moveToThreadNext()
        else:            p.moveToThreadBack()
        if not p: break
        g.trace('searching',p.headString())
        c.selectPosition(p)
        w.mark_set('insert','1.0')
        w.update_idletasks()
        # if not self.forward:
            # w.mark_set('insert','end')
    c.selectPosition(p1)</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = '1.0'
    index = w.index('insert')
    index2 = w.index('%s+%dc' % (index,len(s)))
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    &lt;&lt; give warning and return if we try to bind to Enter or Leave &gt;&gt;
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = g.stripBrackets(shortcut.strip())
        # if shortcut.startswith('&lt;Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility</t>
<t tx="ekr.20050920085536.38">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    
    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            if ch == '\b':
                s = g.app.gui.getAllText(w)
                if len(s) &gt; len(k.mb_prefix):
                    w.delete(i+'-1c')
            else:
                w.insert('insert',ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)</t>
<t tx="ekr.20050920085536.62">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = 0 or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'</t>
<t tx="ekr.20050921103230">def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuHelpTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
</t>
<t tx="ekr.20050921103736">def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&amp;mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Center...',          self.cmdsMenuCenterTable),
        ('C&amp;hange Case...',     self.cmdsMenuChangeCaseTable),
        ('&amp;Help For Commands...',self.cmdsMenuHelpTable),
        ('&amp;Indent...',          self.cmdsMenuIndentTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('&amp;Sort...',            self.cmdsMenuSortTable),
        ('S&amp;pell Check...',     self.cmdsMenuSpellCheckTable),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20050928092516">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter</t>
<t tx="ekr.20051012062458.1"></t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None,show=True):
    
    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)</t>
<t tx="ekr.20051020120306.1">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020120306.2">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020120306.3">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020120306.4">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)</t>
<t tx="ekr.20051020120306.5"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020120306.12">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    
    if  self.optionsOnly:
        buttons = []
    else:
        &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole &amp;Word", self.dict["whole_word"]),
    ("&amp;Ignore Case",self.dict["ignore_case"]),
    ("Wrap &amp;Around",self.dict["wrap"]),
    ("&amp;Reverse",    self.dict["reverse"]),
    ('Rege&amp;xp',     self.dict['pattern_match']),
    ("Mark &amp;Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&amp;Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
]

checkLists[1] = [
    ("Search &amp;Headline", self.dict["search_headline"]),
    ("Search &amp;Body",     self.dict["search_body"]),
    ("Mark &amp;Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051020120306.19">def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020120306.20">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020120306.21">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")</t>
<t tx="ekr.20051020120306.22">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    c.widgetWantsFocus(t)
    g.app.gui.selectAllText(t)
    c.widgetWantsFocus(t)</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"</t>
<t tx="ekr.20051020120306.28">def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051023132350">def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    
    if self.useTextWidget:
        w.update_idletasks()
        s = g.app.gui.getAllText(w)
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''</t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)
        
    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'
        
    if 0: # No longer needed.
        def findTabClickCallback(event,self=self):
            c = self.c ; k = c.k ; w = event.widget
            k.keyboardQuit(event)
            w and c.widgetWantsFocusNow(w)
            return k.masterClickHandler(event)

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    findButtonBindingCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)</t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()</t>
<t tx="ekr.20051026083733.6">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20051026083733.7">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20051026092433">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20051026171121">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p,w)
        # g.trace(removeTrailing)</t>
<t tx="ekr.20051026171121.1"># By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051105073850"></t>
<t tx="ekr.20051121070552"></t>
<t tx="ekr.20051125080855">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    # g.trace('event',event,g.callers())
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    # g.trace(name)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name,repr(ch))
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20051216155728">def beginUpdate (self):
    
    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())
    
def endUpdate (self,flag,scroll=False):
    
    self.updateCount -= 1
    # g.trace('  tree',id(self),self.updateCount,g.callers())
    
    if self.updateCount &lt;= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount &lt; 0:
            g.trace("Can't happen: negative updateCount",g.callers())</t>
<t tx="ekr.20060114110141">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)</t>
<t tx="ekr.20060114115648">for bunch in bunchList:

    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060117094955">def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat &amp;Last Complex Command',    'repeat-complex-command'),
        ('&amp;Execute Named Command',          'full-command'),
        ('Keyboard &amp;Quit',                  'keyboard-quit'),
        ('-', None),
    ]
</t>
<t tx="ekr.20060117094955.1">def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ('&amp;Toggle Abbreviation Mode',    'abbrev-mode'),
        ('-', None),
        ('&amp;List Abbrevs',                'list-abbrevs'),
        ('&amp;Read Abbrevs',                'read-abbrev-file'),
        ('&amp;Write Abbrevs',               'write-abbrev-file'),
        ('-', None),
        ('&amp;Add Global Abbrev',           'add-global-abbrev'),
        ('&amp;Inverse Add Global Abbrev',   'inverse-add-global-abbrev'),
        ('&amp;Kill All Abbrevs',            'kill-all-abbrevs'),
        ('-', None),
        # ('&amp;Expand Abbrev',             'expand-abbrev'), # Not a command
        ('&amp;Expand Abbrev in Region',     'expand-region-abbrevs'),
    ]</t>
<t tx="ekr.20060117095212">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('&amp;Append To Buffer',             'append-to-buffer'),
        ('&amp;Kill Buffer',                  'kill-buffer'),
        ('List &amp;Buffers',                 'list-buffers'),
        ('&amp;List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('&amp;Prepend To Buffer',            'prepend-to-buffer'),
        ('&amp;Rename Buffer',                'rename-buffer'),
        ('&amp;Switch To Buffer',             'switch-to-buffer'),
    ]</t>
<t tx="ekr.20060117095212.1">def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ('&amp;Append To Reg',   'append-to-register'),
        ('Copy R&amp;ect To Reg','copy-rectangle-to-register'),
        ('&amp;Copy To Reg',     'copy-to-register'),
        ('I&amp;nc Reg',         'increment-register'),
        ('&amp;Insert Reg',      'insert-register'),
        ('&amp;Jump To Reg',     'jump-to-register'),
        # ('xxx',           'number-to-register'),
        ('&amp;Point to Reg',    'point-to-register'),
        ('P&amp;repend To Reg',  'prepend-to-register'),
        ('&amp;View Reg',        'view-register'),
    ]</t>
<t tx="ekr.20060117095212.2">def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ('&amp;Clear Rect',  'clear-rectangle'),
        ('C&amp;lose Rect',  'close-rectangle'),
        ('&amp;Delete Rect', 'delete-rectangle'),
        ('&amp;Kill Rect',   'kill-rectangle'),
        ('&amp;Open Rect',   'open-rectangle'),
        ('&amp;String Rect', 'string-rectangle'),
        ('&amp;Yank Rect',   'yank-rectangle'),
    ]</t>
<t tx="ekr.20060117095212.3">def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort &amp;Columns',    'sort-columns'),
        ('Sort &amp;Fields',     'sort-fields'),
        ('Sort &amp;Lines',      'sort-lines'),
    ]</t>
<t tx="ekr.20060117095212.4">def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('&amp;Capitalize Word', 'capitalize-word'),
        ('&amp;Downcase Word',   'downcase-word'),
        ('&amp;Upcase Word',     'upcase-word'),
        ('-', None),
        ('D&amp;owncase Region', 'downcase-region'),
        ('U&amp;pcase Region',   'upcase-region'),
    ]
</t>
<t tx="ekr.20060117095212.5">def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center &amp;Line',     'center-line'),
        ('Center &amp;Region',   'center-region'),
    ]</t>
<t tx="ekr.20060117095212.6">def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('&amp;Indent Region',   'indent-region'),
        ('Indent R&amp;elative', 'indent-relative'),
        ('Indent Ri&amp;gidly',  'indent-rigidly'),
        ('&amp;Unindent Region', 'unindent-region'),
    ]</t>
<t tx="ekr.20060117095212.7">def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check &amp;Spelling',      'open-spell-tab'),
        ('&amp;Change',              'spell-change'),
        ('Change, &amp;Then Find',   'spell-change-then-find'),
        ('&amp;Find',                'spell-find'),
        ('&amp;Ignore',              'spell-ignore'),
    ]</t>
<t tx="ekr.20060117114315">def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ('&amp;Load Macro File',     'load-file'),
        ("-", None),
        ('&amp;Start Macro',         'start-kbd-macro'),
        ('&amp;End Macro',           'end-kbd-macro'),
        ('&amp;Name Last Macro',     'name-last-kbd-macro'),
        ("-", None),
        ('&amp;Call Last Macro',     'call-last-keyboard-macro'),
        ('&amp;Insert Macro',        'insert-keyboard-macro'),
    ]</t>
<t tx="ekr.20060122184114">- Entering outline mode should call c.endEditing.
- Entering edit mode shouldn't call c.endEditing!
</t>
<t tx="ekr.20060123115459">def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')
    
def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')
    
def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)</t>
<t tx="ekr.20060123125256">class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others</t>
<t tx="ekr.20060123125317.2">def __init__(self,c,finder):

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []
    
    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s</t>
<t tx="ekr.20060123131421"></t>
<t tx="ekr.20060124093828">def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)</t>
<t tx="ekr.20060124115801">def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler</t>
<t tx="ekr.20060124122844">def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060124123133">def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)</t>
<t tx="ekr.20060124134356">def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()</t>
<t tx="ekr.20060124135401">def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060124140114"></t>
<t tx="ekr.20060124140224.1">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060124140224.2">def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060124140224.3">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060124181213.4">def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    c = self.c
    
    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()</t>
<t tx="ekr.20060125074939">def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))</t>
<t tx="ekr.20060125082510">def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        verbose and g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None</t>
<t tx="ekr.20060125091234">def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060125093807">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060127183752">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    # g.trace(stroke,g.callers())
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting

    val = self.masterKeyHandlerHelper(event,stroke,trace)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    if trace: g.trace('done:',repr(val))
    return val</t>
<t tx="ekr.20060128075225">def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20060128080201">def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)</t>
<t tx="ekr.20060128081317">def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip().lstrip('&lt;').rstrip('&gt;')
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    # g.trace(setting,shortcut)
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting</t>
<t tx="ekr.20060128090219">def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    # g.trace(c.widget_name(w))
    
    if stroke: # New in 4.4a6:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)</t>
<t tx="ekr.20060128103640.1"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')</t>
<t tx="ekr.20060128103640.2">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)</t>
<t tx="ekr.20060128103640.4">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)
    
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])</t>
<t tx="ekr.20060129052538.1"></t>
<t tx="ekr.20060129052538.2">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler</t>
<t tx="ekr.20060131084938">def masterDoubleClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        i = w.index("@%d,%d" % (event.x,event.y))
        g.app.gui.setTextSelection(w,i+' wordstart',i+' wordend')
        return 'break'</t>
<t tx="ekr.20060201065809">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0</t>
<t tx="ekr.20060202235215.1"></t>
<t tx="ekr.20060203072636">def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')
    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20060204120158">def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        </t>
<t tx="ekr.20060204120158.1">def findAgainCommand (self):
    
    s = g.app.gui.getAllText(self.find_ctrl)
    
    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False</t>
<t tx="ekr.20060204120158.2">def findAgain (self,event):

    '''The find-again command is the same as the find-tab-find command
    if the search pattern in the Find tab is not '&lt;find pattern here&gt;'
    Otherwise, the find-again is the same as the search-with-present-options command.'''
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)</t>
<t tx="ekr.20060205105950">def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060205105950.1">def generalChangeHelper (self,find_pattern,change_pattern):
    
    # g.trace(repr(change_pattern))
    
    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()</t>
<t tx="ekr.20060205221734">def masterKeyHandlerHelper (self,event,stroke,trace):
    
    &lt;&lt; define vars &gt;&gt;

    if keysym in special_keys:
        return None

    &lt;&lt; do key traces &gt;&gt;

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;

    &lt;&lt; handle per-pane bindings &gt;&gt;
</t>
<t tx="ekr.20060209064140">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)</t>
<t tx="ekr.20060209064832">def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()</t>
<t tx="ekr.20060210164421">def addFindStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20060210173041">def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)
    
    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)</t>
<t tx="ekr.20060210174441">def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()</t>
<t tx="ekr.20060210180352">def addChangeStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.change_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()
    
    s = t.get('1.0','end')

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20060211093935">Add support for @list</t>
<t tx="ekr.20060214072931">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3575014

Actually, the run-unit-tests command first appeared in Leo 4.4, but it never got
properly announced.</t>
<t tx="ekr.20060215104239">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False</t>
<t tx="ekr.20060221074900"></t>
<t tx="ekr.20060221074900.1">def findButtonCallback(self,event=None):
    
    self.findButton()
    return 'break'</t>
<t tx="ekr.20060224104109">@nocolor

What I did:
    
- Used Python search code instead of Tkinter search.
- Allow \1, \2, etc. replacements in re searches.
- Allow \n and \t in plain searches.
- The shortcut for the replace-string command now changes from the find command to the replace command.


@color</t>
<t tx="ekr.20060224171851">def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)
        
def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)</t>
<t tx="ekr.20060309065445">def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False</t>
<t tx="ekr.20060321105403">k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')</t>
<t tx="ekr.20060321105403.1">self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace('keysym',repr(event.keysym or ''),'state',state)</t>
<t tx="ekr.20060321105403.2"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
    return 'break'</t>
<t tx="ekr.20060321105403.3">for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060417183606.1">def moveLinesUp (self,event):
    
    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = event.widget

    if not g.app.gui.hasSelection(w): return
    
    self.beginCommand(undoType='move-lines-up')
    
    i,j = g.app.gui.getSelectionRange(w)
    i = w.index(i+' linestart')
    j = w.index(j+' lineend+1c')
    i2 = w.index(i+'-1c linestart')
    selected = w.get(i,j) # ; g.trace('selected',repr(selected))
    moved = w.get(i2,i)   # ; g.trace('moved',repr(moved))

    if moved:
        w.mark_set('i',i)
        w.mark_set('j',j)
        w.delete(i2,i)
        if w.compare('j','==','end'):
            if moved.endswith('\n'): moved = moved[:-1]
            w.insert('j','\n' + moved)
        else:
            w.insert('j',moved)
        w.mark_unset('sel')
        w.mark_set('sel.start','i')
        w.mark_set('sel.end','j')
        w.mark_unset('i')
        w.mark_unset('j')
    elif g.app.gui.widget_name(w).startswith('body'):
        p = c.currentPosition()
        if not p.hasThreadBack(): return
        w.delete(i,j+'+1c')
        p.setBodyString(w.get('1.0','end'))
        p = p.threadBack()
        c.beginUpdate()
        c.selectPosition(p)
        c.endUpdate()
        w.focus_force()
        s = g.app.gui.getAllText(w)
        if s.endswith('\n'):
            w.insert('end',selected)
        else:
            if selected.endswith('\n'): selected = selected[:-1]
            w.insert('end','\n'+selected)
        g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-1c') # works

    self.endCommand(changed=True,setLabel=True)</t>
<t tx="ekr.20060417203717">def helpForCommand (self,event):
    
    '''Prompts for a command name and prints the help message for that command.'''
    
    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)
    
def helpForCommandFinisher (self,commandName):

    c = self.c
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
        g.es('%s:\n%s\n' % (commandName,s),color='blue')
    else:
        g.es('No help available for %s' % (commandName),color='blue')</t>
<t tx="ekr.20060419101401"></t>
<t tx="ekr.20060420144640">def iSearchBackspace (self):
    
    c = self.c ; k = self.k ; w = self.w
    
    b = self.stack.pop()
    g.trace(b.insert)

    c.selectPosition(b.p)
    w.mark_set('insert',b.insert)
    w.see('insert')
    w.update_idletasks()
    
    if self.stack:
        self.scolorizer(event=None,pattern=b.pattern)
    else:
        self.stack.append(b)
        w.tag_delete('color','color1')</t>
<t tx="ekr.20060512101324"></t>
<t tx="ekr.20060512101324.1">@nocolor

** Removed calls to update_idletasks in node selection logic.

update_idletasks interfere with the logic in the new colorizer that re-queues
the colorizer. What happens is that update_idletasks causes the queued
colorizerOneChunk method to be executed immediately, without looking to see if
any events are pending!  This can not, I think, be called a Tk bug.

- (in the colorizer) Used after instead of after_idle.

This can, I think, be called a Tk bug. It seems to me that any function queued
with after-idle should only be called a) as the result of update_idletasks (or
update) or when *no* events are pending.

In any event, the contrast between the slow colorizing code and scite's fast colorizer is breathtaking.</t>
<t tx="ekr.20060514164817">0.7 EKR: Fixed crasher in Leo 4.4 by initing self.p in Quickfind ctor.</t>
<t tx="ekr.20060514164817.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3729858
By: ejoy

Hi,
  I got the following error message when trying search using the searchbox plugin
with 4.4 final:

Error: 4
AttributeError Exception in Tk callback
  Function: &lt;function callit at 0x013011F0&gt; (type: &lt;type 'function'&gt;)
  Args: ()
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line
1752, in __call__
    None
  File "C:\Python24\lib\lib-tk\Tkinter.py", line 456, in callit
    func(*args)
  File "C:\Program Files\Leo\plugins\searchbox.py", line 173, in doSearch
    c.findNext()
  File "C:\Program Files\Leo\src\leoCommands.py", line 2812, in findNext
    c.frame.findPanel.findNextCommand(c)
  File "C:\Program Files\Leo\src\leoFind.py", line 311, in findNextCommand
    self.findNext()
  File "C:\Program Files\Leo\src\leoFind.py", line 661, in findNext
    data = self.save()
  File "C:\Program Files\Leo\src\leoFind.py", line 1020, in save
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
AttributeError: 'NoneType' object has no attribute 'edit_widget'

Hope this will be fixed soon.
Cheers,
ejoy
</t>
<t tx="ekr.20060514170725"></t>
<t tx="ekr.20060514170854"></t>
<t tx="ekr.20060515060803"># Added support for @bool idle_redraw setting.</t>
<t tx="ekr.20060515060803.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3729823
By: nobody

I am running Ubuntu 5.10 and have the same (I think) problem - this is with
the 4.4 final release.

When I move through nodes using the alt-XXX short cuts, there is a lot of flicker
as nodes are redrawn etc. I had no problem with this in 4.3.</t>
<t tx="ekr.20060519003651">def debug (self,event=None,target = None):
    
    '''Start an external debugger in another process.'''

    c = self.c ; p = c.currentPosition()
    pythonDir = g.os_path_dirname(sys.executable)
    
    &lt;&lt; find a debugger or return &gt;&gt;
    &lt;&lt; find the target file &gt;&gt;
    
    if target:
        args = [sys.executable, debugger, '-t', target]
    else:
        args = [sys.executable, debugger, '-t']
    
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, sys.executable, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)</t>
<t tx="ekr.20060519003651.1"></t>
<t tx="ekr.20060521140213">debuggers = (
    c.config.getString('debugger_path'),
    g.os_path_join(pythonDir,'scripts','_winpdb.py'),
)

for debugger in debuggers:
    if debugger:
        debugger = g.os_path_abspath(debugger)
        if g.os_path_exists(debugger):
            break
        else:
            g.es('Debugger does not exist: %s' % (debugger),color='blue')
else:
    return g.es('No debugger found.')</t>
<t tx="ekr.20060521140213.1">targets = (
    target,
    c.config.getString('debugger_force_taget'),
    p.copy().anyAtFileNodeName(),
    c.config.getString('debugger_default_target'),
)

for target in targets:
    if target:
        target = g.os_path_abspath(target)
        if g.os_path_exists(target):
            break
        else:
            g.es('Debug target does not exist: %s' % (target),color='blue')</t>
<t tx="ekr.20060522082833"></t>
<t tx="ekr.20060522083716"></t>
<t tx="ekr.20060522101202">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3737879

The "Check Bindings" button gave the following report.

-------------------------------------------------
No bindings is missing run-unit-test                       = None
Undefined command name: add-spaces-to-lines
Undefined command name: clean-line
Undefined command name: remove-spaces-from-lines
Undefined command name: remove-tab-from-lines
Undefined command name: run-unit-test
Check Bindings done
-------------------------------------------------</t>
<t tx="ekr.20060522102610">pythonDir = g.os_path_dirname(sys.executable)
idle = g.os_path_join(pythonDir,'Lib','idlelib','idle.py')
args = [sys.executable, idle ]

if 1: # Use present environment.
    os.spawnv(os.P_NOWAIT, sys.executable, args)
else: # Use a pristine environment.
    os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
</t>
<t tx="ekr.20060522103446"></t>
<t tx="ekr.20060526081931">def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word):
    
    if backwards: i,j = j,i
        
    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1
        
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,backwards,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,backwards,nocase,word)

    return pos,newpos
</t>
<t tx="ekr.20060526092203">def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        return k, k2</t>
<t tx="ekr.20060526093531">def plainHelper (self,s,i,j,pattern,backwards,nocase,word):
    
    # g.trace(repr(s[i:i+20]))
    
    n = len(pattern)
    if nocase:
        s = s.lower() ; pattern.lower()
        pattern = pattern.replace('\\n','\n').replace('\\t','\t')

    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n</t>
<t tx="ekr.20060526140328">if self.wrapping and self.wrapPos and self.wrapPosition and self.p == self.wrapPosition:

    if self.reverse and gui.compareIndices(w,pos, "&lt;", self.wrapPos):
        # g.trace("wrap done")
        return None, None

    if not self.reverse and gui.compareIndices(w,newpos, "&gt;", self.wrapPos):
        return None, None</t>
<t tx="ekr.20060526140744">def backwardsHelper (self,s,i,j,pattern,backwards,nocase,word):

    # g.trace(repr(s[i-20: i]))

    if nocase:
        s = s.lower() ; pattern.lower()

    if word:
        n = len(pattern)
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return max(0,k-n+1),k+1, 
            else:
                j = max(0,k-n)
    else:
        k = s.rfind(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return max(0,k-n+1),k+1, </t>
<t tx="ekr.20060526140744.1">def matchWord(self,s,i,pattern):
    
    return g.match_word(s,i,pattern) and (i == 0 or s[i-1] not in self.word_chars)</t>
<t tx="ekr.20060526201951">def makeRegexSubs(self,s,groups):
    
    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''
    
    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j &lt; n:
        k = s.find('\\',j)
        if k == -1 or k + 1 &gt;= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn &lt; len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)</t>
<t tx="ekr.20060527065935"></t>
<t tx="ekr.20060527065935.1"></t>
<t tx="ekr.20060527182907">@nocolor

The add-editor command adds a new editor, the delete-editor command deletes the presently selected editor, and the cycle-editor-focus command cycles focus between editors in the body text.

The leftmost editor has no label: it always shows the body text of the presently selected node.  All other editors have a label showing the node to which it applies.

All editors are 'live' at all times: changing an editor changes the corresponding node. All editors are syntax colored properly at all times.

A small quirk.  Selecting an editor will not show the corresponding node if the node is not visible in a hoist.  This is probably different from how the chapters plugin worked.  It would be easy enough to change the code to de-hoist as necessary, but I'm not sure that is really what is desired.  Tell me if you care one way or another.

@color</t>
<t tx="ekr.20060527190049"></t>
<t tx="ekr.20060528100747"></t>
<t tx="ekr.20060528100747.1">def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    self.numberOfEditors += 1
    name = '%d' % self.numberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    &lt;&lt; create label and text widgets &gt;&gt;
    
    self.editorWidgets[name] = w
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()</t>
<t tx="ekr.20060528100747.3">def createTextWidget (self,frame,parentFrame,name,p):
    
    c = self.c

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    body.leo_pane_name = name
    body.leo_v = p and p.v
        
    def focusInCallback(event,self=self,w=body):
        self.onFocusIn(w)
    body.bind('&lt;FocusIn&gt;',focusInCallback)

    return body</t>
<t tx="ekr.20060528104554">def onFocusIn(self,w):
    
    c = self.c ; p = None

    # Get the ivars from the ivars injected into w.
    self.editor_name = hasattr(w,'leo_pane_name') and w.leo_pane_name or None
    self.editor_v = v = hasattr(w,'leo_v')         and w.leo_v         or None
    # g.trace(w,v)
    
    if not v:
        # We are selecting the main editor, so nothing actually changes.
        self.bodyCtrl = w
        c.frame.bodyWantsFocus()
        return
    
    for p in c.allNodes_iter():
        if p.v == v:
            c.selectPosition(p, updateBeadList=True)
            self.bodyCtrl = w # This may be changed by c.selectPosition
            c.frame.bodyWantsFocus()
            break
    else:
        g.trace("Can't happen",p)</t>
<t tx="ekr.20060528110922">f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

label = Tk.Label(f,text= p.headString(),bg='LightSteelBlue1')
label.pack(side='top')

text = Tk.Frame(f)
text.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,text,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

# Temporarily make this the 'real' text widget so we can color it.
old_w = self.bodyCtrl
self.bodyCtrl = w
c.recolor_now()
self.bodyCtrl = old_w

# Disable this editor.
# Eventually, we should allow edits here.
# w.configure(state='disabled')</t>
<t tx="ekr.20060528113806">def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    name = self.editor_name

    if not name:
        g.es('Can not delete the main body editor',color='blue')
        return
        
    del self.editorWidgets [name]

    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    self.selectMainEditor()</t>
<t tx="ekr.20060528131618">def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.
    w_main = d.get(None)

    for key in d.keys():
        w = d.get(key)
        if w == self.bodyCtrl: continue
        v = w.leo_v
        if v == p.v or w == w_main:
            # g.trace('update',v,w)
            # Temporarily make this the 'real' text widget so we can color it.
            old_w = self.bodyCtrl
            self.bodyCtrl = w
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            c.recolor_now()
            self.bodyCtrl = old_w
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060528132829">def selectMainEditor (self):
    
    c = self.c

    w = self.editorWidgets.get(None)
    self.bodyCtrl = w
    c.recolor_now()</t>
<t tx="ekr.20060528170438">def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets
    keys = d.keys() ; n = len(keys)
    if n &lt; 2: return # There is only the main widget. 

    i = 0
    for key in d.keys():
        i += 1
        w = d.get(key)
        if w == self.bodyCtrl:
            if i &gt;= n: i = 0
            self.bodyCtrl = w = d.get(keys[i])
            g.app.gui.set_focus(c, w)
            return</t>
<t tx="ekr.20060528172956">def toGuiIndex (self,s,w,index):
    
    '''Convert a python index in string s into a Tk index in Tk.Text widget w.'''
    
    # A subtle point: s typically does not have Tk's trailing newline, so add it.

    row,col = g.convertPythonIndexToRowCol (s+'\n',index)
    index = w.index('%s.%s' % (row+1,col))
    return index
    
def toPythonIndex (self,s,w,index):
    
    '''Convert a Tk index in Tk.Text widget w into a python index in string s.'''
    
    index = w.index(index)
    row, col = index.split('.') ; row, col = int(row), int(col)
    index = g.convertRowColToPythonIndex (s,row-1,col)
    return index</t>
<t tx="ekr.20060528173539"></t>
<t tx="ekr.20060529083409"></t>
<t tx="ekr.20060529091202"></t>
<t tx="ekr.20060529091202.1"></t>
<t tx="ekr.20060529092645">def selectAllText (self,w,insert='end-1c'):
    
    '''Select all text of the widget, *not* including the extra newline.'''
    
    self.setTextSelection(w,'1.0','end-1c',insert=insert)</t>
<t tx="ekr.20060529130603"></t>
<t tx="ekr.20060529130603.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3737745
By: nobody

From: Rich
Installed Leo 4.4 final using Windows Installer (exe)
Ran using a Command Window
-------------------------------------------------
Setup:
Leo Log Window...
Leo 4.4 final, build  1.10 , May 11, 2006
Python 2.3.4, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 1

leoID = xxxx (in C:\Software Engineering\Leo\config)
global config dir: C:\Software Engineering\Leo\config
home dir: None
reading settings in C:\Software Engineering\Leo\config\leoSettings.leo
6 plugins loaded
-------------------------------------------------
Plugins Activated:
Add_directives
Chapter Hoist
Cleo 
Color_markup
GroupOps
Labels
Macros
Nav_buttons
NewButtons
NodeNavigator
OpenWith
RClick
Scripting
TimeStamp
UniversalScrolling
UNL
-------------------------------------------------
Log Window Messages after exiting Plugiin Mgr.:
Sending 'start1' to 'add_directives'
Sending 'scan-directives' to 'add_directives'
Failed to dynamically enable 'add_directives': 'NoneType' object has no attribute
'has_key'
Sending 'new' to 'chapter_hoist'
Failed to dynamically enable 'chapter_hoist': 'Bunch' object has no attribute
'frame'
Sending 'new' to 'cleo'
Failed to dynamically enable 'cleo': 'Bunch' object has no attribute 'frame'
Sending 'init-color-markup' to 'color_markup'
Failed to dynamically enable 'color_markup': 'NoneType' object has no attribute
'c'
Sending 'new' to 'groupOperations'
Failed to dynamically enable 'groupOperations': 'Bunch' object has no attribute
'exists'
Sending 'before-create-leo-frame' to 'mod_labels'
Failed to dynamically enable 'mod_labels': 'Bunch' object has no attribute
'frame'
Sending 'after-create-leo-frame' to 'leoupdate'
Failed to dynamically enable 'leoupdate': 'Bunch' object has no attribute
'frame'
Sending 'new' to 'macros'
Failed to dynamically enable 'macros': 'Bunch' object has no attribute 'frame'
Sending 'after-create-leo-frame' to 'nav_buttons'
Failed to dynamically enable 'nav_buttons': 'Bunch' object has no attribute
'mFileName'
Sending 'after-create-leo-frame' to 'newButtons'
Failed to dynamically enable 'newButtons': 'Bunch' object has no attribute
'frame'
Sending 'new' to 'nodenavigator'
Failed to dynamically enable 'nodenavigator': 'Bunch' object has no attribute
'frame'
Sending 'after-create-leo-frame' to 'rClick'
Failed to dynamically enable 'rClick': 'Bunch' object has no attribute 'exists'
Failed to dynamically enable 'mod_timestamp': 'Bunch' object has no attribute
'frame'
Failed to dynamically enable 'UniversalScrolling': 'Bunch' object has no attribute
'frame'
-------------------------------------------------

Exited Leo, re-entered.

-------------------------------------------------
Leo Log Window:
Leo Log Window...
Leo 4.4 final, build  1.10 , May 11, 2006
Python 2.3.4, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 1

leoID = xxxx (in C:\Software Engineering\Leo\config)
global config dir: C:\Software Engineering\Leo\config
home dir: None
reading settings in C:\Software Engineering\Leo\config\leoSettings.leo
can not load enabled chapter_hoist plugin
18 plugins loaded

-------------------------------------------------
Tested Plugins:
Chapter Hoist: Not loaded. (Needs mod_scripting 0.19 ??)

Cleo: Collapsing a Cleo'd node leaves the colored priority arrows - may need
to add the Wipe-out trick used to remove arrows? (Node coloring works OK.

Color Markup (wiki): Works as advertised.

Group Operations: Works as expected. I still prefer the older key-based method,
or some way to mark a number of nodes with just a couple of mouse clicks. This
one-at-a-tiime-deal is a PITA! (I know Group Ops aren't really being supported,
but I'll  still make my comments!)

Labels: Works OK. A way to see (a) labelled nodes and (b) the node's labels
without going through the menu would be "wunnerful, wunnerful."

Macros: Instructions for use??
I tried selecting a node and Outline--&gt; Parameterize Section Reference

Log Window Showed:
-------------------------------------------------
exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
TypeError: parameterize() takes exactly 1 argument (2 given)
-------------------------------------------------

Nav Buttons: Still work. (I still prefer Up-and-Down rather than Left-and-Right
buttons.)

New Buttons: Works as guessed-at. More info would be nice.

Node Navigator: This should be marked as being already built into Leo.

Open With: Desparately needs a way to modify the Open-With menu other than going
in and changing the code.

RClick: OK, but I use a different command set. See comment for Open-With

Time Stamp: "Timestamp all save operations to show when they occur" gave me
the impression that a file would be created with a timestamp. Having it just
pop up in the Log window (when I can look at my watch) is rather useless.

Universal Scrolling: There's a conflict with a Config setting which should be
mentioned in the U.S. info box.

UNL: I followed the directions, but all clickiing on "@url Test UNL--&gt;Test UNL
Node" got me was a DOS box that had tried to open "Test". Trying '@url
file:"c:\Software Engineering\Test\Test My Plugins.leo#Test UNL--&gt;Test UNL Node"'
didn't work, either.
=================================================

Suggestion: All untested Plugins should be marked as such in the Plugin Manager,
ESPECIALLY if Leo is to go "Big Time."
</t>
<t tx="ekr.20060529161541">('.*'):(.*)(self.*),
(\1,\2\3),


 '
('xxx',    '

':.*
'),</t>
<t tx="ekr.20060529170949">def defineCmdsMenuHelpTable (self):

    c = self.c

    self.cmdsMenuHelpTable = [
        ('&amp;Getting Started',         'help'),
        ('&amp;Help For Command',        'help-for-command'),
        ('-', None),
        ('Apropos &amp;Autocompletion',  'apropos-autocompletion'),
        ('Apropos &amp;Bindings',        'apropos-bindings'),
        ('Apropos &amp;Find Commands',   'apropos-find-commands'),
    ]</t>
<t tx="ekr.20060529175453">It is now clearer what the selected values are.</t>
<t tx="ekr.20060529195042"># No docstring yet...
            dabbrev-completion dynamicExpansion2
               dabbrev-expands dynamicExpansion
                        escape watchEscape
                number-command numberCommand
              set-mark-command setRegion</t>
<t tx="ekr.20060529230636"></t>
<t tx="ekr.20060530084936">if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('Ignoring invalid key binding: %s = %s' % (
                commandName,shortcut),color='blue')
            return</t>
<t tx="ekr.20060530100259">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3756402
By: ktenney

auto-indent doesn't work in the extra editors.

@color</t>
</tnodes>
</leo_file>
