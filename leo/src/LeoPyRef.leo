<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="51" left="342" height="819" width="857"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240" str_leo_pos="9"><vh>Buttons &amp; commands</vh>
<v t="ekr.20060531093331"><vh>@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20060908104329"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20041005105605.198,ekr.20061028070057.22,ekr.20061028070057.37,ekr.20061028070057.54,ekr.20061028070057.55,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20050920084036.138,ekr.20051126124705,ekr.20060216163305,"
expanded="ekr.20061028065955,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"
marks="ekr.20040701065235.2,"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20061028065955"><vh>To do first</vh>
<v t="ekr.20061028085127"><vh>Only disable pychecker import warnings for imports that actually generate the warnings</vh></v>
<v t="ekr.20061028065955.1"><vh>Switch to new-style positions</vh></v>
<v t="ekr.20060915175024"><vh>Maintain vertical node position if possible</vh></v>
<v t="ekr.20061022190904"><vh>use g.globalDirectiveDict rather than leoColor.leoKeywords in at.directiveKind4</vh></v>
<v t="ekr.20061028065955.2"><vh>Fix binding nits</vh>
<v t="ekr.20061014050154.2"><vh>Binding to None clears all bindings</vh></v>
<v t="ekr.20060927173836.6"><vh>Don't abort mode if there are problems with bindings</vh></v>
<v t="ekr.20061015160449"><vh>log font size setting in myLeoSettings.leo are not overriding previous settings</vh></v>
</v>
<v t="ekr.20061020155051"><vh>Simplify and fix undo</vh>
<v t="ekr.20061020155051.1"><vh>Notes</vh></v>
<v t="ekr.20061009152210.1"><vh>yank/kill/undo do not work as expected</vh>
<v t="ekr.20061020080610"><vh>How to reproduce undo bug</vh></v>
<v t="ekr.20050920084036.174"><vh>killBufferCommandsClass (add docstrings)</vh>
<v t="ekr.20050920084036.175"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20050920084036.176"><vh> getPublicCommands</vh></v>
<v t="ekr.20050920084036.183"><vh>addToKillBuffer</vh></v>
<v t="ekr.20050920084036.181"><vh>backwardKillSentence</vh></v>
<v t="ekr.20050920084036.180"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20051216151811"><vh>clearKillRing</vh></v>
<v t="ekr.20050920084036.185"><vh>getClipboard</vh></v>
<v t="ekr.20050920084036.184"><vh>iterateKillBuffer</vh></v>
<v t="ekr.20050920084036.178"><vh>kill, killLine</vh></v>
<v t="ekr.20050920084036.182"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20050930095323.1"><vh>killSentence</vh></v>
<v t="ekr.20050930100733"><vh>killWs</vh></v>
<v t="ekr.20050930091642.1"><vh>yank</vh></v>
<v t="ekr.20050930091642.2"><vh>yankPop</vh></v>
<v t="ekr.20050920084036.128"><vh>zapToCharacter</vh></v>
</v>
<v t="EKR.20040526090701.4"><vh>undoTyping</vh></v>
<v t="EKR.20040526075238.5"><vh>redoTyping</vh></v>
<v t="ekr.20031218072017.1493"><vh>undoRedoText</vh>
<v t="ekr.20031218072017.1494"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1495"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1496"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1497"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2406" a="TV"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="2858060000006c6162656c737100540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571017471022e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"
marks="ekr.20041005105605.52,ekr.20041005105605.198,"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"
marks="ekr.20031218072017.1607,ekr.20031218072017.1896,ekr.20031218072017.2803,"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20050920084036.138,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"
marks="ekr.20060919110638.44,ekr.20040701065235.2,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"
marks="ekr.20031218072017.3132,ekr.20031218072017.3124,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"
marks="ekr.20051126124705,ekr.20060216163305,ekr.20060606095344,"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"
marks="ekr.20031218072017.3419,ekr.20031218072017.3421,ekr.20031218072017.3426,ekr.20031218072017.3438,ekr.20040303214038,ekr.20040303163330,ekr.20040303175026.2,ekr.20040303175026.3,ekr.20040303175026.5,ekr.20040303175026.10,ekr.20040306060312,ekr.20040303175026.11,ekr.20040310062332.4,ekr.20040310062332.5,"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20031218072017.3446"
marks="ekr.20031218072017.3601,"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"
marks="ekr.20051113110851,"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"
marks="ekr.20050921103736,ekr.20031218072017.3803,"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"
marks="ekr.20060211144330.1,"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040526075238.5">def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
        
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()
    
    if u.newSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="EKR.20040526090701.4">def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="ekr.20031218072017.840"></t>
<t tx="ekr.20031218072017.1493">def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.
    
    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; body = c.frame.body
    &lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
    &lt;&lt; Compute the result using p's body text &gt;&gt;
    p.setTnodeText(result)
    &lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
    if textResult == result:
        c.frame.body.recolor(p,incremental=False)
    else: # Rewrite the pane and do a full recolor.
        if 0: # Warning: can cause unit tests to fail if text contains unicode.
            &lt;&lt; print mismatch trace &gt;&gt;
        c.setBodyString(p,result)
</t>
<t tx="ekr.20031218072017.1494"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading &gt; 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len &gt; 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading &gt; 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines &gt; oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines &gt; newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
</t>
<t tx="ekr.20031218072017.1495"># Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
</t>
<t tx="ekr.20031218072017.1496">textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) &gt; 0 and textResult[:-1] == result:
        textResult = result
</t>
<t tx="ekr.20031218072017.1497">print "undo mismatch"
print "expected:",result
print "actual  :",textResult
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"
</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4.2.1 final, build %s, October 27, 2006" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.
</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050920084036.128">def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        c = k.c
        ch = event and event.char
        k.resetLabel()
        k.clearState()
        if len(event.char) != 0 and not ch.isspace():
            i = w.search(ch,'insert',stopindex='end')
            if i != -1:
                s = w.get('insert','%s' % i)
                self.addToKillBuffer(s)
                w.delete('insert','%s' % i)
</t>
<t tx="ekr.20050920084036.174">class killBufferCommandsClass (baseEditCommandsClass):
    
    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20050920084036.175">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):
    
    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
    
    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20050920084036.176">def getPublicCommands (self):
    
    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20050920084036.178">def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    w.delete(frm,to)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    self.kill(event,'insert linestart','insert lineend+1c',undoType='kill-line')</t>
<t tx="ekr.20050920084036.180">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20050920084036.181">def backwardKillSentence (self,event):
    
    '''Kill the previous sentence.'''
    
    w = self.editWidget(event)
    if not w: return

    i = w.search('.','insert',backwards=True,stopindex='1.0')

    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='backward-kill-sentence')
</t>
<t tx="ekr.20050920084036.182">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return
    
    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20050920084036.183">def addToKillBuffer (self,text):
    
    killKeys =(
        '&lt;Control-k&gt;', '&lt;Control-w&gt;',
        '&lt;Alt-d&gt;', '&lt;Alt-Delete', '&lt;Alt-z&gt;', '&lt;Delete&gt;',
        '&lt;Control-Alt-w&gt;')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20050920084036.184">def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
</t>
<t tx="ekr.20050920084036.185">def getClipboard (self,w):

    try:
        ctxt = w.selection_get(selection='CLIPBOARD')
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except: pass

    return None
</t>
<t tx="ekr.20050930091642.1">def yank (self,event):
    
    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050930091642.2">def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert') ; t, t1 = i.split('.')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        if clip_text: s = clip_text
        else:         s = self.kbiterator.next()
        t1 = str(int(t1)+len(s))
        r = w.tag_ranges('kb')
        if r and r [0] == i:
            w.delete(r[0],r[-1])
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
</t>
<t tx="ekr.20050930095323.1">def killSentence (self,event):
    
    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return

    i  = w.search('.','insert',stopindex='end')
    if i:
        self.beginCommand(undoType='kill-sentence')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='kill-sentence')
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050930100733">def killWs (self,event,undoType=None):
    
    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break
   
    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20051011072049.2">def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = g.app.gui.getAllText(w)
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s=g.app.gui.getAllText(w)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20051011072903.2">def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
</t>
<t tx="ekr.20051011072903.5">def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = g.app.gui.getTextSelection(w)  # Returns insert point if no selection.
    oldText = w.get('1.0','end')
    
    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)
    
    if middleButton and c.k.previousSelection:
        start,end = c.k.previousSelection
        s = w.get(start,end)
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051216151811">def clearKillRing (self,event=None):
    
    '''Clear the kill ring.'''
    
    self.killBuffer = []
</t>
<t tx="ekr.20060217111834">.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:
    
copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060908104329"></t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060915175024">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3916155

When a node is among several other nodes at the same level of hierarchy, which
are all children of a node, and the "MOVE LFET" command is executed, the node
does move left in the outline hierarchy, but it also move down to just before
the next node at the higher hierarchy level - the level to which it is moving
left.</t>
<t tx="ekr.20060927173836.6"></t>
<t tx="ekr.20061009152210.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3924236

Added unit tests for yank and all kill commands.

@color</t>
<t tx="ekr.20061014050154.2"></t>
<t tx="ekr.20061015160449"></t>
<t tx="ekr.20061020080610">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3972170
By: oculog

Step 1 - add some lines...
line 1
line 2
line 3

Step 2 - cut and paste first line to the end
line 2
line 3
line 1

Step 3 - *Copy* and paste first line to the end x2
line 2
line 3
line 1
line 2
line 2

That's it!  The fourth undo doesn't work right.
</t>
<t tx="ekr.20061020155051"></t>
<t tx="ekr.20061020155051.1">@nocolor

Several things became clearer after a short walk in the woods:

- It's a little late in the release cycle to mess with undo, so I'm going to put
off work until Leo 4.4.3. The present code is complex, and should be simplified
if possible. However, the potential for harm is too great to make substantial
change now. Given the complexity of the code, *any* change is a substantial
change :-)

- Some problems with undo may actually be just unexpected results. In
particular, undo typing should 'coalesce', only for actual typing: all other
commands that affect body text (cut, copy, yank and kill in particular) should
be independently undoable regardless of undo granularity. Thus, if you cut,
copy, yank or kill text an immediate undo command should restore the text to
what it was before those commands. This probably doesn't happen now, and that
could be the source of some (all??) undo problems.

Edward

P.S. I recently uncovered some more hard bindings in the yank command. Such
bindings must somehow be removed, and certainly are a symptom that yank does not
yet work as in Emacs. This is a separate issue from undo, so discovering this
problem actually simplifies the undo task to come.
</t>
<t tx="ekr.20061022190904">@nocolor

Having two lists for the same thing is very bad.
When this is fixed we will be able to simplify the multifile plugin.</t>
<t tx="ekr.20061028065955"></t>
<t tx="ekr.20061028065955.1">An experimental, potentially risky, project, but well worth doing.</t>
<t tx="ekr.20061028065955.2"></t>
<t tx="ekr.20061028085127"></t>
</tnodes>
</leo_file>
