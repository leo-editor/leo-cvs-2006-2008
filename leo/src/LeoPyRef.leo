<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="9381" clone_windows="0"/>
<globals body_outline_ratio="0.715460526316">
	<global_window_position top="9" left="108" height="922" width="1086"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20060203112912.1"><vh>Initing</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3941"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20031218072017.1801"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20031218072017.1802"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3942"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20041221122440"><vh>f.component &amp; components</vh></v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20051121092320"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20041221071131.1"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050119210541"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221071131"><vh>createPmwTreeCanvas (not used)</vh></v>
</v>
<v t="ekr.20041221123325"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20041223130032"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20041221195402"><vh>Pmw...</vh>
<v t="ekr.20041221073427"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20031218072017.3946"><vh>resizePanesToRatio</vh>
<v t="ekr.20050104084531"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221075743"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20041221185246"><vh>Tk...</vh>
<v t="ekr.20041221073427.1"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20031218072017.3947"><vh>bindBar</vh></v>
<v t="ekr.20031218072017.3949"><vh>divideAnySplitter</vh></v>
<v t="ekr.20031218072017.3950"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20031218072017.3951"><vh>onDrag...</vh></v>
<v t="ekr.20031218072017.3952"><vh>placeSplitter</vh></v>
<v t="ekr.20031218072017.998"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3964"><vh>Destroying the frame</vh>
<v t="ekr.20031218072017.1975"><vh>destroyAllObjects</vh>
<v t="ekr.20031218072017.1976"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3965"><vh>destroyAllPanels</vh></v>
<v t="ekr.20031218072017.1974"><vh>destroySelf (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
</v>
<v t="ekr.20060306070425"><vh>4.4 b3 projects</vh>
<v t="ekr.20060323131536"><vh>New features</vh>
<v t="ekr.20060307234849"><vh>Addded outline-scroll commands</vh>
<v t="ekr.20060309060654.1"><vh>scrollOutlineUp/Down/Line/Page</vh></v>
</v>
<v t="ekr.20060307080642.1"><vh>Added some balloons to the tree pane</vh>
<v t="ekr.20060307080642"><vh>&lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</vh></v>
<v t="ekr.20040803072955.11"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20050618045715"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.8"><vh>newClickBox</vh></v>
<v t="ekr.20040803072955.52"><vh>drawTopTree</vh></v>
</v>
<v t="ekr.20060306200304.1"><vh>Added scroll outline pane commands</vh></v>
<v t="ekr.20060325093414"><vh>Improved registerCommand</vh>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
<v t="ekr.20051015110547"><vh>k.registerCommand</vh>
<v t="ekr.20060325110412"><vh>registerBinding</vh></v>
</v>
</v>
<v t="ekr.20060228071700"><vh>Suppressed autocompletion after numbers</vh></v>
<v t="ekr.20060227120635"><vh>Added Lua patch</vh>
<v t="ekr.20060328110802.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.367"><vh>How to add support for a new language</vh>
<v t="EKR.20040623090054"><vh>&lt;&lt; define global colorizer data &gt;&gt;</vh></v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="ekr.20031218072017.370"><vh>&lt;&lt; configure language-specific settings &gt;&gt; colorizer</vh></v>
<v t="ekr.20031218072017.371"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="ekr.20031218072017.372"><vh>actionscript keywords</vh></v>
<v t="bwmulder.20041023131509"><vh>ada keywords</vh></v>
<v t="ekr.20040206072057"><vh>c# keywords</vh></v>
<v t="ekr.20031218072017.373"><vh>c/c++ keywords</vh></v>
<v t="ekr.20040401103539"><vh>css keywords</vh></v>
<v t="ekr.20031218072017.374"><vh>elisp keywords</vh></v>
<v t="ekr.20041107093834"><vh>forth keywords</vh></v>
<v t="ekr.20031218072017.375"><vh>html keywords</vh></v>
<v t="ekr.20031218072017.376"><vh>java keywords</vh></v>
<v t="ekr.20031218072017.377"><vh>latex keywords</vh></v>
<v t="ekr.20060328110802"><vh>lua keywords</vh></v>
<v t="ekr.20031218072017.378"><vh>pascal keywords</vh></v>
<v t="ekr.20031218072017.379"><vh>perl keywords</vh></v>
<v t="ekr.20031218072017.380"><vh>php keywords</vh></v>
<v t="ekr.20050618052653"><vh>plsql keywords</vh></v>
<v t="ekr.20031218072017.381"><vh>python keywords</vh></v>
<v t="ekr.20040331145826"><vh>rapidq keywords</vh></v>
<v t="ekr.20031218072017.382"><vh>rebol keywords</vh></v>
<v t="ekr.20040401111125"><vh>shell keywords</vh></v>
<v t="ekr.20031218072017.383"><vh>tcl/tk keywords</vh></v>
</v>
<v t="ekr.20050618052621"><vh>Add the language name to @language default_target_language entry in leoSettings.leo</vh></v>
</v>
<v t="ekr.20031218072017.1809"><vh>importDerivedFile</vh></v>
</v>
<v t="ekr.20060328121145.1"><vh>Added run-unit-test command</vh>
<v t="ekr.20060328121145"><vh>runUnitTest</vh></v>
</v>
</v>
<v t="ekr.20060323131536.1"><vh>Bugs</vh>
<v t="ekr.20060309022225"><vh>Fixed problem with left &amp; right arrows in outline mode</vh>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh>
<v t="ekr.20060321105403"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20060321105403.1"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20060321105403.2"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20060321105403.3"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
</v>
<v t="ekr.20060309065445"><vh>handleMiniBindings</vh></v>
</v>
</v>
<v t="ekr.20060321094013"><vh>Made Control-v work again in find command</vh>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh>
<v t="ekr.20060321105403"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20060321105403.1"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20060321105403.2"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20060321105403.3"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
</v>
<v t="ekr.20060309065445"><vh>handleMiniBindings</vh></v>
</v>
</v>
<v t="ekr.20060320113137"><vh>Fixed undo problem with clones</vh>
<v t="ekr.20060320113137.2"><vh>Report</vh></v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20051026143009"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20031218072017.1762"><vh>c.clone</vh></v>
<v t="ekr.20050412084055"><vh>undoDeleteNode</vh></v>
<v t="EKR.20040526090701.4"><vh>undoTyping</vh></v>
<v t="ekr.20050412083057"><vh>redoCloneNode</vh></v>
<v t="ekr.20050412083057.1"><vh>undoCloneNode</vh></v>
<v t="EKR.20040526075238.5"><vh>redoTyping</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
</v>
<v t="ekr.20031218072017.1490"><vh>setUndoTypingParams</vh>
<v t="ekr.20040324061854"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20040324061854.1"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1491"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1492"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20040324061854.2"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20040324061854.3"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20050125220613"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20050125203937"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060321140706"><vh>Investigated setting descendant @file nodes dirty when changing body text</vh>
<v t="ekr.20060323085310"><vh>Report</vh></v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20051026143009"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20031218072017.1490"><vh>setUndoTypingParams</vh>
<v t="ekr.20040324061854"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20040324061854.1"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1491"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1492"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20040324061854.2"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20040324061854.3"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20050125220613"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20050125203937"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060306193836"><vh>Work around newline problems on the Mac</vh>
<v t="ekr.20060323095532"><vh>Report</vh></v>
<v t="ekr.20050920084036.85"><vh>insert &amp; delete...</vh>
<v t="ekr.20051026092433.1"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.87"><vh>deleteNextChar</vh></v>
<v t="ekr.20050920084036.135"><vh>deleteSpaces</vh></v>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20050920084036.138"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20050920084036.86"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20050920084036.139"><vh>insertParentheses</vh></v>
<v t="ekr.20051125080855"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
</v>
</v>
<v t="ekr.20060321111639"><vh>Got rid of settings messages</vh>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060216110502"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20041121143823"><vh>getValFromDict</vh></v>
</v>
<v t="ekr.20060323110223"><vh>Clicks outside minibuffer no longer rip focus</vh>
<v t="ekr.20060129052538.2"><vh>masterClickHandler</vh></v>
<v t="ekr.20050920085536.63"><vh>keyboardQuit</vh></v>
</v>
<v t="ekr.20060321080150.6"><vh>Handled missing leoSettings.leo files more gracefully</vh>
<v t="ekr.20060323132048"><vh>Report</vh></v>
<v t="ekr.20060323134459"><vh>What I did</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20051008152134"><vh>initSpecialIvars</vh></v>
<v t="ekr.20041118104831.2"><vh>configSettings.__init__</vh>
<v t="ekr.20041118104240"><vh>initIvar</vh></v>
<v t="ekr.20041118104414"><vh>initEncoding</vh></v>
</v>
</v>
<v t="ekr.20060309132452"><vh>Converted all shortcuts to unicode</vh>
<v t="ekr.20060324065958"><vh>What I did</vh></v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20051026143009"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20031218072017.4091"><vh>g.app.gui.getAllText</vh></v>
<v t="ekr.20060323194410"><vh>Found: g.safeStringCompare</vh>
<v t="ekr.20051026143009"><vh>removeTrailingNewlines</vh></v>
<v t="ekr.20051125080855"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
</v>
<v t="ekr.20041117062717.14"><vh>getShortcut (config)</vh></v>
<v t="ekr.20060128081317"><vh>shortcutFromSetting</vh>
<v t="ekr.20060201065809"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060215104239"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060128103640.1"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060128103640.2"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060128103640.4"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060306193910"><vh>Made Open With shortcuts work again</vh>
<v t="ekr.20060324080104"><vh>Report</vh></v>
<v t="ekr.20060216074643"><vh>k.completeAllBindings &amp; helpers</vh>
<v t="ekr.20060221141535"><vh>completeAllBindingsForWidget</vh></v>
<v t="ekr.20060324092758"><vh>completeOneBindingForWidget</vh></v>
</v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060216110502"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4116"><vh>createOpenWithMenuFromTable &amp; helper</vh>
<v t="ekr.20051022043608.1"><vh>createOpenWithMenuItemsFromTable</vh>
<v t="ekr.20051022043713.1"><vh>&lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh>
<v t="ekr.20060321105403"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20060321105403.1"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20060321105403.2"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20060321105403.3"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
</v>
<v t="ekr.20060309065445"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20051015110547"><vh>k.registerCommand</vh>
<v t="ekr.20060325110412"><vh>registerBinding</vh></v>
</v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060130093055"><vh>bindKeyToDict</vh></v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20060216074643"><vh>k.completeAllBindings &amp; helpers</vh>
<v t="ekr.20060221141535"><vh>completeAllBindingsForWidget</vh></v>
<v t="ekr.20060324092758"><vh>completeOneBindingForWidget</vh></v>
</v>
<v t="ekr.20051007080058"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051008152134"><vh>initSpecialIvars</vh></v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20060305110016"><vh>Made sure autocompleter and calltip text stick</vh></v>
<v t="ekr.20060213094300"><vh>Added call to g.enableIdleTimeHook to c.openWith</vh>
<v t="ekr.20060213145539"><vh>The causes</vh></v>
<v t="ekr.20060213144352"><vh>Report</vh></v>
<v t="ekr.20031218072017.1315"><vh>idle time functions (leoGlobals)</vh>
<v t="EKR.20040602125018"><vh>enableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.1"><vh>disableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.2"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20031218072017.2823"><vh>openWith and allies</vh>
<v t="ekr.20031218072017.2824"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2825"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20031218072017.2826"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2827"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20031218072017.2828"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2829"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2830"><vh>createOpenWithTempFile</vh>
<v t="ekr.20031218072017.2831"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2832"><vh>c.openWithTempFilePath</vh></v>
</v>
</v>
<v t="ekr.20060328150113.1"><vh>Set g.app.globalOpenDir in import/export commands</vh>
<v t="ekr.20060328150113"><vh>setGlobalOpenDir</vh></v>
<v t="ekr.20060328150113.2"><vh>Found: globalOpenDir </vh>
<v t="ekr.20031218072017.1416"><vh>app.__init__</vh>
<v t="ekr.20031218072017.1417"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20031218072017.2821"><vh>open</vh>
<v t="ekr.20031218072017.2822"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060212061804"><vh>runOpenFileDialog</vh></v>
<v t="ekr.20060212061804.1"><vh>runSaveFileDialog</vh></v>
</v>
<v t="ekr.20031218072017.2849"><vh>Import&amp;Export submenu</vh>
<v t="ekr.20031218072017.2850"><vh>exportHeadlines</vh></v>
<v t="ekr.20031218072017.2851"><vh>flattenOutline</vh></v>
<v t="ekr.20031218072017.2852"><vh>importAtRoot</vh></v>
<v t="ekr.20031218072017.2853"><vh>importAtFile</vh></v>
<v t="ekr.20031218072017.2854"><vh>importCWEBFiles</vh></v>
<v t="ekr.20031218072017.2855"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20031218072017.2856"><vh>importNowebFiles</vh></v>
<v t="ekr.20031218072017.2857"><vh>outlineToCWEB</vh></v>
<v t="ekr.20031218072017.2858"><vh>outlineToNoweb</vh></v>
<v t="ekr.20031218072017.2859"><vh>removeSentinels</vh></v>
<v t="ekr.20031218072017.2860"><vh>weave</vh></v>
</v>
</v>
<v t="ekr.20060227125713"><vh>Investigated colorizer problems: can not reproduce</vh></v>
<v t="ekr.20060325073234"><vh>Removed support @ifgui: it doesn't and can't work</vh></v>
<v t="ekr.20060325122134.1"><vh>Removed autocompletion for self</vh></v>
<v t="ekr.20060329090924"><vh>Rewrote g.importExtension to simplify startup logic</vh>
<v t="ekr.20041219071407"><vh>g.importExtension &amp; helpers</vh>
<v t="ekr.20060329083657"><vh>cantImportDialog &amp; helpers</vh>
<v t="ekr.20060329083310.1"><vh>createDialogFrame</vh></v>
<v t="ekr.20060329083310.2"><vh>createDialogButtons</vh></v>
<v t="ekr.20060329085417.1"><vh>center</vh></v>
<v t="ekr.20060329085612"><vh>get_window_info</vh></v>
</v>
</v>
</v>
<v t="ekr.20060410091659"><vh>Removed lstrip and rstrip for compatibility with Python 2.2.1</vh>
<v t="ekr.20060410112600"><vh>g.stripBrackets</vh></v>
<v t="ekr.20060410104419"><vh>Found: lstrip</vh>
<v t="ekr.20040718101315"><vh>stripWhitespaceFromBlankLines(before_lines)</vh></v>
<v t="ekr.20031218072017.3315"><vh>skipLeadingComments</vh>
<v t="ekr.20031218072017.3316"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="ekr.20060328112327.1"><vh>&lt;&lt; scan for Lua comments &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3317"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3318"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3637"><vh>compare_lines</vh></v>
<v t="ekr.20051022043713.1"><vh>&lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060216110502"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060130093055"><vh>bindKeyToDict</vh></v>
<v t="ekr.20060131075440"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060201083154"><vh>k.prettyPrintKey</vh></v>
<v t="ekr.20050920085536.75"><vh>executeNTimes</vh></v>
<v t="ekr.20050920085536.76"><vh>doControlU</vh></v>
<v t="ekr.20050920084036.103"><vh>fillParagraph</vh></v>
<v t="ekr.20050920084036.98"><vh>killParagraph (Test)</vh></v>
<v t="ekr.20050920084036.96"><vh>selectParagraph &amp; helper</vh>
<v t="ekr.20050920084036.97"><vh>selectParagraphHelper</vh></v>
</v>
<v t="ekr.20050920084036.97"><vh>selectParagraphHelper</vh></v>
<v t="ekr.20050920084036.107"><vh>indentRegion</vh></v>
<v t="ekr.20050920084036.203"><vh>_executeMacro (revise)</vh></v>
</v>
<v t="ekr.20060410112600.2"><vh>Found: rstrip</vh>
<v t="ekr.20051022043713.1"><vh>&lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060216110502"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060130093055"><vh>bindKeyToDict</vh></v>
<v t="ekr.20060131075440"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060201083154"><vh>k.prettyPrintKey</vh></v>
<v t="ekr.20050920085536.75"><vh>executeNTimes</vh></v>
<v t="ekr.20050920085536.76"><vh>doControlU</vh></v>
<v t="ekr.20050920084036.203"><vh>_executeMacro (revise)</vh></v>
</v>
</v>
<v t="ekr.20060410112600.1"><vh>Fixed crash in string.startswith and string.endswith</vh>
<v t="ekr.20060220110302"><vh>calltip</vh>
<v t="ekr.20060224103829"><vh>&lt;&lt; try to set s from a Python global function &gt;&gt;</vh></v>
<v t="ekr.20060224103829.1"><vh>&lt;&lt; get s using inspect &gt;&gt;</vh></v>
<v t="ekr.20060224103829.2"><vh>&lt;&lt; remove 'self' from s, but not from args &gt;&gt;</vh></v>
<v t="ekr.20060224103829.3"><vh>&lt;&lt; remove 's' from s *and* args &gt;&gt;</vh></v>
<v t="ekr.20060224103829.4"><vh>&lt;&lt; insert the text and set j1 and j2 &gt;&gt;</vh></v>
<v t="ekr.20060224103829.5"><vh>&lt;&lt; put the status line &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060408093907"><vh>Fixed Crash after undoing clearRecentFiles command</vh>
<v t="ekr.20060411135857"><vh>Trace</vh></v>
<v t="ekr.20060127052111.1"><vh>cutStack</vh></v>
</v>
<v t="ekr.20060408065447"><vh>fixed? newline problem on MacOS</vh>
<v t="ekr.20050920084036.138"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20051125080855"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060411101844"><vh>Fixed failed unit tests</vh>
<v t="ekr.20040718101315"><vh>stripWhitespaceFromBlankLines(before_lines)</vh></v>
</v>
</v>
<v t="ekr.20060323140748"><vh>Plugins</vh>
<v t="ekr.20060301182319"><vh>Support for chapters plugin</vh>
<v t="ekr.20060306030946.1"><vh>Event handling for multiple editors</vh>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20051026143009"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh>
<v t="ekr.20060321105403"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20060321105403.1"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20060321105403.2"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20060321105403.3"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
</v>
<v t="ekr.20060309065445"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20060129052538.2"><vh>masterClickHandler</vh></v>
</v>
<v t="ekr.20060306070502"><vh>Find</vh>
<v t="ekr.20031218072017.3091"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060306103239"><vh>Problems with unit testing</vh>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20041221071131.1"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050119210541"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221071131"><vh>createPmwTreeCanvas (not used)</vh></v>
</v>
<v t="ekr.20051104075904.42"><vh>leoTest.runLeoTest</vh></v>
<v t="ekr.20031218072017.2052"><vh>g.openWithFileName</vh></v>
<v t="ekr.20031218072017.4121"><vh>setMenuLabel</vh></v>
</v>
<v t="ekr.20060306030946"><vh>Drawing</vh>
<v t="ekr.20040803072955.52"><vh>drawTopTree</vh></v>
<v t="ekr.20040803072955.53"><vh>drawTree</vh></v>
<v t="ekr.20040803072955.42"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040803072955.43"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file</vh>
<v t="ekr.20040324080359"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040324080359.1"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3047"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20040324080819.1"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20050405103712"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050405103712.1"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2950"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20031218072017.2954"><vh>c.redraw and c.redraw_now</vh></v>
<v t="ekr.20051216155728"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20040803072955.58"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20040803072955.59"><vh>redrawHelper</vh></v>
</v>
</v>
<v t="ekr.20060306130654"><vh>Selecting</vh>
<v t="ekr.20040803072955.128"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803140033.1"><vh>setCurrentPosition</vh></v>
<v t="ekr.20040803072955.136"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20040803072955.85"><vh>configureTextState</vh></v>
<v t="ekr.20040803112450"><vh>c.isCurrentPosition</vh></v>
</v>
<v t="ekr.20040307104131.3"><vh>p.exists</vh></v>
<v t="ekr.20031218072017.1771"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040803140033.3"><vh>setRootPosition</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
</v>
<v t="ekr.20060319155125"><vh>Changed path to stylesheet in the rst3 plugin</vh>
<v t="ekr.20060320071608"><vh>proposed revision</vh></v>
</v>
<v t="ekr.20060319103111"><vh>Fixed problems with chapters plugin</vh>
<v t="ekr.20060319103111.1"><vh>Report 1</vh></v>
<v t="ekr.20060319103111.2"><vh>Report 2</vh></v>
<v t="ekr.20060319103111.3"><vh>Report 3</vh></v>
</v>
<v t="ekr.20060310093345"><vh>Improved groupoperations plugin</vh></v>
<v t="ekr.20060308103043"><vh>Fixed crasher in Word (and other) plugins</vh></v>
<v t="ekr.20060307142612"><vh>Fixed problem with labels plugin</vh></v>
</v>
</v>
</v>
<v t="ekr.20060226131603" a="V"><vh>To do 4.4 b4 or final</vh>
<v t="ekr.20060210140415"><vh>Most important 10</vh>
<v t="ekr.20060307074302.1"><vh>set-change-text command should work when entering find text.</vh></v>
<v t="ekr.20060122183544"><vh>Improve isearch</vh></v>
<v t="ekr.20060123095316"><vh>clear-selection</vh></v>
<v t="ekr.20060113090042"><vh>open-outline-by-name &amp; filename completion</vh></v>
<v t="ekr.20060122194643"><vh>isearch-headline (forward &amp; backward)</vh></v>
<v t="ekr.20060116085649"><vh>find-word-on-line, find-character-on-line (forward &amp; backward)</vh></v>
<v t="ekr.20060116074839.2"><vh>extend-to-word</vh></v>
<v t="ekr.20060123091352"><vh>Incremental search in switch-to-buffer</vh></v>
<v t="ekr.20060206103922"><vh>Minibuffer interface for GoToLine number (rewrite goto-line)</vh></v>
<v t="ekr.20060122185244.2"><vh>Fix unindent command</vh></v>
</v>
<v t="ekr.20060328120455"><vh>Next 7</vh>
<v t="ekr.20051202095626"><vh>help-for-command</vh></v>
<v t="ekr.20060116084526.1"><vh>insert/remove spaces/tabs from lines (LeoUser)</vh></v>
<v t="ekr.20060117115212"><vh>Fix rename-buffer command</vh></v>
<v t="ekr.20060104083551"><vh>move-line-up/down (LeoUser)</vh></v>
<v t="ekr.20060211093935"><vh>Support for @list and on-enter-mode</vh></v>
<v t="ekr.20060116090428"><vh>Expand 'point' so it indicates node as well as text location</vh></v>
<v t="ekr.20060211184834"><vh>Review all commands in leoEditCommands.py</vh></v>
</v>
<v t="ekr.20060227163911.1"><vh>Leo's web site</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040526075238.5">def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
        
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()
    
    if u.newSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)</t>
<t tx="EKR.20040526090701.4">def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)</t>
<t tx="EKR.20040602125018">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.</t>
<t tx="EKR.20040602125018.1"># Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False</t>
<t tx="EKR.20040602125018.2"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args &amp; keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None</t>
<t tx="EKR.20040623090054">case_insensitiveLanguages = ['plsql',]</t>
<t tx="bwmulder.20041023131509">ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]</t>
<t tx="ekr.20031218072017.367">@nocolor

- Add a new entries in &lt;&lt; define global data structures &gt;&gt; app

- Add a new Tk.Radiobutton in &lt;&lt;create the Target Language frame&gt;&gt;

- Add an entry to the languages list in &lt;&lt;configure language-specific settings&gt;&gt;

- Add a list of the keywords of the language to &lt;&lt; define colorizer keywords &gt;&gt;

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.
  
- If the language is case insensitive, add it to the list of
case_insensitiveLanguages found in  &lt;&lt; define global colorizer data &gt;&gt;

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the &lt;preferences&gt; tag (near the top) contains an entry like this:

&lt;preferences allow_rich_text="0" defaultTargetLanguage="Python"&gt;
&lt;/preferences&gt;

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color</t>
<t tx="ekr.20031218072017.368"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }</t>
<t tx="ekr.20031218072017.370"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex","lua",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "&lt;&lt;"
    self.rb = "&gt;&gt;"
else:
    self.lb = g.choose(self.language == "cweb","@&lt;","&lt;&lt;")
    self.rb = g.choose(self.language == "cweb","@&gt;","&gt;&gt;")</t>
<t tx="ekr.20031218072017.371">@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords</t>
<t tx="ekr.20031218072017.372">actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]</t>
<t tx="ekr.20031218072017.373">c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]</t>
<t tx="ekr.20031218072017.374"># EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]</t>
<t tx="ekr.20031218072017.375"># No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "&lt;%","%&gt;" ]</t>
<t tx="ekr.20031218072017.376">java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]</t>
<t tx="ekr.20031218072017.377">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx", "\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap",
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus",
    "\\bigvee", "\\bigwedge", "\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter",
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage",
    "\\cline", "\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh",
    "\\cot", "\\coth", "csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl",
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj",
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath",
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote",
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing",
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright", "\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill", "\\hspace", "\\huge", "\\Huge", "\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota", "\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", "\\linebreak", 
    "\\linethickness", "\\linewidth", "\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow", "longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength", "\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox", "\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", "\\phi", "\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi", "\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", "\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow", "\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow", "\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone", "\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark", "\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title", "\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow", "\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", "\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]</t>
<t tx="ekr.20031218072017.378">pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]</t>
<t tx="ekr.20031218072017.379">perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 &amp; FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 &amp; f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]</t>
<t tx="ekr.20031218072017.380">php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "&lt;?php", "?&gt;"
</t>
<t tx="ekr.20031218072017.381">python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]</t>
<t tx="ekr.20031218072017.382">rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]</t>
<t tx="ekr.20031218072017.383">tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]</t>
<t tx="ekr.20031218072017.840"></t>
<t tx="ekr.20031218072017.998">def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20031218072017.1315"></t>
<t tx="ekr.20031218072017.1329"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding) # New in 4.4b3.
    newText = g.app.gui.getAllText(bodyCtrl) # New in 4.4b3: converts to unicode.
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        # g.trace('removeTrailing:',removeTrailing)
        g.trace('newText:',repr(newText))
        #g.trace('oldText:',repr(oldText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        &lt;&lt; recolor the body &gt;&gt;
        if not c.changed: c.setChanged(True)
        &lt;&lt; redraw the screen if necessary &gt;&gt;</t>
<t tx="ekr.20031218072017.1416">def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    &lt;&lt; Define global constants &gt;&gt;
    &lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="ekr.20031218072017.1417">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
</t>
<t tx="ekr.20031218072017.1490">@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    &lt;&lt; return if there is nothing to do &gt;&gt;
    # g.trace(undo_type,g.callers(7))
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    return bunch</t>
<t tx="ekr.20031218072017.1491">@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"</t>
<t tx="ekr.20031218072017.1492">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines</t>
<t tx="ekr.20031218072017.1723">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)</t>
<t tx="ekr.20031218072017.1725"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        if not g.app.unitTesting and not not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20031218072017.1762">def clone (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone(p)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.</t>
<t tx="ekr.20031218072017.1771">def moveOutlineRight (self,event=None):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasBack: return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True): return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20031218072017.1801">def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.
    &lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</t>
<t tx="ekr.20031218072017.1802"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None</t>
<t tx="ekr.20031218072017.1809">def importDerivedFile (self,event=None):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(parent=p,paths=names)</t>
<t tx="ekr.20031218072017.1974">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20031218072017.1975">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)</t>
<t tx="ekr.20031218072017.1976"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="ekr.20031218072017.2052">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20031218072017.2176">def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    self.trace_status_line = c.config.getBool('trace_status_line')
    # f.enableTclTraces()</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.2821">def open (self,event=None):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.bodyWantsFocus()</t>
<t tx="ekr.20031218072017.2822">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20031218072017.2823">def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            enableIdleTimeHook(idleTimeDelay=100)
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20031218072017.2824">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20031218072017.2825">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20031218072017.2826">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20031218072017.2827">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20031218072017.2828">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20031218072017.2829">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20031218072017.2830">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.2831">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20031218072017.2832">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20031218072017.2849"></t>
<t tx="ekr.20031218072017.2850">def exportHeadlines (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.exportHeadlines(fileName)

</t>
<t tx="ekr.20031218072017.2851">def flattenOutline (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.flattenOutline(fileName)

</t>
<t tx="ekr.20031218072017.2852">def importAtRoot (self,event=None):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@root")
</t>
<t tx="ekr.20031218072017.2853">def importAtFile (self,event=None):
    
    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand(names,"@file")</t>
<t tx="ekr.20031218072017.2854">def importCWEBFiles (self,event=None):
    
    c = self
    
    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"cweb")
</t>
<t tx="ekr.20031218072017.2855">def importFlattenedOutline (self,event=None):
    
    c = self
    
    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFlattenedOutline(names)
</t>
<t tx="ekr.20031218072017.2856">def importNowebFiles (self,event=None):
    
    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"noweb")
</t>
<t tx="ekr.20031218072017.2857">def outlineToCWEB (self,event=None):
    
    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.outlineToWeb(fileName,"cweb")

</t>
<t tx="ekr.20031218072017.2858">def outlineToNoweb (self,event=None):
    
    c = self
    
    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName

</t>
<t tx="ekr.20031218072017.2859">def removeSentinels (self,event=None):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)</t>
<t tx="ekr.20031218072017.2860">def weave (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.weave(fileName)
</t>
<t tx="ekr.20031218072017.2950">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20031218072017.2954">def redraw (self):
    c = self
    c.beginUpdate()
    c.endUpdate()

def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
force_redraw = redraw_now</t>
<t tx="ekr.20031218072017.3046">def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        theActualFile = None
        if not toString:
            &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        if not toString:
            theActualFile = open(fileName, 'wb')
        &lt;&lt; put the .leo file &gt;&gt;
        s = self.outputFile.getvalue()
        if toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            &lt;&lt; delete backup file &gt;&gt;
        self.outputFile = None
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        &lt;&lt; delete fileName &gt;&gt;
        &lt;&lt; rename backupName to fileName &gt;&gt;
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20031218072017.3047"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None</t>
<t tx="ekr.20031218072017.3048">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')</t>
<t tx="ekr.20031218072017.3091">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    # g.trace(id(t),pos,newpos)
    c.widgetWantsFocusNow(t)
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    # c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20031218072017.3315">def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        &lt;&lt; scan for C-style comments &gt;&gt;
    elif self.fileType == ".lua":
        &lt;&lt; scan for Lua comments &gt;&gt;
    elif self.fileType == ".pas":
        &lt;&lt; scan for Pascal comments &gt;&gt;
    elif self.fileType == ".py":
        &lt;&lt; scan for Python comments &gt;&gt;
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"</t>
<t tx="ekr.20031218072017.3316">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break</t>
<t tx="ekr.20031218072017.3317">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break</t>
<t tx="ekr.20031218072017.3318">while i &lt; len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3637">def compare_lines (self,s1,s2):
    
    if self.ignoreLeadingWhitespace:
        s1 = s1.lstrip()
        s2 = s2.lstrip()

    if self.ignoreInteriorWhitespace:
        k1 = g.skip_ws(s1,0)
        k2 = g.skip_ws(s2,0)
        ws1 = s1[:k1]
        ws2 = s2[:k2]
        tail1 = s1[k1:]
        tail2 = s2[k2:]
        tail1 = string.replace(tail1," ","")
        tail1 = string.replace(tail1,"\t","")
        tail2 = string.replace(tail2," ","")
        tail2 = string.replace(tail2,"\t","")
        s1 = ws1 + tail1
        s2 = ws2 + tail2

    return s1 == s2</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3941"></t>
<t tx="ekr.20031218072017.3942">def __repr__ (self):

    return "&lt;leoTkinterFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20031218072017.3944">def createCanvas (self,parentFrame,pack=True):

    # pageName is not used here: it is used for compatibility with the Chapters plugin.

    c = self.c

    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas</t>
<t tx="ekr.20031218072017.3946">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        &lt;&lt; resize the Pmw panes &gt;&gt;
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20031218072017.3947">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="ekr.20031218072017.3949"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="ekr.20031218072017.3950"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20031218072017.3951">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="ekr.20031218072017.3952">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="ekr.20031218072017.3964"></t>
<t tx="ekr.20031218072017.3965">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()</t>
<t tx="ekr.20031218072017.4091">def getAllText (self,t):
    
    """Return all the text of Tk.Text widget t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4116">@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &amp;With...")
    amp_index = label.find("&amp;")
    label = label.replace("&amp;","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
</t>
<t tx="ekr.20031218072017.4121">def setMenuLabel (self,menu,name,label,underline=-1):

    try:
        if type(name) == type(0):
            # "name" is actually an index into the menu.
            menu.entryconfig(name,label=label,underline=underline)
        else:
            # Bug fix: 2/16/03: use translated name.
            realName = self.getRealMenuName(name)
            realName = realName.replace("&amp;","")
            # Bug fix: 3/25/03" use tranlasted label.
            label = self.getRealMenuName(label)
            label = label.replace("&amp;","")
            menu.entryconfig(realName,label=label,underline=underline)
    except:
        if not g.app.unitTesting:
            print "setMenuLabel menu,name,label:",menu,name,label
            g.es_exception()</t>
<t tx="ekr.20040206072057">csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]</t>
<t tx="ekr.20040303175026.11">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        if not parent.equal(c.rootPosition()):
            # g.trace('old root',c.rootPosition(),'new root',parent())
            c.setRootPosition(parent)

    return p
</t>
<t tx="ekr.20040303214038">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    dirtyVnodeList = []
    
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) &gt; 0

    c.beginUpdate()
    try:
        for v in dirtyVnodeList:
            v.t.setDirty() # Do not call v.setDirty here!
    finally:
        c.endUpdate(changed)

    return dirtyVnodeList</t>
<t tx="ekr.20040307104131.3">def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p.headString(),'parent',p.parent(),'back',p.back())
        if p.equal(root):
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    # g.trace('does not exist in root:',root.headString())
    return False</t>
<t tx="ekr.20040310062332.3">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n,parent.v)

    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")</t>
<t tx="ekr.20040324061854">if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None</t>
<t tx="ekr.20040324061854.1"># Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()</t>
<t tx="ekr.20040324061854.2">#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
</t>
<t tx="ekr.20040324061854.3">@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
if not p.isDirty():
    bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview</t>
<t tx="ekr.20040324080359">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20040324080359.1"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20040324080819.1">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20040331145826">rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]</t>
<t tx="ekr.20040401103539">css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]</t>
<t tx="ekr.20040401111125">shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 b3, build %s, April 14, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040709081208"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)</t>
<t tx="ekr.20040718101315">def stripWhitespaceFromBlankLines (self,lines):
    
    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.
    
    &gt;&gt;&gt; import leoGlobals as g
    &gt;&gt;&gt; s = "a\\n \\t\\n\\t\\t \\t\\nb"
    &gt;&gt;&gt; theLines = g.splitLines(s)
    &gt;&gt;&gt; theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    &gt;&gt;&gt; g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        # stripped_line = lines[i].lstrip(" \t") # lstrip does not exist in python 2.2.1.
        stripped_line = lines[i]
        while stripped_line and stripped_line[0] in (' ','\t'):
            stripped_line = stripped_line [1:]
        if stripped_line in ('\n',''):
            lines[i] = stripped_line
            
    return lines</t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20040803072955.8">def newClickBox (self,p,x1,y1,x2,y2):
    
    canvas = self.canvas ; defaultColor = ""
    tag = g.choose(p.hasChildren(),'clickBox','selectBox')

    if self.freeClickBoxes:
        theId = self.freeClickBoxes.pop(0)
        canvas.coords(theId,x1,y1,x2,y2)
        canvas.itemconfig(theId,tag=tag)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        
    if self.trace_alloc:
        g.trace("%3d %3d %3d %3d %3d" % (theId,x1,y1,x2,y2),p.headString(),align=-20)

    assert(theId not in self.visibleClickBoxes)
    self.visibleClickBoxes.append(theId)
    
    # assert(p)
    # assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    return theId</t>
<t tx="ekr.20040803072955.11">def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k

    found = len(self.freeText) &gt; 0
    if found:
        t,theId = self.freeText.pop()
        if self.trace_alloc: g.trace('%4d' % (theId),self.textAddr(t),'recycled')
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.

    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        t.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
        if self.trace_alloc:
            g.trace('%4d' % (theId),self.textAddr(t),'** new')
            
    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')
            
    self.ids[theId] = p # Add the id of the *window*
    self.setText(theId,t,p.headString())
    t.configure(width=self.headWidth(p=p))
    t.leo_position = p # This p never changes.
        # *Required*: onHeadlineClick uses w.leo_position to get p.

    # Keys are p.key().  Entries are (t,theId)
    self.visibleText [p.key()] = t,theId
    
    return t</t>
<t tx="ekr.20040803072955.42">def drawNode(self,p,x,y):
    
    c = self.c
    
    # g.trace(x,y,p,id(self.canvas))
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20040803072955.43">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20040803072955.52">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        self.redrawCount += 1
        # print ; print
        delta = g.app.positions - self.prevPositions
        # g.trace("**** gen: %-3d positions: %5d +%4d" % (
            # self.generation,g.app.positions,delta),g.callers())
        
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)

    if self.trace_stats: self.showStats()
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20040803072955.53">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20040803072955.58"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20040803072955.59">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20040803072955.85">def configureTextState (self,p):
    
    if not p: return
    
    # g.trace(p.headString(),self.c._currentPosition)
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20040803072955.128">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('does not exist',p.headString())
        return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.</t>
<t tx="ekr.20040803072955.129"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20040803072955.130"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20040803072955.131"># c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20040803072955.132"># The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!</t>
<t tx="ekr.20040803072955.133">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()</t>
<t tx="ekr.20040803072955.136">def setSelectedLabelState (self,p): # selected, disabled

    # g.trace(p.headString(),g.callers())

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20040803112450">def isCurrentPosition (self,p):
    
    c = self
    
    if p is None or c._currentPosition is None:
        return False
    else:
        return p.isEqual(c._currentPosition)</t>
<t tx="ekr.20040803140033.1">def setCurrentPosition (self,p):
    
    """Set the presently selected position."""
    
    c = self
    
    if p:
        if p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
    else:
        c._currentPosition = None
    
# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition</t>
<t tx="ekr.20040803140033.3">def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    if p:
        if p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
    
# For compatibiility with old scripts.
setRootVnode = setRootPosition</t>
<t tx="ekr.20041107093834"># Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]</t>
<t tx="ekr.20041117062717.14">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.
    
    bunchList = self.get(c,key,"shortcut")
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]</t>
<t tx="ekr.20041118104240">def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)</t>
<t tx="ekr.20041118104414">def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')
    
    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))</t>
<t tx="ekr.20041118104831.2">def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041121143823">def getValFromDict (self,d,setting,requestedType,warn=True):
    
    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            s = (
                'Warning: ignoring %s:%s not %s\n' +
                'There may be conflicting settings!')
            g.es_print(s % (bunch.kind,setting,requestedType),color='red')
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041219071407">def importExtension (moduleName,pluginName=None,verbose=False,required=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)
            
        if not module and required:
            g.cantImportDialog(pluginName,moduleName)
            try: # Avoid raising SystemExit if possible.
                import os ; os._exit(1) # May not be available on all platforms.
            except Exception:
                import sys ; sys.exit(1)

    return module</t>
<t tx="ekr.20041221071131">def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
 
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas</t>
<t tx="ekr.20041221071131.1">def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    trace = self.c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace(canvas)
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 0:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20041221073427">def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame</t>
<t tx="ekr.20041221073427.1">def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2</t>
<t tx="ekr.20041221075743">@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)</t>
<t tx="ekr.20041221122440">def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()</t>
<t tx="ekr.20041221123325">def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        &lt;&lt; create Pmw splitters and their components &gt;&gt;
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="ekr.20041221185246">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.</t>
<t tx="ekr.20041221195402"></t>
<t tx="ekr.20041223130032"># Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20050104084531">self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))</t>
<t tx="ekr.20050119210541"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)</t>
<t tx="ekr.20050125203937">old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 &gt;= len(old_s) or new_col-1 &gt;= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)</t>
<t tx="ekr.20050125220613">@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True</t>
<t tx="ekr.20050405103712">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20050405103712.1">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)</t>
<t tx="ekr.20050412083057">def redoCloneNode (self):
    
    u = self ; c = u.c
    
    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()

    c.selectPosition(u.newP)</t>
<t tx="ekr.20050412083057.1">def undoCloneNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    c.selectPosition(u.p)</t>
<t tx="ekr.20050412084055">def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty() # New in 4.4b3.
    c.selectPosition(u.p)</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050618045715">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

instance_tag = t.bindtags()[0]
t.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
t.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
t.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)</t>
<t tx="ekr.20050618052621"></t>
<t tx="ekr.20050618052653">plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050920084036.85"></t>
<t tx="ekr.20050920084036.86">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    w = event.widget
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('head'):
        w.insert('insert','\n\t')
</t>
<t tx="ekr.20050920084036.87">def deleteNextChar (self,event):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed,setLabel=False)</t>
<t tx="ekr.20050920084036.96">def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break</t>
<t tx="ekr.20050920084036.97">def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.strip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)</t>
<t tx="ekr.20050920084036.98">def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.strip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20050920084036.103">def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.strip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.strip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.strip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )</t>
<t tx="ekr.20050920084036.107">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20050920084036.135">def deleteSpaces (self,event,insertspace=False):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)</t>
<t tx="ekr.20050920084036.138">def insertNewLine (self,event):

    w = event.widget
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('head'):
        w.insert('insert','\n')

insertNewline = insertNewLine</t>
<t tx="ekr.20050920084036.139">def insertParentheses (self,event):

    w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')</t>
<t tx="ekr.20050920084036.141">def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050920084036.203">def _executeMacro (self,macro,w):

    k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('&lt;Key&gt;',keycode=z[0],keysym=z[1])
        else:
            meth = g.stripBrackets(z [0])
            bunchList = k.bindingsDict.get(meth,[])  ### Probably should not strip &lt; and &gt;
            if bunchList:
                b = bunchList[0]
                ev = Tk.Event()
                ev.widget = w
                ev.keycode = z [1]
                ev.keysym = z [2]
                ev.char = z [3]
                k.masterCommand(ev,b.f,'&lt;%s&gt;' % meth)</t>
<t tx="ekr.20050920085536.1"></t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter')
    self.enable_calltips                = c.config.getBool('enable_calltips')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;
    
    self.autoCompleter = autoCompleterClass(self)</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = g.stripBrackets(shortcut.strip())
        # if shortcut.startswith('&lt;Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility</t>
<t tx="ekr.20050920085536.63">def keyboardQuit (self,event,hideTabs=True):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    
    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()
    
    k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.bodyWantsFocus()</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    special = keysym in (
        'Caps_Lock','Num_Lock','Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None

    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920085536.75">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)</t>
<t tx="ekr.20050920085536.76">def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20050923213858">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20051006125633"></t>
<t tx="ekr.20051007080058">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())</t>
<t tx="ekr.20051008134059">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)</t>
<t tx="ekr.20051008135051.1">def bindOpenWith (self,shortcut,name,data):
    
    '''Register an open-with command.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='text',verbose=False)
    
    if 0: # now in k.registerCommand
    
        # Duplicate the logic k.completeAllBindings to set the actual bindings.
        stroke = k.shortcutFromSetting(shortcut)
        
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
    
        for w in (f.body.bodyCtrl,f.tree.canvas,f.tree.bindingWidget):
            k.completeOneBindingForWidget(w,stroke,bindKeyCallback)</t>
<t tx="ekr.20051008152134">def initSpecialIvars (self):
    
    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = c.config.getBool('trace_bindings')
    warn  = c.config.getBool('warn_about_missing_settings')
    
    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)</t>
<t tx="ekr.20051009044751">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
        f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)
        f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
        f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)</t>
<t tx="ekr.20051009044920"># Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()</t>
<t tx="ekr.20051009045208">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()</t>
<t tx="ekr.20051009045300"># Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)</t>
<t tx="ekr.20051011072049.2">def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20051011072903.2">def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20051011072903.5">def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    # g.trace(wname,s,i,j)
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText</t>
<t tx="ekr.20051011103654">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    if not c.config.getBool('warn_about_missing_settings'): return
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20051015110547">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
        ok = k.bindKey (pane,stroke,func,commandName)
        k.registerBinding(shortcut)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    else:
        # New in 4.4b3: try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        found = False
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                found = True
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,func,commandName)
                k.registerBinding(accel)
                if verbose:
                    g.es_print('Registered %s bound to %s' % (
                        commandName,k.prettyPrintKey(shortcut)),color='blue')
        if verbose and not found:
            g.es_print('Registered %s' % (commandName),color='blue')
</t>
<t tx="ekr.20051021091958">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20051022043608.1">def createOpenWithMenuItemsFromTable (self,menu,table):
    
    '''Create an entry in the Open with Menu from the table.
    
    Each entry should be a sequence with 2 or 3 elements.'''
    
    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        callback = self.defineOpenWithMenuCallback(openWithData)
    
        self.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
</t>
<t tx="ekr.20051022043713.1">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data</t>
<t tx="ekr.20051026083544">def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20051026083733.6">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20051026083733.7">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20051026092433">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20051026092433.1">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget
    if not g.app.gui.isTextWidget(w):
        g.trace('*'*40,'Not a text widget',c.widget_name(w))
        return
    
    wname = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(wname,i,j)

    if wname.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20051026092746">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20051026143009">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    ### elif g.safeStringCompare(old,new[-1]):
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True</t>
<t tx="ekr.20051026171121">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
        # g.trace(removeTrailing)</t>
<t tx="ekr.20051026171121.1"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051104075904.42">def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    try:
        g.app.unitTesting = True
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            g.app.closeLeoWindow(frame.c.frame)
        c.frame.top.update()
        g.app.unitTesting = False

    if not ok: raise</t>
<t tx="ekr.20051121092320">def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)</t>
<t tx="ekr.20051125080855">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name,repr(ch))
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20051202095626">Use docstrings as the help message.</t>
<t tx="ekr.20051216155728">def beginUpdate (self):
    
    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())
    
def endUpdate (self,flag,scroll=False):
    
    self.updateCount -= 1
    # g.trace('  tree',id(self),self.updateCount,g.callers())
    
    if self.updateCount &lt;= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount &lt; 0:
            g.trace("Can't happen: negative updateCount",g.callers())</t>
<t tx="ekr.20060104083551">http://sourceforge.net/forum/message.php?msg_id=3488030

move-region-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-region-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.</t>
<t tx="ekr.20060104154937">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))</t>
<t tx="ekr.20060113090042"></t>
<t tx="ekr.20060114110141">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)</t>
<t tx="ekr.20060114115648">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060115195302">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20060116074839.2"></t>
<t tx="ekr.20060116084526.1">http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space is added to start of all selected lines.

add-tab-to-line         Adds 4 spaces to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a space from start of all selected lines.</t>
<t tx="ekr.20060116085649"></t>
<t tx="ekr.20060116090428"></t>
<t tx="ekr.20060117115212"></t>
<t tx="ekr.20060122183544">@nocolor

- Handle backspace for isearch: keep a stack of previous matches.
- Allow cross-node isearches.
</t>
<t tx="ekr.20060122185244.2"># unindent-region should work in all panes.</t>
<t tx="ekr.20060122194643"></t>
<t tx="ekr.20060123091352"></t>
<t tx="ekr.20060123095316">Useful, e.g., after a find.</t>
<t tx="ekr.20060127052111.1">def cutStack (self):
    
    u = self ; n = u.max_undo_stack_size

    if n &gt; 0 and u.bead &gt;= n and not g.app.unitTesting:
        
        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i &gt;= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))</t>
<t tx="ekr.20060127183752">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val</t>
<t tx="ekr.20060128081317">def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip()
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting</t>
<t tx="ekr.20060128103640.1"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')</t>
<t tx="ekr.20060128103640.2">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)</t>
<t tx="ekr.20060128103640.4">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)
    
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])</t>
<t tx="ekr.20060129052538.2">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else: return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler</t>
<t tx="ekr.20060130093055">def bindKeyToDict (self,pane,stroke,func,commandName):
    
    k = self
    d =  k.masterBindingsDict.get(pane,{})
    
    stroke = g.stripBrackets(stroke)
    
    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__)) # ,len(d.keys()))

    if d.get(stroke):
        g.es('ignoring duplicate definition of %s to %s in %s' % (
            stroke,commandName,pane), color='blue')
    else:
        d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
        k.masterBindingsDict [pane] = d</t>
<t tx="ekr.20060131075440">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    return '&lt;%s&gt;' % stroke</t>
<t tx="ekr.20060201065809">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0</t>
<t tx="ekr.20060201083154">def prettyPrintKey (self,stroke):
    
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '&lt;%s&gt;' % s</t>
<t tx="ekr.20060203112912.1"></t>
<t tx="ekr.20060205221734">def masterKeyHandlerHelper (self,event,stroke):
    
    &lt;&lt; define vars &gt;&gt;

    if keysym in special_keys:
        return None

    &lt;&lt; do key traces &gt;&gt;

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;

    &lt;&lt; handle per-pane bindings &gt;&gt;
</t>
<t tx="ekr.20060206103922"></t>
<t tx="ekr.20060210140415"></t>
<t tx="ekr.20060211093935"></t>
<t tx="ekr.20060211184834">Any command that alters text should call begin/endCommand.</t>
<t tx="ekr.20060212061804">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    
    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)</t>
<t tx="ekr.20060212061804.1">def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir=g.app.globalOpenDir or g.os_path_abspath(os.getcwd()),

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)</t>
<t tx="ekr.20060213094300"></t>
<t tx="ekr.20060213144352">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3573148
By: yarkot

With the "latest" CVS snapshot. Do this:

[] Open LeoDocs.leo from the latest workspace;
[] Expand node "What's new in Leo 4.4" (I'll refer to this as the "parent");
[] Dbl-click parent (VIM opens text; text is single line: "@nocolor");
[] Add a second "@nocolor" line; write and save from VIM;
[] Leo view does not show line;
[] re-open w/ vim - vim shows new line;

[] Save;  add more text;  shows w/ vim, not in Leo; Apparently doesn't get save.
You can add a line in Leo, "This is a test", modify it in vim - "This was a
test", save vim, save Leo - close leo, re-open leo - the vim changes never got
saved.

Ok  - that's one.

Here's the second (same file, node, fresh session):

[] Open parent w/ vim (dbl-clk); opens ok;
[] open child "New commands not in legacy Leo" w/ vim; opens ok.
[] FAILS:  try to open first child: "Minibuffer-oriented find commands" - vim
doesn't open, status line flashes node name (once for each click it looks like),
and console window shows this:

open_in_vim: {'p': &lt;pos 20987888 lvl: 1 [0] New commands not in legacy Leo&gt;,
'c'
: Commander 25144936: u'C:\\Workspace\\Leo\\leo\\doc\\LeoDocs.leo', 'event':
&lt;Tk
inter.Event instance at 0x0132BE90&gt;, 'v': &lt;pos 20987888 lvl: 1 [0] New commands
not in legacy Leo&gt;}</t>
<t tx="ekr.20060213145539">@nocolor

1.  Both the vim and xemacs plugins require that open_with plugin be enabled.
    I changed the docstrings for each.

2.  The open_with plugin now explicitly calls g.enableIdleTimeHook.
    That is, the idle time hook is no longer enabled by default.
   
These were easy fixes to make.  A similar fix should be done for files opened from the Open With menu, but it's too late to do that for b2.</t>
<t tx="ekr.20060215104239">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False</t>
<t tx="ekr.20060216074643">def completeAllBindings (self):
    
    '''New in 4.4b3: make an actual binding in *all* the standard places.
    
    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    
    k = self ; c = k.c ; f = c.frame
    bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
    canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
    bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
    if not bodyCtrl or not canvas: return
    
    for w in (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget):
    
        self.completeAllBindingsForWidget(w)
</t>
<t tx="ekr.20060216110502">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''</t>
<t tx="ekr.20060220110302">def calltip (self,obj=None):
    
    c = self.c ; w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        &lt;&lt; try to set s from a Python global function &gt;&gt;

    if not s:
        &lt;&lt; get s using inspect &gt;&gt;
        
    &lt;&lt; remove 'self' from s, but not from args &gt;&gt;
    if isStringMethod:
        &lt;&lt; remove 's' from s *and* args &gt;&gt;

    s = s.rstrip(')') # Convenient.
    &lt;&lt; insert the text and set j1 and j2 &gt;&gt;

    # End autocompletion mode, restoring the selection.
    self.finish()
    c.widgetWantsFocusNow(w)
    g.app.gui.setSelectionRange(w,j1,j2,insert=j2)
    &lt;&lt; put the status line &gt;&gt;
</t>
<t tx="ekr.20060221141535">def completeAllBindingsForWidget (self,w):
    
    k = self
    
    for stroke in k.bindingsDict.keys():
        
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
            
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)</t>
<t tx="ekr.20060224103829"># The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i &gt; -1: s = s [i:]
    s = s and s.strip() or ''</t>
<t tx="ekr.20060224103829.1">isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)</t>
<t tx="ekr.20060224103829.2">if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()</t>
<t tx="ekr.20060224103829.3">if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]</t>
<t tx="ekr.20060224103829.4">if g.app.gui.hasSelection(w):
    i,j = g.app.gui.getSelectionRange(w)
else:
    i = j = g.app.gui.getInsertPoint(w)
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')

if 1:
    j1 = w.index('%s + 1c' % j)
    j2 = w.index('%s + %sc' % (j,len(s)))
else:
    j1 = j2 = w.index('%s + 2c' % j)</t>
<t tx="ekr.20060224103829.5">c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))</t>
<t tx="ekr.20060226131603"></t>
<t tx="ekr.20060227120635"></t>
<t tx="ekr.20060227125713">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3585710
By: e

sometimes it seems to happen no matter what.
here are two (I hope) repeatable cases.

happens if the previous line has a comment or string
@language python
some=expr #trailing comment
another line
copy then paste 'another line' line
it colorized like a comment, or all one color.
a sure way to fix it is goto another node then back.
it won't naturally resynch by itself 
even if you goto end of body and back.

after that,
cut something inside next line after a comment same thing.
similar problem if previous line ends in a string.
same if cut/paste and trailing comment is on the same line.
undo restores the previous coloring, correct or not.
its been this way since early 4.4alpha I think.
still using 4.4b1

the final color was comment color as I write this,
as I open a fresh Leo and repeat, its text color.
there may be more than one trigger to the problem.

I know its a tradeoff of constant colorizing runs vrs incremental update, its
not technically a new problem, but this seems way buggier.

@color</t>
<t tx="ekr.20060227163911.1">@nocolor

- Put more screen shots on Leo's web site.
- Put complete slide show on Leo's web site.</t>
<t tx="ekr.20060228071700"></t>
<t tx="ekr.20060301182319"></t>
<t tx="ekr.20060305110016">g.</t>
<t tx="ekr.20060306030946"></t>
<t tx="ekr.20060306030946.1"></t>
<t tx="ekr.20060306070425"></t>
<t tx="ekr.20060306070502"></t>
<t tx="ekr.20060306103239"></t>
<t tx="ekr.20060306130654"></t>
<t tx="ekr.20060306193836"></t>
<t tx="ekr.20060306193910"></t>
<t tx="ekr.20060306200304.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3608246

Added the following commands:

scroll-outline-down-line       
scroll-outline-down-page       
scroll-outline-up-line       
scroll-outline-up-page</t>
<t tx="ekr.20060307074302.1"># It's not clear how to do this.</t>
<t tx="ekr.20060307080642">if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)</t>
<t tx="ekr.20060307080642.1"></t>
<t tx="ekr.20060307142612">@nocolor

I tried the Labels plugin, and got:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
TypeError: menu_add_label() takes exactly 1 argument (2 given)

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
TypeError: marks_to_label() takes exactly 1 argument (2 given)

--Rich

The fix: all menu commands now have event=None in their argument list.</t>
<t tx="ekr.20060307234849"></t>
<t tx="ekr.20060308103043">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3617936
By: nobody

I did a clean install of A7. I have the export to word plugin enabled. When
I try to export my outline to word I get the following:

Leo Log Window...
Leo 4.4 a7, build  1.417 , February 28, 2006
Python 2.3.5, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

reading: C:\Development\VL4\VL4 outline.leo
Trying to connect to Word
Writing tree to Word
Exception writing Word
Traceback (most recent call last):
  File "C:\Program Files\Leo\plugins\word_export.py", line 163, in cmd_Export
    "")
  File "C:\Program Files\Leo\plugins\word_export.py", line 122, in
writeNodeAndTree
    vnode = c.currentVnode()
AttributeError: 'Bunch' object has no attribute 'currentVnode'

The fix was to plugins_menu.py: the cmd_callback must have an event argument.
</t>
<t tx="ekr.20060309022225">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3619340
By: nobody

Just tried out CVS today, and on Linux left/right and L/R in outline mode
(Ctrl-Shift-O) seem to do nothing, whereas they should expand/contract parent
nodes. Do I need to do something special to enable these keys, or is this a bug?

@color</t>
<t tx="ekr.20060309060654.1">def scrollOutlineDownLine (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(1,"unit")
    
def scrollOutlineDownPage (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(-1,"page")


</t>
<t tx="ekr.20060309065445">def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False</t>
<t tx="ekr.20060309132452"></t>
<t tx="ekr.20060310093345">@nocolor

Cleaned up the code and added support minibuffer commands:

group-operations-clear-marked       = Alt-Ctrl-Shift-l
group-operations-mark-for-copy      = Alt-Ctrl-Shift-c
group-operations-mark-for-move      = Alt-Ctrl-Shift-m
group-operations-mark-for-clone     = Alt-Ctrl-`
group-operations-mark-target        = Alt-Ctrl-Shift-t
group-operations-operate-on-marked  = Alt-Ctrl-Shift-o
group-operations-transfer           = Alt-Ctrl-Shift-d

This code has not been tested with the chapters2 plugin.</t>
<t tx="ekr.20060319103111"></t>
<t tx="ekr.20060319103111.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3626542

v .203 EKR:
- Chapter.makeCurrent now calls self.rp.v.linkAsRoot to properly anchor the root node.
  This was the cause of the move-outline-right problems.
By: tfer

Just playing with the chapters plug-in under a CVS download and ran into odd
behavior.  I was playing with putting Dive into Python" into chapters.  inserted
a new chapter (2), named the node "Your first Python Program", cntrl-i for insert
new node, cntrl-r  to move right.
(1st odd thing:), node collapsed under chapter title.
(2nd odd thing:) I can't select the "NewHeading" via mouse (chapter name  node remains selected)
trying same by keyboard (alt-dwnArrow, cntrl-h),
changes the body pane "location line" to "NewHeading", but in outline pane chapter
title node reamains selected,  and I can't edit the NewHeading node name.

Only thing I'm leaving out is alt-tabbing to scintila to cut and paste teaxt to nodes/body.

Tom
</t>
<t tx="ekr.20060319103111.2">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3629055
By: tfer

Saved out the troubled outline, did a update via CVS, adn the outline seems
to be behaving itself now.  Need to test more to be sure.  The problem seems
to start when you move a node via cntrl-r.

There seems to be a problem with @button w/chapters, opening a chpters doc with
an one does not add a button to button bar.

tom
</t>
<t tx="ekr.20060319103111.3">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3632004
By: tfer

Darn, bug still seems to be present.

1) Add &amp; name new chapter
2) Insert a node (cntrl-i)
3) Move "NewNode" right (cntrl-r)

"NewNode" collapses into chapter name and selection box will not leave it.

Tom
</t>
<t tx="ekr.20060319155125">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3637393
By: nobody

Leo 4.4 a7, build  1.417 (under Linux)

Using rst3 to generate LaTex

Hi,

I'm trying to set up a default stylesheet for a project and want this to be
held relative to the project directory (where the .leo file is). The default
is to place it in the same directory as the output, which is a couple of levels
down.

setting stylesheet_path = . or empty does not work. I seem to have to specify
an absolute path, which is not helpful when sharing developmnent through cvs.

Am I missing something?

Mike S.</t>
<t tx="ekr.20060320071608">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3639216
By: nobody

I looked at the code myself. I have changed rst3.py line 1213 to replace
g.os_path_dirname(self.outputFileName) with self.c.frame.openDirectory. This
makes the path relative to the project. Not 100% as the stylesheet filename
would need a path embedded in it to move the location down the tree. However,
it is consistent with the way the output file is named.
</t>
<t tx="ekr.20060320113137"># The dirty bits were not updated properly in several undo/redo operations.</t>
<t tx="ekr.20060320113137.2">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3639193
By: nobody

I'm using Leo 4.3.1, build 1.266 , June 20, 2005. 

I have a document of a few @thin nodes that in some hundred subnodes contain
many nodes so that the same node is cloned in more than one file. This works
mgaically greatly in Leo. Whatever I change in one cloned node is neatly distributed
to all the files.

But I've found a situation, that can be a bit dangerous. I changed the body
(actually I did Ctrl-x to cut a part of it) of one of these cloned nodes and
saved the whole document with Ctrl-s. Then I undid from the Edit menu with the
"Undo Cut" and saved whole document with Ctrl-s again.

After undo and before second saving I already noticed that the icons before
changed clones did not get different, more black, colour that signifies changed
nodes.

But, more seriously, I've noticed in the log, that only the top .leo file was
saved. I looked into other files containing the cloned node and really, there
was still the old contents.

There is a simple workaround. I simply type and delete one space into the body
of the changed node and then the colour of the icons is OK and Ctrl-s saves
oall the clones.

May be it's not important that I have @thin nodes. May be the same situation
would show in one self contained .leo document with a few clones. I didn't try.

I hope I explained well enough. If anybody is interested to anylse and cannot
reproduce the situation, I would try to prepare a simplified document to show
the problem.

maksr@snt.si</t>
<t tx="ekr.20060321080150.6"></t>
<t tx="ekr.20060321094013"></t>
<t tx="ekr.20060321105403">k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')</t>
<t tx="ekr.20060321105403.1">self.master_key_count += 1

if trace and (self.master_key_count % 100) == 0:
    g.printGcSummary(trace=True)

if 0:
    if stroke is None:
        if trace: g.trace('no stroke: using strokeFromEvent')
        stroke = k.strokeFromEvent(event)
        
if trace:
    g.trace(repr(stroke),'state',state)
</t>
<t tx="ekr.20060321105403.2"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        g.trace('No state dictionary for %s' % state)
    return 'break'</t>
<t tx="ekr.20060321105403.3">for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060321111639">Apparently g.app.unitTesting isn't set properly for the new-window test.

### It's a button in some .leo file.

Warning: ignoring bool:tracegc not shortcut
There may be conflicting settings!</t>
<t tx="ekr.20060321140706"></t>
<t tx="ekr.20060323085310">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3642892
By: thyrsus

An unimportant bug presented when I tried this: the logic to interpret
the @file didn't notice the change to the parent node, and I had to taint the
@file node itself (I'm sure a child node would also have worked) to get Leo
to notice that the @file needed to be rewritten.


EKR: The present code is probably the best compromise between strict accuracy and marking too many nodes dirty.</t>
<t tx="ekr.20060323095532">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3606515
By: spboulet

When pressing the return key, I see:

masterKeyHandlerHelper: 'Return' state None
masterKeyHandlerHelper: 'Return' no func

This is the case regardless of whether @bool swap_mac_keys is True or False,
although with 'True' the command key works as expected on the mac.

Same result using CVS re the return key.

Another thing I noticed (cvs version) is that the recent files is updated during
a session but is not saved from session to session.

Stephen</t>
<t tx="ekr.20060323110223"># Hit control-f, then select the text that doesn't have focus.</t>
<t tx="ekr.20060323131536"></t>
<t tx="ekr.20060323131536.1"></t>
<t tx="ekr.20060323132048">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3641107
By: thyrsus

Running the entitled version of Leo from CVS on Fedora Core 4, python 2.4.1

Bug: attempting to save the outline:

+ top
(contents)
@delims dnl 
...@file foo.mc
(contents)
@first divert(-1)dnl
test
dnl test
more test

With no @settings nodes anywhere (there is no leSettings.leo file, contrary
to the generated message below), "python ~/leo/src/leo.py" makes a large number
of comments about

leoID = sps (in /home/sps)
Plugins disabled: use_plugins is 0 in a leoSettings.leo file.
initSpecialIvars: no setting for full-command
initSpecialIvars: no setting for keyboard-quit
initSpecialIvars: no setting for universal-argument
checkBindings: No shortcut for abbrev-mode = abbrevmode
checkBindings: No shortcut for abort-edit-headline = aborteditheadline
checkBindings: No shortcut for about-leo = aboutleo

(goes on for many lines)

The menu save results in python exceptions:

Leo Log Window...
Leo 4.4 a7, build  1.418 , February 28, 2006
Python 2.4.1, Tk 8.4.9, Pmw 1.2
linux2

leoID = sps (in /home/sps)
global config dir: /home/sps/leo/config
home dir: /home/sps
Plugins disabled: use_plugins is 0 in a leoSettings.leo file.
exception writing:divert(-1)dnl
Traceback (most recent call last):
  File "/home/sps/leo/src/leoAtFile.py", line 4138, in os
    s = g.toEncodedString(s,at.encoding,reportErrors=True)
  File "/home/sps/leo/src/leoGlobals.py", line 3842, in toEncodedString
    s = s.encode(encoding,"strict")
TypeError: encode() argument 1 must be string, not None
exception writing:/home/sps/foo.mc
Traceback (most recent call last):
  File "/home/sps/leo/src/leoAtFile.py", line 2912, in write
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
  File "/home/sps/leo/src/leoAtFile.py", line 3180, in writeOpenFile
    at.putOpenLeoSentinel("@+leo-ver=4")
  File "/home/sps/leo/src/leoAtFile.py", line 3894, in putOpenLeoSentinel
    encoding = at.encoding.lower()
AttributeError: 'NoneType' object has no attribute 'lower'
exception writing: /home/sps/foo.leo
TypeError: encode() argument 1 must be string, not None

</t>
<t tx="ekr.20060323134459">ConfigSettings.initEncoding now uses the g.app.config settings if no other settings are available.

In particular, this causes at.encoding to be inited to a reasonable value.</t>
<t tx="ekr.20060323140748"></t>
<t tx="ekr.20060323194410"></t>
<t tx="ekr.20060324065958">@nocolor

- onBodyChanged now converts everything to unicode, either directly or by calling g.app.gui.getAllText.

- Replaced all calls to g.safeStringCompare by g.app.gui.getAllText which calls g.toUnicode.

- Converted all shortcuts to unicode in shortcutFromSetting (a.k.a strokeFromSetting)

- Removed g.safeStringCompare.  This function was a bad idea.

Important: Leo is supposed to convert all characters to unicode, so there should
never be a need for safeStringCompare. The proper way to avoid UnicodeError's is
to call g.toUnicode(s,g.app.tkEncoding).</t>
<t tx="ekr.20060324080104">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3607355
By: vpe

Alt-Ctrl-T shortcut for Open With external editor does not work in a7. Is it
possible to assign shortcuts to Open With items? I see that there is open-with
minibuffer command, but do not understand how to use it.
</t>
<t tx="ekr.20060324092758">def completeOneBindingForWidget (self,w,stroke,callback):

    k = self ; c = k.c

    try:
        bindStroke = k.tkbindingFromStroke(stroke)
        # g.trace(bindStroke,c.widget_name(w))
        w.bind(bindStroke,callback)

    except Exception:
        g.es_print('exception binding %s to %s' % (
            bindStroke, c.widget_name(w)), color = 'blue')</t>
<t tx="ekr.20060325073234">@nocolor

Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.</t>
<t tx="ekr.20060325093414"># It now properly creates bindings.</t>
<t tx="ekr.20060325110412">def registerBinding (self,shortcut):
    
    k = self ; f = k.c.frame

    # Duplicate the logic k.completeAllBindings to set the actual bindings.
    stroke = k.shortcutFromSetting(shortcut)
    # g.trace(stroke)
        
    def bindKeyCallback (event,k=k,stroke=stroke):
        return k.masterKeyHandler(event,stroke=stroke)
    
    for w in (f.body.bodyCtrl,f.tree.canvas,f.tree.bindingWidget):
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)</t>
<t tx="ekr.20060325122134.1"># It's not ready for prime time.</t>
<t tx="ekr.20060328110802"># ddm 13/02/06
lua_keywords = [
    "and", "break", "do", "else", "elseif", "end",
    "false", "for", "function", "if", "in", "local",
    "nil", "not", "or", "repeat", "return", "then",
    "true", "until", "while",
]
</t>
<t tx="ekr.20060328110802.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3572598
By: davidmcnab

I have added support to Leo for the Lua programming language (www.lua.org).

A patch, against Leo 4.4 beta 1, build  1.375, is up at:
http://www.freenet.org.nz/misc/leo-with-lua.patch.gz

Patch should be executed with '-p1' inside the leo 'src' directory.

Summary: support for importing Lua files; support for Lua comments and keywords;
no auto-detect of Lua function definitions or classes (because Lua function/class
idioms vary); no support for Lua v5+ metamethods.

Implementation method - I loaded LeoPy.leo, searched the whole outline for 'java',
and added lua counterparts throughout, including a Lua comment scanner.</t>
<t tx="ekr.20060328112327.1">while i &lt; len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break</t>
<t tx="ekr.20060328120455"></t>
<t tx="ekr.20060328121145">def runUnitTests (self,event=None):
    
    '''Run all unit tests contained in the presently selected outline.'''
    
    c = self.c

    leoTest.doTests(c,all=False)</t>
<t tx="ekr.20060328121145.1"></t>
<t tx="ekr.20060328150113">def setGlobalOpenDir (fileName):
    
    if fileName:
        g.app.globalOpenDir = g.os_path_dirname(fileName)
        # g.es('current directory: %s' %  g.app.globalOpenDir)</t>
<t tx="ekr.20060328150113.1"></t>
<t tx="ekr.20060328150113.2"></t>
<t tx="ekr.20060329083310.1">def createDialogFrame(Tk,root,title,message):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("&lt;Key&gt;",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")
    
    label = Tk.Label(f,text=message)
    label.pack(pady=10)
    
    def okButton(top=top):
        top.destroy()
    
    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)
    
    center(top)
    top.lift()
    top.focus_force()
    
    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)

    return top</t>
<t tx="ekr.20060329083310.2">def createDialogButtons (Tk,top,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    buttonList = []
    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)</t>
<t tx="ekr.20060329083657">def cantImportDialog (pluginName,moduleName):
    
    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if 1: # Requires minimal further imports.
        try:
            import Tkinter as Tk
            root = g.app.root or Tk.Tk()
            title = 'Can not import %s' % moduleName
            top = createDialogFrame(Tk,root,title,message)
            root.wait_window(top)
        except ImportError:
            print 'Can not import %s' % moduleName
            print 'Can not import Tkinter'
            print 'Leo must now exit'
        
    else: # Can cause import problems during startup.
        import leoTkinterDialog
        
        d = leoTkinterDialog.tkinterAskOk(
            c=None,title='Can not import %s' %(moduleName),
            message=message)
        d.run(modal=True)</t>
<t tx="ekr.20060329085417.1">def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20060329085612"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20060329090924"></t>
<t tx="ekr.20060408065447"># Very weird.  Things are working now, but I don't know why...
</t>
<t tx="ekr.20060408093907"></t>
<t tx="ekr.20060410091659">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3671350

Change aString.lstrip and aString.rstrip to the aString.replace.
@color</t>
<t tx="ekr.20060410104419"></t>
<t tx="ekr.20060410112600">def stripBrackets (s):
    
    '''Same as s.lstrip('&lt;').rstrip('&gt;') except it works for Python 2.2.1.'''
    
    if s.startswith('&lt;'):
        s = s[1:]
    if s.endswith('&gt;'):
        s = s[:-1]
    return s</t>
<t tx="ekr.20060410112600.1">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\leoCVS\leo\config\leoSettings.leo
reading settings in C:\prog\leoCVS\leo\src\LeoPy.leo
rst3 plugin: SilverCity not loaded
AttributeError Exception in Tk callback
  Function: &lt;function bindKeyCallback at 0x016F2E70&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x03510288&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2002, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2928, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2992, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2219, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 348, in autoCompleterStateHandler
    self.insertNormalChar(ch,keysym)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 856, in insertNormalChar
    self.calltip(obj)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 455, in calltip
    obj = getattr(string,obj.__name__)
AttributeError: 'module' object has no attribute 'startswith'

================================================
  Event contents:
    char: (
    delta: 57
    height: ??
    keycode: 57
    keysym: parenleft
    keysym_num: 40
    num: ??
    serial: 120644
    state: 1
    time: 16118166
    type: 2
    widget: .20658096.20658616.23344872.23344992.body-pane
    width: ??
    x: 562
    x_root: 740
    y: 38
    y_root: 732

selfInsertCommand: '\n'
selfInsertCommand: '\n'
AttributeError Exception in Tk callback
  Function: &lt;function bindKeyCallback at 0x016F2E70&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x03289C88&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2002, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2928, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2992, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2219, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 348, in autoCompleterStateHandler
    self.insertNormalChar(ch,keysym)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 856, in insertNormalChar
    self.calltip(obj)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 455, in calltip
    obj = getattr(string,obj.__name__)
AttributeError: 'module' object has no attribute 'endswith'

================================================
  Event contents:
    char: (
    delta: 57
    height: ??
    keycode: 57
    keysym: parenleft
    keysym_num: 40
    num: ??
    serial: 123470
    state: 1
    time: 16173496
    type: 2
    widget: .20658096.20658616.23344872.23344992.body-pane
    width: ??
    x: 324
    x_root: 502
    y: 95
    y_root: 789

</t>
<t tx="ekr.20060410112600.2"></t>
<t tx="ekr.20060411101844">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\unitTest.leo
rst3 plugin: SilverCity not loaded
Registered unit-test-command1
found  3 doctests for leoGlobals
found  1 doctests for leoTest
found  5 test routines for leoAtFile
found  4 test routines for leoEditCommands
found  1 test routine for leoFileCommands
found 14 test routines for leoGlobals
EKR: reportlab.__init__
found  5 test routines for multifile
..F.
End of doctests
..........OSError: [Errno 2] No such file or directory: 'xyzzy'

......
test of es_print: ─é
.es_trace:
test of es_trace: ─é
........
End of test routines
..leoID = ekr (in c:\Documents and Settings\Ed)
leoID = ekr (in c:\Documents and Settings\Ed)
...............................................Registered test-registerCommand bound to &lt;Alt+Ctrl+Shift+Z&gt;
...............................
End of new find tests
.............................................
End of tests of @file nodes
.................................
End of general unit tests
....
End of commands tests
.............................F..........................................................................................
..................
opening a new window to test more plugin logic

.........................................................................................................
======================================================================
FAIL: Doctest: leoGlobals.mulderUpdateAlgorithm.stripWhitespaceFromBlankLines
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\python24\lib\doctest.py", line 2152, in runTest
    raise self.failureException(self.format_failure(new.getvalue()))
AssertionError: Failed doctest test for leoGlobals.mulderUpdateAlgorithm.stripWhitespaceFromBlankLines
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 4774, in stripWhitespaceFromBlankLines

----------------------------------------------------------------------
File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 4782, in leoGlobals.mulderUpdateAlgorithm.stripWhitespaceFromBlank
Lines
Failed example:
    g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
Expected:
    ['a\n', '\n', '\n', 'b']
Got:
    ['a\n', '', '', 'b']


======================================================================
FAIL: @test line endings of Linux scripts

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 155, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 20, in ?
  File "&lt;string&gt;", line 14, in checkLinuxLineEndings
AssertionError: Bad Linux line ending in C:\prog\tigris-cvs\leo\src\..\install: cr: 156, nl: 156

----------------------------------------------------------------------
Ran 434 tests in 179.829s

FAILED (failures=2)
&gt;&gt;&gt;</t>
<t tx="ekr.20060411135857">exception executing command
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 884, in clearRecentFiles
    u.afterClearRecentFiles(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 621, in afterClearRecentFiles
    u.pushBead(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 192, in pushBead
    u.setUndoTypes()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 341, in setUndoTypes
    u.cutStack()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 136, in cutStack
    if bunch.kind == 'beforeGroup':
AttributeError: 'Bunch' object has no attribute 'kind'
</t>
</tnodes>
</leo_file>
