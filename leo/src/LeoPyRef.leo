<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="9852" clone_windows="0"/>
<globals body_outline_ratio="0.466594827586">
	<global_window_position top="20" left="239" height="928" width="978"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20060908104329"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20060908104833"><vh>@url Code--&gt; version &amp; signon stuff</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20051113110851,ekr.20031218072017.3419,ekr.20031218072017.3421,ekr.20040303175026.3,ekr.20040303175026.5,ekr.20040303214038,ekr.20040303163330,ekr.20051113110851,ekr.20040303175026.2,ekr.20040310062332.4,ekr.20040303175026.10,ekr.20040306060312,ekr.20040303175026.11,ekr.20040310062332.5,ekr.20031218072017.3426,ekr.20031218072017.3438,ekr.20040303175026.2,ekr.20050921103736,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20060912091922,"
expanded="ekr.20061001060913,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20060904165452"><vh>4.4.2 projects</vh>
<v t="ekr.20060929090247.1"><vh>4.4.2 b1</vh>
<v t="ekr.20060908092306"><vh>Bugs</vh>
<v t="ekr.20060906220124"><vh>Clone-find-all doesn't put focus in minibuffer</vh>
<v t="ekr.20050920085536.62"><vh>getArg</vh>
<v t="ekr.20050928092516"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060908091132"><vh>Fixed undo clone-find-all </vh>
<v t="ekr.20060908095225"><vh>Notes</vh></v>
<v t="ekr.20060128080201"><vh>cloneFindAll</vh></v>
<v t="ekr.20060128075225"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20031218072017.3073"><vh>findAll</vh>
<v t="ekr.20051113110735"><vh>&lt;&lt; create the found node and begin the undo group &gt;&gt;</vh></v>
<v t="ekr.20051113110851" a="M"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803140033.3"><vh>c.setRootPosition</vh></v>
<v t="ekr.20040803140033.1"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20050318085713"><vh>undoGroup</vh></v>
<v t="ekr.20050318085432.6"><vh>redoGroup</vh></v>
<v t="ekr.20031218072017.1193"><vh>c.deleteOutline</vh></v>
<v t="ekr.20050412085112"><vh>undoInsertNode</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20060908104646"><vh>Fixed several bugs in UNL plugin</vh></v>
<v t="ekr.20060912073120"><vh>Fixed crasher with multiple editors</vh>
<v t="ekr.20060912073340"><vh>Report</vh></v>
<v t="ekr.20060912073340.1"><vh>Traceback</vh></v>
<v t="ekr.20060912083415"><vh>What I did</vh></v>
<v t="ekr.20060528113806"><vh>deleteEditor</vh></v>
<v t="ekr.20031218072017.1733"><vh>update (statusLine)</vh></v>
<v t="ekr.20060528100747"><vh>Editors</vh>
<v t="ekr.20060530204135"><vh>recolorWidget</vh></v>
<v t="ekr.20060530210057"><vh>create/select/unselect/Label</vh></v>
<v t="ekr.20060528100747.1"><vh>addEditor</vh>
<v t="ekr.20060528110922"><vh>&lt;&lt; create label and text widgets &gt;&gt;</vh></v>
</v>
<v t="ekr.20060606090542"><vh>setEditorColors</vh></v>
<v t="ekr.20060528170438"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20060528113806"><vh>deleteEditor</vh></v>
<v t="ekr.20060528104554"><vh>onFocusIn</vh>
<v t="ekr.20060605190146"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20060528132829"><vh>selectMainEditor</vh></v>
<v t="ekr.20060528131618"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20041223104933"><vh>class statusLineClass</vh>
<v t="ekr.20031218072017.3961"><vh> ctor</vh></v>
<v t="ekr.20031218072017.3962"><vh>clear</vh></v>
<v t="EKR.20040424153344"><vh>enable, disable &amp; isEnabled</vh></v>
<v t="ekr.20041026132435"><vh>get</vh></v>
<v t="ekr.20041223114744"><vh>getFrame</vh></v>
<v t="ekr.20050120093555"><vh>onActivate</vh></v>
<v t="ekr.20041223111916"><vh>pack &amp; show</vh></v>
<v t="ekr.20031218072017.3963"><vh>put (leoTkinterFrame:statusLineClass)</vh></v>
<v t="ekr.20041223111916.1"><vh>unpack &amp; hide</vh></v>
<v t="ekr.20031218072017.1733"><vh>update (statusLine)</vh></v>
</v>
</v>
<v t="ekr.20060915113237"><vh>Fixed problem with body/outline ratio</vh>
<v t="ekr.20031218072017.2306"><vh>getGlobals</vh></v>
<v t="ekr.20060915124834"><vh>resizePanesToRatio</vh></v>
</v>
<v t="ekr.20060918091042"><vh>Guarded against strange crasher</vh>
<v t="ekr.20031218072017.1999"><vh>toString</vh></v>
</v>
<v t="ekr.20060920145332"><vh>Fixed compare bug</vh>
<v t="ekr.20060920151334"><vh>Report</vh></v>
<v t="ekr.20031218072017.3635"><vh>compare_directories (entry)</vh></v>
</v>
<v t="ekr.20060921113950"><vh>Fixed problem with g.CheckVersion</vh>
<v t="ekr.20031218072017.3097"><vh>CheckVersion </vh>
<v t="ekr.20060921100435"><vh>checkVersion (EKR)</vh></v>
<v t="ekr.20060921100435.1"><vh>oldCheckVersion (Dave Hein)</vh></v>
</v>
<v t="ekr.20031218072017.1856"><vh>setDefaultIcon</vh></v>
<v t="ekr.20031218072017.1936"><vh>isValidPython</vh></v>
</v>
<v t="ekr.20060925080505"><vh>Added force argument to c.set_focus</vh>
<v t="ekr.20060210102201"><vh>c.xWantsFocusNow</vh></v>
<v t="ekr.20060205103842"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20050120092028"><vh>c.xWantsFocus</vh></v>
</v>
<v t="ekr.20060927070439"><vh>Fixed crasher involving CheckVersion</vh>
<v t="ekr.20060921100435"><vh>checkVersion (EKR)</vh></v>
<v t="ekr.20031218072017.1856"><vh>setDefaultIcon</vh></v>
<v t="ekr.20060212061804"><vh>runOpenFileDialog</vh></v>
</v>
<v t="ekr.20060928111850"><vh>Fixed recent bug in c.setHeadSring</vh>
<v t="ekr.20040305223225"><vh>c.setHeadString</vh></v>
</v>
</v>
<v t="ekr.20060905091234"><vh>Code level</vh>
<v t="ekr.20060904114302"><vh>Added OPML support to fileCommands</vh>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file</vh>
<v t="ekr.20040324080359"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040324080359.1"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20060919070145"><vh>&lt;&lt; ensure that filename ends with .opml &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3047"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20050405103712"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20050405103712.1"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20060929103258"><vh>&lt;&lt; create theActualFile &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060905092512.2"><vh>Eliminated v.c and p.c</vh>
<v t="ekr.20060905181927"><vh>Added new methods</vh>
<v t="ekr.20060906134053"><vh>c.findRootPosition New in 4.4.2</vh></v>
<v t="ekr.20060906131836"><vh>c.setRootVnode New in 4.4.2</vh></v>
</v>
<v t="ekr.20060905165341.1"><vh>Unchanged signatures (just removed v.c or other minor changes)</vh>
<v t="ekr.20031218072017.3419" a="M"><vh>v.insertAfter</vh></v>
<v t="ekr.20031218072017.3421" a="M"><vh>v.insertAsNthChild</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040303175026.3" a="M"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.5" a="M"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20051104075904.30"><vh>u.findNodeInTree</vh></v>
<v t="ekr.20040303214038" a="M"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330" a="M"><vh>p.setDirty</vh></v>
<v t="EKR.20040506075328.2"><vh>perfectImport</vh>
<v t="ekr.20040717112739"><vh>&lt;&lt; about this algorithm &gt;&gt;</vh></v>
<v t="ekr.20040716065356"><vh>&lt;&lt; clear all dirty bits &gt;&gt;</vh></v>
<v t="ekr.20040716064333"><vh>&lt;&lt; Assign file indices  &gt;&gt;</vh></v>
<v t="ekr.20040716064333.1"><vh>&lt;&lt; Write root's tree to to string s &gt;&gt;</vh></v>
<v t="ekr.20040717132539"><vh>&lt;&lt; put the corrected fat lines in a new node &gt;&gt;</vh></v>
<v t="ekr.20040717113036"><vh>&lt;&lt; correct root's tree using write_lines &gt;&gt;</vh></v>
<v t="ekr.20040718035658"><vh>&lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</vh>
<v t="ekr.20040718045423"><vh>&lt;&lt; dump the files &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040803072955.21"><vh>tkTree.injectCallbacks</vh>
<v t="ekr.20040803072955.22"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20040803072955.23"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20040803072955.24"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20040803072955.25"><vh>OnHyperLinkLeave</vh></v>
</v>
</v>
</v>
<v t="ekr.20060907085253"><vh>Removed p.allNodes_iter</vh>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__ (p.allNodesIter)</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="EKR.20040529091232"><vh>c.all_positions_iter == allNodes_iter</vh>
<v t="ekr.20060907085906.1"><vh>__init__ &amp; __iter__ (p.allNodesIter)</vh></v>
<v t="ekr.20060907085906.2"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20060906130502"><vh>Removed p arg</vh>
<v t="ekr.20040303175026.8"><vh>p.clone (does not need any args)</vh></v>
<v t="ekr.20060905104612"><vh>Found: .clone</vh>
<v t="ekr.20031218072017.1762"><vh>c.clone</vh></v>
<v t="ekr.20031218072017.2946"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="ekr.20031218072017.2948"><vh>c.dragCloneAfter</vh></v>
<v t="ekr.20051113110851" a="M"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060905165341.2"><vh>Removed c arg</vh>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20040303175026.2" a="M"><vh>p.doDelete</vh></v>
<v t="ekr.20040310062332.4" a="M"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040303175026.10" a="M"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312" a="M"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20040303175026.11" a="M"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040310062332.5" a="M"><vh>p.unlink</vh></v>
<v t="ekr.20051104075904.35"><vh>replaceOutline (leoTest)</vh></v>
<v t="ekr.20031218072017.3344"><vh>v.__init__</vh></v>
<v t="ekr.20031218072017.3426" a="M"><vh>v.linkAsRoot</vh></v>
<v t="ekr.20031218072017.3422"><vh>v.moveToRoot</vh></v>
<v t="ekr.20031218072017.3438" a="M"><vh>v.unlink</vh></v>
</v>
<v t="ekr.20060905114409"><vh>Added c arg</vh>
<v t="ekr.20031218072017.1385"><vh>g.findReference</vh></v>
</v>
<v t="ekr.20060905172505.1"><vh>Converted p.x(c) to c.x(p)</vh>
<v t="ekr.20040315032503"><vh>c.appendStringToBody</vh></v>
<v t="ekr.20060906211138"><vh>c.clearMarked</vh></v>
<v t="ekr.20040306220230.1"><vh>c.edit_widget</vh></v>
<v t="ekr.20031218072017.4146"><vh>c.lastVisible</vh></v>
<v t="ekr.20040307104131.3"><vh>c.positionExists</vh></v>
<v t="ekr.20040305223522"><vh>c.setBodyString</vh></v>
<v t="ekr.20060906211138.1"><vh>c.setMarked</vh></v>
<v t="ekr.20031218072017.3404"><vh>c.trimTrailingLines</vh></v>
<v t="ekr.20040305222924.1"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
</v>
<v t="ekr.20060905103748"><vh>Removed p and v methods using v.c or p.c</vh>
<v t="ekr.20040312015705"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20040803140033.4"><vh>p.isCurrentPosition</vh></v>
<v t="ekr.20040803140033.5"><vh>p.isRootPosition</vh></v>
<v t="ekr.20060905090957"><vh>removed findRoot methods</vh>
<v t="ekr.20031218072017.3381"><vh>v.findRoot (4.2)</vh></v>
<v t="ekr.20040306215548"><vh>p.findRoot</vh></v>
</v>
<v t="ekr.20060905121515"><vh>v.clearDirtyJoined</vh></v>
<v t="ekr.20031218072017.3379"><vh>v.currentVnode (and c.currentPosition 4.2)</vh></v>
</v>
</v>
<v t="ekr.20060907101636"><vh>Call c.findRootPosition in c.setCurrentPosition</vh>
<v t="ekr.20060906134053"><vh>c.findRootPosition New in 4.4.2</vh></v>
<v t="ekr.20040803140033"><vh>c.currentPosition</vh></v>
<v t="ekr.20040803140033.3"><vh>c.setRootPosition</vh></v>
<v t="ekr.20031218072017.2997"><vh>c.selectPosition</vh></v>
<v t="ekr.20040803140033.2"><vh>c.rootPosition</vh></v>
<v t="ekr.20040803140033.1"><vh>c.setCurrentPosition</vh></v>
</v>
<v t="ekr.20060908075800.1"><vh>Removed redundant calls to c.findRootPosition</vh></v>
<v t="ekr.20060908115325"><vh>Reviewed p.deleteLinksInTree</vh>
<v t="ekr.20040303175026.2" a="M"><vh>p.doDelete</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20060913082305"><vh>Fixed problem with t.hash</vh>
<v t="ekr.20060908205857"><vh>t.__hash__ (only for zodb)</vh></v>
<v t="ekr.20060910100316"><vh>v.__hash__ (only for zodb)</vh></v>
</v>
<v t="ekr.20060920180657"><vh>Investigated removing t.vnodeList (not a good idea)</vh></v>
</v>
<v t="ekr.20060912093334"><vh>New features</vh>
<v t="ekr.20060911160213"><vh>Added multiple editor commands to Cmds menu</vh>
<v t="ekr.20060912093334.1"><vh>Request</vh></v>
</v>
<v t="ekr.20060913090832"><vh>Created convenience methods for zodb scripts</vh>
<v t="ekr.20060913090832.1"><vh>g.init_zodb</vh></v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20060913091805.1"><vh>v.detach</vh></v>
</v>
<v t="ekr.20060923043120"><vh>Improved help-for-command</vh></v>
<v t="ekr.20060923065819"><vh>Put cursor/focus/pane/scroll/selection commands in Cmds menu</vh>
<v t="ekr.20060924124119"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20050921103736" a="M"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20060924161901"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20060923060822"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20060924120752"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20060923060822.1"><vh>defineCmdsMenuScrollTable</vh></v>
</v>
<v t="ekr.20060926085352"><vh>Improved  quick-find commands</vh>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20051218122116"><vh>moveToHelper</vh></v>
<v t="ekr.20060417194232"><vh>find (quick)</vh>
<v t="ekr.20060925151926"><vh>backward/findCharacter &amp; helper</vh>
<v t="ekr.20060417194232.1"><vh>findCharacterHelper</vh></v>
</v>
<v t="ekr.20060417194232.2"><vh>findWord</vh></v>
</v>
<v t="ekr.20051218121447"><vh>moveWordHelper</vh></v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20060420144640"><vh>iSearchBackspace</vh></v>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
<v t="ekr.20060203072636"><vh>endSearch</vh></v>
</v>
</v>
<v t="ekr.20041228084018.5"><vh>Finished/retired zodb plugin</vh>
<v t="ekr.20060913084832"><vh>@ulr http://www.zope.org/Wikis/ZODB/guide/zodb.html</vh></v>
<v t="ekr.20060913085557"><vh>Scripting using zodb</vh></v>
</v>
<v t="ekr.20060923043845"><vh>Improved how Leo works w/o the mousre</vh>
<v t="ekr.20060924173041"><vh>What I did</vh></v>
<v t="ekr.20051218174113"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20060926213642"><vh>capitalizeMinibufferMenuName</vh></v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3753"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20050711091931"><vh>defineEditMenuEditCursorTable (not ready yet)</vh></v>
<v t="ekr.20031218072017.3754"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20031218072017.3755"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3759"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20031218072017.3760"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20031218072017.3761"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20031218072017.3762"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20031218072017.3763"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20031218072017.3764"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20031218072017.3765"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20031218072017.3766"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20050921103230"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20060912093104"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060924124119"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20060923060822"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20060924120752"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20060923060822.1"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20060924161901"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20060926161940"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20031218072017.3773"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20031218072017.3774"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20060928054124"><vh>Increased speed of arrow keys</vh>
<v t="ekr.20031218072017.2996"><vh>selectVisNext</vh></v>
<v t="ekr.20031218072017.2995"><vh>selectVisBack</vh></v>
</v>
<v t="ekr.20060928062431.1"><vh>Sparse find command</vh>
<v t="ekr.20050920084036.189"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
<v t="ekr.20060928062431"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20031218072017.3091"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060928110801"><vh>Allow -- comments in @url nodes</vh>
<v t="ekr.20031218072017.2312"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20031218072017.2313"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2314"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2315"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060929090247"><vh>4.4.2 b2</vh>
<v t="ekr.20060929091051"><vh>Bugs</vh>
<v t="ekr.20060927073203"><vh>Fixed rst3 problem</vh></v>
<v t="ekr.20060929133002"><vh>Fixed apparent bug in pmw</vh></v>
</v>
<v t="ekr.20060929141921"><vh>Features</vh>
<v t="ekr.20060929141750"><vh>Improved the mod_scripting plugin</vh></v>
<v t="ekr.20060929090247.2"><vh>rst3 plugin now register rst3-process-tree command</vh></v>
<v t="ekr.20060928082153"><vh>Completed support for myLeoSettings.leo</vh>
<v t="ekr.20041117083857"><vh>initSettingsFiles</vh></v>
<v t="ekr.20031218072017.2943"><vh>openLeoSettings and openMyLeoSettings</vh></v>
<v t="ekr.20041117093246"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20041117085625"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20041120064303"><vh>g.app.config.readSettingsFiles</vh></v>
<v t="ekr.20041117083857.1"><vh>g.app.config.readSettings</vh></v>
<v t="ekr.20051013161232"><vh>g.app.config.updateSettings</vh></v>
</v>
</v>
<v t="ekr.20060930110140"><vh>Added settings for all mod_scripting switches</vh></v>
</v>
<v t="ekr.20060929141921.1"><vh>Tests</vh>
<v t="ekr.20060929100150"><vh>Tested Python 2.5 exception reporting</vh>
<v t="ekr.20031218072017.3111"><vh>es_event_exception</vh></v>
<v t="ekr.20040731204831"><vh>getLastTracebackFileAndLineNumber</vh></v>
<v t="ekr.20031218072017.3112"><vh>es_exception &amp; test</vh>
<v t="ekr.20050220030850"><vh>test_g_es_exception</vh></v>
</v>
<v t="ekr.20060624085200"><vh>g.handleScriptException</vh>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060930125206"><vh>Made writing .leo files faster</vh>
<v t="EKR.20040526202501"><vh>putUnknownAttributes &amp; helper</vh>
<v t="ekr.20050418161620.2"><vh>putUaHelper</vh></v>
</v>
<v t="ekr.20031218072017.1577"><vh>putTnode</vh></v>
<v t="ekr.20031218072017.1579"><vh>putVnodes &amp; helpers</vh>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Set gnx = tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Append attribute bits to attrs &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Append tnodeList and unKnownAttributes to attrs&gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2002"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20040701065235.2"><vh>putDescendentAttributes</vh></v>
<v t="EKR.20040627113418"><vh>putDescendentUnknownAttributes</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060927172440"><vh>To do before 4.4.2 final</vh>
<v t="ekr.20061001060913.1"><vh>To do first</vh>
<v t="ekr.20060930172926"><vh>Make sure unit tests test tnodeList, etc.</vh></v>
<v t="ekr.20061001060913.2"><vh>install sax read code into Leo's core</vh></v>
<v t="ekr.20060929100640.1"><vh>Add setting: @bool outline_pane_has_initial_focus</vh></v>
<v t="ekr.20060930085556"><vh>Add setting: @bool collapse_nodes_during_finds = True</vh></v>
<v t="ekr.20060929084830.1"><vh>Suppress redraw on all applicable outline:goto commands</vh></v>
</v>
<v t="ekr.20060929122217.2"><vh>Bugs: 5</vh>
<v t="ekr.20060927173836.1"><vh>Disable calltips in @nocolor sections</vh></v>
<v t="ekr.20060930111450"><vh>Make yank/kill work in minibuffer</vh></v>
<v t="ekr.20060927173836.6"><vh>Don't abort mode if there are problems with bindings</vh></v>
<v t="ekr.20060927100500.1"><vh>Fix bugs in new colorizer</vh></v>
<v t="ekr.20060824112937.1"><vh>Fix unicode problem with double-click word St√©phane</vh>
<v t="ekr.20051218121447"><vh>moveWordHelper</vh></v>
<v t="ekr.20060131084938"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20031218072017.3978"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="ekr.20060203114017"><vh>f.setMinibufferBindings</vh></v>
<v t="ekr.20040803072955.87"><vh>onHeadlineClick</vh></v>
<v t="ekr.20040803072955.105"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20040803072955.106"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh>
<v t="ekr.20060131173440"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
<v t="ekr.20060131173440.2"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
<v t="ekr.20060307080642"><vh>&lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060920150119"><vh>Fix undo problems (important)</vh></v>
</v>
<v t="ekr.20061001060913" a="E"><vh>Minor bugs 2:</vh>
<v t="ekr.20060928194335"><vh>Fix bug: closing a window after removing a script button can crash</vh></v>
<v t="ekr.20060930110925"><vh>Fix arrow keys (if possible)</vh></v>
</v>
<v t="ekr.20060929141941"><vh>Docs</vh>
<v t="ekr.20060920190138"><vh>Document tnodeList, vnodeList and make better unit tests</vh></v>
</v>
<v t="ekr.20060912091922" a="M"><vh>Test all plugins</vh>
<v t="ekr.20060914085747"><vh>Have plugin-specific unit tests</vh></v>
<v t="ekr.20060914130034"><vh>Tested, no unit tests</vh></v>
<v t="ekr.20060914090250"><vh>To test next</vh></v>
<v t="ekr.20060914085747.1"><vh>To test</vh></v>
</v>
</v>
<v t="ekr.20061001060913.1" a="TV"><vh>To do first</vh>
<v t="ekr.20060930172926"><vh>Make sure unit tests test tnodeList, etc.</vh></v>
<v t="ekr.20061001060913.2"><vh>install sax read code into Leo's core</vh></v>
<v t="ekr.20060929100640.1"><vh>Add setting: @bool outline_pane_has_initial_focus</vh></v>
<v t="ekr.20060930085556"><vh>Add setting: @bool collapse_nodes_during_finds = True</vh></v>
<v t="ekr.20060929084830.1"><vh>Suppress redraw on all applicable outline:goto commands</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"
marks="ekr.20060919110638.44,ekr.20060919110638.8,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"
marks="ekr.20031218072017.3419,ekr.20031218072017.3421,ekr.20031218072017.3426,ekr.20031218072017.3438,ekr.20031218072017.3390,ekr.20040306220634.9,ekr.20040303214038,ekr.20040303163330,ekr.20040303175026.2,ekr.20040303175026.3,ekr.20040303175026.5,ekr.20040303175026.10,ekr.20040306060312,ekr.20040303175026.11,ekr.20040310062332.4,ekr.20040310062332.5,"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"
marks="ekr.20051113110851,"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"
marks="ekr.20050921103736,"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040424153344">def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.widgetWantsFocus(t)
    self.enabled = True
        
def isEnabled(self):
    return self.enabled</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040506075328.2">def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    __pychecker__ = 'maxlines=500'
    
    &lt;&lt; about this algorithm &gt;&gt;
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        &lt;&lt; clear all dirty bits &gt;&gt;
    &lt;&lt; Assign file indices &gt;&gt;
    &lt;&lt; Write root's tree to to string s &gt;&gt;

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            &lt;&lt; put the corrected fat lines in a new node &gt;&gt;
        &lt;&lt; correct root's tree using write_lines &gt;&gt;
    if verify:
        &lt;&lt; verify that writing the tree would produce the original file &gt;&gt;
</t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040526202501">def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        return ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])</t>
<t tx="EKR.20040529091232"># New in Leo 4.4.2 (It used to be defined in terms of p.allNodes_iter.)

class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    c = self
    return self.allNodes_iter_class(c,copy)

all_positions_iter = allNodes_iter</t>
<t tx="EKR.20040612215018">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

# Print surrounding lines.
i = max(0,n-2)
j = min(n+2,len(lines))
while i &lt; j:
    ch = g.choose(i==n-1,'*',' ')
    s = "%s line %d: %s" % (ch,i+1,lines[i])
    g.es(s,newline=False)
    i += 1
</t>
<t tx="EKR.20040627113418">def putDescendentUnknownAttributes (self,p):

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                tnodes.append((p,t),)
    
    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodes:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.
            for key in d.keys():
                try: pickle.dumps(d[key],bin=True)
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
            data.append((t,d),)
            
    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d
    
    if 0:
        print "resultDict"
        for key in resultDict:
            print ; print key,resultDict[key]
        
    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            s = pickle.dumps(resultDict,bin=True)
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            return field
        except pickle.PicklingError:
            g.trace("can't happen",color="red")
            return ''
    else:
        return ''
</t>
<t tx="ekr.20031218072017.839">def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &amp;U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &amp;R reserved for Redo
        ("-",None),
        ("Cu&amp;t",f.OnCutFromMenu), 
        ("Cop&amp;y",f.OnCopyFromMenu),
        ("&amp;Paste",f.OnPasteFromMenu),
        ("&amp;Delete",c.editCommands.backwardDeleteCharacter),
        ("Select &amp;All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
</t>
<t tx="ekr.20031218072017.892"># New in Leo 4.4.2: make stack default to None.

def __init__ (self,v,stack=None,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    # assert(v is None or v.t)
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # if g.app.tracePositions and trace: g.trace(g.callers())
    
    # Note: __getattr__ implements p.t.</t>
<t tx="ekr.20031218072017.1193">def deleteOutline (self,event=None,op_name="Delete Node"):
    
    """Deletes the selected outline."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
       undoData = u.beforeDeleteNode(p)
       dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
       p.doDelete()
       c.selectPosition(newNode)
       c.setChanged(True)
       u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
</t>
<t tx="ekr.20031218072017.1385">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
</t>
<t tx="ekr.20031218072017.1577">def putTnode (self,t):
    
    # New in Leo 4.4.2 b2: call put just once.
    gnx = g.app.nodeIndices.toString(t.fileIndex)
    ua = hasattr(t,'unknownAttributes') and self.putUnknownAttributes(t) or ''
    body = t.bodyString and xml.sax.saxutils.escape(t.bodyString) or ''
    self.put('&lt;t tx="%s"%s&gt;%s&lt;/t&gt;\n' % (gnx,ua,body))</t>
<t tx="ekr.20031218072017.1579">def putVnodes (self):

    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("&lt;vnodes&gt;\n")

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            if not p.isAtIgnoreNode(): # New in Leo 4.4.2 b2 An optimization:
                self.putVnode(p) # Write the next top-level node.

    self.put("&lt;/vnodes&gt;\n")</t>
<t tx="ekr.20031218072017.1733">def update (self):
    
    c = self.c ; w = c.frame.bodyCtrl ; lab = self.labelWidget

    if g.app.killed or not self.isVisible:
        return

    index = w.index("insert")
    row,col = g.app.gui.getindex(w,index)

    if col &gt; 0:
        s = w.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)
    
    s = "line %d, col %d " % (row,col)
    # Important: this does not change the focus because labels never get focus.
    lab.configure(text=s)
    self.lastRow = row
    self.lastCol = col
</t>
<t tx="ekr.20031218072017.1762">def clone (self,event=None):
    
    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone()
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
</t>
<t tx="ekr.20031218072017.1856">def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        # g.trace(repr(version),g.CheckVersion(version,"8.4.3"))
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32":
            
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20031218072017.1863">def putVnode (self,p):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    forceWrite = not isThin or (isThin and isOrphan)
    &lt;&lt; Set gnx = tnode index &gt;&gt;
    attrs = []
    &lt;&lt; Append attribute bits to attrs &gt;&gt;
    &lt;&lt; Append tnodeList and unKnownAttributes to attrs &gt;&gt;
    attrs = ''.join(attrs)
    v_head = '&lt;v t="%s"%s&gt;&lt;vh&gt;%s&lt;/vh&gt;' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than these calls.
    # fc.put('&lt;v t="') ; fc.put(gnx) ; fc.put('"')
    # fc.put(attrs)
    # fc.put('&gt;&lt;vh&gt;')
    # fc.put(xml.sax.saxutils.escape(p.v.headString()or''))
    # fc.put('&lt;/vh&gt;')
    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            if not p.isAtIgnoreNode(): # New in Leo 4.4.2 b2 An optimization:
                fc.putVnode(p)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent()
        fc.put('&lt;/v&gt;\n')
    else:
        fc.put('%s&lt;/v&gt;\n' % v_head) # Call put only once.
        # fc.put('&lt;/v&gt;\n')</t>
<t tx="ekr.20031218072017.1864">if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
</t>
<t tx="ekr.20031218072017.1865"># attr = ''.join([
    # v.isExpanded() and 'E' or '',
    # v.isMarked()   and 'M' or '',
    # v.isOrphan()   and 'O' or '',
    # p.equal(self.topPosition) and 'T' or '',    # was a bottleneck
    # p.equal(self.currentPosition) and 'V' or '' # was bottleneck.
# ])

# These string catenations are benign because they rarely happen.
attr = ""
if v.isExpanded(): attr += "E"
if v.isMarked():   attr += "M"
if v.isOrphan():   attr += "O"

# No longer a bottleneck now that we use p.equal rather than p.__cmp__
# Almost 30% of the entire writing time came from here!!!
if p.equal(self.topPosition):     attr += "T" # was a bottleneck
if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr:
    attrs.append(' a="%s"' % (attr))</t>
<t tx="ekr.20031218072017.1936">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # g.trace(version)
        ok = g.CheckVersion(version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20031218072017.1999">def toString (self,index,removeDefaultId=False):
    
    """Convert a gnx (a tuple) to its string representation"""

    try:
        theId,t,n = index
        if removeDefaultId and theId == self.defaultId:
            theId = ""
        if not n: # None or ""
            return "%s.%s" % (theId,t)
        else:
            return "%s.%s.%d" % (theId,t,n)
    except TypeError:
        g.trace('unusual gnx',repr(index))
        return repr(index)</t>
<t tx="ekr.20031218072017.2002">def putTnodeList (self,v):
    
    """Put the tnodeList attribute of a tnode."""
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

    fc = self ; nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        for t in tnodeList:
            try: # Will fail for None or any pre 4.1 file index.
                theId,time,n = t.fileIndex
            except:
                g.trace("assigning gnx for ",v,t)
                gnx = nodeIndices.getNewIndex()
                v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
        s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        return ' tnodeList="%s"' % (s)
    else:
        return ''</t>
<t tx="ekr.20031218072017.2306">def getGlobals (self):

    if self.getOpenTag("&lt;globals"):
        # &lt;globals/&gt; seen: set reasonable defaults:
        self.ratio = 0.5
        y,x,h,w = 50,50,500,700
    else:
        self.getTag("body_outline_ratio=\"")
        self.ratio = self.getDouble() ; self.getDquote() ; self.getTag("&gt;")

        self.getTag("&lt;global_window_position")
        y,x,h,w = self.getPosition()
        self.getTag("/&gt;")

        self.getTag("&lt;global_log_window_position")
        self.getPosition()
        self.getTag("/&gt;") # no longer used.

        self.getTag("&lt;/globals&gt;")

    # Redraw the window before writing into it.
    self.frame.setTopGeometry(w,h,x,y)
    self.frame.deiconify()
    self.frame.lift()
    self.frame.update()
</t>
<t tx="ekr.20031218072017.2312">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            &lt;&lt; stop the url after any whitespace &gt;&gt;
        # g.trace(url)
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        g.doHook("@url2",c=c,p=p,v=p)
</t>
<t tx="ekr.20031218072017.2313"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
</t>
<t tx="ekr.20031218072017.2314">if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
</t>
<t tx="ekr.20031218072017.2315">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
 z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
</t>
<t tx="ekr.20031218072017.2943">def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')
    
def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')
    
def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))
</t>
<t tx="ekr.20031218072017.2946">def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    
    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone &amp; dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20031218072017.2948">def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20031218072017.2995"># This has an up arrow for a control key.

def selectVisBack (self,event=None):
    
    '''Select the visible node preceding the presently selected node.'''

    c = self ; current = c.currentPosition()
    if not current: return

    p = current.visBack()
    if p:
        redraw = not p.isVisible()
        if not redraw: c.frame.tree.setSelectedLabelState(current)
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate(redraw)
    c.treeWantsFocusNow()
</t>
<t tx="ekr.20031218072017.2996">def selectVisNext (self,event=None):
    
    '''Select the visible node following the presently selected node.'''

    c = self ; current = c.currentPosition()
    if not current: return
    
    p = current.visNext()
    if p:
        redraw = not p.isVisible()
        if not redraw: c.frame.tree.setSelectedLabelState(current)
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate(redraw)

    c.treeWantsFocusNow()
</t>
<t tx="ekr.20031218072017.2997">def selectPosition(self,p,updateBeadList=True):
    
    """Select a new position."""

    c = self
    
    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)
    
    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
</t>
<t tx="ekr.20031218072017.3046">def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    self.putCount = 0
    self.toString = toString
    self.assignFileIndices()
    if not outlineOnlyFlag or toOPML:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        if toOPML:
            &lt;&lt; ensure that filename ends with .opml &gt;&gt;
        self.outputFile = cStringIO.StringIO()
        &lt;&lt; create theActualFile &gt;&gt;
        # t1 = time.clock()
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        # t2 = time.clock()
        s = self.outputFile.getvalue()
        # g.trace(self.leo_file_encoding)
        if toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            &lt;&lt; delete backup file &gt;&gt;
            # t3 = time.clock()
            # g.es_print('len %d, putCount %d' % (len(s),self.putCount)) # 'put',t2-t1,'write&amp;close',t3-t2)
        self.outputFile = None
        self.toString = False
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        if backupName:
            &lt;&lt; delete fileName &gt;&gt;
            &lt;&lt; rename backupName to fileName &gt;&gt;
        self.toString = False
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20031218072017.3047">backupName = None

# rename fileName to fileName.bak if fileName exists.
if not toString and g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False</t>
<t tx="ekr.20031218072017.3048">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
</t>
<t tx="ekr.20031218072017.3073">def findAll(self):

    c = self.c ; t = self.s_ctrl ; u = c.undoer
    gui = g.app.gui ; undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if not pos: break
        count += 1
        line = gui.getLineContainingIndex(t,pos)
        self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            if not clones:
                &lt;&lt; create the found node and begin the undo group &gt;&gt;
            &lt;&lt; create a clone of p under the find node &gt;&gt;
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)
          
    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
</t>
<t tx="ekr.20031218072017.3091">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible()
    c.beginUpdate()
    try:
        # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
        for p in c.allNodes_iter():
            if not p.isAncestorOf(self.p):
                p.contract()
                redraw = True
        for p in self.p.parents_iter():
            if not p.isExpanded():
                p.expand()
                redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    # g.trace(id(t),pos,newpos)
    c.widgetWantsFocusNow(t)
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    # c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20031218072017.3097"></t>
<t tx="ekr.20031218072017.3111">def es_event_exception (eventName,full=False):

    g.es("exception handling ", eventName, " event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es(i)
        
    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()
</t>
<t tx="ekr.20031218072017.3112">def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch &gt; 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch &gt; 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
</t>
<t tx="ekr.20031218072017.3344">def __init__ (self,t):

    assert(t)
    
    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits
    
    # Structure links.
    self._parent = self._next = self._back = None</t>
<t tx="ekr.20031218072017.3379">if 0:
    def currentPosition (self):
        return self.c.currentPosition()
            
    def currentVnode (self):
        return self.c.currentVnode()</t>
<t tx="ekr.20031218072017.3381">def findRoot (self):
    
    return self.c.rootPosition()
</t>
<t tx="ekr.20031218072017.3404">def trimTrailingLines (self,p):

    """Trims trailing blank lines from a node.
    
    It is surprising difficult to do this during Untangle."""

    c = self
    body = p.bodyString()
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i &gt;= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        c.setBodyString(p,body)
        # Don't set the dirty bit: it would just be annoying.</t>
<t tx="ekr.20031218072017.3419">def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
</t>
<t tx="ekr.20031218072017.3421">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
</t>
<t tx="ekr.20031218072017.3422">def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.
    
    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v</t>
<t tx="ekr.20031218072017.3426">def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v</t>
<t tx="ekr.20031218072017.3438">def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3635"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
    
    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)
    
    if dir1 == dir2:
        return self.show("Please pick distinct directories.")
    try:
        list1 = os.listdir(dir1)
    except:
        return self.show("invalid directory:" + dir1)
    try:
        list2 = os.listdir(dir2)
    except:
        return self.show("invalid directory:" + dir2)
        
    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok: return None

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and missing lists.
    yes = [] ; no = [] ; missing1 = [] ; missing2 = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                missing1.append(f1)
        else:
            missing1.append(f1)
    for f2 in files2:
        head,f1 = g.os_path_split(f2)
        if f1 not in files1:
            missing2.append(f1)
    
    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found 1 ------",missing1),
        ("----- not found 2 ------",missing2),
    ):
        self.show(kind)
        for f in files:
            self.show(f)
    
    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None

    return None # To keep pychecker happy.</t>
<t tx="ekr.20031218072017.3752">def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20031218072017.3753">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20031218072017.3754">def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &amp;Section",c.extractSection),
        ("Extract &amp;Names",c.extractSectionNames),
        ("&amp;Extract",c.extract),
        ("-",None,None),
        ("Convert All B&amp;lanks",c.convertAllBlanks),
        ("Convert All T&amp;abs",c.convertAllTabs),
        ("Convert &amp;Blanks",c.convertBlanks),
        ("Convert &amp;Tabs",c.convertTabs),
        ("Insert Body Time/&amp;Date",c.insertBodyTime),
        ("&amp;Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&amp;Indent",c.indentBody),
        ("&amp;Unindent",c.dedentBody),
        ("&amp;Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
</t>
<t tx="ekr.20031218072017.3755">def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &amp;Headline",c.editHeadline),
        ("&amp;End Edit Headline",f.endEditLabelCommand),
        ("&amp;Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&amp;Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]
</t>
<t tx="ekr.20031218072017.3756">def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,t,u,w,x
        '&amp;open-find-tab',
        '&amp;hide-find-tab',
        'search-&amp;with-present-options',
        '-',
        'find-tab-find-&amp;next',
        'find-tab-find-&amp;prev',
        'find-tab-&amp;change',
        'find-with-present-op&amp;tions',
        'find-tab-find-&amp;all',
        'clone-fi&amp;nd-all',
        'find-tab-change-a&amp;ll',
        '-',
        '&amp;find-character',
        'find-character-extend-&amp;selection',
        '&amp;backward-find-character',
        'backward-find-character-&amp;extend-selection',
        '-',
        '&amp;isearch-forward',
        'isea&amp;rch-backward',
        'isearch-forward-rege&amp;xp',
        'isearch-backward-regex&amp;p',
        '-',
        '&amp;query-replace',
        'q&amp;uery-replace-regex',
    ]

# find-character-reverse            = Alt-P
# isearch-with-present-options      = None</t>
<t tx="ekr.20031218072017.3757">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.toggleShowInvisibles),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20031218072017.3758">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20031218072017.3759">def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&amp;New",c.new),
        ("&amp;Open...",c.open),
    ]
</t>
<t tx="ekr.20031218072017.3760">def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&amp;Close",c.close),
        ("&amp;Save",c.save),
        ("Save &amp;As",c.saveAs),
        ("Save To",c.saveTo), # &amp;Tangle
        ("Re&amp;vert To Saved",c.revert), # &amp;Read/Write
    ]
</t>
<t tx="ekr.20031218072017.3761">def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&amp;Read Outline Only",c.readOutlineOnly),
        ("Read @file &amp;Nodes",c.readAtFileNodes),
        ("Write &amp;Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &amp;Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &amp;Outline Only",fc.writeOutlineOnly),
        ("&amp;Write @file Nodes",fc.writeAtFileNodes),
    ]
</t>
<t tx="ekr.20031218072017.3762">def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &amp;All",c.tangleAll),
        ("Tangle &amp;Marked",c.tangleMarked),
        ("&amp;Tangle",c.tangle),
    ]
</t>
<t tx="ekr.20031218072017.3763">def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &amp;All",c.untangleAll),
        ("Untangle &amp;Marked",c.untangleMarked),
        ("&amp;Untangle",c.untangle),
    ]
</t>
<t tx="ekr.20031218072017.3764">def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&amp;file",c.importAtFile),
        ("Import To @&amp;root",c.importAtRoot),
        ("Import &amp;CWEB Files",c.importCWEBFiles),
        ("Import &amp;noweb Files",c.importNowebFiles),
        ("Import Flattened &amp;Outline",c.importFlattenedOutline),
    ]
</t>
<t tx="ekr.20031218072017.3765">def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &amp;Headlines",c.exportHeadlines),
        ("Outline To &amp;CWEB",c.outlineToCWEB),
        ("Outline To &amp;Noweb",c.outlineToNoweb),
        ("&amp;Flatten Outline",c.flattenOutline),
        ("&amp;Remove Sentinels",c.removeSentinels),
        ("&amp;Weave",c.weave),
    ]
</t>
<t tx="ekr.20031218072017.3766">def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&amp;xit",g.app.onQuit),
    ]
</t>
<t tx="ekr.20031218072017.3767">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20031218072017.3768">def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&amp;ut Node",c.cutOutline),
        ("C&amp;opy Node",c.copyOutline),
        ("&amp;Paste Node",c.pasteOutline),
        ("Pas&amp;te Node As Clone",c.pasteOutlineRetainingClones),
        ("&amp;Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&amp;Insert Node",c.insertHeadline),
        ("&amp;Clone Node",c.clone),
        ("Sort Childre&amp;n",c.sortChildren), # Conflicted with Hoist.
        ("&amp;Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&amp;Hoist",c.hoist),
        ("D&amp;e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20031218072017.3769">def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&amp;Contract All",c.contractAllHeadlines),
        ("Contract &amp;Node",c.contractNode),
        ("Contract &amp;Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&amp;rev Level",c.expandPrevLevel),
        ("Expand N&amp;ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &amp;1",c.expandLevel1),
        ("Expand To Level &amp;2",c.expandLevel2),
        ("Expand To Level &amp;3",c.expandLevel3),
        ("Expand To Level &amp;4",c.expandLevel4),
        ("Expand To Level &amp;5",c.expandLevel5),
        ("Expand To Level &amp;6",c.expandLevel6),
        ("Expand To Level &amp;7",c.expandLevel7),
        ("Expand To Level &amp;8",c.expandLevel8),
        ("-",None),
        ("Expand &amp;All",c.expandAllHeadlines),
        ("Expand N&amp;ode",c.expandNode),
    ]
</t>
<t tx="ekr.20031218072017.3770">def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &amp;Down",c.moveOutlineDown),
        ("Move &amp;Left",c.moveOutlineLeft),
        ("Move &amp;Right",c.moveOutlineRight),
        ("Move &amp;Up",c.moveOutlineUp),
        ("-",None),
        ("&amp;Promote",c.promote),
        ("&amp;Demote",c.demote),
    ]
</t>
<t tx="ekr.20031218072017.3771">def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&amp;Mark",c.markHeadline),
        ("Mark &amp;Subheads",c.markSubheads),
        ("Mark Changed &amp;Items",c.markChangedHeadlines),
        ("Mark Changed &amp;Roots",c.markChangedRoots),
        ("Mark &amp;Clones",c.markClones),
        ("&amp;Unmark All",c.unmarkAll),
    ]
</t>
<t tx="ekr.20031218072017.3772">def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]
</t>
<t tx="ekr.20031218072017.3773">def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&amp;Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &amp;Active Pane",f.toggleActivePane),
        ("Toggle &amp;Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&amp;de",f.cascade),
        ("&amp;Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &amp;Compare Window",c.openCompareWindow),
        ("Open &amp;Python Window",c.openPythonWindow),
    ]
</t>
<t tx="ekr.20031218072017.3774">def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTable = [
        # &amp;: a,b,c,d,f,h,l,m,n,o,p,r,s,t,u
        ("&amp;About Leo...",           c.about),
        ("Online &amp;Home Page",       c.leoHome),
        ("Open Online &amp;Tutorial",   c.leoTutorial),
        ("Open &amp;Users Guide",       c.leoUsersGuide),
        '-',
        ("Open Leo&amp;Docs.leo",       c.leoDocumentation),
        ("Open Leo&amp;Plugins.leo",    c.openLeoPlugins),
        ("Open Leo&amp;Settings.leo",   c.openLeoSettings),
        ("Open &amp;myLeoSettings.leo", c.openMyLeoSettings),
        '-',
        'he&amp;lp',
        'help-for-&amp;command',
        '-',
        '&amp;apropos-autocompletion',
        'apropos-&amp;bindings',
        'apropos-&amp;find-commands',
        '-',
        'pri&amp;nt-bindings',
        'print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3961">def __init__ (self,c,parentFrame):
    
    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("&lt;Button-1&gt;", self.onActivate)
</t>
<t tx="ekr.20031218072017.3962">def clear (self):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(g.callers())
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
</t>
<t tx="ekr.20031218072017.3963">def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(s,g.callers())
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
</t>
<t tx="ekr.20031218072017.3978">def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            if event: # Prevent wandering insertion point.
                w = self.bodyCtrl
                index = w.index("@%d,%d" % (event.x, event.y)) # Find where we clicked.
                start = w.index(index + " wordstart")
                end   = w.index(index + " wordend")
                # g.trace(index,start,end,w.get('1.0','end'))
                self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.
</t>
<t tx="ekr.20031218072017.4146">def lastVisible(self):
    
    """Move to the last visible node of the entire tree."""

    c = self ; p = c.rootPosition()
    
    # Move to the last top-level node.
    while p.hasNext():
        p.moveToNext()
    assert(p.isVisible())

    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        p.moveToLastChild()
    
    return p
</t>
<t tx="ekr.20040117171654"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self.stack,trace=False)
</t>
<t tx="ekr.20040303163330">def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []
    
    # g.trace(p.headString(),g.callers())

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList
</t>
<t tx="ekr.20040303175026.2">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
</t>
<t tx="ekr.20040303175026.3">def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2
</t>
<t tx="ekr.20040303175026.5">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2
</t>
<t tx="ekr.20040303175026.6">def moveToRoot (self,oldRoot=None):

    '''Moves a position to the root position.
    
    Important: oldRoot must the previous root position if it exists.'''

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p
</t>
<t tx="ekr.20040303175026.8">def clone (self):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self

    p2 = p.copy()
    p2.v = vnode(p.v.t)
    p2.linkAfter(p)

    return p2</t>
<t tx="ekr.20040303175026.10">def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)

    return p</t>
<t tx="ekr.20040303175026.11">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsNthChild(parent,n)

    return p</t>
<t tx="ekr.20040303214038">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) &gt; 0

    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!

    return dirtyVnodeList</t>
<t tx="ekr.20040305171133">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,c,copy=False):
    
    return self.allNodes_iter_class(self,c,copy)
</t>
<t tx="ekr.20040305171133.1">def __init__(self,p,c,copy):
    
    # g.trace('p.allNodes_iter.__init','p',p,'c',c)

    self.first = c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20040305171133.3">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
</t>
<t tx="ekr.20040305222924.1">def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
</t>
<t tx="ekr.20040305223225">def setHeadString (self,p,s,encoding="utf-8"):

    c = self ; t = c.edit_widget(p)
    
    p.initHeadString(s,encoding)

    if t:
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state,width=c.frame.tree.headWidth(s=s))

    p.setDirty()</t>
<t tx="ekr.20040305223522">def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
</t>
<t tx="ekr.20040306060312">def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = parent.numberOfChildren()
    p.linkAsNthChild(parent,n)
        
    return p</t>
<t tx="ekr.20040306215548">def findRoot (self):
    
    return self.c.frame.rootPosition()
</t>
<t tx="ekr.20040306220230.1">def edit_widget (self,p):
    
    c = self
    
    return p and c.frame.tree.edit_widget(p)</t>
<t tx="ekr.20040307104131.3">def positionExists(self,p):
    
    """Return True if a position exists in c's tree"""
    
    c = self ; p = p.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p.headString(),'parent',p.parent(),'back',p.back())
        if p.equal(root):
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    # g.trace('does not exist in root:',root.headString())
    return False
</t>
<t tx="ekr.20040310062332.4">def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v
    
    # p.dump(label="root")
</t>
<t tx="ekr.20040310062332.5">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")</t>
<t tx="ekr.20040312015705"># Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()
</t>
<t tx="ekr.20040315032503">def appendStringToBody (self,p,s,encoding="utf-8"):
    
    c = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    c.setBodyString(p,body + s,encoding)
</t>
<t tx="ekr.20040324080359">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
</t>
<t tx="ekr.20040324080359.1"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
</t>
<t tx="ekr.20040324082713"># Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

# Debugging.
# if v.isAnyAtFileNode():
    # if hasattr(v.t,"tnodeList"):
        # g.trace(v.headString(),len(v.t.tnodeList))
    # else:
        # g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))</t>
<t tx="ekr.20040409203454.1">def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
</t>
<t tx="ekr.20040410170806">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
</t>
<t tx="ekr.20040410170806.1">def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"
</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4.2 beta 1, build %s, September 29, 2006" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.
</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()
</t>
<t tx="ekr.20040701065235.2">def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    marks = [] ; expanded = []
    for p in p.subtree_iter():
        if p.isMarked() and not p in marks:
            marks.append(p.copy())
        if p.hasChildren() and p.isExpanded() and not p in expanded:
            expanded.append(p.copy())

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for p in theList:
                gnx = p.v.t.fileIndex
                sList.append("%s," % nodeIndices.toString(gnx))
            s = string.join(sList,'')
            # g.trace(tag,[str(p.headString()) for p in theList])
            result.append('\n%s="%s"' % (tag,s))
            
    return ''.join(result)
</t>
<t tx="ekr.20040702085529">if isOrphan and isThin:
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

# For testing.
# if p.isAtIgnoreNode():
     # for p2 in p.self_and_subtree_iter():
            # if p2.isAtThinFileNode():
                # g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
</t>
<t tx="ekr.20040711140738">def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &amp;Outline",c.checkOutline),
        ("&amp;Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &amp;All Python Code",c.checkAllPythonCode),
        ("&amp;Check Python &amp;Code",c.checkPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
</t>
<t tx="ekr.20040716064333">nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
</t>
<t tx="ekr.20040716064333.1">at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
</t>
<t tx="ekr.20040716065356">for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
</t>
<t tx="ekr.20040717112739">@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
</t>
<t tx="ekr.20040717113036">@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "&lt;perfectImport string-file&gt;"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
</t>
<t tx="ekr.20040717132539">write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
</t>
<t tx="ekr.20040718035658">try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            &lt;&lt; dump the files &gt;&gt;
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
</t>
<t tx="ekr.20040718045423">print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j &lt; i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k &lt; i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
</t>
<t tx="ekr.20040731204831">def getLastTracebackFileAndLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ in (exceptions.SyntaxError,exceptions.IndentationError):
        # Syntax and indentation errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            # g.es_print(repr(val))
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        # g.es_print(repr(data))
        item = data[-1]
        filename = item[0]
        n = item[1]
        return filename,n
</t>
<t tx="ekr.20040803072955.21">def injectCallbacks(self):
    
    c = self.c
    
    &lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):
        
        g.funcToMethod(f,leoNodes.position)</t>
<t tx="ekr.20040803072955.22"># N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
</t>
<t tx="ekr.20040803072955.23">def OnHyperLinkControlClick (self,event=None,c=c):
    
    """Callback injected into position class."""
    
    p = self
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
</t>
<t tx="ekr.20040803072955.24">def OnHyperLinkEnter (self,event=None,c=c):
    
    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
</t>
<t tx="ekr.20040803072955.25">def OnHyperLinkLeave (self,event=None,c=c):
    
    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
</t>
<t tx="ekr.20040803072955.87">def onHeadlineClick (self,event,p=None):
    
    c = self.c ; w = event.widget
    
    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'
        
    # g.trace(p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
</t>
<t tx="ekr.20040803072955.105">def OnActivateHeadline (self,p,event=None):
    
    '''Handle common process when any part of a headline is clicked.'''
    
    # g.trace(p.headString())
    
    returnVal = 'break' # Default: do nothing more.

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")
        
    return returnVal
</t>
<t tx="ekr.20040803072955.106">if p == c.currentPosition():
    # g.trace("is current")
    # The *second* click in the headline starts editing.
    if self.active:
        self.editLabel(p)
        returnVal = 'continue'
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.treeWantsFocusNow()
        returnVal = 'break'
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    returnVal = 'break'

# The next click *in the same headline* will start editing.
self.active = True
</t>
<t tx="ekr.20040803140033">def currentPosition (self,copy=True):
    
    """Return the presently selected position."""
    
    c = self

    if c._currentPosition:
        # New in Leo 4.4.2: *always* return a copy.
        return c._currentPosition.copy()
    else:
        return c.nullPosition()
    
# For compatibiility with old scripts.
currentVnode = currentPosition
</t>
<t tx="ekr.20040803140033.1">def setCurrentPosition (self,p):
    
    """Set the presently selected position. For internal use only.
    
    Client code should use c.selectPosition instead."""
    
    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
            
        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        c.setRootPosition(c.findRootPosition(c._currentPosition))
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition</t>
<t tx="ekr.20040803140033.2">def rootPosition(self):
    
    """Return the root position."""
    
    c = self
    
    if self._rootPosition:
        return self._rootPosition.copy()
    else:
        return  c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition</t>
<t tx="ekr.20040803140033.3">def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None</t>
<t tx="ekr.20040803140033.4">def isCurrentPosition (self,c):
    
    p = self
    
    return c.isCurrentPosition(p)
</t>
<t tx="ekr.20040803140033.5">def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)
</t>
<t tx="ekr.20041026132435">def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
</t>
<t tx="ekr.20041117083857">def initSettingsFiles (self):
    
    """Set self.globalConfigFile, self.homeFile and self.myConfigFile."""
    
    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    
    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global:',self.globalConfigFile)
        g.trace('home:',self.homeFile)
        g.trace('myGlobal:',self.myGlobalConfigFile)
        g.trace('myHome:',self.myHomeConfigFile)</t>
<t tx="ekr.20041117083857.1"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
</t>
<t tx="ekr.20041117085625">def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20041117093246"></t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041120064303">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []

    # This can't be done in initSettingsFiles because the local directory does not exits.
    localDirectory = g.os_path_dirname(fileName)
    
    #  Set the local leoSettings.leo file.
    localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
    if not g.os_path_exists(localConfigFile): localConfigFile = None
    
    # Set the local myLeoSetting.leo file.
    myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
    if not g.os_path_exists(myLocalConfigFile): myLocalConfigFile = None
    
    # Init settings from leoSettings.leo files, including myLeoSettings.leo.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041223104933">class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
</t>
<t tx="ekr.20041223111916">def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)
        
show = pack
</t>
<t tx="ekr.20041223111916.1">def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
</t>
<t tx="ekr.20041223114744">def getFrame (self):
    
    return self.statusFrame
</t>
<t tx="ekr.20041228084018.5">@nocolor

My present thinking is that scripts should be able to store/retrieve persistent
objects to/from the zodb. That is, the zodb plugin is likely to be retired.

Leo's vnode and tnode classes now derive from ZODB.Persistence.Persistent if
leoNodes.use_zodb is True. It remains to be seen whether having use_zodb = True
will cause any serious problems.

See the posting below (Scripting using zodb) for latest details.

See the node 'zodb get/put buttons' in test.leo for examples of how scripts can access zodb easily.</t>
<t tx="ekr.20050120092028">def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and c.edit_widget(p))
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
</t>
<t tx="ekr.20050120093555">def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
</t>
<t tx="ekr.20050220030850">def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) &gt; -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) &gt; -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
</t>
<t tx="ekr.20050318085432.6">def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()
    
    u.groupCount += 1

    
    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        c.beginUpdate()
        try:
            for z in bunch.items:
                self.setIvarsFromBunch(z)
                if z.redoHelper:
                    # g.trace(z.redoHelper)
                    z.redoHelper() ; count += 1
                else:
                    g.trace('oops: no redo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1
    
    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)
        
    c.selectPosition(p)
    newSel and c.frame.body.setTextSelection(newSel)</t>
<t tx="ekr.20050318085713">def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)</t>
<t tx="ekr.20050405103712">if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20050405103712.1">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
</t>
<t tx="ekr.20050412085112">def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
</t>
<t tx="ekr.20050418161620.2">def putUaHelper (self,torv,key,val):
    
    '''Put attribute whose name is key and value is val to the output stream.'''
    
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,xml.sax.saxutils.escape(val))
            return attr
        else:
            g.es("ignoring non-string attribute %s in %s" % (
                key,torv),color="blue")
            return ''
    try:
        try:
            # Protocol argument is new in Python 2.3
            # Use protocol 1 for compatibility with bin.
            s = pickle.dumps(val,protocol=1)
        except TypeError:
            s = pickle.dumps(val,bin=True)
        attr = ' %s="%s"' % (key,binascii.hexlify(s))
        return attr

    except pickle.PicklingError:
        # New in 4.2 beta 1: keep going after error.
        g.es("ignoring non-pickleable attribute %s in %s" % (
            key,torv),color="blue")
        return ''
</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050711091931">def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050920084036.189">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify-all-python-code':     c.beautifyAllPythonCode,
    'beautify-python-code':         c.beautifyPythonCode,
    'cascade-windows':              f.cascade,
    'clear-recent-files':           c.clearRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible':            c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-bracket':                c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-users-guide':             c.leoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-CWEB':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-to':                 c.saveTo,
    'select-all':                   f.body.selectAllText,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}
</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)
    
def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)
    
def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)
    
def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w
    
    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!
    
    self.ins1 = ins = g.app.gui.getInsertPoint(w)
    sel = g.app.gui.getSelectionRange(w) or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''
    
    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition() ;
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = gui.getAllText(w)

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = gui.getSelectionRange(w)
    startindex = insert = gui.getInsertPoint(w)
    
    if self.forward:
        i1 = gui.toPythonIndex(s,w,startindex)
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),gui.toPythonIndex(s,w,startindex) + len(pattern))
    
    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        pos    = gui.toGuiIndex(s,w,i)
        newpos = gui.toGuiIndex(s,w,j)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        gui.setTextSelection(w,pos,newpos,insert=pos)
</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocusNow()
    if keysym == 'Return':
        sel = g.app.gui.getSelectionRange(w)
        if sel: i,j = sel
        else:   i = j = g.app.gui.getInsertPoint(w)
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = '1.0'
    index = w.index('insert')
    index2 = w.index('%s+%dc' % (index,len(s)))
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
</t>
<t tx="ekr.20050920085536.62">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
</t>
<t tx="ekr.20050921103230">def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuPanesTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()</t>
<t tx="ekr.20050921103736">def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&amp;Cmds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # Used in top table: q,u,x
        # &amp;: a,b,c,d,f,g,h,m,n,o,p,r,s,t
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Cursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',     self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20050928092516">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
</t>
<t tx="ekr.20051013161232">def updateSettings (self,c,localFlag):

    d = self.readSettings(c)
    
    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)
            
    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
</t>
<t tx="ekr.20051024102724">def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    &lt;&lt; make bindings for a common binding widget &gt;&gt;

    self.canvas.bind('&lt;Key&gt;',k.masterKeyHandler)
    self.canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    &lt;&lt; make bindings for tagged items on the canvas &gt;&gt;
    &lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051104075904.30">def findNodeInTree(self,p,headline):

    """Search for a node in p's tree matching the given headline."""

    c = self.c
    for p in p.subtree_iter():
        h = headline.strip().lower()
        if p.headString().strip().lower() == h:
            return p.copy()
    return c.nullPosition()
</t>
<t tx="ekr.20051104075904.35">def replaceOutline (self,outline1,outline2):

    """Replace outline1 by a copy of outline 2,

    retaining the headline of outline1."""

    c = outline1.c
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete()
    c.setRootPosition(c.findRootPosition(copy)) # New in 4.4.2.
    c.selectPosition(copy)
</t>
<t tx="ekr.20051113110735">u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20051113110851">clones.append(self.p.v.t)
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20051218121447">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
    def isWordChar(ch): return ch in (string.letters + string.digits + '_')

    i = toPython(w.index('insert'))
    delta = g.choose(forward,1,-1)
    
    if not forward: i -= 1
    while 0 &lt;= i &lt; n and isWordChar(s[i]):
        i += delta
    while 0 &lt;= i &lt; n and not isWordChar(s[i]):
        i += delta
    if not forward: i += 1

    self.moveToHelper(event,toGui(i),extend)</t>
<t tx="ekr.20051218122116">def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'&lt;',i):
            spot = i
        elif w.compare(spot,'&gt;',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
</t>
<t tx="ekr.20051218174113">def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c ; w = event.widget
    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocus(w)
</t>
<t tx="ekr.20060117094955">def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        'repeat-comple&amp;x-command',
        'f&amp;ull-command',
        'keyboard-&amp;quit',
        '-',
    ]
</t>
<t tx="ekr.20060117094955.1">def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20060117095212">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20060117095212.1">def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20060117095212.2">def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20060117095212.7">def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20060117114315">def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-keyboard-macro',
        '&amp;insert-keyboard-macro',
    ]
</t>
<t tx="ekr.20060128075225">def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20060128080201">def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
</t>
<t tx="ekr.20060131084938">def masterDoubleClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        i = w.index("@%d,%d" % (event.x,event.y))
        start = w.index(i+' wordstart')
        end = w.index(i+' wordend')
        g.app.gui.setTextSelection(w,start,end)
        return 'break'
</t>
<t tx="ekr.20060131173440">self.bindingWidget = t = Tk.Text(self.canvas,name='bindingWidget')

t.bind('&lt;Key&gt;',k.masterKeyHandler)

table = (
    ('&lt;Button-1&gt;',       k.masterClickHandler,          tree.onHeadlineClick),
    ('&lt;Button-3&gt;',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('&lt;Double-Button-1&gt;',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('&lt;Double-Button-3&gt;',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    t.bind(a,treeBindingCallback)
    
self.textBindings = t.bindtags()
</t>
<t tx="ekr.20060131173440.2">where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '&lt;Button-1&gt;',self.onClickBoxClick),
    ('iconBox','&lt;Button-1&gt;',self.onIconBoxClick),
    ('iconBox','&lt;Double-1&gt;',self.onIconBoxDoubleClick),
    ('iconBox','&lt;Button-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;Double-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;B1-Motion&gt;',self.onDrag),
    ('iconBox','&lt;Any-ButtonRelease-1&gt;',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)
</t>
<t tx="ekr.20060203072636">def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')
    
    insert = g.choose(self.forward,'sel.end','sel.start')
    g.app.gui.setTextSelection (self.w,i,j,insert=insert)

    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20060203114017">def setMinibufferBindings (self):
    
    '''Create bindings for the minibuffer..'''
    
    f = self ; c = f.c ; k = c.k ; t = f.miniBufferWidget
    
    if not c.useTextMinibuffer: return
    
    for kind,callback in (
        ('&lt;Key&gt;',           k.masterKeyHandler),
        ('&lt;Button-1&gt;',      k.masterClickHandler),
        ('&lt;Button-3&gt;',      k.masterClick3Handler),
        ('&lt;Double-1&gt;',      k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',      k.masterDoubleClick3Handler),
    ):
        t.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            t.bind("&lt;Button-2&gt;",frame.OnPaste)
</t>
<t tx="ekr.20060205103842">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
</t>
<t tx="ekr.20060210102201">def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    #g.trace(body and body.bodyCtrl)
    c.set_focus(body and body.bodyCtrl,force=True)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and c.edit_widget(p),force=True)
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl,force=True)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas,force=True)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w,force=True)
</t>
<t tx="ekr.20060212061804">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    
    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        if (
            g.CheckVersion(version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)
</t>
<t tx="ekr.20060217111834">.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:
    
copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x</t>
<t tx="ekr.20060307080642">if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
</t>
<t tx="ekr.20060417194232"></t>
<t tx="ekr.20060417194232.1">def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        self.event = event ; self.widget = w = event.widget
        self.backward = backward ; self.extend = extend ;
        self.insert = w.index('insert')
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' &amp; extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.widget
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = g.app.gui.getAllText(w)
        def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
        def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
        ins = toPython(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j &gt; -1:
                spot = toGui(j)
                self.moveToHelper(event,spot,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j &gt; -1:
                spot = toGui(j)
                self.moveToHelper(event,spot,extend)
        c.frame.clearStatusLine()
        k.clearState()</t>
<t tx="ekr.20060417194232.2">def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.widget ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            word_chars = string.letters + string.digits + '_'
            while i &lt; len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or s[i-1] not in word_chars)
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20060420144640">def iSearchBackspace (self):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w
    
    if not self.isearch_stack:
        ins = gui.getInsertPoint(w)
        self.endSearch(ins,ins)
        return 
    
    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()
    
    if sel:
        i,j = sel
        gui.setTextSelection(w,i,j,insert=ins)
    else:
        gui.setInsertPoint(w,ins)

    w.see('insert')
    
    if not self.isearch_stack:
        self.endSearch(ins,ins)
</t>
<t tx="ekr.20060528100747">@ **Important**: body.bodyCtrl and body.frame.bodyCtrl must always be the same.
</t>
<t tx="ekr.20060528100747.1">def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
     
    if self.numberOfEditors == 1:
        # Inject the ivars into the first editor.
        w = self.editorWidgets.get('1')
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v
        w.leo_label_s = p.headString()

    self.numberOfEditors += 1
    name = '%d' % self.numberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    &lt;&lt; create label and text widgets &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.updateEditors()
    # self.onFocusIn(w,setFocus=True)
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20060528104554">lockout_onFocusIn = False

def onFocusIn(self,w,setFocus=False):

    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.callers())
    if self.lockout_onFocusIn:
        if trace: g.trace('lockout')
        return 'break'
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    
    # Disable recursive calls: some of the calls below generate OnFocusInEvents.
    self.lockout_onFocusIn = True
    try:
        if trace: g.trace(w)
    
        # Inactivate the previously active editor.
        # Don't capture ivars here! selectMainEditor keeps them up-to-date.
        for key in d.keys():
            w2 = d.get(key)
            if w2 != w and w2.leo_active:
                w2.leo_active = False
                self.unselectLabel(w2)
                w2.leo_scrollBarSpot = w2.yview()
                w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
                w2.leo_selection = g.app.gui.getSelectionRange(w2)
                break
        else:
            if trace: g.trace('no active editor!')
    
        # Careful, leo_p may not exist.
        if not c.positionExists(w.leo_p):
            g.trace('does not exist',w.leo_name)
            for p2 in c.allNodes_iter():
                if p2.v == w.leo_v:
                    w.leo_p = p2.copy()
                    break
            else:
                if trace: g.trace("Can't happen")
                return 'break'

        self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
        w.leo_active = True
        c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
        c.recolor_now()
        &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
        w3 = g.app.gui.get_focus(c)
        if setFocus or w3 and not g.app.gui.widget_name(w3).startswith('body'):
            if trace: g.trace(g.app.gui.widget_name(w),id(w))
            c.bodyWantsFocusNow()
    finally:
        self.lockout_onFocusIn = False

    return 'break'
</t>
<t tx="ekr.20060528110922">f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,f,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
w.see('1.0')
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
</t>
<t tx="ekr.20060528113806">def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w # Bug fix: 9/12/06
    self.onFocusIn(w)
</t>
<t tx="ekr.20060528131618">def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.frame.bodyWantsFocus()
</t>
<t tx="ekr.20060528132829">def selectMainEditor (self,p):

    c = self.c ; p = c.currentPosition() ; w = self.bodyCtrl

    # Don't inject ivars if there is only one editor.
    if w.leo_p is not None:
        # Keep w's ivars up-to-date.
        w.leo_p = p.copy()
        w.leo_v = p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w)
        # g.trace(w.leo_name,p.headString())
</t>
<t tx="ekr.20060528170438">def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.onFocusIn(w2,setFocus=True)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # g.trace('***',g.app.gui.widget_name(w2),id(w2))

    return 'break'
</t>
<t tx="ekr.20060530204135">def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl
    
    # g.trace(id(w),c.currentPosition().headString())
    
    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w
    
    c.recolor_now(interruptable=False) # Force a complete recoloring.
    
    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w</t>
<t tx="ekr.20060530210057">def unselectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='LightSteelBlue1')
        
def selectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='white')
        
def createLabel (self,w):

    w.leo_label = Tk.Label(w.leo_frame)
    w.pack_forget()
    w.leo_label.pack(side='top')
    w.pack(expand=1,fill='both')
</t>
<t tx="ekr.20060605190146">if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20060606090542">def setEditorColors (self,bg,fg):
    
    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
</t>
<t tx="ekr.20060624085200">def handleScriptException (c,p,script,script1):

    g.es("exception executing script",color='blue')

    fileName, n = g.es_exception(full=False)

    if p and not script1 and fileName == "&lt;string&gt;":
        c.goToScriptLineNumber(p,script,n)

    &lt;&lt; dump the lines near the error &gt;&gt;
</t>
<t tx="ekr.20060824112937.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3882798
By: jujusl

When I double-click in the body on a word with accents, only a part of the word
is selected (up to the accentuated char, forward and backward)

This does not happen in headlines.

I saw that using Windows ; I will test it on Linux machine.

Maybe is it a Tk problem, may be not. You'll tell me...

St√©phane

@color</t>
<t tx="ekr.20060904114302"></t>
<t tx="ekr.20060904165452"></t>
<t tx="ekr.20060905090957"># A step towards removing c ivars from vnode and position classes.</t>
<t tx="ekr.20060905091234"></t>
<t tx="ekr.20060905092512.2">@nocolor

To do:
    
- Eliminate most calls to c.setRootPosition(c.findRootPosition(p))
    ** Just have c.rootPosition call c.findRootPosition(c.currentPosition())
    
What I did:

- Removed c argument from t, v and p ctors.
- Removed c argument from most position methods.
    - In particular, p.link, p.unlink, v.link and v.unlink no longer update c.currentPosition()
    - Moved all position methods that still had a c argument to the Commands class.
- Removed p.allNodes_iter.
- Added c.findRootPosition and c.findRootVnode.
- c.rootPosition now returns c.findRootPosition(c.currentPosition())

As a result:
    
- The tnode, vnode and position classes are *completely* independent of Leo.
  In particular, no tnode, vnode or position method gets a c argument.
- The p.link, p.unlink, v.link and v.unlink are significantly simpler.
- The machinery for keeping the root position up-to-date is
  simple and confined to one place in the Commands class.
  
@color</t>
<t tx="ekr.20060905103748"></t>
<t tx="ekr.20060905104612"></t>
<t tx="ekr.20060905114409"></t>
<t tx="ekr.20060905121515">def clearDirtyJoined (self,c):

    v = self
    c.beginUpdate()
    try:
        v.t.clearDirty()
    finally:
        c.endUpdate() # recomputes all icons
</t>
<t tx="ekr.20060905165341.1"></t>
<t tx="ekr.20060905165341.2"></t>
<t tx="ekr.20060905172505.1"></t>
<t tx="ekr.20060905181927"></t>
<t tx="ekr.20060906130502"></t>
<t tx="ekr.20060906131836">def setRootVnode (self, v):
    
    c = self
    newRoot = leoNodes.position(v,[])
    c.setRootPosition(newRoot)</t>
<t tx="ekr.20060906134053">@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):
    
    '''Return the root position of the outline containing p.'''
    
    c = self ; p = p.copy()
    
    while p and p.hasParent():
        p.moveToParent()
        
    while p and p.hasBack():
        p.moveToBack()
        
    # g.trace(p and p.headString())

    return p</t>
<t tx="ekr.20060906211138">def clearMarked  (self,p):
    
    c = self
    p.v.clearMarked()
    g.doHook("clear-mark",c=c,p=p,v=p)</t>
<t tx="ekr.20060906211138.1">def setMarked (self,p):
    
    c = self
    p.v.setMarked()
    g.doHook("set-mark",c=c,p=p,v=p)</t>
<t tx="ekr.20060906220124"># getArg now has:
    
if k.useTextWidget: c.minibufferWantsFocusNow() # 9/8/06

instead of:
    
if k.useTextWidget: c.minibufferWantsFocus()</t>
<t tx="ekr.20060907085253"></t>
<t tx="ekr.20060907085906.1">def __init__(self,c,copy):
    
    # g.trace('c.allNodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20060907085906.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
</t>
<t tx="ekr.20060907101636"># Very important: it guarantees that c.rootPosition always returns the proper value.</t>
<t tx="ekr.20060908075800.1"></t>
<t tx="ekr.20060908091132"></t>
<t tx="ekr.20060908092306"></t>
<t tx="ekr.20060908095225">@nocolor

Undo crashed or didn't work.  Redo clone-find-all could hang.
</t>
<t tx="ekr.20060908104329"></t>
<t tx="ekr.20060908104646"></t>
<t tx="ekr.20060908104833"></t>
<t tx="ekr.20060908115325"># In fact, p.deleteLinksInTree is needed: as unit tests show that some adjustments are made.</t>
<t tx="ekr.20060908205857">if use_zodb and ZODB:
    
    # The only required property is that objects
    # which compare equal have the same hash value.
    
    def __hash__(self):

        return hash(g.app.nodeIndices.toString(self.fileIndex))
        
        # return sum([ord(ch) for ch in g.app.nodeIndices.toString(self.fileIndex)])</t>
<t tx="ekr.20060910100316">if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()</t>
<t tx="ekr.20060911160213"></t>
<t tx="ekr.20060912073120"></t>
<t tx="ekr.20060912073340">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3910237
Kam-Yung
Python 2.4.3, Tk 8.4.12, Pmw 1.2

I'm getting "TclError Exception in Tk" callback with the new multi-editor
feature.

Steps to reproduce:

* start up Leo with no files
* execute "add-editor"
* make sure the left-most body pane is selected
* execute "delete-editor"

Up comes a TK error box.</t>
<t tx="ekr.20060912073340.1">TclError Exception in Tk callback
  Function: &lt;function masterBindKeyCallback at 0x0164DBB0&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x01840FD0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2117, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 3096, in masterKeyHandler
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2241, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2318, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2355, in callAltXFunction
    func(event)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 2124, in deleteEditor
    self.onFocusIn(w)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 2173, in onFocusIn
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 6381, in selectPosition
    c.frame.tree.select(p,updateBeadList)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterTree.py", line 2548, in select
    c.frame.updateStatusLine() # New in Leo 4.4.1.
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 1002, in updateStatusLine
    if self.statusLine: self.statusLine.update()
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 727, in update
    index = w.index("insert")
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2938, in index
    return self.tk.call(self._w, 'index', index)
TclError: invalid command name ".20195728.20196288.22611848.22611928.23069560.23069920.body-pane"

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 1356
    state: 8
    time: 3053230
    type: 2
    widget: .20195728.20196288.22412264.minibuffer
    width: ??
    x: 244
    x_root: 678
    y: -164
    y_root: 518

</t>
<t tx="ekr.20060912083415">@nocolor

- in statusLine.update:
    
replace self.bodyCtrl with c.frame.bodyCtrl.

- Removed bodyCtrl ivar from statusLine class.  This value can not be cached!

- in deleteEditor: add:

self.bodyCtrl = self.frame.bodyCtrl = w

just before the call to self.onFocusIn(w).</t>
<t tx="ekr.20060912091922">** Create separate @test node for each plugin.</t>
<t tx="ekr.20060912093104">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]</t>
<t tx="ekr.20060912093334"></t>
<t tx="ekr.20060912093334.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3909651

Could the multiple editor activation be added to the standard Leo menus?</t>
<t tx="ekr.20060913082305"></t>
<t tx="ekr.20060913084832"></t>
<t tx="ekr.20060913085557">&gt; Do you see zodb as persisting Leo files or Leo nodes?

Interesting question.  I now see the zodb plugin as a proof-of-concept for *user-defined* scripts.  The zodb plugin is probably going to go away.

Let us suppose that db is a ZODB.DB instance. (To see how to create such an instance, see the init_zodb method in the zodb plugin.  Perhaps I'll defines something like g.openZodb to make this easier.)  Then the statements:

connection = db.open()
root = connection.root()
root[aKey] = v
get_transaction().commit()
connection.close()

will write all of v's data (all vnodes and tnodes) to the zodb.  This is true whatever v is: it can be the root of an entire outline, or any suboutline.  If you want to write a single node, you would have to 'detach' that node from the outline.  You can do this by copying the node and then unlinking the node from its descendents. Perhaps I could add a convenience method to the vnode class to make this easier.

&gt;Do you see zodb work as providing enhanced access to nodes across multiple files?

Scripts could do so easily.  Happily, the distinction between 'long-lived' and 'short-lived' connections is not important for scripts: a script should hold a connection open only for as long as needed.  So it would be easy to write any number of vnode trees to the zodb.  Later, another script could access any of the data in the zodb by zodb key.  Like this:

connection = db.open()
root = connection.root()
v = root.get(aKey)
p = leoNodes.position(v,[])

After running this script, p is a position representing the root of the tree of 'imported' vnodes.  The script above does not 'connect' the imported trees to an outline, nor should it do so.  As I write this, I realize that the position ctor should make the second argument optional, so that leoNodes.position(v) would be equivalent to leoNodes.position(v,[]).

Each script should open at most connection at a time and be sure to close any zodb connection it creates.  The proper way to do this is in a finally statement, like this:

try:
....connection = db.open()
....root = connection.root()
....v = root.get(aKey)
....p = leoNodes.position(v,[])
....&lt;&lt; do something with the nodes in p's tree&gt;&gt;
finally:
....get_transaction().commit()
....connection.close()

In short, the recent changes to Leo's vnode and tnode classes give scripts the ability to save/retrieve Leo data to/from the zodb in any way a script wants, without any further support from Leo, or from me.

I shall spend an hour or two more with the zodb plugin, but it looks to me that the plugin has served its purpose.  Rather than trying to guess how people will want to use the zodb, it will be simpler and more general to have people write scripts that do exactly what they want.  In particular, such scripts can easily sidestep the problems with multiple open connections.

Edward

P.S. Please note that the scripts shown above could not have been written without all the recent work with the zodb plugin and the big code reorg.

P.P.S. A couple of unit tests involving the new v/t.__hash__ methods just failed, so it may be just a little bit longer before the code on cvs is truly zodb ready.  I'll also be working on example scripts and the convenience methods described above.

EKR
</t>
<t tx="ekr.20060913090832"># Also, the 'stack' arg to the position ctor now defaults to None.</t>
<t tx="ekr.20060913090832.1">init_zodb_import_failed = False
init_zodb_failed = {} # Keys are paths, values are True.
init_zodb_db = {} # Keys are paths, values are ZODB.DB instances.

def init_zodb (pathToZodbStorage,verbose=True):
    
    '''Return an ZODB.DB instance from ZODB.FileStorage.FileStorage(pathToZodbStorage)
    return None on any error.'''
    
    global init_zodb_db, init_zodb_failed, init_zodb_import_failed
    
    db = init_zodb_db.get(pathToZodbStorage)
    if db: return db
    
    if init_zodb_import_failed: return None

    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed: return None

    try:
        import ZODB
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None
    
    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db [pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed [pathToZodbStorage] = True
        return None</t>
<t tx="ekr.20060913091805.1">def detach (self):
    
    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''
    
    v = self
    
    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())
    
    return vnode(t2)</t>
<t tx="ekr.20060914085747">chapter_hoist.py
leoOPML.py
leo_to_html.py
leo_to_rtf.py
mod_scripting.py
paste_as_headlines.py
open_with.py
rst3.py
UNL.py
</t>
<t tx="ekr.20060914085747.1">ConceptualSort.py
EditAttributes.py
FileActions.py
Library.py
TabWindow.py
UASearch.py
URLloader.py
UniversalScrolling.py

add_directives.py
arrows.py
at_view.py
autotrees.py
base64Packager.py
bibtex.py
cleo.py
color_markup.py
datenodes.py
detect_urls.py
dyna_menu.py
fastGotoNode.py
footprints.py
groupOperations.py
hoist.py
image.py
import_cisco_config.py
leoupdate.py
macros.py
mod_autosave.py
mod_http.py
mod_labels.py
mod_read_dir_outline.py
mod_shadow.py
nav_buttons.py
newButtons.py
niceNosent.py
nodebar.py
nodenavigator.py
open_shell.py
pie_menus.py
pretty_print.py
print_cp.py
rClick.py
read_only_nodes.py
rowcol.py
run_nodes.py
scheduler.py
scripts_menu.py
searchbox.py
shortcut_button.py
slideshow.py
table.py
templates.py
trace_tags.py
xcc_nodes.py
xsltWithNodes.py</t>
<t tx="ekr.20060914090250">__jEdit_colorizer__.py


vim.py
word_export.py
xemacs.py</t>
<t tx="ekr.20060914130034"># No unit tests needed: these are always active.
plugins_manager.py
plugins_menu.py

# Unit tests needed...
word_count.py
zodb.py</t>
<t tx="ekr.20060915113237">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3914969

This body-outline ratio in the .leo file is not used, regardless of orientation.

The problem that tkFrame.resizePanesToRatio got deleted sometime after 4.4 final,
so the do-nothing base class method was executed instead.
@color</t>
<t tx="ekr.20060915124834">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    self.divideLeoSplitter(self.splitVerticalFlag,ratio)
    self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20060918091042"></t>
<t tx="ekr.20060919070145">if not self.mFileName.endswith('opml'):
    self.mFileName = self.mFileName + '.opml'
fileName = self.mFileName</t>
<t tx="ekr.20060920145332"></t>
<t tx="ekr.20060920150119">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3924236

Clear the * mark if all changes have been done.
There are serious problems with undoing and redoing text.</t>
<t tx="ekr.20060920151334">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3924236

Comparing directory A, with files A1 and A2, and directory B, with files B1 and B2
(A1, A2, B1, B2 all being different) shows up in the log as A1 and A2 not being founnd.

I think also B1 and B2 should be mentioned somewhere (e.g. using headings like 'Only present in A' and 'Only present in B').

</t>
<t tx="ekr.20060920180657">@nocolor
@

It's tempting to try to remove t.vnodeList, but it would not be wise:
    
1. The present code works, and is not actually inefficient.
2. Whan a clone is deleted, we need to update the parent if the tnode that the clone shared.
   Other ways of doing so are conceivable, but they won't be significantly simpler.
3. The markAllAncestorAtFileNodesDirty algorithm is usually *much* faster than searching the entire tree.
4. Although mostly the code tests whether len(vnodeList) &gt; 1, there *are* other uses.

The actual usages of vnodeList:
    
- In createVnode: skip = len(vnodeList) &gt; 1.
- getExistingVnode uses vnodeList[0].
- adjustParentLinksInSubtree uses vnodeList[0]
- isCloned: returns len(vnodeList) &gt; 1.
- directParents: returns vnodeList (but directParents only used by setAllAncestorAtFileNodesDirty.
- findAllPotentiallyDirtyNodes: uses vnodeList.
- moveToParent: use len(vnodeList)
- vParentWithStack: uses len(vnodeList)
** moveOutlineUp: if back2 and p.v in back2.v.t.vnodeList:
* findChild4: uses vnodeList[0], but it's a weird use.</t>
<t tx="ekr.20060920190138"></t>
<t tx="ekr.20060921100435"># Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition="&gt;=",stringCompare=None,delimiter='.',trace=False):
    
    vals1 = [int(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [int(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 &lt; n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 &lt; n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('&lt;',  vals1 &lt;  vals2), ('&lt;=', vals1 &lt;= vals2),
        ('&gt;',  vals1 &gt;  vals2), ('&gt;=', vals1 &gt;= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."
    
    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result</t>
<t tx="ekr.20060921100435.1">@
g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", "&gt;=", "&lt;=", "&gt;", or "&lt;"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def oldCheckVersion( version, againstVersion, condition="&gt;=", stringCompare="0.0.0.0", delimiter='.' ):

    __pychecker__ = 'maxreturns=20'
    
    # g.pdb()

    # tokenize the stringCompare flags
    compareFlag = string.split( stringCompare, '.' )

    # tokenize the version strings
    testVersion = string.split( version, delimiter )
    testAgainst = string.split( againstVersion, delimiter )

    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount &gt; len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount &gt; len(testVersion):
        tokenCount = len(testVersion)

    # Apply the stringCompare flags
    justInteger = re.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError,errMsg

    # Compare the versions
    if condition == "&gt;=":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == "&gt;":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "&lt;":
        for i in range(tokenCount):
            if testVersion[i] &gt;= testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "&lt;=":
        for i in range(tokenCount):
            if testVersion[i] &gt; testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal

    # didn't find a condition that we expected.
    raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."</t>
<t tx="ekr.20060921113950"># The new version of g.CheckVersion is simpler, and works more often, but is perhaps less general.</t>
<t tx="ekr.20060923043120"># It now prints the binding for the command.</t>
<t tx="ekr.20060923043845"></t>
<t tx="ekr.20060923060822">def defineCmdsMenuFocusTable (self):

    c = self.c

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20060923060822.1">def defineCmdsMenuScrollTable (self):

    c = self.c

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-&amp;down',
        'scroll-&amp;up',
        '-',
        'scroll-down-&amp;extend-selection',
        'scroll-up-e&amp;xtend-selection',
    ]</t>
<t tx="ekr.20060923065819"></t>
<t tx="ekr.20060924120752">def defineCmdsMenuPanesTable (self):

    c = self.c

    self.cmdsMenuPanesTable = [
        # &amp;: a,b,d,f,l,n,o,p,u,x,y
        'contract-&amp;body-pane',
        'contract-&amp;log-pane',
        'contract-&amp;outline-pane',
        'contract-&amp;pane',
        '-',
        'expand-bo&amp;dy-pane',
        'expand-lo&amp;g-pane',
        'expand-o&amp;utline-pane',
        'expand-pa&amp;ne',
        '-',
        '&amp;fully-expand-body-pane',
        'full&amp;y-expand-log-pane',
        'fully-e&amp;xpand-outline-pane',
        'fully-exp&amp;and-pane',
    ]
    </t>
<t tx="ekr.20060924124119">def defineCmdsMenuCursorTable (self):

    c = self.c
    
    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]
    
    self.cursorMenuForwardTable = [
        # &amp;: b,c,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &amp;: e,b,c,l,n,p,s,w
        '&amp;extend-to-word',
        '-',
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;word-extend-selection',
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20060924161901">def defineCmdsMenuTextTable (self):

    c = self.c

    self.cmdsMenuTextTable = [
        # &amp;: b,c,d,e,f,g,i,l,m,n,o,p,r,s,u,y
        '&amp;beautify-python-code',
        'beautify-all-p&amp;ython-code',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]</t>
<t tx="ekr.20060924173041">@nocolor

- Removed all modes except Alt-C mode.
- Use Shift-arrows for outline moves when focus is in outline pane.
- Put help / apropos commands in help menu.
- Put focus commands in Cmds menu.
- When focus is in outline, normal character navagates like Windows explorer.
- Put Scrolling commands in Cmds menu.
- Screened out(some) unwanted characters from affecting outline navigation.More work is needed.
- Esc character is never inserted into text.
- Replaced @button clones-tab with @command clones-tab.
- Scripting plugins now sets verbose=True so @commands get shown.
* Alt keys (outline move commands) should set focus to outline even if nothing else happens.
- Closing a window no longer puts focus in limbo: added force argument to c.set_focus.
- New gui bindings: (I should actually be able to remember these).
    cycle-all-focus                     = Alt-Y
    contract-pane                       = Alt+Ctrl+-
    expand-pane                         = Alt+Ctrl-=
    focus-to-tree                       = Alt-space
    scroll-outline-down-page            = Alt-PageDn
    scroll-outline-down-page            ! tree = PageDn
    scroll-outline-up-page              = Alt-PageUp
    scroll-outline-up-page              ! tree = PageUp
    scroll-outline-left                 = Alt+Ctrl+LtArrow
    scroll-outline-right                = Alt+Ctrl+RtArrow
- Put find-character and back-find-character in Edit:Find menu.
- Use Alt-S,Alt-R for incremental searches.
- Created find-character-extend-selection and back-find-character-extend-selection.
- Added binding (Ctrl-W) and entry in Cmds menu for select-word-at-cursor.
- Added binding (Ctrl-P) for repeat-complex-command.
- Added binding (Ctrl-B) for execute-script.
* Fixed bug in extend mode.
- Added binding (Ctrl-space) for toggle extend mode.
- Removed most cursor move bindings involving ctrl keys. Exception: ctrl-a and ctrl-e.
    ** The idea is that I'll use extend mode instead.
- Stay in outline mode: added @bool stayInTreeAfterEditHeadline setting.
- Added Cmds:Toggle Settings submenu.
- Use emacs names in Cmds menu (and in some other places): allow single item in menu tables.
     - regex: \(.*\ '  --&gt; '</t>
<t tx="ekr.20060925080505">@
This should *finally* fix the problems with focus going to limbo.
All xWantsFocusNow methods set the force arg.</t>
<t tx="ekr.20060925151926">def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)
    
def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)
    
def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)
    
def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)</t>
<t tx="ekr.20060926085352"># Rewrote moveWordHelper. It now avoids Tk and regexes.  *Much* simpler.</t>
<t tx="ekr.20060926161940">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20060926213642">def capitalizeMinibufferMenuName (self,s):
    
    result = []
    for i in xrange(len(s)):
        ch = s[i]
        prev = i &gt; 0 and s[i-1] or ''
        prevprev = i &gt; 1 and s[i-2] or ''
        if 1: # Just capitalize the start of each word.
            if (
                i == 0 or
                i == 1 and prev == '&amp;' or
                prev == '-' or
                prev == '&amp;' and prevprev == '-'
            ):
                result.append(ch.capitalize())
            else:
                result.append(ch)
        else: # Capitalizing accelerators in the middle of a word is dubious.
            next = i+1 &lt; len(s) and s[i+1] or ''
            if (
                i == 0 and next != '&amp;' or
                prev == '&amp;' or
                prev == '-' and next != '&amp;'
            ):
                result.append(ch.capitalize())
            else:
                result.append(ch)
    return ''.join(result)
        
    </t>
<t tx="ekr.20060927070439">http://sourceforge.net/forum/message.php?msg_id=3929272</t>
<t tx="ekr.20060927073203">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3932641

LEO *always* outputs the first line of a node without indentation even if it is indented in the node.
</t>
<t tx="ekr.20060927100500.1">@nocolor

- Does not restore selection after indent/undent commands.</t>
<t tx="ekr.20060927172440"></t>
<t tx="ekr.20060927173836.1">@nocolor

Why are calltips enabled at all??

Show calltips treats the node as code, and that can have very weird effects in @nocolor sections.</t>
<t tx="ekr.20060927173836.6"></t>
<t tx="ekr.20060928054124">http://sourceforge.net/forum/message.php?msg_id=3935368</t>
<t tx="ekr.20060928062431">def expandOnlyAncestorsOfNode (self,event=None):
    
    '''Contract all nodes in the outline.'''

    c = self ; level = 1
    
    c.beginUpdate()
    try:
        for p in c.allNodes_iter():
            p.contract()
        for p in c.currentPosition().parents_iter():
            p.expand()
            level += 1
    finally:
        c.endUpdate()
        c.treeWantsFocusNow()

    c.expansionLevel = level # Reset expansion level.
</t>
<t tx="ekr.20060928062431.1">http://sourceforge.net/forum/message.php?msg_id=3935780

This greatly speeds searches that used to open many nodes.</t>
<t tx="ekr.20060928082153">@nocolor

New in beta 2: Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.

@color</t>
<t tx="ekr.20060928110801">http://sourceforge.net/forum/message.php?msg_id=3935981
</t>
<t tx="ekr.20060928111850"></t>
<t tx="ekr.20060928194335"></t>
<t tx="ekr.20060929084830.1"></t>
<t tx="ekr.20060929090247"></t>
<t tx="ekr.20060929090247.1"></t>
<t tx="ekr.20060929090247.2"></t>
<t tx="ekr.20060929091051"></t>
<t tx="ekr.20060929100150">Used brief traceback in g.handleScriptException</t>
<t tx="ekr.20060929100640.1">True: Outline gets focus when a new window is opened.
False Body pane gets focus when a new window is opened.</t>
<t tx="ekr.20060929103258">if toString:
    theActualFile = None
else:
    theActualFile = open(fileName, 'wb')</t>
<t tx="ekr.20060929122217.2"></t>
<t tx="ekr.20060929133002">@nocolor

This was a very weird one.  It's not clear why it wasn't biting before.


Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 321, in &lt;module&gt;
    run(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 151, in run
    g.app.gui.runMainLoop()
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 182, in runMainLoop
    self.root.mainloop()
  File "c:\python25\lib\lib-tk\Tkinter.py", line 1023, in mainloop
    self.tk.mainloop(n)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1756, in __call__
    _reporterror(self.func, args)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1782, in _reporterror
    msg = exc_type + ' Exception in Tk callback\n'
TypeError: unsupported operand type(s) for +: 'type' and 'str'
&gt;&gt;&gt;</t>
<t tx="ekr.20060929141750">@nocolor

- Make showing the Run Script button optional.
- The Script Button button now creates the press-script-button-button command.
- A new utility method does a much better job of massaging button and command names.
</t>
<t tx="ekr.20060929141921"></t>
<t tx="ekr.20060929141921.1"></t>
<t tx="ekr.20060929141941"></t>
<t tx="ekr.20060930085556">True: (Recommended) The find commands collapse all nodes that are not ancestors of the node containing the match.
False: The find command expands nodes needed to show the match, but does not collapse any nodes.</t>
<t tx="ekr.20060930110140"></t>
<t tx="ekr.20060930110925">Up/down arrow keys should move straight up/down, but this is difficult with Tk.
Still the present way is very bad.</t>
<t tx="ekr.20060930111450"></t>
<t tx="ekr.20060930125206"></t>
<t tx="ekr.20060930172926"></t>
<t tx="ekr.20061001060913"></t>
<t tx="ekr.20061001060913.1"></t>
<t tx="ekr.20061001060913.2"></t>
</tnodes>
</leo_file>
