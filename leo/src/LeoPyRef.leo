<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="93" left="311" height="825" width="909"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240" str_leo_pos="9"><vh>Buttons &amp; commands</vh>
<v t="ekr.20060531093331"><vh>@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20060908104329"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20060908104833"><vh>@url Code--&gt; version &amp; signon stuff</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="ekr.20060904165452"><vh>4.4.2 projects</vh>
<v t="ekr.20061010104745"><vh>Bugs</vh>
<v t="ekr.20061010105844"><vh>Fixed crash when searching for headllines containing unicode chars</vh>
<v t="ekr.20031218072017.3054"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20050123164539"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
<v t="ekr.20060417194232.2"><vh>findWord</vh></v>
<v t="ekr.20051025071455.47"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20061010105932"><vh>Fixed failed unit test</vh>
<v t="ekr.20060609150503"><vh>k.initAbbrev</vh></v>
</v>
<v t="ekr.20061007094817"><vh>Fixed bugs in cycle-all-focus command</vh>
<v t="ekr.20051022144825.1"><vh>cycleFocus</vh></v>
<v t="ekr.20060613090701"><vh>cycleAllFocus</vh></v>
<v t="ekr.20051016101724.1"><vh>selectTab</vh></v>
<v t="ekr.20060528170438"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20060613131217"><vh>cycleTabFocus</vh></v>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
<v t="ekr.20060207142332"><vh>c.traceFocus</vh></v>
<v t="ekr.20060207140352"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060127183752"><vh>masterKeyHandler</vh>
<v t="ekr.20060321105403"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20060321105403.1"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20060321105403.2"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20060321105403.3"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20060608070318"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20060309065445"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20060205103842"><vh>c.get/request/set_focus</vh></v>
</v>
<v t="ekr.20061008091617"><vh>Fixed bug: with Alt-n keys</vh>
<v t="ekr.20051015110547"><vh>k.registerCommand</vh></v>
<v t="ekr.20060605130652"><vh>makeMasterGuiBinding</vh></v>
<v t="ekr.20060131075440"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20051012201831"><vh>printBindings &amp; helper</vh>
<v t="ekr.20061007185125"><vh>printBindingsHelper</vh></v>
</v>
<v t="ekr.20060201083154"><vh>k.prettyPrintKey</vh></v>
</v>
</v>
<v t="ekr.20061010115312"><vh>Features</vh>
<v t="ekr.20061009153818"><vh>Added @bool select_all_text_when_editing_headlines</vh>
<v t="ekr.20040803072955.135"><vh>setEditLabelState</vh></v>
</v>
<v t="ekr.20061009152554"><vh>Removed .leoRecentFiles.txt from distribution and cvs</vh>
<v t="ekr.20041117062717.2"><vh>ctor (configClass)</vh></v>
<v t="ekr.20041120064303"><vh>g.app.config.readSettingsFiles</vh></v>
<v t="ekr.20050424115658"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061010121944"><vh>createRecentFiles</vh></v>
<v t="ekr.20050424114937.2"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20050424131051"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20061009154800"><vh>Settings</vh>
<v t="ekr.20061009153504"><vh>Made unlimited undo the default</vh></v>
</v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"
marks="ekr.20040701065235.2,"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20061010115312.1" a="TV"><vh>Urgent: 5</vh>
<v t="ekr.20060927173836.1"><vh>Disable calltips in @nocolor sections</vh></v>
<v t="ekr.20051112080017"><vh>delete-x-script-button</vh></v>
<v t="ekr.20061008114340"><vh>Finish collapse-on-move-left</vh></v>
<v t="ekr.20060927100500.1"><vh>Fix bugs in new colorizer</vh></v>
<v t="ekr.20061009152210.1"><vh>yank/kill/undo do not work as expected</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="2858060000006c6162656c737100540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571017471022e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20050920084036.138,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"
marks="ekr.20060919110638.44,ekr.20040701065235.2,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"
marks="ekr.20031218072017.3419,ekr.20031218072017.3421,ekr.20031218072017.3426,ekr.20031218072017.3438,ekr.20040303214038,ekr.20040303163330,ekr.20040303175026.2,ekr.20040303175026.3,ekr.20040303175026.5,ekr.20040303175026.10,ekr.20040306060312,ekr.20040303175026.11,ekr.20040310062332.4,ekr.20040310062332.5,"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"
marks="ekr.20051113110851,"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"
marks="ekr.20050921103736,"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
</t>
<t tx="ekr.20031218072017.3054">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated (in the subclass by update_ivars) just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# To do: this should depend on language.
self.word_chars = g.toUnicode(string.letters + string.digits + '_',encoding='ascii')

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = None # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"
</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4.2 beta 2, build %s, October 9, 2006" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.
</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()
</t>
<t tx="ekr.20040803072955.135">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove('sel','1.0','end')
        start = g.choose(c.config.getBool('select_all_text_when_editing_headlines'),'1.0','end')
        w.tag_add('sel',start,'end')
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
</t>
<t tx="ekr.20041117062717.2">def __init__ (self):
    
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.modeCommandsDict = {} # For use by @mode logic. Keys are command names, values are g.Bunches.
    self.myGlobalConfigFile = None
    self.myHomeConfigFile = None
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
</t>
<t tx="ekr.20041120064303">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []

    # This can't be done in initSettingsFiles because the local directory does not exits.
    localDirectory = g.os_path_dirname(fileName)
    
    #  Set the local leoSettings.leo file.
    localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
    if not g.os_path_exists(localConfigFile): localConfigFile = None
    
    # Set the local myLeoSetting.leo file.
    myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
    if not g.os_path_exists(myLocalConfigFile): myLocalConfigFile = None
    
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Init settings from leoSettings.leo files, including myLeoSettings.leo.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            if c and localFlag:
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
            self.readRecentFilesFile(c,path)
    if self.write_recent_files_as_needed:
        self.createRecentFiles(fileName)

    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20050123164539">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None
</t>
<t tx="ekr.20050424114937.2">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,'.leoRecentFiles.txt')
            if g.os_path_exists(fileName):
                # g.es_print('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        g.trace('----- not found:',localFileName)
        return
</t>
<t tx="ekr.20050424115658">def readRecentFilesFile (self,c,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'
    
    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    if not g.os_path_exists(fileName):
        # g.trace('does not exist',fileName)
        return
        
    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return

    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
        self.appendToRecentFiles(lines)</t>
<t tx="ekr.20050424131051">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050920085536.45">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    
    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20051001050607">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20051012201831">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)
            
    # Print keys by type:
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        g.es('%s %s' % (sep, prefix),tabName=tabName)
        self.printBindingsHelper(data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    g.es('%s %s' % (sep, 'Plain Keys',),tabName=tabName)
    self.printBindingsHelper(data,n1,n2,prefix=None)
    state = k.unboundKeyAction 
    k.showStateAndMode()
</t>
<t tx="ekr.20051015110547">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = verbose and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                break
        else: stroke = None
  
    if stroke:
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
             g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')
                
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break</t>
<t tx="ekr.20051016101724.1">def selectTab (self,tabName,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName,wrap=wrap)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
</t>
<t tx="ekr.20051022144825.1">def cycleFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget
   
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i &gt;= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body
    
    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)
    
    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane</t>
<t tx="ekr.20051025071455.47"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as Ã©.  I don't know what the solution is.
    word_start = toUnicode(string.letters,encoding='ascii')
    word_end   = toUnicode(string.letters + string.digits,encoding='ascii')
    word_chars = toUnicode(string.letters + string.digits + "`" + "'" + "_",encoding='ascii')
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and line[i] not in word_start:
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051112080017">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?

EKR: This is on the list of unfixable bugs, but I have a hard time believing there is no workaround.</t>
<t tx="ekr.20060127183752">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    &lt;&lt; define vars &gt;&gt;

    if keysym in special_keys:
        return None

    &lt;&lt; do key traces &gt;&gt;

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;
        
    &lt;&lt; handle per-pane bindings &gt;&gt;
    &lt;&lt; handle keys without bindings &gt;&gt;
</t>
<t tx="ekr.20060131075440">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    # g.trace('&lt;%s&gt;' % stroke)
    return '&lt;%s&gt;' % stroke
</t>
<t tx="ekr.20060201083154">def prettyPrintKey (self,stroke,brief=False):
    
    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.tkBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'&lt;%s&gt;' % s)
</t>
<t tx="ekr.20060205103842">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
        c.traceFocus(w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
</t>
<t tx="ekr.20060207140352">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if trace: print \
        'requested',c.widget_name(c.requestedFocusWidget),\
        'present',c.widget_name(c.hasFocusWidget)
    
    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        if trace: print 'no change.',c.widget_name(w)
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        if trace: print '*'*20,'oops: moving to body pane.'
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
</t>
<t tx="ekr.20060207142332">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        print '%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8)
</t>
<t tx="ekr.20060217111834">.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:
    
copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x</t>
<t tx="ekr.20060309065445">def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
</t>
<t tx="ekr.20060321105403">k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
    
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
</t>
<t tx="ekr.20060321105403.1">self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(
        # 'keysym',repr(event.keysym or ''),
        'stroke',repr(stroke),
        'state',state,
        'unboundKeyAction',k.unboundKeyAction)
</t>
<t tx="ekr.20060321105403.2"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
</t>
<t tx="ekr.20060321105403.3">key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(g.app.gui.isTextWidget(w),w_name,key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
</t>
<t tx="ekr.20060417194232.2">def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            word_chars = g.toUnicode(string.letters + string.digits + '_',encoding='ascii')
            while i &lt; len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or s[i-1] not in word_chars)
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()

</t>
<t tx="ekr.20060528170438">def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.onFocusIn(w2,setFocus=True)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060605130652">def makeMasterGuiBinding (self,stroke,w=None):
    
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    
    k = self ; c = k.c ; f = c.frame
   
    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)
    
    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        widgets=(c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)
    
    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
</t>
<t tx="ekr.20060608070318">if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif event and event.keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    # g.trace(stroke,event.char,event.keysym)
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20060609150503">def initAbbrev (self):
    
    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d.keys():
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev: %s: unknown command name: %s' %
                (key,commandName),color='blue')
</t>
<t tx="ekr.20060613090701">editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        if n &gt; 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount &gt; n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n &gt; 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount &gt; n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        editWidgetCount = logWidgetCount = 0
        
    if trace:
        print 'old: %10s new: %10s' % (
            w_name(w),id(w),w_name(pane),pane and id(pane))
    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)</t>
<t tx="ekr.20060613131217">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20060904165452"></t>
<t tx="ekr.20060908104329"></t>
<t tx="ekr.20060908104833"></t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060927100500.1">@nocolor

- Does not restore selection after indent/undent commands.</t>
<t tx="ekr.20060927173836.1">@nocolor

Why are calltips enabled at all??

Show calltips treats the node as code, and that can have very weird effects in @nocolor sections.</t>
<t tx="ekr.20061007094817">@

The logic in cycleAllFocus is now much cleaner.
The cycle focus commands work in the minibuffer *only* if not tab-completion is done.
I think this is the old, horrible problems with Pmw focus: it's a very small nit.</t>
<t tx="ekr.20061007185125">def printBindingsHelper (self,data,n1,n2,prefix):
        
    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.
    
    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) &gt;  1]
        # The list of all other items.
                
    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
</t>
<t tx="ekr.20061008091617">@

@command whaterver @key Alt-1 didn't work
Actually, no Alt-n keys worked for n in (1,2,3,4,5) in any context.

Happily, the problem was a confusion about what Alt-1 means.
Apparently it means Alt-Button-1 rather than Alt-Key-1.

The solution was to insert an explicit Key- prefix in k.tkBindingFromStroke.
I also made a minor mod to printBindings.</t>
<t tx="ekr.20061008114340">@nocolor

cvs now contains support for this new setting:

@bool sparse_move_outline_left

When True, Leo will collapse the (former) parent of a node when moving that node left.  This makes moving outlines left extremely fast, but it takes getting used to it.  I think I like it :-)

To do:

- The move-outline-up/down commands can have the effect of moving an outline left.  At present, the outline isn't collapsed in those cases, but it should be.

- set/clear/toggle-sparce-move-outline-left commands are needed to turn this option on or off at will.

@color</t>
<t tx="ekr.20061009152210.1">http://sourceforge.net/forum/message.php?msg_id=3924236
</t>
<t tx="ekr.20061009152554">@nocolor

- @bool write_recent_files_as_needed = True

People who don't want Leo to update .leoRecentFiles.txt can set this to False.

- Remove .leoRecentFiles from cvs
- Remove .leoRecentFiles from distribution list.

@color</t>
<t tx="ekr.20061009153504">@nocolor

As always, you can set max_undo_stack_size in myLeoSettings.leo.</t>
<t tx="ekr.20061009153818">A highly useful option
</t>
<t tx="ekr.20061009154800"></t>
<t tx="ekr.20061010104745"></t>
<t tx="ekr.20061010105844">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\unitTest.leo
FAILED (failures=1)
UnicodeDecodeError Exception in Tk callback
  Function: &lt;function masterBindKeyCallback at 0x018BD970&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x02B0B5F8&gt;,)
  Event type: KeyPress (type num: 2)
  
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2118, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 3133, in masterKeyHandler
    return k.getArg(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2755, in getArg
    if handler: handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7191, in searchWithPresentOptions
    self.generalSearchHelper(k.arg)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7066, in generalSearchHelper
    self.finder.findNextCommand()
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7676, in findNextCommand
    self.findNext()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 684, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 711, in findNextMatch
    pos, newpos = self.search()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 746, in search
    regexp=self.pattern_match,word=self.whole_word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 780, in searchHelper
    pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 856, in plainHelper
    elif self.matchWord(s,k,pattern):
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 871, in matchWord
    s[i-1] not in self.word_chars or
UnicodeDecodeError: 'ascii' codec can't decode byte 0x83 in position 52: ordinal not in range(128)

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 49425
    state: 0
    time: 17007655
    type: 2
    widget: .21619056.21619656.24867464.minibuffer
    width: ??
    x: 526
    x_root: 782
    y: -648
    y_root: 240

</t>
<t tx="ekr.20061010105932">@nocolor

FAIL: @test k.inverseCommandsDict is inverse of c.commandsDict
AssertionError: cl not in inverseCommandsDict.values()

I just hacked the unit test not to complain about abbreviations.
Another solution would be to allow the values of k.inverseCommandsDict to be lists.</t>
<t tx="ekr.20061010115312"></t>
<t tx="ekr.20061010115312.1"></t>
<t tx="ekr.20061010121944">def createRecentFiles (self,fileName):
    
    localPath,junk = g.os_path_split(fileName)

    for path in (g.app.homeDir,g.app.globalConfigDir,localPath):
        fileName = g.os_path_join(path,'.leoRecentFiles.txt')
        if g.os_path_exists(fileName):
            # g.es_print('found %s' % fileName)
            return

    # Create the file in the home directory.
    try:
        fileName = g.os_path_join(g.app.homeDir,'.leoRecentFiles.txt')
        f = file(fileName,'w')
        f.close()
        g.es_print('Created %s' % (fileName),color='red')
        return
    except Exception:
        g.es_print('Exception creating %s' % (fileName),color='red')
        g.es_exception()</t>
</tnodes>
</leo_file>
