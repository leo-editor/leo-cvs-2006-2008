<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="153" left="326" height="759" width="857"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240" str_leo_pos="9"><vh>Buttons &amp; commands</vh>
<v t="ekr.20060531093331"><vh>@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20060908104329"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20051113110851,ekr.20050921103736,ekr.20031218072017.3803,ekr.20050920084036.138,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20061028211424.46,ekr.20061028211424.47,ekr.20061028211424.50,ekr.20061028211424.52,ekr.20061028070057.22,ekr.20061028070057.37,ekr.20061028070057.54,ekr.20061028070057.55,ekr.20051126124705,ekr.20060216163305,"
expanded="ekr.20070105135851,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"
marks="ekr.20040701065235.2,"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20060531161030" a="TV"><vh>To do: 4.4.3</vh>
<v t="ekr.20070105135851" a="E"><vh>To do first</vh>
<v t="ekr.20070105121752"><vh>Add Find &amp; Spell tabs to log pane on startup</vh></v>
<v t="ekr.20061209083136"><vh>Complete the wxGui plugin</vh>
<v t="ekr.20061115111353"><vh>(Remove special tk indices)</vh>
<v t="ekr.20051025071455.47"><vh>findNextWord (tkSpell)</vh></v>
<v t="ekr.20050920084036.27"><vh>expandAbbrev</vh></v>
<v t="ekr.20050920084036.22"><vh>&lt;&lt; define a new generator searchXR &gt;&gt;</vh></v>
<v t="ekr.20050920084036.134"><vh>indentToCommentColumn (test)</vh></v>
<v t="ekr.20050920084036.59"><vh>dynamicExpansion (to do)</vh></v>
<v t="ekr.20050920084036.60"><vh>dynamicExpansion2 (to do)</vh></v>
<v t="ekr.20050920084036.67"><vh>centerLine (pass)</vh></v>
<v t="ekr.20050920084036.69"><vh>centerRegion (passed)</vh></v>
<v t="ekr.20050920084036.70"><vh>setFillPrefix (test)</vh></v>
<v t="ekr.20050920084036.75"><vh>backToIndentation (test)</vh></v>
<v t="ekr.20050920084036.76"><vh>deleteIndentation (test)</vh></v>
<v t="ekr.20050920084036.78"><vh>indentRelative</vh></v>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20050920084036.135"><vh>deleteSpaces (to do)</vh></v>
<v t="ekr.20050920084036.77"><vh>splitLine (test)</vh></v>
<v t="ekr.20060113105246.1"><vh>moveUpOrDownHelper (passed)</vh></v>
<v t="ekr.20051218133207.1"><vh>forwardParagraphHelper (passed)</vh></v>
<v t="ekr.20051218133207"><vh>backwardParagraphHelper (passed)</vh></v>
<v t="ekr.20051218141237"><vh>lines (test)</vh></v>
<v t="ekr.20050920084036.99"><vh>backwardKillParagraph (passed)</vh></v>
<v t="ekr.20050920084036.103"><vh>fillParagraph</vh></v>
<v t="ekr.20050920084036.100"><vh>fillRegion</vh></v>
<v t="ekr.20050920084036.104"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20050920084036.98"><vh>killParagraph (passed)</vh></v>
<v t="ekr.20050920084036.96"><vh>extend-to-paragraph &amp; helper (passed)</vh>
<v t="ekr.20050920084036.97"><vh>selectParagraphHelper</vh></v>
</v>
<v t="ekr.20050920084036.97"><vh>selectParagraphHelper</vh></v>
<v t="ekr.20050920084036.107"><vh>indentRegion (not used: use c.indentBody instead)</vh></v>
<v t="ekr.20050920084036.108"><vh>tabIndentRegion (indent-rigidly)</vh></v>
<v t="ekr.20060417183606"><vh>moveLinesDown (pass hand test)</vh></v>
<v t="ekr.20060417183606.1"><vh>moveLinesUp (pass hand test)</vh></v>
<v t="ekr.20050920084036.110"><vh>reverseRegion</vh></v>
<v t="ekr.20050920084036.118"><vh>sortLines</vh></v>
<v t="ekr.20050920084036.119"><vh>sortColumns</vh></v>
<v t="ekr.20050920084036.120"><vh>sortFields</vh></v>
<v t="ekr.20060529184652"><vh>swapHelper</vh></v>
<v t="ekr.20050920084036.122"><vh>transposeLines (pass)</vh></v>
<v t="ekr.20050920084036.123"><vh>swapWords</vh></v>
<v t="ekr.20050920084036.180"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20050920084036.229"><vh>yankRectangle</vh></v>
</v>
<v t="ekr.20061127171128"><vh>Fix wiki markup bug (test)</vh>
<v t="ekr.20060113105246.1"><vh>moveUpOrDownHelper (passed)</vh></v>
</v>
<v t="ekr.20061105134302"><vh>Crasher</vh></v>
<v t="ekr.20061116054917.4"><vh>Improve body widget</vh>
<v t="ekr.20061114122858.2"><vh>Test for i != j in w.replace</vh></v>
<v t="ekr.20061114122858.1"><vh>Define w.name method</vh></v>
<v t="ekr.20061113171540"><vh>create nullTextWidget for nullGui</vh></v>
<v t="ekr.20061116054917.5"><vh>Move gui.get/set_focus to body widget</vh></v>
</v>
<v t="ekr.20061212095134"><vh>Added tabs to wxLog</vh>
<v t="ekr.20051016101724.1"><vh>selectTab</vh></v>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051024173701"><vh>createTab</vh>
<v t="ekr.20051018072306"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061212085958.2"><vh>Refactored the findTab class</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__ &amp; initGui</vh></v>
<v t="ekr.20061212092124"><vh>Defined in subclasses</vh></v>
</v>
<v t="ekr.20060221074900"><vh>Callbacks</vh>
<v t="ekr.20060221074900.1"><vh>findButtonCallback</vh></v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
</v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
<v t="ekr.20070105123638"><vh>changeAllCommand</vh></v>
<v t="ekr.20060128075225"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20060204120158.1"><vh>findAgainCommand</vh></v>
<v t="ekr.20060209064832"><vh>findAllCommand</vh></v>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
</v>
</v>
<v t="ekr.20061212085958"><vh>class tkFindTab (findTab)</vh>
<v t="ekr.20061212085958.1"><vh> Birth</vh>
<v t="ekr.20051020120306.12"><vh>initGui</vh></v>
<v t="ekr.20051020120306.13"><vh>createFrame (tkFindTab)</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>createBindings (tkFindTab)</vh></v>
</v>
</v>
</v>
<v t="ekr.20061212110702"><vh>Remove Tk code from minibufferFind class</vh>
<v t="ekr.20060124122844"><vh>setOption (minibufferFind: Tk code)</vh></v>
<v t="ekr.20060125082510"><vh>getOption (minibufferFind: Tk code)</vh></v>
<v t="ekr.20060124135401"><vh>toggleOption (minibufferFind: tk code)</vh></v>
</v>
<v t="ekr.20041223102225"><vh>class tkIconBarClass</vh>
<v t="ekr.20041223102225.1"><vh> ctor</vh></v>
<v t="ekr.20031218072017.3958"><vh>add</vh>
<v t="ekr.20031218072017.3959"><vh>&lt;&lt; create a picture &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3956"><vh>clear</vh></v>
<v t="ekr.20061213091114.1"><vh>deleteButton (new in Leo 4.4.3)</vh></v>
<v t="ekr.20041223114821"><vh>getFrame</vh></v>
<v t="ekr.20041223102225.2"><vh>pack (show)</vh></v>
<v t="ekr.20061213092103"><vh>setCommandForButton (new in Leo 4.4.3)</vh></v>
<v t="ekr.20031218072017.3955"><vh>unpack (hide)</vh></v>
</v>
</v>
</v>
<v t="ekr.20061209082338"><vh>Docs</vh>
<v t="ekr.20061127181712"><vh>Make sure that the uA docs mention str_ attributes (and other escapes?)</vh></v>
<v t="ekr.20061130084909"><vh>Improve What's special whitepaper</vh></v>
<v t="ekr.20061029100330.1"><vh>Better pymacs docs &amp; examples</vh></v>
</v>
<v t="ekr.20061209081047"><vh>Fix bugs</vh>
<v t="ekr.20061030074731"><vh>Create standard pluginsManager.txt only if it does not exist</vh></v>
<v t="ekr.20061101174435"><vh>Fix clone-drag problem</vh></v>
<v t="ekr.20061022190904"><vh>use g.globalDirectiveDict rather than leoColor.leoKeywords in at.directiveKind4</vh></v>
<v t="ekr.20061127170820.1"><vh>Allow spaces in new filenames (a Mac problem?)</vh></v>
<v t="ekr.20061110214440"><vh>Make sure all ancestors expanded when select a body editor with multiple body editors</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1" a="M"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="2858060000006c6162656c737100540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571017471022e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"
marks="ekr.20041005105605.52,ekr.20041005105605.198,"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"
marks="ekr.20031218072017.1607,ekr.20031218072017.1896,ekr.20031218072017.2803,"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.1,ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20050920084036.138,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018" a="E"
marks="ekr.20060919110638.44,ekr.20040701065235.2,"
expanded="ekr.20031218072017.3032,ekr.20031218072017.3046,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"
marks="ekr.20031218072017.3132,ekr.20031218072017.3124,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"
marks="ekr.20031218072017.3419,ekr.20031218072017.3421,ekr.20031218072017.3426,ekr.20031218072017.3438,ekr.20040303214038,ekr.20040303163330,ekr.20040303175026.2,ekr.20040303175026.3,ekr.20040303175026.5,ekr.20040303175026.10,ekr.20040306060312,ekr.20040303175026.11,ekr.20040310062332.4,ekr.20040310062332.5,"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20031218072017.3446"
marks="ekr.20031218072017.3601,"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"
marks="ekr.20051113110851,"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"
marks="ekr.20050921103736,ekr.20031218072017.3803,"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"
marks="ekr.20060211144330.1,"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3955">def unpack (self):
    
    """Hide the icon bar by unpacking it.
    
    A later call to show will repack it in a new location."""
    
    if self.visible:
        self.visible = False
        self.iconFrame.pack_forget()
        
hide = unpack
</t>
<t tx="ekr.20031218072017.3956">def clear(self):
    
    """Destroy all the widgets in the icon bar"""
    
    f = self.iconFrame
    
    for slave in f.pack_slaves():
        slave.destroy()
    self.visible = False

    f.configure(height="5m") # The default height.
    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
</t>
<t tx="ekr.20031218072017.3958">def add(self,*args,**keys):
    
    """Add a button containing text or a picture to the icon bar.
    
    Pictures take precedence over text"""
    
    f = self.iconFrame
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    # First define n.
    try:
        g.app.iconWidgetCount += 1
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 1

    if not command:
        def command():
            print "command for widget %s" % (n)

    if imagefile or image:
        &lt;&lt; create a picture &gt;&gt;
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if sys.platform != 'darwin':
            width = max(6,len(text))
            b.configure(width=width)
        b.pack(side="left", fill="y")
        return b
        
    return None
</t>
<t tx="ekr.20031218072017.3959">try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        
        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []
    
        refs.append((imagefile,image),)
    
    if not bg:
        bg = f.cget("bg")

    b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b
    
except:
    g.es_exception()
    return None
</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"
</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4.3 beta 1, build %s, October 29, 2006" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision$" # CVS updates this.
</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()
</t>
<t tx="ekr.20041223102225">class tkIconBarClass:
    
    '''A class representing the singleton Icon bar'''
    
    @others
</t>
<t tx="ekr.20041223102225.1">def __init__ (self,c,parentFrame):
    
    self.c = c
    
    self.buttons = {}
    self.iconFrame = w = Tk.Frame(parentFrame,height="5m",bd=2,relief="groove")
    self.c.frame.iconFrame = self.iconFrame
    self.parentFrame = parentFrame
    self.visible = False
    self.show()
</t>
<t tx="ekr.20041223102225.2">def pack (self):
    
    """Show the icon bar by repacking it"""
    
    if not self.visible:
        self.visible = True
        self.iconFrame.pack(fill="x",pady=2)
        
show = pack
</t>
<t tx="ekr.20041223114821">def getFrame (self):

    return self.iconFrame
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050920084036.22">@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.mark_set('insert',ins)
    w.selection_clear()
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
</t>
<t tx="ekr.20050920084036.27">def expandAbbrev (self,event):
    
    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.'''

    k = self.k ; c = self.c ; ch = event.char.strip()
    w = self.editWidget(event)
    if not w: return

    word = w.get('insert -1c wordstart','insert -1c wordend')
    g.trace('ch',repr(ch),'word',repr(word))
    if ch:
        # We must do this: expandAbbrev is called from Alt-x and Control-x,
        # we get two differnt types of data and w states.
        word = '%s%s'% (word,ch)
        
    val = self.abbrevs.get(word)
    if val is not None:
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Typing')
        
    return val is not None
</t>
<t tx="ekr.20050920084036.59">def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
</t>
<t tx="ekr.20050920084036.60">def dynamicExpansion2 (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)
</t>
<t tx="ekr.20050920084036.67">def centerLine (self,event):

    '''Centers line within current fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) &gt;= self.fillColumn: return
    
    self.beginCommand(undoType='center-line')
    n = (self.fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k &gt; i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.69">def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    while ind &lt; end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) &gt;= self.fillColumn:
            ind = j
        else:
            n = (self.fillColumn-len(line)) / 2
            k = g.skip_ws(s,i)
            if k &gt; i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.70">def setFillPrefix( self, event ):
    
    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    ###txt = w.get( 'insert linestart', 'insert' )
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,junk = g.getLine(s,ins)
    txt = s[i:ins]
    self.fillPrefix = txt
</t>
<t tx="ekr.20050920084036.75">def backToIndentation (self,event):
    
    '''Position the point at the first non-blank character on the line.'''
    
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    ###i = w.index('insert linestart')
    s = w.getAllText()
    i = w.getInsertPoint()
    i,j = g.getLine(s,i)
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    ###i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    i2 = w.search(r'\w',i,j,regexp=True)
    ###w.mark_set('insert',i2)
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.76">def deleteIndentation (self,event):
    
    '''Delete indentation in the presently line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    self.beginCommand(undoType='delete-indentation')

    ###txt = w.get('insert linestart','insert lineend')
    ###txt = ' %s' % txt.lstrip()
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    txt = s[i:j].strip()
    ###w.delete('insert linestart','insert lineend +1c')
    w.delete(i,j)
    ###i = w.index('insert - 1c')
    ###w.insert('insert -1c',txt)
    w.insert(ins-1,txt)
    ###w.mark_set('insert',i)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.77">def splitLine (self,event):
    
    '''Split a line at the cursor position.'''

    w = self.editWidget(event)
    if not w: return

    s = w.get('insert linestart','insert lineend')
    
    self.beginCommand(undoType='split-line')
    s = self.getWSString(s)
    i = w.getInsertPoint()
    w.insert(i,s + '\n')
    # w.mark_set('insert',i)
    # w.insert('insert','\n')
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.78">def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'indent-relative' ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    oldYview = w.yview()
    # Find the previous non-blank line
    i,j = g.getLine(s,ins)
    while 1:
        if i &lt;= 0: return
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(undoType=undoType)
    try:
        k = g.skip_ws(s,i)
        ws = s[i:k]
        i2,j2 = g.getLine(s,ins)
        k = g.skip_ws(s,i2)
        line = ws + s[k:j2]
        w.delete(i2,j2)
        w.insert(i2,line)
        w.setInsertPoint(i2+len(ws))
        c.frame.body.onBodyChanged(undoType,oldSel=oldSel,oldText=s,oldYview=oldYview)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.96">def extendToParagraph (self,event):
    
    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i &gt; 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j &lt; len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
</t>
<t tx="ekr.20050920084036.97">def selectParagraphHelper (self,w,start):
    
    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j &lt; len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break
        
    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
</t>
<t tx="ekr.20050920084036.98">def killParagraph (self,event):
    
    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.99">def backwardKillParagraph (self,event):
    
    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i &gt; 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.100">def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''
    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region')

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == 0:
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        ###if w.compare('insert','&gt;',s2):
        if w.getInsertPoint() &gt; s2:
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.103">def fillParagraph( self, event ):
    
    '''Fill the selected paragraph'''
    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.strip()
    if txt:
        self.beginCommand(undoType='fill-paragraph')
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == 0:
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.strip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.strip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.104">def fillRegionAsParagraph (self,event):
    
    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region-as-paragraph')

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.107">def indentRegion (self,event):
    w = self.editWidget(event)
    if not w: return

    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
    # self.removeRKeys(w)</t>
<t tx="ekr.20050920084036.108">def tabIndentRegion (self,event):
    
    '''Insert a hard tab at the start of each line of the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='indent-rigidly')

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)
</t>
<t tx="ekr.20050920084036.110">def reverseRegion (self,event):
    
    '''Reverse the order of lines in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()
    
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.118">def sortLines (self,event,which=None):
    
    '''Sort lines of the selected text by comparing the entire text of a line.
    A prefix argument means sort in descending order.'''

    c = self.c ; k = c.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.119">def sortColumns (self,event):
    
    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-columns')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i &lt;= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.120">def sortFields (self,event,which=None):
    
    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.122">def transposeLines (self,event):
    
    '''Transpose the line containing the cursor with the preceding line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    if not s.strip(): return

    i,j = g.getLine(s,ins)
    line1 = s[i:j]
    
    self.beginCommand(undoType='transpose-lines')
    
    if i == 0: # Transpose the next line.
        i2,j2 = g.getLine(s,j+1)
        line2 = s[i2:j2]
        w.delete(0,j2)
        w.insert(0,line2+line1)
        w.setInsertPoint(j2-1)
    else: # Transpose the previous line.
        i2,j2 = g.getLine(s,i-1)
        line2 = s[i2:j2]
        w.delete(i2,j)
        w.insert(i2,line1+line2)
        w.setInsertPoint(j-1)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.123">def swapWords (self,event,swapspots):
    
    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return

    txt = w.get('insert wordstart','insert wordend')
    if not txt: return
    
    i = w.index('insert wordstart')
    
    self.beginCommand(undoType='swap-words')

    if len(swapspots) != 0:
        if w.compare(i,'&gt;',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'&lt;',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.134">def indentToCommentColumn (self,event):

    '''Insert whitespace to indent to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint()) 
    i1,i2 = g.convertPythonIndexToRowCol(s,i)
    c1 = int(self.ccolumn)

    if i2 &lt; c1:
        wsn = c1- i2
        ###w.insert('insert lineend',' '*wsn)
        w.insert(i,' '*wsn)
    if i2 &gt;= c1:
        ###w.insert('insert lineend',' ')
        w.insert(i,' ')
    ###w.mark_set('insert','insert lineend')
    w.setInsertPoint(i)
    
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.135">def deleteSpaces (self,event,insertspace=False):
    
    '''Delete all whitespace surrounding the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    self.beginCommand(undoType=undoType)

    i = w.getInsertPoint()
    wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
    if '' not in (wf,wb):
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.180">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20050920084036.229">def yankRectangle (self,event,killRect=None):
    
    '''Yank into the rectangle defined by the start and end of selected text.'''
    
    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    killRect = killRect or self.theKillRectangle
    if not killRect:
        k.setLabelGrey('No kill rect')
        return
        
    w,r1,r2,r3,r4 = self.beginCommand('yank-rectangle')
    
    # Change the text.
    txt = w.get('insert linestart','insert')
    txt = self.getWSString(txt)
    i = w.getInsertPoint()
    i1, i2 = i.split('.')
    i1 = int(i1)
    for z in killRect:
        txt2 = w.get('%s.0 linestart' % i1,'%s.%s' % (i1,i2))
        if len(txt2) != len(txt):
            amount = len(txt) - len(txt2)
            z = txt [-amount:] + z
        w.insert('%s.%s' % (i1,i2),z)
        if w.index('%s.0 lineend +1c' % i1) == w.index('end'):
            w.insert('%s.0 lineend' % i1,'\n')
        i1 += 1

    self.endCommand()
</t>
<t tx="ekr.20051016101724.1">def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c
    
    tabFrame = self.frameDict.get(tabName)
    logCtrl = self.textDict.get(tabName)

    if tabFrame and logCtrl:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    elif not tabFrame:
        self.createTab(tabName,createText=createText,wrap=wrap)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
</t>
<t tx="ekr.20051018072306">w = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'

if wrap not in ('none','char','word'): wrap = 'none'
try: w.configure(bg=bg,wrap=wrap)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=w)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = w

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags
</t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None,show=True):
    
    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = self.inited
        
    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)
        
    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others
</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):
    
    # g.trace('findTab',g.callers())

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
    </t>
<t tx="ekr.20051020120306.12">def initGui (self):

    self.svarDict = {}
    
    for key in self.intKeys:
        self.svarDict[key] = Tk.IntVar()
    
    for key in self.newStringKeys:
        self.svarDict[key] = Tk.StringVar()

</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')

    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    
    if  self.optionsOnly:
        buttons = []
    else:
        &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = g.app.gui.leoTextWidgetClass(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = g.app.gui.leoTextWidgetClass(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = g.app.gui.leoTextWidgetClass(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = g.app.gui.leoTextWidgetClass(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")
</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    c = self.c
    c.widgetWantsFocusNow(w)
    w.setSelectionRange(0,0)
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = w.getSelectionRange()
    if data: start,end = data
    else: start = end = w.getInsertPoint()
    w.replace(start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)
</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&amp;t Change",self.svarDict["script_change"]),
    ("Whole &amp;Word", self.svarDict["whole_word"]),
    ("&amp;Ignore Case",self.svarDict["ignore_case"]),
    ("Wrap &amp;Around",self.svarDict["wrap"]),
    ("&amp;Reverse",    self.svarDict["reverse"]),
    ('Rege&amp;xp',     self.svarDict['pattern_match']),
    ("Mark &amp;Finds", self.svarDict["mark_finds"]),
]

radioLists[1] = [
    (self.svarDict["radio-search-scope"],"&amp;Entire Outline","entire-outline"),
    (self.svarDict["radio-search-scope"],"&amp;Suboutline Only","suboutline-only"),  
    (self.svarDict["radio-search-scope"],"&amp;Node Only","node-only"),
]

checkLists[1] = [
    ("Search &amp;Headline", self.svarDict["search_headline"]),
    ("Search &amp;Body",     self.svarDict["search_body"]),
    ("Mark &amp;Changes",    self.svarDict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)
        
    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    findButtonBindingCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)
</t>
<t tx="ekr.20051024173701">def createTab (self,tabName,createText=True,wrap='none'):
    
    # g.trace(tabName,wrap)
    
    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    if createText:
        &lt;&lt; Create the tab's text widget &gt;&gt;
        if tabName != 'Log':
            # c.k doesn't exist when the log pane is created.
            # k.makeAllBindings will call setTabBindings('Log')
            self.setTabBindings(tabName)
    else:
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabFrame
</t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()
</t>
<t tx="ekr.20051025071455.47">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; w = self.workCtrl ; s = w.getAllText() ; p = p.copy()
    while 1:
        i = w.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # g.trace(repr(word)) # This trace verifies that all words have been checked.
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w2.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            w.delete(0,'end')
            w.insert(0,p.bodyString())
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w.setSelectionRange(0,0,insert=0)
    return None,None</t>
<t tx="ekr.20051026092746">s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051218133207">def backwardParagraphHelper (self,event,extend):
    
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i &gt; 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20051218133207.1">def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1
        
    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20051218141237">def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)
    
def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)
    
def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)
    
def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
</t>
<t tx="ekr.20060113105246.1">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # Make the insertion cursor visible so bbox won't return an empty list.
    w.seeInsertPoint()
    
    # Compute the new spot.
    ins = w.getInsertPoint()
    s = w.getAllText()
    row1,col1 = g.convertPythonIndexToRowCol(s,ins)
    
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))

    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y &gt;= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)

    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width / 2: x = newx + width + 1
    
    # Make the move
    spot = w.xyToPythonIndex(x,y)
    self.extendHelper(w,extend,spot,upOrDown=True)
</t>
<t tx="ekr.20060124122844">def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20060124135401">def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20060125082510">def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.svarDict.get(ivar)
    if var:
        val = var.get()
        verbose and g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
</t>
<t tx="ekr.20060128075225">def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20060204120158.1">def findAgainCommand (self):
    
    s = self.find_ctrl.getAllText()
    
    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
</t>
<t tx="ekr.20060209064832">def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
</t>
<t tx="ekr.20060217111834">.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:
    
copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x</t>
<t tx="ekr.20060221074900"></t>
<t tx="ekr.20060221074900.1">def findButtonCallback(self,event=None):
    
    self.findButton()
    return 'break'
</t>
<t tx="ekr.20060417183606">def moveLinesDown (self,event):
    
    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j &lt; len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            w.focus_force()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20060417183606.1">def moveLinesUp (self,event):
    
    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i &gt; 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            w.focus_force()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20060529184652">def swapHelper (self,w,find,ftext,lind,ltext):

    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060531161030"></t>
<t tx="ekr.20060908104329"></t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20061022190904">@nocolor

Having two lists for the same thing is very bad.
When this is fixed we will be able to simplify the multifile plugin.</t>
<t tx="ekr.20061029100330.1">- Better install notes.

- Better Python scripting examples (multi-line scripts).</t>
<t tx="ekr.20061030074731">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3987635
By: rogererens

At present I have to go through the list in the Plugin Manager again, trying to
remember which plugins I had enabled in the previous version.

Possibly the .leoRecentFiles.txt construct analogue may be used?</t>
<t tx="ekr.20061101174435">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991369
By: rich_ries

The mousal Ctrl+Left Button does NOT result in a cloning of the chosen node.
When I do a Ctrl+Left Click, the drag message is "dragged node will be moved",
and move -- not clone -- it does.

@bool allow_clone_drags = True
@bool enable_drag_messages = True
@bool look_for_control_drag_on_mouse_down = True</t>
<t tx="ekr.20061105134302">Typed '(' in canvas pane.

Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoCommands.py", line 268, in doCommand
    val = command(event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 348, in showCalltips
    self.leadinWord = self.findCalltipWord(w)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 722, in findCalltipWord
    s = gui.getAllText(w)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 809, in getAllText
    s = w.get("1.0","end-1c") # New in 4.4.1: use end-1c.
AttributeError: Canvas instance has no attribute 'get'</t>
<t tx="ekr.20061110214440"></t>
<t tx="ekr.20061113171540"></t>
<t tx="ekr.20061114122858.1"></t>
<t tx="ekr.20061114122858.2"></t>
<t tx="ekr.20061115111353">@nocolor

To do:
    
- remove calls to w.search

- need wrapper for tag_remove

@color</t>
<t tx="ekr.20061116054917.4"></t>
<t tx="ekr.20061116054917.5"></t>
<t tx="ekr.20061127170820.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3992390

The 'username' in the path is just edited by me: in the original error message
it is my login name, of course.

What was happening is the following. 
Yesterday I was playing with Leo 4.4.2.1 and I often could not create *new*
Leo files in certain directories.
Leo would just give me the above error message. After some experimentation,
I found out that when there was a space somewhere in the path from where I started
Leo (and planned to save the file), Leo would give me the above error message.
When the path would not contain a space, Leo would happily save the file.

Note that I only have this problem with *new* files. Leo files that have already
been created can be opened and saved everywhere.

Perhaps this is only a problem for Mac OS X, but earlier versions of Leo (and
Mac OS X) did not have this behaviour.

Theo</t>
<t tx="ekr.20061127171128">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3994218
By: rich_ries

Leo 4.4.2.1 (also seen in 4.4 final)

I was commenting some code, using the markup marks for various emphases. When
I went back and moved the cursor over the first two characters (the hidden markup
characters) of the line, I got the following error message:

===========================================================
exception executing command
Traceback (most recent call last):

  File "...leoCommands.py",line 264, in doCommand
    val = command(event)

  File "...leoEditCommands.py", line 3703, in nextLine
    g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-1c') # works

  File "...leoEditCommands.py", line 3314, in moveUpOrDownHelper
    txt = w.get( 'insert linestart', 'insert lineend' )

TypeError: unpack non-sequence
===========================================================

I did not get this when moving the cursor over the visible characters.

@color</t>
<t tx="ekr.20061127181712"></t>
<t tx="ekr.20061130084909">@nocolor

- Answer the question: how can Leo help me with programming.
    
</t>
<t tx="ekr.20061209081047"></t>
<t tx="ekr.20061209082338"></t>
<t tx="ekr.20061209083136">@nocolor

Bugs

* Arrow keys do not work properly.
- Shortcuts not shown in wx menus
- Focus commands do not work
- Alt-D does not work when outline selected

* Refactor to minimize work done in wx subclasses.

- Fix all unit tests.
- It's not clear what to do about k.shortcutFromSetting.
- Move Tk tables to Tk gui.

@color</t>
<t tx="ekr.20061212085958">class tkFindTab (leoFind.findTab):
    
    '''A subclass of the findTab class containing all Tk code.'''

    @others</t>
<t tx="ekr.20061212085958.1">if 0: # We can use the base-class ctor.

    def __init__ (self,c,parentFrame):
    
        leoFind.findTab.__init__(self,c,parentFrame)
            # Init the base class.
            # Calls initGui, createFrame, createBindings &amp; init(c), in that order.
</t>
<t tx="ekr.20061212085958.2"></t>
<t tx="ekr.20061212092124">def createBindings (self):
    self.oops()
    
def createFrame (self):
    self.oops()
    
def initGui (self):
    pass # Optional method.
    
# self.oops is defined in the leoFind class.</t>
<t tx="ekr.20061212095134"></t>
<t tx="ekr.20061212110702"></t>
<t tx="ekr.20061213091114.1">def deleteButton (self,w):
    
    w.pack_forget()
</t>
<t tx="ekr.20061213092103">def setCommandForButton(self,b,command):
    
    b.configure(command=command)
</t>
<t tx="ekr.20070105121752"># Perhaps there should be an option for the spell tab.</t>
<t tx="ekr.20070105123638">def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
</t>
<t tx="ekr.20070105135851"></t>
</tnodes>
</leo_file>
