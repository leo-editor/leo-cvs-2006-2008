<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.412472647702">
	<global_window_position top="16" left="358" height="914" width="853"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240" str_leo_pos="9"><vh>Startup</vh>
<v t="ekr.20070619130151"><vh>Buttons</vh>
<v t="ekr.20070201082722"><vh>@button Beautify</vh></v>
<v t="ekr.20070627144218"><vh>@button unit-tests @key=Alt+4</vh></v>
<v t="ekr.20070627144218.1"><vh>@button all-unit-tests @key=Alt+5</vh></v>
<v t="ekr.20070629073827"><vh>Disabled buttons</vh>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
<v t="ekr.20070628175250"><vh>@@button Add if g.unitTesting @key=f6</vh></v>
</v>
</v>
<v t="ekr.20060531093331"><vh>@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070603183100"><vh>@settings</vh>
<v t="ekr.20070603183100.1"><vh>@bool use_chapters = True</vh></v>
<v t="ekr.20070605104326"><vh>@bool use_chapter_tabs = True</vh></v>
</v>
<v t="ekr.20070605104410"><vh>@chapters</vh></v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20060908104329"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20070703122141.102,ekr.20070707113832.1,ekr.20070707190351,ekr.20070707171329,"
expanded="ekr.20070703122141.65,ekr.20070707071124,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@thin leoBridge.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@thin leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20070627083814"><vh>Unit tests</vh>
<v t="ekr.20070627083814.1"><vh>@thin unitTests.txt</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3206"
marks="ekr.20070703122141.102,ekr.20070707113832.1,ekr.20070707190351,ekr.20070707171329,"
expanded="ekr.20070703122141.65,ekr.20070707071124,"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20070706152845"><vh>To do first</vh></v>
<v t="ekr.20070324084040"><vh>(Rewrite import code to support @auto)</vh>
<v t="ekr.20031218072017.3151"><vh>Scanning... (leoGlobals.py)</vh>
<v t="ekr.20031218072017.3152"><vh>g.scanAtFileOptions (used in 3.x read code)</vh>
<v t="ekr.20031218072017.3153"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3154"><vh>scanAtRootOptions</vh>
<v t="ekr.20031218072017.3155"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3156"><vh>scanError</vh></v>
<v t="ekr.20031218072017.3157"><vh>scanf</vh></v>
<v t="ekr.20031218072017.3158"><vh>Scanners: calling scanError</vh>
<v t="ekr.20031218072017.3159"><vh>skip_block_comment</vh></v>
<v t="ekr.20031218072017.3160"><vh>skip_braces</vh></v>
<v t="ekr.20031218072017.3161"><vh>skip_php_braces (Dave Hein)</vh></v>
<v t="ekr.20031218072017.3162"><vh>skip_parens</vh></v>
<v t="ekr.20031218072017.3163"><vh>skip_pascal_begin_end</vh></v>
<v t="ekr.20031218072017.3164"><vh>skip_pascal_block_comment</vh></v>
<v t="ekr.20031218072017.3165"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="ekr.20031218072017.3166"><vh>skip_heredoc_string : called by php import (Dave Hein)</vh></v>
<v t="ekr.20031218072017.3167"><vh>skip_pp_directive</vh></v>
<v t="ekr.20031218072017.3168"><vh>skip_pp_if</vh></v>
<v t="ekr.20031218072017.3169"><vh>skip_pp_part</vh></v>
<v t="ekr.20031218072017.3170"><vh>skip_python_string</vh></v>
<v t="ekr.20031218072017.2369"><vh>skip_string</vh></v>
<v t="ekr.20031218072017.3171"><vh>skip_to_semicolon</vh></v>
<v t="ekr.20031218072017.3172"><vh>skip_typedef</vh></v>
</v>
<v t="ekr.20031218072017.3173"><vh>Scanners: no error messages</vh>
<v t="ekr.20031218072017.3174"><vh>escaped</vh></v>
<v t="ekr.20031218072017.3175"><vh>find_line_start</vh></v>
<v t="ekr.20031218072017.3176"><vh>find_on_line</vh></v>
<v t="ekr.20031218072017.3177"><vh>is_c_id</vh></v>
<v t="ekr.20031218072017.3178"><vh>is_nl</vh></v>
<v t="ekr.20031218072017.3179"><vh>is_special</vh></v>
<v t="ekr.20031218072017.3180"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="ekr.20031218072017.3181"><vh>match</vh></v>
<v t="ekr.20031218072017.3182"><vh>match_c_word</vh></v>
<v t="ekr.20031218072017.3183"><vh>match_ignoring_case</vh></v>
<v t="ekr.20031218072017.3184"><vh>match_word</vh></v>
<v t="ekr.20031218072017.3185"><vh>skip_blank_lines</vh></v>
<v t="ekr.20031218072017.3186"><vh>skip_c_id</vh></v>
<v t="ekr.20040705195048"><vh>skip_id</vh></v>
<v t="ekr.20031218072017.3187"><vh>skip_line, skip_to_start/end_of_line &amp; tests</vh>
<v t="ekr.20070627082044.836"><vh>@test g.skip_line</vh></v>
<v t="ekr.20070627082044.837"><vh>@test g.skip_to_end_of_line</vh></v>
<v t="ekr.20070627082044.838"><vh>@test g.skip_to_start_of_line</vh></v>
</v>
<v t="ekr.20031218072017.3188"><vh>skip_long</vh></v>
<v t="ekr.20031218072017.3189"><vh>skip_matching_python_delims</vh></v>
<v t="ekr.20060627080947"><vh>skip_matching_python_parens</vh></v>
<v t="ekr.20031218072017.3190"><vh>skip_nl</vh></v>
<v t="ekr.20031218072017.3191"><vh>skip_non_ws</vh></v>
<v t="ekr.20031218072017.3192"><vh>skip_pascal_braces</vh></v>
<v t="ekr.20031218072017.3193"><vh>skip_to_char</vh></v>
<v t="ekr.20031218072017.3194"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="ekr.20031218072017.3195"><vh>splitLines &amp; joinLines</vh></v>
</v>
<v t="ekr.20070611173545.1"><vh>Design</vh>
<v t="ekr.20070703172130.1"><vh>Aha: perfect import *can* correct whitespace</vh></v>
<v t="ekr.20070512162750"><vh>@url http://simpleparse.sourceforge.net/</vh></v>
<v t="ekr.20040721094203"><vh>Probably not: Make sure Leo uses "verbatim" whitespace</vh>
<v t="ekr.20060808103849"><vh>Report</vh></v>
<v t="ekr.20041005105605.210"><vh>putIndent</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3207"><vh>import.__init__</vh></v>
<v t="ekr.20070703122141.65" a="E"><vh>class baseScannerClass</vh>
<v t="ekr.20070703122141.66"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20070707072749"><vh>run</vh></v>
<v t="ekr.20070703122141.102" a="M"><vh>check &amp; helpers</vh>
<v t="ekr.20070705085126"><vh>checkTab</vh></v>
<v t="ekr.20070703122141.103"><vh>checkWhitespace</vh></v>
<v t="ekr.20070703122141.104"><vh>checkTrialWrite</vh></v>
</v>
<v t="ekr.20070707071124" a="E"><vh>utils</vh>
<v t="ekr.20070703122141.78"><vh>error &amp; scanError</vh></v>
<v t="ekr.20070703122141.79"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070703122141.80"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20070707073627"><vh>oops</vh></v>
<v t="ekr.20070703122141.82"><vh>setEncoding</vh></v>
</v>
<v t="ekr.20070706084535.1"><vh>Parsing</vh>
<v t="ekr.20070707075646"><vh>Must be defined in base class</vh>
<v t="ekr.20070706101600"><vh>scan &amp; helper</vh>
<v t="ekr.20070707073044.1"><vh>addRef</vh></v>
</v>
<v t="ekr.20070707080042"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20070709084313"><vh>adjustClassOrFunctionStart</vh></v>
</v>
</v>
<v t="ekr.20070707075646.1"><vh>May be defined in subclasses</vh>
<v t="ekr.20070707150022"><vh>extendSignature</vh></v>
<v t="ekr.20070707172732"><vh>getClass/FunctionID</vh></v>
<v t="ekr.20070707073859"><vh>skipBlock</vh></v>
<v t="ekr.20070707074541"><vh>skipBlockComment</vh></v>
<v t="ekr.20070707094858.1"><vh>skipId</vh></v>
<v t="ekr.20070707073627.2"><vh>skipString</vh></v>
<v t="ekr.20070707094858.2"><vh>startsId</vh></v>
<v t="ekr.20070707172732.1"><vh>startsString</vh></v>
</v>
<v t="ekr.20070707073627.3"><vh>Must be defined in subclasses</vh></v>
</v>
<v t="ekr.20070706084535"><vh>Semantics (must be defined in base class)</vh>
<v t="ekr.20070705144309"><vh>createDeclsNode</vh></v>
<v t="ekr.20070707085612"><vh>createFunctionNode</vh></v>
<v t="ekr.20070703122141.77"><vh>createHeadline</vh></v>
<v t="ekr.20070705085335"><vh>insertIgnoreDirectives</vh></v>
<v t="ekr.20070703122141.81"><vh>massageComment</vh></v>
<v t="ekr.20070707113832.1" a="M"><vh>putClass &amp; helpers</vh>
<v t="ekr.20070703122141.106"><vh>appendRefToClassNode</vh></v>
<v t="ekr.20070707190351" a="M"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20070703122141.105"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20070707171329" a="M"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20070707082432"><vh>putFunction</vh></v>
<v t="ekr.20070705094630"><vh>putRootText</vh></v>
<v t="ekr.20070703122141.88"><vh>undentBody</vh></v>
<v t="ekr.20070709094002"><vh>indentBody</vh></v>
</v>
</v>
<v t="ekr.20070703122141.100"><vh>class pythonScanner (baseScannerClass)</vh>
<v t="ekr.20070703122141.101"><vh> __init__</vh></v>
<v t="ekr.20070707073723"><vh>Overrides</vh>
<v t="ekr.20070707113839"><vh>extendSignature</vh></v>
<v t="ekr.20070707082226"><vh>skipClass/Function &amp; helper</vh>
<v t="ekr.20070707111805"><vh>skipHelper (pythonScanner)</vh></v>
</v>
<v t="ekr.20070707115247"><vh>skipSignature</vh></v>
<v t="ekr.20070707073627.4"><vh>skipString</vh></v>
<v t="ekr.20070707080005"><vh>startsClass/Function</vh></v>
</v>
</v>
</v>
<v t="ekr.20070707185118" a="TV"><vh>Indentation issues</vh>
<v t="ekr.20070703122141.106"><vh>appendRefToClassNode</vh></v>
<v t="ekr.20070707080042"><vh>skipDecls &amp; helper</vh>
<v t="ekr.20070709084313"><vh>adjustClassOrFunctionStart</vh></v>
</v>
<v t="ekr.20070706101600"><vh>scan &amp; helper</vh>
<v t="ekr.20070707073044.1"><vh>addRef</vh></v>
</v>
<v t="ekr.20070707113832.1" a="M"><vh>putClass &amp; helpers</vh>
<v t="ekr.20070703122141.106"><vh>appendRefToClassNode</vh></v>
<v t="ekr.20070707190351" a="M"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20070703122141.105"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20070707171329" a="M"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20070703122141.88"><vh>undentBody</vh></v>
<v t="ekr.20041005105605.174"><vh>putCodeLine</vh></v>
<v t="ekr.20070709094002"><vh>indentBody</vh></v>
<v t="ekr.20070703122141.102" a="M"><vh>check &amp; helpers</vh>
<v t="ekr.20070705085126"><vh>checkTab</vh></v>
<v t="ekr.20070703122141.103"><vh>checkWhitespace</vh></v>
<v t="ekr.20070703122141.104"><vh>checkTrialWrite</vh></v>
</v>
<v t="ekr.20070707111805"><vh>skipHelper (pythonScanner)</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.2369">def skip_string(s,i,verbose=True):

    '''Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True'''

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20031218072017.2406">@tabwidt -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
 d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
</t>
<t tx="ekr.20031218072017.3151"></t>
<t tx="ekr.20031218072017.3152">def scanAtFileOptions (h,err_flag=False):

    assert(g.match(h,0,"@file"))
    i = len("@file")
    atFileType = "@file"
    optionsList = []

    while g.match(h,i,'-'):
        &lt;&lt; scan another @file option &gt;&gt;

    # Convert atFileType to a list of options.
    for fileType,option in (
        ("@silentfile","asis"),
        ("@nosentinelsfile","nosent"),
        ("@rawfile","noref"),
        ("@thinfile","thin")
    ):
        if atFileType == fileType and option not in optionsList:
            optionsList.append(option)

    # g.trace(atFileType,optionsList)

    return i,atFileType,optionsList
</t>
<t tx="ekr.20031218072017.3153">i += 1 ; err = -1

if g.match_word(h,i,"asis"):
    if atFileType == "@file":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@rawfile"
    elif atFileType == "@nosentinelsfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@nosentinelsfile"
    elif atFileType == "@rawfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
    if atFileType == "@file":
        atFileType = "@thinfile"
    elif err_flag:
        g.es("using -thin option in:" + h)
else:
    if 0: # doesn't work
        for option in ("fat","new","now","old","thin","wait"):
            if g.match_word(h,i,option):
                optionsList.append(option)
        if len(option) == 0:
            err = i-1
# Scan to the next minus sign.
while i &lt; len(h) and h[i] not in (' ','\t','-'):
    i += 1
if err &gt; -1:
    g.es("unknown option:" + h[err:i] + " in " + h)
</t>
<t tx="ekr.20031218072017.3154">def scanAtRootOptions (s,i,err_flag=False):

    assert(g.match(s,i,"@root"))
    i += len("@root")
    mode = None 
    while g.match(s,i,'-'):
        &lt;&lt; scan another @root option &gt;&gt;

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")
    return i,mode
</t>
<t tx="ekr.20031218072017.3155">i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:" + g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:" + g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ','\t','-'):
    i += 1

if err &gt; -1 and err_flag:
    g.es("unknown option:" + s[err:i] + " in " + g.get_line(s,i))
</t>
<t tx="ekr.20031218072017.3156"># It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s):

    """Bump the error count in the tangle command."""

    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors +=1
    g.es(s)
</t>
<t tx="ekr.20031218072017.3157"># A quick and dirty sscanf.  Understands only %s and %d.

def scanf (s,pat):
    count = pat.count("%s") + pat.count("%d")
    pat = pat.replace("%s","(\S+)")
    pat = pat.replace("%d","(\d+)")
    parts = re.split(pat,s)
    result = []
    for part in parts:
        if len(part) &gt; 0 and len(result) &lt; count:
            result.append(part)
    # g.trace("scanf returns:",result)
    return result

if 0: # testing
    g.scanf("1.0","%d.%d",)
</t>
<t tx="ekr.20031218072017.3158">@ These scanners all call g.scanError() directly or indirectly, so they will call g.es() if they find an error.  g.scanError() also bumps c.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="ekr.20031218072017.3159"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

    assert(g.match(s,i,"/*"))
    j = i ; i += 2 ; n = len(s)

    k = string.find(s,"*/",i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    else: return k + 2
</t>
<t tx="ekr.20031218072017.3160">@ This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

    """Skips from the opening to the matching brace.

    If no matching is found i is set to len(s)"""

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,'//'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        # 7/29/02: be more careful handling conditional code.
        elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta = g.skip_pp_if(s,i)
            level += delta
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3161">@ 08-SEP-2002 DTHEIN: Added for PHP import support
Skips from the opening to the matching . If no matching is found i is set to len(s).

This code is called only from the import logic, and only for PHP imports.
@c

def skip_php_braces(s,i):

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i + 1
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"&lt;&lt;&lt;"): i = g.skip_heredoc_string(s,i)
        elif g.match(s,i,'//') or g.match(s,i,'#'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3162">def skip_parens(s,i):

    """Skips from the opening ( to the matching ).

    If no matching is found i is set to len(s)"""

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))
    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:  return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3163">def skip_pascal_begin_end(s,i):

    """Skips from begin to matching end.
    If found, i points to the end. Otherwise, i &gt;= len(s)
    The end keyword matches begin, case, class, record, and try."""

    assert(g.match_c_word(s,i,"begin"))
    level = 1 ; i = g.skip_c_id(s,i) # Skip the opening begin.
    while i &lt; len(s):
        ch = s[i]
        if ch =='{' : i = g.skip_pascal_braces(s,i)
        elif ch =='"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.match_c_word(s,i,"end"):
            level -= 1 ;
            if level == 0:
                # lines = s[i1:i+3] ; g.trace('\n' + lines + '\n')
                return i
            else: i = g.skip_c_id(s,i)
        elif g.is_c_id(ch):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3164"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):

    j = i
    assert(g.match(s,i,"(*"))
    i = string.find(s,"*)",i)
    if i &gt; -1: return i + 2
    else:
        g.scanError("Run on comment" + s[j:i])
        return len(s)

#   n = len(s)
#   while i &lt; n:
#       if g.match(s,i,"*)"): return i + 2
#       i += 1
#   g.scanError("Run on comment" + s[j:i])
#   return i
</t>
<t tx="ekr.20031218072017.3165">def skip_pascal_string(s,i):

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    while i &lt; len(s):
        if s[i] == delim:
            return i + 1
        else: i += 1

    g.scanError("Run on string: " + s[j:i])
    return i
</t>
<t tx="ekr.20031218072017.3166">@ 08-SEP-2002 DTHEIN:  added function skip_heredoc_string
A heredoc string in PHP looks like:

  &lt;&lt;&lt;EOS
  This is my string.
  It is mine. I own it.
  No one else has it.
  EOS

It begins with &lt;&lt;&lt; plus a token (naming same as PHP variable names).
It ends with the token on a line by itself (must start in first position.

@c
def skip_heredoc_string(s,i):

    j = i
    assert(g.match(s,i,"&lt;&lt;&lt;"))
    m = re.match("\&lt;\&lt;\&lt;([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)", s[i:])
    if (None == m):
        i += 3
        return i

    # 14-SEP-2002 DTHEIN: needed to add \n to find word, not just string
    delim = m.group(1) + '\n' 

    i = g.skip_line(s,i) # 14-SEP-2002 DTHEIN: look after \n, not before
    n = len(s)
    while i &lt; n and not g.match(s,i,delim):
        i = g.skip_line(s,i) # 14-SEP-2002 DTHEIN: move past \n

    if i &gt;= n:
        g.scanError("Run on string: " + s[j:i])
    elif g.match(s,i,delim):
        i += len(delim)
    return i
</t>
<t tx="ekr.20031218072017.3167"># Now handles continuation lines and block comments.

def skip_pp_directive(s,i):

    while i &lt; len(s):
        if g.is_nl(s,i):
            if g.escaped(s,i): i = g.skip_nl(s,i)
            else: break
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3168"># Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s,i):

    start_line = g.get_line(s,i) # used for error messages.
    # g.trace(start_line)

    assert(
        g.match_word(s,i,"#if") or
        g.match_word(s,i,"#ifdef") or
        g.match_word(s,i,"#ifndef"))

    i = g.skip_line(s,i)
    i,delta1 = g.skip_pp_part(s,i)
    i = g.skip_ws(s,i)
    if g.match_word(s,i,"#else"):
        i = g.skip_line(s,i)
        i = g.skip_ws(s,i)
        i,delta2 = g.skip_pp_part(s,i)
        if delta1 != delta2:
            g.es("#if and #else parts have different braces: " + start_line)
    i = g.skip_ws(s,i)
    if g.match_word(s,i,"#endif"):
        i = g.skip_line(s,i)
    else:
        g.es("no matching #endif: " + start_line)

    # g.trace(delta1,start_line)
    return i,delta1
</t>
<t tx="ekr.20031218072017.3169"># Skip to an #else or #endif.  The caller has eaten the #if, #ifdef, #ifndef or #else

def skip_pp_part(s,i):

    # g.trace(g.get_line(s,i))

    delta = 0
    while i &lt; len(s):
        c = s[i]
        if 0:
            if c == '\n':
                g.trace(delta,g.get_line(s,i))
        if g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta1 = g.skip_pp_if(s,i)
            delta += delta1
        elif g.match_word(s,i,"#else") or g.match_word(s,i,"#endif"):
            return i,delta
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif c == '{':
            delta += 1 ; i += 1
        elif c == '}':
            delta -= 1 ; i += 1
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i,delta
</t>
<t tx="ekr.20031218072017.3170">def skip_python_string(s,i,verbose=True):

    if g.match(s,i,"'''") or g.match(s,i,'"""'):
        j = i ; delim = s[i]*3 ; i += 3
        k = string.find(s,delim,i)
        if k &gt; -1: return k+3
        if verbose:
            g.scanError("Run on triple quoted string: " + s[j:i])
        return len(s)
    else:
        return g.skip_string(s,i)
</t>
<t tx="ekr.20031218072017.3171"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c == ';': return i
        elif c == '\'' or c == '"' : i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20031218072017.3172">def skip_typedef(s,i):

    n = len(s)
    while i &lt; n and g.is_c_id(s[i]):
        i = g.skip_c_id(s,i)
        i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        i = g.skip_to_semicolon(s,i)
    return i
</t>
<t tx="ekr.20031218072017.3173"></t>
<t tx="ekr.20031218072017.3174"># Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 &gt;= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1
</t>
<t tx="ekr.20031218072017.3175">def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
</t>
<t tx="ekr.20031218072017.3176">def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k &gt; -1: return k
    else: return None
</t>
<t tx="ekr.20031218072017.3177">def is_c_id(ch):

    return g.isWordChar(ch)

</t>
<t tx="ekr.20031218072017.3178">def is_nl(s,i):

    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')
</t>
<t tx="ekr.20031218072017.3179"># We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i &lt; len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1
</t>
<t tx="ekr.20031218072017.3180">def is_ws(c):

    return c == '\t' or c == ' '

def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i &lt; len(s) and g.is_ws(s[i]))
</t>
<t tx="ekr.20031218072017.3181"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i
</t>
<t tx="ekr.20031218072017.3182">def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))
</t>
<t tx="ekr.20031218072017.3183">def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)
</t>
<t tx="ekr.20031218072017.3184">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
</t>
<t tx="ekr.20031218072017.3185">def skip_blank_lines(s,i):

    while i &lt; len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i
</t>
<t tx="ekr.20031218072017.3186">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3187">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i &gt;= len(s): return len(s)
    if i &lt;= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
</t>
<t tx="ekr.20031218072017.3188">def skip_long(s,i):

    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or (not s[i].isdigit() and s[i] not in u'+-'):
        return i, None
    j = i
    if s[i] in u'+-': # Allow sign before the first digit
        i +=1
    while i &lt; n and s[i].isdigit():
        i += 1
    try: # There may be no digits.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20031218072017.3189">def skip_matching_python_delims(s,i,delim1,delim2,reverse=False):

    '''Skip from the opening delim to the matching delim2.

    Return the index of the matching ')', or -1'''

    level = 0 ; n = len(s)
    # g.trace('delim1/2',repr(delim1),repr(delim2),'i',i,'s[i]',repr(s[i]),'s',repr(s[i-5:i+5]))
    assert(g.match(s,i,delim1))
    if reverse:
         while i &gt;= 0:
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i -= 1
            # Doesn't handle strings and comments properly...
            else: i -= 1
    else:
        while i &lt; n:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i += 1
            elif ch == '\'' or ch == '"': i = g.skip_string(s,i,verbose=False)
            elif g.match(s,i,'#'):  i = g.skip_to_end_of_line(s,i)
            else: i += 1
            if i == progress: return -1
    return -1
</t>
<t tx="ekr.20031218072017.3190"># We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
</t>
<t tx="ekr.20031218072017.3191">def skip_non_ws (s,i):

    n = len(s)
    while i &lt; n and not g.is_ws(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3192"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k
</t>
<t tx="ekr.20031218072017.3193">def skip_to_char(s,i,ch):

    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
</t>
<t tx="ekr.20031218072017.3194">def skip_ws(s,i):

    n = len(s)
    while i &lt; n and g.is_ws(s[i]):
        i += 1
    return i

def skip_ws_and_nl(s,i):

    n = len(s)
    while i &lt; n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i
</t>
<t tx="ekr.20031218072017.3195">def splitLines (s):

    """Split s into lines, preserving the number of lines and the ending of the last line."""

    # g.stat()

    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

splitlines = splitLines

def joinLines (aList):

    return ''.join(aList)

joinlines = joinLines
</t>
<t tx="ekr.20031218072017.3207">def __init__ (self,c):

    self.c = c

    # New in 4.3: honor any tabwidth directive in effect when importing files.
    self.tabwidth = c.tab_width

    # Set by ImportFilesFommand.
    self.treeType = "@file" # "@root" or "@file"
    # Set by ImportWebCommand.
    self.webType = "@noweb" # "cweb" or "noweb"

    # Set by create_outline.
    self.fileName = None # The original file name, say x.cpp
    self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
    self.fileType = None # ".py", ".c", etc.
    self.rootLine = "" # Empty or @root + self.fileName

    # Support of output_newline option
    self.output_newline = g.getOutputNewline(c=c)

    # Used by Importers.
    self.web_st = []
    self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
    self._forcedGnxPositionList = []
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4.3.1, build %s, July 3, 2007" % c.getBuildNumber()
</t>
<t tx="ekr.20040705195048">def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i</t>
<t tx="ekr.20040721094203">http://sourceforge.net/forum/message.php?msg_id=3578166

I think these issues are not really relevant.</t>
<t tx="ekr.20041005105605.174">def putCodeLine (self,s,i):

    """Put a normal code line."""

    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.trace('atRaw',at.raw,'line',repr(line),g.callers(4))

    if self.write_strips_blank_lines:
        # Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)

            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # Don't put leading indent if the line is empty!
        if line.strip() and not at.raw:  ### 7/9/2007: changed line to line.strip()
            at.putIndent(at.indent)

        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
</t>
<t tx="ekr.20041005105605.210">def putIndent(self,n):

    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w &gt; 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20060217111834">.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:
    
copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060627080947">def skip_matching_python_parens(s,i):

    '''Skip from the opening ( to the matching ).

    Return the index of the matching ')', or -1'''

    return skip_matching_python_delims(s,i,'(',')')
</t>
<t tx="ekr.20060808103849">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinery if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent &lt;number&gt;.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

&gt; 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or &lt;&lt;&gt;&gt; for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.</t>
<t tx="ekr.20060908104329"></t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20070201082722">c.prettyPrintPythonNode()</t>
<t tx="ekr.20070324084040"></t>
<t tx="ekr.20070512162750"></t>
<t tx="ekr.20070603183100"></t>
<t tx="ekr.20070603183100.1"></t>
<t tx="ekr.20070605104326">True:  Chapter tabs appear in the outline pane.
False: Chapter tabs do not appear.</t>
<t tx="ekr.20070605104410"></t>
<t tx="ekr.20070611173545.1">@nocolor

I have just started the process of 'priming the pump' for work on @auto.

Here are the key factors that drive the design:

0. [Terminology] Alice uses Leo and doesn't mind having sentinels in derived files. Bob doesn't use Leo, and *does not want sentinels* (at least until Bob gets turned on to Leo), and Mike is Alice's and Bob's manager.  Mike probably doesn't care about sentinels, but would side with Bob if Bob objected to using sentinels.

1. [No sentinels] There was a *lot* of discussion about this.  The initial implementation of @auto will use *absolutely no* sentinels. This might be relaxed later, but the *essential* idea is that @auto is a feature primarily for newbies who DO NOT WANT sentinels in their files.  As Kent has clearly pointed out, within @auto trees, Alice can live without clones, section references and @others, etc.

2. [Perfect import] I designed an algorithm that guarantees that files imported with @auto can be rewritten from the @auto tree with *no* changes to the original file.  This is the 'round-tripping' requirement.

See: Huge aha: design of the parser (perfect import)
http://sourceforge.net/forum/message.php?msg_id=4224283

3. [Resolve cvs conflicts] Leo can let the user resolve cvs conflicts.

See: Huge aha: resolving conflicts
http://sourceforge.net/forum/message.php?msg_id=4224589

The following are references to extended discussions in Leo's forums:

1. From the Open Forum, March, 2007:

auto: a new vision
http://sourceforge.net/forum/forum.php?thread_id=1700873&amp;forum_id=10226

Huge aha: parsing replaces sentinels
http://sourceforge.net/forum/forum.php?thread_id=1699679&amp;forum_id=10226

@auto nodes
http://sourceforge.net/forum/forum.php?thread_id=1699599&amp;forum_id=10226

2. The original motivation was in the 'Discurssion of wxPython issues' thread in
the Developers Forum in March 2007:
http://sourceforge.net/forum/forum.php?thread_id=1695549&amp;forum_id=10228

And especially:
http://sourceforge.net/forum/message.php?msg_id=4217121</t>
<t tx="ekr.20070619130151"></t>
<t tx="ekr.20070627082044.836">if g.unitTesting:
    s = 'a\n\nc'
    for i,result in (
        (-1,2), # One too few.
        (0,2),(1,2),
        (2,3),
        (3,4),
        (4,4), # One too many.
    ):
        j = g.skip_line(s,i)
        assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)</t>
<t tx="ekr.20070627082044.837">if g.unitTesting:
    s = 'a\n\nc'
    for i,result in (
        (-1,1), # One too few.
        (0,1),(1,1),
        (2,2),
        (3,4),
        (4,4), # One too many.
    ):
        j = g.skip_to_end_of_line(s,i)
        assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)</t>
<t tx="ekr.20070627082044.838">if g.unitTesting:
    s1 = 'a\n\nc'
    table1 = (
        (-1,0), # One too few.
        (0,0),(1,0),
        (2,2),
        (3,3),
        (4,4), # One too many.
    )
    s2 = 'a\n'
    table2 = ((1,0),(2,2)) # A special case at end.

    for s,table in ((s1,table1),(s2,table2)):
        for i,result in table:
            j = g.skip_to_start_of_line(s,i)
            assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
</t>
<t tx="ekr.20070627083814"></t>
<t tx="ekr.20070627144218">import leoTest
leoTest.runTestsExternally (c,all=False)</t>
<t tx="ekr.20070627144218.1">import leoTest
leoTest.runTestsExternally (c,all=True)
</t>
<t tx="ekr.20070628175250">@color

u = c.undoer
b = u.beforeChangeNodeContents(p)
s = p.bodyString()

result = [' '*4 + line for line in g.splitLines(s)]
result.insert(0,'if g.unitTesting:\n')
s = ''.join(result)
c.setBodyString(p,s)

u.afterChangeNodeContents(p,'add-if-g-unitTesting',b)
</t>
<t tx="ekr.20070629073827"></t>
<t tx="ekr.20070703122141.65">class baseScannerClass:

    '''
    The base class for all import scanner classes.
    This class contains common utility methods.
    '''

    @others
</t>
<t tx="ekr.20070703122141.66">def __init__ (self,importCommands,atAuto,language,strict):

    # Copy arguments.
    self.atAuto = atAuto
    self.language = language
    self.strict = strict

    # Copy ivars from the importCommands class.
    self.importCommands = ic = importCommands
    self.c = ic.c
    self.encoding = ic.encoding
    self.fileName = ic.fileName
    self.fileType = ic.fileType
    # self._forcedGnxPositionList = []
    self.methodName = ic.methodName
    self.output_newline = ic.output_newline
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine
    self.tab_width = ic.getTabWidth()
    self.treeType = ic.treeType
    # self.web_st = []
    self.webType = ic.webType

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width &lt; 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.lineCommentDelim = None
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.signatureDelim = '{'
</t>
<t tx="ekr.20070703122141.77">def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)

    # Create the vnode.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
</t>
<t tx="ekr.20070703122141.78">def error (self,s):
    g.es_print(s,color='red')

scanError = error</t>
<t tx="ekr.20070703122141.79">def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    width = 0 ; i = g.find_line_start(s,i)
    while i &lt; len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i)
        if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            break

    # g.trace("returns:",width)
    return width
</t>
<t tx="ekr.20070703122141.80"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
</t>
<t tx="ekr.20070703122141.81">def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace."""

    s = s.strip()
    s = s.replace("\n"," ")
    s = s.replace("\r"," ")
    s = s.replace("\t"," ")
    s = s.replace("  "," ")
    s = s.strip()
    return s
</t>
<t tx="ekr.20070703122141.82">def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
</t>
<t tx="ekr.20070703122141.88">def undentBody (self,s):

    '''Remove the leading indentation of line 1 from all lines of s.'''

    i = 0 ; result = ''

    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]

    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s

    result = []
    for line in g.splitLines(s):
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result.append(line)
    return ''.join(result)
</t>
<t tx="ekr.20070703122141.100">class pythonScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20070703122141.101">def __init__ (self,importCommands,atAuto,strict):

    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,
        language='python',
        strict=strict,
    )

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = '#'
    self.signatureDelim = ':'
</t>
<t tx="ekr.20070703122141.102">def check (self,parent):

    '''
    Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    return self.checkWhitespace(parent) and self.checkTrialWrite()
</t>
<t tx="ekr.20070703122141.103">def checkWhitespace(self,parent):

    '''Check and normalize the leading whitespace of all nodes.

    - The original sources may fail Python's tabNanny checks.  

    - Leading whitespace in the original sources may be inconsistent with the
      @tabwidth setting in effect in the @auto tree.

    - The original sources may contain underindented comments. 

    If an indentation problem is found, issue a warning and return False.
    Otherwise, normalize the indentation of all pieces so that it is indeed
    consistent with the indentation specified by the present @tabwidth setting.
    Normalizing underindented comments means shifting the comments right.
    '''

    # Check that whitespace passes TabNanny.
    # Check that whitespace is compatible with @tabwidth.
    # Check for underindented lines.
    g.trace(self.tab_width)
    ok = True
    for p in parent.self_and_subtree_iter():
        ok = ok and self.checkTab(p)
    return ok</t>
<t tx="ekr.20070703122141.104">def checkTrialWrite (self):

    '''Return True if a trial write produces the original file.'''

    c = self.c ; at = c.atFileCommands

    at.write(self.root,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=True,
        write_strips_blank_lines=False,
    )
    s1 = self.file_s
    s2 = at.stringOutput
    ok = s1 == s2
    if ok:
        pass
        g.trace('***success***')
    else:
        lines1 = g.splitLines(s1)
        lines2 = g.splitLines(s2)
        if not self.strict: # ignore blank lines.
            lines1 = [z for z in lines1 if z.strip()]
            lines2 = [z for z in lines2 if z.strip()]
        if len(lines1) != len(lines2):
            g.trace('***different number of lines:',
                'lines1',len(lines1),'lines2',len(lines2))
        g.trace('***mismatch',
            'len(s1)',len(s1),'len(s2)',len(s2))
        n = min(len(lines1),len(lines2))
        for i in xrange(n):
            if lines1[i] != lines2[i]:
                print 'first mismatch at line %d' % (i)
                print 'original line: ', repr(lines1[i])
                print 'generated line:', repr(lines2[i])
                break
        else:
            if len(lines2) &lt; len(lines1):
                 print 'missing lines'
                 i = n
                 while i &lt; len(lines1):
                     print repr(lines1[i])
                     i += 1
            else:
                print 'extra lines'
                i = n
                while i &lt; len(lines2):
                    print repr(lines1[2])
                    i += 1
        if 0:
            print
            for i in xrange(len(lines2)):
                print '%3d: %s' % (i,repr(lines2[i]))
    return ok
</t>
<t tx="ekr.20070703122141.105">def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True

    return prefix
</t>
<t tx="ekr.20070703122141.106">def appendRefToClassNode (self,class_name,class_node):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == "@file":
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
</t>
<t tx="ekr.20070703172130.1">@nocolor

Aha: the perfect import code *can* correct whitespace (tab, underindented lines)
problems that exists in the original files. When such errors are found, Leo will
issue the message:

    'whitepace error: remove the @ignore statement to correct these problems.'

This is the best possible solution:

- It alerts the user that there are problems with the original file.
- It does *not* change them unless the user takes specific action.
- It *does* correct the problems if desired.
</t>
<t tx="ekr.20070705085126"># Similar to c.tabNannyNode

def checkTab (self,p):

    """Check indentation using tabnanny."""

    h = p.headString() ; body = p.bodyString()

    try:
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return True

    except IndentationError, err:
        # Instances of this class have attributes filename, lineno, offset and text.
        g.es_print("IndentationError in %s at line %d" % (h,err.lineno),color="blue")
        # g.es_print(str(err)) # str(err.text))

    except parser.ParserError, msg:
        g.es_print("ParserError in %s" % h,color="blue")
        g.es_print(str(msg))

    except tokenize.TokenError, msg:
        g.es_print("TokenError in %s" % h,color="blue")
        g.es_print(str(msg))

    except tabnanny.NannyNag, nag:
        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()
        g.es_print("Indentation error in %s, line %d" % (h, badline),color="blue")
        g.es_print(message)
        g.es_print("offending line:\n%s" % repr(str(line))[1:-1])

    except:
        g.trace("unexpected exception")
        g.es_exception()

    return False
</t>
<t tx="ekr.20070705085335">def insertIgnoreDirectives (self,parent):

    g.trace(parent)
</t>
<t tx="ekr.20070705094630">def putRootText (self,p):

    c = self.c

    if self.atAuto:
        c.appendStringToBody(p,self.rootLine + '@language python\n')
    else:
        c.appendStringToBody(p,'@ignore\n' + self.rootLine + '@language python\n')
</t>
<t tx="ekr.20070705144309">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20070706084535"></t>
<t tx="ekr.20070706084535.1"></t>
<t tx="ekr.20070706101600">def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''
    i = start = self.skipDecls(s,0,len(s))
    decls = s[:i]
    if decls: self.createDeclsNode(parent,decls)
    needRef = False
    while i &lt; len(s):
        progress = i
        if g.match(s,i,self.lineCommentDelim):
            i = g.skip_line(s,i)
        elif g.match(s,i,self.blockCommentDelim1):
            i = self.skipBlockComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):
            end2 = self.skipClass(s,i)
            self.putClass(s,i,end2,start,parent)
            i = start = end2
            needRef = True
        elif self.startsFunction(s,i):
            end2 = self.skipFunction(s,i)
            self.putFunction(s,i,end2,start,parent)
            i = start = end2
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert(progress &lt; i)
    self.addRef(parent)
</t>
<t tx="ekr.20070706152845">@

- Don't create node for class decls: put them directly in the class node.

- Revise preface.

** scanPython class duplicates logic of base scan class.
   Is it possible to be more clever?
   
* Section references are anti-patterns.</t>
<t tx="ekr.20070707071124"></t>
<t tx="ekr.20070707072749">def run (self,s,parent):

    scanner = self
    scanner.root = parent
    scanner.file_s = s

    # Step 1: generate the nodes,
    # including all directive and section references.
    scanner.scan(s,parent)

    # Step 2: check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = scanner.check(parent)

    # Step 3: insert an @ignore directive if there are any problems.
    if not ok:
        scanner.insertIgnoreDirectives(parent)
</t>
<t tx="ekr.20070707073044.1">def addRef (self,parent):

    '''Create an unindented the @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == "@file":
        c.appendStringToBody(parent,"@others\n")

    if self.treeType == "@root" and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
</t>
<t tx="ekr.20070707073627">def oops (self):
    print ("baseScannerClass oops:",
        g.callers(),
        "must be overridden in subclass")
</t>
<t tx="ekr.20070707073627.2">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
</t>
<t tx="ekr.20070707073627.3">def getClassId (self,s,i):
    self.oops()

def getFunctionId (self,s,i):
    self.oops()

def putClass (self,s,i,end,start,parent):
    self.oops()

def putFunction (self,s,i,end,start,parent):
    self.oops()

def skipClass (self,s,i):
    self.oops()

def skipFunction (self,s,i):
    self.oops()

def skipSignature (self,s,i):
    self.oops()

def startsClass (self,s,i):
    self.oops()

def startsFunction (self,s,i):
    self.oops()
</t>
<t tx="ekr.20070707073627.4">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
</t>
<t tx="ekr.20070707073723"></t>
<t tx="ekr.20070707073859">def skipBlock(self,s,i,delim1='{',delim2='}'):

    """Skips from the opening delim to the matching closing delim.

    If no matching is found i is set to len(s)"""

    # start = g.get_line(s,i)
    assert g.match(s,i,delim1)
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == delim1:
            level += 1 ; i += 1
        elif c == delim2:
            level -= 1 ; i += 1
            if level &lt;= 0: return i
        elif g.match(s,i,self.lineCommentDelim):
            i = g.skip_line(s,i)
        elif g.match(s,i,self.blockCommentDelim1):
            i = self.skipBlockComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        # Only for C++.
        # elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            # i,delta = g.skip_pp_if(s,i)
            # level += delta
        else: i += 1
    return i
</t>
<t tx="ekr.20070707074541">def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.scanError("Run on block comment: " + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
</t>
<t tx="ekr.20070707075646"></t>
<t tx="ekr.20070707075646.1"></t>
<t tx="ekr.20070707080005">def startsClass (self,s,i):
    '''Return the class id if s[i:] starts a class definition.'''
    return self.startsHelper(s,i,'class')

def startsFunction (self,s,i):
    '''Return the function id if s[i:] starts a function definition.'''
    return self.startsHelper(s,i,'def')

def startsHelper(self,s,i,tag):

    '''Return the id following the tag, or the empty string.'''

    if g.match_word(s,i,tag):
        i += len(tag)
        i = g.skip_ws_and_nl(s,i)
        j = g.skip_c_id(s,i)
        return s[i:j]
    else:
        return ''
</t>
<t tx="ekr.20070707080042">def skipDecls (self,s,i,end):

    '''
    Carefully skip everything until the start of the next class or function.
    '''

    while i &lt; end:
        progress = i
        if g.match(s,i,self.lineCommentDelim):
            i = g.skip_line(s,i)
        elif g.match(s,i,self.blockCommentDelim1):
            i = self.skipBlockComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'class')
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert(progress &lt; i)

    return min(i,end)
</t>
<t tx="ekr.20070707082226">def skipClass (self,s,i):
    return self.skipHelper(s,i)

def skipFunction (self,s,i):
    return self.skipHelper(s,i)
</t>
<t tx="ekr.20070707082432">def putFunction (self,s,i,end,start,parent):

    '''
    Create a node of parent for a function defintion.
    '''

    headline = self.getFunctionID(s,i)
    body = s[start:end]
    self.createFunctionNode(headline,body,parent)
</t>
<t tx="ekr.20070707085612">def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + headline + " methods ") + "=\n\n"
        self.methodsSeen = True

    body = self.undentBody(body)

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20070707094858.1">def skipId (self,s,i):

    return g.skip_c_id(s,i)
</t>
<t tx="ekr.20070707094858.2">def startsId(self,s,i):

    return g.is_c_id(s[i])
</t>
<t tx="ekr.20070707111805">def skipHelper (self,s,i):

    # g.trace(g.get_line(s,i))

    startIndent = self.getLeadingIndent(s,i)
    i = self.skipSignature(s,i)
    i = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                underIndented = indent &lt;= startIndent and parenCount == 0
                if underIndented:
                    if g.match(s,j,'#') or g.match(s,j,'\n'):
                        # Dont stop immediately for underindented comment or blank lines.
                        # Extend the range of underindented lines.
                        if underIndentedStart is None:
                            underIndentedStart = i
                        i = j
                    else:
                        # The actual end of the function.
                        return g.choose(underIndentedStart is None,i,underIndentedStart)
                else:
                    underIndentedStart = None
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress &lt; i)

    return i
</t>
<t tx="ekr.20070707113832.1">def putClass (self,s,i,end,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace('start',start,'i',i,g.get_line(s,i))
    c = self.c
    classStart = g.find_line_start(s,i)
    class_name = self.getClassID(s,i)
    headline = "class " + class_name

    prefix = self.createClassNodePrefix()
    i = self.skipSignature(s,i)
    body = s[start:i]
    body = self.undentBody(body)
    j = i ; i = self.extendSignature(s,i)
    extend = s[j:i]
    if extend:
        extend = self.undentBody(extend)
        extend = self.indentBody(extend)
        body = body + extend

    class_node = self.createHeadline(parent,prefix + body,headline)

    savedMethodName = self.methodName
    self.methodName = headline

    self.putClassHelper(s,i,end,class_name,class_node)
    self.methodName = savedMethodName
</t>
<t tx="ekr.20070707113839">def extendSignature(self,s,i):

    '''
    Extend the text to added to the class node following the signature.

    The text *must* end with a newline.
    '''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j &lt; len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
</t>
<t tx="ekr.20070707115247">def skipSignature (self,s,i):

    '''Skip the signature line of a class or function.
    The text must end with a newline.'''

    start = i
    message = 'Warning: improper signature: %s' % g.get_line(s,start)

    # g.trace(g.getLine(s,i))

    # Skip the def or class.
    for tag in ('def','class'):
        if g.match_word(s,i,tag):
            i += len(tag)
            break
    else:
        self.error(message)
        return start

    # Skip the class or function name.
    i = g.skip_ws_and_nl(s,i)
    j = g.skip_c_id(s,i)
    if j == i:
        self.error(message)
        return start

    # Skip the optional argument or base-class list.
    i = g.skip_ws_and_nl(s,j)
    if g.match(s,i,'('):
        i = self.skipBlock(s,i,delim1='(',delim2=')')
        i = g.skip_ws_and_nl(s,i)

    if g.match(s,i,self.signatureDelim):
        return g.skip_line(s,i+1)
    else:
        self.error(message)
        return start
</t>
<t tx="ekr.20070707150022">def extendSignature(self,s,i,start):

    '''
    Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.
    '''

    return i
</t>
<t tx="ekr.20070707171329">def putClassHelper(self,s,i,end,class_name,class_node):

    assert(i &lt;= end)
    # Put any leading decls in the class node.
    start = i
    i = self.skipDecls(s,i,end)
    decls = s[start:i]
    if decls:
        # We must regularize the indentation to match the @others
        decls = self.undentBody(decls)
        decls = self.indentBody(decls)
        # g.trace(class_name,'decls',repr(decls))
        self.appendTextToClassNode(class_node,decls)
    start = i ; putRef = False
    while i &lt; end:
        progress = i
        if g.match(s,i,self.lineCommentDelim):
            i = g.skip_line(s,i)
        elif g.match(s,i,self.blockCommentDelim1):
            i = self.skipBlockComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):
            putRef = True
            end2 = self.skipClass(s,i)
            self.putClass(s,i,end2,start,class_node)
            i = start = end2
        elif self.startsFunction(s,i):
            putRef = True
            end2 = self.skipFunction(s,i)
            self.putFunction(s,i,end2,start,class_node)
            i = start = end2
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert(progress &lt; i)

    if putRef:
        self.appendRefToClassNode(class_name,class_node)

    if start &lt; end:
        trailing = s[start:end]
        self.appendTextToClassNode(class_node,trailing)
</t>
<t tx="ekr.20070707172732">def getClassID (self,s,i):

    '''
    Return the class id if s[i:] starts a class definition.
    '''

    return self.startsClass(s,i)

def getFunctionID (self,s,i):

    '''
    Return the function id if s[i:] starts a function definition.
    '''

    return self.startsFunction(s,i)
</t>
<t tx="ekr.20070707172732.1">def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
</t>
<t tx="ekr.20070707185118"></t>
<t tx="ekr.20070707190351">def appendTextToClassNode (self,class_node,s):

    c = self.c
    c.appendStringToBody(class_node,s) 
</t>
<t tx="ekr.20070709084313">def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    if s[j:i].strip():
        message = '% definition does not start a line. Leo must insert a newline.' % tag
        self.error(message)
        return i
    else:
        return j
</t>
<t tx="ekr.20070709094002">def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    return ''.join(result)
</t>
</tnodes>
</leo_file>
