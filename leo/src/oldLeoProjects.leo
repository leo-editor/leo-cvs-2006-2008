<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="120" left="340" height="690" width="909"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070626112503"><vh>@chapters</vh></v>
<v t="ekr.20070105153920"><vh>Old notes</vh>
<v t="ekr.20070105153901"><vh>Tuple notes (revised originals)</vh>
<v t="ekr.20070105153901.1"><vh>Overview</vh></v>
<v t="ekr.20070105153901.2"><vh>Ahas</vh></v>
<v t="ekr.20070105153901.3"><vh>Block allocation</vh></v>
<v t="ekr.20070105153901.4"><vh>Stream allocation</vh></v>
<v t="ekr.20070105153901.5"><vh>Details</vh></v>
<v t="ekr.20070105153901.6"><vh>Deallocating objects</vh></v>
<v t="ekr.20070105153901.7"><vh>Debugging and production objects</vh></v>
<v t="ekr.20070105153901.8"><vh>Simplifications</vh></v>
<v t="ekr.20070105153901.9"><vh>Defining polymorphic streams</vh></v>
<v t="ekr.20070105153901.10"><vh>Using Streams</vh></v>
<v t="ekr.20070105153901.11"><vh>Lists Are Streams</vh></v>
<v t="ekr.20070105153901.12"><vh>Are any calls to calloc needed?</vh></v>
<v t="ekr.20070105153901.13"><vh>Abbreviation Macros</vh></v>
</v>
</v>
<v t="ekr.20061029091830"><vh>Leo 4.4.2 projects</vh>
<v t="ekr.20061029091751.1"><vh>Leo 4.4.2.1 final projects</vh>
<v t="ekr.20061029091751.2"><vh>Fixed bug reading recent files</vh>
<v t="ekr.20061029091751.3"><vh>appendToRecentFiles (g.app.config)</vh></v>
<v t="ekr.20061029091751.4"><vh>initSettingsFiles</vh></v>
<v t="ekr.20061029091751.5"><vh>g.app.config.readSettingsFiles</vh>
<v t="ekr.20061029091751.6"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091751.7"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20061029091751.8"><vh>createRecentFiles</vh></v>
<v t="ekr.20061029091751.9"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061029091751.10"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061029091751.11"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061029091811"><vh>Leo 4.4.2 final projects</vh>
<v t="ekr.20061029091811.1"><vh>Bugs</vh>
<v t="ekr.20061029091811.2"><vh>Changed leo_rst.css to pass the w3 validator</vh></v>
<v t="ekr.20061029091811.3"><vh>Fixed 'Run on string' message when typing ( with no @color in effect</vh>
<v t="ekr.20061029091811.4"><vh>skip_string</vh></v>
<v t="ekr.20061029091811.5"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20061029091811.6"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20061029091811.7"><vh>test_selfInsertCommand</vh></v>
<v t="ekr.20061029091811.8"><vh>initBracketMatcher</vh></v>
<v t="ekr.20061029091811.9"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20061029091811.10"><vh>flashCharacter</vh></v>
<v t="ekr.20061029091811.11"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20061029091811.12"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20061029091811.13"><vh>updateTab</vh></v>
</v>
<v t="ekr.20061029091811.14"><vh>skip_matching_python_delims</vh></v>
</v>
<v t="ekr.20061029091811.15"><vh>Fixed problem with c++ extensions</vh>
<v t="ekr.20061029091811.16"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20061029091811.17"><vh>Move on if regexp matches an empty string</vh>
<v t="ekr.20061029091811.18"><vh>regexHelper</vh></v>
</v>
<v t="ekr.20061029091811.19"><vh>Fixed several bugs related to multiple body panes</vh>
<v t="ekr.20061029091811.20"><vh>selectEditor</vh>
<v t="ekr.20061029091811.21"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091811.22"><vh>masterClickHandler</vh></v>
<v t="ekr.20061029091811.23"><vh>onClick</vh></v>
<v t="ekr.20061029091811.24"><vh>tkBody.createTextWidget</vh></v>
</v>
<v t="ekr.20061029091811.25"><vh>Fixed multipath plugin so it works with new colorizier</vh>
<v t="ekr.20061029091811.26" a="M"><vh>directiveKind4 &amp; test</vh>
<v t="ekr.20061029091811.27"><vh>test_directiveKind4</vh></v>
</v>
<v t="ekr.20061029091811.28"><vh>&lt;&lt; define leo keywords &gt;&gt;</vh></v>
<v t="ekr.20061029091811.29"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20061029091811.30"><vh>&lt;&lt; set theDict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20061029091811.31"><vh>&lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061029091811.32"><vh>Fixed bug in new colorizer</vh></v>
<v t="ekr.20061029091811.33"><vh>Fixed config bug</vh>
<v t="ekr.20061029091811.34"><vh>setInitialWindowGeometry</vh></v>
</v>
<v t="ekr.20061029091811.35"><vh>Investigated problems with leoRecentFiles.txt</vh>
<v t="ekr.20061029091811.36"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20061029091811.37"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20061029091811.38"><vh>computeHomeDir</vh></v>
<v t="ekr.20061029091811.39"><vh>computeLeoDir</vh></v>
<v t="ekr.20061029091811.40"><vh>computeLoadDir</vh></v>
<v t="ekr.20061029091811.41"><vh>computeStandardDirectories</vh></v>
<v t="ekr.20061029091811.42"><vh>startupEncoding</vh></v>
</v>
<v t="ekr.20061029091811.43"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20061029091811.44"><vh>createRecentFiles</vh></v>
<v t="ekr.20061029091811.45"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061029091811.46"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061029091811.47"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061029091811.48"><vh>New features</vh>
<v t="ekr.20061029091811.49"><vh>Created leoPymacs.py for interaction with pymacs</vh></v>
<v t="ekr.20061029091811.50"><vh>Further improvements to leoPymacs</vh>
<v t="ekr.20061029091811.51"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20061029091811.52"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20061029091811.53"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091811.54"><vh>g.openWithFileName</vh></v>
<v t="ekr.20061029091811.55"><vh>run &amp; allies</vh>
<v t="ekr.20061029091811.56"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20061029091811.57"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20061029091811.58"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20061029091811.59"><vh>isValidPython</vh></v>
<v t="ekr.20061029091811.60"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20061029091811.51"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20061029091811.61"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20061029091811.62"><vh>getBatchScript</vh></v>
<v t="ekr.20061029091811.63"><vh>reportDirectories</vh></v>
</v>
</v>
<v t="ekr.20061029091811.64"><vh>Added forward-end-word/-extend-selection commands</vh>
<v t="ekr.20061029091811.65"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061029091811.66"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20061029091811.67"><vh>words</vh></v>
<v t="ekr.20061029091811.68"><vh>moveWordHelper</vh></v>
<v t="ekr.20061029091811.69"><vh>runEditCommandTest</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014"><vh>4.4.2 b3 projects</vh>
<v t="ekr.20061021144014.1"><vh>Bugs</vh>
<v t="ekr.20061021144014.2"><vh>Fixed crash when searching for headllines containing unicode chars</vh>
<v t="ekr.20061021144014.3"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20061021144014.4"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.5"><vh>findWord</vh></v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20061021144014.7"><vh>Fixed failed unit test</vh>
<v t="ekr.20061021144014.8"><vh>k.initAbbrev</vh></v>
</v>
<v t="ekr.20061021144014.9"><vh>Fixed bugs in cycle-all-focus command</vh>
<v t="ekr.20061021144014.10"><vh>cycleFocus</vh></v>
<v t="ekr.20061021144014.11"><vh>cycleAllFocus</vh></v>
<v t="ekr.20061021144014.12"><vh>selectTab</vh></v>
<v t="ekr.20061021144014.13"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20061021144014.14"><vh>cycleTabFocus</vh></v>
<v t="ekr.20061021144014.15"><vh>callAltXFunction</vh></v>
<v t="ekr.20061021144014.16"><vh>endCommand</vh></v>
<v t="ekr.20061021144014.17"><vh>c.traceFocus</vh></v>
<v t="ekr.20061021144014.18"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20061021144014.19"><vh>masterKeyHandler</vh>
<v t="ekr.20061021144014.20"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20061021144014.21"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20061021144014.22"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.23"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.24"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.25"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20061021144014.26"><vh>c.get/request/set_focus</vh></v>
</v>
<v t="ekr.20061021144014.27"><vh>Fixed bug: with Alt-n keys</vh>
<v t="ekr.20061021144014.28"><vh>k.registerCommand</vh></v>
<v t="ekr.20061021144014.29"><vh>makeMasterGuiBinding</vh></v>
<v t="ekr.20061021144014.30"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20061021144014.31"><vh>printBindings &amp; helper</vh>
<v t="ekr.20061021144014.32"><vh>printBindingsHelper</vh></v>
</v>
<v t="ekr.20061021144014.33"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20061021144014.34"><vh>Fix bug in ops plugin</vh></v>
<v t="ekr.20061021144014.35"><vh>Fixed crasher on script button balloons</vh></v>
<v t="ekr.20061021144014.36"><vh>Fix bug: closing a window after removing a script button can crash</vh></v>
<v t="ekr.20061021144014.37"><vh>The end-of-script message no longer yanks focus from tabs</vh>
<v t="ekr.20061021144014.38"><vh>c.executeScript</vh>
<v t="ekr.20061021144014.39"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20061021144014.40"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.41"><vh>Fixed  warning if minibuffer command does not exist when making menus</vh>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.47"><vh>Fixed new unicode bug</vh>
<v t="ekr.20061021144014.48"><vh>Found: string.letters</vh>
<v t="ekr.20061021144014.5"><vh>findWord</vh></v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
<v t="ekr.20061021144014.49"><vh>insertNormalChar</vh></v>
<v t="ekr.20061021144014.50"><vh>doOp</vh></v>
<v t="ekr.20061021144014.51"><vh>appendToRegister</vh></v>
<v t="ekr.20061021144014.52"><vh>prependToRegister</vh></v>
<v t="ekr.20061021144014.53"><vh>copyRectangleToRegister</vh></v>
<v t="ekr.20061021144014.54"><vh>copyToRegister</vh></v>
<v t="ekr.20061021144014.55"><vh>incrementRegister</vh></v>
<v t="ekr.20061021144014.56"><vh>insertRegister</vh></v>
<v t="ekr.20061021144014.57"><vh>jumpToRegister</vh></v>
<v t="ekr.20061021144014.58"><vh>numberToRegister (not used)</vh></v>
<v t="ekr.20061021144014.59"><vh>pointToRegister</vh></v>
<v t="ekr.20061021144014.60"><vh>viewRegister</vh></v>
<v t="ekr.20061021144014.61"><vh>&lt;&lt; create press-buttonText-button command &gt;&gt;</vh></v>
<v t="ekr.20061021144014.62"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20061021144014.63"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
</v>
<v t="ekr.20061021144014.64"><vh>Found: string.digits</vh>
<v t="ekr.20061021144014.65"><vh>zapToCharacter</vh></v>
<v t="ekr.20061021144014.66" a="M"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.67"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.68"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20061021144014.69"><vh>skip_id</vh></v>
<v t="ekr.20061021144014.70"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
<v t="ekr.20061021144014.71"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20061021144014.72"><vh>getDouble</vh></v>
<v t="ekr.20061021144014.73"><vh>getLong</vh></v>
<v t="ekr.20061021144014.74"><vh>is_c_id</vh></v>
<v t="ekr.20061021144014.75"><vh>match_word</vh></v>
<v t="ekr.20061021144014.76"><vh>skip_c_id</vh></v>
<v t="ekr.20061021144014.77"><vh>skip_id</vh></v>
<v t="ekr.20061021144014.78"><vh>skip_long</vh></v>
<v t="ekr.20061021144014.79"><vh>skipElispId</vh></v>
<v t="ekr.20061021144014.80"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20061021144014.81"><vh>universalDispatcher &amp; helpers</vh>
<v t="ekr.20061021144014.82"><vh>&lt;&lt; about repeat counts &gt;&gt;</vh></v>
<v t="ekr.20061021144014.83"><vh>executeNTimes</vh></v>
<v t="ekr.20061021144014.84"><vh>doControlU</vh></v>
</v>
<v t="ekr.20061021144014.85"><vh>scan_short_val</vh></v>
<v t="ekr.20061021144014.86"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="ekr.20061021144014.87"><vh>computeOldStyleShortcutKey</vh></v>
<v t="ekr.20061021144014.88"><vh>&lt;&lt; eliminate invalid characters &gt;&gt;</vh></v>
<v t="ekr.20061021144014.89"><vh>&lt;&lt; eliminate non-numbers &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.90"><vh>Found: string.</vh>
<v t="ekr.20061021144014.91" a="M"><vh>doNormalState</vh>
<v t="ekr.20061021144014.92"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20061021144014.93"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20061021144014.94"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.95"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.96"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.97"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.98"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20061021144014.99"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
<v t="ekr.20061021144014.100"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.101"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20061021144014.102"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20061021144014.103"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.104"><vh>Vaid only in latex mode</vh>
<v t="ekr.20061021144014.105"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.106"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20061021144014.107"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20061021144014.108"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20061021144014.109"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20061021144014.110"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20061021144014.111"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20061021144014.112"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.113" a="M"><vh>getCwebWord</vh></v>
<v t="ekr.20061021144014.114" a="M"><vh>init_trace</vh></v>
<v t="ekr.20061021144014.115" a="M"><vh>sanitize_filename</vh></v>
<v t="ekr.20061021144014.116" a="M"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="ekr.20061021144014.117" a="M"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="ekr.20061021144014.66" a="M"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.118" a="M"><vh>definePatterns</vh></v>
<v t="ekr.20061021144014.119" a="M"><vh>autoCompleterStateHandler</vh></v>
<v t="ekr.20061021144014.120" a="M"><vh>directiveKind4 &amp; test</vh>
<v t="ekr.20061021144014.121"><vh>test_directiveKind4</vh></v>
</v>
<v t="ekr.20061021144014.122" a="M"><vh>test_isPlainKey</vh></v>
</v>
</v>
<v t="ekr.20061021144014.123"><vh>Made 'About Plugin' dialog scrollable</vh></v>
<v t="ekr.20061021144014.124"><vh>Removed unwanted key-state message</vh></v>
<v t="ekr.20061021144014.125"><vh>Removed datenodes.ini from cvs</vh></v>
<v t="ekr.20061021144014.126"><vh>Made sure all kill commands do a full recolor</vh>
<v t="ekr.20061021144014.127"><vh>killBufferCommandsClass (add docstrings)</vh>
<v t="ekr.20061021144014.128"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20061021144014.129"><vh> getPublicCommands</vh></v>
<v t="ekr.20061021144014.130"><vh>addToKillBuffer</vh></v>
<v t="ekr.20061021144014.131"><vh>backwardKillSentence</vh></v>
<v t="ekr.20061021144014.132"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20061021144014.133"><vh>clearKillRing</vh></v>
<v t="ekr.20061021144014.134"><vh>getClipboard</vh></v>
<v t="ekr.20061021144014.135"><vh>iterateKillBuffer</vh></v>
<v t="ekr.20061021144014.136"><vh>kill, killLine</vh></v>
<v t="ekr.20061021144014.137"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20061021144014.138"><vh>killSentence</vh></v>
<v t="ekr.20061021144014.139"><vh>killWs</vh></v>
<v t="ekr.20061021144014.140"><vh>yank</vh></v>
<v t="ekr.20061021144014.141"><vh>yankPop</vh></v>
<v t="ekr.20061021144014.65"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20061021144014.142"><vh>begin/endCommand</vh>
<v t="ekr.20061021144014.143"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20061021144014.144"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20061021144014.145"><vh>endCommand</vh></v>
</v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.149"><vh>Fixed bug in new colorizer</vh>
<v t="ekr.20061021144014.150"><vh>Edit Body submenu</vh>
<v t="ekr.20061021144014.151"><vh>convertAllBlanks</vh></v>
<v t="ekr.20061021144014.152"><vh>convertAllTabs</vh></v>
<v t="ekr.20061021144014.153"><vh>convertBlanks</vh></v>
<v t="ekr.20061021144014.154"><vh>convertTabs</vh></v>
<v t="ekr.20061021144014.155"><vh>createLastChildNode</vh></v>
<v t="ekr.20061021144014.156"><vh>dedentBody</vh></v>
<v t="ekr.20061021144014.157"><vh>extract</vh></v>
<v t="ekr.20061021144014.158"><vh>extractSection</vh>
<v t="ekr.20061021144014.159"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.160"><vh>extractSectionNames</vh>
<v t="ekr.20061021144014.161"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.162"><vh>findBoundParagraph</vh>
<v t="ekr.20061021144014.163"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.164"><vh>findMatchingBracket</vh>
<v t="ekr.20061021144014.165"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20061021144014.166"><vh>getBodyLines</vh></v>
<v t="ekr.20061021144014.167"><vh>indentBody</vh></v>
<v t="ekr.20061021144014.168"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20061021144014.169"><vh>getTime &amp; test</vh></v>
</v>
<v t="ekr.20061021144014.170"><vh>insert/removeComments</vh>
<v t="ekr.20061021144014.171"><vh>addComments</vh></v>
<v t="ekr.20061021144014.172"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20061021144014.173"><vh>reformatParagraph</vh>
<v t="ekr.20061021144014.174"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20061021144014.175"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20061021144014.176"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20061021144014.177"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.178"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20061021144014.178"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.179"><vh>setSelection</vh></v>
</v>
<v t="ekr.20061021144014.180"><vh>Removed set-mark-command and all calls to removeRKeys</vh>
<v t="ekr.20061021144014.181"><vh>Found: removeRKeys</vh>
<v t="ekr.20061021144014.137"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20061021144014.182"><vh>testinrange</vh></v>
<v t="ekr.20061021144014.183"><vh>indentRegion (not used: use c.indentBody instead)</vh></v>
<v t="ekr.20061021144014.184"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
</v>
<v t="ekr.20061021144014.185"><vh>Fixed body editor problems</vh>
<v t="ekr.20061021144014.186"><vh>masterClickHandler</vh></v>
<v t="ekr.20061021144014.11"><vh>cycleAllFocus</vh></v>
<v t="ekr.20061021144014.187"><vh>class leoTkinterBody</vh>
<v t="ekr.20061021144014.188"><vh> Birth &amp; death</vh>
<v t="ekr.20061021144014.189"><vh>tkBody. __init__</vh></v>
<v t="ekr.20061021144014.190"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20061021144014.191"><vh>tkBody.createControl</vh></v>
<v t="ekr.20061021144014.192"><vh>tkBody.createTextWidget</vh></v>
</v>
<v t="ekr.20061021144014.193"><vh>Editors</vh>
<v t="ekr.20061021144014.194"><vh>recolorWidget</vh></v>
<v t="ekr.20061021144014.195"><vh>create/select/unselect/Label</vh></v>
<v t="ekr.20061021144014.196"><vh>addEditor</vh>
<v t="ekr.20061021144014.197"><vh>&lt;&lt; create label and text widgets &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.198"><vh>setEditorColors</vh></v>
<v t="ekr.20061021144014.13"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20061021144014.199"><vh>deleteEditor</vh></v>
<v t="ekr.20061021144014.200"><vh>onClick</vh></v>
<v t="ekr.20061021144014.201"><vh>selectEditor</vh>
<v t="ekr.20061021144014.202"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.203"><vh>selectMainEditor</vh></v>
<v t="ekr.20061021144014.204"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20061021144014.205"><vh>tkBody.setColorFromConfig</vh></v>
<v t="ekr.20061021144014.206"><vh>tkBody.setFontFromConfig</vh></v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.207"><vh>Focus (tkBody)</vh></v>
<v t="ekr.20061021144014.208"><vh>forceRecolor</vh></v>
<v t="ekr.20061021144014.209"><vh>Tk bindings (tkBbody)</vh>
<v t="ekr.20061021144014.210"><vh>Bounding box (Tk spelling)</vh></v>
<v t="ekr.20061021144014.211"><vh>Color tags (Tk spelling)</vh></v>
<v t="ekr.20061021144014.212"><vh>Configuration (Tk spelling)</vh></v>
<v t="ekr.20061021144014.213"><vh>Height &amp; width</vh></v>
<v t="ekr.20061021144014.214"><vh>Idle time...</vh></v>
<v t="ekr.20061021144014.215"><vh>Indices (leoTkinterBody)</vh>
<v t="ekr.20061021144014.216"><vh>adjustIndex</vh></v>
<v t="ekr.20061021144014.217"><vh>compareIndices</vh></v>
<v t="ekr.20061021144014.218"><vh>convertRowColumnToIndex</vh></v>
<v t="ekr.20061021144014.219"><vh>convertIndexToRowColumn</vh></v>
<v t="ekr.20061021144014.220"><vh>getImageIndex</vh></v>
<v t="ekr.20061021144014.221"><vh>tkIndex (internal use only)</vh></v>
</v>
<v t="ekr.20061021144014.222"><vh>Insert point</vh>
<v t="ekr.20061021144014.223"><vh>get/setPythonInsertionPoint</vh></v>
<v t="ekr.20061021144014.224"><vh>getInsertionPoint &amp; getBeforeInsertionPoint</vh></v>
<v t="ekr.20061021144014.225"><vh>getCharAtInsertPoint &amp; getCharBeforeInsertPoint</vh></v>
<v t="ekr.20061021144014.226"><vh>makeInsertPointVisible</vh></v>
<v t="ekr.20061021144014.227"><vh>setInsertionPointTo...</vh></v>
</v>
<v t="ekr.20061021144014.228"><vh>Menus</vh></v>
<v t="ekr.20061021144014.229"><vh>Selection</vh>
<v t="ekr.20061021144014.230"><vh>deleteTextSelection</vh></v>
<v t="ekr.20061021144014.231"><vh>getSelectedText</vh></v>
<v t="ekr.20061021144014.232"><vh>getTextSelection</vh></v>
<v t="ekr.20061021144014.233"><vh>getPythonTextSelection</vh></v>
<v t="ekr.20061021144014.234"><vh>setPythonTextSelection</vh></v>
<v t="ekr.20061021144014.235"><vh>hasTextSelection</vh></v>
<v t="ekr.20061021144014.236"><vh>selectAllText</vh></v>
<v t="ekr.20061021144014.237"><vh>setTextSelection (tkinterBody)</vh></v>
</v>
<v t="ekr.20061021144014.238"><vh>Text</vh>
<v t="ekr.20061021144014.239"><vh>delete...</vh></v>
<v t="ekr.20061021144014.240"><vh>get...</vh>
<v t="ekr.20061021144014.241"><vh>tkBody.getAllText</vh></v>
<v t="ekr.20061021144014.242"><vh>getCharAtIndex</vh></v>
<v t="ekr.20061021144014.243"><vh>getInsertLines</vh></v>
<v t="ekr.20061021144014.244"><vh>getSelectionAreas</vh></v>
<v t="ekr.20061021144014.245"><vh>getSelectionLines (tkBody)</vh></v>
<v t="ekr.20061021144014.246"><vh>getTextRange</vh></v>
</v>
<v t="ekr.20061021144014.247"><vh>Insert...</vh>
<v t="ekr.20061021144014.248"><vh>insertAtInsertPoint</vh></v>
<v t="ekr.20061021144014.249"><vh>insertAtEnd</vh></v>
<v t="ekr.20061021144014.250"><vh>insertAtStartOfLine</vh></v>
</v>
<v t="ekr.20061021144014.251"><vh>setSelectionAreas (tkinterBody)</vh></v>
</v>
<v t="ekr.20061021144014.252"><vh>Visibility &amp; scrolling</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.253"><vh>Fixed rst3 crash</vh></v>
<v t="ekr.20061021144014.254"><vh>Moved @import to top of doc/default.css</vh></v>
<v t="ekr.20061021144014.255"><vh>Fixed focus problem when double-clicking @url nodes</vh>
<v t="ekr.20061021144014.256"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20061021144014.257"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20061021144014.258"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20061021144014.259"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20061021144014.260"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.261"><vh>onTreeClick</vh></v>
<v t="ekr.20061021144014.262"><vh>set_focus (app.gui)</vh></v>
</v>
</v>
<v t="ekr.20061021144014.263"><vh>Features</vh>
<v t="ekr.20061021144014.264"><vh>Removed .leoRecentFiles.txt from distribution and cvs</vh>
<v t="ekr.20061021144014.265"><vh>ctor (configClass)</vh></v>
<v t="ekr.20061021144014.266"><vh>g.app.config.readSettingsFiles</vh></v>
<v t="ekr.20061021144014.267"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061021144014.268"><vh>createRecentFiles</vh></v>
<v t="ekr.20061021144014.269"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061021144014.270"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
<v t="ekr.20061021144014.271"><vh>Added minibuffer and Settings menus</vh>
<v t="ekr.20061021144014.272"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.273"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20061021144014.274"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20061021144014.275"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20061021144014.276"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061021144014.277"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20061021144014.278"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20061021144014.279"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20061021144014.280"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20061021144014.281"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20061021144014.282"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20061021144014.283"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20061021144014.284"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20061021144014.285"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20061021144014.286"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20061021144014.287"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20061021144014.288" a="M"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20061021144014.290"><vh>Created do-nothing command and tested binding to unicode character</vh>
<v t="ekr.20061021144014.291"><vh>doNothing</vh></v>
</v>
<v t="ekr.20061021144014.292"><vh>Toggling autocompleter and calltips now write to log (in red) instead of the statusLine</vh>
<v t="ekr.20061021144014.293"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20061021144014.294"><vh>Finished collapse-on-move-left</vh>
<v t="ekr.20061021144014.295"><vh>Move... (Commands)</vh>
<v t="ekr.20061021144014.296"><vh>demote</vh></v>
<v t="ekr.20061021144014.297"><vh>moveOutlineDown</vh>
<v t="ekr.20061021144014.298"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.299"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20061021144014.300"><vh>moveOutlineRight</vh></v>
<v t="ekr.20061021144014.301"><vh>moveOutlineUp</vh>
<v t="ekr.20061021144014.302"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.303"><vh>promote</vh></v>
</v>
</v>
<v t="ekr.20061021144014.304"><vh>Properly create Help menu on the Mac</vh>
<v t="ekr.20061021144014.305" a="M"><vh>createHelpMenuFromTable</vh></v>
<v t="ekr.20061021144014.306" a="M"><vh>getMacHelpMenu</vh></v>
</v>
<v t="ekr.20061021144014.307"><vh>'*command-name' in headline means convert '-' to blanks</vh></v>
<v t="ekr.20061021144014.308"><vh>Removed all references to commands from menu tables</vh>
<v t="ekr.20061021144014.309"><vh>regexp</vh></v>
<v t="ekr.20061021144014.310"><vh>capitalizeMinibufferMenuName</vh></v>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.311"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.312"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.313"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20061021144014.314"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20061021144014.315"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20061021144014.316"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20061021144014.317"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20061021144014.318"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.319"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20061021144014.320"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20061021144014.321"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20061021144014.322"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20061021144014.323"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20061021144014.324"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20061021144014.325"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20061021144014.326"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20061021144014.327"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.328"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20061021144014.329"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20061021144014.330"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20061021144014.331"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20061021144014.332"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20061021144014.333"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20061021144014.272"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.273"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20061021144014.274"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20061021144014.275"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20061021144014.276"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061021144014.277"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20061021144014.278"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20061021144014.279"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20061021144014.280"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20061021144014.281"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20061021144014.282"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20061021144014.283"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20061021144014.284"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20061021144014.285"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20061021144014.286"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20061021144014.287"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20061021144014.334"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20061021144014.335"><vh>Add Open scripts.leo to help menu</vh>
<v t="ekr.20061021144014.336"><vh>openLeoScripts</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20061021144014.337"><vh>The spell tab now uses ctypes for Python 2.5</vh>
<v t="ekr.20061021144014.338"><vh>Spell classes</vh>
<v t="ekr.20061021144014.339"><vh>class spellCommandsClass</vh>
<v t="ekr.20061021144014.340"><vh>ctor</vh></v>
<v t="ekr.20061021144014.341"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20061021144014.342"><vh>openSpellTab</vh></v>
<v t="ekr.20061021144014.343"><vh>commands...</vh></v>
</v>
<v t="ekr.20061021144014.344"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20061021144014.345"><vh>Birth &amp; death</vh>
<v t="ekr.20061021144014.346"><vh>spellTab.__init__</vh></v>
<v t="ekr.20061021144014.347"><vh>init_aspell</vh></v>
<v t="ekr.20061021144014.348"><vh>createSpellTab</vh>
<v t="ekr.20061021144014.349"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20061021144014.350"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20061021144014.351"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.352"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20061021144014.353"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20061021144014.354"><vh>Buttons</vh>
<v t="ekr.20061021144014.355"><vh>onAddButton</vh></v>
<v t="ekr.20061021144014.356"><vh>onIgnoreButton</vh></v>
<v t="ekr.20061021144014.357"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20061021144014.358"><vh>onFindButton</vh></v>
<v t="ekr.20061021144014.359"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20061021144014.360"><vh>Commands</vh>
<v t="ekr.20061021144014.361"><vh>add</vh></v>
<v t="ekr.20061021144014.362"><vh>change</vh></v>
<v t="ekr.20061021144014.363"><vh>find</vh></v>
<v t="ekr.20061021144014.364"><vh>hide</vh></v>
<v t="ekr.20061021144014.365"><vh>ignore</vh></v>
</v>
<v t="ekr.20061021144014.366"><vh>Helpers</vh>
<v t="ekr.20061021144014.367"><vh>bringToFront</vh></v>
<v t="ekr.20061021144014.368"><vh>fillbox</vh></v>
<v t="ekr.20061021144014.369"><vh>findNextMisspelledWord</vh>
<v t="ekr.20061021144014.370"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
<v t="ekr.20061021144014.371"><vh>getSuggestion</vh></v>
<v t="ekr.20061021144014.372"><vh>onMap</vh></v>
<v t="ekr.20061021144014.373"><vh>onSelectListBox</vh></v>
<v t="ekr.20061021144014.374"><vh>update</vh></v>
<v t="ekr.20061021144014.375"><vh>updateButtons</vh></v>
</v>
</v>
<v t="ekr.20061021144014.376"><vh>class AspellClass</vh>
<v t="ekr.20061021144014.377"><vh>Birth &amp; death</vh>
<v t="ekr.20061021144014.378"><vh>__init__</vh></v>
<v t="ekr.20061021144014.379"><vh>getAspell</vh></v>
<v t="ekr.20061021144014.380"><vh>getAspellWithCtypes</vh>
<v t="ekr.20061021144014.381"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.382"><vh>processWord</vh></v>
<v t="ekr.20061021144014.383"><vh>suggestions</vh></v>
<v t="ekr.20061021144014.384"><vh>updateDictionary</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.385"><vh>Simulated x-windows middle-button paste</vh>
<v t="ekr.20061021144014.386"><vh>Request</vh></v>
<v t="ekr.20061021144014.387"><vh>Fix new middle-button problem</vh></v>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.190"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20061021144014.388"><vh>OnPaste (To support middle-button paste)</vh></v>
<v t="ekr.20061021144014.186"><vh>masterClickHandler</vh></v>
<v t="ekr.20061021144014.389"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20061021144014.390"><vh>copyText</vh></v>
<v t="ekr.20061021144014.391"><vh>cutText</vh></v>
<v t="ekr.20061021144014.392"><vh>pasteText</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.393"><vh>Plugins</vh>
<v t="ekr.20061021144014.394"><vh>Fixed keyBindings plugin</vh></v>
<v t="ekr.20061021144014.395"><vh>The scripting plugin now creates a delete-x-script-button command for each script button</vh></v>
<v t="ekr.20061021144014.396"><vh>Fixed (sorta) the nodenavigator plugin</vh></v>
<v t="ekr.20061021144014.397"><vh>Rewrote the multifile plugin for the 4.x code base.</vh></v>
<v t="ekr.20061021144014.398"><vh>Replaced __name__ with __plugin_name__ in four plugins</vh></v>
<v t="ekr.20061021144014.399"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20061021144014.400"><vh>Fixed bugs in multi-file plugin</vh></v>
<v t="ekr.20061021144014.401"><vh>More work on multifile plugin</vh></v>
<v t="ekr.20061021144014.402"><vh>Fix bug in shortcut_button plugin</vh></v>
</v>
<v t="ekr.20061021144014.403"><vh>Settings</vh>
<v t="ekr.20061021144014.404"><vh>Made unlimited undo the default</vh></v>
<v t="ekr.20061021144014.405"><vh>Added @bool select_all_text_when_editing_headlines</vh>
<v t="ekr.20061021144014.406"><vh>setEditLabelState</vh></v>
<v t="ekr.20061021144014.407"><vh>editLabel</vh></v>
<v t="ekr.20061021144014.408"><vh>c.insertHeadline</vh></v>
<v t="ekr.20061021144014.409"><vh>c.editPosition</vh></v>
</v>
<v t="ekr.20061021144014.410"><vh>Added bindings to toggle-autocompleter and toggle-calltips</vh></v>
<v t="ekr.20061021144014.411"><vh>Added 'Candidates for myLeoSettings.leo' to leoSettings.leo</vh></v>
<v t="ekr.20061021144014.412"><vh>Recent changes to settings</vh></v>
<v t="ekr.20061021144014.413"><vh>Added @boo insert_new_nodes_at_end</vh>
<v t="ekr.20061021144014.408"><vh>c.insertHeadline</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.2"><vh>Leo 4.4.3 projects</vh>
<v t="ekr.20070626112754.3"><vh>Leo 4.4.3 alpha 1 projects</vh>
<v t="ekr.20070626112754.4"><vh>Bugs</vh>
<v t="ekr.20070626112754.5"><vh>Fixed an escape bug in new colorizer</vh></v>
<v t="ekr.20070626112754.6"><vh>Fixed new autocompletion bugs</vh></v>
<v t="ekr.20070626112754.7"><vh>Treat escaped characters in find patterns as a single character</vh>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
<v t="ekr.20070626112754.14"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20070626112754.15"><vh>Fixed undo problems with yank/kill</vh>
<v t="ekr.20070626112754.16"><vh>Notes</vh></v>
<v t="ekr.20070626112754.17"><vh>How to reproduce undo bug</vh></v>
<v t="ekr.20070626112754.18"><vh>killBufferCommandsClass (add docstrings)</vh>
<v t="ekr.20070626112754.19"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20070626112754.20"><vh> getPublicCommands</vh></v>
<v t="ekr.20070626112754.21"><vh>addToKillBuffer</vh></v>
<v t="ekr.20070626112754.22"><vh>backwardKillSentence</vh></v>
<v t="ekr.20070626112754.23"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20070626112754.24"><vh>clearKillRing</vh></v>
<v t="ekr.20070626112754.25"><vh>getClipboard</vh></v>
<v t="ekr.20070626112754.26"><vh>iterateKillBuffer</vh></v>
<v t="ekr.20070626112754.27"><vh>kill, killLine</vh></v>
<v t="ekr.20070626112754.28"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20070626112754.29"><vh>killSentence</vh></v>
<v t="ekr.20070626112754.30"><vh>killWs</vh></v>
<v t="ekr.20070626112754.31"><vh>yank</vh></v>
<v t="ekr.20070626112754.32"><vh>yankPop</vh></v>
<v t="ekr.20070626112754.33"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20070626112754.34"><vh>undoTyping</vh></v>
<v t="ekr.20070626112754.35"><vh>redoTyping</vh></v>
<v t="ekr.20070626112754.36"><vh>undoRedoText (passed)</vh>
<v t="ekr.20070626112754.37"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.38"><vh>Fixed clone-drag problem</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.40"><vh>Dragging (tkTree)</vh>
<v t="ekr.20070626112754.41"><vh>endDrag</vh>
<v t="ekr.20070626112754.42"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20070626112754.43"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.44"><vh>startDrag</vh></v>
<v t="ekr.20070626112754.45"><vh>onContinueDrag</vh>
<v t="ekr.20070626112754.46"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.47"><vh>onDrag</vh></v>
<v t="ekr.20070626112754.48"><vh>onEndDrag</vh></v>
</v>
</v>
<v t="ekr.20070626112754.49"><vh>Made sure all ancestors expanded when select a body editor with multiple body editors</vh>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.53"><vh>Fixed bug in CheckVersion</vh>
<v t="ekr.20070626112754.54"><vh>CheckVersion (EKR) &amp; helper</vh>
<v t="ekr.20070626112754.55"><vh>CheckVersionToInt</vh></v>
<v t="ekr.20070626112754.56"><vh>@test CheckVersionToInt</vh></v>
</v>
</v>
<v t="ekr.20070626112754.57"><vh>Fixed bugs arising from new reorg</vh>
<v t="ekr.20070626112754.58"><vh>Fixed several unit tests that failed with bad selection</vh>
<v t="ekr.20070626112754.59"><vh>backToIndentation</vh></v>
<v t="ekr.20070626112754.60"><vh>runEditCommandTest</vh></v>
<v t="ekr.20070626112754.61"><vh>setInsertPoint</vh></v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.67"><vh>Fixed change bugs</vh>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.61"><vh>setInsertPoint</vh></v>
<v t="ekr.20070626112754.70"><vh>changeSelection</vh>
<v t="ekr.20070626112754.71"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20070626112754.14"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20070626112754.72"><vh>(Fixed match-brackets command)</vh>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.82"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.83"><vh>c.findMatchingBracket &amp; helper</vh>
<v t="ekr.20070626112754.84"><vh>findMatchingBracketHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.85"><vh>Fixed off-by-one error in go-to-line-number command</vh></v>
<v t="ekr.20070626112754.86"><vh>Fixed crash in backwardDeleteCharacters</vh>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.89"><vh>(Fix autocompletion problems)</vh></v>
<v t="ekr.20070626112754.90"><vh>(Fixed index problems due to changing w.toGuiIndex)</vh>
<v t="ekr.20070626112754.91"><vh>Removed no-longer needed tests for newlines</vh>
<v t="ekr.20070626112754.92"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20070626112754.93"><vh> Index utilities... (leoGlobals) (passed)</vh>
<v t="ekr.20070626112754.94"><vh>g.convertPythonIndexToRowCol</vh></v>
<v t="ekr.20070626112754.95"><vh>g.convertRowColToPythonIndex</vh></v>
</v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.96"><vh>Fixed problems in new headlines</vh>
<v t="ekr.20070626112754.97"><vh>setEditLabelState</vh></v>
<v t="ekr.20070626112754.98"><vh>tree.setHeadlineText</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
</v>
<v t="ekr.20070626112754.100"><vh>(Suppressed initial scroll on drag)</vh>
<v t="ekr.20070626112754.101"><vh>onIconBoxClick</vh></v>
<v t="ekr.20070626112754.40"><vh>Dragging (tkTree)</vh>
<v t="ekr.20070626112754.41"><vh>endDrag</vh>
<v t="ekr.20070626112754.42"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20070626112754.43"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.44"><vh>startDrag</vh></v>
<v t="ekr.20070626112754.45"><vh>onContinueDrag</vh>
<v t="ekr.20070626112754.46"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.47"><vh>onDrag</vh></v>
<v t="ekr.20070626112754.48"><vh>onEndDrag</vh></v>
</v>
</v>
<v t="ekr.20070626112754.102"><vh>(Made sure word search for w. works)</vh>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.103"><vh>Restore selection in undo/redo</vh>
<v t="ekr.20070626112754.104"><vh>class undoer</vh>
<v t="ekr.20070626112754.105"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="ekr.20070626112754.106"><vh>clearIvars</vh></v>
</v>
<v t="ekr.20070626112754.107"><vh>Internal helpers</vh>
<v t="ekr.20070626112754.108"><vh>cutStack</vh></v>
<v t="ekr.20070626112754.109"><vh>getBead</vh></v>
<v t="ekr.20070626112754.110"><vh>peekBead</vh></v>
<v t="ekr.20070626112754.111"><vh>pushBead</vh></v>
<v t="ekr.20070626112754.112"><vh>setIvarsFromBunch</vh></v>
<v t="ekr.20070626112754.113"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20070626112754.114"><vh>redoMenuName, undoMenuName</vh></v>
<v t="ekr.20070626112754.115"><vh>setRedoType, setUndoType</vh></v>
<v t="ekr.20070626112754.116"><vh>setUndoTypes</vh></v>
<v t="ekr.20070626112754.117"><vh>u.restoreTree &amp; helpers</vh>
<v t="ekr.20070626112754.118"><vh>restoreVnodeUndoInfo</vh></v>
<v t="ekr.20070626112754.119"><vh>restoreTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20070626112754.120"><vh>u.saveTree &amp; helpers</vh>
<v t="ekr.20070626112754.121"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
<v t="ekr.20070626112754.122"><vh>createVnodeUndoInfo</vh></v>
<v t="ekr.20070626112754.123"><vh>createTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20070626112754.124"><vh>u.trace</vh></v>
<v t="ekr.20070626112754.125"><vh>updateMarks</vh></v>
</v>
<v t="ekr.20070626112754.126"><vh>Externally visible entries</vh>
<v t="ekr.20070626112754.127"><vh>afterX...</vh>
<v t="ekr.20070626112754.128"><vh>afterChangeGroup</vh></v>
<v t="ekr.20070626112754.129"><vh>afterChangeNodeContents</vh></v>
<v t="ekr.20070626112754.130"><vh>afterChangeTree</vh></v>
<v t="ekr.20070626112754.131"><vh>afterClearRecentFiles</vh></v>
<v t="ekr.20070626112754.132"><vh>afterCloneNode</vh></v>
<v t="ekr.20070626112754.133"><vh>afterDehoist</vh></v>
<v t="ekr.20070626112754.134"><vh>afterDeleteNode</vh></v>
<v t="ekr.20070626112754.135"><vh>afterHoist</vh></v>
<v t="ekr.20070626112754.136"><vh>afterInsertNode</vh></v>
<v t="ekr.20070626112754.137"><vh>afterMark</vh></v>
<v t="ekr.20070626112754.138"><vh>afterMoveNode</vh></v>
</v>
<v t="ekr.20070626112754.139"><vh>beforeX...</vh>
<v t="ekr.20070626112754.140"><vh>beforeChangeGroup</vh></v>
<v t="ekr.20070626112754.141"><vh>beforeChangeNodeContents</vh></v>
<v t="ekr.20070626112754.142"><vh>beforeChangeTree</vh></v>
<v t="ekr.20070626112754.143"><vh>beforeClearRecentFiles</vh></v>
<v t="ekr.20070626112754.144"><vh>beforeCloneNode</vh></v>
<v t="ekr.20070626112754.145"><vh>beforeDeleteNode</vh></v>
<v t="ekr.20070626112754.146"><vh>beforeInsertNode</vh></v>
<v t="ekr.20070626112754.147"><vh>beforeMark</vh></v>
<v t="ekr.20070626112754.148"><vh>beforeMoveNode</vh></v>
<v t="ekr.20070626112754.149"><vh>createCommonBunch</vh></v>
</v>
<v t="ekr.20070626112754.150"><vh>canRedo &amp; canUndo</vh></v>
<v t="ekr.20070626112754.151"><vh>clearUndoState</vh></v>
<v t="ekr.20070626112754.152"><vh>enableMenuItems</vh></v>
<v t="ekr.20070626112754.153"><vh>getMark &amp; rollbackToMark (no longer used)</vh></v>
<v t="ekr.20070626112754.154"><vh>setUndoTypingParams</vh>
<v t="ekr.20070626112754.155"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20070626112754.156"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20070626112754.157"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.158"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20070626112754.159"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20070626112754.160"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20070626112754.161"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20070626112754.162"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.163"><vh>redo &amp; helpers...</vh>
<v t="ekr.20070626112754.164"><vh>redoClearRecentFiles</vh></v>
<v t="ekr.20070626112754.165"><vh>redoCloneNode</vh></v>
<v t="ekr.20070626112754.166"><vh>redoDeleteNode</vh></v>
<v t="ekr.20070626112754.167"><vh>redoInsertNode</vh></v>
<v t="ekr.20070626112754.168"><vh>redoHoistNode &amp; redoDehoistNode</vh></v>
<v t="ekr.20070626112754.169"><vh>redoGroup</vh></v>
<v t="ekr.20070626112754.170"><vh>redoNodeContents</vh></v>
<v t="ekr.20070626112754.171"><vh>redoMark</vh></v>
<v t="ekr.20070626112754.172"><vh>redoMove</vh></v>
<v t="ekr.20070626112754.173"><vh>redoTree</vh></v>
<v t="ekr.20070626112754.35"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20070626112754.174"><vh>undo &amp; helpers...</vh>
<v t="ekr.20070626112754.175"><vh>undoClearRecentFiles</vh></v>
<v t="ekr.20070626112754.176"><vh>undoCloneNode</vh></v>
<v t="ekr.20070626112754.177"><vh>undoDeleteNode</vh></v>
<v t="ekr.20070626112754.178"><vh>undoGroup</vh></v>
<v t="ekr.20070626112754.179"><vh>undoHoistNode &amp; undoDehoistNode</vh></v>
<v t="ekr.20070626112754.180"><vh>undoInsertNode</vh></v>
<v t="ekr.20070626112754.181"><vh>undoMark</vh></v>
<v t="ekr.20070626112754.182"><vh>undoMove</vh></v>
<v t="ekr.20070626112754.183"><vh>undoNodeContents</vh></v>
<v t="ekr.20070626112754.184"><vh>undoTree</vh></v>
<v t="ekr.20070626112754.185"><vh>undoRedoTree</vh></v>
<v t="ekr.20070626112754.34"><vh>undoTyping</vh></v>
<v t="ekr.20070626112754.36"><vh>undoRedoText (passed)</vh>
<v t="ekr.20070626112754.37"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.35"><vh>redoTyping</vh></v>
<v t="ekr.20070626112754.34"><vh>undoTyping</vh></v>
</v>
<v t="ekr.20070626112754.193"><vh>Improved selection in several commands and undo</vh>
<v t="ekr.20070626112754.194"><vh>reformatParagraph</vh>
<v t="ekr.20070626112754.195"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20070626112754.196"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20070626112754.197"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.198"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.199"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20070626112754.200"><vh>setSelectionAreas</vh></v>
<v t="ekr.20070626112754.201"><vh>getBodyLines</vh></v>
<v t="ekr.20070626112754.202"><vh>getSelectionLines</vh></v>
<v t="ekr.20070626112754.203"><vh>getInsertLines</vh></v>
<v t="ekr.20070626112754.204"><vh>Found: .getBodyLines</vh>
<v t="ekr.20070626112754.205"><vh>removeBlankLines</vh></v>
<v t="ekr.20070626112754.206"><vh>convertBlanks (test)</vh></v>
<v t="ekr.20070626112754.207"><vh>convertTabs (test)</vh></v>
<v t="ekr.20070626112754.208"><vh>dedentBody (test)</vh></v>
<v t="ekr.20070626112754.209"><vh>extract (test)</vh></v>
<v t="ekr.20070626112754.210"><vh>extractSection (test)</vh>
<v t="ekr.20070626112754.211"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.212"><vh>extractSectionNames (test)</vh>
<v t="ekr.20070626112754.213"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.214"><vh>indentBody (test)</vh></v>
<v t="ekr.20070626112754.215"><vh>addComments (test)</vh></v>
<v t="ekr.20070626112754.216"><vh>deleteComments (test)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.217"><vh>Fixed bug in end-of-line commands</vh>
<v t="ekr.20070626112754.218"><vh>move cursor... (leoEditCommands)</vh>
<v t="ekr.20070626112754.219"><vh> helpers</vh>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.223"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20070626112754.224"><vh>moveWordHelper</vh></v>
<v t="ekr.20070626112754.225"><vh>backSentenceHelper</vh></v>
<v t="ekr.20070626112754.226"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20070626112754.227"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.228"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.229"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20070626112754.230"><vh>buffers</vh></v>
<v t="ekr.20070626112754.231"><vh>characters</vh></v>
<v t="ekr.20070626112754.232"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20070626112754.233"><vh>exchangePointMark</vh></v>
<v t="ekr.20070626112754.234"><vh>extend-to-line</vh></v>
<v t="ekr.20070626112754.235"><vh>extend-to-sentence</vh></v>
<v t="ekr.20070626112754.236"><vh>extend-to-word</vh></v>
<v t="ekr.20070626112754.237"><vh>lines</vh></v>
<v t="ekr.20070626112754.238"><vh>movePastClose</vh></v>
<v t="ekr.20070626112754.239"><vh>paragraphs</vh></v>
<v t="ekr.20070626112754.240"><vh>sentences</vh></v>
<v t="ekr.20070626112754.241"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20070626112754.242"><vh>Fixed new bug in kill-line</vh>
<v t="ekr.20070626112754.27"><vh>kill, killLine</vh></v>
</v>
<v t="ekr.20070626112754.243"><vh>Replacing selection not done properly in headline</vh>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
</v>
<v t="ekr.20070626112754.249"><vh>Fixed paragraph commands</vh>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.250"><vh>tag_add</vh></v>
<v t="ekr.20070626112754.251"><vh>extend-to-paragraph &amp; helper</vh>
<v t="ekr.20070626112754.252"><vh>selectParagraphHelper</vh></v>
</v>
<v t="ekr.20070626112754.227"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.228"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.253"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20070626112754.254"><vh>killParagraph</vh></v>
</v>
<v t="ekr.20070626112754.255"><vh>UNL's are not being shown</vh>
<v t="ekr.20070626112754.256"><vh>Status line convenience methods</vh></v>
<v t="ekr.20070626112754.257"><vh>class tkStatusLineClass</vh>
<v t="ekr.20070626112754.258"><vh> ctor</vh></v>
<v t="ekr.20070626112754.259"><vh>clear</vh></v>
<v t="ekr.20070626112754.260"><vh>enable, disable &amp; isEnabled</vh></v>
<v t="ekr.20070626112754.261"><vh>get</vh></v>
<v t="ekr.20070626112754.262"><vh>getFrame</vh></v>
<v t="ekr.20070626112754.263"><vh>onActivate</vh></v>
<v t="ekr.20070626112754.264"><vh>pack &amp; show</vh></v>
<v t="ekr.20070626112754.265"><vh>put (leoTkinterFrame:statusLineClass)</vh></v>
<v t="ekr.20070626112754.266"><vh>unpack &amp; hide</vh></v>
<v t="ekr.20070626112754.267"><vh>update (statusLine)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.268"><vh>Select-all and delete shows too much in body pane</vh>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.269"><vh>selectAllText</vh></v>
</v>
<v t="ekr.20070626112754.270"><vh>Fixed colorizer bug: section references not colored properly</vh>
<v t="ekr.20070626112754.271"><vh>doNowebSecRef (colorizer)</vh>
<v t="ekr.20070626112754.272"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.273"><vh>Fixed cursor up/down bug</vh>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
<v t="ekr.20070626112754.229"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20070626112754.274"><vh>Fix recent crasher in about-leo command</vh>
<v t="ekr.20070626112754.275"><vh>tkinterAboutLeo.createFrame</vh></v>
</v>
<v t="ekr.20070626112754.276"><vh>Fixed bugs in headline</vh>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.269"><vh>selectAllText</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.277"><vh>Features</vh>
<v t="ekr.20070626112754.278"><vh>Added handleUrlInUrlNode helper for OnIconDoubleClick</vh>
<v t="ekr.20070626112754.279"><vh>Request</vh></v>
<v t="ekr.20070626112754.280"><vh>tree.OnIconDoubleClick (@url) &amp; helper</vh>
<v t="ekr.20070626112754.281"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20070626112754.282"><vh>handleUrlInUrlNode</vh>
<v t="ekr.20070626112754.283"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20070626112754.284"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.285"><vh>Only do one message re writing recent files</vh>
<v t="ekr.20070626112754.286"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20070626112754.287"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.288"><vh>Made escape in the minibuffer work like ctrl-g</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.297"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20070626112754.298"><vh>callAltXFunction</vh></v>
</v>
</v>
<v t="ekr.20070626112754.299"><vh>Clear status line in repeat-complex-command</vh></v>
<v t="ekr.20070626112754.300"><vh>Added shortcuts for goto-first/last-sibling</vh></v>
<v t="ekr.20070626112754.301"><vh>Made copied nodes valid Leo files</vh></v>
<v t="ekr.20070626112754.302"><vh>Added support for chdir_to_relative_path setting</vh>
<v t="ekr.20070626112754.303"><vh>g.getBaseDirectory</vh></v>
</v>
<v t="ekr.20070626112754.304"><vh>changeAll now works like findAll</vh>
<v t="ekr.20070626112754.305"><vh>Search classes</vh>
<v t="ekr.20070626112754.306"><vh>class minibufferFind( (the findHandler)</vh>
<v t="ekr.20070626112754.307"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20070626112754.308"><vh> Options (minibufferFind)</vh>
<v t="ekr.20070626112754.309"><vh>setFindScope</vh></v>
<v t="ekr.20070626112754.310"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20070626112754.311"><vh>showFindOptions</vh></v>
<v t="ekr.20070626112754.312"><vh>setupChangePattern</vh></v>
<v t="ekr.20070626112754.313"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20070626112754.314"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20070626112754.315"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20070626112754.316"><vh>changeAll</vh></v>
<v t="ekr.20070626112754.317"><vh>cloneFindAll</vh></v>
<v t="ekr.20070626112754.318"><vh>findAgain</vh></v>
<v t="ekr.20070626112754.319"><vh>findAll</vh></v>
<v t="ekr.20070626112754.320"><vh>generalChangeHelper</vh></v>
<v t="ekr.20070626112754.321"><vh>generalSearchHelper</vh></v>
<v t="ekr.20070626112754.322"><vh>lastStateHelper</vh></v>
<v t="ekr.20070626112754.323"><vh>replaceString</vh></v>
<v t="ekr.20070626112754.324"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20070626112754.325"><vh>seachForward/Backward</vh></v>
<v t="ekr.20070626112754.326"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20070626112754.327"><vh>setupArgs</vh></v>
<v t="ekr.20070626112754.328"><vh>stateZeroHelper</vh></v>
<v t="ekr.20070626112754.329"><vh>updateChange/FindList</vh></v>
<v t="ekr.20070626112754.330"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20070626112754.331"><vh>class searchCommandsClass</vh>
<v t="ekr.20070626112754.332"><vh> ctor (searchCommandsClass)</vh></v>
<v t="ekr.20070626112754.333"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20070626112754.334"><vh>Top-level methods</vh>
<v t="ekr.20070626112754.335"><vh>openFindTab</vh></v>
<v t="ekr.20070626112754.336"><vh>Find Tab commands</vh></v>
<v t="ekr.20070626112754.337"><vh>getHandler</vh></v>
<v t="ekr.20070626112754.338"><vh>Find options wrappers</vh></v>
<v t="ekr.20070626112754.339"><vh>Find wrappers</vh></v>
<v t="ekr.20070626112754.340"><vh>findAgain</vh></v>
</v>
<v t="ekr.20070626112754.341"><vh>incremental search...</vh>
<v t="ekr.20070626112754.342"><vh>iSearchBackspace</vh></v>
<v t="ekr.20070626112754.343"><vh>startIncremental</vh></v>
<v t="ekr.20070626112754.344"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20070626112754.345"><vh>scolorizer LATER</vh></v>
<v t="ekr.20070626112754.346"><vh>iSearchHelper</vh></v>
<v t="ekr.20070626112754.347"><vh>endSearch</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.348"><vh>class leoFind</vh>
<v t="ekr.20070626112754.349"><vh>leoFind.__init__ &amp; helpers</vh>
<v t="ekr.20070626112754.350"><vh>&lt;&lt; compute self.title &gt;&gt;</vh></v>
<v t="ekr.20070626112754.351"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20070626112754.352"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.353"><vh>Top Level Buttons</vh>
<v t="ekr.20070626112754.354"><vh>changeAllButton</vh></v>
<v t="ekr.20070626112754.355"><vh>changeButton</vh></v>
<v t="ekr.20070626112754.356"><vh>changeThenFindButton</vh></v>
<v t="ekr.20070626112754.357"><vh>findAllButton</vh></v>
<v t="ekr.20070626112754.358"><vh>findButton</vh></v>
<v t="ekr.20070626112754.359"><vh>setup_button</vh></v>
</v>
<v t="ekr.20070626112754.360"><vh>Top Level Commands</vh>
<v t="ekr.20070626112754.361"><vh>changeCommand</vh></v>
<v t="ekr.20070626112754.362"><vh>changeThenFindCommand</vh></v>
<v t="ekr.20070626112754.363"><vh>dismiss: defined in subclass class</vh></v>
<v t="ekr.20070626112754.364"><vh>findNextCommand</vh></v>
<v t="ekr.20070626112754.365"><vh>findPreviousCommand</vh></v>
<v t="ekr.20070626112754.366"><vh>handleUserClick</vh></v>
<v t="ekr.20070626112754.367"><vh>setup_command</vh></v>
</v>
<v t="ekr.20070626112754.368"><vh>Find/change utils</vh>
<v t="ekr.20070626112754.369"><vh>batchChange (sets start of change-all group)</vh>
<v t="ekr.20070626112754.370"><vh>&lt;&lt; change headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.371"><vh>&lt;&lt; change body &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.372"><vh>change</vh></v>
<v t="ekr.20070626112754.373"><vh>changeAll (sets end of change-all group)</vh></v>
<v t="ekr.20070626112754.70"><vh>changeSelection</vh>
<v t="ekr.20070626112754.71"><vh>makeRegexSubs</vh></v>
</v>
<v t="ekr.20070626112754.374"><vh>changeThenFind</vh></v>
<v t="ekr.20070626112754.375"><vh>doChange...Script</vh></v>
<v t="ekr.20070626112754.376"><vh>doFind...Script</vh></v>
<v t="ekr.20070626112754.377"><vh>findAll</vh>
<v t="ekr.20070626112754.378"><vh>&lt;&lt; create the found node and begin the undo group &gt;&gt;</vh></v>
<v t="ekr.20070626112754.379"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.380"><vh>findNext</vh></v>
<v t="ekr.20070626112754.381"><vh>findNextMatch</vh></v>
<v t="ekr.20070626112754.382"><vh>resetWrap</vh></v>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.383"><vh>selectNextPosition</vh></v>
</v>
<v t="ekr.20070626112754.384"><vh>General utils</vh>
<v t="ekr.20070626112754.385"><vh>bringToFront (leoFind)</vh></v>
<v t="ekr.20070626112754.386"><vh>oops (leoFind)</vh></v>
<v t="ekr.20070626112754.387"><vh>selectAllFindText (leoFind)</vh></v>
</v>
<v t="ekr.20070626112754.388"><vh>Initing &amp; finalizing</vh>
<v t="ekr.20070626112754.389"><vh>checkArgs</vh></v>
<v t="ekr.20070626112754.390"><vh>init_s_ctrl</vh></v>
<v t="ekr.20070626112754.391"><vh>initBatchCommands</vh></v>
<v t="ekr.20070626112754.392"><vh>initBatchText &amp; initNextText</vh></v>
<v t="ekr.20070626112754.393"><vh>initInHeadline</vh></v>
<v t="ekr.20070626112754.394"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20070626112754.395"><vh>printLine</vh></v>
<v t="ekr.20070626112754.396"><vh>restore</vh></v>
<v t="ekr.20070626112754.397"><vh>save</vh></v>
<v t="ekr.20070626112754.14"><vh>showSuccess</vh></v>
<v t="ekr.20070626112754.398"><vh>update_ivars (leoFind)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.399"><vh>class findTab (leoFind)</vh>
<v t="ekr.20070626112754.400"><vh>findTab.__init__</vh></v>
<v t="ekr.20070626112754.401"><vh>Must be defined in subclasses</vh></v>
<v t="ekr.20070626112754.402"><vh>Callbacks</vh>
<v t="ekr.20070626112754.403"><vh>findButtonCallback</vh></v>
<v t="ekr.20070626112754.404"><vh>hideTab</vh></v>
</v>
<v t="ekr.20070626112754.405"><vh> Top level</vh>
<v t="ekr.20070626112754.406"><vh>change/ThenFindCommand</vh></v>
<v t="ekr.20070626112754.407"><vh>changeAllCommand</vh></v>
<v t="ekr.20070626112754.408"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20070626112754.409"><vh>findAgainCommand</vh></v>
<v t="ekr.20070626112754.410"><vh>findAllCommand</vh></v>
<v t="ekr.20070626112754.411"><vh>findNext/PrefCommand</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.412"><vh>Added Find &amp; Spell tabs to log pane on startup</vh>
<v t="ekr.20070626112754.335"><vh>openFindTab</vh></v>
<v t="ekr.20070626112754.413"><vh>openSpellTab</vh>
<v t="ekr.20070626112754.414"><vh>commands...</vh></v>
</v>
<v t="ekr.20070626112754.415"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20070626112754.416"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20070626112754.417"><vh>tkFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.419"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20070626112754.420"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20070626112754.421"><vh>tkLog.finishCreate</vh></v>
<v t="ekr.20070626112754.422"><vh>deleteTab</vh></v>
</v>
<v t="ekr.20070626112754.423"><vh>Created standard pluginsManager.txt only if it does not exist</vh>
<v t="ekr.20070626112754.424"><vh>loadHandlers &amp; helper</vh>
<v t="ekr.20070626112754.425"><vh>&lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;</vh></v>
<v t="ekr.20070626112754.426"><vh>getEnabledFiles</vh></v>
</v>
</v>
<v t="ekr.20070626112754.427"><vh>Executing Leo-specific scripts from winpdb</vh>
<v t="ekr.20070626112754.428"><vh>Preliminary docs</vh></v>
<v t="ekr.20070626112754.429"><vh>c.executeScript &amp; helpers</vh>
<v t="ekr.20070626112754.430"><vh>redirectScriptOutput</vh></v>
<v t="ekr.20070626112754.431"><vh>unredirectScriptOutput</vh></v>
<v t="ekr.20070626112754.432"><vh>writeScriptFile</vh></v>
</v>
<v t="ekr.20070626112754.433"><vh>debug &amp; helper</vh>
<v t="ekr.20070626112754.434"><vh>findDebugger</vh></v>
</v>
<v t="ekr.20070626112754.435"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20070626112754.436"><vh>@test g.getScript strips crlf</vh></v>
</v>
<v t="ekr.20070626112754.437"><vh>g.handleScriptException</vh>
<v t="ekr.20070626112754.438"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.439"><vh>Added \runAskOkCancelStringDialog</vh></v>
<v t="ekr.20070626112754.440"><vh>Use plain ascii characters instead of special Tk symbols</vh>
<v t="ekr.20070626112754.441"><vh>To do: define special_keys in base class</vh></v>
<v t="ekr.20070626112754.442"><vh>Found: .bind</vh>
<v t="ekr.20070626112754.443"><vh>bindHotKey</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.445"><vh>printBindings</vh></v>
<v t="ekr.20070626112754.446"><vh>bindHotKey</vh></v>
<v t="ekr.20070626112754.447"><vh>f.setMinibufferBindings</vh></v>
<v t="ekr.20070626112754.448"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20070626112754.449"><vh>Menus</vh></v>
<v t="ekr.20070626112754.450"><vh>setTabBindings</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.453"><vh>Shortcuts (keyHandler)</vh>
<v t="ekr.20070626112754.454"><vh>isPlainKey &amp; test</vh>
<v t="ekr.20070626112754.455"><vh>@test isPlainKey</vh></v>
</v>
<v t="ekr.20070626112754.456"><vh>shortcutFromSetting (uses k.guiBindNamesDict)</vh>
<v t="ekr.20070626112754.457"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20070626112754.458"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20070626112754.459"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20070626112754.460"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20070626112754.461"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.462"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20070626112754.463"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.470"><vh>class leoKeyEvent (tkGui)</vh></v>
<v t="ekr.20070626112754.471"><vh>k.defineSpecialKeys</vh></v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
</v>
<v t="ekr.20070626112754.472"><vh>Removed all calls to Tk.Text.bbox</vh>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.473"><vh>Menu reorgs</vh>
<v t="ekr.20070626112754.474"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20070626112754.475"><vh>createFileMenuFromTable</vh>
<v t="ekr.20070626112754.476"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.477"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.478"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.479"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.480"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.481"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.482"><vh>createEditMenuFromTable</vh>
<v t="ekr.20070626112754.483"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.484"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.485"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.486"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20070626112754.487"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.488"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.489"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.490"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.491"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.492"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20070626112754.493"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20070626112754.494"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20070626112754.495"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.496"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.497"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20070626112754.498"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20070626112754.499"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20070626112754.500"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20070626112754.501"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20070626112754.502"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.503"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20070626112754.504"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20070626112754.505"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20070626112754.506"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20070626112754.507"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20070626112754.508"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20070626112754.509"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20070626112754.510"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20070626112754.511"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.512"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20070626112754.513"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20070626112754.514"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20070626112754.515"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20070626112754.516"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20070626112754.517"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20070626112754.518"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20070626112754.519"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20070626112754.520"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20070626112754.521"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20070626112754.522"><vh>defineCmdsMenuChaptersTable</vh></v>
<v t="ekr.20070626112754.523"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20070626112754.524"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20070626112754.525"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20070626112754.526"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20070626112754.527"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20070626112754.528"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20070626112754.529"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20070626112754.530"><vh>defineCmdsMenuRunTable</vh></v>
<v t="ekr.20070626112754.531"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20070626112754.532"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20070626112754.533"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20070626112754.534"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20070626112754.535"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20070626112754.536"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20070626112754.537"><vh>Plugins</vh>
<v t="ekr.20070626112754.538"><vh>Changed bindings in UniversalScrolling pluing</vh></v>
<v t="ekr.20070626112754.539"><vh>Registered write-restructured-text command in rst3 plugin</vh></v>
</v>
<v t="ekr.20070626112754.540"><vh>Settings</vh>
<v t="ekr.20070626112754.541"><vh>Added @bool center_selected_tree_node</vh></v>
<v t="ekr.20070626112754.542"><vh>Added @bool invisible_outline_navigation = False</vh></v>
<v t="ekr.20070626112754.543"><vh>Added @bool show_full_tracebacks_in_scripts</vh></v>
</v>
</v>
<v t="ekr.20070626112754.544"><vh>Leo 4.4.3 alpha 2 projects</vh>
<v t="ekr.20070626112754.545"><vh>Bugs</vh>
<v t="ekr.20070626112754.546"><vh>Fixed bugs in undo/redoNodeContents</vh>
<v t="ekr.20070626112754.547"><vh>c.setBodyString</vh></v>
<v t="ekr.20070626112754.183"><vh>undoNodeContents</vh></v>
<v t="ekr.20070626112754.170"><vh>redoNodeContents</vh></v>
</v>
<v t="ekr.20070626112754.548"><vh>Fixed minor xml problem</vh>
<v t="ekr.20070626112754.549"><vh>putClipboardHeader</vh>
<v t="ekr.20070626112754.550"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.551"><vh>getDummyElements</vh></v>
</v>
<v t="ekr.20070626112754.552"><vh>Fixed C++ import bug</vh>
<v t="ekr.20070626112754.553"><vh>Report</vh></v>
<v t="ekr.20070626112754.554"><vh>scanCText</vh></v>
<v t="ekr.20070626112754.555"><vh>class cScanner</vh>
<v t="ekr.20070626112754.556"><vh>cScanner.ctor</vh></v>
<v t="ekr.20070626112754.557"><vh>scan &amp; helpers</vh>
<v t="ekr.20070626112754.558"><vh>appendUnusedText</vh></v>
<v t="ekr.20070626112754.559"><vh>doId</vh></v>
<v t="ekr.20070626112754.560"><vh>doInner</vh></v>
<v t="ekr.20070626112754.561"><vh>doOuterParen</vh></v>
<v t="ekr.20070626112754.562"><vh>doSemicolon</vh></v>
<v t="ekr.20070626112754.563"><vh>skipComments</vh></v>
</v>
<v t="ekr.20070626112754.564"><vh>Utilities (should be in base class)</vh>
<v t="ekr.20070626112754.565"><vh>createHeadline</vh></v>
<v t="ekr.20070626112754.566"><vh>error</vh></v>
<v t="ekr.20070626112754.567"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070626112754.568"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20070626112754.569"><vh>massageComment</vh></v>
<v t="ekr.20070626112754.570"><vh>setEncoding</vh></v>
<v t="ekr.20070626112754.571"><vh>skipLeadingComments</vh>
<v t="ekr.20070626112754.572"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.573"><vh>&lt;&lt; scan for Lua comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.574"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.575"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.576"><vh>undentBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.577"><vh>Fixed recent bug in next-line command</vh>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
</v>
<v t="ekr.20070626112754.578"><vh>Made standalone plugins manager work again</vh></v>
<v t="ekr.20070626112754.579"><vh>Fixed wiki markup bug</vh></v>
<v t="ekr.20070626112754.580"><vh>Fixed bugs in regular expressions</vh>
<v t="ekr.20070626112754.68"><vh>search &amp; helpers</vh>
<v t="ekr.20070626112754.69"><vh>&lt;&lt; fail if we are passed the wrap point &gt;&gt;</vh></v>
<v t="ekr.20070626112754.8"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20070626112754.9"><vh>regexHelper</vh></v>
<v t="ekr.20070626112754.10"><vh>backwardsHelper</vh></v>
<v t="ekr.20070626112754.11"><vh>plainHelper</vh></v>
<v t="ekr.20070626112754.12"><vh>matchWord</vh></v>
<v t="ekr.20070626112754.13"><vh>replaceBackSlashes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.381"><vh>findNextMatch</vh></v>
<v t="ekr.20070626112754.380"><vh>findNext</vh></v>
</v>
<v t="ekr.20070626112754.581"><vh>Fixed memory error in leoBridge</vh>
<v t="ekr.20070626112754.582"><vh>es, enl, ecnl</vh></v>
</v>
<v t="ekr.20070626112754.583"><vh>Fixed backspace in headline bug</vh>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.87"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20070626112754.88"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.584"><vh>Make sure alt-arrow keys honor focus settings</vh>
<v t="ekr.20070626112754.585"><vh>Goto</vh>
<v t="ekr.20070626112754.586"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20070626112754.587"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20070626112754.588"><vh>goToFirstNode</vh></v>
<v t="ekr.20070626112754.589"><vh>goToFirstSibling</vh></v>
<v t="ekr.20070626112754.590"><vh>goToFirstVisibleNode</vh></v>
<v t="ekr.20070626112754.591"><vh>goToLastNode</vh></v>
<v t="ekr.20070626112754.592"><vh>goToLastSibling</vh></v>
<v t="ekr.20070626112754.593"><vh>c.goToLastVisibleNode</vh></v>
<v t="ekr.20070626112754.594"><vh>goToNextClone</vh></v>
<v t="ekr.20070626112754.595"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20070626112754.596"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20070626112754.597"><vh>goToNextSibling</vh></v>
<v t="ekr.20070626112754.598"><vh>goToParent</vh></v>
<v t="ekr.20070626112754.599"><vh>goToPrevSibling</vh></v>
<v t="ekr.20070626112754.600"><vh>selectThreadBack</vh></v>
<v t="ekr.20070626112754.601"><vh>selectThreadNext</vh></v>
<v t="ekr.20070626112754.602"><vh>selectVisBack</vh></v>
<v t="ekr.20070626112754.603"><vh>selectVisNext</vh></v>
<v t="ekr.20070626112754.604"><vh>utils</vh>
<v t="ekr.20070626112754.605"><vh> treeFocusHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.607"><vh>Commands (outline menu)</vh>
<v t="ekr.20070626112754.608"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20070626112754.609"><vh>contractNode</vh></v>
<v t="ekr.20070626112754.610"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20070626112754.611"><vh>contractParent</vh></v>
<v t="ekr.20070626112754.612"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20070626112754.613"><vh>expandAllSubheads</vh></v>
<v t="ekr.20070626112754.614"><vh>expandLevel1..9</vh></v>
<v t="ekr.20070626112754.615"><vh>expandNextLevel</vh></v>
<v t="ekr.20070626112754.616"><vh>expandNode</vh></v>
<v t="ekr.20070626112754.617"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20070626112754.618"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20070626112754.619"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20070626112754.620"><vh>Move... (Commands)</vh>
<v t="ekr.20070626112754.621"><vh>cantMoveMessage</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
<v t="ekr.20070626112754.623"><vh>moveOutlineDown</vh>
<v t="ekr.20070626112754.624"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.625"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20070626112754.626"><vh>moveOutlineRight</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.629"><vh>promote</vh></v>
</v>
<v t="ekr.20070626112754.630"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20070626112754.631"><vh>NewHeadline</vh></v>
<v t="ekr.20070626112754.632"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
</v>
<v t="ekr.20070626112754.633"><vh>Fixed bug in nav button plugin</vh></v>
<v t="ekr.20070626112754.634"><vh>Fixed yet another cursor down bug</vh>
<v t="ekr.20070626112754.218"><vh>move cursor... (leoEditCommands)</vh>
<v t="ekr.20070626112754.219"><vh> helpers</vh>
<v t="ekr.20070626112754.220"><vh>extendHelper</vh></v>
<v t="ekr.20070626112754.221"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20070626112754.222"><vh>moveToHelper</vh></v>
<v t="ekr.20070626112754.223"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20070626112754.224"><vh>moveWordHelper</vh></v>
<v t="ekr.20070626112754.225"><vh>backSentenceHelper</vh></v>
<v t="ekr.20070626112754.226"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20070626112754.227"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.228"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20070626112754.229"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20070626112754.230"><vh>buffers</vh></v>
<v t="ekr.20070626112754.231"><vh>characters</vh></v>
<v t="ekr.20070626112754.232"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20070626112754.233"><vh>exchangePointMark</vh></v>
<v t="ekr.20070626112754.234"><vh>extend-to-line</vh></v>
<v t="ekr.20070626112754.235"><vh>extend-to-sentence</vh></v>
<v t="ekr.20070626112754.236"><vh>extend-to-word</vh></v>
<v t="ekr.20070626112754.237"><vh>lines</vh></v>
<v t="ekr.20070626112754.238"><vh>movePastClose</vh></v>
<v t="ekr.20070626112754.239"><vh>paragraphs</vh></v>
<v t="ekr.20070626112754.240"><vh>sentences</vh></v>
<v t="ekr.20070626112754.241"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20070626112754.635"><vh>Improved special case in moveOutlineUp</vh>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.636"><vh>Fixed crasher in rclicker plugin</vh></v>
<v t="ekr.20070626112754.637"><vh>Fixed problem with settings report</vh>
<v t="ekr.20070626112754.638"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20070626112754.639"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.641"><vh>g.app.config.updateSettings</vh></v>
</v>
</v>
<v t="ekr.20070626112754.642"><vh>Investigated bugs (these work for me)</vh>
<v t="ekr.20070626112754.643"><vh>Fix bugs in @url nodes (works for me)</vh></v>
<v t="ekr.20070626112754.644"><vh>Fix slideshow/button problem (works for me)</vh>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20070626112754.646"><vh>Investigated @file nosent glitch (works for me)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.647"><vh>Features</vh>
<v t="ekr.20070626112754.648"><vh>Warn on dubious section brackets</vh>
<v t="ekr.20070626112754.649"><vh>hasSectionName</vh></v>
</v>
<v t="ekr.20070626112754.650"><vh>Added leoBridge module</vh>
<v t="ekr.20070626112754.651"><vh>log stuff</vh>
<v t="ekr.20070626112754.652"><vh>app.writeWaitingLog</vh></v>
<v t="ekr.20070626112754.582"><vh>es, enl, ecnl</vh></v>
<v t="ekr.20070626112754.653"><vh>put and putnl (nullLog)</vh></v>
</v>
<v t="ekr.20070626112754.654"><vh>functions</vh>
<v t="ekr.20070626112754.655"><vh>run &amp; allies</vh>
<v t="ekr.20070626112754.656"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.657"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20070626112754.658"><vh>adjustSysPath</vh></v>
<v t="ekr.20070626112754.659"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.661"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20070626112754.662"><vh>getBatchScript</vh></v>
<v t="ekr.20070626112754.663"><vh>isValidPython</vh></v>
<v t="ekr.20070626112754.664"><vh>reportDirectories</vh></v>
<v t="ekr.20070626112754.665"><vh>startPsyco</vh></v>
</v>
<v t="ekr.20070626112754.666"><vh>initLeo &amp; helpers</vh>
<v t="ekr.20070626112754.667"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.668"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20070626112754.669"><vh>adjustSysPath</vh></v>
<v t="ekr.20070626112754.670"><vh>createGui</vh></v>
<v t="ekr.20070626112754.671"><vh>isValidPython</vh></v>
<v t="ekr.20070626112754.672"><vh>getLeoID</vh>
<v t="ekr.20070626112754.673"><vh>&lt;&lt; try to get leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20070626112754.674"><vh>&lt;&lt; try to get leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20070626112754.675"><vh>&lt;&lt; try to get leoID from os.getenv('USER') &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.676"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
<v t="ekr.20070626112754.677"><vh>event_generate (baseTextWidget)</vh></v>
<v t="ekr.20070626112754.456"><vh>shortcutFromSetting (uses k.guiBindNamesDict)</vh>
<v t="ekr.20070626112754.457"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20070626112754.458"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20070626112754.459"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20070626112754.460"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20070626112754.461"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.678"><vh>classes</vh>
<v t="ekr.20070626112754.679"><vh>class baseTextWidget</vh>
<v t="ekr.20070626112754.680"><vh>Birth &amp; special methods (baseText)</vh></v>
<v t="ekr.20070626112754.681"><vh>baseTextWidget.onChar</vh></v>
<v t="ekr.20070626112754.682"><vh>Do-nothing</vh></v>
<v t="ekr.20070626112754.683"><vh>bindings (must be overridden in subclasses)</vh></v>
<v t="ekr.20070626112754.684"><vh>oops</vh></v>
<v t="ekr.20070626112754.685"><vh>Index conversion</vh>
<v t="ekr.20070626112754.686"><vh>w.toGuiIndex &amp; toPythonIndex</vh></v>
<v t="ekr.20070626112754.687"><vh>w.rowColToGuiIndex</vh></v>
</v>
<v t="ekr.20070626112754.688"><vh>Wrapper methods (widget-independent)</vh>
<v t="ekr.20070626112754.689"><vh>appendText</vh></v>
<v t="ekr.20070626112754.690"><vh>bind</vh></v>
<v t="ekr.20070626112754.691"><vh>clipboard_clear &amp; clipboard_append</vh></v>
<v t="ekr.20070626112754.692"><vh>delete</vh></v>
<v t="ekr.20070626112754.693"><vh>deleteTextSelection</vh></v>
<v t="ekr.20070626112754.677"><vh>event_generate (baseTextWidget)</vh></v>
<v t="ekr.20070626112754.694"><vh>flashCharacter (to do)</vh></v>
<v t="ekr.20070626112754.695"><vh>getFocus (baseText)</vh></v>
<v t="ekr.20070626112754.696"><vh>get</vh></v>
<v t="ekr.20070626112754.697"><vh>getAllText</vh></v>
<v t="ekr.20070626112754.698"><vh>getInsertPoint (baseText)</vh></v>
<v t="ekr.20070626112754.699"><vh>getName &amp; GetName</vh></v>
<v t="ekr.20070626112754.700"><vh>getSelectedText</vh></v>
<v t="ekr.20070626112754.701"><vh>getSelectionRange (baseText)</vh></v>
<v t="ekr.20070626112754.702"><vh>getYScrollPosition</vh></v>
<v t="ekr.20070626112754.703"><vh>getWidth</vh></v>
<v t="ekr.20070626112754.704"><vh>hasSelection</vh></v>
<v t="ekr.20070626112754.705"><vh>insert</vh></v>
<v t="ekr.20070626112754.706"><vh>indexIsVisible</vh></v>
<v t="ekr.20070626112754.707"><vh>replace</vh></v>
<v t="ekr.20070626112754.708"><vh>scrollLines</vh></v>
<v t="ekr.20070626112754.709"><vh>see &amp; seeInsertPoint</vh></v>
<v t="ekr.20070626112754.710"><vh>selectAllText</vh></v>
<v t="ekr.20070626112754.711"><vh>setAllText</vh></v>
<v t="ekr.20070626112754.712"><vh>setBackgroundColor &amp; SetBackgroundColour</vh></v>
<v t="ekr.20070626112754.713"><vh>setFocus (baseText)</vh></v>
<v t="ekr.20070626112754.714"><vh>setInsertPoint (baseText)</vh></v>
<v t="ekr.20070626112754.715"><vh>setSelectionRange (baseText)</vh></v>
<v t="ekr.20070626112754.716"><vh>setWidth</vh></v>
<v t="ekr.20070626112754.717"><vh>setYScrollPosition</vh></v>
<v t="ekr.20070626112754.718"><vh>tags (to-do)</vh>
<v t="ekr.20070626112754.719"><vh>mark_set (to be removed)</vh></v>
<v t="ekr.20070626112754.720"><vh>tag_add</vh></v>
<v t="ekr.20070626112754.721"><vh>tag_configure &amp; helper</vh>
<v t="ekr.20070626112754.722"><vh>tkColorToWxColor</vh></v>
</v>
<v t="ekr.20070626112754.723"><vh>tag_delete (NEW)</vh></v>
<v t="ekr.20070626112754.724"><vh>tag_names</vh></v>
<v t="ekr.20070626112754.725"><vh>tag_ranges</vh></v>
<v t="ekr.20070626112754.726"><vh>tag_remove</vh></v>
<v t="ekr.20070626112754.727"><vh>yview</vh></v>
</v>
<v t="ekr.20070626112754.728"><vh>xyToGui/PythonIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.399"><vh>class findTab (leoFind)</vh>
<v t="ekr.20070626112754.400"><vh>findTab.__init__</vh></v>
<v t="ekr.20070626112754.401"><vh>Must be defined in subclasses</vh></v>
<v t="ekr.20070626112754.402"><vh>Callbacks</vh>
<v t="ekr.20070626112754.403"><vh>findButtonCallback</vh></v>
<v t="ekr.20070626112754.404"><vh>hideTab</vh></v>
</v>
<v t="ekr.20070626112754.405"><vh> Top level</vh>
<v t="ekr.20070626112754.406"><vh>change/ThenFindCommand</vh></v>
<v t="ekr.20070626112754.407"><vh>changeAllCommand</vh></v>
<v t="ekr.20070626112754.408"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20070626112754.409"><vh>findAgainCommand</vh></v>
<v t="ekr.20070626112754.410"><vh>findAllCommand</vh></v>
<v t="ekr.20070626112754.411"><vh>findNext/PrefCommand</vh></v>
</v>
</v>
<v t="ekr.20070626112754.729"><vh>class leoBody</vh>
<v t="ekr.20070626112754.730"><vh>leoBody.__init__</vh>
<v t="ekr.20070626112754.731"><vh>leoBody.mustBeDefinedInSubclasses</vh></v>
<v t="ekr.20070626112754.732"><vh>define leoBody.mustBeDefinedOnlyInBaseClass</vh></v>
</v>
<v t="ekr.20070626112754.733"><vh>leoBody: must be defined in subclasses</vh></v>
<v t="ekr.20070626112754.734"><vh>leoBody: must be defined in the base class</vh>
<v t="ekr.20070626112754.735"><vh>Coloring</vh></v>
<v t="ekr.20070626112754.736"><vh>Editors (leoBody)</vh>
<v t="ekr.20070626112754.737"><vh>entries</vh>
<v t="ekr.20070626112754.738"><vh>addEditor</vh>
<v t="ekr.20070626112754.739"><vh>&lt;&lt; create text widget w &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.740"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20070626112754.741"><vh>deleteEditor</vh></v>
<v t="ekr.20070626112754.742"><vh>findEditorForChapter (leoBody)</vh></v>
<v t="ekr.20070626112754.743"><vh>select/unselectLabel</vh></v>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.744"><vh>assignPositionToEditor</vh></v>
<v t="ekr.20070626112754.745"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20070626112754.746"><vh>utils</vh>
<v t="ekr.20070626112754.747"><vh>computeLabel</vh></v>
<v t="ekr.20070626112754.748"><vh>createChapterIvar</vh></v>
<v t="ekr.20070626112754.749"><vh>ensurePositionExists</vh></v>
<v t="ekr.20070626112754.750"><vh>inactivateActiveEditor</vh></v>
<v t="ekr.20070626112754.751"><vh>recolorWidget</vh></v>
<v t="ekr.20070626112754.752"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20070626112754.753"><vh>updateInjectedIvars</vh></v>
</v>
</v>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.757"><vh>onClick</vh></v>
<v t="ekr.20070626112754.758"><vh>oops</vh></v>
<v t="ekr.20070626112754.759"><vh>Text (leoBody)</vh>
<v t="ekr.20070626112754.203"><vh>getInsertLines</vh></v>
<v t="ekr.20070626112754.760"><vh>getSelectionAreas</vh></v>
<v t="ekr.20070626112754.202"><vh>getSelectionLines</vh></v>
<v t="ekr.20070626112754.200"><vh>setSelectionAreas</vh></v>
<v t="ekr.20070626112754.761"><vh>get/setYScrollPosition</vh></v>
</v>
<v t="ekr.20070626112754.762"><vh>Text Wrappers (base class)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.763"><vh>class leoGui</vh>
<v t="ekr.20070626112754.764"><vh>&lt;&lt; define leoGui file types &gt;&gt; (not used yet)</vh></v>
<v t="ekr.20070626112754.765"><vh>app.gui Birth &amp; death</vh>
<v t="ekr.20070626112754.766"><vh> leoGui.__init__</vh></v>
<v t="ekr.20070626112754.767"><vh>leoGui.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20070626112754.768"><vh>leoGui.mustBeDefinedInSubclasses</vh></v>
</v>
<v t="ekr.20070626112754.769"><vh>Must be defined only in base class</vh>
<v t="ekr.20070626112754.770"><vh>guiName</vh></v>
<v t="ekr.20070626112754.771"><vh>setScript</vh></v>
</v>
<v t="ekr.20070626112754.772"><vh>Must be defined in subclasses</vh>
<v t="ekr.20070626112754.773"><vh>app.gui create &amp; destroy</vh>
<v t="ekr.20070626112754.774"><vh>createRootWindow</vh></v>
<v t="ekr.20070626112754.775"><vh>destroySelf</vh></v>
<v t="ekr.20070626112754.776"><vh>killGui</vh></v>
<v t="ekr.20070626112754.777"><vh>recreateRootWindow</vh></v>
<v t="ekr.20070626112754.778"><vh>runMainLoop</vh></v>
</v>
<v t="ekr.20070626112754.779"><vh>app.gui dialogs</vh></v>
<v t="ekr.20070626112754.780"><vh>app.gui.createKeyHandlerClass</vh></v>
<v t="ekr.20070626112754.781"><vh>app.gui file dialogs</vh></v>
<v t="ekr.20070626112754.782"><vh>app.gui panels</vh></v>
<v t="ekr.20070626112754.783"><vh>app.gui utils</vh>
<v t="ekr.20070626112754.784"><vh>Clipboard (leoGui)</vh></v>
<v t="ekr.20070626112754.785"><vh>color</vh></v>
<v t="ekr.20070626112754.786"><vh>Dialog utils</vh></v>
<v t="ekr.20070626112754.787"><vh>Events (leoGui)</vh></v>
<v t="ekr.20070626112754.788"><vh>getFullVersion</vh></v>
<v t="ekr.20070626112754.789"><vh>Focus</vh></v>
<v t="ekr.20070626112754.790"><vh>Font (leoGui)</vh></v>
<v t="ekr.20070626112754.791"><vh>Idle time</vh></v>
<v t="ekr.20070626112754.792"><vh>makeScriptButton</vh></v>
</v>
</v>
<v t="ekr.20070626112754.793"><vh>May be defined in subclasses</vh>
<v t="ekr.20070626112754.794"><vh>finishCreate (may be overridden in subclasses)</vh></v>
<v t="ekr.20070626112754.795"><vh>oops</vh></v>
<v t="ekr.20070626112754.796"><vh>widget_name (leoGui)</vh></v>
<v t="ekr.20070626112754.797"><vh>class leoKeyEvent (leoGui)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.798"><vh>class leoLog</vh>
<v t="ekr.20070626112754.799"><vh> ctor (leoLog)</vh></v>
<v t="ekr.20070626112754.800"><vh>Must be defined in the base class</vh></v>
<v t="ekr.20070626112754.801"><vh>May be overridden</vh>
<v t="ekr.20070626112754.802"><vh>clearTab</vh></v>
<v t="ekr.20070626112754.803"><vh>createTab</vh></v>
<v t="ekr.20070626112754.804"><vh>cycleTabFocus</vh></v>
<v t="ekr.20070626112754.805"><vh>deleteTab</vh></v>
<v t="ekr.20070626112754.806"><vh>hideTab</vh></v>
<v t="ekr.20070626112754.807"><vh>getSelectedTab</vh></v>
<v t="ekr.20070626112754.808"><vh>lower/raiseTab</vh></v>
<v t="ekr.20070626112754.809"><vh>numberOfVisibleTabs</vh></v>
<v t="ekr.20070626112754.810"><vh>renameTab</vh></v>
<v t="ekr.20070626112754.811"><vh>selectTab</vh></v>
</v>
<v t="ekr.20070626112754.812"><vh>Must be overridden</vh></v>
<v t="ekr.20070626112754.813"><vh>leoLog.oops</vh></v>
</v>
<v t="ekr.20070626112754.814"><vh>class leoTkinterLog</vh>
<v t="ekr.20070626112754.815"><vh>tkLog Birth</vh>
<v t="ekr.20070626112754.816"><vh>tkLog.__init__</vh></v>
<v t="ekr.20070626112754.817"><vh>tkLog.createControl</vh></v>
<v t="ekr.20070626112754.421"><vh>tkLog.finishCreate</vh></v>
<v t="ekr.20070626112754.818"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20070626112754.819"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20070626112754.820"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20070626112754.821"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20070626112754.822"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20070626112754.823"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20070626112754.824"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20070626112754.825"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20070626112754.826"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20070626112754.827"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20070626112754.828"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20070626112754.829"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20070626112754.830"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20070626112754.831"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20070626112754.832"><vh>put</vh>
<v t="ekr.20070626112754.833"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20070626112754.834"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.835"><vh>putnl</vh></v>
</v>
<v t="ekr.20070626112754.836"><vh>Tab (TkLog)</vh>
<v t="ekr.20070626112754.837"><vh>clearTab</vh></v>
<v t="ekr.20070626112754.838"><vh>createTab</vh>
<v t="ekr.20070626112754.839"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.840"><vh>cycleTabFocus</vh></v>
<v t="ekr.20070626112754.422"><vh>deleteTab</vh></v>
<v t="ekr.20070626112754.841"><vh>hideTab</vh></v>
<v t="ekr.20070626112754.842"><vh>getSelectedTab</vh></v>
<v t="ekr.20070626112754.843"><vh>lower/raiseTab</vh></v>
<v t="ekr.20070626112754.844"><vh>numberOfVisibleTabs</vh></v>
<v t="ekr.20070626112754.845"><vh>renameTab</vh></v>
<v t="ekr.20070626112754.846"><vh>selectTab</vh></v>
<v t="ekr.20070626112754.450"><vh>setTabBindings</vh></v>
<v t="ekr.20070626112754.847"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20070626112754.848"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20070626112754.849"><vh>newTabFromMenu</vh></v>
<v t="ekr.20070626112754.850"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20070626112754.851"><vh>getTabName</vh></v>
</v>
</v>
<v t="ekr.20070626112754.852"><vh>tkLog color tab stuff</vh>
<v t="ekr.20070626112754.853"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.854"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.855"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.856"><vh>tkLog font tab stuff</vh>
<v t="ekr.20070626112754.857"><vh>createFontPicker</vh>
<v t="ekr.20070626112754.858"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20070626112754.859"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.860"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20070626112754.861"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.862"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20070626112754.863"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20070626112754.864"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.865"><vh>createBindings (fontPicker)</vh></v>
<v t="ekr.20070626112754.866"><vh>getFont</vh></v>
<v t="ekr.20070626112754.867"><vh>setFont</vh></v>
<v t="ekr.20070626112754.868"><vh>hideFontTab</vh></v>
</v>
</v>
<v t="ekr.20070626112754.869"><vh>class nullBody (leoBody)</vh>
<v t="ekr.20070626112754.870"><vh> nullBody.__init__</vh></v>
<v t="ekr.20070626112754.871"><vh>Utils (internal use)</vh>
<v t="ekr.20070626112754.872"><vh>findStartOfLine</vh></v>
<v t="ekr.20070626112754.873"><vh>scanToStartOfLine</vh></v>
<v t="ekr.20070626112754.874"><vh>scanToEndOfLine</vh></v>
</v>
<v t="ekr.20070626112754.875"><vh>nullBody: leoBody interface</vh></v>
</v>
<v t="ekr.20070626112754.876"><vh>class nullFindTab class (findTab)</vh>
<v t="ekr.20070626112754.877"><vh>Birth (nullFindTab)</vh>
<v t="ekr.20070626112754.878"><vh> ctor (nullFindTab)</vh></v>
<v t="ekr.20070626112754.879"><vh>initGui</vh></v>
<v t="ekr.20070626112754.880"><vh>init</vh>
<v t="ekr.20070626112754.881"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20070626112754.882"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.883"><vh>&lt;&lt; set checkboxes from ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.884"><vh>createBindings</vh></v>
<v t="ekr.20070626112754.885"><vh>createFrame</vh>
<v t="ekr.20070626112754.886"><vh>createFindChangeAreas</vh></v>
<v t="ekr.20070626112754.887"><vh>createBoxes</vh></v>
<v t="ekr.20070626112754.888"><vh>createButtons (not used)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.889"><vh>class svar (nullFindTab)</vh></v>
<v t="ekr.20070626112754.890"><vh>class buttonWidget (nullFindTab)</vh></v>
<v t="ekr.20070626112754.891"><vh>Options</vh>
<v t="ekr.20070626112754.892"><vh>getOption</vh></v>
<v t="ekr.20070626112754.893"><vh>setOption</vh></v>
<v t="ekr.20070626112754.894"><vh>toggleOption</vh></v>
</v>
</v>
<v t="ekr.20070626112754.895"><vh>class nullFrame</vh>
<v t="ekr.20070626112754.896"><vh> ctor</vh></v>
<v t="ekr.20070626112754.897"><vh>destroySelf</vh></v>
<v t="ekr.20070626112754.898"><vh>finishCreate</vh></v>
<v t="ekr.20070626112754.899"><vh>Overrides</vh>
<v t="ekr.20070626112754.900"><vh>Config...</vh>
<v t="ekr.20070626112754.901"><vh>setTopGeometry</vh></v>
</v>
<v t="ekr.20070626112754.902"><vh>Gui-dependent commands</vh></v>
<v t="ekr.20070626112754.903"><vh>Window...</vh></v>
</v>
</v>
<v t="ekr.20070626112754.904"><vh>class nullGui (leoGui)</vh>
<v t="ekr.20070626112754.905"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.906"><vh> nullGui.__init__</vh></v>
<v t="ekr.20070626112754.907"><vh>nullGui.createKeyHandlerClass</vh></v>
<v t="ekr.20070626112754.908"><vh>runMainLoop</vh></v>
</v>
<v t="ekr.20070626112754.909"><vh>isTextWidget</vh></v>
<v t="ekr.20070626112754.910"><vh>oops</vh></v>
<v t="ekr.20070626112754.911"><vh>do nothings</vh></v>
<v t="ekr.20070626112754.912"><vh>app.gui panels</vh></v>
<v t="ekr.20070626112754.913"><vh>dialogs (nullGui)</vh></v>
<v t="ekr.20070626112754.914"><vh>simulateDialog</vh></v>
</v>
<v t="ekr.20070626112754.915"><vh>class nullLog</vh>
<v t="ekr.20070626112754.916"><vh>Birth</vh>
<v t="ekr.20070626112754.917"><vh>nullLog.__init__</vh></v>
<v t="ekr.20070626112754.918"><vh>createControl</vh></v>
<v t="ekr.20070626112754.919"><vh>createTextWidget</vh></v>
</v>
<v t="ekr.20070626112754.920"><vh>oops</vh></v>
<v t="ekr.20070626112754.653"><vh>put and putnl (nullLog)</vh></v>
<v t="ekr.20070626112754.921"><vh>tabs</vh></v>
</v>
<v t="ekr.20070626112754.922"><vh>class nullStatusLineClass</vh>
<v t="ekr.20070626112754.923"><vh> nullStatusLineClass.ctor</vh></v>
<v t="ekr.20070626112754.924"><vh>methods</vh></v>
</v>
<v t="ekr.20070626112754.925"><vh>class nullTree</vh>
<v t="ekr.20070626112754.926"><vh> nullTree.__init__</vh></v>
<v t="ekr.20070626112754.927"><vh>printWidgets</vh></v>
<v t="ekr.20070626112754.928"><vh>Overrides</vh>
<v t="ekr.20070626112754.929"><vh>Colors &amp; fonts</vh></v>
<v t="ekr.20070626112754.930"><vh>Drawing &amp; scrolling</vh></v>
<v t="ekr.20070626112754.931"><vh>Headlines</vh>
<v t="ekr.20070626112754.932"><vh>editLabel (nullTree) same as tkTree)</vh></v>
<v t="ekr.20070626112754.933"><vh>setHeadline (nullTree)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.934"><vh>class stringTextWidget (stringTextWidget)</vh>
<v t="ekr.20070626112754.935"><vh>ctor</vh></v>
<v t="ekr.20070626112754.936"><vh>Overrides</vh></v>
<v t="ekr.20070626112754.937"><vh>setSelectionRange (stringText)</vh></v>
</v>
<v t="ekr.20070626112754.938"><vh>class unitTestGui (nullGui)</vh>
<v t="ekr.20070626112754.939"><vh> ctor (unitTestGui)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.940"><vh>Added new search path for pluginsManager.txt</vh>
<v t="ekr.20070626112754.941"><vh>Request</vh></v>
<v t="ekr.20070626112754.424"><vh>loadHandlers &amp; helper</vh>
<v t="ekr.20070626112754.425"><vh>&lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;</vh></v>
<v t="ekr.20070626112754.426"><vh>getEnabledFiles</vh></v>
</v>
</v>
<v t="ekr.20070626112754.942"><vh>Added support for @enabled-plugins in settings files</vh>
<v t="ekr.20070626112754.943"><vh>Getters</vh></v>
<v t="ekr.20070626112754.944"><vh>Getters... (g.app.config)</vh>
<v t="ekr.20070626112754.945"><vh>canonicalizeSettingName (munge)</vh></v>
<v t="ekr.20070626112754.946"><vh>config.findSettingsPosition</vh></v>
<v t="ekr.20070626112754.947"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20070626112754.948"><vh>getValFromDict</vh></v>
<v t="ekr.20070626112754.949"><vh>typesMatch</vh></v>
</v>
<v t="ekr.20070626112754.950"><vh>exists (g.app.config)</vh></v>
<v t="ekr.20070626112754.951"><vh>getAbbrevDict</vh></v>
<v t="ekr.20070626112754.952"><vh>getBool</vh></v>
<v t="ekr.20070626112754.953"><vh>getColor</vh></v>
<v t="ekr.20070626112754.954"><vh>getDirectory</vh></v>
<v t="ekr.20070626112754.955"><vh>getEnabledPlugins</vh></v>
<v t="ekr.20070626112754.956"><vh>getFloat</vh></v>
<v t="ekr.20070626112754.957"><vh>getFontFromParams (config)</vh></v>
<v t="ekr.20070626112754.958"><vh>getInt</vh></v>
<v t="ekr.20070626112754.959"><vh>getLanguage</vh></v>
<v t="ekr.20070626112754.960"><vh>getOpenWith</vh></v>
<v t="ekr.20070626112754.961"><vh>getRatio</vh></v>
<v t="ekr.20070626112754.962"><vh>getRecentFiles</vh></v>
<v t="ekr.20070626112754.963"><vh>getShortcut (config)</vh></v>
<v t="ekr.20070626112754.964"><vh>getString</vh></v>
<v t="ekr.20070626112754.965"><vh>setCommandsIvars</vh></v>
<v t="ekr.20070626112754.966"><vh>settingsRoot</vh></v>
</v>
<v t="ekr.20070626112754.967"><vh>kind handlers (parserBaseClass)</vh>
<v t="ekr.20070626112754.968"><vh>doAbbrev</vh></v>
<v t="ekr.20070626112754.969"><vh>doBool</vh></v>
<v t="ekr.20070626112754.970"><vh>doColor</vh></v>
<v t="ekr.20070626112754.971"><vh>doDirectory &amp; doPath</vh></v>
<v t="ekr.20070626112754.972"><vh>doEnabledPlugins</vh></v>
<v t="ekr.20070626112754.973"><vh>doFloat</vh></v>
<v t="ekr.20070626112754.974"><vh>doFont</vh></v>
<v t="ekr.20070626112754.975"><vh>doIf</vh></v>
<v t="ekr.20070626112754.976"><vh>doIfGui</vh></v>
<v t="ekr.20070626112754.977"><vh>doIfPlatform</vh></v>
<v t="ekr.20070626112754.978"><vh>doIgnore</vh></v>
<v t="ekr.20070626112754.979"><vh>doInt</vh></v>
<v t="ekr.20070626112754.980"><vh>doInts</vh></v>
<v t="ekr.20070626112754.981"><vh>doMode (ParserBaseClass)</vh>
<v t="ekr.20070626112754.982"><vh>&lt;&lt; Compute modeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.983"><vh>doOpenWith (ParserBaseClass)</vh></v>
<v t="ekr.20070626112754.984"><vh>doPage</vh></v>
<v t="ekr.20070626112754.985"><vh>doRatio</vh></v>
<v t="ekr.20070626112754.986"><vh>doShortcuts (ParserBaseClass)</vh></v>
<v t="ekr.20070626112754.987"><vh>doString</vh></v>
<v t="ekr.20070626112754.988"><vh>doStrings</vh></v>
</v>
<v t="ekr.20070626112754.638"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20070626112754.639"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.641"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20070626112754.989"><vh>loadOnePlugin</vh></v>
<v t="ekr.20070626112754.655"><vh>run &amp; allies</vh>
<v t="ekr.20070626112754.656"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.657"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20070626112754.658"><vh>adjustSysPath</vh></v>
<v t="ekr.20070626112754.659"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.661"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20070626112754.662"><vh>getBatchScript</vh></v>
<v t="ekr.20070626112754.663"><vh>isValidPython</vh></v>
<v t="ekr.20070626112754.664"><vh>reportDirectories</vh></v>
<v t="ekr.20070626112754.665"><vh>startPsyco</vh></v>
</v>
<v t="ekr.20070626112754.972"><vh>doEnabledPlugins</vh></v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.991"><vh>doPlugins</vh></v>
<v t="ekr.20070626112754.424"><vh>loadHandlers &amp; helper</vh>
<v t="ekr.20070626112754.425"><vh>&lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;</vh></v>
<v t="ekr.20070626112754.426"><vh>getEnabledFiles</vh></v>
</v>
</v>
<v t="ekr.20070626112754.992"><vh>Made Leo's core gui-indenpendent)</vh>
<v t="ekr.20070626112754.993"><vh> Calls to w.xxx</vh>
<v t="ekr.20070626112754.994"><vh>find w.xxx script</vh></v>
<v t="ekr.20070626112754.995"><vh>Script results</vh></v>
</v>
<v t="ekr.20070626112754.996"><vh>What I did</vh>
<v t="ekr.20070626112754.997"><vh>Moved cut/copy/pasteText into base leoFrame class</vh>
<v t="ekr.20070626112754.998"><vh>Cut/Copy/Paste (leoFrame)</vh>
<v t="ekr.20070626112754.999"><vh>copyText</vh></v>
<v t="ekr.20070626112754.1000"><vh>leoFrame.cutText</vh></v>
<v t="ekr.20070626112754.1001"><vh>leoFrame.pasteText</vh></v>
<v t="ekr.20070626112754.1002"><vh>OnPaste (To support middle-button paste)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1003"><vh>Replaced leoTextWidgetClass by plainTextWidget or bodyTextWidget</vh></v>
<v t="ekr.20070626112754.1004"><vh>Removed w.configure &amp; w.cget from Leo's core</vh>
<v t="ekr.20070626112754.1001"><vh>leoFrame.pasteText</vh></v>
<v t="ekr.20070626112754.1000"><vh>leoFrame.cutText</vh></v>
<v t="ekr.20070626112754.1005"><vh>c.setHeadString</vh></v>
</v>
<v t="ekr.20070626112754.1006"><vh>Removed Tk code from minibufferFind class</vh>
<v t="ekr.20070626112754.306"><vh>class minibufferFind( (the findHandler)</vh>
<v t="ekr.20070626112754.307"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20070626112754.308"><vh> Options (minibufferFind)</vh>
<v t="ekr.20070626112754.309"><vh>setFindScope</vh></v>
<v t="ekr.20070626112754.310"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20070626112754.311"><vh>showFindOptions</vh></v>
<v t="ekr.20070626112754.312"><vh>setupChangePattern</vh></v>
<v t="ekr.20070626112754.313"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20070626112754.314"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20070626112754.315"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20070626112754.316"><vh>changeAll</vh></v>
<v t="ekr.20070626112754.317"><vh>cloneFindAll</vh></v>
<v t="ekr.20070626112754.318"><vh>findAgain</vh></v>
<v t="ekr.20070626112754.319"><vh>findAll</vh></v>
<v t="ekr.20070626112754.320"><vh>generalChangeHelper</vh></v>
<v t="ekr.20070626112754.321"><vh>generalSearchHelper</vh></v>
<v t="ekr.20070626112754.322"><vh>lastStateHelper</vh></v>
<v t="ekr.20070626112754.323"><vh>replaceString</vh></v>
<v t="ekr.20070626112754.324"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20070626112754.325"><vh>seachForward/Backward</vh></v>
<v t="ekr.20070626112754.326"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20070626112754.327"><vh>setupArgs</vh></v>
<v t="ekr.20070626112754.328"><vh>stateZeroHelper</vh></v>
<v t="ekr.20070626112754.329"><vh>updateChange/FindList</vh></v>
<v t="ekr.20070626112754.330"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20070626112754.1007"><vh>Support for minibufferFind class (tkFindTab)</vh>
<v t="ekr.20070626112754.1008"><vh>getOption</vh></v>
<v t="ekr.20070626112754.1009"><vh>setOption</vh></v>
<v t="ekr.20070626112754.1010"><vh>toggleOption</vh></v>
</v>
<v t="ekr.20070626112754.308"><vh> Options (minibufferFind)</vh>
<v t="ekr.20070626112754.309"><vh>setFindScope</vh></v>
<v t="ekr.20070626112754.310"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20070626112754.311"><vh>showFindOptions</vh></v>
<v t="ekr.20070626112754.312"><vh>setupChangePattern</vh></v>
<v t="ekr.20070626112754.313"><vh>setupSearchPattern</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1011"><vh>Moved Tk color code into tkLog</vh>
<v t="ekr.20070626112754.1012"><vh>show-colors</vh></v>
<v t="ekr.20070626112754.852"><vh>tkLog color tab stuff</vh>
<v t="ekr.20070626112754.853"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.854"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
<v t="ekr.20070626112754.855"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1013"><vh>Moved Tk font code into tkLog</vh>
<v t="ekr.20070626112754.1014"><vh>editCommands.show-fonts &amp; helpers</vh></v>
<v t="ekr.20070626112754.856"><vh>tkLog font tab stuff</vh>
<v t="ekr.20070626112754.857"><vh>createFontPicker</vh>
<v t="ekr.20070626112754.858"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20070626112754.859"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.860"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20070626112754.861"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20070626112754.862"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20070626112754.863"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20070626112754.864"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.865"><vh>createBindings (fontPicker)</vh></v>
<v t="ekr.20070626112754.866"><vh>getFont</vh></v>
<v t="ekr.20070626112754.867"><vh>setFont</vh></v>
<v t="ekr.20070626112754.868"><vh>hideFontTab</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1015"><vh>Refactored tk spell code tkSpellTab</vh>
<v t="ekr.20070626112754.1016"><vh>tkGui.createSpellTab</vh></v>
<v t="ekr.20070626112754.413"><vh>openSpellTab</vh>
<v t="ekr.20070626112754.414"><vh>commands...</vh></v>
</v>
<v t="ekr.20070626112754.1017"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20070626112754.1018"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1019"><vh>spellTabHandler.__init__</vh></v>
<v t="ekr.20070626112754.1020"><vh>init_aspell</vh></v>
<v t="ekr.20070626112754.1021"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20070626112754.1022"><vh>Commands</vh>
<v t="ekr.20070626112754.1023"><vh>add</vh></v>
<v t="ekr.20070626112754.1024"><vh>change (spellTab)</vh></v>
<v t="ekr.20070626112754.1025"><vh>find &amp; helpers</vh>
<v t="ekr.20070626112754.1026"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070626112754.1027"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1028"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20070626112754.1029"><vh>hide</vh></v>
<v t="ekr.20070626112754.1030"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1031"><vh>class tkSpellTab</vh>
<v t="ekr.20070626112754.1032"><vh>tkSpellTab.__init__</vh></v>
<v t="ekr.20070626112754.1033"><vh>createBindings</vh></v>
<v t="ekr.20070626112754.1034"><vh>createFrame</vh>
<v t="ekr.20070626112754.1035"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1036"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1037"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1038"><vh>Event handlers</vh>
<v t="ekr.20070626112754.1039"><vh>onAddButton</vh></v>
<v t="ekr.20070626112754.1040"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20070626112754.1041"><vh>onFindButton</vh></v>
<v t="ekr.20070626112754.1042"><vh>onHideButton</vh></v>
<v t="ekr.20070626112754.1043"><vh>onIgnoreButton</vh></v>
<v t="ekr.20070626112754.1044"><vh>onMap</vh></v>
<v t="ekr.20070626112754.1045"><vh>onSelectListBox</vh></v>
</v>
<v t="ekr.20070626112754.1046"><vh>Helpers</vh>
<v t="ekr.20070626112754.1047"><vh>bringToFront</vh></v>
<v t="ekr.20070626112754.1048"><vh>fillbox</vh></v>
<v t="ekr.20070626112754.1049"><vh>getSuggestion</vh></v>
<v t="ekr.20070626112754.1050"><vh>update</vh></v>
<v t="ekr.20070626112754.1051"><vh>updateButtons (spellTab)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1052"><vh>Replaced w.clipboard* by gui methods</vh>
<v t="ekr.20070626112754.784"><vh>Clipboard (leoGui)</vh></v>
<v t="ekr.20070626112754.1053"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20070626112754.1054"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20070626112754.1055"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20070626112754.27"><vh>kill, killLine</vh></v>
<v t="ekr.20070626112754.28"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
</v>
<v t="ekr.20070626112754.1056"><vh>Replaced tkFileDialog by gui.runOpenFileDialog</vh>
<v t="ekr.20070626112754.1057"><vh>readAbbreviations</vh></v>
<v t="ekr.20070626112754.1058"><vh>writeAbbreviations</vh></v>
<v t="ekr.20070626112754.1059"><vh>getReadableTextFile</vh></v>
<v t="ekr.20070626112754.1060"><vh>loadFile &amp; helpers</vh>
<v t="ekr.20070626112754.1061"><vh>_loadMacros</vh></v>
</v>
<v t="ekr.20070626112754.1062"><vh>saveFile</vh></v>
<v t="ekr.20070626112754.1063"><vh>saveMacros &amp; helper</vh>
<v t="ekr.20070626112754.1064"><vh>_saveMacros</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1065"><vh>Removed references to Tk and  Pmw from Leo's core</vh>
<v t="ekr.20070626112754.1066"><vh>_executeMacro (test)</vh></v>
<v t="ekr.20070626112754.1067"><vh>c.signOnWithVersion</vh></v>
<v t="ekr.20070626112754.1068"><vh>getFullVersion</vh></v>
<v t="ekr.20070626112754.1069"><vh>g.createStandAloneTkApp</vh></v>
<v t="ekr.20070626112754.1070"><vh>cantImportDialog &amp; helpers</vh>
<v t="ekr.20070626112754.1071"><vh>createDialogFrame</vh></v>
<v t="ekr.20070626112754.1072"><vh>createDialogButtons</vh></v>
<v t="ekr.20070626112754.1073"><vh>center</vh></v>
<v t="ekr.20070626112754.1074"><vh>get_window_info</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1075"><vh>class leoTkTextWidget (Tk.Text)</vh>
<v t="ekr.20070626112754.1076"><vh>plainTextWidget.__init__</vh></v>
<v t="ekr.20070626112754.1077"><vh>bindings (not used)</vh></v>
<v t="ekr.20070626112754.63"><vh>Index conversion (leoTextWidget)</vh>
<v t="ekr.20070626112754.64"><vh>w.toGuiIndex</vh></v>
<v t="ekr.20070626112754.65"><vh>w.toPythonIndex</vh></v>
<v t="ekr.20070626112754.66"><vh>w.rowColToGuiIndex</vh></v>
</v>
<v t="ekr.20070626112754.1078"><vh>getName (Tk.Text)</vh></v>
<v t="ekr.20070626112754.1079"><vh>_setSelectionRange</vh></v>
<v t="ekr.20070626112754.1080"><vh>Wrapper methods (leoTextWidget)</vh>
<v t="ekr.20070626112754.1081"><vh>delete</vh></v>
<v t="ekr.20070626112754.82"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.1082"><vh>get</vh></v>
<v t="ekr.20070626112754.1083"><vh>getAllText</vh></v>
<v t="ekr.20070626112754.1084"><vh>getInsertPoint</vh></v>
<v t="ekr.20070626112754.1085"><vh>getSelectedText</vh></v>
<v t="ekr.20070626112754.1086"><vh>getSelectionRange</vh></v>
<v t="ekr.20070626112754.1087"><vh>getYScrollPosition</vh></v>
<v t="ekr.20070626112754.1088"><vh>getWidth</vh></v>
<v t="ekr.20070626112754.1089"><vh>hasSelection</vh></v>
<v t="ekr.20070626112754.1090"><vh>insert</vh></v>
<v t="ekr.20070626112754.1091"><vh>indexIsVisible</vh></v>
<v t="ekr.20070626112754.1092"><vh>mark_set NO LONGER USED</vh></v>
<v t="ekr.20070626112754.1093"><vh>replace</vh></v>
<v t="ekr.20070626112754.1094"><vh>see</vh></v>
<v t="ekr.20070626112754.1095"><vh>seeInsertPoint</vh></v>
<v t="ekr.20070626112754.269"><vh>selectAllText</vh></v>
<v t="ekr.20070626112754.1096"><vh>setAllText</vh></v>
<v t="ekr.20070626112754.1097"><vh>setBackgroundColor</vh></v>
<v t="ekr.20070626112754.61"><vh>setInsertPoint</vh></v>
<v t="ekr.20070626112754.62"><vh>setSelectionRange</vh></v>
<v t="ekr.20070626112754.1098"><vh>setYScrollPosition</vh></v>
<v t="ekr.20070626112754.1099"><vh>setWidth</vh></v>
<v t="ekr.20070626112754.250"><vh>tag_add</vh></v>
<v t="ekr.20070626112754.1100"><vh>tag_ranges</vh></v>
<v t="ekr.20070626112754.1101"><vh>tag_remove</vh></v>
<v t="ekr.20070626112754.1102"><vh>w.deleteTextSelection</vh></v>
<v t="ekr.20070626112754.1103"><vh>xyToGui/PythonIndex</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1104"><vh>Next</vh>
<v t="ekr.20070626112754.1105"><vh> Create unit tests 17</vh>
<v t="ekr.20070626112754.1106"><vh>moveLinesUp</vh></v>
<v t="ekr.20070626112754.1107"><vh>moveLinesDown</vh></v>
<v t="ekr.20070626112754.1108"><vh>fillRegion</vh></v>
<v t="ekr.20070626112754.1109"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20070626112754.1025"><vh>find &amp; helpers</vh>
<v t="ekr.20070626112754.1026"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070626112754.1027"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1028"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20070626112754.1110"><vh>findCharacterHelper</vh></v>
<v t="ekr.20070626112754.1111"><vh>getRectanglePoints</vh></v>
<v t="ekr.20070626112754.1112"><vh>lineNumber</vh></v>
<v t="ekr.20070626112754.1113"><vh>measure</vh></v>
<v t="ekr.20070626112754.1114"><vh>setCommentColumn</vh></v>
<v t="ekr.20070626112754.1115"><vh>shellCommandOnRegion</vh></v>
<v t="ekr.20070626112754.1116"><vh>sortFields</vh></v>
<v t="ekr.20070626112754.1117"><vh>swapWords</vh></v>
<v t="ekr.20070626112754.1118"><vh>whatLine</vh></v>
<v t="ekr.20070626112754.761"><vh>get/setYScrollPosition</vh></v>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1119"><vh>Unit tests for menu enablers</vh></v>
</v>
<v t="ekr.20070626112754.1120"><vh>Remove Tk code from commands (later)</vh>
<v t="ekr.20070626112754.1121"><vh>class autoCompleterClass</vh>
<v t="ekr.20070626112754.1122"><vh> ctor (autocompleter)</vh>
<v t="ekr.20070626112754.1123"><vh>defineClassesDict</vh></v>
<v t="ekr.20070626112754.1124"><vh>defineObjectDict</vh></v>
</v>
<v t="ekr.20070626112754.1125"><vh>Top level</vh>
<v t="ekr.20070626112754.1126"><vh>autoComplete</vh></v>
<v t="ekr.20070626112754.1127"><vh>autoCompleteForce</vh></v>
<v t="ekr.20070626112754.1128"><vh>autoCompleterStateHandler</vh></v>
<v t="ekr.20070626112754.1129"><vh>enable/disable/toggleAutocompleter/Calltips</vh></v>
<v t="ekr.20070626112754.1130"><vh>showCalltips</vh></v>
<v t="ekr.20070626112754.1131"><vh>showCalltipsForce</vh></v>
<v t="ekr.20070626112754.1132"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20070626112754.1133"><vh>Helpers</vh>
<v t="ekr.20070626112754.1134"><vh>.abort &amp; exit (autocompleter) (test)</vh></v>
<v t="ekr.20070626112754.1135"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20070626112754.1136"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20070626112754.1137"><vh>calltip</vh>
<v t="ekr.20070626112754.1138"><vh>&lt;&lt; try to set s from a Python global function &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1139"><vh>&lt;&lt; get s using inspect &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1140"><vh>&lt;&lt; remove 'self' from s, but not from args &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1141"><vh>&lt;&lt; remove 's' from s *and* args &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1142"><vh>&lt;&lt; insert the text and set j1 and j2 &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1143"><vh>&lt;&lt; put the status line &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1144"><vh>chain</vh></v>
<v t="ekr.20070626112754.1145"><vh>computeCompletionList</vh></v>
<v t="ekr.20070626112754.1146"><vh>doBackSpace (autocompleter)</vh></v>
<v t="ekr.20070626112754.1147"><vh>doTabCompletion (autocompleter)</vh></v>
<v t="ekr.20070626112754.1148"><vh>extendSelection</vh></v>
<v t="ekr.20070626112754.1149"><vh>findAnchor</vh></v>
<v t="ekr.20070626112754.1150"><vh>findCalltipWord</vh></v>
<v t="ekr.20070626112754.1151"><vh>finish</vh></v>
<v t="ekr.20070626112754.1152"><vh>getAttr and hasAttr</vh></v>
<v t="ekr.20070626112754.1153"><vh>getLeadinWord</vh></v>
<v t="ekr.20070626112754.1154"><vh>getMembersList</vh></v>
<v t="ekr.20070626112754.1155"><vh>info</vh></v>
<v t="ekr.20070626112754.1156"><vh>insertNormalChar</vh></v>
<v t="ekr.20070626112754.1157"><vh>push, pop, clear, stackNames</vh></v>
<v t="ekr.20070626112754.1158"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20070626112754.1159"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20070626112754.1160"><vh>completeSelf</vh></v>
<v t="ekr.20070626112754.1161"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20070626112754.1162"><vh>setSelection</vh></v>
<v t="ekr.20070626112754.1163"><vh>start</vh></v>
</v>
<v t="ekr.20070626112754.1164"><vh>Scanning</vh>
<v t="ekr.20070626112754.1165"><vh>initialScan</vh></v>
<v t="ekr.20070626112754.1166"><vh>scan</vh></v>
<v t="ekr.20070626112754.1167"><vh>definePatterns</vh></v>
<v t="ekr.20070626112754.1168"><vh>scanOutline</vh></v>
<v t="ekr.20070626112754.1169"><vh>scanForCallTip</vh></v>
<v t="ekr.20070626112754.1170"><vh>scanForAutoCompleter</vh>
<v t="ekr.20070626112754.1171"><vh>makeAutocompletionList</vh>
<v t="ekr.20070626112754.1172"><vh>reverseFindWhitespace</vh></v>
<v t="ekr.20070626112754.1173"><vh>getCleanString</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1174"><vh>Proxy classes and objects</vh>
<v t="ekr.20070626112754.1175"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20070626112754.1176"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20070626112754.1177"><vh>class forgivingParserClass</vh>
<v t="ekr.20070626112754.1178"><vh>ctor (forgivingParserClass)</vh></v>
<v t="ekr.20070626112754.1179"><vh>parse</vh></v>
<v t="ekr.20070626112754.1180"><vh>forgivingParser</vh></v>
<v t="ekr.20070626112754.1181"><vh>computeErrorNode</vh></v>
<v t="ekr.20070626112754.1182"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20070626112754.1183"><vh>class classScannerClass</vh>
<v t="ekr.20070626112754.1184"><vh>ctor</vh></v>
<v t="ekr.20070626112754.1185"><vh>scan</vh></v>
<v t="ekr.20070626112754.1186"><vh>findParentClass</vh></v>
<v t="ekr.20070626112754.1187"><vh>findClass &amp; helpers</vh>
<v t="ekr.20070626112754.1188"><vh>endsDoc</vh></v>
<v t="ekr.20070626112754.1189"><vh>startsClass</vh></v>
<v t="ekr.20070626112754.1190"><vh>startsDoc</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1191"><vh>dynamicExpansion</vh>
<v t="ekr.20070626112754.1192"><vh>dynamicExpandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1193"><vh>dynamicCompletion</vh></v>
<v t="ekr.20070626112754.1194"><vh>executeSubprocess</vh></v>
<v t="ekr.20070626112754.1195"><vh>insertRegister</vh></v>
<v t="ekr.20070626112754.1196"><vh>insertToBuffer</vh></v>
<v t="ekr.20070626112754.1197"><vh>prependToBuffer</vh></v>
<v t="ekr.20070626112754.1198"><vh>doOneReplace</vh></v>
<v t="ekr.20070626112754.1199"><vh>findNextMatch (query-replace)</vh>
<v t="ekr.20070626112754.1200"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1201"><vh>&lt;&lt; handle plain search &gt;&gt; (tag_add &amp; tag_config) LATER</vh></v>
</v>
<v t="ekr.20070626112754.1202"><vh>regionalExpandAbbrev (TK code)</vh>
<v t="ekr.20070626112754.1203"><vh>&lt;&lt; define a new generator searchXR &gt;&gt; LATER</vh></v>
</v>
<v t="ekr.20070626112754.345"><vh>scolorizer LATER</vh></v>
<v t="ekr.20070626112754.1204"><vh>sort...</vh>
<v t="ekr.20070626112754.1205"><vh>sortLines</vh></v>
<v t="ekr.20070626112754.1206"><vh>sortColumns</vh></v>
<v t="ekr.20070626112754.1116"><vh>sortFields</vh></v>
</v>
<v t="ekr.20070626112754.32"><vh>yankPop</vh></v>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1207"><vh>Maybe never</vh>
<v t="ekr.20070626112754.1208"><vh>Font stuff in colorizer (maybe never)</vh>
<v t="ekr.20070626112754.1209"><vh>setFontFromConfig (colorizer)</vh></v>
</v>
<v t="ekr.20070626112754.1210"><vh>removeAllImages (leoColor)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1211"><vh>Testing key code in wxGui plugin</vh>
<v t="ekr.20070626112754.1212"><vh>createMenuEntries</vh>
<v t="ekr.20070626112754.1213"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1214"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20070626112754.1215"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1216"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1217"><vh>Dispatching (keyHandler)</vh>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.297"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20070626112754.298"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20070626112754.1218"><vh>endCommand</vh></v>
</v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.244"><vh>head key handlers (leoTree)</vh>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.247"><vh>onHeadlineKey</vh></v>
<v t="ekr.20070626112754.99"><vh>updateHead</vh></v>
<v t="ekr.20070626112754.248"><vh>endEditLabel</vh></v>
</v>
<v t="ekr.20070626112754.1219"><vh>Events (tkGui)</vh></v>
<v t="ekr.20070626112754.1220"><vh>manufactureKeyPressForCommandName</vh></v>
<v t="ekr.20070626112754.73"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20070626112754.74"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.75"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20070626112754.76"><vh>initBracketMatcher</vh></v>
<v t="ekr.20070626112754.77"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20070626112754.78"><vh>flashCharacter</vh></v>
<v t="ekr.20070626112754.79"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20070626112754.80"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20070626112754.81"><vh>updateTab</vh></v>
</v>
<v t="ekr.20070626112754.1001"><vh>leoFrame.pasteText</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.630"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20070626112754.1221"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.1222"><vh>masterClickHandler</vh></v>
<v t="ekr.20070626112754.1223"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20070626112754.1224"><vh>masterMenuHandler</vh></v>
</v>
<v t="ekr.20070626112754.1225"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20070626112754.1226"><vh>tree.editLabel</vh></v>
<v t="ekr.20070626112754.97"><vh>setEditLabelState</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1227"><vh>Leo 4.4.3 b1 projects</vh>
<v t="ekr.20070626112754.1228"><vh>New features</vh>
<v t="ekr.20070626112754.1229"><vh>Added @bool force_newlines_in_at_nosent_bodies setting</vh>
<v t="ekr.20070626112754.1230"><vh>putBody</vh>
<v t="ekr.20070626112754.1231"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1232"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1233"><vh>putCodeLine</vh></v>
</v>
<v t="ekr.20070626112754.1234"><vh>Added apropos-debugging-commands command</vh></v>
<v t="ekr.20070626112754.1235"><vh>Added print-plugins &amp; print-plugin-handlers commands</vh>
<v t="ekr.20070626112754.1236"><vh>printPlugins</vh></v>
</v>
<v t="ekr.20070626112754.1237"><vh>Added print-settings command</vh>
<v t="ekr.20070626112754.1238"><vh>g.app.config.printSettings &amp; helper</vh>
<v t="ekr.20070626112754.1239"><vh>printSettingsHelper</vh>
<v t="ekr.20070626112754.1240"><vh>&lt;&lt; set letter &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1241"><vh>Added support for @openwith nodes</vh>
<v t="ekr.20070626112754.1242"><vh>request</vh></v>
<v t="ekr.20070626112754.1243"><vh>Config stuff</vh>
<v t="ekr.20070626112754.947"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20070626112754.948"><vh>getValFromDict</vh></v>
<v t="ekr.20070626112754.949"><vh>typesMatch</vh></v>
</v>
<v t="ekr.20070626112754.1244"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20070626112754.960"><vh>getOpenWith</vh></v>
<v t="ekr.20070626112754.983"><vh>doOpenWith (ParserBaseClass)</vh></v>
<v t="ekr.20070626112754.1245"><vh>parseOpenWith &amp; helper</vh>
<v t="ekr.20070626112754.1246"><vh>parseOpenWithLine</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1247"><vh>openWith and allies</vh>
<v t="ekr.20070626112754.1248"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1249"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20070626112754.1250"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1251"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20070626112754.1252"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1253"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1254"><vh>createOpenWithTempFile</vh>
<v t="ekr.20070626112754.1255"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1256"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20070626112754.1257"><vh>createOpenWithMenuFromTable &amp; helper</vh>
<v t="ekr.20070626112754.1258"><vh>createOpenWithMenuItemsFromTable</vh>
<v t="ekr.20070626112754.1259"><vh>&lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1260"><vh>bindOpenWith</vh></v>
</v>
<v t="ekr.20070626112754.1261"><vh>Created clean-all-lines command</vh>
<v t="ekr.20070626112754.1262"><vh>cleanAllLines</vh></v>
<v t="ekr.20070626112754.1263"><vh>cleanLines</vh></v>
</v>
<v t="ekr.20070626112754.1264"><vh>Support for compressed .leo files</vh>
<v t="ekr.20070626112754.1265"><vh>What I did</vh></v>
<v t="ekr.20070626112754.1266"><vh>Request 1</vh></v>
<v t="ekr.20070626112754.1267"><vh>Request 2</vh></v>
<v t="ekr.20070626112754.1268"><vh>open (leoFileCommands)</vh>
<v t="ekr.20070626112754.1269"><vh>&lt;&lt; read the entire file into the buffer &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1270"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.1271"><vh>g.openLeoOrZipFile</vh></v>
<v t="ekr.20070626112754.1272"><vh>top level (file menu)</vh>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
<v t="ekr.20070626112754.1274"><vh>open</vh>
<v t="ekr.20070626112754.1275"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1247"><vh>openWith and allies</vh>
<v t="ekr.20070626112754.1248"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1249"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20070626112754.1250"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1251"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20070626112754.1252"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1253"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1254"><vh>createOpenWithTempFile</vh>
<v t="ekr.20070626112754.1255"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1256"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20070626112754.1276"><vh>close</vh></v>
<v t="ekr.20070626112754.1277"><vh>save (commands)</vh></v>
<v t="ekr.20070626112754.1278"><vh>saveAs</vh></v>
<v t="ekr.20070626112754.1279"><vh>saveAsUnzipped &amp; saveAsZipped</vh></v>
<v t="ekr.20070626112754.1280"><vh>saveTo</vh></v>
<v t="ekr.20070626112754.1281"><vh>revert</vh></v>
</v>
<v t="ekr.20070626112754.1282"><vh>Top-level  (leoFileCommands)</vh>
<v t="ekr.20070626112754.1283"><vh>save (fileCommands)</vh></v>
<v t="ekr.20070626112754.1284"><vh>saveAs</vh></v>
<v t="ekr.20070626112754.1285"><vh>saveTo</vh></v>
<v t="ekr.20070626112754.1286"><vh>putSavedMessage</vh></v>
</v>
<v t="ekr.20070626112754.1287"><vh>write_Leo_file</vh>
<v t="ekr.20070626112754.1288"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1289"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1290"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1291"><vh>&lt;&lt; ensure that filename ends with .opml &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1292"><vh>&lt;&lt; create theActualFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1293"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1294"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1295"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1296"><vh>writeZipFile</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1297"><vh>Fixed bugs</vh>
<v t="ekr.20070626112754.1298"><vh>Fixed bug: new-file doesn't allow edit of initial headline</vh>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
<v t="ekr.20070626112754.1226"><vh>tree.editLabel</vh></v>
</v>
<v t="ekr.20070626112754.1299"><vh>Removed all returns from finally clauses</vh>
<v t="ekr.20070626112754.662"><vh>getBatchScript</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.1179"><vh>parse</vh></v>
<v t="ekr.20070626112754.50"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1300"><vh>Fixed crashes when trying to import aspell</vh>
<v t="ekr.20070626112754.1301"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1302"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1303"><vh>getAspell</vh></v>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1306"><vh>Fixed repeatComplexCommand weirdness</vh>
<v t="ekr.20070626112754.1307"><vh>repeatComplexCommand &amp; helper</vh></v>
<v t="ekr.20070626112754.1308"><vh>keyboardQuit</vh></v>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1309"><vh>setState</vh></v>
<v t="ekr.20070626112754.797"><vh>class leoKeyEvent (leoGui)</vh></v>
</v>
<v t="ekr.20070626112754.1310"><vh>Improved widget allocation in trees</vh>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.1311"><vh>tt.createTab</vh></v>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1313"><vh>tt.selectTab</vh></v>
<v t="ekr.20070626112754.1314"><vh>destroyAllObjects</vh>
<v t="ekr.20070626112754.1315"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1316"><vh>initing g.app.ivars</vh>
<v t="ekr.20070626112754.1317"><vh>setIvarsFromSettings (g.app.config)</vh></v>
<v t="ekr.20070626112754.638"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20070626112754.639"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.641"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20070626112754.303"><vh>g.getBaseDirectory</vh></v>
<v t="ekr.20070626112754.1318"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20070626112754.1319"><vh>Found: makeAllNonExistentDirectories</vh>
<v t="ekr.20070626112754.1320"><vh>atFile.rename &amp; test</vh>
<v t="ekr.20070626112754.1321"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1322"><vh>@tesst atFile_rename</vh></v>
</v>
<v t="ekr.20070626112754.1323"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20070626112754.1324"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1325"><vh>&lt;&lt; Set path from @file node &gt;&gt; in scanDirectory in leoGlobals.py</vh></v>
<v t="ekr.20070626112754.1326"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20070626112754.1327"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1328"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1329"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1330"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1331"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1332"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1333"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1334"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1335"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1336"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1337"><vh>atFile.scanDefaultDirectory</vh>
<v t="ekr.20070626112754.1338"><vh>&lt;&lt; Set path from @file node &gt;&gt;  in df.scanDeafaultDirectory in leoAtFile.py</vh></v>
<v t="ekr.20070626112754.1339"><vh>&lt;&lt; handle @path &gt;&gt; in df.scanDeafaultDirectory in leoAtFile.py</vh>
<v t="ekr.20070626112754.1340"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1341"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1342"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1343"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20070626112754.1344"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1345"><vh>@test g.utils_rename</vh></v>
</v>
<v t="ekr.20070626112754.1346"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20070626112754.1347"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1348"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1349"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1350"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1351"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1352"><vh>&lt;&lt; Test for @path &gt;&gt; in tangleScanAllDirectives</vh>
<v t="ekr.20070626112754.1353"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1354"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1355"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1356"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1357"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1358"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1359"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="ekr.20070626112754.1360"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1361"><vh>Found: utils_rename</vh>
<v t="ekr.20070626112754.1287"><vh>write_Leo_file</vh>
<v t="ekr.20070626112754.1288"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1289"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1290"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1291"><vh>&lt;&lt; ensure that filename ends with .opml &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1292"><vh>&lt;&lt; create theActualFile &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1293"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1294"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1295"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1296"><vh>writeZipFile</vh></v>
</v>
<v t="ekr.20070626112754.1362"><vh>g.update_file_if_changed</vh></v>
<v t="ekr.20070626112754.1343"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20070626112754.1344"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1345"><vh>@test g.utils_rename</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1363"><vh>Fixed crash when deleting a chapter</vh>
<v t="ekr.20070626112754.1364"><vh>f.createTkTreeCanvas &amp; callbacks</vh>
<v t="ekr.20070626112754.1365"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1366"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1367"><vh>Scrolling callbacks (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1368"><vh>Fixed minor chapter hoist bug</vh>
<v t="ekr.20070626112754.1369"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
</v>
<v t="ekr.20070626112754.1370"><vh>Fixed crasher in plugins_menu.py</vh></v>
<v t="ekr.20070626112754.1371"><vh>error writing file with newly-created @chapters node</vh>
<v t="ekr.20070626112754.1372"><vh>putVnodes &amp; helpers</vh>
<v t="ekr.20070626112754.1373"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20070626112754.1374"><vh>&lt;&lt; Set gnx = tnode index &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1375"><vh>&lt;&lt; Append attribute bits to attrs &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1376"><vh>&lt;&lt; Append tnodeList and unKnownAttributes to attrs&gt;&gt;</vh></v>
<v t="ekr.20070626112754.1377"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1378"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20070626112754.1379"><vh>putDescendentAttributes</vh></v>
<v t="ekr.20070626112754.1380"><vh>putDescendentUnknownAttributes</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1381"><vh>Fixed chapter-save code when clicking on window's close box</vh>
<v t="ekr.20070626112754.1382"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20070626112754.1383"><vh>promptForSave</vh>
<v t="ekr.20070626112754.1384"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1385"><vh>Made sure starting from leo.py inits chapters properly</vh>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20070626112754.1386"><vh>Fixed focus problem in headline</vh>
<v t="ekr.20070626112754.97"><vh>setEditLabelState</vh></v>
<v t="ekr.20070626112754.1387"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20070626112754.1388"><vh>tk.Gui.set_focus</vh></v>
<v t="ekr.20070626112754.851"><vh>getTabName</vh></v>
<v t="ekr.20070626112754.1389"><vh>Calls to x.bringToFront</vh>
<v t="ekr.20070626112754.1390"><vh>c.bringToFront</vh></v>
<v t="ekr.20070626112754.1391"><vh>Tk bindings...</vh></v>
<v t="ekr.20070626112754.385"><vh>bringToFront (leoFind)</vh></v>
</v>
<v t="ekr.20070626112754.1222"><vh>masterClickHandler</vh></v>
<v t="ekr.20070626112754.1392"><vh>onHeadlineClick</vh></v>
<v t="ekr.20070626112754.1226"><vh>tree.editLabel</vh></v>
<v t="ekr.20070626112754.1393"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20070626112754.1394"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1395"><vh>Fixed bindings in new chapters</vh>
<v t="ekr.20070626112754.1396"><vh>tt.renameChapterHelper</vh></v>
<v t="ekr.20070626112754.1397"><vh>cc.createChapter</vh></v>
<v t="ekr.20070626112754.1398"><vh>tt.createTopLevelMenuItems</vh></v>
<v t="ekr.20070626112754.1399"><vh> Birth... (tkTree)</vh>
<v t="ekr.20070626112754.1400"><vh>__init__ (tkTree)</vh>
<v t="ekr.20070626112754.1401"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1402"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1403"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1404"><vh>tkTree.setCanvasBindings</vh>
<v t="ekr.20070626112754.1405"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1406"><vh>&lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1407"><vh>newText (tkTree) and helper</vh>
<v t="ekr.20070626112754.1408"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
<v t="ekr.20070626112754.98"><vh>tree.setHeadlineText</vh></v>
</v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.1409"><vh>Found: makeMasterGuiBinding</vh>
<v t="ekr.20070626112754.1410"><vh>k.completeAllBindingsForWidget</vh></v>
<v t="ekr.20070626112754.1411"><vh>k.completeAllBindings</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
<v t="ekr.20070626112754.1412"><vh>createModeBindings</vh></v>
</v>
<v t="ekr.20070626112754.1413"><vh>cc.finishCreate</vh></v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1414"><vh>Fixed memory leaks</vh>
<v t="ekr.20070626112754.1415"><vh>Destroying the tkFrame</vh>
<v t="ekr.20070626112754.1314"><vh>destroyAllObjects</vh>
<v t="ekr.20070626112754.1315"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1416"><vh>destroyAllPanels</vh></v>
<v t="ekr.20070626112754.1417"><vh>destroySelf (tkFrame)</vh></v>
</v>
<v t="ekr.20070626112754.1418"><vh>Interesting methods</vh>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1419"><vh>idle time functions (leoGlobals)</vh>
<v t="ekr.20070626112754.1420"><vh>enableIdleTimeHook</vh></v>
<v t="ekr.20070626112754.1421"><vh>disableIdleTimeHook</vh></v>
<v t="ekr.20070626112754.1422"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20070626112754.1423"><vh>g.doHook</vh></v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.1424"><vh> ctor (keyHandler)</vh>
<v t="ekr.20070626112754.1425"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1426"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1427"><vh>Garbage Collection</vh>
<v t="ekr.20070626112754.1428"><vh>clearAllIvars</vh></v>
<v t="ekr.20070626112754.1429"><vh>collectGarbage</vh></v>
<v t="ekr.20070626112754.1430"><vh>enable_gc_debug</vh></v>
<v t="ekr.20070626112754.1431"><vh>printGc</vh>
<v t="ekr.20070626112754.1432"><vh>printGcRefs</vh></v>
</v>
<v t="ekr.20070626112754.1433"><vh>printGcAll</vh></v>
<v t="ekr.20070626112754.1434"><vh>printGcObjects   (printNewObjects=pno)</vh>
<v t="ekr.20070626112754.1435"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1436"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1437"><vh>printGcSummary</vh></v>
<v t="ekr.20070626112754.1438"><vh>printGcVerbose</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1439"><vh>Fixed bug: Key bindings were not set in @command nodes</vh>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.1413"><vh>cc.finishCreate</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1410"><vh>k.completeAllBindingsForWidget</vh></v>
<v t="ekr.20070626112754.460"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1440"><vh>Leo 4.4.3 b2 projects</vh>
<v t="ekr.20070626112754.1441"><vh>Fixed bugs</vh>
<v t="ekr.20070626112754.1442"><vh>Fixed noweb hangs</vh>
<v t="ekr.20070626112754.1443"><vh>Reports</vh></v>
<v t="ekr.20070626112754.1444"><vh>Bill Page</vh></v>
<v t="ekr.20070626112754.1445"><vh>Import</vh>
<v t="ekr.20070626112754.1446"><vh>createOutline</vh>
<v t="ekr.20070626112754.1447"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1448"><vh>getTabWidth</vh></v>
<v t="ekr.20070626112754.1449"><vh>importDerivedFiles</vh>
<v t="ekr.20070626112754.1450"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1451"><vh>forceGnxOnPosition</vh></v>
</v>
<v t="ekr.20070626112754.1452"><vh>importFilesCommand</vh>
<v t="ekr.20070626112754.1453"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1454"><vh>importFlattenedOutline &amp; allies</vh>
<v t="ekr.20070626112754.1455"><vh>convertMoreString/StringsToOutlineAfter</vh>
<v t="ekr.20070626112754.1456"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1457"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1458"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1459"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1460"><vh>importFlattenedOutline</vh>
<v t="ekr.20070626112754.1461"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1462"><vh>moreHeadlineLevel</vh></v>
<v t="ekr.20070626112754.1463"><vh>stringIs/stringsAreValidMoreFile</vh></v>
</v>
<v t="ekr.20070626112754.1464"><vh>importWebCommand &amp; allies</vh>
<v t="ekr.20070626112754.1465"><vh>createOutlineFromWeb</vh></v>
<v t="ekr.20070626112754.1466"><vh>importWebCommand</vh></v>
<v t="ekr.20070626112754.1467"><vh>findFunctionDef</vh></v>
<v t="ekr.20070626112754.1468"><vh>scanBodyForHeadline</vh>
<v t="ekr.20070626112754.1469"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1470"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1471"><vh>scanWebFile (handles limbo)</vh>
<v t="ekr.20070626112754.1472"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1473"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1474"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="ekr.20070626112754.1475"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1476"><vh>Symbol table</vh>
<v t="ekr.20070626112754.1477"><vh>cstCanonicalize</vh></v>
<v t="ekr.20070626112754.1478"><vh>cstDump</vh></v>
<v t="ekr.20070626112754.1479"><vh>cstEnter</vh></v>
<v t="ekr.20070626112754.1480"><vh>cstLookup</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1481"><vh>perfectImport</vh>
<v t="ekr.20070626112754.1482"><vh>&lt;&lt; about this algorithm &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1483"><vh>&lt;&lt; clear all dirty bits &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1484"><vh>&lt;&lt; Assign file indices  &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1485"><vh>&lt;&lt; Write root's tree to to string s &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1486"><vh>&lt;&lt; put the corrected fat lines in a new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1487"><vh>&lt;&lt; correct root's tree using write_lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1488"><vh>&lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</vh>
<v t="ekr.20070626112754.1489"><vh>&lt;&lt; dump the files &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1490"><vh>Scanners for createOutline</vh>
<v t="ekr.20070626112754.1491"><vh>Python scanners &amp; tests</vh>
<v t="ekr.20070626112754.1492"><vh>scanPythonClass &amp; helpers</vh>
<v t="ekr.20070626112754.1493"><vh>&lt;&lt; set class_name and headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1494"><vh>scanPythonClassHelper</vh></v>
<v t="ekr.20070626112754.1495"><vh>createParentText</vh></v>
<v t="ekr.20070626112754.1496"><vh>createClassNodeText</vh></v>
</v>
<v t="ekr.20070626112754.1497"><vh>scanPythonDef</vh>
<v t="ekr.20070626112754.1498"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1499"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1500"><vh>scanPythonDecls</vh>
<v t="ekr.20070626112754.1501"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1502"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1503"><vh>scanPythonText</vh>
<v t="ekr.20070626112754.1504"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1505"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1506"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1507"><vh>skipPythonDef</vh>
<v t="ekr.20070626112754.1508"><vh>&lt;&lt; skip the entire signature &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1509"><vh>@test skipPythonDef</vh>
<v t="ekr.20070626112754.1510"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1511"><vh>@test skipPythonDef (long lines)</vh>
<v t="ekr.20070626112754.1512"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1513"><vh>@test scanPythonClass</vh>
<v t="ekr.20070626112754.1514"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.554"><vh>scanCText</vh></v>
<v t="ekr.20070626112754.1515"><vh>scanElispText &amp; allies</vh>
<v t="ekr.20070626112754.1516"><vh>skipElispParens</vh></v>
<v t="ekr.20070626112754.1517"><vh>skipElispId</vh></v>
<v t="ekr.20070626112754.1518"><vh>createElispFunction</vh></v>
<v t="ekr.20070626112754.1519"><vh>createElispDataNode</vh></v>
</v>
<v t="ekr.20070626112754.1520"><vh>scanForthText</vh></v>
<v t="ekr.20070626112754.1521"><vh>scanJavaText</vh>
<v t="ekr.20070626112754.1522"><vh>&lt;&lt; define scanJavaText vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1523"><vh>&lt;&lt; handle possible Java comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1524"><vh>&lt;&lt; handle equal sign in Java &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1525"><vh>&lt;&lt; handle open paren in Java &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1526"><vh>&lt;&lt; handle semicolon in Java &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1527"><vh>&lt;&lt; handle open curly bracket in Java &gt;&gt;</vh>
<v t="ekr.20070626112754.1528"><vh>&lt;&lt; create a Java declaration node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1529"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1530"><vh>&lt;&lt; recursively scan the text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1531"><vh>&lt;&lt; skip and remember the Java id &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1532"><vh>&lt;&lt; append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1533"><vh>scanLuaText</vh></v>
<v t="ekr.20070626112754.1534"><vh>scanPascalText</vh>
<v t="ekr.20070626112754.1535"><vh>&lt;&lt; handle possible Pascal function &gt;&gt;</vh>
<v t="ekr.20070626112754.1536"><vh>&lt;&lt; remember the function name, or continue &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1537"><vh>&lt;&lt; skip the function definition, or continue &gt;&gt;</vh>
<v t="ekr.20070626112754.1538"><vh>&lt;&lt; skip past the semicolon &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1539"><vh>&lt;&lt; create a child node for leading declarations &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1540"><vh>&lt;&lt; append noweb method reference to the parent node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1541"><vh>&lt;&lt; create a child node for the function &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1532"><vh>&lt;&lt; append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1542"><vh>scanPHPText (Dave Hein)</vh>
<v t="ekr.20070626112754.1543"><vh>&lt;&lt; define scanPHPText vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1544"><vh>&lt;&lt; Append file if not pure PHP &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1545"><vh>&lt;&lt; handle possible PHP comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1546"><vh>&lt;&lt; handle possible heredoc string &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1547"><vh>&lt;&lt; handle possible class or function &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1548"><vh>&lt;&lt; handle end of class &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1549"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.555"><vh>class cScanner</vh>
<v t="ekr.20070626112754.556"><vh>cScanner.ctor</vh></v>
<v t="ekr.20070626112754.557"><vh>scan &amp; helpers</vh>
<v t="ekr.20070626112754.558"><vh>appendUnusedText</vh></v>
<v t="ekr.20070626112754.559"><vh>doId</vh></v>
<v t="ekr.20070626112754.560"><vh>doInner</vh></v>
<v t="ekr.20070626112754.561"><vh>doOuterParen</vh></v>
<v t="ekr.20070626112754.562"><vh>doSemicolon</vh></v>
<v t="ekr.20070626112754.563"><vh>skipComments</vh></v>
</v>
<v t="ekr.20070626112754.564"><vh>Utilities (should be in base class)</vh>
<v t="ekr.20070626112754.565"><vh>createHeadline</vh></v>
<v t="ekr.20070626112754.566"><vh>error</vh></v>
<v t="ekr.20070626112754.567"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070626112754.568"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20070626112754.569"><vh>massageComment</vh></v>
<v t="ekr.20070626112754.570"><vh>setEncoding</vh></v>
<v t="ekr.20070626112754.571"><vh>skipLeadingComments</vh>
<v t="ekr.20070626112754.572"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.573"><vh>&lt;&lt; scan for Lua comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.574"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.575"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.576"><vh>undentBody</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1464"><vh>importWebCommand &amp; allies</vh>
<v t="ekr.20070626112754.1465"><vh>createOutlineFromWeb</vh></v>
<v t="ekr.20070626112754.1466"><vh>importWebCommand</vh></v>
<v t="ekr.20070626112754.1467"><vh>findFunctionDef</vh></v>
<v t="ekr.20070626112754.1468"><vh>scanBodyForHeadline</vh>
<v t="ekr.20070626112754.1469"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1470"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1471"><vh>scanWebFile (handles limbo)</vh>
<v t="ekr.20070626112754.1472"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1473"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1474"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="ekr.20070626112754.1475"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1476"><vh>Symbol table</vh>
<v t="ekr.20070626112754.1477"><vh>cstCanonicalize</vh></v>
<v t="ekr.20070626112754.1478"><vh>cstDump</vh></v>
<v t="ekr.20070626112754.1479"><vh>cstEnter</vh></v>
<v t="ekr.20070626112754.1480"><vh>cstLookup</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1550"><vh>Utilities</vh>
<v t="ekr.20070626112754.1551"><vh>createHeadline</vh></v>
<v t="ekr.20070626112754.1552"><vh>error</vh></v>
<v t="ekr.20070626112754.1553"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070626112754.1554"><vh>isDocStart and isModuleStart</vh></v>
<v t="ekr.20070626112754.1555"><vh>massageBody</vh></v>
<v t="ekr.20070626112754.1556"><vh>massageComment</vh></v>
<v t="ekr.20070626112754.1557"><vh>massageWebBody</vh>
<v t="ekr.20070626112754.1558"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1559"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1560"><vh>setEncoding</vh></v>
<v t="ekr.20070626112754.1561"><vh>skipLeadingComments</vh>
<v t="ekr.20070626112754.1562"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1563"><vh>&lt;&lt; scan for Lua comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1564"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1565"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1566"><vh>undentBody</vh></v>
</v>
<v t="ekr.20070626112754.1567"><vh>skip_line, skip_to_start/end_of_line</vh></v>
</v>
<v t="ekr.20070626112754.1568"><vh>Fixed bug: Alt-4 did not work in tree pane in unitTest.leo</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.645"><vh>k.registerCommand</vh></v>
<v t="ekr.20070626112754.444"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1569"><vh>k.makeAllBindings</vh></v>
</v>
<v t="ekr.20070626112754.1570"><vh>Investigated problem with subprocess (works for me)</vh></v>
<v t="ekr.20070626112754.1571"><vh>Fixed crashers in leoupate plugin</vh></v>
<v t="ekr.20070626112754.1572"><vh>Fixed automatic directory creation</vh>
<v t="ekr.20070626112754.1318"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20070626112754.1573"><vh>openFileForWritingHelper</vh></v>
</v>
<v t="ekr.20070626112754.1574"><vh>Fixed bug: shift-arrow keys not bound properly when node is clicked</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.1393"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20070626112754.1394"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1575"><vh>Made sure the new outlines aren't marked dirty</vh>
<v t="ekr.20070626112754.1576"><vh>Report</vh></v>
<v t="ekr.20070626112754.660"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
</v>
<v t="ekr.20070626112754.1577"><vh>Fix crasher in maximizeNewWindows</vh></v>
<v t="ekr.20070626112754.1578"><vh>Fixed lost data when deleting the root</vh>
<v t="ekr.20070626112754.1579"><vh>Third report</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1581"><vh>c.positionExists</vh></v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.1582"><vh>c.setRootPosition</vh></v>
<v t="ekr.20070626112754.1583"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20070626112754.1584"><vh>cutOutline</vh></v>
<v t="ekr.20070626112754.1585"><vh>copyOutline</vh></v>
<v t="ekr.20070626112754.1586"><vh>pasteOutline</vh>
<v t="ekr.20070626112754.1587"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1588"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1589"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1590"><vh>p.doDelete</vh></v>
<v t="ekr.20070626112754.1591"><vh>Report</vh></v>
</v>
<v t="ekr.20070626112754.1592"><vh>Fixed recent bug: the Leo window is *always* dirty</vh>
<v t="ekr.20070626112754.1593"><vh>c.setChanged</vh></v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.1277"><vh>save (commands)</vh></v>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1594"><vh>Fixed bug that caused the wrong clone to be selected.</vh>
<v t="ekr.20070626112754.1595"><vh>setPositionsFromStacks (silly)</vh></v>
<v t="ekr.20070626112754.1596"><vh>cc.selectChapterByName</vh></v>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.1581"><vh>c.positionExists</vh></v>
</v>
<v t="ekr.20070626112754.1598"><vh>Don't change focus in the save command</vh>
<v t="ekr.20070626112754.1277"><vh>save (commands)</vh></v>
<v t="ekr.20070626112754.1278"><vh>saveAs</vh></v>
<v t="ekr.20070626112754.1280"><vh>saveTo</vh></v>
</v>
<v t="ekr.20070626112754.1599"><vh>downcase-region and upcase-region didn't color body text.</vh>
<v t="ekr.20070626112754.1600"><vh>up/downCaseRegion &amp; helper</vh></v>
<v t="ekr.20070626112754.1601"><vh>begin/endCommand (baseEditCommands)</vh>
<v t="ekr.20070626112754.1602"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20070626112754.1603"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1604"><vh>endCommand</vh></v>
</v>
<v t="ekr.20070626112754.754"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20070626112754.755"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20070626112754.756"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1605"><vh>capitalization &amp; case</vh>
<v t="ekr.20070626112754.1606"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20070626112754.1607"><vh>changePreviousWord (not used)</vh></v>
<v t="ekr.20070626112754.1608"><vh>capitalizeHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1609"><vh>Fixed bug involving moving up/down out of hoists</vh>
<v t="ekr.20070626112754.593"><vh>c.goToLastVisibleNode</vh></v>
<v t="ekr.20070626112754.1610"><vh>c.lastVisible</vh></v>
<v t="ekr.20070626112754.1611"><vh>c.visLimit</vh></v>
<v t="ekr.20070626112754.1612"><vh>canMoveOutlineDown</vh></v>
<v t="ekr.20070626112754.1613"><vh>canMoveOutlineUp</vh></v>
<v t="ekr.20070626112754.1614"><vh>canSelect....</vh></v>
<v t="ekr.20070626112754.607"><vh>Commands (outline menu)</vh>
<v t="ekr.20070626112754.608"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20070626112754.609"><vh>contractNode</vh></v>
<v t="ekr.20070626112754.610"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20070626112754.611"><vh>contractParent</vh></v>
<v t="ekr.20070626112754.612"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20070626112754.613"><vh>expandAllSubheads</vh></v>
<v t="ekr.20070626112754.614"><vh>expandLevel1..9</vh></v>
<v t="ekr.20070626112754.615"><vh>expandNextLevel</vh></v>
<v t="ekr.20070626112754.616"><vh>expandNode</vh></v>
<v t="ekr.20070626112754.617"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20070626112754.618"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20070626112754.619"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20070626112754.620"><vh>Move... (Commands)</vh>
<v t="ekr.20070626112754.621"><vh>cantMoveMessage</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
<v t="ekr.20070626112754.623"><vh>moveOutlineDown</vh>
<v t="ekr.20070626112754.624"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.625"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20070626112754.626"><vh>moveOutlineRight</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.629"><vh>promote</vh></v>
</v>
<v t="ekr.20070626112754.1615"><vh>p.isVisible</vh></v>
<v t="ekr.20070626112754.1616"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20070626112754.1617"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20070626112754.1618"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
<v t="ekr.20070626112754.602"><vh>selectVisBack</vh></v>
<v t="ekr.20070626112754.603"><vh>selectVisNext</vh></v>
</v>
<v t="ekr.20070626112754.1620"><vh>Improved speed of visNext/Back</vh>
<v t="ekr.20070626112754.1621"><vh>drawTopTree</vh></v>
<v t="ekr.20070626112754.41"><vh>endDrag</vh>
<v t="ekr.20070626112754.42"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20070626112754.43"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.245"><vh>onHeadChanged</vh>
<v t="ekr.20070626112754.246"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1618"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20070626112754.1622"><vh>Fixed moveToVisBack/Next bugs</vh>
<v t="ekr.20070626112754.1615"><vh>p.isVisible</vh></v>
<v t="ekr.20070626112754.1618"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1613"><vh>canMoveOutlineUp</vh></v>
</v>
<v t="ekr.20070626112754.1623"><vh>Fixed *major* demote bug</vh>
<v t="ekr.20070626112754.1624"><vh>canDemote</vh></v>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1626"><vh>Features</vh>
<v t="ekr.20070626112754.1627"><vh>Supported write_strips_blank_lines option</vh>
<v t="ekr.20070626112754.1628"><vh>norefWrite</vh>
<v t="ekr.20070626112754.1629"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20070626112754.1630"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1631"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1632"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1633"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1634"><vh>asisWrite</vh>
<v t="ekr.20070626112754.1635"><vh>&lt;&lt; Write p's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1636"><vh>&lt;&lt; Write p's body &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1233"><vh>putCodeLine</vh></v>
<v t="ekr.20070626112754.1230"><vh>putBody</vh>
<v t="ekr.20070626112754.1231"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1232"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1637"><vh>cleanLines</vh></v>
</v>
<v t="ekr.20070626112754.1638"><vh>Improved uinit testing</vh>
<v t="ekr.20070626112754.1639"><vh>@@button at-test-nodes</vh></v>
<v t="ekr.20070626112754.1640"><vh>@@button run-test-nodes</vh>
<v t="ekr.20070626112754.1641"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1642"><vh> fail</vh></v>
<v t="ekr.20070626112754.1643"><vh>runTest</vh></v>
<v t="ekr.20070626112754.1644"><vh>isMethod</vh></v>
<v t="ekr.20070626112754.1645"><vh>shortDescription</vh></v>
<v t="ekr.20070626112754.1646"><vh>removeLeadingWs</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1647"><vh>Completed chapters</vh>
<v t="ekr.20070626112754.1648"><vh> getPublicCommands (chapterCommandsClass)</vh></v>
</v>
<v t="ekr.20070626112754.1649"><vh>Aspell now works on Linux, but only using Python 2.5</vh>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1650"><vh>Spell classes</vh>
<v t="ekr.20070626112754.1651"><vh>class spellCommandsClass</vh>
<v t="ekr.20070626112754.1652"><vh>ctor</vh></v>
<v t="ekr.20070626112754.1653"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20070626112754.413"><vh>openSpellTab</vh>
<v t="ekr.20070626112754.414"><vh>commands...</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1017"><vh>class spellTabHandler (leoFind.leoFind)</vh>
<v t="ekr.20070626112754.1018"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1019"><vh>spellTabHandler.__init__</vh></v>
<v t="ekr.20070626112754.1020"><vh>init_aspell</vh></v>
<v t="ekr.20070626112754.1021"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20070626112754.1022"><vh>Commands</vh>
<v t="ekr.20070626112754.1023"><vh>add</vh></v>
<v t="ekr.20070626112754.1024"><vh>change (spellTab)</vh></v>
<v t="ekr.20070626112754.1025"><vh>find &amp; helpers</vh>
<v t="ekr.20070626112754.1026"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070626112754.1027"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1028"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20070626112754.1029"><vh>hide</vh></v>
<v t="ekr.20070626112754.1030"><vh>ignore</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1654"><vh>class AspellClass</vh>
<v t="ekr.20070626112754.1301"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1302"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1303"><vh>getAspell</vh></v>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1655"><vh>processWord</vh></v>
<v t="ekr.20070626112754.1656"><vh>suggestions</vh></v>
<v t="ekr.20070626112754.1657"><vh>updateDictionary</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1658"><vh>Improved dynamic abbreviations</vh>
<v t="ekr.20070626112754.1659"><vh>Report</vh></v>
<v t="ekr.20070626112754.1660"><vh>Emacs docs</vh></v>
<v t="ekr.20070626112754.1661"><vh>dynamic abbreviation...</vh>
<v t="ekr.20070626112754.1193"><vh>dynamicCompletion</vh></v>
<v t="ekr.20070626112754.1191"><vh>dynamicExpansion</vh>
<v t="ekr.20070626112754.1192"><vh>dynamicExpandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1662"><vh>getDynamicList (helper)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1663"><vh>Added tab completion for dabbrev-expand</vh>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1191"><vh>dynamicExpansion</vh>
<v t="ekr.20070626112754.1192"><vh>dynamicExpandHelper</vh></v>
</v>
<v t="ekr.20070626112754.1193"><vh>dynamicCompletion</vh></v>
</v>
<v t="ekr.20070626112754.1664"><vh>Created hoist/de-hoist hooks for hoist plugin</vh>
<v t="ekr.20070626112754.1665"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1666"><vh>Enabled more plugins by default</vh></v>
<v t="ekr.20070626112754.1667"><vh>Finished chapters</vh>
<v t="ekr.20070626112754.1668"><vh>Rewrote chapters code</vh>
<v t="ekr.20070626112754.1669"><vh>What I did</vh></v>
<v t="ekr.20070626112754.1670"><vh>Birth...</vh>
<v t="ekr.20070626112754.415"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20070626112754.416"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20070626112754.1273"><vh>new</vh></v>
<v t="ekr.20070626112754.417"><vh>tkFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.419"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20070626112754.420"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20070626112754.1413"><vh>cc.finishCreate</vh></v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.1404"><vh>tkTree.setCanvasBindings</vh>
<v t="ekr.20070626112754.1405"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1406"><vh>&lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.451"><vh>tkTtree.setBindings</vh>
<v t="ekr.20070626112754.452"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1671"><vh>Drawing stuff</vh>
<v t="ekr.20070626112754.1621"><vh>drawTopTree</vh></v>
<v t="ekr.20070626112754.1672"><vh>drawTree</vh></v>
<v t="ekr.20070626112754.1673"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="ekr.20070626112754.1674"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20070626112754.1675"><vh>Creating a new chapter</vh>
<v t="ekr.20070626112754.1397"><vh>cc.createChapter</vh></v>
<v t="ekr.20070626112754.1676"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1677"><vh>c.insertHeadline</vh></v>
<v t="ekr.20070626112754.1678"><vh>c.clone</vh></v>
<v t="ekr.20070626112754.1679"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20070626112754.1680"><vh>cc.createChild</vh></v>
</v>
<v t="ekr.20070626112754.1681"><vh>currentPosition &amp; rootPosition stuff</vh>
<v t="ekr.20070626112754.1682"><vh>c.findRootPosition New in 4.4.2</vh></v>
<v t="ekr.20070626112754.192"><vh>c.setCurrentPosition</vh></v>
<v t="ekr.20070626112754.1582"><vh>c.setRootPosition</vh></v>
</v>
<v t="ekr.20070626112754.1683"><vh>Selection stuff</vh>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.752"><vh>switchToChapter (leoBody)</vh></v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.1684"><vh>chapter.select &amp; helpers</vh>
<v t="ekr.20070626112754.1312"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.1685"><vh>chapter.findEditorInChapter</vh></v>
<v t="ekr.20070626112754.1686"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20070626112754.1687"><vh>chapter.rename (not used)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1688"><vh>class leoTkinterTreeTab</vh>
<v t="ekr.20070626112754.1689"><vh> Birth &amp; death</vh>
<v t="ekr.20070626112754.1690"><vh> ctor (leoTreeTab)</vh></v>
<v t="ekr.20070626112754.1691"><vh>tt.createControl</vh></v>
</v>
<v t="ekr.20070626112754.1692"><vh>Tabs...</vh>
<v t="ekr.20070626112754.1311"><vh>tt.createTab</vh></v>
<v t="ekr.20070626112754.1693"><vh>tt.destroyTab</vh></v>
<v t="ekr.20070626112754.1313"><vh>tt.selectTab</vh></v>
<v t="ekr.20070626112754.1694"><vh>tt.setTabLabel</vh></v>
<v t="ekr.20070626112754.1695"><vh>tt.setNames</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1696"><vh>Minibuffer commands and Cmds menu</vh>
<v t="ekr.20070626112754.1697"><vh>chapterCommandsClass</vh>
<v t="ekr.20070626112754.1698"><vh> ctor</vh></v>
<v t="ekr.20070626112754.1648"><vh> getPublicCommands (chapterCommandsClass)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1699"><vh>canHoist &amp; canDehoist</vh></v>
<v t="ekr.20070626112754.295"><vh>getArg</vh>
<v t="ekr.20070626112754.296"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1700"><vh>Deleting an @chapter node is equivalent to remove-chapter</vh>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1584"><vh>cutOutline</vh></v>
</v>
<v t="ekr.20070626112754.1701"><vh>Removed no-inverse message when loading .leo files from LeoPy.leo.</vh>
<v t="ekr.20070626112754.1702"><vh> ctor: chapterController</vh></v>
<v t="ekr.20070626112754.1212"><vh>createMenuEntries</vh>
<v t="ekr.20070626112754.1213"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1214"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20070626112754.1215"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1216"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1697"><vh>chapterCommandsClass</vh>
<v t="ekr.20070626112754.1698"><vh> ctor</vh></v>
<v t="ekr.20070626112754.1648"><vh> getPublicCommands (chapterCommandsClass)</vh></v>
</v>
<v t="ekr.20070626112754.1703"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20070626112754.1704"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.415"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20070626112754.416"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20070626112754.474"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20070626112754.475"><vh>createFileMenuFromTable</vh>
<v t="ekr.20070626112754.476"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.477"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.478"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.479"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.480"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.481"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.482"><vh>createEditMenuFromTable</vh>
<v t="ekr.20070626112754.483"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.484"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.485"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.486"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20070626112754.487"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.488"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.489"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.490"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20070626112754.491"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.492"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20070626112754.493"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20070626112754.494"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20070626112754.990"><vh>g.openWithFileName</vh></v>
<v t="ekr.20070626112754.640"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20070626112754.417"><vh>tkFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20070626112754.39"><vh>createOuterFrames</vh></v>
<v t="ekr.20070626112754.418"><vh>createSplitterComponents</vh></v>
<v t="ekr.20070626112754.419"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20070626112754.420"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20070626112754.492"><vh>createCmndsMenuFromTable</vh></v>
</v>
<v t="ekr.20070626112754.1705"><vh>Made chapter ops undoable</vh>
<v t="ekr.20070626112754.1676"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1677"><vh>c.insertHeadline</vh></v>
<v t="ekr.20070626112754.1678"><vh>c.clone</vh></v>
<v t="ekr.20070626112754.1679"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20070626112754.1706"><vh>Outline menu...</vh>
<v t="ekr.20070626112754.1707"><vh> Top Level... (Commands)</vh>
<v t="ekr.20070626112754.1583"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20070626112754.1584"><vh>cutOutline</vh></v>
<v t="ekr.20070626112754.1585"><vh>copyOutline</vh></v>
<v t="ekr.20070626112754.1586"><vh>pasteOutline</vh>
<v t="ekr.20070626112754.1587"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1588"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1589"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20070626112754.1665"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20070626112754.1676"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20070626112754.1625"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20070626112754.1580"><vh>c.deleteOutline</vh></v>
<v t="ekr.20070626112754.1677"><vh>c.insertHeadline</vh></v>
<v t="ekr.20070626112754.1678"><vh>c.clone</vh></v>
<v t="ekr.20070626112754.1679"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20070626112754.1708"><vh>c.sortChildren</vh></v>
<v t="ekr.20070626112754.1709"><vh>c.sortChildrenHelper</vh></v>
<v t="ekr.20070626112754.1710"><vh>c.sortSiblings</vh></v>
<v t="ekr.20070626112754.1711"><vh>c.sortTopLevel</vh></v>
</v>
<v t="ekr.20070626112754.1712"><vh>Check Outline submenu...</vh>
<v t="ekr.20070626112754.1713"><vh>c.checkOutline</vh>
<v t="ekr.20070626112754.1714"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1715"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20070626112754.1716"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20070626112754.1717"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20070626112754.1718"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20070626112754.1719"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20070626112754.1720"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20070626112754.1721"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20070626112754.1722"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20070626112754.1723"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20070626112754.1724"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1725"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1726"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20070626112754.1727"><vh>checkAllPythonCode</vh>
<v t="ekr.20070626112754.1728"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1729"><vh>checkPythonCode</vh>
<v t="ekr.20070626112754.1730"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1731"><vh>checkPythonNode</vh></v>
<v t="ekr.20070626112754.1732"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20070626112754.1733"><vh>c.dumpOutline</vh></v>
<v t="ekr.20070626112754.1734"><vh>Pretty Print commands</vh>
<v t="ekr.20070626112754.1735"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20070626112754.1736"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20070626112754.1737"><vh>prettyPrintPythonNode</vh></v>
<v t="ekr.20070626112754.1738"><vh>class prettyPrinter</vh>
<v t="ekr.20070626112754.1739"><vh>__init__</vh>
<v t="ekr.20070626112754.1740"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1741"><vh>clear</vh></v>
<v t="ekr.20070626112754.1742"><vh>dumpLines</vh></v>
<v t="ekr.20070626112754.1743"><vh>dumpToken</vh></v>
<v t="ekr.20070626112754.1744"><vh>endUndo</vh></v>
<v t="ekr.20070626112754.1745"><vh>get</vh></v>
<v t="ekr.20070626112754.1746"><vh>prettyPrintNode</vh></v>
<v t="ekr.20070626112754.1747"><vh>put</vh></v>
<v t="ekr.20070626112754.1748"><vh>putArray</vh></v>
<v t="ekr.20070626112754.1749"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20070626112754.1750"><vh>doEndMarker</vh></v>
<v t="ekr.20070626112754.1751"><vh>doErrorToken</vh></v>
<v t="ekr.20070626112754.1752"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20070626112754.1753"><vh>doMultiLine (strings, etc).</vh></v>
<v t="ekr.20070626112754.1754"><vh>doName</vh></v>
<v t="ekr.20070626112754.1755"><vh>doNewline</vh></v>
<v t="ekr.20070626112754.1756"><vh>doNumber</vh></v>
<v t="ekr.20070626112754.1757"><vh>doOp</vh></v>
<v t="ekr.20070626112754.1758"><vh>doStartLine</vh></v>
<v t="ekr.20070626112754.1759"><vh>oops</vh></v>
<v t="ekr.20070626112754.1760"><vh>trace</vh></v>
</v>
<v t="ekr.20070626112754.1761"><vh>putToken</vh></v>
<v t="ekr.20070626112754.1762"><vh>replaceBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1763"><vh>Expand &amp; Contract...</vh>
<v t="ekr.20070626112754.607"><vh>Commands (outline menu)</vh>
<v t="ekr.20070626112754.608"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20070626112754.609"><vh>contractNode</vh></v>
<v t="ekr.20070626112754.610"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20070626112754.611"><vh>contractParent</vh></v>
<v t="ekr.20070626112754.612"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20070626112754.613"><vh>expandAllSubheads</vh></v>
<v t="ekr.20070626112754.614"><vh>expandLevel1..9</vh></v>
<v t="ekr.20070626112754.615"><vh>expandNextLevel</vh></v>
<v t="ekr.20070626112754.616"><vh>expandNode</vh></v>
<v t="ekr.20070626112754.617"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20070626112754.618"><vh>expandOnlyAncestorsOfNode</vh></v>
<v t="ekr.20070626112754.619"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20070626112754.1764"><vh>Utilities</vh>
<v t="ekr.20070626112754.1765"><vh>contractSubtree</vh></v>
<v t="ekr.20070626112754.1766"><vh>expandSubtree</vh></v>
<v t="ekr.20070626112754.1767"><vh>expandToLevel (rewritten in 4.4)</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1768"><vh>Mark...</vh>
<v t="ekr.20070626112754.1769"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20070626112754.1770"><vh>markChangedRoots</vh></v>
<v t="ekr.20070626112754.1771"><vh>markAllAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20070626112754.1772"><vh>markAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20070626112754.1773"><vh>markClones</vh></v>
<v t="ekr.20070626112754.1774"><vh>markHeadline</vh></v>
<v t="ekr.20070626112754.1775"><vh>markSubheads</vh></v>
<v t="ekr.20070626112754.1776"><vh>unmarkAll</vh></v>
</v>
<v t="ekr.20070626112754.620"><vh>Move... (Commands)</vh>
<v t="ekr.20070626112754.621"><vh>cantMoveMessage</vh></v>
<v t="ekr.20070626112754.622"><vh>demote</vh></v>
<v t="ekr.20070626112754.623"><vh>moveOutlineDown</vh>
<v t="ekr.20070626112754.624"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.625"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20070626112754.626"><vh>moveOutlineRight</vh></v>
<v t="ekr.20070626112754.627"><vh>moveOutlineUp</vh>
<v t="ekr.20070626112754.628"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.629"><vh>promote</vh></v>
</v>
<v t="ekr.20070626112754.585"><vh>Goto</vh>
<v t="ekr.20070626112754.586"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20070626112754.587"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20070626112754.588"><vh>goToFirstNode</vh></v>
<v t="ekr.20070626112754.589"><vh>goToFirstSibling</vh></v>
<v t="ekr.20070626112754.590"><vh>goToFirstVisibleNode</vh></v>
<v t="ekr.20070626112754.591"><vh>goToLastNode</vh></v>
<v t="ekr.20070626112754.592"><vh>goToLastSibling</vh></v>
<v t="ekr.20070626112754.593"><vh>c.goToLastVisibleNode</vh></v>
<v t="ekr.20070626112754.594"><vh>goToNextClone</vh></v>
<v t="ekr.20070626112754.595"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20070626112754.596"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20070626112754.597"><vh>goToNextSibling</vh></v>
<v t="ekr.20070626112754.598"><vh>goToParent</vh></v>
<v t="ekr.20070626112754.599"><vh>goToPrevSibling</vh></v>
<v t="ekr.20070626112754.600"><vh>selectThreadBack</vh></v>
<v t="ekr.20070626112754.601"><vh>selectThreadNext</vh></v>
<v t="ekr.20070626112754.602"><vh>selectVisBack</vh></v>
<v t="ekr.20070626112754.603"><vh>selectVisNext</vh></v>
<v t="ekr.20070626112754.604"><vh>utils</vh>
<v t="ekr.20070626112754.605"><vh> treeFocusHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1777"><vh>Dragging (commands)</vh>
<v t="ekr.20070626112754.1778"><vh>c.dragAfter</vh></v>
<v t="ekr.20070626112754.1779"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="ekr.20070626112754.1780"><vh>c.dragToNthChildOf</vh></v>
<v t="ekr.20070626112754.1781"><vh>c.dragCloneAfter</vh></v>
</v>
<v t="ekr.20070626112754.1782"><vh>Commands (chapters)</vh>
<v t="ekr.20070626112754.1783"><vh>cc.cloneNodeToChapter &amp; helper</vh>
<v t="ekr.20070626112754.1784"><vh>cc.cloneToChapterHelper</vh></v>
</v>
<v t="ekr.20070626112754.1785"><vh>cc.convertNodeToChapter</vh></v>
<v t="ekr.20070626112754.1786"><vh>cc.copyNodeToChapter &amp; helper</vh>
<v t="ekr.20070626112754.1787"><vh>cc.copyNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070626112754.1397"><vh>cc.createChapter</vh></v>
<v t="ekr.20070626112754.1788"><vh>cc.createChapterByName</vh></v>
<v t="ekr.20070626112754.1789"><vh>cc.createChapterFromNode</vh></v>
<v t="ekr.20070626112754.1790"><vh>cc.moveNodeToChapter &amp; helper</vh>
<v t="ekr.20070626112754.1791"><vh>cc.moveNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070626112754.1792"><vh>cc.removeChapter</vh></v>
<v t="ekr.20070626112754.1793"><vh>cc.removeChapterByName</vh></v>
<v t="ekr.20070626112754.1794"><vh>cc.renameChapter &amp; testHelper</vh></v>
<v t="ekr.20070626112754.1795"><vh>cc.selectChapter</vh></v>
<v t="ekr.20070626112754.1596"><vh>cc.selectChapterByName</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1796"><vh>Leo 4.4.3 b3 projects</vh>
<v t="ekr.20070626112754.1797"><vh>Fixed bugs</vh>
<v t="ekr.20070626112754.1798"><vh>Allow aspell on Linux provided that ctypes exists</vh>
<v t="ekr.20070626112754.1301"><vh>Birth &amp; death</vh>
<v t="ekr.20070626112754.1302"><vh>__init__</vh></v>
<v t="ekr.20070626112754.1303"><vh>getAspell</vh></v>
<v t="ekr.20070626112754.1304"><vh>getAspellWithCtypes</vh>
<v t="ekr.20070626112754.1305"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1799"><vh>Fixed a bug that disabled icon button colors on Linux</vh></v>
<v t="ekr.20070626112754.1800"><vh>Made alt menu keys work</vh>
<v t="ekr.20070626112754.289"><vh>masterKeyHandler</vh>
<v t="ekr.20070626112754.290"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20070626112754.291"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.292"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.293"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20070626112754.294"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20070626112754.464"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20070626112754.465"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20070626112754.466"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20070626112754.467"><vh>callStateFunction</vh></v>
<v t="ekr.20070626112754.468"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20070626112754.469"><vh>handleDefaultChar</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1801"><vh>Switch chapters if new position isn't in current chapter</vh>
<v t="ekr.20070626112754.1802"><vh>Report</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.51"><vh>selectEditorHelper</vh>
<v t="ekr.20070626112754.52"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.187"><vh>leoTree.select &amp; helper</vh>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20070626112754.1686"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20070626112754.1686"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20070626112754.1610"><vh>c.lastVisible</vh></v>
<v t="ekr.20070626112754.1803"><vh>c.firstVisible</vh></v>
<v t="ekr.20070626112754.1619"><vh>p.moveToVisNext</vh></v>
<v t="ekr.20070626112754.590"><vh>goToFirstVisibleNode</vh></v>
<v t="ekr.20070626112754.517"><vh>defineOutlineMenuGoToMenuTable</vh></v>
<v t="ekr.20070626112754.1804"><vh>cc.selectChapterForPosition</vh></v>
<v t="ekr.20070626112754.1597"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20070626112754.186"><vh>c.selectPosition</vh></v>
<v t="ekr.20070626112754.1674"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20070626112754.1805"><vh>Improved goto-next/prev-node commands</vh>
<v t="ekr.20070626112754.1806"><vh>class nodeHistory</vh>
<v t="ekr.20070626112754.1807"><vh>canGoToNext/Prev</vh></v>
<v t="ekr.20070626112754.1808"><vh>clear</vh></v>
<v t="ekr.20070626112754.1809"><vh>goNext/Prev</vh></v>
<v t="ekr.20070626112754.1810"><vh>nodeHistory.ctor</vh></v>
<v t="ekr.20070626112754.1811"><vh>remove</vh></v>
<v t="ekr.20070626112754.1812"><vh>selectChapter</vh></v>
<v t="ekr.20070626112754.1813"><vh>update &amp; helpers</vh>
<v t="ekr.20070626112754.1814"><vh>updatePositionList</vh></v>
<v t="ekr.20070626112754.1815"><vh>updateVisitedList</vh></v>
</v>
<v t="ekr.20070626112754.1816"><vh>visitedPositions</vh></v>
</v>
<v t="ekr.20070626112754.587"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20070626112754.586"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20070626112754.606"><vh> treeSelectHelper (new in Leo 4.4.3)</vh></v>
<v t="ekr.20070626112754.188"><vh>treeSelectHelper</vh>
<v t="ekr.20070626112754.189"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.190"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20070626112754.191"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1817"><vh>&lt;&lt; enable go to submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1818"><vh>Fixed failing bridge unit test</vh>
<v t="ekr.20070626112754.1637"><vh>cleanLines</vh></v>
</v>
<v t="ekr.20070626112754.1819"><vh>Applied patch for cleo coloring problem</vh></v>
<v t="ekr.20070626112754.1820"><vh>Fixed php coloring problems</vh>
<v t="ekr.20070626112754.1821"><vh>Report</vh></v>
<v t="ekr.20070626112754.1822"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1823"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
<v t="ekr.20070626112754.1824"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1825"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1826"><vh>doNormalState</vh>
<v t="ekr.20070626112754.1827"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20070626112754.1828"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20070626112754.1829"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1830"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1831"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1824"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1832"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20070626112754.1833"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1834"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1835"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1836"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1837"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1838"><vh>Vaid only in latex mode</vh>
<v t="ekr.20070626112754.1839"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20070626112754.1840"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20070626112754.1841"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1842"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1825"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1843"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1844"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20070626112754.1845"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1846"><vh>New features &amp; settings</vh>
<v t="ekr.20070626112754.1847"><vh>Added @bool contractVisitedNodes setting</vh></v>
<v t="ekr.20070626112754.1848"><vh>Added goto-first-visible-node command</vh></v>
<v t="ekr.20070626112754.1849"><vh>Changed binding of Alt-Home</vh></v>
<v t="ekr.20070626112754.1850"><vh>leoDist.leo now creates a python egg</vh></v>
<v t="ekr.20070626112754.1851"><vh>Removed Linux install/uninstall scripts</vh></v>
<v t="ekr.20070626112754.1852"><vh>Added @button dynamic-tests.</vh></v>
<v t="ekr.20070626112754.1853"><vh>created g.getTestVars</vh></v>
<v t="ekr.20070626112754.1854"><vh>Clean up unit tests in this file</vh></v>
<v t="ekr.20070626112754.1855"><vh>Added a section in this file called How to make Leo commands undoable</vh>
<v t="ekr.20070626112754.1856"><vh>How to make Leo commands undoable</vh>
<v t="ekr.20070626112754.1857"><vh>Undo</vh>
<v t="ekr.20070626112754.1858"><vh>afterCreateChapter</vh></v>
<v t="ekr.20070626112754.1859"><vh>afterRemoveChapter</vh></v>
<v t="ekr.20070626112754.1860"><vh>beforeCreateChapter</vh></v>
<v t="ekr.20070626112754.1861"><vh>beforeRemoveChapter</vh></v>
<v t="ekr.20070626112754.1862"><vh>redoInsertChapter</vh></v>
<v t="ekr.20070626112754.1863"><vh>redoRemoveChapter</vh></v>
<v t="ekr.20070626112754.1864"><vh>undoInsertChapter</vh></v>
<v t="ekr.20070626112754.1865"><vh>undoRemoveChapter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20070703172620"><vh>Leo 4.4.3.1 projects</vh>
<v t="ekr.20070703172620.1" a="E"><vh>Bugs</vh>
<v t="ekr.20070703172620.2"><vh>Fixed improper can not open myLeoSettings message</vh>
<v t="ekr.20070703172620.3"><vh>openLeoSettings and openMyLeoSettings</vh></v>
<v t="ekr.20070703172620.4"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20070703172620.5"><vh>Fixed import problem in leoDynamicTest.py</vh>
<v t="ekr.20070703172620.6"><vh>debugCommandsClass</vh>
<v t="ekr.20070703172620.7"><vh> ctor</vh></v>
<v t="ekr.20070703172620.8"><vh> getPublicCommands</vh></v>
<v t="ekr.20070703172620.9"><vh>collectGarbage</vh></v>
<v t="ekr.20070703172620.10"><vh>debug &amp; helper</vh>
<v t="ekr.20070703172620.11"><vh>findDebugger</vh></v>
</v>
<v t="ekr.20070703172620.12"><vh>dumpAll/New/VerboseObjects</vh></v>
<v t="ekr.20070703172620.13"><vh>enable/disableGcTrace</vh></v>
<v t="ekr.20070703172620.14"><vh>freeTreeWidgets</vh></v>
<v t="ekr.20070703172620.15"><vh>printFocus</vh></v>
<v t="ekr.20070703172620.16"><vh>printGcSummary</vh></v>
<v t="ekr.20070703172620.17"><vh>printStats</vh></v>
<v t="ekr.20070703172620.18"><vh>runUnitTest commands</vh></v>
</v>
<v t="ekr.20070703172620.19"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20070703172620.20"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20070703172620.21"><vh>computeHomeDir</vh></v>
<v t="ekr.20070703172620.22"><vh>computeLeoDir</vh></v>
<v t="ekr.20070703172620.23"><vh>computeLoadDir</vh></v>
<v t="ekr.20070703172620.24"><vh>computeStandardDirectories</vh></v>
<v t="ekr.20070703172620.25"><vh>startupEncoding</vh></v>
</v>
<v t="ekr.20070703172620.26"><vh>runTestsExternally &amp; helper class</vh>
<v t="ekr.20070703172620.27"><vh>class runTestHelperClass</vh>
<v t="ekr.20070703172620.28"><vh> ctor: runTestHelperClass</vh></v>
<v t="ekr.20070703172620.29"><vh>createFileFromOutline</vh></v>
<v t="ekr.20070703172620.30"><vh>createOutline</vh></v>
<v t="ekr.20070703172620.31"><vh>runTests</vh></v>
<v t="ekr.20070703172620.32"><vh>runLeoDynamicTest</vh></v>
<v t="ekr.20070703172620.33"><vh>searchOutline</vh></v>
</v>
</v>
</v>
<v t="ekr.20070703172620.34"><vh>Fixed cleo crasher</vh></v>
<v t="ekr.20070703172620.35"><vh>Fixed spell-check bug</vh>
<v t="ekr.20070703172620.36"><vh>find &amp; helpers</vh>
<v t="ekr.20070703172620.37"><vh>findNextMisspelledWord</vh>
<v t="ekr.20070703172620.38"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20070703172620.39"><vh>findNextWord</vh></v>
</v>
</v>
<v t="ekr.20070703172620.40"><vh>Fixed several crashers in the group operations plugin</vh></v>
<v t="ekr.20070703172620.41"><vh>Fixed chapters bug</vh>
<v t="ekr.20070703172620.42"><vh>cc.selectChapterForPosition</vh></v>
</v>
<v t="ekr.20070703172620.43"><vh>Fixed problems in groupOperations plugin</vh>
<v t="ekr.20070703172620.44"><vh>getLeoOutlineFromClipboard &amp; helpers</vh>
<v t="ekr.20070703172620.45"><vh>finishPaste</vh>
<v t="ekr.20070703172620.46"><vh>&lt;&lt; reassign tnode indices &gt;&gt;</vh></v>
</v>
<v t="ekr.20070703172620.47"><vh>getLeoOutlineHelper</vh>
<v t="ekr.20070703172620.48"><vh>&lt;&lt; recreate tnodesDict &gt;&gt;</vh></v>
</v>
<v t="ekr.20070703172620.49"><vh>getClipboardHeader</vh></v>
</v>
</v>
<v t="ekr.20070703172620.50"><vh>Fixed pychecker complaints</vh></v>
<v t="ekr.20070703172620.51"><vh>Fixed bug: deleting an editor does select the proper body pane</vh>
<v t="ekr.20070703172620.52"><vh>selectEditor &amp; helpers</vh>
<v t="ekr.20070703172620.53"><vh>selectEditorHelper</vh>
<v t="ekr.20070703172620.54"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20070703172620.55"><vh>Features</vh>
<v t="ekr.20070703172620.56"><vh>g.es and g.es_print print only to console during unit tests</vh>
<v t="ekr.20070703172620.57"><vh>es_print &amp; test</vh>
<v t="ekr.20070703172620.58"><vh>@test g.es_print</vh></v>
</v>
<v t="ekr.20070703172620.59"><vh>es</vh></v>
</v>
<v t="ekr.20070703172620.60"><vh>Suppressed status messages during unit testing</vh></v>
<v t="ekr.20070703172620.61"><vh>Run unit tests in a separate process</vh>
<v t="ekr.20070703172620.6"><vh>debugCommandsClass</vh>
<v t="ekr.20070703172620.7"><vh> ctor</vh></v>
<v t="ekr.20070703172620.8"><vh> getPublicCommands</vh></v>
<v t="ekr.20070703172620.9"><vh>collectGarbage</vh></v>
<v t="ekr.20070703172620.10"><vh>debug &amp; helper</vh>
<v t="ekr.20070703172620.11"><vh>findDebugger</vh></v>
</v>
<v t="ekr.20070703172620.12"><vh>dumpAll/New/VerboseObjects</vh></v>
<v t="ekr.20070703172620.13"><vh>enable/disableGcTrace</vh></v>
<v t="ekr.20070703172620.14"><vh>freeTreeWidgets</vh></v>
<v t="ekr.20070703172620.15"><vh>printFocus</vh></v>
<v t="ekr.20070703172620.16"><vh>printGcSummary</vh></v>
<v t="ekr.20070703172620.17"><vh>printStats</vh></v>
<v t="ekr.20070703172620.18"><vh>runUnitTest commands</vh></v>
</v>
<v t="ekr.20070703172620.62"><vh>doTests...</vh>
<v t="ekr.20070703172620.63"><vh>class generalTestCase</vh>
<v t="ekr.20070703172620.64"><vh>__init__</vh></v>
<v t="ekr.20070703172620.65"><vh> fail</vh></v>
<v t="ekr.20070703172620.66"><vh>setUp</vh></v>
<v t="ekr.20070703172620.67"><vh>tearDown</vh></v>
<v t="ekr.20070703172620.68"><vh>runTest</vh></v>
<v t="ekr.20070703172620.69"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20070703172620.70"><vh>makeTestSuite</vh></v>
<v t="ekr.20070703172620.71"><vh>makeTestCase</vh></v>
</v>
<v t="ekr.20070703172620.26"><vh>runTestsExternally &amp; helper class</vh>
<v t="ekr.20070703172620.27"><vh>class runTestHelperClass</vh>
<v t="ekr.20070703172620.28"><vh> ctor: runTestHelperClass</vh></v>
<v t="ekr.20070703172620.29"><vh>createFileFromOutline</vh></v>
<v t="ekr.20070703172620.30"><vh>createOutline</vh></v>
<v t="ekr.20070703172620.31"><vh>runTests</vh></v>
<v t="ekr.20070703172620.32"><vh>runLeoDynamicTest</vh></v>
<v t="ekr.20070703172620.33"><vh>searchOutline</vh></v>
</v>
</v>
</v>
<v t="ekr.20070703172620.72"><vh>Move most unit tests into derived files</vh></v>
<v t="ekr.20070703172620.73"><vh>Send can not import aspell message only to the log</vh></v>
</v>
</v>
</v>
<v t="ekr.20070626112754.1866" a="TV"><vh>pychecker</vh>
<v t="ekr.20070626112754.1867"><vh>Invalid warnings</vh></v>
<v t="ekr.20070626112754.1868"><vh>Report 5-7-07</vh></v>
<v t="ekr.20070626112754.1869"><vh>Report 6-10-07</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20061021144014"></t>
<t tx="ekr.20061021144014.1"></t>
<t tx="ekr.20061021144014.2">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\unitTest.leo
FAILED (failures=1)
UnicodeDecodeError Exception in Tk callback
  Function: &lt;function masterBindKeyCallback at 0x018BD970&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x02B0B5F8&gt;,)
  Event type: KeyPress (type num: 2)
  
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2118, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 3133, in masterKeyHandler
    return k.getArg(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2755, in getArg
    if handler: handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7191, in searchWithPresentOptions
    self.generalSearchHelper(k.arg)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7066, in generalSearchHelper
    self.finder.findNextCommand()
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7676, in findNextCommand
    self.findNext()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 684, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 711, in findNextMatch
    pos, newpos = self.search()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 746, in search
    regexp=self.pattern_match,word=self.whole_word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 780, in searchHelper
    pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 856, in plainHelper
    elif self.matchWord(s,k,pattern):
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 871, in matchWord
    s[i-1] not in self.word_chars or
UnicodeDecodeError: 'ascii' codec can't decode byte 0x83 in position 52: ordinal not in range(128)

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 49425
    state: 0
    time: 17007655
    type: 2
    widget: .21619056.21619656.24867464.minibuffer
    width: ??
    x: 526
    x_root: 782
    y: -648
    y_root: 240

</t>
<t tx="ekr.20061021144014.3">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated (in the subclass by update_ivars) just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = None # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
</t>
<t tx="ekr.20061021144014.4">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None
</t>
<t tx="ekr.20061021144014.5">def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            while i &lt; len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1]))
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()

</t>
<t tx="ekr.20061021144014.6"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and not g.isWordChar1(line[i]):
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and g.isWordChar(line[j]):
                j += 1
            word = line[i:j]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.</t>
<t tx="ekr.20061021144014.7">@nocolor

FAIL: @test k.inverseCommandsDict is inverse of c.commandsDict
AssertionError: cl not in inverseCommandsDict.values()

I just hacked the unit test not to complain about abbreviations.
Another solution would be to allow the values of k.inverseCommandsDict to be lists.</t>
<t tx="ekr.20061021144014.8">def initAbbrev (self):
    
    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d.keys():
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev: %s: unknown command name: %s' %
                (key,commandName),color='blue')
</t>
<t tx="ekr.20061021144014.9">@

The logic in cycleAllFocus is now much cleaner.
The cycle focus commands work in the minibuffer *only* if not tab-completion is done.
I think this is the old, horrible problems with Pmw focus: it's a very small nit.</t>
<t tx="ekr.20061021144014.10">def cycleFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget
   
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i &gt;= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body
    
    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)
    
    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane</t>
<t tx="ekr.20061021144014.11">editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        # g.trace(self.editWidgetCount,n)
        if n &gt; 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount &gt; n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n &gt; 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount &gt; n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = 1 ; self.logWidgetCount = 0
        
    if trace: print 'old: %10s new: %10s' % (w_name(w),w_name(pane))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)</t>
<t tx="ekr.20061021144014.12">def selectTab (self,tabName,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName,wrap=wrap)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
</t>
<t tx="ekr.20061021144014.13">def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
</t>
<t tx="ekr.20061021144014.14">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20061021144014.15">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    
    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.16">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20061021144014.17">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        print '%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8)
</t>
<t tx="ekr.20061021144014.18">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if trace: print \
        'requested',c.widget_name(c.requestedFocusWidget),\
        'present',c.widget_name(c.hasFocusWidget)
    
    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        if trace: print 'no change.',c.widget_name(w)
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        if trace: print '*'*20,'oops: moving to body pane.'
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
</t>
<t tx="ekr.20061021144014.19">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    &lt;&lt; define vars &gt;&gt;

    if keysym in special_keys:
        return None

    &lt;&lt; do key traces &gt;&gt;

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;
        
    &lt;&lt; handle per-pane bindings &gt;&gt;
    &lt;&lt; handle keys without bindings &gt;&gt;
</t>
<t tx="ekr.20061021144014.20">k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
    
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
</t>
<t tx="ekr.20061021144014.21">self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(
        # 'keysym',repr(event.keysym or ''),
        'stroke',repr(stroke),
        'state',state,
        'unboundKeyAction',k.unboundKeyAction)
</t>
<t tx="ekr.20061021144014.22"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
</t>
<t tx="ekr.20061021144014.23">key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(g.app.gui.isTextWidget(w),w_name,key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
</t>
<t tx="ekr.20061021144014.24">if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif event and event.keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    # g.trace(stroke,event.char,event.keysym)
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20061021144014.25">def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
</t>
<t tx="ekr.20061021144014.26">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
        c.traceFocus(w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
</t>
<t tx="ekr.20061021144014.27">@

@command whaterver @key Alt-1 didn't work
Actually, no Alt-n keys worked for n in (1,2,3,4,5) in any context.

Happily, the problem was a confusion about what Alt-1 means.
Apparently it means Alt-Button-1 rather than Alt-Key-1.

The solution was to insert an explicit Key- prefix in k.tkBindingFromStroke.
I also made a minor mod to printBindings.</t>
<t tx="ekr.20061021144014.28">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = verbose and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None
  
    if stroke:
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
             g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')
                
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break</t>
<t tx="ekr.20061021144014.29">def makeMasterGuiBinding (self,stroke,w=None):
    
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    
    k = self ; c = k.c ; f = c.frame
   
    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)
    
    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        widgets=(c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)
    
    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
</t>
<t tx="ekr.20061021144014.30">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    # g.trace('&lt;%s&gt;' % stroke)
    return '&lt;%s&gt;' % stroke
</t>
<t tx="ekr.20061021144014.31">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)
            
    # Print keys by type:
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        g.es('%s %s' % (sep, prefix),tabName=tabName)
        self.printBindingsHelper(data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    g.es('%s %s' % (sep, 'Plain Keys',),tabName=tabName)
    self.printBindingsHelper(data,n1,n2,prefix=None)
    state = k.unboundKeyAction 
    k.showStateAndMode()
</t>
<t tx="ekr.20061021144014.32">def printBindingsHelper (self,data,n1,n2,prefix):
        
    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.
    
    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) &gt;  1]
        # The list of all other items.
                
    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
</t>
<t tx="ekr.20061021144014.33">def prettyPrintKey (self,stroke,brief=False):
    
    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.tkBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'&lt;%s&gt;' % s)
</t>
<t tx="ekr.20061021144014.34">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3956836

p.clone(p) -&gt; p.clone() in the big reorg.
</t>
<t tx="ekr.20061021144014.35">http://sourceforge.net/forum/message.php?msg_id=3958333
By: mstarzyk

I get the following exception while opening a leo file:

Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoGlobals.py", line 2441, in doHook
    return f(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 69, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 48, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 193, in onCreate
    sc.createAllButtons()
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 249,
in createAllButtons
    self.createAtButtonButton(p)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 316,
in createAtButtonButton
    b = self.createAtButtonIconButton(p,buttonText,statusLine,shortcut)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 588,
in createAtButtonIconButton
    b = self.createIconButton(text=buttonText,statusLine=statusLine,bg=bg)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 431,
in createIconButton
    self.createBalloon(b,statusLine)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 459,
in createBalloon
    balloon.bind(w,label)
  File "C:\Program Files\Leo\extensions\Pmw\Pmw_1_2\lib\PmwBalloon.py", line
76, in bind
    enterId = widget.bind('&lt;Enter&gt;',
AttributeError: 'NoneType' object has no attribute 'bind'

@nocolor

This is strange: I never have a problem with it.
The fix: don't call balloon.bind if balloon is None.</t>
<t tx="ekr.20061021144014.36"></t>
<t tx="ekr.20061021144014.37">@nocolor

Do *not* bother with trying to preserve the focus.
Instead, the 'end of script' message should just go to whatever log pane is on top.

@color</t>
<t tx="ekr.20061021144014.38">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    &lt;&lt; redirect output &gt;&gt;
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally: # New in 4.3 beta 2: unredirect output last.
        &lt;&lt; unredirect output &gt;&gt;
</t>
<t tx="ekr.20061021144014.39">if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20061021144014.40">if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
</t>
<t tx="ekr.20061021144014.41">@ The warning was disabled due to a programming error (not not)
Enabling this found two errors: view-lossage (missing comma) and
find-with-present-options --&gt; search-with-present-options.</t>
<t tx="ekr.20061021144014.42">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
</t>
<t tx="ekr.20061021144014.43">if type(data) == type(''):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&amp;','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data
            
        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data</t>
<t tx="ekr.20061021144014.44"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
</t>
<t tx="ekr.20061021144014.45">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
</t>
<t tx="ekr.20061021144014.46">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
</t>
<t tx="ekr.20061021144014.47">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3957980
By: dcbbcd

This was a major effort.

What I did:
    
- Defined g.isWordChar in terms of ch.isalnum()

- Replace almost all instances of string.letters and string.digits by calls to
  ch.isalnum(), ch.isalpha(), ch.isdigit(), etc.
  
- Similarly, replaced word_chars.

- The new code uses string literals only for

a) small constants like '+-' and
b) constants in a very limited context, as in the input to regexp.

To do: look for string.printable

@color</t>
<t tx="ekr.20061021144014.48"># most uses of these should be converted to g.isWordChar.</t>
<t tx="ekr.20061021144014.49">def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = g.app.gui.getSelectedText(w) + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = g.app.gui.getSelectedText(w)
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = g.app.gui.getSelectedText(w)
        if keysym == 'parenleft':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20061021144014.50">def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel &lt;= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','&lt;=','&gt;=','&lt;','&gt;','&lt;&gt;','*','**','+','&amp;','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '&gt;&gt;':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '&lt;&lt;':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
</t>
<t tx="ekr.20061021144014.51">def appendToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('append-to-reg')
    
    if state == 0:
        k.setLabelBlue('Append to register: ',protect=True)
        k.setState('append-to-reg',1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = val + w.get('sel.first','sel.last')
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.52">def prependToRegister (self,event):
    
    '''Prompt for a register name and prepend the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('prepend-to-reg')
    
    if state == 0:
        k.setLabelBlue('Prepend to register: ',protect=True)
        k.setState('prepend-to-reg',1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = w.get('sel.first','sel.last') + val
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.53">def copyRectangleToRegister (self,event):
    
    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 &lt;= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.54">def copyToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('copy-to-reg')
    
    if state == 0:
        k.commandName = 'copy-to-register'
        k.setLabelBlue('Copy to register: ',protect=True)
        k.setState('copy-to-reg',1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                try:
                    val = w.get('sel.first','sel.last')
                except Exception:
                    g.es_exception()
                    val = ''
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.55">def incrementRegister (self,event):
    
    '''Prompt for a register name and increment its value if it has a numeric value.'''
    
    c = self.c ; k = self.k ; state = k.getState('increment-reg')
    
    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.56">def insertRegister (self,event):
    
    '''Prompt for a register name and and insert the value of another register into its contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('insert-reg')
    
    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.57">def jumpToRegister (self,event):
    
    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            if self._checkIfRectangle(event): return
            key = event.keysym.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.mark_set('insert',val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.58">@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):
    
    k = self.k ; state = k.getState('number-to-reg')
    
    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            # self.registers[event.keysym.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
</t>
<t tx="ekr.20061021144014.59">def pointToRegister (self,event):
    
    '''Prompt for a register name and put a value indicating the insert point in the register.'''
    
    c = self.c ; k = self.k ; state = k.getState('point-to-reg')
    
    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = w.index('insert')
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.60">def viewRegister (self,event):
    
    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')
    
    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.61">aList = [g.choose(ch.isalnum(),ch,'-') for ch in buttonText]

buttonCommandName = ''.join(aList)
buttonCommandName = buttonCommandName.replace('--','-')
buttonCommandName = 'press-%s-button' % buttonCommandName.lower()

# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName,None,executeScriptCallback,pane='button',verbose=False)
</t>
<t tx="ekr.20061021144014.62">def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
</t>
<t tx="ekr.20061021144014.63">def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        accel_ch = (string.digits + string.letters.upper()) # Not a unicode problem.
        label = "%s %s" % (accel_ch[i-2],g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
</t>
<t tx="ekr.20061021144014.64"></t>
<t tx="ekr.20061021144014.65">def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        c = k.c
        ch = event and event.char
        k.resetLabel()
        k.clearState()
        if len(event.char) != 0 and not ch.isspace():
            i = w.search(ch,'insert',stopindex='end')
            if i != -1:
                s = w.get('insert','%s' % i)
                self.addToKillBuffer(s)
                w.delete('insert','%s' % i)
</t>
<t tx="ekr.20061021144014.66">i = g.skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i].isdigit():
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
</t>
<t tx="ekr.20061021144014.67">while i &lt; len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i &lt; len(s) and s[i].isdigit():
            i += 1
        if j &lt; i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
</t>
<t tx="ekr.20061021144014.68">new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i &lt; len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1

    if j &lt; i:
        pass
    else:
        valid = False
</t>
<t tx="ekr.20061021144014.69">def skip_id(self,s,i,chars=None):

    n = len(s)
    chars = chars and g.toUnicode(chars,encoding='ascii') or u''
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
            i += 1
    return i
</t>
<t tx="ekr.20061021144014.70">if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i &gt; -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1].isdigit():
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
</t>
<t tx="ekr.20061021144014.71">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
</t>
<t tx="ekr.20061021144014.72">def getDouble (self):

    self.skipWs()
    i = self.fileIndex ; buf = self.fileBuffer
    floatChars = 'eE.+-'
    n = len(buf)
    while i &lt; n and (buf[i].isdigit() or buf[i] in floatChars):
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting float constant")
    val = float(buf[self.fileIndex:i])
    self.fileIndex = i
    return val
</t>
<t tx="ekr.20061021144014.73">def getLong (self):

    self.skipWs() # guarantees at least one more character.
    i = self.fileIndex
    if self.fileBuffer[i] == u'-':
        i += 1
    n = len(self.fileBuffer)
    while i &lt; n and self.fileBuffer[i].isdigit():
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting int constant")
    val = int(self.fileBuffer[self.fileIndex:i])
    self.fileIndex = i
    return val
</t>
<t tx="ekr.20061021144014.74">def is_c_id(ch):

    return g.isWordChar(ch)

</t>
<t tx="ekr.20061021144014.75">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
</t>
<t tx="ekr.20061021144014.76">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20061021144014.77">def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i</t>
<t tx="ekr.20061021144014.78">def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or (not s[i].isdigit() and s[i] not in u'+-'):
        return i, None
    j = i
    if s[i] in u'+-': # Allow sign before the first digit
        i +=1
    while i &lt; n and s[i].isdigit():
        i += 1
    try: # There may be no digits.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20061021144014.79">def skipElispId (self,s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20061021144014.80">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
            
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)
</t>
<t tx="ekr.20061021144014.81">def universalDispatcher (self,event):
    
    '''Handle accumulation of universal argument.'''
    
    &lt;&lt; about repeat counts &gt;&gt;

    k = self ; state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = event.keysym
            # Stroke is &lt;Key&gt; for plain keys, &lt;Control-u&gt; (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '&lt;Key&gt;' and (keysym.isdigit() or keysym == u'-'):
            k.updateLabel(event)
        elif stroke == '&lt;Key&gt;' and keysym in (
            'Alt_L','Alt_R','Shift_L','Shift_R','Control_L','Control_R'):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '&lt;Control-x&gt;':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
</t>
<t tx="ekr.20061021144014.82">@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
</t>
<t tx="ekr.20061021144014.83">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)
</t>
<t tx="ekr.20061021144014.84">def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
</t>
<t tx="ekr.20061021144014.85"># This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):
    
    
    if i &gt;= len(s) or not s[i].isdigit():
        return i, -1
    j = i
    while i &lt; len(s) and s[i].isdigit():
        i += 1
    val = int(s[j:i])
    # g.trace(s[j:i],val)
    return i, val</t>
<t tx="ekr.20061021144014.86">def canonicalizeMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch.isalnum()])
    
def canonicalizeTranslatedMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch not in u'&amp; \t\n\r'])

</t>
<t tx="ekr.20061021144014.87">def computeOldStyleShortcutKey (self,s):
    
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    
    return ''.join([ch for ch in s.strip().lower() if ch.isalnum()])
</t>
<t tx="ekr.20061021144014.88">e = self.id_entry
s = e.get().strip()
i = 0 ; ok = True
while i &lt; len(s):
    ch = s[i]
    if not ch.isalnum():
        e.delete(str(i))
        s = e.get()
        ok = False
    else:
        i += 1
if not ok: return
</t>
<t tx="ekr.20061021144014.89">e = self.number_entry
s = e.get().strip()

i = 0
while i &lt; len(s):
    ch = s[i]
    if not ch.isdigit():
        e.delete(str(i))
        s = e.get()
    else:
        i += 1
</t>
<t tx="ekr.20061021144014.90"></t>
<t tx="ekr.20061021144014.91">def doNormalState (self,s,i):
    
    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&amp;*()_+-={}|[];':\",./&lt;&gt;?")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state
</t>
<t tx="ekr.20061021144014.92"></t>
<t tx="ekr.20061021144014.93">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
elif self.language == "forth":
    &lt;&lt; handle possible forth keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j
</t>
<t tx="ekr.20061021144014.94">if g.match(s,i,"\\"):
    if i + 1 &lt; len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
</t>
<t tx="ekr.20061021144014.95">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20061021144014.96">j = self.skip_id(s,i+1,chars="`~!@#$%^&amp;*()-_=+[]{};:'\\\",./&lt;&gt;?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
</t>
<t tx="ekr.20061021144014.97">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
</t>
<t tx="ekr.20061021144014.98">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
</t>
<t tx="ekr.20061021144014.99">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20061021144014.100"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
</t>
<t tx="ekr.20061021144014.101"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
</t>
<t tx="ekr.20061021144014.102">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
</t>
<t tx="ekr.20061021144014.103">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
</t>
<t tx="ekr.20061021144014.104"></t>
<t tx="ekr.20061021144014.105">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.106"></t>
<t tx="ekr.20061021144014.107"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20061021144014.108"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
</t>
<t tx="ekr.20061021144014.109">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
</t>
<t tx="ekr.20061021144014.110">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.111">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.112"># self.tag("normal",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.113">def getCwebWord (self,s,i):
    
    # g.trace(g.get_line(s,i))
    if not g.match(s,i,"@"):
        return None
    
    ch1 = ch2 = word = None
    if i + 1 &lt; len(s): ch1 = s[i+1]
    if i + 2 &lt; len(s): ch2 = s[i+2]

    if g.match(s,i,"@**"):
        word = "@**"
    elif not ch1:
        word = "@"
    elif not ch2:
        word = s[i:i+2]
    elif (
        (ch1 in string.ascii_letters and not ch2 in string.ascii_letters) or # single-letter control code
        ch1 not in string.ascii_letters # non-letter control code
    ):
        word = s[i:i+2]

    # if word: g.trace(word)
        
    return word
</t>
<t tx="ekr.20061021144014.114">def init_trace(args,echo=1):

    t = app.trace_list
    args = g.get_Sherlock_args(args)

    for arg in args:
        if arg[0] in string.ascii_letters: prefix = '+'
        else: prefix = arg[0] ; arg = arg[1:]
        
        if prefix == '?':
            print "trace list:", t
        elif prefix == '+' and not arg in t:
            t.append(string.lower(arg))
            if echo:
                print "enabling:", arg
        elif prefix == '-' and arg in t:
            t.remove(string.lower(arg))
            if echo:
                print "disabling:", arg
        else:
            print "ignoring:", prefix + arg
</t>
<t tx="ekr.20061021144014.115">def sanitize_filename(s):

    """Prepares string s to be a valid file name:
    
    - substitute '_' whitespace and characters used special path characters.
    - eliminate all other non-alphabetic characters.
    - strip leading and trailing whitespace.
    - return at most 128 characters."""

    result = ""
    for ch in s.strip():
        if ch in string.ascii_letters:
            result += ch
        elif ch in string.whitespace: # Translate whitespace.
            result += '_'
        elif ch in ('.','\\','/',':'): # Translate special path characters.
            result += '_'
    while 1:
        n = len(result)
        result = result.replace('__','_')
        if len(result) == n:
            break
    result = result.strip()
    return result [:128]
</t>
<t tx="ekr.20061021144014.116">i = g.skip_ws(s,i)
if g.match(s,i,"@*") or g.match(s,i,"@ "): kind = at_doc
elif g.match(s,i,"@&lt;"): i, kind, end = self.skip_section_name(s,i)
elif g.match(s,i,"@@"): kind = at_at
elif g.match_word(s,i,"@c") or g.match_word(s,i,"@p"): kind = at_code
elif i &lt; len(s) and s[i] == '@':
    if   i + 1 &gt;= len(s): kind = at_doc
    elif i + 1 &lt; len(s) and s[i+1] not in string.ascii_letters:
        kind = at_web
    else: kind = at_other # Set kind later
else: kind = plain_line
</t>
<t tx="ekr.20061021144014.117">self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}
    
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns
    
    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.
    
    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective
                
    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword
    
    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword
        
    if self.language == "php":
        dict1 ['&lt;'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword
    
    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["&lt;&lt;"] = self.doPossibleSectionRefOrDef
        
    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
    
    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
</t>
<t tx="ekr.20061021144014.118">def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars </t>
<t tx="ekr.20061021144014.119">def autoCompleterStateHandler (self,event):
    
    c = self.c ; k = self.k
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = event and event.keysym
    ch = event and event.char or ''
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in ('space','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == 'period':
        self.chain()
    elif keysym == 'question':
        self.info()
    elif keysym == 'exclam':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20061021144014.120">def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if s[i+1] not in string.ascii_letters:
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
</t>
<t tx="ekr.20061021144014.121">def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20061021144014.122">def test_isPlainKey (self):
    
    import string
    
    k = c.k # self is a dummy argument
    
    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)
        
    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
</t>
<t tx="ekr.20061021144014.123">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3960993

I happen to select Plugins-&gt;Scripting and the "About Scripting" window opened...a
huge, long, "about" window with no scroll-bars that was taller than my screen.

Can the "About" info be put into a resizable window (with scroll-bars) instead,
with a reasonable initial size?

Kam-Yung

</t>
<t tx="ekr.20061021144014.124">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3961623
By: vpe

Leo periodically prints 'Key state: Insert' message in the status area even
though I never change insert mode. It does not seem to be necessary and it destroys
UNL info. I get this message when I open new file, insert new node, type (,
type . in Python nodes, and probably on other events.

To get rid of it, I added one line to showStateAndMode(self) in
Code--&gt;@thin leoKeys.py--&gt;class keyHandlerClass--&gt;Input
State--&gt;showStateAndMode

....if hasattr(frame,'clearStatusLine'):
........if not state.capitalize()=='Insert': # &lt;---- added
............frame.clearStatusLine()
............put = frame.putStatusLine
............put('Key state: ',color='blue')
............put('%s' % state.capitalize())

There should be a more intelligent solution. 


Also, command set-overwrite-state works but generates a Tk error.

specs:
Leo 4.4.2 beta 2, build  1.69 , October 9, 2006
Python 2.5.0, Tk 8.4.12, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4
</t>
<t tx="ekr.20061021144014.125">@nocolor

No longer needed now that the datenodes plugins gets settings from cvs.</t>
<t tx="ekr.20061021144014.126">@ To force a recolor there must be a non-None undoType passed to kill.
or an explicit call to self.c.frame.body.forceFullRecolor() before calling endCommand.
</t>
<t tx="ekr.20061021144014.127">class killBufferCommandsClass (baseEditCommandsClass):
    
    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20061021144014.128">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):
    
    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
    
    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20061021144014.129">def getPublicCommands (self):
    
    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20061021144014.130">def addToKillBuffer (self,text):
    
    killKeys =(
        '&lt;Control-k&gt;', '&lt;Control-w&gt;',
        '&lt;Alt-d&gt;', '&lt;Alt-Delete', '&lt;Alt-z&gt;', '&lt;Delete&gt;',
        '&lt;Control-Alt-w&gt;')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20061021144014.131">def backwardKillSentence (self,event):
    
    '''Kill the previous sentence.'''
    
    w = self.editWidget(event)
    if not w: return

    i = w.search('.','insert',backwards=True,stopindex='1.0')

    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='backward-kill-sentence')
</t>
<t tx="ekr.20061021144014.132">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20061021144014.133">def clearKillRing (self,event=None):
    
    '''Clear the kill ring.'''
    
    self.killBuffer = []
</t>
<t tx="ekr.20061021144014.134">def getClipboard (self,w):

    try:
        ctxt = w.selection_get(selection='CLIPBOARD')
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except: pass

    return None
</t>
<t tx="ekr.20061021144014.135">def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
</t>
<t tx="ekr.20061021144014.136">def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    w.delete(frm,to)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    self.kill(event,'insert linestart','insert lineend+1c',undoType='kill-line')</t>
<t tx="ekr.20061021144014.137">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return
    
    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.138">def killSentence (self,event):
    
    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return

    i  = w.search('.','insert',stopindex='end')
    if i:
        self.beginCommand(undoType='kill-sentence')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='kill-sentence')
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.139">def killWs (self,event,undoType=None):
    
    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break
   
    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.140">def yank (self,event):
    
    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.141">def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert') ; t, t1 = i.split('.')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        if clip_text: s = clip_text
        else:         s = self.kbiterator.next()
        t1 = str(int(t1)+len(s))
        r = w.tag_ranges('kb')
        if r and r [0] == i:
            w.delete(r[0],r[-1])
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
</t>
<t tx="ekr.20061021144014.142"></t>
<t tx="ekr.20061021144014.143">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
</t>
<t tx="ekr.20061021144014.144"># New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
</t>
<t tx="ekr.20061021144014.145"># New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20061021144014.146"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = g.app.gui.getAllText(bodyCtrl) # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText))
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        g.trace('newText:',repr(newText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        &lt;&lt; recolor the body &gt;&gt;
        if not c.changed: c.setChanged(True)
        self.updateEditors()
        &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20061021144014.147">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
</t>
<t tx="ekr.20061021144014.148">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
</t>
<t tx="ekr.20061021144014.149"># Did not restore selection after indent/undent commands.
</t>
<t tx="ekr.20061021144014.150"></t>
<t tx="ekr.20061021144014.151">def convertAllBlanks (self,event=None):
    
    '''Convert all blanks to tabs in the selected outline.'''
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count &gt; 0)
</t>
<t tx="ekr.20061021144014.152">def convertAllTabs (self,event=None):
    
    '''Convert all tabs to blanks in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count &gt; 0)
</t>
<t tx="ekr.20061021144014.153">def convertBlanks (self,event=None):
    
    '''Convert all blanks to tabs in the selected node.'''

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20061021144014.154">def convertTabs (self,event=None):
    
    '''Convert all tabs to blanks in the selected node.'''

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False,None

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
</t>
<t tx="ekr.20061021144014.155">def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
</t>
<t tx="ekr.20061021144014.156">def dedentBody (self,event=None):
    
    '''Remove one tab's worth of indentation from all presently selected lines.'''
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.157">def extract (self,event=None):
    
    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20061021144014.158">def extractSection (self,event=None):
    
    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20061021144014.159">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
</t>
<t tx="ekr.20061021144014.160">def extractSectionNames(self,event=None):
    
    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
</t>
<t tx="ekr.20061021144014.161">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)
        
if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]
</t>
<t tx="ekr.20061021144014.162">def findBoundParagraph (self,event=None):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        &lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;

    # Scan backwards.
    i = len(head_lines)
    while i &gt; 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i &lt; len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#   para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
</t>
<t tx="ekr.20061021144014.163">if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
</t>
<t tx="ekr.20061021144014.164">def findMatchingBracket (self,event=None):
    
    '''Selecte the text between matching brackets.'''
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"&lt;=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
</t>
<t tx="ekr.20061021144014.165"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,"&gt;=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level &lt;= 0:
                return index
        if not forward and body.compareIndices(index,"&lt;=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
</t>
<t tx="ekr.20061021144014.166">def getBodyLines (self,expandSelection=False):
    
    """Return head,lines,tail where:
        
    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use g.splitLines.

    return head,lines,tail,oldSel,oldVview
</t>
<t tx="ekr.20061021144014.167">def indentBody (self,event=None):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; undoType = 'Indent Region' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.168">def insertBodyTime (self,event=None):
    
    '''Insert a time/date stamp at the cursor.'''
    
    c = self ; undoType = 'Insert Body Time'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)
</t>
<t tx="ekr.20061021144014.169">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20061021144014.170"></t>
<t tx="ekr.20061021144014.171">def addComments (self,event=None):
    
    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.172">def deleteComments (self,event=None):
    
    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.173">def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;
</t>
<t tx="ekr.20061021144014.174">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
</t>
<t tx="ekr.20061021144014.175">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20061021144014.176"># Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
</t>
<t tx="ekr.20061021144014.177">sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
</t>
<t tx="ekr.20061021144014.178">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
</t>
<t tx="ekr.20061021144014.179">def setSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = g.app.gui.getInsertPoint(w)
        
    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    # g.trace(i,j)
    g.app.gui.setSelectionRange(w,i,j,insert=j)
    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20061021144014.180">@
The 'hang' was due to removeRKeys, which removes the bindings create by
setRegion (set-mark-command) by *also* cleared all the other bindings!
For now I have simply disabled the set-mark-command and commented out all
calls to removeRKeys.

Note that toggle-extend-mode (Alt-3) is a good way to define regions.</t>
<t tx="ekr.20061021144014.181"></t>
<t tx="ekr.20061021144014.182">def testinrange (self,w):

    if not self.inRange(w,'sel') or not self.contRanges(w,'sel'):
        # self.removeRKeys(w)
        return False
    else:
        return True
</t>
<t tx="ekr.20061021144014.183">def indentRegion (self,event):
    w = self.editWidget(event)
    if not w: return

    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.184">def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')
    
def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')
    
def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w: return

    trange = w.tag_ranges('sel')
    if len(trange) != 0:
        self.beginCommand(undoType=undoType)
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)
        self.endCommand(changed=True,setLabel=True)

    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.185">@nocolor
@

onFocusIn and its associated binding were a very bad idea.  It is not needed:
k.masterClickHandler simply calls the new onClick method.

What I did:
    
- Eliminating onFocusIn and its associated binding.
  Hurray: this also fixed the Find problem.
- Fixed problem with deleting nodes when multiple editors are present.
- Fixed minor problem with cycle-all-focus.
- Removed title bar when penultimate editor is deleted.

@color</t>
<t tx="ekr.20061021144014.186">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        # g.trace(event.x,event.y)
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = g.app.gui.getSelectionRange(w)
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
        c.frame.body.onClick(w) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20061021144014.187">class leoTkinterBody (leoFrame.leoBody):
    
    """A class that represents the body pane of a Tkinter window."""

    @others
</t>
<t tx="ekr.20061021144014.188"></t>
<t tx="ekr.20061021144014.189">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterBody")
    
    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)
    
    c = self.c ; p = c.currentPosition()
    self.editor_name = None
    self.editor_v = None
    self.editorWidgets = {} # keys are pane names, values are Tk.Text widgets

    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.bodyCtrl = self.createControl(frame,parentFrame,p)
    self.colorizer = leoColor.colorizer(c)
</t>
<t tx="ekr.20061021144014.190">def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl
    
    w.bind('&lt;Key&gt;', k.masterKeyHandler)

    for kind,func,handler in (
        ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
        ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
        ('&lt;Button-2&gt;',  frame.OnPaste,              k.masterClickHandler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        w.bind(kind,bodyClickCallback)</t>
<t tx="ekr.20061021144014.191">def createControl (self,frame,parentFrame,p):
    
    c = self.c
    
    # New in 4.4.1: make the parent frame a Pmw.PanedWidget.
    self.numberOfEditors = 1 ; name = '1'
    self.totalNumberOfEditors = 1
    
    orient = c.config.getString('editor_orientation') or 'horizontal'
    if orient not in ('horizontal','vertical'): orient = 'horizontal'
   
    self.pb = pb = Pmw.PanedWidget(parentFrame,orient=orient)
    parentFrame = pb.add(name)
    pb.pack(expand=1,fill='both') # Must be done after the first page created.
   
    w = self.createTextWidget(frame,parentFrame,p,name)
    self.editorWidgets[name] = w

    return w
</t>
<t tx="ekr.20061021144014.192">def createTextWidget (self,frame,parentFrame,p,name):
    
    c = self.c
    
    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = w = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
        
    # g.trace(id(w))
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
    w.leo_active = True
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w</t>
<t tx="ekr.20061021144014.193">@ **Important**: body.bodyCtrl and body.frame.bodyCtrl must always be the same.
</t>
<t tx="ekr.20061021144014.194">def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl
    
    # g.trace(id(w),c.currentPosition().headString())
    
    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w
    
    c.recolor_now(interruptable=False) # Force a complete recoloring.
    
    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w</t>
<t tx="ekr.20061021144014.195">def unselectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='LightSteelBlue1')
        
def selectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    # g.trace(self.numberOfEditors)
    if self.numberOfEditors &gt; 1:
        if not w.leo_label: self.createLabel(w)
        w.leo_label.configure(text=w.leo_label_s,bg='white')
    elif w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None

def createLabel (self,w):

    w.leo_label = Tk.Label(w.leo_frame)
    w.pack_forget()
    w.leo_label.pack(side='top')
    w.pack(expand=1,fill='both')
</t>
<t tx="ekr.20061021144014.196">def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
     
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        w = self.editorWidgets.get('1')
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w) # Immediately create the label in the old editor.
   
    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    &lt;&lt; create label and text widgets &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.197">f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,f,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
w.see('1.0')
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
</t>
<t tx="ekr.20061021144014.198">def setEditorColors (self,bg,fg):
    
    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
</t>
<t tx="ekr.20061021144014.199">def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20061021144014.200">def onClick (self,w):
    
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('body'):
        g.trace('can not happen')
        return

    self.selectEditor(w)</t>
<t tx="ekr.20061021144014.201">def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
        # Inactivate the previously active editor.
        # Don't capture ivars here! selectMainEditor keeps them up-to-date.
        for key in d.keys():
            w2 = d.get(key)
            if w2 != w and w2.leo_active:
                w2.leo_active = False
                self.unselectLabel(w2)
                w2.leo_scrollBarSpot = w2.yview()
                w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
                w2.leo_selection = g.app.gui.getSelectionRange(w2)
                break
        else:
            if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20061021144014.202">if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20061021144014.203">def selectMainEditor (self,p):
    
    
    '''Called from tree.select to select the present body editor.'''

    c = self.c ; p = c.currentPosition() ; w = self.bodyCtrl

    # Don't inject ivars if there is only one editor.
    if w.leo_p is not None:
        # Keep w's ivars up-to-date.
        w.leo_p = p.copy()
        w.leo_v = p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w)
        # g.trace(w.leo_name,p.headString())
</t>
<t tx="ekr.20061021144014.204">def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.frame.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.205">def setColorFromConfig (self,w=None):
    
    c = self.c
    if not w: w = self.bodyCtrl
    
    bg = c.config.getColor("body_text_background_color") or 'white'
    # g.trace(id(w),bg)
    
    try: w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: w.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20061021144014.206">def setFontFromConfig (self,w=None):

    c = self.c
    
    if not w: w = self.bodyCtrl
    
    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
    
    self.fontRef = font # ESSENTIAL: retain a link to font.
    w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
</t>
<t tx="ekr.20061021144014.207">def hasFocus (self):
    
    return self.bodyCtrl == self.frame.top.focus_displayof()
    
def setFocus (self):
    
    self.c.widgetWantsFocus(self.bodyCtrl)
</t>
<t tx="ekr.20061021144014.208">def forceFullRecolor (self):
    
    self.forceFullRecolorFlag = True
</t>
<t tx="ekr.20061021144014.209">@
I could have used this to redirect all calls from the body class and the bodyCtrl to Tk. OTOH:

1. Most of the wrappers do more than the old Tk routines now and
2. The wrapper names are more discriptive than the Tk names.

Still, using the Tk names would have had its own appeal.  If I had prefixed the tk routine with tk_ the __getatt__ routine could have stripped it off!
@c

if 0: # This works.
    def __getattr__(self,attr):
        return getattr(self.bodyCtrl,attr)
        
if 0: # This would work if all tk wrapper routines were prefixed with tk_
    def __getattr__(self,attr):
        if attr[0:2] == "tk_":
            return getattr(self.bodyCtrl,attr[3:])
</t>
<t tx="ekr.20061021144014.210">def bbox(self,index):

    return self.bodyCtrl.bbox(index)
</t>
<t tx="ekr.20061021144014.211"># Could have been replaced by the __getattr__ routine above...
# 12/19/03: no: that would cause more problems.

def tag_add (self,tagName,index1,index2):
    self.bodyCtrl.tag_add(tagName,index1,index2)

def tag_bind (self,tagName,event,callback):
    self.bodyCtrl.tag_bind(tagName,event,callback)

def tag_configure (self,colorName,**keys):
    self.bodyCtrl.tag_configure(colorName,keys)

def tag_delete(self,tagName):
    self.bodyCtrl.tag_delete(tagName)
    
def tag_names(self,*args): # New in Leo 4.4.1.
    return self.bodyCtrl.tag_names(*args)

def tag_remove (self,tagName,index1,index2):
    return self.bodyCtrl.tag_remove(tagName,index1,index2)
</t>
<t tx="ekr.20061021144014.212">def cget(self,*args,**keys):
    
    val = self.bodyCtrl.cget(*args,**keys)
    
    if g.app.trace:
        g.trace(val,args,keys)

    return val
    
def configure (self,*args,**keys):
    
    # g.trace(args,keys)
    
    return self.bodyCtrl.configure(*args,**keys)
</t>
<t tx="ekr.20061021144014.213">def getBodyPaneHeight (self):
    
    return self.bodyCtrl.winfo_height()

def getBodyPaneWidth (self):
    
    return self.bodyCtrl.winfo_width()
</t>
<t tx="ekr.20061021144014.214">def scheduleIdleTimeRoutine (self,function,*args,**keys):

    self.bodyCtrl.after_idle(function,*args,**keys)
</t>
<t tx="ekr.20061021144014.215"></t>
<t tx="ekr.20061021144014.216">def adjustIndex (self,index,offset):
    
    t = self.bodyCtrl
    return t.index("%s + %dc" % (t.index(index),offset))
</t>
<t tx="ekr.20061021144014.217">def compareIndices(self,i,rel,j):

    return self.bodyCtrl.compare(i,rel,j)
</t>
<t tx="ekr.20061021144014.218">def convertRowColumnToIndex (self,row,column):
    
    return self.bodyCtrl.index("%s.%s" % (row,column))
</t>
<t tx="ekr.20061021144014.219">def convertIndexToRowColumn (self,index):
    
    index = self.bodyCtrl.index(index)
    start, end = string.split(index,'.')
    return int(start),int(end)
</t>
<t tx="ekr.20061021144014.220">def getImageIndex (self,image):
    
    return self.bodyCtrl.index(image)
</t>
<t tx="ekr.20061021144014.221">def tkIndex(self,index):
    
    """Returns the canonicalized Tk index."""
    
    if index == "start": index = "1.0"
    
    return self.bodyCtrl.index(index)
</t>
<t tx="ekr.20061021144014.222"></t>
<t tx="ekr.20061021144014.223">def getPythonInsertionPoint (self,t=None,s=None):
    
    b = self
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    i = t.index("insert")
    row,col = b.convertIndexToRowColumn(i)
    
    return g.convertRowColToPythonIndex(s,row-1,col)
    
def setPythonInsertionPoint (self,i,t=None,s=None):
    
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    t.mark_set( 'insert','%d.%d' % (row+1,col))
</t>
<t tx="ekr.20061021144014.224">def getBeforeInsertionPoint (self):
    
    return self.bodyCtrl.index("insert-1c")

def getInsertionPoint (self):
    
    return self.bodyCtrl.index("insert")
</t>
<t tx="ekr.20061021144014.225">def getCharAtInsertPoint (self):
    
    s = self.bodyCtrl.get("insert")
    return g.toUnicode(s,g.app.tkEncoding)

def getCharBeforeInsertPoint (self):

    s = self.bodyCtrl.get("insert -1c")
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.226">def makeInsertPointVisible (self):
    
    self.bodyCtrl.see("insert") # -5l")
</t>
<t tx="ekr.20061021144014.227">def setInsertionPoint (self,index):
    self.bodyCtrl.mark_set("insert",index)

def setInsertionPointToEnd (self):
    self.bodyCtrl.mark_set("insert","end")
    
def setInsertPointToStartOfLine (self,lineNumber): # zero-based line number
    self.bodyCtrl.mark_set("insert",str(1+lineNumber)+".0 linestart")
</t>
<t tx="ekr.20061021144014.228">def bind (self,*args,**keys):
    
    return self.bodyCtrl.bind(*args,**keys)
</t>
<t tx="ekr.20061021144014.229"></t>
<t tx="ekr.20061021144014.230">def deleteTextSelection (self):
    
    t = self.bodyCtrl
    sel = t.tag_ranges("sel")
    if len(sel) == 2:
        start,end = sel
        if t.compare(start,"!=",end):
            t.delete(start,end)
</t>
<t tx="ekr.20061021144014.231">def getSelectedText (self):
    
    """Return the selected text of the body frame, converted to unicode."""

    start, end = self.getTextSelection()
    if start and end and start != end:
        s = self.bodyCtrl.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u'' # Bug fix: 1/8/06
</t>
<t tx="ekr.20061021144014.232">def getTextSelection (self,sort=True):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    w = self.bodyCtrl
    
    sel = w.tag_ranges("sel")

    if len(sel) == 2:
        # New in 4.4a5: match behavior of g.app.gui.getTextSelection.
        if sort:
            i,j = sel
            if w.compare(i, "&gt;", j):
                i,j = j,i
        return sel
    else:
        # Return the insertion point if there is no selected text.
        insert = w.index("insert")
        return insert,insert
</t>
<t tx="ekr.20061021144014.233">def getPythonTextSelection (self):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    b = self ; t = self.bodyCtrl
    sel = t.tag_ranges("sel")

    if len(sel) == 2:
        s = t.get('1.0','end')
        i,j = sel
        row,col = b.convertIndexToRowColumn(i)
        i1 = g.convertRowColToPythonIndex(s,row-1,col)
        row,col = b.convertIndexToRowColumn(j)
        i2 = g.convertRowColToPythonIndex(s,row-1,col)
        return i1,i2
    else:
        # Return the insertion point if there is no selected text.
        i = self.getPythonTextSelection()
        return i,i
</t>
<t tx="ekr.20061021144014.234">def setPythonTextSelection(self,i,j):

    t = self.bodyCtrl
    s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    i1 = '%d.%d' % (row+1,col)
    row,col = g.convertPythonIndexToRowCol(s,j)
    i2 = '%d.%d' % (row+1,col)
    g.app.gui.setTextSelection(self.bodyCtrl,i1,i2)
</t>
<t tx="ekr.20061021144014.235">def hasTextSelection (self):

    sel = self.bodyCtrl.tag_ranges("sel")
    return sel and len(sel) == 2
</t>
<t tx="ekr.20061021144014.236">def selectAllText (self,event=None):
    
    '''Select all text in the presently selected pane.'''
    
    c = self.c ; k = c.k

    try:
        w = c.get_focus() ; wname = c.widget_name(w)
        n = 0
        if wname.startswith('head'):
            s = w.get('1.0','end')
            while s.endswith('\n') or s.endswith('\r'):
                s = s[:-1] ; n += 1
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
        elif wname.startswith('mini'):
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j)
        else:
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
    except:
        # g.es_exception()
        pass
</t>
<t tx="ekr.20061021144014.237">def setTextSelection (self,i,j=None,insert='sel.end'):
    
    # Allow the user to pass either a 2-tuple or two separate args.
    if i is None:
        i,j = "1.0","1.0"
    elif len(i) == 2:
        i,j = i

    g.app.gui.setTextSelection(self.bodyCtrl,i,j,insert)
</t>
<t tx="ekr.20061021144014.238"></t>
<t tx="ekr.20061021144014.239">def deleteAllText(self):
    self.bodyCtrl.delete("1.0","end")

def deleteCharacter (self,index):
    t = self.bodyCtrl
    t.delete(t.index(index))
    
def deleteLastChar (self):
    self.bodyCtrl.delete("end-1c")
    
def deleteLine (self,lineNumber): # zero based line number.
    self.bodyCtrl.delete(str(1+lineNumber)+".0","end")
    
def deleteLines (self,line1,numberOfLines): # zero based line numbers.
    self.bodyCtrl.delete(str(1+line1)+".0",str(1+line1+numberOfLines-1)+".0 lineend")
    
def deleteRange (self,index1,index2):
    t = self.bodyCtrl
    t.delete(t.index(index1),t.index(index2))
</t>
<t tx="ekr.20061021144014.240"></t>
<t tx="ekr.20061021144014.241">def getAllText (self):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get("1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.242">def getCharAtIndex (self,index):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get(index)
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.243">def getInsertLines (self):
    
    """Return before,after where:
        
    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.
    
    All lines end in a newline, except possibly the last line."""
    
    t = self.bodyCtrl

    before = t.get("1.0","insert linestart")
    ins    = t.get("insert linestart","insert lineend + 1c")
    after  = t.get("insert lineend + 1c","end")

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
</t>
<t tx="ekr.20061021144014.244">def getSelectionAreas (self):
    
    """Return before,sel,after where:
        
    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    t = self.bodyCtrl
    
    sel_index = t.getTextSelection()
    if len(sel_index) == 2:
        i,j = sel_index
        sel = t.get(i,j)
    else:
        i = j = t.index("insert")
        sel = ""

    before = t.get("1.0",i)
    after  = t.get(j,"end")
    
    before = g.toUnicode(before,g.app.tkEncoding)
    sel    = g.toUnicode(sel,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)
    return before,sel,after
</t>
<t tx="ekr.20061021144014.245">def getSelectionLines (self):
    
    """Return before,sel,after where:
        
    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""
    
    # At present, called only by c.getBodyLines.

    t = self.bodyCtrl
    sel_index = t.tag_ranges("sel") 
    if len(sel_index) != 2:
        if 1: # Choose the insert line.
            index = t.index("insert")
            sel_index = index,index
        else:
            return "","","" # Choose everything.

    i,j = sel_index
    i = t.index(i + "linestart")
    j = t.index(j + "lineend") # 10/24/03: -1c  # 11/4/03: no -1c.
    before = g.toUnicode(t.get("1.0",i),g.app.tkEncoding)
    sel    = g.toUnicode(t.get(i,j),    g.app.tkEncoding)
    after  = g.toUnicode(t.get(j,"end-1c"),g.app.tkEncoding)
    
    # g.trace(i,j)
    return before,sel,after
</t>
<t tx="ekr.20061021144014.246">def getTextRange (self,index1,index2):
    
    t = self.bodyCtrl
    return t.get(t.index(index1),t.index(index2))
</t>
<t tx="ekr.20061021144014.247"></t>
<t tx="ekr.20061021144014.248">def insertAtInsertPoint (self,s):
    
    self.bodyCtrl.insert("insert",s)
</t>
<t tx="ekr.20061021144014.249">def insertAtEnd (self,s):
    
    self.bodyCtrl.insert("end",s)
</t>
<t tx="ekr.20061021144014.250">def insertAtStartOfLine (self,lineNumber,s):
    
    self.bodyCtrl.insert(str(1+lineNumber)+".0",s)
</t>
<t tx="ekr.20061021144014.251">def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)
</t>
<t tx="ekr.20061021144014.252">def makeIndexVisible (self,index):
    
    self.bodyCtrl.see(index)
    
def setFirstVisibleIndex (self,index):
    
    self.bodyCtrl.yview("moveto",index)
    
def getYScrollPosition (self):
    
    return self.bodyCtrl.yview()
    
def setYScrollPosition (self,scrollPosition):

    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.yview("moveto",first)
    
def scrollUp (self):
    
    self.bodyCtrl.yview("scroll",-1,"units")
    
def scrollDown (self):

    self.bodyCtrl.yview("scroll",1,"units")
</t>
<t tx="ekr.20061021144014.253">@nocolor

I hate to constantly be the bearer of bad news, but:

exception executing command
Traceback (most recent call last):
   File 
"/mnt/usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoCommands.py", 
line 263, in doCommand
     val = command(event)
   File 
"/mnt/usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/plugins/rst3.py", 
line 677, in rst3PluginCallback
     self.processTopTree(c.currentPosition())
TypeError: processTopTree() takes exactly 3 arguments (2 given)

Cheers -Terry

</t>
<t tx="ekr.20061021144014.254">@nocolor

&gt;&gt; Sorry, the css in the .html doesn't include leo_rst.css 
&gt;&gt; silver_city.css, that's just in the default.css it's looking in 
&gt;&gt; the wrong place for.

&gt; Coming in in the middle of a conversation like this, I have no 
&gt; idea what you are talking about.

Hmmm, my second email amending my first email must have reached you 
before my first email... not helpful.  My first email is repeated 
below, the second email was just saying I mispoke about where those
include statements were.

But maybe you should just address these two points, as they 
represent the current state of my understanding of rst3 css 
problems.

1) On 'Write restructured text' I get "stylesheet does not exist: 
/mnt/proj/ItascaLegacy/default.css" - leo seems to be looking one 
directory too high, the .html file being written and the .css 
files are in /mnt/proj/ItascaLegacy/app/

2) http://www.w3.org/TR/REC-CSS2/cascade.html#at-import 
unfortunately says "Any @import rules must precede all rule sets in 
a style sheet." and Firefox at least ignores them otherwise, so your 
default.css, which has them at the end, needs looking at on this 
point.

Cheers -Terry

---------- Forwarded message ----------
From: Terry Brown &lt;tbrown@nrri.umn.edu&gt;
To: Edward K. Ream &lt;edreamleo@charter.net&gt;
Date: Wed, 18 Oct 2006 14:03:02 -0500 (CDT)
Subject: rst3...


Some problems with rst3

     ignoring unknown option: doc_mode_only

no problem, but it was in the example on Leo's homepage

     stylesheet does not exist: /mnt/proj/ItascaLegacy/default.css

This is true, but /mnt/proj/ItascaLegacy/app/default.css does
exist, and /mnt/proj/ItascaLegacy/app/ is where Leo's writing
the .html file to.  The @rst node just says
'@rst itascatooldoc.html', and the .leo file's in /mnt/proj/ItascaLegacy/app/.

I.e. it seems to be looking one directory higher than it should for 
default.css.

The .html file includes a default rst3 style sheet within it that
includes leo_rst.css  silver_city.css, but the .html file never
refers to default.css.  But maybe this is just a flow on effect
of looking for it in the wrong place.

Cheers -Terry
</t>
<t tx="ekr.20061021144014.255">@

Double-clicking  @url &lt;leo-fille&gt; did not bring Leo file to top

onTreeClick was being called after the double-click handling.
The fix was the c.doubleClickFlag logic.</t>
<t tx="ekr.20061021144014.256"></t>
<t tx="ekr.20061021144014.257">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            &lt;&lt; stop the url after any whitespace &gt;&gt;
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06</t>
<t tx="ekr.20061021144014.258"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
</t>
<t tx="ekr.20061021144014.259">if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
</t>
<t tx="ekr.20061021144014.260">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()</t>
<t tx="ekr.20061021144014.261">def onTreeClick (self,event=None):
    
    '''Handle an event in the tree canvas, outside of any tree widget.'''
    
    c = self.c
    
    # New in Leo 4.4.2: a kludge: disable later event handling after a double-click.
    # This allows focus to stick in newly-opened files opened by double-clicking an @url node.
    if c.doubleClickFlag:
        c.doubleClickFlag = False
    else:
        c.treeWantsFocusNow()
    
    return 'break'
</t>
<t tx="ekr.20061021144014.262">set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""

                
    if not g.app.unitTesting and c and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        # Do not call trace here: that might affect focus!
        print 'gui.set_focus: %4d %10s %s' % (
            self.set_focus_count,c and c.shortFileName(),
            c and c.widget_name(w)), g.callers(5)
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
</t>
<t tx="ekr.20061021144014.263"></t>
<t tx="ekr.20061021144014.264">@nocolor

- @bool write_recent_files_as_needed = True

People who don't want Leo to update .leoRecentFiles.txt can set this to False.

- Remove .leoRecentFiles from cvs
- Remove .leoRecentFiles from distribution list.

@color</t>
<t tx="ekr.20061021144014.265">def __init__ (self):
    
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.modeCommandsDict = {} # For use by @mode logic. Keys are command names, values are g.Bunches.
    self.myGlobalConfigFile = None
    self.myHomeConfigFile = None
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
</t>
<t tx="ekr.20061021144014.266">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []

    # This can't be done in initSettingsFiles because the local directory does not exits.
    localDirectory = g.os_path_dirname(fileName)
    
    #  Set the local leoSettings.leo file.
    localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
    if not g.os_path_exists(localConfigFile): localConfigFile = None
    
    # Set the local myLeoSetting.leo file.
    myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
    if not g.os_path_exists(myLocalConfigFile): myLocalConfigFile = None
    
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Init settings from leoSettings.leo files, including myLeoSettings.leo.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            if c and localFlag:
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
            self.readRecentFilesFile(c,path)
    if self.write_recent_files_as_needed:
        self.createRecentFiles(fileName)

    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20061021144014.267">def readRecentFilesFile (self,c,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'
    
    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    if not g.os_path_exists(fileName):
        # g.trace('does not exist',fileName)
        return
        
    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return

    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
        self.appendToRecentFiles(lines)</t>
<t tx="ekr.20061021144014.268">def createRecentFiles (self,fileName):
    
    localPath,junk = g.os_path_split(fileName)

    for path in (g.app.homeDir,g.app.globalConfigDir,localPath):
        fileName = g.os_path_join(path,'.leoRecentFiles.txt')
        if g.os_path_exists(fileName):
            # g.es_print('found %s' % fileName)
            return

    # Create the file in the home directory.
    try:
        fileName = g.os_path_join(g.app.homeDir,'.leoRecentFiles.txt')
        f = file(fileName,'w')
        f.close()
        g.es_print('Created %s' % (fileName),color='red')
        return
    except Exception:
        g.es_print('Exception creating %s' % (fileName),color='red')
        g.es_exception()</t>
<t tx="ekr.20061021144014.269">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,'.leoRecentFiles.txt')
            if g.os_path_exists(fileName):
                # g.es_print('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        g.trace('----- not found:',localFileName)
        return
</t>
<t tx="ekr.20061021144014.270">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061021144014.271">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3588148
By: vpe

One way to make Leo more newbie friendly is to add menu items for key features
that are likely to cause confusion in the beginning.

What I did:
    
- Added minibuffer submenu.
- Renamed help to help-for-minibuffer
- Added Pickers submenu
- Added help-for-settings command

@color</t>
<t tx="ekr.20061021144014.272">def defineCmdsMenuTables (self):
    
    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPanesTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()</t>
<t tx="ekr.20061021144014.273">def defineCmdsMenuAbbrevTable (self):
    
    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20061021144014.274">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]</t>
<t tx="ekr.20061021144014.275">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20061021144014.276">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]
    
    self.cursorMenuForwardTable = [
        # &amp;: b,c,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20061021144014.277">def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20061021144014.278">def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-keyboard-macro',
        '&amp;insert-keyboard-macro',
    ]
</t>
<t tx="ekr.20061021144014.279">def defineCmdsMenuMinibufferTable (self):
    
    self.cmdsMenuMinibufferTable = [
        # &amp;: f,h,i,q,r,s,v
        '&amp;full-command',
        'keyboard-&amp;quit',
        '&amp;repeat-complex-command',
        '&amp;view-lossage',
        '-',
        '&amp;show-mini-buffer',
        'h&amp;ide-mini-buffer',
        '-',
        '&amp;help-for-minibuffer',
    ]
</t>
<t tx="ekr.20061021144014.280">def defineCmdsMenuPanesTable (self):

    self.cmdsMenuPanesTable = [
        # &amp;: a,b,d,f,l,n,o,p,u,x,y
        'contract-&amp;body-pane',
        'contract-&amp;log-pane',
        'contract-&amp;outline-pane',
        'contract-&amp;pane',
        '-',
        'expand-bo&amp;dy-pane',
        'expand-lo&amp;g-pane',
        'expand-o&amp;utline-pane',
        'expand-pa&amp;ne',
        '-',
        '&amp;fully-expand-body-pane',
        'full&amp;y-expand-log-pane',
        'fully-e&amp;xpand-outline-pane',
        'fully-exp&amp;and-pane',
    ]
    </t>
<t tx="ekr.20061021144014.281">def defineCmdsMenuPickersTable (self):
    
    self. cmdsMenuPickersTable = [
        'show-&amp;colors',
        'show-find-&amp;options',
        'show-&amp;fonts',
    ]</t>
<t tx="ekr.20061021144014.282">def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20061021144014.283">def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20061021144014.284">def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-&amp;down',
        'scroll-&amp;up',
        '-',
        'scroll-down-&amp;extend-selection',
        'scroll-up-e&amp;xtend-selection',
    ]</t>
<t tx="ekr.20061021144014.285">def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20061021144014.286">def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &amp;: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&amp;beautify',
        'beautify-&amp;all',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]</t>
<t tx="ekr.20061021144014.287">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20061021144014.288">def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&amp;Cmds')
    
    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &amp;: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Cursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('M&amp;inibuffer',         self.cmdsMenuMinibufferTable),
        ('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('Pic&amp;kers...',         self.cmdsMenuPickersTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',     self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,t,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &amp;To...',                self.cursorMenuExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20061021144014.289">def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &amp;: a,b,c,d,f,h,l,m,n,o,p,r,s,t,u
        ('&amp;About Leo...',           'about-leo'),
        ('Online &amp;Home Page',       'open-online-home'),
        '*open-online-&amp;tutorial',
        '*open-&amp;users-guide',
        '-',
        ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
        ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
        '-',
        '*he&amp;lp-for-minibuffer',
        '*help-for-&amp;command',
        '-',
        '*&amp;apropos-autocompletion',
        '*apropos-&amp;bindings',
        '*apropos-&amp;find-commands',
        '-',
        '*pri&amp;nt-bindings',
        '*print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20061021144014.290"># It's not clear how to specify a setting for unicode characters.
# Leo crashes on do-nothing = ц</t>
<t tx="ekr.20061021144014.291">def doNothing (self,event):
    
    '''A placeholder command, useful for testing bindings.'''

    g.trace()</t>
<t tx="ekr.20061021144014.292"># This is much more visible.</t>
<t tx="ekr.20061021144014.293">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''
    
    k = self.k
    
    if 1:
        g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Autocompleter ',color='blue')
        frame.putStatusLine(g.choose(k.enable_autocompleter,'On','Off'))
    
def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    if 1:
        g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Calltips ',color='blue')
        frame.putStatusLine(g.choose(k.enable_calltips,'On','Off'))</t>
<t tx="ekr.20061021144014.294">@nocolor

Added support for @bool sparse_move_outline_left

When True, Leo collapses the (former) parent of a node when moving that node left.
Takes getting used to, but I like it.

Note that the move-outline-up/down commands can have the effect of moving an outline left.

@color</t>
<t tx="ekr.20061021144014.295"></t>
<t tx="ekr.20061021144014.296">def demote (self,event=None):
    
    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext():
        c.treeWantsFocusNow()
        return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            c.treeWantsFocusNow()
            return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(current)  # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.297">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):
    
    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next:
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.298">parent = p.parent()

if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)
        
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20061021144014.299">def moveOutlineLeft (self,event=None):
    
    '''Move the selected node left if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasParent():
        c.treeWantsFocusNow()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20061021144014.300">def moveOutlineRight (self,event=None):
    
    '''Move the selected node right if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasBack:
        c.treeWantsFocusNow()
        return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeWantsFocusNow()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.301">def moveOutlineUp (self,event=None):
    
    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.302">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())
    
parent = p.parent()

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(oldRoot=c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20061021144014.303">def promote (self,event=None):
    
    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        c.treeWantsFocusNow()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.304"># At long last Leo creates a proper help menu on the Mac.</t>
<t tx="ekr.20061021144014.305">def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&amp;Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)</t>
<t tx="ekr.20061021144014.306">def getMacHelpMenu (self):
    
    try:
        topMenu = self.getMenu('top')
        # Use the name argument to create the special Macintosh Help menu.
        helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        self.createMenuEntries(helpMenu,self.helpMenuTable)
        return helpMenu

    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None</t>
<t tx="ekr.20061021144014.307">This would greatly simplify menu entries.</t>
<t tx="ekr.20061021144014.308"># This is an important step towards making all menus configurable.</t>
<t tx="ekr.20061021144014.309"># \(\"(.*)\",.*\),  --&gt; '\1',</t>
<t tx="ekr.20061021144014.310">def capitalizeMinibufferMenuName (self,s,removeHyphens):
    
    result = []
    for i in xrange(len(s)):
        ch = s[i]
        prev = i &gt; 0 and s[i-1] or ''
        prevprev = i &gt; 1 and s[i-2] or ''
        if (
            i == 0 or
            i == 1 and prev == '&amp;' or
            prev == '-' or
            prev == '&amp;' and prevprev == '-'
        ):
            result.append(ch.capitalize())
        elif removeHyphens and ch == '-':
            result.append(' ')
        else:
            result.append(ch)
    return ''.join(result)</t>
<t tx="ekr.20061021144014.311">def defineMenuTables (self):
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20061021144014.312">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20061021144014.313">def defineEditMenuTopTable (self):
    
    self.editMenuTopTable = [
        # &amp;: u,r reserved for undo/redo: a,d,p,t,y.
        # &amp; (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&amp;t','cut-text'),
        ('Cop&amp;y','copy-text'),
        ('&amp;Paste','paste-text'),
        ('&amp;Delete','backward-delete-char'),
        ('Select &amp;All','select-all'),
        '-',
    ]
</t>
<t tx="ekr.20061021144014.314">def defineEditMenuEditBodyTable (self):
    
    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&amp;section',
        '*extract-&amp;names',
        '*&amp;extract',
        '-',
        '*convert-all-b&amp;lanks',
        '*convert-all-t&amp;abs',
        '*convert-&amp;blanks',
        '*convert-&amp;tabs',
        '*insert-body-&amp;time',
        '*&amp;reformat-paragraph',
        '-',
        '*&amp;indent-region',
        '*&amp;unindent-region',
        '*&amp;match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
</t>
<t tx="ekr.20061021144014.315">def defineEditMenuEditHeadlineTable (self):
    
    self.editMenuEditHeadlineTable = [
        '*edit-&amp;headline',
        '*&amp;end-edit-headline',
        '*&amp;abort-edit-headline',
        '*insert-headline-&amp;time',
        '*toggle-&amp;angle-brackets',
    ]
</t>
<t tx="ekr.20061021144014.316">def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&amp;open-find-tab',
        '*&amp;hide-find-tab',
        '*search-&amp;with-present-options',
        '-',
        '*find-tab-find-&amp;next',
        '*find-tab-find-&amp;prev',
        '*find-tab-&amp;change',
        '*find-tab-find-&amp;all',
        '*clone-fi&amp;nd-all',
        '*find-tab-change-a&amp;ll',
        '-',
        '*&amp;find-character',
        '*find-character-extend-&amp;selection',
        '*&amp;backward-find-character',
        '*backward-find-character-&amp;extend-selection',
        '-',
        '*&amp;isearch-forward',
        '*isea&amp;rch-backward',
        '*isearch-forward-rege&amp;xp',
        '*isearch-backward-regex&amp;p',
        '-',
        '*&amp;query-replace',
        '*q&amp;uery-replace-regex',
    ]
</t>
<t tx="ekr.20061021144014.317">def defineEditMenuTop2Table (self):
    
    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        '*&amp;goto-global-line',
        '*&amp;execute-script',
        (label,'toggle-invisibles'),
        ("Setti&amp;ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20061021144014.318">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20061021144014.319">def defineFileMenuTopTable (self):
    
    self.fileMenuTopTable = [
        '*&amp;new',
        ('&amp;Open...','open-outline'),
    ]
</t>
<t tx="ekr.20061021144014.320">def defineFileMenuTop2Table (self):
    
    self.fileMenuTop2Table = [
        '-',
        ('&amp;Close','close-window'),
        ('&amp;Save','save-file'),
        ('Save &amp;As','save-file-as'),
        ('Save &amp;To','save-file-to'),
        ('Re&amp;vert To Saved','revert'),
    ]
</t>
<t tx="ekr.20061021144014.321">def defineFileMenuReadWriteMenuTable (self):
    
    self.fileMenuReadWriteMenuTable = [
        '*&amp;read-outline-only',
        ('Read @file &amp;Nodes','read-at-file-nodes'),
        ('Write &amp;Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &amp;Missing @file Nodes','write-missing-at-file-nodes'),
        '*write-&amp;outline-only',
        ('&amp;Write @file Nodes','write-at-file-nodes'),
    ]
</t>
<t tx="ekr.20061021144014.322">def defineFileMenuTangleMenuTable (self):
    
    self.fileMenuTangleMenuTable = [
        '*tangle-&amp;all',
        '*tangle-&amp;marked',
        '*&amp;tangle',
    ]
</t>
<t tx="ekr.20061021144014.323">def defineFileMenuUntangleMenuTable (self):
    
    self.fileMenuUntangleMenuTable = [
        '*untangle-&amp;all',
        '*untangle-&amp;marked',
        '*&amp;untangle',
    ]
</t>
<t tx="ekr.20061021144014.324">def defineFileMenuImportMenuTable (self):
    
    self.fileMenuImportMenuTable = [
        #&amp;: c,d,f,n,o,r,
        '*import-&amp;derived-file',
        ('Import To @&amp;file','import-at-file'),
        ('Import To @&amp;root','import-at-root'),
        '*import-&amp;cweb-files',
        '*import-&amp;noweb-files',
        '*import-flattened-&amp;outline',
    ]
</t>
<t tx="ekr.20061021144014.325">def defineFileMenuExportMenuTable (self):
    
    self.fileMenuExportMenuTable = [
        '*export-&amp;headlines',
        '*outline-to-&amp;cweb',
        '*outline-to-&amp;noweb',
        '*&amp;flatten-outline',
        '*&amp;remove-sentinels',
        '*&amp;weave',
    ]
</t>
<t tx="ekr.20061021144014.326">def defineFileMenuTop3MenuTable (self):
    
    self.fileMenuTop3MenuTable = [
        ('E&amp;xit','exit-leo'),
    ]
</t>
<t tx="ekr.20061021144014.327">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20061021144014.328">def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&amp;ut-node',
        '*c&amp;opy-node',
        '*&amp;paste-node',
        ('Pas&amp;te Node As Clone','paste-retaining-clones'),
        '*&amp;delete-node',
        '-',
        '*&amp;insert-node',
        '*&amp;clone-node',
        '*sort-childre&amp;n',
        '*&amp;sort-siblings',
        '-',
        '*&amp;hoist',
        ('D&amp;e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20061021144014.329">def defineOutlineMenuCheckOutlineMenuTable (self):
    
    self.outlineMenuCheckOutlineMenuTable = [
        # &amp;: a,c,d,o
        '*check-&amp;outline',
        '*&amp;dump-outline',
        '-',
        '*check-&amp;all-python-code',
        '*&amp;check-python-code',
    ]
</t>
<t tx="ekr.20061021144014.330">def defineOutlineMenuExpandContractMenuTable (self):
    
    self.outlineMenuExpandContractMenuTable = [
        '*&amp;contract-all',
        '*contract-&amp;node',
        '*contract-&amp;parent',
        '*contract-or-go-&amp;left',
        '-',
        '*expand-p&amp;rev-level',
        '*expand-n&amp;ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&amp;1',
        '*expand-to-level-&amp;2',
        '*expand-to-level-&amp;3',
        '*expand-to-level-&amp;4',
        '*expand-to-level-&amp;5',
        '*expand-to-level-&amp;6',
        '*expand-to-level-&amp;7',
        '*expand-to-level-&amp;8',
        '-',
        '*expand-&amp;all',
        '*expand-n&amp;ode',
    ]
</t>
<t tx="ekr.20061021144014.331">def defineOutlineMenuMoveMenuTable (self):
    
    self.outlineMenuMoveMenuTable = [
        ('Move &amp;Down','move-outline-down'),
        ('Move &amp;Left','move-outline-left'),
        ('Move &amp;Right','move-outline-right'),
        ('Move &amp;Up','move-outline-up'),
        '-',
        '*&amp;promote',
        '*&amp;demote',
    ]
</t>
<t tx="ekr.20061021144014.332">def defineOutlineMenuMarkMenuTable (self):
    
    self.outlineMenuMarkMenuTable = [
        '*&amp;mark',
        '*mark-&amp;subheads',
        '*mark-changed-&amp;items',
        '*mark-changed-&amp;roots',
        '*mark-&amp;clones',
        '*&amp;unmark-all',
    ]
</t>
<t tx="ekr.20061021144014.333">def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &amp;: a,c,d,e,g,i,l,m,n,o,p,r,s,t,v,x
        ('Go Prev Visite&amp;d','go-back'),
        ('Go Next Visited','go-forward'),
        ('Go To P&amp;rev Node','goto-prev-node'),
        ('Go To N&amp;ext Node','goto-next-node'),
        '-',
        ('Go To Next &amp;Marked','goto-next-marked'),
        ('Go To Next &amp;Changed','goto-next-changed'),
        ('Go To Next &amp;Clone','goto-next-clone'),
        '-',
        ('&amp;Go To First Node','goto-first-node'),
        ('G&amp;o To Prev Visible','goto-prev-visible'),
        ('Go To Ne&amp;xt Visible','goto-next-visible'),
        ('Go To L&amp;ast Node','goto-last-node'),
        ('Go To Last &amp;Visible','goto-last-visible'),
        '-',
        ('Go To &amp;Parent','goto-parent'),
        ('Go To First &amp;Sibling','goto-first-sibling'),
        ('Go To Last S&amp;ibling','goto-last-sibling'),
        ('Go To Prev Sibli&amp;ng','goto-prev-sibling'),
        ('Go To Next Siblin&amp;g','goto-next-sibling'),
    ]
</t>
<t tx="ekr.20061021144014.334">def defineWindowMenuTables (self):
    
    self.windowMenuTopTable = [
        # &amp;: a,c,e,m,o,p,r,s
        '*&amp;equal-sized-panes',
        '*toggle-&amp;active-pane',
        '*toggle-&amp;split-direction',
        '-',
        '*&amp;resize-to-screen',
        '*&amp;cascade-windows',
        '*&amp;minimize-all',
        '-',
        '*&amp;open-compare-window',
        '*open-&amp;python-window',
    ]
</t>
<t tx="ekr.20061021144014.335"># The open-scripts-leo command.</t>
<t tx="ekr.20061021144014.336">def openLeoScripts (self,event=None):
    
    c = self
    fileName = g.os_path_join(g.app.loadDir,'..','scripts','scripts.leo')

    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es('not found: %s' % fileName)
</t>
<t tx="ekr.20061021144014.337"></t>
<t tx="ekr.20061021144014.338">@others
</t>
<t tx="ekr.20061021144014.339">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20061021144014.340">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20061021144014.341">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20061021144014.342">def openSpellTab (self,event=None):
    
    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()
</t>
<t tx="ekr.20061021144014.343"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20061021144014.344">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others
</t>
<t tx="ekr.20061021144014.345"></t>
<t tx="ekr.20061021144014.346">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()
</t>
<t tx="ekr.20061021144014.347">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)
    
    # if not self.aspell.aspell:
    if not self.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
</t>
<t tx="ekr.20061021144014.348">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)
</t>
<t tx="ekr.20061021144014.349">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
</t>
<t tx="ekr.20061021144014.350">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
</t>
<t tx="ekr.20061021144014.351"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
</t>
<t tx="ekr.20061021144014.352">def createBindings (self):
    
    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
</t>
<t tx="ekr.20061021144014.353">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
</t>
<t tx="ekr.20061021144014.354"></t>
<t tx="ekr.20061021144014.355">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()
</t>
<t tx="ekr.20061021144014.356">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()
</t>
<t tx="ekr.20061021144014.357">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
</t>
<t tx="ekr.20061021144014.358">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.359">def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()
</t>
<t tx="ekr.20061021144014.360"></t>
<t tx="ekr.20061021144014.361">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
</t>
<t tx="ekr.20061021144014.362">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20061021144014.363">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.364">def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []
</t>
<t tx="ekr.20061021144014.365">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
</t>
<t tx="ekr.20061021144014.366"></t>
<t tx="ekr.20061021144014.367">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')
</t>
<t tx="ekr.20061021144014.368">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
</t>
<t tx="ekr.20061021144014.369">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20061021144014.370">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20061021144014.371">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
</t>
<t tx="ekr.20061021144014.372">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)
</t>
<t tx="ekr.20061021144014.373">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.374">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.375">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
</t>
<t tx="ekr.20061021144014.376">class AspellClass:
    
    """A wrapper class for Aspell spell checker"""
    
    @others
</t>
<t tx="ekr.20061021144014.377"></t>
<t tx="ekr.20061021144014.378">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))
    
    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]
    
    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)
    
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    self.use_ctypes = g.CheckVersion(version,'2.5')
    self.aspell = self.sc = None
    
    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
</t>
<t tx="ekr.20061021144014.379">def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)</t>
<t tx="ekr.20061021144014.380">def getAspellWithCtypes (self):
    
    import ctypes
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    aspell = ctypes.CDLL(g.os_path_join(self.aspell_bin_dir, "aspell-15.dll"))

    &lt;&lt; define and configure aspell entry points &gt;&gt;

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
</t>
<t tx="ekr.20061021144014.381"># new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]</t>
<t tx="ekr.20061021144014.382">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it 
    """
    
    if self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
</t>
<t tx="ekr.20061021144014.383">def suggestions(self,word):

    "return list of words found"
    
    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList</t>
<t tx="ekr.20061021144014.384">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False
</t>
<t tx="ekr.20061021144014.385"></t>
<t tx="ekr.20061021144014.386">@nocolor

I think to make it as X-windowish as possible it should paste the 
selection, rather than the contents of the clipboard, when there is 
a selection.

Perhaps paste is the wrong word. In X-windows, when you middle-button-click in a
text frame, and there is a selection somewhere in the text frame, the contents
of that selection is inserted at the point you clicked - even if the insertion
cursor is elsewhere (e.g. at the end of the selection).
</t>
<t tx="ekr.20061021144014.387">@nocolor

If the selection is in a different frame, e.g. the log frame, middle 
button click in the body frame first pastes the clipboard text, then 
pastes the selected text in the middle of it :-} It should just 
paste the selected text.
</t>
<t tx="ekr.20061021144014.388">def OnPaste (self,event=None):
    
    return self.pasteText(event=event,middleButton=True)</t>
<t tx="ekr.20061021144014.389"></t>
<t tx="ekr.20061021144014.390">def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
</t>
<t tx="ekr.20061021144014.391">def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = g.app.gui.getAllText(w)
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s=g.app.gui.getAllText(w)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20061021144014.392">def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = g.app.gui.getTextSelection(w)  # Returns insert point if no selection.
    oldText = w.get('1.0','end')
    
    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)
    
    if middleButton and c.k.previousSelection:
        start,end = c.k.previousSelection
        s = w.get(start,end)
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20061021144014.393"></t>
<t tx="ekr.20061021144014.394">http://sourceforge.net/forum/message.php?msg_id=3958380
By: paulpaterson

Printing from the KeyBindings plugin is broken. The fix is,

Change (line 306, printKeys()): 

fname = os.path.abspath(g.os_path_join("..", "plugins", "keyreport.html"))

To:

fname = os.path.abspath(g.os_path_join("..", "..", "plugins",
"keyreport.html"))


(Note the additional "..")

It appears that the current directory in use when running Leo has changed to
/Leo/test/plugins ?!</t>
<t tx="ekr.20061021144014.395">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?</t>
<t tx="ekr.20061021144014.396">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3959003
By: nobody

The node navigator plugin does not show up in the plugins menu (also happens
in Leo4.4.1.1)

The quick fix was to revert to the default module-level __name__ attribute.
Presumably a better fix involves the plugins manager plugin.

The use of this plugin decreases when moving through the outline without the
mouse. Maybe some setting could be introduced to only include a node to the
'Recent' list when it has had focus for more than, say, 5 seconds? Or being
edited, of course.

Another suggestion might be to set _named_ marks for a (line in a?) node a la
vim (where its shortcut is m&lt;markname&gt;). I can remember about 3 or 4 marks when
analyzing code, and switching by only using the keyboard (shortcuts '&lt;markname&gt;
or `&lt;markname&gt;) works very good (for me) in vim. Switching between the two most
recent marks is done in vim using the shortcut '' or ``.
</t>
<t tx="ekr.20061021144014.397">@nocolor

(via email) Terry Brown</t>
<t tx="ekr.20061021144014.398">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3962632
By: paulpaterson

This isn't a problem in the manager or plugins menu as such - the plugins_menu
uses the __name__ attribute of a module to identify what to display. This shouldn't
be changed or the plugin wont display in the menu.

If you want to display a nice name in the plugins menu then you set the
__plugin_name__ attribute of a plugin.

There are four current plugins that break this rule,

nodenavigator
wordexport
newbuttons
rowcol

(ironically I had a hand in a few of those!)

All these plugins should have the line,

__name__ = "ldaldjalks"

replaced with

__plugin_name__ = "kjldldasd"


Regards,

Paul

</t>
<t tx="ekr.20061021144014.399">- Every button created by the plugin creates a corresponding command.  The command name is the 'cleaned' version of the button name.

- Every button created by the plugin also creates a delete-x-button command, where x is the command name as just discussed.  So now you can delete script buttons without right-clicking.

- I took the time to revise, refactor, clean up, reorganize and better document the code.  This was overdue: the previous code had grown difficult to understand through multiple small accretions.  I can actually understand the new code.

- This *might* have fixed the following crasher:

http://sourceforge.net/forum/message.php?msg_id=3962483
By: ktenney

right click on icon bar @button results in TK exception

TclError Exception in Tk callback
  Function: &lt;bound method Balloon._destroy of &lt;_Pmw.Pmw_1_2.lib.PmwBalloon.Balloon
instance at 0x020B2EB8&gt;&gt; (type: &lt;type 'instancemethod'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x01FB93C8&gt;,)
  Event type: DestroyNotify (type num: 17)
Traceback (innermost last):
  File "c:\python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747,
in __call__
    return apply(self.func, args)
  File "c:\python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBalloon.py", line 283,
in _destroy
    self.withdraw()
  File "&lt;string&gt;", line 1, in withdraw
    None
  File "c:\python24\lib\lib-tk\Tkinter.py", line 1541, in wm_withdraw
    return self.tk.call('wm', 'withdraw', self._w)
TclError: bad window path name ".20325440.23282432.23282712.34285688.33264144"
</t>
<t tx="ekr.20061021144014.400"></t>
<t tx="ekr.20061021144014.401">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3963935
By: terry_n_brown

Not working for me, with

@multipath /mnt/120/usr1/home/tbrown

or

@multipath /home/tbrown

the former being the symbolic link free form of the latter, but both fail the
same way, so I don't think  it's a symbolic link problem.

If /home/tbrown/itaseval.py doesn't exist I get:

multifile:  
Cant write itaseval.py to /mnt/120/usr1/home/tbrown
IOError, [Errno 2] No such file or directory: u'itaseval.py'

If I make it a zero length file I get

multifile:
Cant write itaseval.py to /mnt/120/usr1/home/tbrown
Error, `itaseval.py` and `/mnt/120/usr1/home/tbrown/itaseval.py` are the same
file

As I said /mnt/120/usr1/home/tbrown and /home/tbrown are equivalent, I was just
trying both to see if it's a symbolic link problem, but it doesn't seem to be.
</t>
<t tx="ekr.20061021144014.402">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3963657

This crash was due to the recent changes in the mod_scripting plugin, which the
shortcut_button plugin uses. The new code is much simpler than the old, and does
more.</t>
<t tx="ekr.20061021144014.403"></t>
<t tx="ekr.20061021144014.404">@nocolor

As always, you can set max_undo_stack_size in myLeoSettings.leo.</t>
<t tx="ekr.20061021144014.405">A highly useful option.
However, creating a new node always selects the entire text, regardless of this options.
</t>
<t tx="ekr.20061021144014.406">def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove('sel','1.0','end')
        selectAll = selectAll or c.config.getBool('select_all_text_when_editing_headlines')
        start = g.choose(selectAll,'1.0','end')
        w.tag_add('sel',start,'end')
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
</t>
<t tx="ekr.20061021144014.407">def editLabel (self,p,selectAll=False):
    
    """Start editing p's headline."""

    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
</t>
<t tx="ekr.20061021144014.408">def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20061021144014.409"># Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)
        c.frame.tree.editLabel(p,selectAll=selectAll)
        
        if k:
            k.setDefaultUnboundKeyAction()
            k.showStateAndMode()
</t>
<t tx="ekr.20061021144014.410">@nocolor

- Added bindings for toggle-autocompleter (Alt-1) and toggle-calltips (Alt-2)

- Ctrl-. and ctrl-( do not seem to do anything.

** Mystery solved: there was a trace in the calltip logic!

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off. It's been added to a 'later'
section of the to-do list.</t>
<t tx="ekr.20061021144014.411">@nocolor

Added the node: Candidates for settings in myLeoSettings.leo. This lists the
most 'controversial' settings in leoSetting.leo, and is a quick-start to
creating myLeoSettings.leo."
</t>
<t tx="ekr.20061021144014.412">- Added shift-ctrl keys to extend the selection.
focus-to-body = Alt-D
focus-to-tree = Alt-T
toggle-extend-mode = Alt-3</t>
<t tx="ekr.20061021144014.413">@nocolor

By: tibi ( Thiébaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
&lt; v = current.insertAsNthChild(0)
---
&gt; v = current.insertAsLastChild()

What I did:
    
Added @bool insert_new_nodes_at_end

@color</t>
<t tx="ekr.20061029091751.1"></t>
<t tx="ekr.20061029091751.2"></t>
<t tx="ekr.20061029091751.3">def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
</t>
<t tx="ekr.20061029091751.4">def initSettingsFiles (self):
    
    """Set self.globalConfigFile, self.homeFile and self.myConfigFile."""
    
    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    
    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)</t>
<t tx="ekr.20061029091751.5">def readSettingsFiles (self,fileName,verbose=True):
        
    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
    # Read all .leoRecentFiles.txt files.
    # The order of files in this list affects the order of the recent files list.
    seen = []
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20061029091751.6"># This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20061029091751.7"></t>
<t tx="ekr.20061029091751.8">def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()</t>
<t tx="ekr.20061029091751.9">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok</t>
<t tx="ekr.20061029091751.10">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20061029091751.11">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061029091811"></t>
<t tx="ekr.20061029091811.1"></t>
<t tx="ekr.20061029091811.2"></t>
<t tx="ekr.20061029091811.3">Typing in leoDocs.leo will show the problem.</t>
<t tx="ekr.20061029091811.4">def skip_string(s,i,verbose=True):
    
    '''Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True'''
    
    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')
    
    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20061029091811.5">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = self.editWidget(event)
    if not w: return 'break'

    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w) or (None,None)
    oldText = name.startswith('body') and p.bodyString() or ''
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    brackets = self.openBracketsList + self.closeBracketsList
    inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
    
    if trace: g.trace(name,repr(ch),ch in brackets)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)
        if inBrackets and self.flashMatchingBrackets: # New in 4.4.1.
           self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'
        
    # New in 4.4.1: Set the column for up and down keys.
    spot = w.index('insert')
    c.editCommands.setMoveCol(spot)

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20061029091811.6">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    if (
        (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
        undoType != "Change"
    ):
        # No auto-indent if in @nocolor mode or after a Change command.
        self.updateAutoIndent(p,w)
</t>
<t tx="ekr.20061029091811.7">def test_selfInsertCommand(self):
    
    self = c.editCommands
    event = g.Bunch(char='É',keysym=None,widget=c.frame.body.bodyCtrl)
    self.selfInsertCommand(event)</t>
<t tx="ekr.20061029091811.8">def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20061029091811.9">def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20061029091811.10">def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    def addFlashCallback(w,count,index):
        w.tag_add('flash',index,'%s+1c' % (index))
        w.after(delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        w.tag_remove('flash','1.0','end')
        if count &gt; 0:
            w.after(delay,addFlashCallback,w,count,index)

    try:
        w.tag_configure('flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass
</t>
<t tx="ekr.20061029091811.11">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
</t>
<t tx="ekr.20061029091811.12"># By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
</t>
<t tx="ekr.20061029091811.13">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
</t>
<t tx="ekr.20061029091811.14">def skip_matching_python_delims(s,i,delim1,delim2,reverse=False):
    
    '''Skip from the opening delim to the matching delim2.
    
    Return the index of the matching ')', or -1'''
    
    level = 0 ; n = len(s)
    assert(g.match(s,i,delim1))
    if reverse:
         while i &gt;= 0:
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i -= 1
            # Doesn't handle strings and comments properly...
            else: i -= 1
    else:
        while i &lt; n:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i += 1
            elif ch == '\'' or ch == '"': i = g.skip_string(s,i,verbose=False)
            elif g.match(s,i,'#'):  i = g.skip_to_end_of_line(s,i)
            else: i += 1
            if i == progress: return -1
    return -1
</t>
<t tx="ekr.20061029091811.15">@nocolor
@language python

http://sourceforge.net/forum/message.php?msg_id=3971242
By: nobody

I just tried to use mod_shadow plugin the first time and it took me sometime
to figure out that I immediately triggered a bug.

The problem is, that I use c++ as programming language, but leo only provides an
\@language c directive. This is OK for colorizing, but it prevents the mod_shadow
plugin to derive the correct file name extension from the language directive (at
least that´s what I guessed from the error messages). To fix it I simply copied
all c language entries in leoApp.py to create cpp new similar cpp language
entries. I have not tried to understand the code that triggers this error in
detail, so I don´t know if this fixes all issues, but at least it seems to work
at the moment.

@color</t>
<t tx="ekr.20061029091811.16"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20061029091811.17"></t>
<t tx="ekr.20061029091811.18">def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
</t>
<t tx="ekr.20061029091811.19">@nocolor

Two body editors open looking at the same node, so you can write 
code at the bottom of the body based on something close to the top. 
Let's say the top pane's showing a data structure defined a page or 
so down from the start of the body, and the bottom pane's showing a
method you're writing at the bottom on the body.

As soon as you enter a character in the bottom pane the point of 
view of the top pane snaps back to the first line of the body, no 
damage caused but now you can't see the datastructure definition you 
were using for reference.

This probably indicates that the body should be split into more than 
one node... but thought I'd let you know it was doing that anyway.

--------------

Still something funky I'm afraid.  Two body panes one above the 
other looking at the same body text.

Say each one is displaying 10 lines.

In one I scroll down to view lines 80-90 by dragging the scroll bar 
on the right, but when I click line 85 to position the cursor it 
jumps to line 5.

@color</t>
<t tx="ekr.20061029091811.20">def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    # Inactivate the previously active editor.
    # Don't capture ivars here! selectMainEditor keeps them up-to-date.
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
            w2.leo_selection = g.app.gui.getSelectionRange(w2)
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            break
    else:
        if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20061029091811.21"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20061029091811.22">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20061029091811.23">def onClick (self,event):
    
    c = self.c ; k = c.k
    w = event and event.widget
    wname = c.widget_name(w)
    
    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        x, y = event.x, event.y
        k.previousSelection = g.app.gui.getSelectionRange(w)
        i = w.index('@%s,%s' % (x,y))
        # g.trace(x,y,i)
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')</t>
<t tx="ekr.20061029091811.24">def createTextWidget (self,frame,parentFrame,p,name):
    
    c = self.c
    
    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = w = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    
    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y)
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)
   
    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
    w.leo_active = True
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w</t>
<t tx="ekr.20061029091811.25">@nocolor

The new colorizer was innocent: the problem is that at.directiveKind4 uses leoColor.leoKeywords,
so multipath must add entroes to leoColor.leoColors.

This should be changed, but it is too late in the development cycle to do more than put a band-aid on the problem.

@color</t>
<t tx="ekr.20061029091811.26">def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
</t>
<t tx="ekr.20061029091811.27">def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20061029091811.28"># leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" ]
</t>
<t tx="ekr.20061029091811.29"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i &lt; n:
        if s[i] == '@' and i+1 &lt; n:
            &lt;&lt; set theDict for @ directives &gt;&gt;
        elif root and g.match(s,i,"&lt;&lt;"):
            &lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;
        i = g.skip_line(s,i)
    return theDict
</t>
<t tx="ekr.20061029091811.30">j = g.skip_c_id(s,i+1)
word = s[i+1:j]

global globalDirectiveList

if word in globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
</t>
<t tx="ekr.20061029091811.31">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
</t>
<t tx="ekr.20061029091811.32">@ 

New colorizer did not handle @&lt;newline&gt; properly.
(It required a space after the '@').</t>
<t tx="ekr.20061029091811.33">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3975898

If the setting "@int initial_window_left" has a value of 0 (zero), leo starts
up without showing a single pane.

@color</t>
<t tx="ekr.20061029091811.34">def setInitialWindowGeometry(self):
    
    """Set the position and size of the frame to config params."""
    
    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10
    
    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
</t>
<t tx="ekr.20061029091811.35">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3978307
By: johnmwhite

The auto-creation of .leoRecentFiles.txt doesn't seem to work. Everything is
fine if myLeoSettings.leo is in the home directory along with .leoRecentFiles.txt,
but strange things happen if .leoRecentFiles.txt does not exist.

----

I simply removed a very misleading message in writeRecentFiles.</t>
<t tx="ekr.20061029091811.36"></t>
<t tx="ekr.20061029091811.37">def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
</t>
<t tx="ekr.20061029091811.38">def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) &gt; 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
</t>
<t tx="ekr.20061029091811.39">def computeLeoDir ():
    
    loadDir = g.app.loadDir
    
    g.app.leoDir = theDir = g.os_path_dirname(loadDir)
    
    if theDir not in sys.path:
        sys.path.append(theDir)
        
    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
</t>
<t tx="ekr.20061029091811.40">def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        ### import leo
        import sys
        
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) &gt; 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
</t>
<t tx="ekr.20061029091811.41">def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    if 0:
        import sys
        for s in sys.path: g.trace(s)
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
        
    g.app.leoDir = g.computeLeoDir()
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
        
    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
</t>
<t tx="ekr.20061029091811.42">def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
</t>
<t tx="ekr.20061029091811.43"></t>
<t tx="ekr.20061029091811.44">def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()</t>
<t tx="ekr.20061029091811.45">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok</t>
<t tx="ekr.20061029091811.46">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20061029091811.47">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061029091811.48"></t>
<t tx="ekr.20061029091811.49">@nocolor

See the node Users Guide--&gt;Chapter 18: Emacs and Leo in LeoDocs.leo for full details.</t>
<t tx="ekr.20061029091811.50"># It is set by tkFrame.finishCreate</t>
<t tx="ekr.20061029091811.51">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame</t>
<t tx="ekr.20061029091811.52">def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    app = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = app.gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
        
    frame.finishCreate(c)
    c.finishCreate()
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
</t>
<t tx="ekr.20061029091811.53"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20061029091811.54">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            if c.config.getBool('outline_pane_has_initial_focus'):
                c.treeWantsFocusNow()
            else:
                c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20061029091811.55">def run(fileName=None,pymacs=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    &lt;&lt; start psycho &gt;&gt;
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20061029091811.56"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
</t>
<t tx="ekr.20061029091811.57">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20061029091811.58">if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        g.app.use_psyco = False
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
        g.app.use_psyco = False
</t>
<t tx="ekr.20061029091811.59">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20061029091811.60">def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
</t>
<t tx="ekr.20061029091811.61">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20061029091811.62">def getBatchScript ():
    
    import leoGlobals as g
    windowFlag = False
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script, windowFlag
</t>
<t tx="ekr.20061029091811.63">def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
</t>
<t tx="ekr.20061029091811.64">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3980193

What I'm needing is 2 commands:

1) move cursor to the end of the current word (if cursor is in a word) or end
of next word (if cursor is not in a word), WITHOUT SELECTING - the functionality
of Ctrl-RtArrow in normal editors

2) extend selection from current cursor position to the end of the current or
next word - the functionality of Shift-Ctrl-RtArrow in normal editors.

EKR: The term 'normal' editor is misleading.  There are two different ways of moving forward:
forward-word and forward-end-word.

@color</t>
<t tx="ekr.20061029091811.65">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]
    
    self.cursorMenuForwardTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;end-word',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;end-word-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20061029091811.66">def getPublicCommands (self):        

    c = self.c ; k = self.k 

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20061029091811.67">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)
    
def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)
        
def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20061029091811.68">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    c.widgetWantsFocusNow(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)

    i = toPython(w.index('insert'))
    
    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1
    
    self.moveToHelper(event,toGui(i),extend)</t>
<t tx="ekr.20061029091811.69">def runEditCommandTest (c,p):
    
    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)
    
    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    
    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        g.app.gui.setTextSelection(w,sel1[0],sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'expected body: %s, got: %s' % (repr(s1),repr(s2))
        sel3 = g.app.gui.getTextSelection(w)
        assert sel2 == sel3, 'expected sel: %s, got: %s' % (sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20061029091830"></t>
<t tx="ekr.20070105153901">@language c
@nocolor</t>
<t tx="ekr.20070105153901.1">Storage allocation is crucial to any compiler because of the number, size and
complexity of data which must be allocated. You would not be far off to say that
a compiler consists of storage allocation and everything else. Indeed, the
design of CC2 was driven by the goal of creating the token list quickly, and
that goal has far-reaching implications for how memory is allocated.

CC2 allocates objects one-at-a-time (simple allocation), in blocks of
fixed-sized objects (block allocation) or in blocks of variable-sized objects
(stream allocation). Simple allocation requires just a single macro call, but
results in a call to calloc for each object allocated. It is appropriate only
for infrequently allocated data structures. Block allocation and stream
allocation are optimizations which reduce calls to calloc by more than an order
of magnitude.
</t>
<t tx="ekr.20070105153901.2">I have recently made some discoveries concerning storage allocation and register
allocation that promise to significantly improve CC2. These discoveries were
surprising because they seemed to contradict either common sense or conclusions
based on performance measurements. Happily, the new code is significantly
smaller and measurably faster than the old code!

These discoveries can be summarized as follows:

- There is no speed penalty for having the stream reservation macros use a
  subroutine to allocate a new stream block. This came as a shock, though the
  reason is clear in retrospect.

- Streams are polymorphic: they may contain items of varying types.

- Streams are defined primarily by their lifetime and only secondarily by their type.

- Lists are special-purpose streams.

- Abbreviation macros highlight relationships among source text, while removing
  the actual source text from view.
</t>
<t tx="ekr.20070105153901.3">Block allocation allocates an array of items all of the same size and kind from
a area of memory obtained from calloc. In the front end, hash table nodes and
some kinds of tokens are allocated using block allocation. Block allocation will
be used extensively in the parser and code generator to allocate nodes for
parsing, semantic analysis and code generation.
</t>
<t tx="ekr.20070105153901.4">Stream allocation allocates a stream block, then adds variable-sized items to
the block until the stream block is nearly full, at which time another stream
block is allocated. Steam blocks contain a stream avail count to keep track of
what is in the stream. The first unused portion of the stream block is
calculated from the stream avail count.

The definition of "nearly full" depends on the individual stream. Because stream
allocation is tricky, the details are hidden by two sets of macros. **Stream
reservation macros** allocate another stream block when the current block is
nearly full. **Stream put macros** add an element to the stream without checking
to see if the stream block is big enough to hold it. I shall speak of stream put
macros being protected by stream reservation macros. Because of differences
between streams, there are separate reservation and put macros for each distinct
stream. While tokenize uses stream allocation for both tokens and streams, the
details of stream allocation for tokens and streams differ substantially.

Tokens form a packed list--tokens usually follow one right after another.
Packing the list eliminates the need for a next token pointer and saves a lot of
space. At the end of a token block a HIDDEN_END_BLOCK_TOK is inserted so that
the next token in the token list can be found. Therefore, a token block is
"almost full" when there is no longer room for an arbitrary token and a
HIDDEN_END_BLOCK_TOK. Tokens have a maximum size, BIG_TOKEN_SIZE. Since
HIDDEN_END_BLOCK_TOK is a big token, a token block is "almost full" when less
than 2 * BIG_TOKEN_SIZE bytes remain.

Strings are handled differently from tokens because strings may be arbitrarily
large but are not part of a list. sreserve_macro is the stream reservation macro
for the string stream. scopy_macro and big_scopy_macro are the put macros for
the string stream.

Huge strings are strings larger than the size of the string space in a string
block. big_scopy_macro allocates string space for huge tokens, creating a block
just big enough to hold the huge string. Such a block does not contain avail or
used counts. big_scopy_macro need not be protected since it always creates its
own string block. By the way, huge strings are seldom allocated now that
multi-line comments are split into one COMMENT_TOK per line.

Normal strings, i.e., strings smaller than the size of a stream block, are
allocated by the scopy_macro. A string block is "almost full" when the next
string to be allocated will not fit in the current block. This wastes some space
if the string to be allocated is large and the current block is almost empty but
not empty enough. Fortunately, large strings are rare so I have ignored this
waste.

The extra work involved in using stream reserve and put macros produces a
spectacular increase in speed of tokenize. Among the benefits:

- Crucial pointers may be allocated in registers throughout the lifetime of
  tokenize. These registers are never unloaded because there are no function calls
  inside tokenize!

- The compiler is able to generate perfect code without doing any global
  optimization. Local code optimization is sufficient to produce code as good as
  would be produced by an excellent assembly language coder.

- There are no get-next-character or put_next_token routines. Earlier versions
  of tokenize, using such routines, ran more than 5 times slower than the present
  version.

- Storage is allocated in uniformly sized blocks, not in small pieces. This
  keeps calloc happy.
</t>
<t tx="ekr.20070105153901.5">tokenize is called in a variety of contexts: to tokenize the main file, header
files, pasted strings, and command-line #define's and #undef's. Many calls to
tokenize create short token lists so it would be very wasteful for tokenize to
create new token and string blocks each time it was called. Also, the hash table
must be retained between calls so that all variables with the same spelling have
the same pointer to the spelling table. The global variables tok_block_list,
str_block_list and sym_hash_list are used to keep track of the current token,
string and hash blocks, respectively.

The compiler allocates strings for several purposes outside of tokenize. Such
strings could often be allocated in a string block, but that would be clumsy.
The str_alloc macros allocate a list object big enough to hold the list pointer
and the actual string.  We put strings on a list so they can be deallocated easily...
</t>
<t tx="ekr.20070105153901.6">**The proper time to specify when an object will be deallocated is when the object
if created**. This simple rule was a big Aha.

All object allocation macros take a parameter specifying a deallocation list. If
the parameter is non-NULL, the allocation macro places the newly created object
on the list. Objects on deallocation lists are freed in the following places:

- At the end of cpp. All preprocessing objects not part of the token list are
  freed here.

- In comp_free_all. Objects which are logically part of the token list may only
  be freed when the entire source file has been compiled. comp_free_all is
  called at the start of compile in the production version of the compiler, and
  it is called at the end of compile in the debugging version. In the debugging
  version we want to make sure that all objects are eventually freed. In the
  production version, the objects used by the last compiled file need never be
  freed, a small time gain.

Objects are placed on no deallocation list in the following situations:
		
- When object are deallocated in the routine in which they are allocated. This
  is seldom used, since most such objects can be allocated on the stack.
  Variable-length objects could be freed in this way.
		
- The ap_first and ap_last arrays are allocated in mac_get_actuals but freed in
  mac_expand.
</t>
<t tx="ekr.20070105153901.7">Debugging objects and production objects are allocated, used and freed in
exactly the same way. However, debugging objects provide increased statistics
and error-checking capabilities. Debugging objects are created by the object
macros when the OBJ_DEBUG compile-time constant is defined. Otherwise,
production objects are created.

Debugging objects contain several fields not found in production objects:

- Lists fields: All debugging objects are placed on lists. These lists ensure
  that obj_free frees only objects. These lists are also used to check the
  integrity of all objects.

- Statistics fields.

- Header and trailer protection fields. These fields are filled with a fixed bit
  pattern when the object is allocated. The fields are checked on request, and
  certainly when the object is freed. This provides an excellent, though not
  foolproof, test for over-writing a buffer allocated by calloc. Using these
  protection fields has found some bugs that otherwise would have been really
  tough to find.
</t>
<t tx="ekr.20070105153901.8">The original treserve_macro was too large to include in each call to put_id_tok,
put_small_tok, etc. The macro was large because I wanted to avoid a
function call here. Similar kinds of function calls had grossly slowed down
previous versions of tokenize. However, I was surprised when measurements showed
that a function call here does not matter at all. So the new version of
treserve_macro, called tok_protect_macro, is::

	#define tok_protect_macro(tp, tavail)\
	if (tavail &lt; MAX_TOKEN_SIZE) {\
		tp = tok_new_block(tp, tavail);\
		tavail = tok_avail;\
	}

The tok_new_block allocates a new token block, sets two global variables,
tok_ptr and tok_avail and returns tok_ptr.

In retrospect, it is clear why a function call is acceptable here. tok_new_block
is called when a new block of tokens is required. An average token comprises
almost exactly 4 characters and there are about 200 tokens per block so
tok_new_block is called only about once every 800 input characters. The function
that had previously slowed down tokenize so much was called once every input
character. Clearly, the overhead of calling tok_new_block is 3 orders of
magnitude smaller.

Because tok_protect_macro is so much smaller than treserve_macro,
tok_protect_macro can be made part of the various stream put macros, such as
put_small_tok.  This ensures that tok_protect_macro is called as needed.

Using function calls in allocation macros creates opportunities for more
simplifications. The put_comment_string_macro no longer exists--tokenize simply
calls str_copy2block, which handles all the details::

	/* Output a comment string token */
	put_ptr(WS_COMMENT_TOK,str_copy2block(string_start, string_length), comments);
 
Simplifying the code to allocate strings created more opportunities to simplify
the code...
</t>
<t tx="ekr.20070105153901.9">Global variables [nowadays we would use ivars of stream classes] drastically
simplify defining a stream. Especially in the back end, streams are used across
numerous functions so there is no possibility of keeping important stream
variables in registers anyway. This was an Aha--defining a stream involves
defining a complex of global variables. [Nowadays we would make each stream a
class.] For instance, the globals [ivars] needed to define the string stream
are::

	string_block * str_block_list = NULL; /* List of string blocks. */
	long	 str_avail = 0;	  /* Available bytes in current block. */
	char * str_ptr = NULL;	/* Pointer to first free byte. */

These variables are all controlled by str_copy2block, so they are benign. In
addition to these essential stream variables, it is useful to define global
stream statistics::

	long	str_blocks; /* Total allocated string blocks. */
	long	str_bytes;		/* Total bytes in strings. */
	long	str_number;	/* Number of strings. */
	long	str_waste;		/* Total wasted bytes. */

Previous schemes required a different kind of block for every kind of allocated
item. Actually allocating an item from such a block was clumsy. There is a much
better way. If global variables are used to keep track of streams, it became
clear that streams themselves have a global nature. [Nowadays we would have
global instances of stream objects.] In addition, both the token stream and the
string stream deals with variable size items, so streams may be composed of a
variety of different **kinds** of items.

If streams may contain different kinds of items, what determines which items go
in which streams? The answer is so simple: a stream is defined by its lifetime,
i.e., when the whole stream is deallocated.

Looking back at the documentation on storage allocation, I am struck by the
section called Deallocating Objects. My subconscious was apparently telling me
that when objects were deallocated was more important than I consciously
realized at the time. This section is not just describing how to free objects;
it tells us how to define streams! In short::

    Streams may contain items of varying sizes and types
    as long as all items of a stream are deallocated at the same time,
    i.e., if all items have the same lifetime.

In practice, it may be convenient to have several streams that are deallocated
at the same time.
</t>
<t tx="ekr.20070105153901.10">The CC2 compiler uses a separate stream (the cs stream) for all items to be in
comp_free_all at the end of compile phase. The cs_ptr and cs_avail global
variables are just like the str_ptr and str_avail variables. The cs_put,
cs_protect and cs_new_block macros suffice to allocate any kind of item that
share this lifetime.

Let's look ahead to the parser and code generator. There will be a parser stream
that contains all parse nodes and other nodes that will be freed at the same
time as the parse tree. The code stream will contain all code nodes. Defining
and using these streams will be trivial and will comprise essentially all the
storage allocation for the back end.

The new storage allocation scheme also guarantees absolute highest storage
allocation speed. Indeed, allocating a new parse or code node will require only
one function call per about 200 nodes, so the call-return overhead in calling
cs_new_block can be ignored. It is also clear that the other processing done by
the cs_put macro can not be reduced further, even if written in assembly
language. These discoveries drastically reduce the design, coding and testing
required to allocated and free objects.
</t>
<t tx="ekr.20070105153901.11">Objects in the front end are on only one list, their deallocation list.
Sometimes the deallocation list does double duty, but the fact remains that each
object appears on only one list.

Objects in the back end, however, may be on several lists simultaneously. For
instance, nodes in a parse tree may be threaded. Many overlapping lists of
symbols may need to be maintained. To maintain these lists separate list nodes
will be required. These will be called cons nodes after LISP terminology. The
definition of a cons node will be something like::

	typedef struct cons_struct cons_node;
	struct const_struct {
		void * cons_next;
		void * cons_item;
	}
	
Thousands of such nodes will be needed throughout the back end. Clearly, cons
nodes should be allocated in list blocks to speed the storage allocation
process. When should list blocks be deallocated? The surprising answer is:
usually never. In other words, cons nodes have permanent lifetime. Cons nodes
will be allocated in a special purpose stream, the cons stream.

The cons_new_block macro allocates a new block of cons_nodes and puts them on
an avail list. When an individual cons node is freed, it is simply added to a
list of free cons nodes. Thus, in general list blocks will contain both free and
used cons nodes. cons_new_block is called only when no free cons nodes exist.
List blocks need never be deallocated because free cons nodes will eventually be
reused--unless the number of cons nodes grows truly enormous, there should never
be a need for garbage collection.

There may be some instances when it would save time to deallocate all the cons
nodes of a specialized stream at once. In that case, the cons nodes would be
allocated using a specialized version of the new_cons_node macro.
</t>
<t tx="ekr.20070105153901.12">We could, in fact, allocate *all* items using streams, but this would be going
too far. The object routines provide detailed statistics about objects which are
lost when items are allocated from blocks. Also, the object routines provide
important error checking for the stream blocks themselves. Finally, it would be
silly to have to allocate an entire stream when allocating an object once or
twice is all that is needed. Having said that, it seems to me that streams are a
more fundamental implementation concept than objects. All the fancy object
macros seem to be overshadowed by the elegantly simple stream allocation macros.

Whatever the theoretical relationship between objects and streams, this storage
allocation scheme seems perfect:

- Items may be allocated simply and flexibly with minimal time or space overhead.
- Streams can be created easily for special purposes.
- Blocks can be of uniform size so that minimal stress is put on calloc.
- Objects can be used instead of stream items during development for greater error
  detection and greater resolution of statistics.
</t>
<t tx="ekr.20070105153901.13">One final Aha simplifies the tokenize code considerably. Abbreviation macros
formalize a relationship between source text that could not be efficiently
expressed as a function call. For instance, consider the macro::

	#define put_small(a,b) put_small_tok(tp, tavail, a, b)

This macro shows clearly that all calls to put_small_tok in tokenize
will have tp and tavail as parameters. This relationship could be expressed as a
function call, but not efficiently.

Once I saw how to use put_small to hide the constant details of the calls to
put_small_tok, I was able to generalize the concept of abbreviation macros to
similar situations.</t>
<t tx="ekr.20070105153920"></t>
<t tx="ekr.20070626112503"></t>
<t tx="ekr.20070626112754.2"></t>
<t tx="ekr.20070626112754.3"></t>
<t tx="ekr.20070626112754.4"></t>
<t tx="ekr.20070626112754.5">Example:

print "\\" + " this is a test"

The escape mechanism must treat an even number of trailing escapes as not an escape.</t>
<t tx="ekr.20070626112754.6">@nocolor

- (fixed) Backspace not handled correcly.
- (fixed) Autocompletion eats one too many characters

@color</t>
<t tx="ekr.20070626112754.7"></t>
<t tx="ekr.20070626112754.8">def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    if swapij and backwards: i,j = j,i

    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
</t>
<t tx="ekr.20070626112754.9">def regexHelper (self,s,i,j,pattern,backwards,nocase):

    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i &lt; len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 &lt;= i &lt; len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 &lt;= i &lt; len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
</t>
<t tx="ekr.20070626112754.10">def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n
</t>
<t tx="ekr.20070626112754.11">@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):

    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
</t>
<t tx="ekr.20070626112754.12">def matchWord(self,s,i,pattern):

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 &lt;= i-1 &lt; len(s) and s[i-1] or '.'
    ch2 = 0 &lt;= i+n &lt; len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
</t>
<t tx="ekr.20070626112754.13">def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
</t>
<t tx="ekr.20070626112754.14">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20070626112754.15">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3924236

Added unit tests for yank and all kill commands.

@color</t>
<t tx="ekr.20070626112754.16">@nocolor

Several things became clearer after a short walk in the woods:

- It's a little late in the release cycle to mess with undo, so I'm going to put
off work until Leo 4.4.3. The present code is complex, and should be simplified
if possible. However, the potential for harm is too great to make substantial
change now. Given the complexity of the code, *any* change is a substantial
change :-)

- Some problems with undo may actually be just unexpected results. In
particular, undo typing should 'coalesce', only for actual typing: all other
commands that affect body text (cut, copy, yank and kill in particular) should
be independently undoable regardless of undo granularity. Thus, if you cut,
copy, yank or kill text an immediate undo command should restore the text to
what it was before those commands. This probably doesn't happen now, and that
could be the source of some (all??) undo problems.

Edward

P.S. I recently uncovered some more hard bindings in the yank command. Such
bindings must somehow be removed, and certainly are a symptom that yank does not
yet work as in Emacs. This is a separate issue from undo, so discovering this
problem actually simplifies the undo task to come.
</t>
<t tx="ekr.20070626112754.17">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3972170
By: oculog

Step 1 - add some lines...
line 1
line 2
line 3

Step 2 - cut and paste first line to the end
line 2
line 3
line 1

Step 3 - *Copy* and paste first line to the end x2
line 2
line 3
line 1
line 2
line 2

That's it!  The fourth undo doesn't work right.
</t>
<t tx="ekr.20070626112754.18">class killBufferCommandsClass (baseEditCommandsClass):

    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20070626112754.19">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k

    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20070626112754.20">def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20070626112754.21">def addToKillBuffer (self,text):

    killKeys =(
        '&lt;Control-k&gt;', '&lt;Control-w&gt;',
        '&lt;Alt-d&gt;', '&lt;Alt-Delete', '&lt;Alt-z&gt;', '&lt;Delete&gt;',
        '&lt;Control-Alt-w&gt;')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20070626112754.22">def backwardKillSentence (self,event):

    '''Kill the previous sentence.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.23">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20070626112754.24">def clearKillRing (self,event=None):

    '''Clear the kill ring.'''

    self.killBuffer = []
</t>
<t tx="ekr.20070626112754.25">def getClipboard (self,w):

    __pychecker__ = '--no-argsused' # w not used.

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except:
        g.es_exception()

    return None
</t>
<t tx="ekr.20070626112754.26">def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
</t>
<t tx="ekr.20070626112754.27">def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins &gt;= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j &gt; i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
</t>
<t tx="ekr.20070626112754.28">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)

def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return

    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20070626112754.29">def killSentence (self,event):

    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.30">def killWs (self,event,undoType=None):

    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break

    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.31">def yank (self,event):

    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    i = w.getInsertPoint()
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert(i,s) # Insert the text, marked with the 'kb' tag.
        w.tag_add('kb',w.toGuiIndex(i),w.toGuiIndex(i+len(s)))
        w.setInsertPoint(i+len(s))
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.32">def yankPop (self,event):

    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    t,t1 = g.convertPythonIndexToRowCol(s,ins)
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        s = clip_text or self.kbiterator.next()
        r = w.tag_ranges('kb') ###
        if r:
            r1,r2 = r
            r1,r2 = w.toPythonIndex(r1),w.toPythonIndex(r2)
            if r1 == ins:
                w.delete(r1,r2)
        w.tag_delete('kb') ###
        w.insert('insert',s,('kb')) ###
        w.setInsertPoint(ins)
</t>
<t tx="ekr.20070626112754.33">def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        if ch.isspace(): return
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.34">def undoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="ekr.20070626112754.35">def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
</t>
<t tx="ekr.20070626112754.36">def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    &lt;&lt; Compute the result using p's body text &gt;&gt;
    p.setTnodeText(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
</t>
<t tx="ekr.20070626112754.37"># Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
</t>
<t tx="ekr.20070626112754.38">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991369

The bindings to f.f.OnControlKeyDown/Up were mistakenly deleted in createOuterFrames.

@color</t>
<t tx="ekr.20070626112754.39">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.

    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)

    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)

    f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
    f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)

    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
    # f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)

    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")</t>
<t tx="ekr.20070626112754.40"></t>
<t tx="ekr.20070626112754.41">def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if self.allow_clone_drags:
            if not self.look_for_control_drag_on_mouse_down:
                self.controlDrag = c.frame.controlKeyIsDown

        redrawFlag = vdrag and vdrag.v.t != p.v.t
        if redrawFlag: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")

        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate(redrawFlag)
        c.recolor_now() # Dragging can affect coloring.
</t>
<t tx="ekr.20070626112754.42">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
</t>
<t tx="ekr.20070626112754.43"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
</t>
<t tx="ekr.20070626112754.44"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
</t>
<t tx="ekr.20070626112754.45">def onContinueDrag(self,event):

    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")
</t>
<t tx="ekr.20070626112754.46"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
</t>
<t tx="ekr.20070626112754.47">def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
</t>
<t tx="ekr.20070626112754.48">def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
</t>
<t tx="ekr.20070626112754.49"></t>
<t tx="ekr.20070626112754.50">selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    #  Called by body.onClick and whenever w must be selected.

    if self.selectEditorLockout or w and self.bodyCtrl == w: return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(w)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.

</t>
<t tx="ekr.20070626112754.51">def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if 0:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    self.inactivateActiveEditor(w)

    # The actual switch.
    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if 0:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls assignPositionToEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20070626112754.52"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20070626112754.53">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4112347
By: niccl

I've just found two places where Tk 8.5 breaks Leo:
Two calls to CheckVersion, with tk_patchlevel as a parameter, in leoTkInterGui.py.

Since Tk 8.5 isn't formally released, the patch level is 8.5a5 (at least in
the version I'm using). CheckVersion expects everything to be a digit, and so
barfs on the 5a5. I solved it very crudely by scanning the string returned when
getting the tk_patchlevel and stopping if there's any non-digit and non '.'.
That way I end up with '8.5' as the string to go to check version, and it works
fine.

@color</t>
<t tx="ekr.20070626112754.54"># Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition="&gt;=",stringCompare=None,delimiter='.',trace=False):

    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 &lt; n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 &lt; n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('&lt;',  vals1 &lt;  vals2), ('&lt;=', vals1 &lt;= vals2),
        ('&gt;',  vals1 &gt;  vals2), ('&gt;=', vals1 &gt;= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."

    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result</t>
<t tx="ekr.20070626112754.55">def CheckVersionToInt (s):

    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit(): aList.append(ch)
            else: break
        if aList:
            s = string.join(aList)
            return int(s)
        else:
            return 0</t>
<t tx="ekr.20070626112754.56">if g.unitTesting:

    assert g.CheckVersionToInt('12') == 12,'fail 1'
    assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
    assert g.CheckVersionToInt('b2') == 0, 'fail 3'</t>
<t tx="ekr.20070626112754.57"></t>
<t tx="ekr.20070626112754.58"># The problem was that the unit test code must now specify the initial insert point.</t>
<t tx="ekr.20070626112754.59">def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i &lt; j and s[i] in (' \t'):
        i += 1
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.60">def runEditCommandTest (c,p):

    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)

    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))

    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        #g.trace(repr(sel1[0]),repr(sel1[1]))
        w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s2),repr(s1))
        sel3 = w.getSelectionRange()
        ins = w.toGuiIndex(w.getInsertPoint())
        #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
        # Convert both selection ranges to gui indices.
        sel2_orig = sel2
        # g.trace(w)
        i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
        i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
        assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate(False) # Don't redraw.</t>
<t tx="ekr.20070626112754.61">def setInsertPoint (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    # g.trace(i,g.callers())
    Tk.Text.mark_set(w,'insert',i)
</t>
<t tx="ekr.20070626112754.62">def setSelectionRange (self,i,j,insert=None): # tkTextWidget

    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())

    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, "&gt;", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
</t>
<t tx="ekr.20070626112754.63"></t>
<t tx="ekr.20070626112754.64">def toGuiIndex (self,i):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # This *must* be 'end-1c', even if other code must change.
        s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i</t>
<t tx="ekr.20070626112754.65">def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
</t>
<t tx="ekr.20070626112754.66"># This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return '%s.%s' % (row+1,col)</t>
<t tx="ekr.20070626112754.67">@nocolor

- There was a call to t.setSelectionRanget(t,...)
- No progress is being made in change, then find.

@color</t>
<t tx="ekr.20070626112754.68">def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()

    s = w.getAllText()
    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    &lt;&lt; fail if we are passed the wrap point &gt;&gt;
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
</t>
<t tx="ekr.20070626112754.69">if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos &lt; self.wrapPos:
        # g.trace("wrap done")
        return None, None

    if not self.reverse and newpos &gt; self.wrapPos:
        return None, None
</t>
<t tx="ekr.20070626112754.70"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start &gt; end: start,end = end,start
    if start == end:
        g.es("No text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
</t>
<t tx="ekr.20070626112754.71">def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j &lt; n:
        k = s.find('\\',j)
        if k == -1 or k + 1 &gt;= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn &lt; len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
</t>
<t tx="ekr.20070626112754.72"></t>
<t tx="ekr.20070626112754.73">def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    w = self.editWidget(event)
    if not w: return 'break'
    &lt;&lt; set local vars &gt;&gt;
    #g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i &gt; j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
</t>
<t tx="ekr.20070626112754.74">c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch and ch in brackets)</t>
<t tx="ekr.20070626112754.75">def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()</t>
<t tx="ekr.20070626112754.76">def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'

    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20070626112754.77">def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20070626112754.78">def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
</t>
<t tx="ekr.20070626112754.79">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins&lt;len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
</t>
<t tx="ekr.20070626112754.80">def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.scanColorDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
</t>
<t tx="ekr.20070626112754.81">def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.

    if i != j:
        w.delete(i,j)

    if tab_width &gt; 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]

        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)</t>
<t tx="ekr.20070626112754.82">def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toGuiIndex(index),w.toGuiIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count &gt; 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()</t>
<t tx="ekr.20070626112754.83">def findMatchingBracket (self,event=None):

    '''Select the text between matching brackets.'''

    c = self ; w = c.frame.body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    s = w.getAllText()
    ins = w.getInsertPoint()
    ch1 = 0 &lt;= ins-1 &lt; len(s) and s[ins-1] or ''
    ch2 = 0 &lt;= ins   &lt; len(s) and s[ins] or ''
    # g.trace(repr(ch1),repr(ch2),ins)

    # Prefer to match the character to the left of the cursor.
    if ch1 and ch1 in brackets:
        ch = ch1 ; index = max(0,ins-1)
    elif ch2 and ch2 in brackets:
        ch = ch2 ; index = ins
    else:
        return

    index2 = self.findMatchingBracketHelper(s,ch,index)
    # g.trace('index,index2',index,index2)
    if index2 is not None:
        if index2 &lt; index:
            w.setSelectionRange(index2,index+1,insert=index2) # was insert=index2+1
            # g.trace('case 1',s[index2:index+1])
        else:
            w.setSelectionRange(index,index2+1,insert=min(len(s),index2+1))
            # g.trace('case2',s[index:index2+1])
        w.see(index2)
    else:
        g.es("unmatched %s" % repr(ch))</t>
<t tx="ekr.20070626112754.84"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findMatchingBracketHelper(self,s,ch,index):

    c = self
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    # g.trace('index',index,'ch',repr(ch),'brackets',brackets)
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    else:
        return None
    # g.trace('index',index,'ch',repr(ch),'match_ch',repr(match_ch))
    level = 0
    while 1:
        if forward and index &gt;= len(s):
            # g.trace("not found")
            return None
        ch2 = 0 &lt;= index &lt; len(s) and s[index] or ''
        # g.trace('forward',forward,'ch2',repr(ch2),'index',index)
        if ch2 == ch:
            level += 1
        if ch2 == match_ch:
            level -= 1
            if level &lt;= 0:
                return index
        if not forward and index &lt;= 0:
            # g.trace("not found")
            return None
        index += g.choose(forward,1,-1)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
</t>
<t tx="ekr.20070626112754.85"></t>
<t tx="ekr.20070626112754.86"></t>
<t tx="ekr.20070626112754.87">def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width &gt; 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                &lt;&lt; backspace with negative tab_width &gt;&gt;
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
</t>
<t tx="ekr.20070626112754.88">s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
</t>
<t tx="ekr.20070626112754.89">@nocolor

- Typing return in calltips should work as in autocompletion:
  Don't wipe out the suggested text.

- (done) Suppress scrolling of body pane!
  The problem was the call to c.setBodyString().

- (done) Make sure to recolor text at end.

@color
</t>
<t tx="ekr.20070626112754.90"># The problem was in a special case (for only one line) in g.convertPythonIndexToRowCol
# This special case is now covered in the unit test.</t>
<t tx="ekr.20070626112754.91"></t>
<t tx="ekr.20070626112754.92">def getEditableTextRange (self):

    k = self ; w = self.widget
    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)
    return i,j</t>
<t tx="ekr.20070626112754.93"></t>
<t tx="ekr.20070626112754.94">def convertPythonIndexToRowCol (s,i):

    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i &lt;= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
</t>
<t tx="ekr.20070626112754.95">def convertRowColToPythonIndex (s,row,col):

    '''Convert zero-based row/col indices into a python index into string s.'''

    if row &lt; 0: return 0

    lines = g.splitLines(s)

    if row &gt;= len(lines):
        return len(s)

    col = min(col, len(lines[row]))

    prev = 0
    for line in lines[:row]:
        prev += len(line)

    return prev + col
</t>
<t tx="ekr.20070626112754.96"></t>
<t tx="ekr.20070626112754.97">def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        # g.trace('*****',g.callers())
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        selectAll = selectAll or self.select_all_text_when_editing_headlines
        if selectAll:
            w.setSelectionRange(0,'end',insert='end')
        else:
            w.setInsertPoint('end') # Clears insert point.
    else:
        g.trace('no edit_widget')

setNormalLabelState = setEditLabelState # For compatibility.
</t>
<t tx="ekr.20070626112754.98">def setHeadlineText (self,theId,w,s):

    """All changes to text widgets should come here."""

    __pychecker__ = '--no-argsused' # theId not used.

    # if self.trace_alloc: g.trace('%4d %6s %s' % (theId,self.textAddr(w),s),align=-20)

    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
</t>
<t tx="ekr.20070626112754.99">def updateHead (self,event,w):

    '''Update a headline from an event.

    The headline officially changes only when editing ends.'''

    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i

    # g.trace('w',w,'ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i-1,i-1,insert=i-1)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20070626112754.100"></t>
<t tx="ekr.20070626112754.101">def onIconBoxClick (self,event,p=None):

    c = self.c ; tree = self

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p,scroll=False)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    return "break" # disable expanded box handling.
</t>
<t tx="ekr.20070626112754.102"></t>
<t tx="ekr.20070626112754.103">@nocolor
@

What I did:

- u.undo and u.redo call c.setCurrentPosition(c.currentPosition()) instead of c.selectPosition(c.currentPosition())
    This accomplishes what is wanted without interfering with selection range.

- u.undoTyping and u.redoTyping now call w.setSelectionRange, i.e., they act directly on w.

@color</t>
<t tx="ekr.20070626112754.104">class baseUndoer:
    """The base class of the undoer class."""
    @others

class undoer (baseUndoer):
    """A class that implements unlimited undo and redo."""
    pass
</t>
<t tx="ekr.20070626112754.105">def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)

    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.

    # New in 4.2...
    self.optionalIvars = []</t>
<t tx="ekr.20070626112754.106">def clearIvars (self):

    u = self

    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
</t>
<t tx="ekr.20070626112754.107"></t>
<t tx="ekr.20070626112754.108">def cutStack (self):

    u = self ; n = u.max_undo_stack_size

    if n &gt; 0 and u.bead &gt;= n and not g.app.unitTesting:

        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i &gt;= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))
</t>
<t tx="ekr.20070626112754.109">def getBead (self,n):

    '''Set undoer ivars from the bunch at the top of the undo stack.'''

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)

    return bunch
</t>
<t tx="ekr.20070626112754.110">def peekBead (self,n):

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
</t>
<t tx="ekr.20070626112754.111">def pushBead (self,bunch):

    u = self

    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead &gt;= 0 and u.bead &lt; len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

        # Recalculate the menu labels.
        u.setUndoTypes()
</t>
<t tx="ekr.20070626112754.112">def setIvarsFromBunch (self,bunch):

    u = self

    u.clearIvars()

    if 0: # Debugging.
        print '-' * 40
        keys = bunch.keys()
        keys.sort()
        for key in keys:
            g.trace(key,bunch.get(key))
        print '-' * 20

    for key in bunch.keys():
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
</t>
<t tx="ekr.20070626112754.113">def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.

    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''

    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
</t>
<t tx="ekr.20070626112754.114">def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
</t>
<t tx="ekr.20070626112754.115"># These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    # g.trace(theType,g.callers())
    u = self ; frame = u.c.frame

    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'

    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel

def setUndoType (self,theType):
    # g.trace(theType,g.callers())

    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
</t>
<t tx="ekr.20070626112754.116">def setUndoTypes (self):

    u = self

    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")

    u.cutStack()
</t>
<t tx="ekr.20070626112754.117">def restoreTree (self,treeInfo):

    """Use the tree info to restore all vnode and tnode data,
    including all links."""

    u = self

    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
</t>
<t tx="ekr.20070626112754.118">def restoreVnodeUndoInfo (self,bunch):

    """Restore all ivars saved in the bunch."""

    v = bunch.v

    v.statusBits = bunch.statusBits
    v._parent    = bunch.parent
    v._next      = bunch.next
    v._back      = bunch.back

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
</t>
<t tx="ekr.20070626112754.119">def restoreTnodeUndoInfo (self,bunch):

    t = bunch.t

    t.headString  = bunch.headString
    t.bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits
    t._firstChild = bunch.firstChild

    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
        t._p_changed = 1
</t>
<t tx="ekr.20070626112754.120">def saveTree (self,p,treeInfo=None):

    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    &lt;&lt; about u.saveTree &gt;&gt;

    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
</t>
<t tx="ekr.20070626112754.121">@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
</t>
<t tx="ekr.20070626112754.122">def createVnodeUndoInfo (self,v):

    """Create a bunch containing all info needed to recreate a vnode for undo."""

    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parent     = v._parent,
        next       = v._next,
        back       = v._back,
        # The tnode never changes so there is no need to save it here.
    )

    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
</t>
<t tx="ekr.20070626112754.123">def createTnodeUndoInfo (self,t):

    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t.headString,
        bodyString = t.bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
        firstChild = t._firstChild,
    )

    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
</t>
<t tx="ekr.20070626112754.124">def trace (self):

    ivars = ('kind','undoType')

    for ivar in ivars:
        print ivar, getattr(self,ivar)
</t>
<t tx="ekr.20070626112754.125">def updateMarks (self,oldOrNew):

    '''Update dirty and marked bits.'''

    u = self ; c = u.c

    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    dirty   = g.choose(isOld,u.oldDirty,  u.newDirty)
    marked  = g.choose(isOld,u.oldMarked, u.newMarked)
    changed = g.choose(isOld,u.oldChanged,u.newChanged)

    if dirty:   u.p.setDirty(setDescendentsDirty=False)
    else:       u.p.clearDirty()

    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    u.c.setChanged(changed)
</t>
<t tx="ekr.20070626112754.126"></t>
<t tx="ekr.20070626112754.127"></t>
<t tx="ekr.20070626112754.128">def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types &amp; helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()

    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag

    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()

    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
</t>
<t tx="ekr.20070626112754.129">def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.bodyString()
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.headString()
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.130">def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''

    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the types &amp; helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.131">def afterClearRecentFiles (self,bunch):

    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]

    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles

    u.pushBead(bunch)

    return bunch
</t>
<t tx="ekr.20070626112754.132">def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'clone'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.133">def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types &amp; helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.134">def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'delete'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.135">def afterHoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return

    bunch = u.createCommonBunch(p)

    # Set types &amp; helpers
    bunch.kind = 'hoist'
    bunch.undoType = command

    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.136">def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set types &amp; helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())

    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode

    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            t = bunch2.t
            afterTree.append(
                g.Bunch(t=t,head=t.headString[:],body=t.bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.137">def afterMark (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node for mark and unmark commands.'''

    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.

    u = self
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark

    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.138">def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):

    u = self ; c = u.c
    if u.redoing or u.undoing: return

    # Set the types &amp; helpers.
    bunch.kind = 'move'
    bunch.undoType = command

    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove

    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newBack   = p.back()
    bunch.newN = p.childIndex()
    bunch.newParent = p.parent()

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.139"></t>
<t tx="ekr.20070626112754.140">def beforeChangeGroup (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command

    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
</t>
<t tx="ekr.20070626112754.141">def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):

    '''Return data that gets passed to afterChangeNode'''

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBody = oldBody or p.bodyString()
    bunch.oldHead = oldHead or p.headString()

    return bunch
</t>
<t tx="ekr.20070626112754.142">def beforeChangeTree (self,p):

    # g.trace(p.headString())

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)

    return bunch
</t>
<t tx="ekr.20070626112754.143">def beforeClearRecentFiles (self):

    u = self ; p = u.c.currentPosition()

    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
</t>
<t tx="ekr.20070626112754.144">def beforeCloneNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    return bunch
</t>
<t tx="ekr.20070626112754.145">def beforeDeleteNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()

    return bunch
</t>
<t tx="ekr.20070626112754.146">def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):

    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone

    if pasteAsClone:
        # Save the list of bunches created by fc.createVnode.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
</t>
<t tx="ekr.20070626112754.147">def beforeMark (self,p,command):

    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command

    return bunch
</t>
<t tx="ekr.20070626112754.148">def beforeMoveNode (self,p):

    u = self

    bunch = u.createCommonBunch(p)

    bunch.oldBack = p.back()
    bunch.oldN = p.childIndex()
    bunch.oldParent = p.parent()

    return bunch
</t>
<t tx="ekr.20070626112754.149">def createCommonBunch (self,p):

    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w.getSelectionRange(),
        p = p.copy(),
    )
</t>
<t tx="ekr.20070626112754.150"># Translation does not affect these routines.

def canRedo (self):

    u = self

    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self

    return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="ekr.20070626112754.151">def clearUndoState (self):

    """Clears then entire Undo state.

    All non-undoable commands should call this method."""

    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
</t>
<t tx="ekr.20070626112754.152">def enableMenuItems (self):

    u = self ; frame = u.c.frame

    menu = frame.menu.getMenu("Edit")
    frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
    frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="ekr.20070626112754.153">if 0:
    def getMark (self):

        __pychecker__ = '--no-classattr' # self.bead does, in fact, exist.

        return self.bead

    def rollbackToMark (self,n):

        u = self

        u.bead = n
        u.beads = u.beads[:n+1]
        u.setUndoTypes()

    rollBackToMark = rollbackToMark
</t>
<t tx="ekr.20070626112754.154">def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.

    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False # Can cause unit tests to fail.
    &lt;&lt; return if there is nothing to do &gt;&gt;
    # g.trace(undo_type,g.callers(7))
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    return bunch
</t>
<t tx="ekr.20070626112754.155">if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
</t>
<t tx="ekr.20070626112754.156"># Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
</t>
<t tx="ekr.20070626112754.157">@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i

# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
</t>
<t tx="ekr.20070626112754.158">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
</t>
<t tx="ekr.20070626112754.159">#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
</t>
<t tx="ekr.20070626112754.160">@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
if not p.isDirty():
    bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
</t>
<t tx="ekr.20070626112754.161">@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
</t>
<t tx="ekr.20070626112754.162">old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 &gt;= len(old_s) or new_col-1 &gt;= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
</t>
<t tx="ekr.20070626112754.163">def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.redoHelper: u.redoHelper()
        else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.redoing = False
        u.bead += 1
        u.setUndoTypes()</t>
<t tx="ekr.20070626112754.164">def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20070626112754.165">def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()

    c.selectPosition(u.newP)
</t>
<t tx="ekr.20070626112754.166">def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20070626112754.167">def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()

    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
</t>
<t tx="ekr.20070626112754.168">def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
</t>
<t tx="ekr.20070626112754.169">def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1


    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        c.beginUpdate()
        try:
            for z in bunch.items:
                self.setIvarsFromBunch(z)
                if z.redoHelper:
                    # g.trace(z.redoHelper)
                    z.redoHelper() ; count += 1
                else:
                    g.trace('oops: no redo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1

    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)

    c.selectPosition(p)
    newSel and c.frame.body.setSelectionRange(newSel)</t>
<t tx="ekr.20070626112754.170">def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setTnodeText(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
</t>
<t tx="ekr.20070626112754.171">def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty()

        c.selectPosition(u.p)</t>
<t tx="ekr.20070626112754.172">def redoMove (self):

    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot=oldRoot)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.173">def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
</t>
<t tx="ekr.20070626112754.174">def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    # g.trace(u.undoType)
    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.undoHelper: u.undoHelper()
        else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.undoing = False
        u.bead -= 1
        u.setUndoTypes()</t>
<t tx="ekr.20070626112754.175">def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20070626112754.176">def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.177">def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty() # New in 4.4b3.
    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.178">def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1

    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)

    c.selectPosition(p)
    oldSel and c.frame.body.setSelectionRange(oldSel)</t>
<t tx="ekr.20070626112754.179">def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
</t>
<t tx="ekr.20070626112754.180">def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.181">def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.clearDirty()
        c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.182">def undoMove (self):

    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        u.p.moveToRoot(oldRoot=c.rootPosition())

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.clearDirty()

    c.selectPosition(u.p)
</t>
<t tx="ekr.20070626112754.183">def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setTnodeText(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead) # New in 4.4b2.

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.clearDirty()
</t>
<t tx="ekr.20070626112754.184">def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
</t>
<t tx="ekr.20070626112754.185">def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.bodyString())

    return p # Nothing really changes.
</t>
<t tx="ekr.20070626112754.186">def selectPosition(self,p,updateBeadList=True):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
</t>
<t tx="ekr.20070626112754.187">tree_select_lockout = False

def select (self,p,updateBeadList=True,scroll=True):

    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        val = 'break'
        self.tree_select_lockout = True
        val = self.treeSelectHelper(p,updateBeadList,scroll)
    finally:
        self.tree_select_lockout = False

    return val  # Don't put a return in a finally clause.
</t>
<t tx="ekr.20070626112754.188">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,updateBeadList,scroll):

    c = self.c ; frame = c.frame
    body = w = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p:
        # Bug fix: 5/31/07: do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # g.trace('      ===',id(w),p and p.headString())
    if self.trace_select and not g.app.unitTesting: g.trace('tree',g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p,updateBeadList) # Remember this position.
    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
</t>
<t tx="ekr.20070626112754.189"># Remember the position of the scrollbar before making any changes.
if not body: g.trace('no body!','c.frame',c.frame,'old_p',old_p)

yview = body.getYScrollPosition()
insertSpot = c.frame.body.getInsertPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
</t>
<t tx="ekr.20070626112754.190"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
w.setAllText(s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
</t>
<t tx="ekr.20070626112754.191">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.192">def setCurrentPosition (self,p):

    """Set the presently selected position. For internal use only.

    Client code should use c.selectPosition instead."""

    c = self ; cc = c.chapterController

    # g.trace(p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()

        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        newRoot = c.findRootPosition(c._currentPosition)
        if newRoot:
            c.setRootPosition(newRoot)
        # This is *not* an error: newRoot can be None when switching chapters.
        # else: g.trace('******** no new root')
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition</t>
<t tx="ekr.20070626112754.193"># Indent and Undent did not set selection properly.
# Improved setSelectionAreas &amp; getBodyLines: these required subtle changes in several methods.</t>
<t tx="ekr.20070626112754.194">def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; w = body.bodyCtrl

    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;</t>
<t tx="ekr.20070626112754.195">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = w.getAllText()
oldSel =  w.getSelectionRange()
oldYview = body.getYScrollPosition()

head,lines,tail = c.findBoundParagraph()
</t>
<t tx="ekr.20070626112754.196">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)

indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20070626112754.197">trailingNL = lines and lines[-1].endswith('\n')
lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult)
if trailingNL: result = result + '\n'</t>
<t tx="ekr.20070626112754.198">junk, ins = body.setSelectionAreas(head,result,tail)

# Advance to the next paragraph.
s = w.getAllText()
ins += 1 # Move past the selection.
while ins &lt; len(s):
    i,j = g.getLine(s,ins)
    line = s[i:j]
    if line.startswith('@') or line.isspace():
        ins = j+1
    else:
        ins = i ; break

changed = original != head + result + tail
if changed:
    undoType = g.choose(changed,"Reformat Paragraph",None)
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

w.setSelectionRange(ins,ins,insert=ins)
w.see(ins)
if changed:
    c.recolor()
</t>
<t tx="ekr.20070626112754.199">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):

    c = self ; body = c.frame.body ; p = c.currentPosition()

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i,len(head)+len(middle)-1)
    newSel = i,j
    body.setSelectionRange(newSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel or newSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.seeInsertPoint()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
</t>
<t tx="ekr.20070626112754.200">def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    w = self.bodyCtrl
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    return i,j
</t>
<t tx="ekr.20070626112754.201">def getBodyLines (self,expandSelection=False):

    """Return head,lines,tail where:

    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    oldVview = body.getYScrollPosition()

    if expandSelection:
        s = w.getAllText()
        head = tail = ''
        oldSel = 0,len(s)
        lines = g.splitLines(s) # Retain the newlines of each line.
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,s,tail = body.getSelectionLines()
        lines = g.splitLines(s) # Retain the newlines of each line.

        # Expand the selection.
        i = len(head)
        j = max(i,len(head)+len(s)-1)
        oldSel = i,j

    return head,lines,tail,oldSel,oldVview # string,list,string,tuple.
</t>
<t tx="ekr.20070626112754.202">def getSelectionLines (self):

    """Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return '','',''

    # At present, called only by c.getBodyLines.
    w = self.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j:
        i,j = g.getLine(s,i)
    else:
        i,junk = g.getLine(s,i)
        junk,j = g.getLine(s,j)


    before = g.toUnicode(s[0:i],g.app.tkEncoding)
    sel    = g.toUnicode(s[i:j],g.app.tkEncoding)
    after  = g.toUnicode(s[j:len(s)],g.app.tkEncoding)

    # g.trace(i,j,'sel',repr(s[i:j]),'after',repr(after))
    return before,sel,after # 3 strings.
</t>
<t tx="ekr.20070626112754.203">def getInsertLines (self):

    """Return before,after where:

    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.

    All lines end in a newline, except possibly the last line."""

    w = self.bodyCtrl
    s = w.getAllText()
    insert = w.getInsertPoint()
    i,j = g.getLine(s,insert)
    before = s[0:i]
    ins = s[i:j]
    after = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
</t>
<t tx="ekr.20070626112754.204"></t>
<t tx="ekr.20070626112754.205">def removeBlankLines (self,event):

    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''

    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20070626112754.206">def convertBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20070626112754.207">def convertTabs (self,event=None):

    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20070626112754.208">def dedentBody (self,event=None):

    '''Remove one tab's worth of indentation from all presently selected lines.'''

    c = self ; current = c.currentPosition() ; undoType='Unindent'

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20070626112754.209">def extract (self,event=None):

    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if lines:
        headline = lines[0].strip()
        del lines[0]
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+'\n',None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.210">def extractSection (self,event=None):

    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType='Extract Section'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.211">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
</t>
<t tx="ekr.20070626112754.212">def extractSectionNames(self,event=None):

    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setSelectionRange(oldSel)
    body.setFocus()
</t>
<t tx="ekr.20070626112754.213">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)

if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]
</t>
<t tx="ekr.20070626112754.214">def indentBody (self,event=None):

    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; current = c.currentPosition() ; undoType='Indent Region'
    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20070626112754.215">def addComments (self,event=None):

    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('No text selected',color='blue')
        return

    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
</t>
<t tx="ekr.20070626112754.216">def deleteComments (self,event=None):

    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return

    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
</t>
<t tx="ekr.20070626112754.217"></t>
<t tx="ekr.20070626112754.218"></t>
<t tx="ekr.20070626112754.219"></t>
<t tx="ekr.20070626112754.220">def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 &lt; len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()</t>
<t tx="ekr.20070626112754.221">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)</t>
<t tx="ekr.20070626112754.222">def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot &lt; i: spot = i
        elif spot &gt; j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)</t>
<t tx="ekr.20070626112754.223">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return

    self.moveToHelper(event,i2+1,extend)
</t>
<t tx="ekr.20070626112754.224">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20070626112754.225">def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i &gt;= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j &gt;= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j &lt; i and s[j].isspace():
        j += 1

    if j &lt; i:
        self.moveToHelper(event,j,extend)
</t>
<t tx="ekr.20070626112754.226">def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20070626112754.227">def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20070626112754.228">def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i &gt; 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20070626112754.229">def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t</t>
<t tx="ekr.20070626112754.230">def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
</t>
<t tx="ekr.20070626112754.231">def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
</t>
<t tx="ekr.20070626112754.232">def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20070626112754.233">def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return

    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
</t>
<t tx="ekr.20070626112754.234">def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
</t>
<t tx="ekr.20070626112754.235">def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)</t>
<t tx="ekr.20070626112754.236">def extendToWord (self,event):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
        i -= 1
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)</t>
<t tx="ekr.20070626112754.237">def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
</t>
<t tx="ekr.20070626112754.238">def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
</t>
<t tx="ekr.20070626112754.239">def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
</t>
<t tx="ekr.20070626112754.240">def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
</t>
<t tx="ekr.20070626112754.241">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20070626112754.242"></t>
<t tx="ekr.20070626112754.243"></t>
<t tx="ekr.20070626112754.244"></t>
<t tx="ekr.20070626112754.245"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if c.suppressHeadChanged: return
    if not w: return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace('changed',changed,'old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(flag=changed,scroll=False)
            # scroll=False in 4.4.1; flag = changed in 4.4.3.
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        else:
            c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
</t>
<t tx="ekr.20070626112754.246"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.247">def onHeadlineKey (self,event):

    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20070626112754.248">def endEditLabel (self):

    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None

    # Can't call setDefaultUnboundKeyAction here: it might put us in ignore mode!
    # if k:
        # k.setDefaultUnboundKeyAction()
        # k.showStateAndMode() # Destroys UNL info.

    # Important: this will redraw if necessary.
    self.onHeadChanged(p)

    if 0: # This interferes with the find command and interferes with focus generally!
        c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.249"></t>
<t tx="ekr.20070626112754.250"># The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_add(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_add(w,tagName,i,j,*args)

</t>
<t tx="ekr.20070626112754.251">def extendToParagraph (self,event):

    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i &gt; 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j &lt; len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
</t>
<t tx="ekr.20070626112754.252">def selectParagraphHelper (self,w,start):

    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j &lt; len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break

    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
</t>
<t tx="ekr.20070626112754.253">def backwardKillParagraph (self,event):

    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i &gt; 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.254">def killParagraph (self,event):

    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.255"># The text frame somehow was not being packed as usual.</t>
<t tx="ekr.20070626112754.256">def createStatusLine (self):
    if not self.statusLine:
        self.statusLine  = self.statusLineClass(self.c,self.outerFrame)
    return self.statusLine

def clearStatusLine (self):
    self.statusLine and self.statusLine.clear()

def disableStatusLine (self,background=None):
    self.statusLine and self.statusLine.disable(background)

def enableStatusLine (self,background="white"):
    self.statusLine and self.statusLine.enable(background)

def getStatusLine (self):
    return self.statusLine

getStatusObject = getStatusLine

def putStatusLine (self,s,color=None):
    self.statusLine and self.statusLine.put(s,color)

def setFocusStatusLine (self):
    self.statusLine and self.statusLine.setFocus()

def statusLineIsEnabled(self):
    return self.statusLine and self.statusLine.isEnabled()

def updateStatusLine(self):
    self.statusLine and self.statusLine.update()</t>
<t tx="ekr.20070626112754.257">class tkStatusLineClass:

    '''A class representing the status line.'''

    @others
</t>
<t tx="ekr.20070626112754.258">def __init__ (self,c,parentFrame):

    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)

    bg = self.statusFrame.cget("background")
    self.textWidget = w = g.app.gui.bodyTextWidget(
        self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    w.bind("&lt;Button-1&gt;", self.onActivate)
    self.show()

    c.frame.statusFrame = self.statusFrame
    c.frame.statusLabel = self.labelWidget
    c.frame.statusText  = self.textWidget
</t>
<t tx="ekr.20070626112754.259">def clear (self):

    w = self.textWidget
    if not w: return

    w.configure(state="normal")
    w.delete(0,"end")
    w.configure(state="disabled")
</t>
<t tx="ekr.20070626112754.260">def disable (self,background=None):

    c = self.c ; w = self.textWidget
    if w:
        if not background:
            background = self.statusFrame.cget("background")
        w.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()

def enable (self,background="white"):

    # g.trace()
    c = self.c ; w = self.textWidget
    if w:
        w.configure(state="normal",background=background)
        c.widgetWantsFocus(w)
    self.enabled = True

def isEnabled(self):
    return self.enabled</t>
<t tx="ekr.20070626112754.261">def get (self):

    w = self.textWidget
    if w:
        return w.getAllText()
    else:
        return ""
</t>
<t tx="ekr.20070626112754.262">def getFrame (self):

    return self.statusFrame
</t>
<t tx="ekr.20070626112754.263">def onActivate (self,event=None):

    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
</t>
<t tx="ekr.20070626112754.264">def pack (self):

    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

show = pack
</t>
<t tx="ekr.20070626112754.265">def put(self,s,color=None):

    # g.trace('tkStatusLine',self.textWidget,s)

    w = self.textWidget
    if not w:
        g.trace('tkStatusLine','***** disabled')
        return

    w.configure(state="normal")
    w.insert("end",s)

    if color:
        if color not in self.colorTags:
            self.colorTags.append(color)
            w.tag_config(color,foreground=color)
        w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        w.tag_config("black",foreground="black")
        w.tag_add("black","end")

    w.configure(state="disabled")
</t>
<t tx="ekr.20070626112754.266">def unpack (self):

    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
</t>
<t tx="ekr.20070626112754.267">def update (self):

    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if g.app.killed or not self.isVisible:
        return

    s = bodyCtrl.getAllText()    
    index = bodyCtrl.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,index)
    if col &gt; 0:
        s2 = s[index-col:index]
        s2 = g.toUnicode(s2,g.app.tkEncoding)
        col = g.computeWidth (s2,c.tab_width)

    # Important: this does not change the focus because labels never get focus.
    self.labelWidget.configure(text="line %d, col %d" % (row,col))
    self.lastRow = row
    self.lastCol = col
</t>
<t tx="ekr.20070626112754.268"></t>
<t tx="ekr.20070626112754.269">def selectAllText (self,insert=None): # tkTextWidget

    '''Select all text of the widget, *not* including the extra newline.'''

    w = self ; s = w.getAllText()
    if insert is None: insert = len(s)
    w.setSelectionRange(0,len(s),insert=insert)
</t>
<t tx="ekr.20070626112754.270"></t>
<t tx="ekr.20070626112754.271">def doNowebSecRef (self,s,i):

    c = self.c
    self.tag("nameBrackets",i,i+2)

    # See if the line contains the right name bracket.
    j = s.find(self.rb+"=",i+2)
    k = g.choose(j==-1,2,3)
    if j == -1:
        j = s.find(self.rb,i+2)
    if j == -1:
        return i + 2
    else:
        # includes brackets
        searchName = s[i:j]
        ref = g.findReference(c,searchName,self.p)
        if ref:
            self.tag("link",i+2,j)
            if self.use_hyperlinks:
                &lt;&lt; set the hyperlink &gt;&gt;
        elif k == 3: # a section definition
            self.tag("link",i+2,j)
        else:
            self.tag("name",i+2,j)
        self.tag("nameBrackets",j,j+k)
        return j + k</t>
<t tx="ekr.20070626112754.272"># Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
self.body.tag_delete(tagName)
self.tag(tagName,i+2,j)

ref.tagName = tagName
self.body.tag_bind(tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
self.body.tag_bind(tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
self.body.tag_bind(tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)
</t>
<t tx="ekr.20070626112754.273"></t>
<t tx="ekr.20070626112754.274">Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 5194, in about
    g.app.gui.runAboutLeoDialog(c,version,theCopyright,url,email)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 197, in runAboutLeoDialog
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterDialog.py", line 203, in __init__
    self.createFrame()
  File "c:\prog\tigris-cvs\leo\src\leoTkinterDialog.py", line 238, in createFrame
    text.insert("end",version,"version")
TypeError: insert() takes exactly 3 arguments (4 given)</t>
<t tx="ekr.20070626112754.275">def createFrame (self):

    """Create the frame for an About Leo dialog."""

    if g.app.unitTesting: return

    frame = self.frame
    theCopyright = self.copyright ; email = self.email
    url = self.url ; version = self.version

    # Calculate the approximate height &amp; width. (There are bugs in Tk here.)
    lines = string.split(theCopyright,'\n')
    height = len(lines) + 8 # Add lines for version,url,email,spacing.
    width = 0
    for line in lines:
        width = max(width,len(line))
    width = max(width,len(url))
    width += 10 # 9/9/02

    frame.pack(padx=6,pady=4)

    self.text = w = g.app.gui.plainTextWidget(
        frame,height=height,width=width,bd=0,bg=frame.cget("background"))
    w.pack(pady=10)

    try:
        bitmap_name = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF") # 5/12/03
        image = Tk.PhotoImage(file=bitmap_name)
        w.image_create("1.0",image=image,padx=10)
    except Exception:
        pass # This can sometimes happen for mysterious reasons.

    w.insert("end",version) #,tag="version")
    w.tag_add('version','end-%dc' %(len(version)+1),'end-1c')
    w.insert("end",theCopyright) #,tag="copyright")
    w.tag_add('copyright','end-%dc' %(len(theCopyright)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",url)
    w.tag_add('url','end-%dc' %(len(url)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",email)
    w.tag_add('url','end-%dc' %(len(email)+1),'end-1c')

    w.tag_config("version",justify="center")
    w.tag_config("copyright",justify="center",spacing1="3")
    w.tag_config("url",underline=1,justify="center",spacing1="10")

    w.tag_bind("url","&lt;Button-1&gt;",self.onAboutLeoUrl)
    w.tag_bind("url","&lt;Enter&gt;",self.setArrowCursor)
    w.tag_bind("url","&lt;Leave&gt;",self.setDefaultCursor)

    w.tag_config("email",underline=1,justify="center",spacing1="10")
    w.tag_bind("email","&lt;Button-1&gt;",self.onAboutLeoEmail)
    w.tag_bind("email","&lt;Enter&gt;",self.setArrowCursor)
    w.tag_bind("email","&lt;Leave&gt;",self.setDefaultCursor)

    w.configure(state="disabled")
</t>
<t tx="ekr.20070626112754.276">@nocolor

1. Backspace does not work when there is an end selection

- Edit headline: cursor at end of last character.
- Drag right: apparent whitespace is selected.
- Now can not use backspace key.

The problem was a special case in backwardDeleteCharacter.

2. Select-all does not work properly in headlines.

@color</t>
<t tx="ekr.20070626112754.277"></t>
<t tx="ekr.20070626112754.278"></t>
<t tx="ekr.20070626112754.279">@nocolor

Email from Terry Brown.

I've written a simple plugin such that double clicking any 
headline in a tree with '@bookmarks' as its root will grab the 
url from the first line of the body text.

My problem is that I had to duplicate a lot of code from here:

Code--&gt;Gui Base classes--&gt;@thin leoFrame.py--&gt;class 
leoTree--&gt;tree.OnIconDoubleClick (@url)

specifically this whole piece:

@color
     if not g.doHook("@url1",c=c,p=p,v=p,url=url):
         # Note: the UNL plugin has its own notion of what a good url is.
         &lt;&lt; check the url; return if bad &gt;&gt;
         &lt;&lt; pass the url to the web browser &gt;&gt;
     g.doHook("@url2",c=c,p=p,v=p)
@nocolor

So I'm wondering if that could be split of to a different function, 
i.e. the first part of leoTree.OnIconDoubleClick gets the url, and 
the second part handles the url, and I want to be able to call just 
the second part.

It's important that this solution will trigger UNL if it's loaded, 
and similar animals.

So, if it's not too tricky, could the handle url part of 
leoTree.OnIconDoubleClick be split out for calling?</t>
<t tx="ekr.20070626112754.280">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            &lt;&lt; stop the url after any whitespace &gt;&gt;
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            self.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06</t>
<t tx="ekr.20070626112754.281"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
</t>
<t tx="ekr.20070626112754.282">def handleUrlInUrlNode(self,url):

    # Note: the UNL plugin has its own notion of what a good url is.

    c = self.c
    # g.trace(url)
    &lt;&lt; check the url; return if bad &gt;&gt;
    &lt;&lt; pass the url to the web browser &gt;&gt;
</t>
<t tx="ekr.20070626112754.283">@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url or len(url) == 0:
    g.es("no url following @url")
    return

# Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return</t>
<t tx="ekr.20070626112754.284">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
</t>
<t tx="ekr.20070626112754.285"></t>
<t tx="ekr.20070626112754.286">recentFileMessageWritten = False

def writeRecentFilesFile (self,c):

    '''Write the appropriate .leoRecentFiles.txt file.'''

    tag = '.leoRecentFiles.txt'

    if g.app.unitTesting:
        return

    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None

    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    self.recentFileMessageWritten = True
                    print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20070626112754.287">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)

    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass

    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()

    if theFile:
        theFile.close()
</t>
<t tx="ekr.20070626112754.288"></t>
<t tx="ekr.20070626112754.289">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    # g.trace('event.keysym_num',event.keysym_num,event,dir(event))

    &lt;&lt; define vars &gt;&gt;
    if keysym in special_keys: return None

    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = (False or self.trace_masterKeyHandlerGC) and not g.app.unitTesting
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',repr(event.keysym),'ch:',repr(event.char),
            'state.kind:',k.state.kind,'\n',g.callers())
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;

    if traceGC: g.printNewObjects('masterKey 2')

    &lt;&lt; handle per-pane bindings &gt;&gt;
    &lt;&lt; handle keys without bindings &gt;&gt;
</t>
<t tx="ekr.20070626112754.290">k = self ; c = k.c ; gui = g.app.gui

if event: event = gui.leoKeyEvent(event,c)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1</t>
<t tx="ekr.20070626112754.291"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
</t>
<t tx="ekr.20070626112754.292">keyStatesTuple = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

# g.trace('w_name',w_name,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))
# g.trace('button',k.masterBindingsDict.get('button'))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d.keys())
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
</t>
<t tx="ekr.20070626112754.293">if traceGC: g.printNewObjects('masterKey 5')

modesTuple = ('insert','overwrite')

if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
    # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
    if trace: g.trace('plain key in insert mode',repr(stroke))
    if traceGC: g.printNewObjects('masterKey 4')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'

elif keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    if trace: g.trace(repr(stroke),'no func')
    if traceGC: g.printNewObjects('masterKey 6')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20070626112754.294">def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or self.trace_masterKeyHandler and not g.app.unitTesting

    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
</t>
<t tx="ekr.20070626112754.295">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
</t>
<t tx="ekr.20070626112754.296">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
</t>
<t tx="ekr.20070626112754.297">def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
</t>
<t tx="ekr.20070626112754.298">def callAltXFunction (self,event):

    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.299"># This is much less confusing.</t>
<t tx="ekr.20070626112754.300"></t>
<t tx="ekr.20070626112754.301">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4014079
By: ktenney

I've been looking at the Leo file format and discovered that a copied node is
nearly a valid Leo file, just add;

&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;

Would it be possible to drop the requirement for these tags or
add them when copying a node?

I think it would be nice if copied nodes were valid Leo files.

@color</t>
<t tx="ekr.20070626112754.302">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4005750
By: ktenney

I like the option @string relative_path_base_directory = .

which puts @file nodes in the same directory as the current Leo file.

I would like it if 
open('file.txt','w').close()

put file.txt in the same directory as the current Leo file.

in g.getBaseDirectory I changed::
    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        return base # base need not exist yet.

to::
    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        os.chdir(base)
        return base # base need not exist yet.

it should probably be configurable::

    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        if app.config.python_cwd_is_leo_base:
            os.chdir(base)
        return base # base need not exist yet.

@color
</t>
<t tx="ekr.20070626112754.303"># Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) &gt; 0 and g.os_path_isabs(base):
        # Set c.chdir_to_relative_path as needed.
        if not hasattr(c,'chdir_to_relative_path'):
            c.chdir_to_relative_path = c.config.getBool('chdir_to_relative_path')
        # Call os.chdir if requested.
        if c.chdir_to_relative_path:
            os.chdir(base)
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
</t>
<t tx="ekr.20070626112754.304"></t>
<t tx="ekr.20070626112754.305"></t>
<t tx="ekr.20070626112754.306">class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
</t>
<t tx="ekr.20070626112754.307">def __init__(self,c,finder):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []

    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
</t>
<t tx="ekr.20070626112754.308"></t>
<t tx="ekr.20070626112754.309">def setFindScope(self,where):

    '''Set the find-scope radio buttons.

    `where` must be in ('node-only','entire-outline','suboutline-only'). '''

    h = self.finder

    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
</t>
<t tx="ekr.20070626112754.310"># This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
</t>
<t tx="ekr.20070626112754.311">def showFindOptions (self):

    '''Show the present find options in the status line.'''

    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')

    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )

    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
</t>
<t tx="ekr.20070626112754.312">def setupChangePattern (self,pattern):

    h = self.finder ; w = h.change_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20070626112754.313">def setupSearchPattern (self,pattern):

    h = self.finder ; w = h.find_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20070626112754.314">def addChangeStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20070626112754.315">def addFindStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20070626112754.316">def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)

</t>
<t tx="ekr.20070626112754.317">def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
</t>
<t tx="ekr.20070626112754.318">def findAgain (self,event):

    f = self.finder

    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
</t>
<t tx="ekr.20070626112754.319">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
</t>
<t tx="ekr.20070626112754.320">def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):

    # g.trace(repr(change_pattern))

    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()

    if changeAll:
         self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20070626112754.321">def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20070626112754.322">def lastStateHelper (self):

    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
</t>
<t tx="ekr.20070626112754.323">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20070626112754.324">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.325">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.326">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.327">def setupArgs (self,forward=False,regexp=False,word=False):

    h = self.finder ; k = self.k

    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)

    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
</t>
<t tx="ekr.20070626112754.328">def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
</t>
<t tx="ekr.20070626112754.329">def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)

def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
</t>
<t tx="ekr.20070626112754.330">def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20070626112754.331">class searchCommandsClass (baseEditCommandsClass):

    '''Implements many kinds of searches.'''

    @others
</t>
<t tx="ekr.20070626112754.332">def __init__ (self,c):

    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.inited = False

    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None

    # For isearch commands.
    self.ifinder = leoFind.leoFind(c,title='ifinder')
    self.isearch_v = None # vnode of last isearch.
    self.isearch_stack = [] # A stack of previous matches: entries are: (sel,insert)
    self.ignoreCase = None
    self.forward = None
    self.regexp = None
</t>
<t tx="ekr.20070626112754.333">def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,

        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,

        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'hide-find-tab':                        self.hideFindTab,

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'open-find-tab':                        self.openFindTab,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.

        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
</t>
<t tx="ekr.20070626112754.334"></t>
<t tx="ekr.20070626112754.335">def openFindTab (self,event=None,show=True):

    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    wasOpen = self.inited

    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
</t>
<t tx="ekr.20070626112754.336"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()

def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
</t>
<t tx="ekr.20070626112754.337">def getHandler(self,show=False):

    '''Return the minibuffer handler, creating it if necessary.'''

    c = self.c

    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
</t>
<t tx="ekr.20070626112754.338">def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')

def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')

def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
</t>
<t tx="ekr.20070626112754.339">def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
</t>
<t tx="ekr.20070626112754.340">def findAgain (self,event):

    '''The find-again command is the same as the find-next command
    if the search pattern in the Find tab is not '&lt;find pattern here&gt;'
    Otherwise, the find-again is the same as the search-with-present-options command.'''

    h = self.getHandler()

    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to search-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
</t>
<t tx="ekr.20070626112754.341">def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)

def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)

def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)

def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)

def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
</t>
<t tx="ekr.20070626112754.342">def iSearchBackspace (self):

    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w

    if not self.isearch_stack:
        ins = w.getInsertPoint()
        self.endSearch(ins,ins)
        return 

    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()

    if sel:
        i,j = sel
        w.setSelectionRange(i,j,insert=ins)
    else:
        w.setInsertPoint(ins)

    w.seeInsertPoint()

    if not self.isearch_stack:
        self.endSearch(ins,ins)
</t>
<t tx="ekr.20070626112754.343">def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w

    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!

    self.ins1 = ins = w.getInsertPoint()
    sel = w.getSelectionRange() or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
</t>
<t tx="ekr.20070626112754.344"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w

    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return

    c.bodyWantsFocusNow()
    if keysym == 'Return':
        i,j = w.getSelectionRange()
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
</t>
<t tx="ekr.20070626112754.345">def scolorizer (self,event,pattern=None):

    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    ind = 0
    index = w.getInsertPoint()
    index2 = index + len(s)
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
</t>
<t tx="ekr.20070626112754.346">def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''

    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition() ;
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = w.getAllText()

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = w.getSelectionRange()
    startindex = insert = w.getInsertPoint()

    if self.forward:
        i1 = startindex
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),startindex + len(pattern))

    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        w.setSelectionRange(i,j,insert=i)
</t>
<t tx="ekr.20070626112754.347">def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')

    insert = g.choose(self.forward,'sel.end','sel.start')
    w.setSelectionRange(i,j,insert=insert)

    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20070626112754.348">class leoFind:

    """The base class for Leo's Find commands."""

    @others
</t>
<t tx="ekr.20070626112754.349">def __init__ (self,c,title=None):

    # g.trace('leoFind',c)

    self.c = c

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        &lt;&lt; compute self.title &gt;&gt;

    &lt;&lt; init the gui-independent ivars &gt;&gt;

def init (self,c):
    self.oops()
</t>
<t tx="ekr.20070626112754.350">if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
</t>
<t tx="ekr.20070626112754.351">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
</t>
<t tx="ekr.20070626112754.352">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
</t>
<t tx="ekr.20070626112754.353"></t>
<t tx="ekr.20070626112754.354"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    elif self.selection_only:
        self.change()
    else:
        self.changeAll()
</t>
<t tx="ekr.20070626112754.355"># The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20070626112754.356"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
</t>
<t tx="ekr.20070626112754.357"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()
</t>
<t tx="ekr.20070626112754.358"># The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20070626112754.359"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.currentPosition()

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20070626112754.360"></t>
<t tx="ekr.20070626112754.361"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
</t>
<t tx="ekr.20070626112754.362"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
</t>
<t tx="ekr.20070626112754.363">def dismiss (self):
    pass
</t>
<t tx="ekr.20070626112754.364"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
</t>
<t tx="ekr.20070626112754.365"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
</t>
<t tx="ekr.20070626112754.366">def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
</t>
<t tx="ekr.20070626112754.367"># Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
</t>
<t tx="ekr.20070626112754.368"></t>
<t tx="ekr.20070626112754.369">@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 &gt; pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        &lt;&lt; change headline &gt;&gt;
    else:
        &lt;&lt; change body &gt;&gt;
</t>
<t tx="ekr.20070626112754.370">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
</t>
<t tx="ekr.20070626112754.371">if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
</t>
<t tx="ekr.20070626112754.372">def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
</t>
<t tx="ekr.20070626112754.373">def changeAll(self):

    # g.trace(g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if pos1 is None: break
            count += 1
            self.batchChange(pos1,pos2)
            s = w.getAllText()
            i,j = g.getLine(s,pos1)
            line = s[i:j]
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
    finally:
        c.endUpdate()
        self.restore(saveData)
</t>
<t tx="ekr.20070626112754.374">def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
</t>
<t tx="ekr.20070626112754.375">def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec self.change_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20070626112754.376">def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec self.find_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
</t>
<t tx="ekr.20070626112754.377">def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                &lt;&lt; create the found node and begin the undo group &gt;&gt;
            clones.append(self.p.v.t)
            &lt;&lt; create a clone of p under the find node &gt;&gt;
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
</t>
<t tx="ekr.20070626112754.378">u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20070626112754.379">undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
</t>
<t tx="ekr.20070626112754.380">def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is not None:
        self.showSuccess(pos,newpos)
    else:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)
</t>
<t tx="ekr.20070626112754.381"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p ; self.errors = 0
    while p:
        pos, newpos = self.search()
        # g.trace('pos',pos,'p',p.headString(),g.callers())
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            p = self.p = self.selectNextPosition()
    return None, None
</t>
<t tx="ekr.20070626112754.382">def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
</t>
<t tx="ekr.20070626112754.383"># Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
</t>
<t tx="ekr.20070626112754.384"></t>
<t tx="ekr.20070626112754.385">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    # g.trace(g.callers())
    c.widgetWantsFocusNow(w)
    g.app.gui.selectAllText(w)
    c.widgetWantsFocus(w)
</t>
<t tx="ekr.20070626112754.386">def oops(self):
    print ("leoFind oops:",
        g.callers(10),"should be overridden in subclass")
</t>
<t tx="ekr.20070626112754.387">def selectAllFindText (self,event=None):

    __pychecker__ = '--no-argsused' # event

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
</t>
<t tx="ekr.20070626112754.388"></t>
<t tx="ekr.20070626112754.389">def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
</t>
<t tx="ekr.20070626112754.390">def init_s_ctrl (self,s):

    w = self.s_ctrl
    w.setAllText(s)
    i = g.choose(self.reverse,len(s),0)
    w.setInsertPoint(i)
    return w
</t>
<t tx="ekr.20070626112754.391"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c ; w = c.frame.body.bodyCtrl
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only or self.selection_only:
        self.p = c.currentPosition()
        if self.selection_only: self.selStart,self.selEnd = w.getSelectionRange()
        else:                   self.selStart,self.selEnd = None,None
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
</t>
<t tx="ekr.20070626112754.392"># Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
    p = self.p
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)
</t>
<t tx="ekr.20070626112754.393"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            # Search headline first.
            self.in_headline = (
                p == c.frame.tree.editPosition() and
                c.get_focus() != c.frame.body.bodyCtrl)
    else:
        self.in_headline = self.search_headline
</t>
<t tx="ekr.20070626112754.394"># For incremental searches

def initInteractiveCommands(self):

    c = self.c ; p = self.p

    self.errors = 0
    if self.in_headline:
        c.frame.tree.setEditPosition(p)
        w = c.edit_widget(p)
        sel = None
    else:
        w = c.frame.bodyCtrl
        sel = w.getSelectionRange()
    pos = w.getInsertPoint()
    st = self.initNextText()
    c.widgetWantsFocus(w)
    st.setInsertPoint(pos)
    if sel:
        self.selStart,self.selEnd = sel
    else:
        self.selStart,self.selEnd = None,None
    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = pos
        # Do not set self.wrapPosition here: that must be done after the first search.
</t>
<t tx="ekr.20070626112754.395">def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('-' * 20,self.p.headString())
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es(theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('-' * 20,self.p.headString())
        g.es(line)
        self.p.setVisited()
    else:
        g.es(line)
</t>
<t tx="ekr.20070626112754.396"># Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    #g.trace(c.widget_name(t))

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)
</t>
<t tx="ekr.20070626112754.397">def save (self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = w.getInsertPoint()
    sel = w.getSelectionRange()
    if len(sel) == 2:
        start,end = sel
    else:
        start,end = None,None
    return (self.in_headline,p,w,insert,start,end)
</t>
<t tx="ekr.20070626112754.398"># New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        # g.trace(self.svarDict.get(key))
        val = self.svarDict[key].get()
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
</t>
<t tx="ekr.20070626112754.399">class findTab (leoFind):

    '''An adapter class that implements Leo's Find tab.'''

    @others
</t>
<t tx="ekr.20070626112754.400">def __init__(self,c,parentFrame):

    # g.trace('findTab',c)

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None

    self.optionsOnly = c.config.getBool('show_only_find_tab_options')

    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
</t>
<t tx="ekr.20070626112754.401">def createBindings (self):
    self.oops()

def createFrame (self,parent):
    __pychecker__ = '--no-argsused'
    self.oops()

def getOption (self,ivar):
    self.oops()

def init (self,c):
    self.oops()

def initGui (self):
    pass # Optional method.

def setOption (self,ivar,val):
    __pychecker__ = '--no-argsused'
    self.oops()

def toggleOption (self,ivar):
    self.oops()

# self.oops is defined in the leoFind class.
</t>
<t tx="ekr.20070626112754.402"></t>
<t tx="ekr.20070626112754.403">def findButtonCallback(self,event=None):

    self.findButton()
    return 'break'
</t>
<t tx="ekr.20070626112754.404">def hideTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.405"></t>
<t tx="ekr.20070626112754.406">def changeCommand (self,event=None):

    self.setup_command()
    self.change()

def changeThenFindCommand(self,event=None):

    self.setup_command()
    self.changeThenFind()
</t>
<t tx="ekr.20070626112754.407">def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
</t>
<t tx="ekr.20070626112754.408">def cloneFindAllCommand (self,event=None):

    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20070626112754.409">def findAgainCommand (self):

    s = self.find_ctrl.getAllText()

    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
</t>
<t tx="ekr.20070626112754.410">def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
</t>
<t tx="ekr.20070626112754.411">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()

def findPrevCommand (self,event=None):

    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
</t>
<t tx="ekr.20070626112754.412">@ Notes:

- The spell tab is only shown if Aspell was properly imported.
- Added leoLog.finishCreate and tkLog.finishCreate, called from c.finishCreate.
- Added force option to deleteTab.
- Handled errors better in the aspell init logic.</t>
<t tx="ekr.20070626112754.413">def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
</t>
<t tx="ekr.20070626112754.414"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()

def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20070626112754.415">def finishCreate (self,initEditCommanders=True):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if initEditCommanders: ### g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    c.frame.log.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)

    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.416">def printCommandsDict (self):

    c = self

    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print
</t>
<t tx="ekr.20070626112754.417">def finishCreate (self,c):

    f = self ; f.c = c
    # g.trace('tkFrame','c',c,g.callers())

    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBar()
    f.createSplitterComponents()
    f.createStatusLine()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()

    # f.enableTclTraces()
</t>
<t tx="ekr.20070626112754.418">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)

    # Create the canvas, tree, log and body.
    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    if self.use_chapters and self.use_chapter_tabs:
        cc.tt = leoTkinterTreeTab(c,f.split2Pane1,cc)

    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)

    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl

    # Configure.
    f.setTabWidth(c.tab_width)
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
</t>
<t tx="ekr.20070626112754.419">def createFirstTreeNode (self):

    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
    c.editPosition(p)
</t>
<t tx="ekr.20070626112754.420">def enableTclTraces (self):

    c = self.c
    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if True:
        def focusIn (event):
            print("Focus in  %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        def focusOut (event):
            print("Focus out %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        def tracewidget(event):
            g.trace('enabling widget trace')
            Pmw.tracetk(event.widget, 1)

        def untracewidget(event):
            g.trace('disabling widget trace')
            Pmw.tracetk(event.widget,0)

        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)
</t>
<t tx="ekr.20070626112754.421">def finishCreate (self):

    # g.trace('tkLog')

    c = self.c ; log = self

    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
    log.selectTab('Log')
</t>
<t tx="ekr.20070626112754.422">def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')

    elif tabName in self.nb.pagenames():
        # g.trace(tabName,force)
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')

    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.423">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3987635
By: rogererens

At present I have to go through the list in the Plugin Manager again, trying to
remember which plugins I had enabled in the previous version.

Possibly the .leoRecentFiles.txt construct analogue may be used?

@color

</t>
<t tx="ekr.20070626112754.424">def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    def pr (*args,**keys):
        if not g.app.unitTesting:
            g.es_print(*args,**keys)

    fileName = "pluginsManager.txt"
    plugins_path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]
    s = g.app.config.getEnabledPlugins()
    theConfigFile = g.app.config.enabledPluginsFileName
    # g.trace('len(s)',s and len(s) or 0)
    if s:
        pr('@enabled-plugins found in %s' % (theConfigFile),color='blue')
        enabled_files = getEnabledFiles(s,plugins_path)
    else:
        for theDir,place in (
            (g.app.homeDir,'HOME'),
            (plugins_path,'leo/config')
        ):
            manager_path = g.os_path_join(theDir,fileName)
            if g.os_path_exists(manager_path):
                g.es_print('%s: %s' % (fileName,theDir),color='blue')
                break
        else: pr('%s not found. No plugins will be loaded' % fileName)
        if g.os_path_exists(manager_path):
            &lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;
        else:  return

    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)

    # Note: g.plugin_signon adds module names to g.app.loadedPlugins
    if 0:
        if g.app.loadedPlugins:
            pr("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
</t>
<t tx="ekr.20070626112754.425">try:
    # New in 4.3: The first reference to a plugin in pluginsManager.txt controls.
    theFile = open(manager_path)
    s = theFile.read()
    pr('Using settings in pluginsManager.txt')
    enabled_files = getEnabledFiles(s,plugins_path)
    theFile.close()
except IOError:
    pr("Can not open: %s"  % manager_path)
    # Don't import leoTest initially.  It causes problems.
    import leoTest ; leoTest.fail()
    return
</t>
<t tx="ekr.20070626112754.426">def getEnabledFiles (s,plugins_path):

    enabled_files = []
    disabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s:
            if g.match(s,0,"#"):
                s = s[1:].strip()
                # Kludge: ignore comment lines containing a blank or not ending in '.py'.
                if s and s.find(' ') == -1 and s[-3:] == '.py':
                    path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                    if path not in enabled_files and path not in disabled_files:
                        # print 'disabled',path
                        disabled_files.append(path)
            else:
                path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                if path not in enabled_files and path not in disabled_files:
                    # print 'enabled',path
                    enabled_files.append(path)

    return enabled_files</t>
<t tx="ekr.20070626112754.427"></t>
<t tx="ekr.20070626112754.428">@nocolor
@

It is now possible to debug both Leo-specific and non-Leo-specific scripts easily with winpdb.

Preliminaries: New settings

The following two new settings now control whether the execute-script and debug commands write the script to an external file.

- @bool write_script_file = True

True: The execute script command writes the script to be executed to a file, then executes the script using Python's execFile function. The script_file_path setting specifies the path to this file.

False (legacy): The execute script command uses Python's exec command to execute the script. 

- @string script_file_path = ../test/scriptFile.py

The path to the file to be written by the execute-script command.

Notes:

- This setting has effect only if the write_script_file setting is True.
- Use / to as the path delimiter, regardless of platform.
- The default path is ../test/scriptFile.py if no path is given.
- The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py
- The filename should end in .py.

From here on, let us assume the settings are as shown above.  There are at least three ways of debugging scripts, depending on your preferences and whether the script contains leo-specific code (g, c or p) or not.

First way:  The debug command

The debug command now works almost exactly like Kent's original @button node. This way of debugging can only be used for general scripts, not leo-specific scripts.  

The debug command writes the script to scriptFile.py and invokes the debugger as specified by the existing @string debugger_kind option.  winpdb opens and is already 'attached' to the script to be debugged.  You can single-step as you like.  Leo continues to run, but killing the debugger will also kill Leo.  When started this way, winpdb is really 'attached' to *all* of Leo, which means you can single step past the end of the script into Leo's executeScript code and from there into all of Leo(!)

As I write this I realize that the code uses arguments specific to winpdb.  That may have to be generalized, though I am not sure why anyone would want to use another debugger...

Second way: @button winpdb

This is almost exactly equivalent to the debug command, except that the script file must be *different* from the script file specified by the  script_file_path setting (The @button code *itself* uses the execute-script command, so we have to pass the script code, not the @button code to the debugger).

Third way: The execute-script command with explicit debugger breaks

The third way of debugging scripts allows winpdb to debug scripts that use c, g and p.  I'm actually not sure of exactly how and why it works, but it certainly does work.

In contrast to the previous two ways, a little more work is needed because winpdb does not start automatically.  But I am getting ahead of myself.

To use this way, insert the following two lines of code at the start of the script to be debugged::

import rpdb2
rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True)

Now just execute the execute-script command (*not* the debug command)  Leo will appear to hang.  Indeed, the  start_embedded_debugger command is waiting for *another* copy of winpdb to 'attach' to the script's process.  This process is all of Leo!  The default timeout is 5 minutes: I'm not sure what happens when the timeout happens: probably an exception gets thrown.

So you must start winpdb explicitly.  On XP just do something like

python c:\python25\Scripts\_winpdb.py -t

The -t option tells winpdb that no encoding of password is necessary.  The password is specified in the call to rpdb2.start_embedded_debugger in your script.  In this example, the password is 'go'.  Use the File:Attach command in winpdb to attach winpdb to Leo.  Specify the password as 'go' and you will see the scriptFile.py containing your entire script.  You can execute or single-step through the script. 

To repeat, the big difference is that c, g and p are defined, so you can debug any script this way.  As before, killing winpdb also kills Leo.

P.S.  winpdb and its documentation has been improved recently.  See

http://www.digitalpeers.com/pythondebugger/  and especially

http://www.digitalpeers.com/pythondebugger/embedded.htm

The discussion of embedded debugging may have been written specifically with Leo in mind.  It certainly could have been.
</t>
<t tx="ekr.20070626112754.429">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20070626112754.430">def redirectScriptOutput (self):

    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20070626112754.431">def unredirectScriptOutput (self):

    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20070626112754.432">def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))

    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None

    return path</t>
<t tx="ekr.20070626112754.433">def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
</t>
<t tx="ekr.20070626112754.434">def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
</t>
<t tx="ekr.20070626112754.435">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands ; w = c.frame.body.bodyCtrl
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
</t>
<t tx="ekr.20070626112754.436">if g.unitTesting:

    c,p = g.getTestVars()
    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
</t>
<t tx="ekr.20070626112754.437">def handleScriptException (c,p,script,script1):

    g.es("exception executing script",color='blue')

    full = c.config.getBool('show_full_tracebacks_in_scripts')

    fileName, n = g.es_exception(full=full)

    if p and not script1 and fileName == "&lt;string&gt;":
        c.goToScriptLineNumber(p,script,n)

    &lt;&lt; dump the lines near the error &gt;&gt;
</t>
<t tx="ekr.20070626112754.438">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

# Print surrounding lines.
i = max(0,n-2)
j = min(n+2,len(lines))
while i &lt; j:
    ch = g.choose(i==n-1,'*',' ')
    s = "%s line %d: %s" % (ch,i+1,lines[i])
    g.es(s,newline=False)
    i += 1
</t>
<t tx="ekr.20070626112754.439">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4113315

&gt; def runAskOkCancelNumberDialog(self,c,title,message): 
&gt; """Create and run askOkCancelNumber dialog .""" 

Can I appeal for a runAskOkCancelStringDialog(self,c,title,message)

and that perhaps both the Number and String forms have an optional 'default'
parameter?

As it happens I wanted to use it for an 'encryptNode' plug-in.  So some people
might want a runAskOkCancelPasswordDialog version, displaying asterisks... personally
I don't mind having the password visible when I type it, and for AES encryption
with 16 char keys it's probably appropriate.

@color</t>
<t tx="ekr.20070626112754.440"># This is another step toward making Leo's core gui-independent</t>
<t tx="ekr.20070626112754.441"></t>
<t tx="ekr.20070626112754.442"></t>
<t tx="ekr.20070626112754.443">def bindHotKey (self,widget):

    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20070626112754.444">def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)

    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None     
        if 1: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
            canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
</t>
<t tx="ekr.20070626112754.445">def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b
</t>
<t tx="ekr.20070626112754.446">def bindHotKey (self,widget):

    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20070626112754.447">def setMinibufferBindings (self):

    '''Create bindings for the minibuffer..'''

    f = self ; c = f.c ; k = c.k ; w = f.miniBufferWidget

    if not c.useTextMinibuffer: return

    for kind,callback in (
        ('&lt;Key&gt;',           k.masterKeyHandler),
        ('&lt;Button-1&gt;',      k.masterClickHandler),
        ('&lt;Button-3&gt;',      k.masterClick3Handler),
        ('&lt;Double-1&gt;',      k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',      k.masterDoubleClick3Handler),
    ):
        w.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            w.bind("&lt;Button-2&gt;",frame.OnPaste)
</t>
<t tx="ekr.20070626112754.448">def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl

    w.bind('&lt;Key&gt;', k.masterKeyHandler)

    for kind,func,handler in (
        ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
        ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
        ('&lt;Button-2&gt;',  frame.OnPaste,              k.masterClickHandler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        w.bind(kind,bodyClickCallback)</t>
<t tx="ekr.20070626112754.449">def bind (self,*args,**keys):

    return self.bodyCtrl.bind(*args,**keys)
</t>
<t tx="ekr.20070626112754.450">def setTabBindings (self,tabName):

    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)

    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)

    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)

    k.completeAllBindingsForWidget(w)
</t>
<t tx="ekr.20070626112754.451">def setBindings (self,):

    '''Create master bindings for all headlines.'''

    tree = self ; k = self.c.k ; canvas = self.canvas

    # g.trace('self',self,'canvas',canvas)

    &lt;&lt; make bindings for a common binding widget &gt;&gt;

    tree.setCanvasBindings(canvas)

    k.completeAllBindingsForWidget(canvas)

    k.completeAllBindingsForWidget(self.bindingWidget)

</t>
<t tx="ekr.20070626112754.452">self.bindingWidget = w = g.app.gui.plainTextWidget(
    self.canvas,name='bindingWidget')

w.bind('&lt;Key&gt;',k.masterKeyHandler)

table = (
    ('&lt;Button-1&gt;',       k.masterClickHandler,          tree.onHeadlineClick),
    ('&lt;Button-3&gt;',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('&lt;Double-Button-1&gt;',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('&lt;Double-Button-3&gt;',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        # g.trace('func',func)
        return handler(event,func)
    w.bind(a,treeBindingCallback)

self.textBindings = w.bindtags()
</t>
<t tx="ekr.20070626112754.453"></t>
<t tx="ekr.20070626112754.454">def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    for s in ('Alt','Ctrl','Command'):
        if shortcut.find(s) != -1:
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('&lt;') and shortcut.endswith('&gt;'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut == 'Tab'
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain
</t>
<t tx="ekr.20070626112754.455">if g.unitTesting:

    import string

    c,p = g.getTestVars()
    k = c.k

    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)

    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
</t>
<t tx="ekr.20070626112754.456">def shortcutFromSetting (self,setting):

    k = self

    if not setting:
        return None

    s = g.stripBrackets(setting.strip())
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    # g.trace(setting,shortcut)
    return shortcut

canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting = shortcutFromSetting
</t>
<t tx="ekr.20070626112754.457">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0
</t>
<t tx="ekr.20070626112754.458">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
</t>
<t tx="ekr.20070626112754.459"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
</t>
<t tx="ekr.20070626112754.460">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()

        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
</t>
<t tx="ekr.20070626112754.461">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
</t>
<t tx="ekr.20070626112754.462">def tkbindingFromStroke (self,stroke):

    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''

    stroke = g.stripBrackets(stroke)

    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)

    # g.trace('&lt;%s&gt;' % stroke)
    return '&lt;%s&gt;' % stroke
</t>
<t tx="ekr.20070626112754.463">def prettyPrintKey (self,stroke,brief=False):

    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'&lt;%s&gt;' % s)
</t>
<t tx="ekr.20070626112754.464">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = False or k.traceMasterCommand
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    &lt;&lt; define specialKeysyms &gt;&gt;
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val</t>
<t tx="ekr.20070626112754.465">specialKeysyms = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)</t>
<t tx="ekr.20070626112754.466">if stroke or len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
</t>
<t tx="ekr.20070626112754.467">def callStateFunction (self,event):

    k = self ; val = None

    # g.trace(k.state.kind)

    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')

    return val
</t>
<t tx="ekr.20070626112754.468">def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
</t>
<t tx="ekr.20070626112754.469">def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: pass # Ignore the key.
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
</t>
<t tx="ekr.20070626112754.470">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(tkGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'tkGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20070626112754.471">def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # g.trace('base keyHandler')

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&amp;" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        "&gt;" : "greater",
        "&lt;" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict.keys():
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key

</t>
<t tx="ekr.20070626112754.472"># One call to Tk.Canvas.bbox remains, but that is in leoTkinterTree so it has no effect on portability.</t>
<t tx="ekr.20070626112754.473"></t>
<t tx="ekr.20070626112754.474">def createMenusFromTables (self):

    c = self.c

    self.defineMenuTables()

    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()

    g.doHook("create-optional-menus",c=c)

    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()
</t>
<t tx="ekr.20070626112754.475">def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&amp;File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &amp;With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    &lt;&lt; create the recent files submenu &gt;&gt;
    self.add_separator(fileMenu)
    &lt;&lt; create the read/write submenu &gt;&gt;
    &lt;&lt; create the tangle submenu &gt;&gt;
    &lt;&lt; create the untangle submenu &gt;&gt;
    &lt;&lt; create the import submenu &gt;&gt;
    &lt;&lt; create the export submenu &gt;&gt;
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
</t>
<t tx="ekr.20070626112754.476">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
</t>
<t tx="ekr.20070626112754.477">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
</t>
<t tx="ekr.20070626112754.478">tangleMenu = self.createNewMenu("Tan&amp;gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
</t>
<t tx="ekr.20070626112754.479">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
</t>
<t tx="ekr.20070626112754.480">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
</t>
<t tx="ekr.20070626112754.481">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
</t>
<t tx="ekr.20070626112754.482">def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&amp;Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    &lt;&lt; create the edit body submenu &gt;&gt;
    &lt;&lt; create the edit headline submenu &gt;&gt;
    &lt;&lt; create the find submenu &gt;&gt;

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
</t>
<t tx="ekr.20070626112754.483">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
</t>
<t tx="ekr.20070626112754.484">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
</t>
<t tx="ekr.20070626112754.485">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
</t>
<t tx="ekr.20070626112754.486">def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&amp;Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    &lt;&lt; create check submenu &gt;&gt;
    &lt;&lt; create expand/contract submenu &gt;&gt;
    &lt;&lt; create move submenu &gt;&gt;
    &lt;&lt; create mark submenu &gt;&gt;
    &lt;&lt; create goto submenu &gt;&gt;
</t>
<t tx="ekr.20070626112754.487">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
</t>
<t tx="ekr.20070626112754.488">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
</t>
<t tx="ekr.20070626112754.489">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
</t>
<t tx="ekr.20070626112754.490">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
</t>
<t tx="ekr.20070626112754.491">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
</t>
<t tx="ekr.20070626112754.492">def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&amp;Cmds')

    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &amp;: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Chapters...',        self.cmdsMenuChaptersTable),
        ('C&amp;ursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('M&amp;inibuffer',         self.cmdsMenuMinibufferTable),
        #('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('&amp;Pickers...',         self.cmdsMenuPickersTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('R&amp;un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,t,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &amp;To...',                self.cursorMenuExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20070626112754.493">def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&amp;Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
</t>
<t tx="ekr.20070626112754.494">def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&amp;Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)</t>
<t tx="ekr.20070626112754.495">def defineMenuTables (self):

    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20070626112754.496">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20070626112754.497">def defineEditMenuTopTable (self):

    self.editMenuTopTable = [
        # &amp;: u,r reserved for undo/redo: a,d,p,t,y.
        # &amp; (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&amp;t','cut-text'),
        ('Cop&amp;y','copy-text'),
        ('&amp;Paste','paste-text'),
        ('&amp;Delete','backward-delete-char'),
        ('Select &amp;All','select-all'),
        '-',
    ]
</t>
<t tx="ekr.20070626112754.498">def defineEditMenuEditBodyTable (self):

    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&amp;section',
        '*extract-&amp;names',
        '*&amp;extract',
        '-',
        '*convert-all-b&amp;lanks',
        '*convert-all-t&amp;abs',
        '*convert-&amp;blanks',
        '*convert-&amp;tabs',
        '*insert-body-&amp;time',
        '*&amp;reformat-paragraph',
        '-',
        '*&amp;indent-region',
        '*&amp;unindent-region',
        '*&amp;match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
</t>
<t tx="ekr.20070626112754.499">def defineEditMenuEditHeadlineTable (self):

    self.editMenuEditHeadlineTable = [
        '*edit-&amp;headline',
        '*&amp;end-edit-headline',
        '*&amp;abort-edit-headline',
        '*insert-headline-&amp;time',
        '*toggle-&amp;angle-brackets',
    ]
</t>
<t tx="ekr.20070626112754.500">def defineEditMenuFindMenuTable (self):

    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&amp;open-find-tab',
        '*&amp;hide-find-tab',
        '*search-&amp;with-present-options',
        '-',
        '*find-&amp;next',
        '*find-&amp;prev',
        '*&amp;change',
        '*find-&amp;all',
        '*clone-fi&amp;nd-all',
        '*change-a&amp;ll',
        '-',
        '*&amp;find-character',
        '*find-character-extend-&amp;selection',
        '*&amp;backward-find-character',
        '*backward-find-character-&amp;extend-selection',
        '-',
        '*&amp;isearch-forward',
        '*isea&amp;rch-backward',
        '*isearch-forward-rege&amp;xp',
        '*isearch-backward-regex&amp;p',
        '-',
        '*&amp;query-replace',
        '*q&amp;uery-replace-regex',
    ]
</t>
<t tx="ekr.20070626112754.501">def defineEditMenuTop2Table (self):

    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")

    self.editMenuTop2Table = [
        '*&amp;goto-global-line',
        '*&amp;execute-script',
        (label,'toggle-invisibles'),
        ("Setti&amp;ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20070626112754.502">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20070626112754.503">def defineFileMenuTopTable (self):

    self.fileMenuTopTable = [
        '*&amp;new',
        ('&amp;Open...','open-outline'),
    ]
</t>
<t tx="ekr.20070626112754.504">def defineFileMenuTop2Table (self):

    self.fileMenuTop2Table = [
        '-',
        ('&amp;Close','close-window'),
        ('&amp;Save','save-file'),
        ('Save &amp;As','save-file-as'),
        ('Save As &amp;Unzipped','save-file-as-unzipped'),
        ('Save As &amp;Zipped','save-file-as-zipped'),
        ('Save &amp;To','save-file-to'),
        ('Re&amp;vert To Saved','revert'),
    ]
</t>
<t tx="ekr.20070626112754.505">def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&amp;read-outline-only',
        ('Read @file &amp;Nodes','read-at-file-nodes'),
        ('Write &amp;Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &amp;Missing @file Nodes','write-missing-at-file-nodes'),
        '*write-&amp;outline-only',
        ('&amp;Write @file Nodes','write-at-file-nodes'),
    ]
</t>
<t tx="ekr.20070626112754.506">def defineFileMenuTangleMenuTable (self):

    self.fileMenuTangleMenuTable = [
        '*tangle-&amp;all',
        '*tangle-&amp;marked',
        '*&amp;tangle',
    ]
</t>
<t tx="ekr.20070626112754.507">def defineFileMenuUntangleMenuTable (self):

    self.fileMenuUntangleMenuTable = [
        '*untangle-&amp;all',
        '*untangle-&amp;marked',
        '*&amp;untangle',
    ]
</t>
<t tx="ekr.20070626112754.508">def defineFileMenuImportMenuTable (self):

    self.fileMenuImportMenuTable = [
        #&amp;: c,d,f,n,o,r,
        '*import-&amp;derived-file',
        ('Import To @&amp;file','import-at-file'),
        ('Import To @&amp;root','import-at-root'),
        '*import-&amp;cweb-files',
        '*import-&amp;noweb-files',
        '*import-flattened-&amp;outline',
    ]
</t>
<t tx="ekr.20070626112754.509">def defineFileMenuExportMenuTable (self):

    self.fileMenuExportMenuTable = [
        '*export-&amp;headlines',
        '*outline-to-&amp;cweb',
        '*outline-to-&amp;noweb',
        '*&amp;flatten-outline',
        '*&amp;remove-sentinels',
        '*&amp;weave',
    ]
</t>
<t tx="ekr.20070626112754.510">def defineFileMenuTop3MenuTable (self):

    self.fileMenuTop3MenuTable = [
        ('E&amp;xit','exit-leo'),
    ]
</t>
<t tx="ekr.20070626112754.511">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20070626112754.512">def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&amp;ut-node',
        '*c&amp;opy-node',
        '*&amp;paste-node',
        ('Pas&amp;te Node As Clone','paste-retaining-clones'),
        '*&amp;delete-node',
        '-',
        '*&amp;insert-node',
        '*&amp;clone-node',
        '*sort-childre&amp;n',
        '*&amp;sort-siblings',
        '-',
        '*&amp;hoist',
        ('D&amp;e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20070626112754.513">def defineOutlineMenuCheckOutlineMenuTable (self):

    self.outlineMenuCheckOutlineMenuTable = [
        # &amp;: a,c,d,o
        '*check-&amp;outline',
        '*&amp;dump-outline',
        '-',
        '*check-&amp;all-python-code',
        '*&amp;check-python-code',
    ]
</t>
<t tx="ekr.20070626112754.514">def defineOutlineMenuExpandContractMenuTable (self):

    self.outlineMenuExpandContractMenuTable = [
        '*&amp;contract-all',
        '*contract-&amp;node',
        '*contract-&amp;parent',
        '*contract-or-go-&amp;left',
        '-',
        '*expand-p&amp;rev-level',
        '*expand-n&amp;ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&amp;1',
        '*expand-to-level-&amp;2',
        '*expand-to-level-&amp;3',
        '*expand-to-level-&amp;4',
        '*expand-to-level-&amp;5',
        '*expand-to-level-&amp;6',
        '*expand-to-level-&amp;7',
        '*expand-to-level-&amp;8',
        '-',
        '*expand-&amp;all',
        '*expand-n&amp;ode',
    ]
</t>
<t tx="ekr.20070626112754.515">def defineOutlineMenuMoveMenuTable (self):

    self.outlineMenuMoveMenuTable = [
        ('Move &amp;Down','move-outline-down'),
        ('Move &amp;Left','move-outline-left'),
        ('Move &amp;Right','move-outline-right'),
        ('Move &amp;Up','move-outline-up'),
        '-',
        '*&amp;promote',
        '*&amp;demote',
    ]
</t>
<t tx="ekr.20070626112754.516">def defineOutlineMenuMarkMenuTable (self):

    self.outlineMenuMarkMenuTable = [
        '*&amp;mark',
        '*mark-&amp;subheads',
        '*mark-changed-&amp;items',
        '*mark-changed-&amp;roots',
        '*mark-&amp;clones',
        '*&amp;unmark-all',
    ]
</t>
<t tx="ekr.20070626112754.517">def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &amp;: a,b,c,d,e,f,g,h,i,l,m,n,o,p,r,s,t,v,
        ('Go To &amp;First Node','goto-first-node'),
        ('Go To First V&amp;isible','goto-first-visible-node'),
        ('Go To First Si&amp;bling','goto-first-sibling'),
        '-',
        ('Go To Next C&amp;hanged','goto-next-changed'),
        ('Go To Next &amp;Clone','goto-next-clone'),
        ('Go To Next &amp;Marked','goto-next-marked'),
        ('Go To Next N&amp;ode','goto-next-node'),
        ('Go To Next &amp;Sibling','goto-next-sibling'),
        ('Go To Next Visibl&amp;e','goto-next-visible'),
        ('Go To Next Visite&amp;d','go-forward'),
        '-',
        ('Go To P&amp;arent','goto-parent'),
        '-',
        ('Go To &amp;Prev Node','goto-prev-node'),
        ('Go To P&amp;rev Sibling','goto-prev-sibling'),
        ('Go To Pre&amp;v Visible','goto-prev-visible'),
        ('Go To Prev Visi&amp;ted','go-back'),
        '-',
        ('Go To Last Node','goto-last-node'),
        ('Go To Last Siblin&amp;g','goto-last-sibling'),
        ('Go To &amp;Last Visible','goto-last-visible-node'),
    ]
</t>
<t tx="ekr.20070626112754.518">def defineCmdsMenuTables (self):

    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuChaptersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()</t>
<t tx="ekr.20070626112754.519">def defineCmdsMenuAbbrevTable (self):

    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20070626112754.520">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]</t>
<t tx="ekr.20070626112754.521">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20070626112754.522">def defineCmdsMenuChaptersTable (self):

    self.cmdsMenuChaptersTable = [
        '&amp;clone-node-to-chapter',
        'c&amp;opy-node-to-chapter',
        'c&amp;reate-chapter',
        '&amp;move-node-to-chapter',
        '&amp;remove-chapter',
        '&amp;select-chapter',
    ]
</t>
<t tx="ekr.20070626112754.523">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]

    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]

    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]

    self.cursorMenuForwardTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;end-word',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]

    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;end-word-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20070626112754.524">def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20070626112754.525">def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-keyboard-macro',
        '&amp;insert-keyboard-macro',
    ]
</t>
<t tx="ekr.20070626112754.526">def defineCmdsMenuMinibufferTable (self):

    self.cmdsMenuMinibufferTable = [
        # &amp;: f,h,i,q,r,s,v
        '&amp;full-command',
        'keyboard-&amp;quit',
        '&amp;repeat-complex-command',
        '&amp;view-lossage',
        '-',
        '&amp;show-mini-buffer',
        'h&amp;ide-mini-buffer',
        '-',
        '&amp;help-for-minibuffer',
    ]
</t>
<t tx="ekr.20070626112754.527">def defineCmdsMenuPickersTable (self):

    self. cmdsMenuPickersTable = [
        'show-&amp;colors',
        'show-find-&amp;options',
        'show-&amp;fonts',
    ]</t>
<t tx="ekr.20070626112754.528">def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20070626112754.529">def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20070626112754.530">def defineCmdsMenuRunTable (self):

    self.cmdsMenuRunTable = [
    # &amp;: e,r
    '&amp;execute-script',
    '&amp;run-unit-tests',
    ]
</t>
<t tx="ekr.20070626112754.531">def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-&amp;down',
        'scroll-&amp;up',
        '-',
        'scroll-down-&amp;extend-selection',
        'scroll-up-e&amp;xtend-selection',
    ]</t>
<t tx="ekr.20070626112754.532">def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20070626112754.533">def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &amp;: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&amp;beautify',
        'beautify-&amp;all',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]</t>
<t tx="ekr.20070626112754.534">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20070626112754.535">def defineWindowMenuTables (self):

    self.windowMenuTopTable = [
        # &amp;: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&amp;equal-sized-panes',
        '*&amp;toggle-active-pane',
        '*toggle-&amp;split-direction',
        '-',
        '*contract-&amp;body-pane',
        '*contract-&amp;log-pane',
        '*contract-&amp;outline-pane',
        '*contract-&amp;pane',
        '-',
        '*expand-bo&amp;dy-pane',
        '*expand-lo&amp;g-pane',
        '*expand-o&amp;utline-pane',
        '*expand-pa&amp;ne',
        '-',
        '*&amp;fully-expand-body-pane',
        '*full&amp;y-expand-log-pane',
        '*fully-e&amp;xpand-outline-pane',
        '*fully-exp&amp;and-pane',
        '-',
        '*&amp;resize-to-screen',
        '*&amp;cascade-windows',
        '*&amp;minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&amp;window',
    ]
</t>
<t tx="ekr.20070626112754.536">def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &amp;: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&amp;About Leo...',           'about-leo'),
        ('Online &amp;Home Page',       'open-online-home'),
        '*open-online-&amp;tutorial',
        '*open-&amp;users-guide',
        '-',
        ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
        ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
        # ('Open t&amp;est.leo',          'open-test-leo'),
        '-',
        '*he&amp;lp-for-minibuffer',
        '*help-for-&amp;command',
        '-',
        '*&amp;apropos-autocompletion',
        '*apropos-&amp;bindings',
        '*apropos-&amp;debugging-commands',
        '*apropos-&amp;find-commands',
        '-',
        '*pri&amp;nt-bindings',
        '*print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20070626112754.537"></t>
<t tx="ekr.20070626112754.538">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991223

I assigned both Control and Shift modifiers to do scrolling: this is so my
finger can hit a key in the lower left corner of the keyboard, and I don't have
to worry too much about my aim (I have LARGE fingers). Also, I stop the
scrolling on the JUST button release -- less worry about my finger slipping off
the key.</t>
<t tx="ekr.20070626112754.539"></t>
<t tx="ekr.20070626112754.540"></t>
<t tx="ekr.20070626112754.541">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3916155

When a node is among several other nodes at the same level of hierarchy, which
are all children of a node, and the "MOVE LFET" command is executed, the node
does move left in the outline hierarchy, but it also move down to just before
the next node at the higher hierarchy level - the level to which it is moving
left.

EKR: I love this new option: how did we ever live without it?

@color</t>
<t tx="ekr.20070626112754.542">@nocolor

This option tells how to treat an uppercase letter typed when the outline pane
is active but no headline is being edited. In such situations Leo searchs for an
node whose headline starts with the present prefix, ignoring case The prefix
starts with the first letter typed and other letters are added if they are typed
within a 'short' period of time, as specified by the outline_nav_extend_delay

True: Look in invisible nodes.
False: Look only in visible nodes.

I set this option to False because it is too easy form me to type Shift-whatever
when I meant Ctrl-whatever.

@color</t>
<t tx="ekr.20070626112754.543">http://sourceforge.net/forum/message.php?msg_id=3985382

</t>
<t tx="ekr.20070626112754.544"></t>
<t tx="ekr.20070626112754.545"></t>
<t tx="ekr.20070626112754.546"></t>
<t tx="ekr.20070626112754.547">def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
</t>
<t tx="ekr.20070626112754.548">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4132529

I'm generating Leo files with ElementTree and ran into a minor issue.

ElementTree generates an empty tag with a space before the closing slash:

&lt;globals /&gt;

in Leo's code for dummy elements to allow copied nodes to be valid Leo files,
the empty tags are generated without the space

leoFileCommands.py 2917
        self.put('&lt;globals/&gt;\n')
        self.put('&lt;preferences/&gt;\n')
        self.put('&lt;find_panel_settings/&gt;\n')

it then checks for these tags in getDummyElements() leoFileCommands.py 1298

Since ElementTree has the space before the slash, 
it's XML is considered invalid by Leo according to
this test.

I would like it if the space could be added in Leo's
self.put(...) and the check in getDummyElements()

The XML specs show the space as optional.

@color</t>
<t tx="ekr.20070626112754.549">def putClipboardHeader (self):

    c = self.c ; tnodes = 0
    &lt;&lt; count the number of tnodes &gt;&gt;
    self.put('&lt;leo_header file_format="1" tnodes=')
    self.put_in_dquotes(str(tnodes))
    self.put(" max_tnode_index=")
    self.put_in_dquotes(str(tnodes))
    self.put("/&gt;") ; self.put_nl()

    # New in Leo 4.4.3: Add dummy elements so copied nodes form a valid .leo file.
    self.put('&lt;globals/&gt;\n')
    self.put('&lt;preferences/&gt;\n')
    self.put('&lt;find_panel_settings/&gt;\n')
</t>
<t tx="ekr.20070626112754.550">c.clearAllVisited()

for p in c.currentPosition().self_and_subtree_iter():
    t = p.v.t
    if t and not t.isWriteBit():
        t.setWriteBit()
        tnodes += 1
</t>
<t tx="ekr.20070626112754.551">def getDummyElements (self):

    # New in Leo 4.4.3: Ignore the dummy elements that allow
    # Pasted Leo outlines to be valid .leo files.
    while 1:
        for tag in ('&lt;globals','&lt;preferences','&lt;find_panel_settings'):
            if self.matchTag(tag) and self.matchTag('/&gt;'):
                break
        else:
            break
</t>
<t tx="ekr.20070626112754.552"></t>
<t tx="ekr.20070626112754.553">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4134384
By: rshanley

A C++ sourcefile that opens and closes multiple namespace blocks messes up the
import. I noticed this for a source file that would 1) open a namespace block
to define a class, 2) close the namespace block and provide the constructor
for the class just defined, and 3) repeat 1) and 2) many times. When this first
occured I thought leo was hung, the word "namepace" appeared in the log pane
13 times where the actual number of namespace blocks was 10, and the .leo file
grew by 24 Mb. When the offending @file node was deleted, the size of the file
shrunk from about 33 Mb to about 9 Mb.

The following small test file causes Import To @File to produce a corrupt
outline.

On a positive note, I have been using leo profitably in navigating unfamiliar
C++ source code for about two months in concert with other tools. This is the
first problem I've had, other than cockpit error.

@color
@language c++

namespace arb
{
    class a: public dbm::X
    {
    public:
        a(int c);
    private:
        int m_a;
    };
}

arb::a::a
(
    int c
)
{
    m_a = c**2;
}


namespace arb
{
    class b: public dbm::X
    {
    public:
    b(int c);
    private:
    int m_a;
    };
}

arb::a::b
(
int c
)
{
m_b = c**2;
}


namespace arb
{

class c: public dbm::X
{
public:
c(int c);
private:
int m_a;
};
}

arb::a::c
(
int c
)
{
m_a = c**2;
}

namespace arb
{

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
}

arb::a::d
(
int c
)
{
m_a = c**2;
}
</t>
<t tx="ekr.20070626112754.554"># Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):

    scanner = self.cScanner(self)
    scanner.scan(s,parent)
</t>
<t tx="ekr.20070626112754.555">@
The C scanner uses an internal class as an organizational aid. This is far
superior, imo, to using a single huge scanCText function organized with noweb
section references. Indeed, the helper class creates a separate namespace for
use by the various helper functions.

At present only the C scanner uses this organization, and the utilities of the
cScanner class are identical to the utilites of the leoImportCommands class.
This duplication would go away if all the scanners derived from a baseScanner
class, but that is not likely any time soon, if ever.
@c

class cScanner:
    @others</t>
<t tx="ekr.20070626112754.556">def __init__ (self,importer):

    # Copy ivars.
    self.c = importer.c
    self.encoding = importer.encoding
    self.methodKind = g.choose(importer.fileType==".c","functions","methods")
    self.methodName = importer.methodName
    self.rootLine = importer.rootLine
    self.treeType = importer.treeType

    # Other ivars.
    self.function_start = 0
    self.name = None
    self.scan_start = 0
</t>
<t tx="ekr.20070626112754.557">def scan (self,s,parent,init=True):

    c = self.c
    if init:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language c\n")
    else:
        saveData = self.name,self.function_start,self.scan_start

    self.name,self.function_start,self.scan_start = '',0,0
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        # if i == 0 or ch == '\n': g.trace('line',repr(g.get_line(s,i)))
        # g.trace('ch',repr(ch))
        if ch == '/':         i = self.skipComments(s,i)
        elif ch in ('"',"'"): i = g.skip_string(s,i)
        elif ch == '(':     i = self.doOuterParen(s,i,parent) # Possible function/method definition.
        elif ch == ';':     i = self.doSemicolon(s,i) # Signals a possible start of a function.
        elif g.is_c_id(ch): i = self.doId(s,i,parent) # Possible class/namespace definition.
        else: i += 1
        assert i &gt; progress
    self.appendUnusedText(s,i,parent)
    if init:
        if parent.hasChildren(): c.appendStringToBody(parent,'@others')
    else:
        self.name,self.function_start,self.scan_start = saveData</t>
<t tx="ekr.20070626112754.558">def appendUnusedText (self,s,i,parent):

    c = self.c

    i = g.skip_ws_and_nl(s,self.scan_start)
    if i &lt; len(s):
        s2 = s[self.scan_start:]
        # g.trace(repr(s2))
        c.appendStringToBody(parent,s2)
</t>
<t tx="ekr.20070626112754.559">def doId (self,s,i,parent):

    j = i ; i = g.skip_c_id(s,i)
    name = s[j:i]
    if name in ('class','namespace'):
        i = self.doInner(s,j,parent,name)
    else:
        self.name = name
        while g.match(s,i,'::'):
            self.name = self.name + '::'
            i = g.skip_ws_and_nl(s,i+2)
            if g.match(s,i,'~'):
                i += 1
                self.name = self.name + '~'
            i = g.skip_ws_and_nl(s,i)
            j = i ; i = g.skip_c_id(s,i)
            name2 = s[j:i]
            self.name = self.name + name2
    return i
</t>
<t tx="ekr.20070626112754.560">def doInner (self,s,i,parent,kind):

    '''Handle a namespace or class definition.'''

    c = self.c
    start = i
    i += len(kind)
    j = g.skip_ws_and_nl(s,i)
    i = g.skip_c_id(s,j)
    name = s[j:i].strip()
    if not name: return i
    i = g.skip_ws_and_nl(s,i)
    bracket = i
    if not g.match(s,i,'{'): return i
    i = g.skip_braces(s,i)
    if g.match(s,i,'}'):
        end = i
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,';'): i += 1
        # Append previous text.
        prev = s[self.scan_start:start]
        c.appendStringToBody(parent,prev)
        self.scan_start = self.function_start = i
        preamble = s[start:bracket+1]
        # Create children.
        p = self.createHeadline(parent,headline='%s %s' % (kind,name),body=preamble)
        body = s[bracket+1:end]
        self.scan(body,p.copy(),init=False)
        # Finish the text.
        if p.hasChildren(): c.appendStringToBody(p,'\n\t@others')
        c.appendStringToBody(p,s[end:i])    
    else:
        g.trace('missing "}" following %s' % kind)
    return i
</t>
<t tx="ekr.20070626112754.561">def doOuterParen (self,s,i,parent):

    '''Handle '(' at the top level.
    This begins a function/method if and only if the character after the matching ')' is '{'.'''

    # Skip the param list.  It may not be properly matched if there are #if's involved.
    c = self.c
    i = g.skip_parens(s,i)
    if not g.match(s,i,')'): return i
    i = g.skip_ws_and_nl(s,i+1)
    if g.match(s,i,';'):
        return self.doSemicolon(s,i)
    elif g.match(s,i,'='):
        # An initializer ends a declaration.
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,'{'):
            i = g.skip_braces(s,i)
        self.function_start = i
        return i
    elif g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        if g.match(s,i,'}'):
            i += 1
            # g.trace('function %s' % self.name)
            c.appendStringToBody(parent,s[self.scan_start:self.function_start])
            body = s[self.function_start:i]
            p = self.createHeadline(parent,headline=self.name,body=body)
        else:
            g.trace('no matching "}" in function/method definition')
        self.scan_start = self.function_start = i
        return i
    else:
        return i
</t>
<t tx="ekr.20070626112754.562">def doSemicolon (self,s,i):

    self.function_start = i+1 # The semicolon ends the declaration.
    return i+1
</t>
<t tx="ekr.20070626112754.563">def skipComments (self,s,i):

    if g.match(s,i,"//"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"/*"):
        i = g.skip_block_comment(s,i)
    else:
        i += 1

    return i
</t>
<t tx="ekr.20070626112754.564"></t>
<t tx="ekr.20070626112754.565">def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)
    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
</t>
<t tx="ekr.20070626112754.566">def error (self,s): g.es(s)
</t>
<t tx="ekr.20070626112754.567">def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i &lt; len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
</t>
<t tx="ekr.20070626112754.568"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
</t>
<t tx="ekr.20070626112754.569">def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace."""

    s = s.strip()
    s = s.replace("\n"," ")
    s = s.replace("\r"," ")
    s = s.replace("\t"," ")
    s = s.replace("  "," ")
    s = s.strip()
    return s
</t>
<t tx="ekr.20070626112754.570">def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
</t>
<t tx="ekr.20070626112754.571">def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        &lt;&lt; scan for C-style comments &gt;&gt;
    elif self.fileType == ".lua":
        &lt;&lt; scan for Lua comments &gt;&gt;
    elif self.fileType == ".pas":
        &lt;&lt; scan for Pascal comments &gt;&gt;
    elif self.fileType == ".py":
        &lt;&lt; scan for Python comments &gt;&gt;
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
</t>
<t tx="ekr.20070626112754.572">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.573">while i &lt; len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.574">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.575">while i &lt; len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
</t>
<t tx="ekr.20070626112754.576"># We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i &lt; len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
</t>
<t tx="ekr.20070626112754.577">Down arrow wasn't handled properly.</t>
<t tx="ekr.20070626112754.578"></t>
<t tx="ekr.20070626112754.579">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3994218
By: rich_ries

Leo 4.4.2.1 (also seen in 4.4 final)

I was commenting some code, using the markup marks for various emphases. When
I went back and moved the cursor over the first two characters (the hidden markup
characters) of the line, I got the following error message:

===========================================================
exception executing command
Traceback (most recent call last):

  File "...leoCommands.py",line 264, in doCommand
    val = command(event)

  File "...leoEditCommands.py", line 3703, in nextLine
    g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-1c') # works

  File "...leoEditCommands.py", line 3314, in moveUpOrDownHelper
    txt = w.get( 'insert linestart', 'insert lineend' )

TypeError: unpack non-sequence
===========================================================

I did not get this when moving the cursor over the visible characters.

@color</t>
<t tx="ekr.20070626112754.580"></t>
<t tx="ekr.20070626112754.581">Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\groupOperations.py", line 139, in &lt;module&gt;
    groupOpPI = Tkinter.PhotoImage( data = groupOps )
  File "C:\prog\tigris-cvs\leo\plugins\groupOperations.py", line 139, in &lt;module&gt;
    groupOpPI = Tkinter.PhotoImage( data = groupOps )

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'

RuntimeError: Too early to create image
RuntimeError: Too early to create image

IronPythonGui 1
found  1 test routine for leoOPML
found  1 test routine for leoOPML
unexpected exception in g.importFromPath(leo_pdf)
unexpected exception in g.importFromPath(leo_pdf)
Traceback (most recent call last):
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\leo_pdf.py", line 401, in &lt;module&gt;
    class Writer (docutils.writers.Writer):
  File "C:\prog\tigris-cvs\leo\plugins\leo_pdf.py", line 401, in &lt;module&gt;
    class Writer (docutils.writers.Writer):

AttributeError: 'module' object has no attribute 'writers'
AttributeError: 'module' object has no attribute 'writers'

---mod_leo2asc 0.4-------
unexpected exception in g.importFromPath(nodebar)
unexpected exception in g.importFromPath(nodebar)
Traceback (most recent call last):
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\nodebar.py", line 33, in &lt;module&gt;
    nodeupPI = Tk.PhotoImage( data = nodeup )
  File "C:\prog\tigris-cvs\leo\plugins\nodebar.py", line 33, in &lt;module&gt;
    nodeupPI = Tk.PhotoImage( data = nodeup )

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'

RuntimeError: Too early to create image
RuntimeError: Too early to create image

rst3 plugin: SilverCity not loaded
unexpected exception in g.importFromPath(templates)
unexpected exception in g.importFromPath(templates)
Traceback (most recent call last):
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 5374, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\prog\tigris-cvs\leo\plugins\templates.py", line 88, in &lt;module&gt;
    templatePI = Tkinter.PhotoImage(data=template)
  File "C:\prog\tigris-cvs\leo\plugins\templates.py", line 88, in &lt;module&gt;
    templatePI = Tkinter.PhotoImage(data=template)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3270, in __init__
    Image.__init__(self, 'photo', name, cnf, master, **kw)

  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'
  File "c:\python25\lib\lib-tk\Tkinter.py", line 3211, in __init__
    raise RuntimeError, 'Too early to create image'

RuntimeError: Too early to create image
RuntimeError: Too early to create image

@suite test syntax of all plugins
EEEEE..E.......................................................................................................................
======================================================================
ERROR: @test test.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test leoDist.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test LeoPy.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test leoPlugins.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: @test LeoDocs.leo

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in d
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 615, in runLeoTest
    ok, frame = g.openWithFileName(path,c,enableLog=False)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 822, in openWithFileName
    g.es("exceptions opening: %s" % (fileName),color="red")
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

======================================================================
ERROR: ('test function', '&lt;unbound method opmlFileCommandsClass.test_fc_deleteFileWithMessage&gt;')
----------------------------------------------------------------------
Traceback (most recent call last):
  File "&lt;string&gt;", line 57, in runTest
  File "&lt;string&gt;", line 6, in &lt;module&gt;
  File "&lt;string&gt;", line 4, in test_fc_deleteFileWithMessage
  File "c:\prog\tigris-cvs\leo\src\leoFileCommands.py", line 2307, in deleteFileWithMessage
    g.es("exception deleting backup file:" + fileName)
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError

----------------------------------------------------------------------
Ran 127 tests in 1077.640s

FAILED (errors=6)
Traceback (most recent call last):
  File "C:\prog\test\leoBridgeTest.py", line 79, in &lt;module&gt;
    main()
  File "C:\prog\test\leoBridgeTest.py", line 32, in main
    runUnitTests(c,g)
  File "C:\prog\test\leoBridgeTest.py", line 71, in runUnitTests
    g.es('unexpected exception')
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2576, in es
    app.logWaiting.append((s+'\n',color),)
MemoryError
&gt;&gt;&gt;</t>
<t tx="ekr.20070626112754.582">def ecnl(tabName='Log'):
    g.ecnls(1,tabName)

def ecnls(n,tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines &lt; n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)

def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
</t>
<t tx="ekr.20070626112754.583"># The buggy code only happens when there is no binding for backward-delete-char.
# http://sourceforge.net/forum/forum.php?thread_id=1681392&amp;forum_id=10227</t>
<t tx="ekr.20070626112754.584"></t>
<t tx="ekr.20070626112754.585"></t>
<t tx="ekr.20070626112754.586">def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()
    if not p: return

    if c.contractVisitedNodes:
        p.contract()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.587">def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()
    if not p: return

    if c.contractVisitedNodes:
        p.contract()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.588">def goToFirstNode (self,event=None):

    '''Select the first node of the entire outline.'''

    c = self ; p = c.rootPosition()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.589">def goToFirstSibling (self,event=None):

    '''Select the first sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.590">def goToFirstVisibleNode (self,event=None):

    '''Select the first visible node of the selected chapter or hoist.'''

    c = self

    p = c.firstVisible()
    if p:
        c.selectPosition(p)

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.591">def goToLastNode (self,event=None):

    '''Select the last node in the entire tree.'''

    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext():
        p.moveToThreadNext()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.592">def goToLastSibling (self,event=None):

    '''Select the last sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.593">def goToLastVisibleNode (self,event=None):

    '''Select the last visible node of selected chapter or hoist.'''

    c = self

    p = c.lastVisible()
    if p:
        c.selectPosition(p)

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.594">def goToNextClone (self,event=None):

    '''Select the next node that is a clone of the selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not p.isCloned(): return

    t = p.v.t
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v.t == t:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20070626112754.595">def goToNextDirtyHeadline (self,event=None):

    '''Select the node that is marked as changed.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isDirty():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20070626112754.596">def goToNextMarkedHeadline (self,event=None):

    '''Select the next marked node.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.isMarked():
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()

    if not p: g.es("done",color="blue")
    c.treeSelectHelper(p) # Sets focus.
</t>
<t tx="ekr.20070626112754.597">def goToNextSibling (self,event=None):

    '''Select the next sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.next())
</t>
<t tx="ekr.20070626112754.598">def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.parent())
</t>
<t tx="ekr.20070626112754.599">def goToPrevSibling (self,event=None):

    '''Select the previous sibling of the selected node.'''

    c = self ; p = c.currentPosition()

    c.treeSelectHelper(p and p.back())
</t>
<t tx="ekr.20070626112754.600">def selectThreadBack (self,event=None):

    '''Select the node preceding the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadBack()

    c.treeSelectHelper(p)
</t>
<t tx="ekr.20070626112754.601">def selectThreadNext (self,event=None):

    '''Select the node following the selected node in outline order.'''

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()

    c.treeSelectHelper(p)</t>
<t tx="ekr.20070626112754.602"># This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)

    if p:
        redraw = not p.isVisible(c)
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
</t>
<t tx="ekr.20070626112754.603">def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.currentPosition()
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)

    if p:
        redraw = not p.isVisible(c)
        if not redraw: c.frame.tree.setSelectedLabelState(c.currentPosition())
    else:
        redraw = True

    c.treeSelectHelper(p,redraw=redraw)
</t>
<t tx="ekr.20070626112754.604"></t>
<t tx="ekr.20070626112754.605">def treeFocusHelper (self):

    c = self

    if c.config.getBool('stayInTreeAfterSelect'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.606">def treeSelectHelper (self,p,redraw=True):

    c = self ; current = c.currentPosition()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectPosition(p,updateBeadList=False)
        finally:
            c.endUpdate(redraw)

    c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.607"></t>
<t tx="ekr.20070626112754.608">def contractAllHeadlines (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self

    c.beginUpdate()
    try: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    finally:
        c.endUpdate()

    c.treeFocusHelper()

    c.expansionLevel = 1 # Reset expansion level.
</t>
<t tx="ekr.20070626112754.609">def contractNode (self,event=None):

    '''Contract the presently selected node.'''

    c = self ; p = c.currentPosition()

    # g.trace(p.headString())

    c.beginUpdate()
    try:
        p.contract()
    finally:
        c.endUpdate()

    c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.610">def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()

    if p.hasChildren() and p.isExpanded():
        # g.trace('contract',p.headString())
        c.contractNode()
    elif p.hasParent() and p.parent().isVisible(c):
        # g.trace('goto parent',p.headString())
        c.goToParent()

    c.treeFocusHelper()</t>
<t tx="ekr.20070626112754.611">def contractParent (self,event=None):

    '''Contract the parent of the presently selected node.'''

    c = self ; p = c.currentPosition()

    parent = p.parent()
    if not parent: return

    c.beginUpdate()
    try:
        parent.contract()
    finally:
        c.endUpdate(False)

    c.treeSelectHelper(parent)
</t>
<t tx="ekr.20070626112754.612">def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self ; p = root = c.rootPosition()

    c.beginUpdate()
    try:
        while p:
            c.expandSubtree(p)
            p.moveToNext()
        c.selectVnode(root)
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
</t>
<t tx="ekr.20070626112754.613">def expandAllSubheads (self,event=None):

    '''Expand all children of the presently selected node.'''

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    try:
        c.expandSubtree(v)
        while child:
            c.expandSubtree(child)
            child = child.next()
        c.selectVnode(v)
    finally:
        c.endUpdate()
        c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.614">def expandLevel1 (self,event=None):
    '''Expand the outline to level 1'''
    self.expandToLevel(1)

def expandLevel2 (self,event=None):
    '''Expand the outline to level 2'''
    self.expandToLevel(2)

def expandLevel3 (self,event=None):
    '''Expand the outline to level 3'''
    self.expandToLevel(3)

def expandLevel4 (self,event=None):
    '''Expand the outline to level 4'''
    self.expandToLevel(4)

def expandLevel5 (self,event=None):
    '''Expand the outline to level 5'''
    self.expandToLevel(5)

def expandLevel6 (self,event=None):
    '''Expand the outline to level 6'''
    self.expandToLevel(6)

def expandLevel7 (self,event=None):
    '''Expand the outline to level 7'''
    self.expandToLevel(7)

def expandLevel8 (self,event=None):
    '''Expand the outline to level 8'''
    self.expandToLevel(8)

def expandLevel9 (self,event=None):
    '''Expand the outline to level 9'''
    self.expandToLevel(9)
</t>
<t tx="ekr.20070626112754.615">def expandNextLevel (self,event=None):

    '''Increase the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="ekr.20070626112754.616">def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; v = c.currentVnode()

    c.beginUpdate()
    try:
        v.expand()
    finally:
        c.endUpdate()
        c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.617">def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    c.beginUpdate()
    try:
        if not p.isExpanded():
            c.expandNode()
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        c.treeFocusHelper()

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode()
        else:
            c.beginUpdate()
            try:
                c.selectVnode(p.firstChild())
            finally:
                c.endUpdate()
    c.treeFocusHelper()
</t>
<t tx="ekr.20070626112754.618">def expandOnlyAncestorsOfNode (self,event=None):

    '''Contract all nodes in the outline.'''

    c = self ; level = 1

    c.beginUpdate()
    try:
        for p in c.allNodes_iter():
            p.contract()
        for p in c.currentPosition().parents_iter():
            p.expand()
            level += 1
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = level # Reset expansion level.
</t>
<t tx="ekr.20070626112754.619">def expandPrevLevel (self,event=None):

    '''Decrease the expansion level of the outline and
    Expand all nodes at that level or lower.'''

    c = self ; v = c.currentVnode()

    # Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v

    self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="ekr.20070626112754.620"></t>
<t tx="ekr.20070626112754.621">def cantMoveMessage (self):

    c = self ; h = c.rootPosition().headString()
    kind = g.choose(h.startswith('@chapter'),'chapter','hoist')
    g.es("Can't move node out of %s" % (kind),color="blue")
</t>
<t tx="ekr.20070626112754.622">def demote (self,event=None):

    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext():
        c.treeFocusHelper() ; return

    # Make sure all the moves will be valid.
    next = current.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next,current,True):
            c.treeFocusHelper() ; return
        next.moveToNext()

    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(current)  # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.623">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    next = p.visNext(c)

    while next and p.isAncestorOf(next):
        next = next.visNext(c)
    if not next:
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.624">if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)

else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20070626112754.625">def moveOutlineLeft (self,event=None):

    '''Move the selected node left if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft():
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    if not p.hasParent():
        c.treeFocusHelper()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20070626112754.626">def moveOutlineRight (self,event=None):

    '''Move the selected node right if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return

    back = p.back()
    if not back:
        c.treeFocusHelper()
        return

    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeFocusHelper()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.627">def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)

    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.628">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            moved = False
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        # g.trace('move to root')
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20070626112754.629">def promote (self,event=None):

    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        # c.treeWantsFocusNow()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20070626112754.630">def endEditLabelCommand (self,event=None):

    '''End editing of a headline and move focus to the body pane.'''

    frame = self ; c = frame.c
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        # g.trace('setting focus')
        if c.config.getBool('stayInTreeAfterEditHeadline'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.631"></t>
<t tx="ekr.20070626112754.632"># Ends the editing in the outline.

def endEditing(self):

    c = self
    c.frame.tree.endEditLabel()
</t>
<t tx="ekr.20070626112754.633">@nocolor

It's about Nav_buttons v1.5 (cvs version from last Saturday) 

Pressing the green back button causes 

Error: 1 
AttributeError Exception in Tk callback 
Function: &lt;bound method Commands.goPrevVisitedNode of Commander 39717104: u'F:\\D\\PIM\\PIM_main.leo'&gt; (type: &lt;type 'instancemethod'&gt;) 
Args: () 
Traceback (innermost last): 
File "F:\C\Programs\Leo_cvs\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__ 
return apply(self.func, args) 
File "F:\C\Programs\Leo_cvs\src\leoCommands.py", line 4435, in goPrevVisitedNode 
c.treeCommandHelper(v) 
AttributeError: Commands instance has no attribute 'treeCommandHelper' 

@color</t>
<t tx="ekr.20070626112754.634">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4201463
By: fgeatfhv

I have done a cvs update today afternoon.

I know that there was an issue with the cursor. The problem there was that it
jumped down several lines at once after the 2nd key press. This one seems different
from that, though, as it goes down 2 lines if there are empty lines following
the line the cursor currently stands on.

@color
</t>
<t tx="ekr.20070626112754.635">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4205072
By: rcy3cornelledu

I find the following behavior strange: In a new window, make node "A" and clone
it.  Then make node "B" and put it between the cloned nodes "A", and finally
select the bottom node "A" so that the outline looks like:

A
B
A &lt;- select this node

Now, perform a "Move Node Up" operation, with keyboard or menu.  I get:

A &lt;- this node selected
B
A

It seems that the cloned nodes have swapped positions.  I would have expected
to see:

A
A &lt;- this node selected
B

which would be more like the behavior if I select the top node and "Move Down"


I am using the evening-of-March 6, 2007 CVS snapshot of LEO on ActivePython,
on the following platforms:

Leo 4.4.3 alpha 1, build  1.124 , January 26, 2006
Python 2.4.3, Tk 8.4.12, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

Leo 4.4.3 alpha 1, build  1.124 , January 26, 2006
Python 2.4.3, Tk 8.4.12, Pmw 1.2
linux2

If I can provide any more information, please let me know:
richard.c.yeh@bankofamerica.com, richard.c.yeh@gmail.com (I use LEO both at
work and at home.)

@color
</t>
<t tx="ekr.20070626112754.636">
Traceback (most recent call last):

  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 2474, in doHook
    return f(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\tigris-cvs\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\tigris-cvs\leo\plugins\rClick.py", line 156, in rClicker
    n0,p0=ind0.split('.',2)

AttributeError: 'int' object has no attribute 'split'
</t>
<t tx="ekr.20070626112754.637">@nocolor

the current CVS does not write to the log pane that settings, either present
in myLeoSettings.leo or the current file, were read.

@color
</t>
<t tx="ekr.20070626112754.638">def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print()
                print s
                g.app.logWaiting.append((s+'\n','blue'),)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20070626112754.639"># This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20070626112754.640">def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(fileName=path,initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20070626112754.641">def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
</t>
<t tx="ekr.20070626112754.642"></t>
<t tx="ekr.20070626112754.643">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4204734
By: fgeatfhv

This is something I encountered in 4.3.1 already, but seems to have gotten worse
since then:

A double click on a @url node results in two single clicks on that node. Result:
Nothing happens.

This occurs if there are many nodes expanded and/or the @url node itself contains
a lot of text.

If I contract all nodes (Alt+-), return to the @url node and double click it
again, the double click works and the app starts.


Franz

@color</t>
<t tx="ekr.20070626112754.644">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4197778
By: rogererens

After enabling the slideshow plugin I can advance to the next slide using the
next-slide-command, but the pressing the button that results from @button NxtSlide
in leoslideshows.leo gives an error:
simulateCommand: no command for next-slide

Leo Log Window...
Leo 4.4.3 alpha 1, build  1.125 , January 26, 2006
Python 2.5.0, Tk 8.4.12, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

leoID = rogererens (in C:\Documents and Settings\Roger)
global config dir: E:\_cvs_\Leo\config
home dir: C:\Documents and Settings\Roger
reading settings in E:\_cvs_\Leo\config\leoSettings.leo
reading: C:\Documents and Settings\Roger\Desktop\leoslideshows.leo
simulateCommand: no command for next-slide

@color
</t>
<t tx="ekr.20070626112754.645">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''

    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = (False or verbose) and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')

    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))

    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None

    if stroke:
        # g.trace('stroke',stroke,'pane',pane,commandName,g.callers())
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
            g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
        c.frame.tree.setBindings()
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')

    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20070626112754.646">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4188344
By: ktenney

current cvs W2K

Here's a @nosent node,
legend: &lt;&gt; title
        | between headline and body
        \ indicates a child node

&lt;@nosent nosent.py&gt;
|
@others

t = 'test
 \
  &lt;class test&gt;
  |
  class test:
      @others
  \
   &lt;body&gt;
   |
   pass

this produces the file:

class test:
    pass    
t = 'test'

without the &lt;BLANKLINE&gt; between 
@others and t = 'test' in the top node:

class test:
    pass    t = 'test'
</t>
<t tx="ekr.20070626112754.647"></t>
<t tx="ekr.20070626112754.648">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4162357

@color</t>
<t tx="ekr.20070626112754.649">def findSectionName(self,s,i):

    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    ok = -1 &lt; n1 &lt; n2

    # New in Leo 4.4.3: warn on extra brackets.
    if ok:
        for ch,j in (('&lt;',n1+2),('&gt;',n2+2)):
            if g.match(s,j,ch):
                line = g.get_line(s,i)
                g.es('dubious brackets in %s' % line)
                break

    return ok, n1, n2
</t>
<t tx="ekr.20070626112754.650"></t>
<t tx="ekr.20070626112754.651"></t>
<t tx="ekr.20070626112754.652">def writeWaitingLog (self):

    # g.trace(g.app.gui,self.log)

    if self.log:
        if 1: # not self.log.isNull: # The test for isNull would probably interfere with batch mode.
            for s,color in self.logWaiting:
                g.es(s,color=color,newline=0) # The caller must write the newlines.
            self.logWaiting = []
    else:
        print 'writeWaitingLog: still no log!'
</t>
<t tx="ekr.20070626112754.653">def put (self,s,color=None,tabName='Log'):
    if self.enabled:
        ### g.rawPrint(s)
        try:
            print s,
        except UnicodeError:
            s = s.encode('ascii','replace')
            print s,

def putnl (self,tabName='Log'):
    if self.enabled:
        # g.rawPrint("")
        print
</t>
<t tx="ekr.20070626112754.654"></t>
<t tx="ekr.20070626112754.655">def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    __pychecker__ = '--no-argsused' # keywords not used.

    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    adjustSysPath(g)
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20070626112754.656"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"

# NOW we can set g.
g = leoGlobals
assert(g.app)
</t>
<t tx="ekr.20070626112754.657">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20070626112754.658">def adjustSysPath (g):

    '''Adjust sys.path to enable imports as usual with Leo.'''

    import sys

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','src','test')

    for theDir in leoDirs:
        path = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..',theDir))
        if path not in sys.path:
            sys.path.append(path)
</t>
<t tx="ekr.20070626112754.659">def completeFileName (fileName):

    import leoGlobals as g

    if not fileName:
        return None

    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
</t>
<t tx="ekr.20070626112754.660">def createFrame (fileName):

    """Create a LeoFrame during Leo's startup process."""

    import leoGlobals as g

    # g.trace('fileName',fileName)

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName,initEditCommanders=True)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if frame.c.chapterController:
        frame.c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame</t>
<t tx="ekr.20070626112754.661">def createNullGuiWithScript (script):

    import leoGlobals as g
    import leoGui

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    # if not g.app.root:
        # g.app.root = g.app.gui.createRootWindow()
    # g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20070626112754.662">def getBatchScript ():

    import leoGlobals as g
    windowFlag = False

    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()

    # Bug fix 4/27/07: Don't put a return in a finally clause.
    return script, windowFlag
</t>
<t tx="ekr.20070626112754.663">def isValidPython():

    if sys.platform == 'cli':
        return True

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20070626112754.664">def reportDirectories(verbose):

    import leoGlobals as g

    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
</t>
<t tx="ekr.20070626112754.665">def startPsyco ():

    import leoGlobals as g

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        g.app.use_psyco = False
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
        g.app.use_psyco = False
</t>
<t tx="ekr.20070626112754.666">def initLeo (self):

    '''Init the Leo app to which this class gives access.
    This code is based on leo.run().'''

    if not self.isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    if not self.getLeoID(): return
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    g.app.config.readSettingsFiles(None,verbose=True)
    self.createGui() # Create the gui *before* loading plugins.
    if self.verbose: self.reportDirectories()
    self.adjustSysPath()
    g.doHook("start1") # Load plugins.
    g.init_sherlock(args=[])
    g.app.initing = False
    g.doHook("start2",c=None,p=None,v=None,fileName=None)
</t>
<t tx="ekr.20070626112754.667"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"

# NOW we can set g.
self.g = g = leoGlobals
assert(g.app)
g.app.leoID = None
</t>
<t tx="ekr.20070626112754.668">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()

try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20070626112754.669">def adjustSysPath (self):

    '''Adjust sys.path to enable imports as usual with Leo.'''

    import sys

    g = self.g

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','src','test')

    for theDir in leoDirs:
        path = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..',theDir))
        if path not in sys.path:
            sys.path.append(path)
</t>
<t tx="ekr.20070626112754.670">def createGui (self):

    g = self.g

    if self.guiName == 'nullGui':
        import leoGui
        import leoFrame
        g.app.gui = leoGui.nullGui("nullGui")
        # print 'createGui:','g.app:',id(g.app),g.app
        # print 'createGui:','g.app.gui',g.app.gui
        g.app.log = g.app.gui.log = log = leoFrame.nullLog()
        log.isNull = False
        log.enabled = True # Allow prints from nullLog.
        # g.app.writeWaitingLog()
    else:
        assert False,'leoBridge.py must run with nullGui'

    if 0: # A gui main loop is probably a bad idea.
        if self.guiName == 'tkinter':
            import leoTkinterGui
            g.app.gui = leoTkinterGui.tkinterGui()
            g.app.root = g.app.gui.createRootWindow()
            g.app.gui.finishCreate()


</t>
<t tx="ekr.20070626112754.671">def isValidPython(self):

    import sys

    if sys.platform == 'cli':
        return True

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20070626112754.672">def getLeoID (self):

    import os
    import sys

    g = self.g ; tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    verbose = False and not g.app.unitTesting
    &lt;&lt; try to get leoID from sys.leoID &gt;&gt;
    if not g.app.leoID:
        &lt;&lt; try to get leoID from "leoID.txt" &gt;&gt;
    if not g.app.leoID:
        &lt;&lt; try to get leoID from os.getenv('USER') &gt;&gt;
    return g.app.leoID
</t>
<t tx="ekr.20070626112754.673"># This would be set by in Python's sitecustomize.py file.

# Use hasattr &amp; getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es("leoID = " + g.app.leoID, color='red')</t>
<t tx="ekr.20070626112754.674">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) &gt; 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                break
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
</t>
<t tx="ekr.20070626112754.675">try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId

except Exception:
    pass
</t>
<t tx="ekr.20070626112754.676">def reportDirectories (self):

    g = self.g

    for kind,theDir in (
        ("global config",g.app.globalConfigDir),
        ("home",g.app.homeDir),
    ):
        g.es('%s dir: %s' % (kind,theDir),color="blue")
</t>
<t tx="ekr.20070626112754.677">def event_generate(self,stroke):

    w = self ; c = self.c ; char = stroke

    # Canonicalize the setting.
    stroke = c.k.shortcutFromSetting(stroke)

    # g.trace('baseTextWidget','char',char,'stroke',stroke)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,keysym):
            self.c = c
            self.char = char
            self.keysym = keysym
            self.leoWidget = w
            self.widget = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
</t>
<t tx="ekr.20070626112754.678"></t>
<t tx="ekr.20070626112754.679"># Subclassing from wx.EvtHandler allows methods of this and derived class to be event handlers.

class baseTextWidget:

    '''The base class for all wrapper classes for leo Text widgets.'''

    @others
</t>
<t tx="ekr.20070626112754.680">def __init__ (self,c,baseClassName,name,widget):

    self.baseClassName = baseClassName
    self.c = c
    self.name = name
    self.virtualInsertPoint = None
    self.widget = widget # Not used at present.

def __repr__(self):
    return '%s: %s' % (self.baseClassName,id(self))

</t>
<t tx="ekr.20070626112754.681"># Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

def onChar (self, event):

    c = self.c
    keycode = event.GetKeyCode()
    event.leoWidget = self
    keysym = g.app.gui.eventKeysym(event)
    #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    if keysym:
        c.k.masterKeyHandler(event,stroke=keysym)</t>
<t tx="ekr.20070626112754.682">def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
</t>
<t tx="ekr.20070626112754.683"># def _appendText(self,s):            self.oops()
# def _get(self,i,j):                 self.oops()
# def _getAllText(self):              self.oops()
# def _getFocus(self):                self.oops()
# def _getInsertPoint(self):          self.oops()
# def _getLastPosition(self):         self.oops()
# def _getSelectedText(self):         self.oops()
# def _getSelectionRange(self):       self.oops()
# def _hitTest(self,pos):             self.oops()
# def _insertText(self,i,s):          self.oops()
# def _scrollLines(self,n):           self.oops()
# def _see(self,i):                   self.oops()
# def _setAllText(self,s):            self.oops()
# def _setBackgroundColor(self,color): self.oops()
# def _setFocus(self):                self.oops()
# def _setInsertPoint(self,i):        self.oops()
# def _setSelectionRange(self,i,j):   self.oops()

# _findFocus = _getFocus
</t>
<t tx="ekr.20070626112754.684">def oops (self):

    print('wxGui baseTextWidget oops:',self,g.callers(),
        'must be overridden in subclass')
</t>
<t tx="ekr.20070626112754.685"></t>
<t tx="ekr.20070626112754.686">def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w._getLastPosition()
    else:
        # g.trace(repr(index))
        s = w._getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col)
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex</t>
<t tx="ekr.20070626112754.687"># This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return g.convertRowColToPythonIndex(s,row,col)    
</t>
<t tx="ekr.20070626112754.688"># These methods are widget-independent because they call the corresponding _xxx methods.</t>
<t tx="ekr.20070626112754.689">def appendText (self,s):

    w = self
    w._appendText(s)
</t>
<t tx="ekr.20070626112754.690">def bind (self,kind,*args,**keys):

    w = self

    pass # g.trace('wxLeoText',kind,args[0].__name__)</t>
<t tx="ekr.20070626112754.691">def clipboard_clear (self):

    g.app.gui.replaceClipboardWith('')

def clipboard_append(self,s):

    s1 = g.app.gui.getTextFromClipboard()

    g.app.gui.replaceClipboardWith(s1 + s)
</t>
<t tx="ekr.20070626112754.692">def delete(self,i,j=None):

    w = self
    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    # g.trace(i,j,len(s),repr(s[:20]))
    s = w.getAllText()
    w.setAllText(s[:i] + s[j:])
</t>
<t tx="ekr.20070626112754.693">def deleteTextSelection (self):

    w = self
    i,j = w._getSelectionRange()
    if i == j: return

    s = w._getAllText()
    s = s[i:] + s[j:]

    # g.trace(len(s),repr(s[:20]))
    w._setAllText(s)
</t>
<t tx="ekr.20070626112754.694">def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    return ###

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toPythonIndex(index),w.toPythonIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count &gt; 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()</t>
<t tx="ekr.20070626112754.695">def getFocus (self):

    w = self
    w2 = w._getFocus()
    # g.trace('w',w,'focus',w2)
    return w2

findFocus = getFocus
</t>
<t tx="ekr.20070626112754.696">def get(self,i,j=None):

    w = self

    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    s = w._get(i,j)
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.697">def getAllText (self):

    w = self

    s = w._getAllText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.698">def getInsertPoint(self):

    w = self
    i = w._getInsertPoint()

    # g.trace(self,'baseWidget: i:',i,'virtual',w.virtualInsertPoint)

    if i is None:
        if w.virtualInsertPoint is None:
            i = 0
        else:
            i = w.virtualInsertPoint

    w.virtualInsertPoint = i

    return i
</t>
<t tx="ekr.20070626112754.699">def GetName(self):
    return self.name

getName = GetName</t>
<t tx="ekr.20070626112754.700">def getSelectedText (self):

    w = self
    s = w._getSelectedText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.701">def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i &gt; j: i,j = j,i
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
</t>
<t tx="ekr.20070626112754.702">def getYScrollPosition (self):

     w = self
     return w._getYScrollPosition()
</t>
<t tx="ekr.20070626112754.703">def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return 0
</t>
<t tx="ekr.20070626112754.704">def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20070626112754.705"># The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toPythonIndex(i)
    # w._setInsertPoint(i)
    w._insertText(i,s)
</t>
<t tx="ekr.20070626112754.706">def indexIsVisible (self,i):

    return False # Code will loop if this returns True forever.</t>
<t tx="ekr.20070626112754.707">def replace (self,i,j,s):

    w = self
    w.delete(i,j)
    w.insert(i,s)
</t>
<t tx="ekr.20070626112754.708">def scrollLines (self,n):

    w = self
    w._scrollLines(n)</t>
<t tx="ekr.20070626112754.709">def see(self,index):

    w = self
    i = self.toPythonIndex(index)
    w._see(i)

def seeInsertPoint(self):

    w = self
    i = w._getInsertPoint()
    w._see(i)
</t>
<t tx="ekr.20070626112754.710">def selectAllText (self,insert=None):

    '''Select all text of the widget.'''

    w = self
    w.setSelectionRange(0,'end',insert=insert)
</t>
<t tx="ekr.20070626112754.711">def setAllText (self,s):

    w = self
    w._setAllText(s)</t>
<t tx="ekr.20070626112754.712">def setBackgroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setBackgroundColor(color)

SetBackgroundColour = setBackgroundColor</t>
<t tx="ekr.20070626112754.713">def setFocus (self):

    w = self
    # g.trace('baseText')
    return w._setFocus()

SetFocus = setFocus
</t>
<t tx="ekr.20070626112754.714">def setInsertPoint (self,pos):

    w = self
    w.virtualInsertPoint = i = w.toPythonIndex(pos)
    # g.trace(self,i)
    w._setInsertPoint(i)
</t>
<t tx="ekr.20070626112754.715">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    # g.trace(self,'baseWidget',repr(i1),'=',repr(i),repr(j1),'=',repr(j),repr(insert1),'=',repr(insert),g.callers(4))

    if i == j:
        w._setInsertPoint(j)
    else:
        w._setSelectionRange(i,j)

    if insert is not None and insert in (i,j):
        ins = w.toPythonIndex(insert)
        if ins in (i,j):
            self.virtualInsertPoint = ins
</t>
<t tx="ekr.20070626112754.716">def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    pass
</t>
<t tx="ekr.20070626112754.717">def setYScrollPosition (self,i):

     w = self
     w._setYScrollPosition(i)</t>
<t tx="ekr.20070626112754.718"></t>
<t tx="ekr.20070626112754.719">def mark_set(self,markName,i):

    w = self
    i = self.toPythonIndex(i)

    ### Tk.Text.mark_set(w,markName,i)
</t>
<t tx="ekr.20070626112754.720"># The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ###

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)</t>
<t tx="ekr.20070626112754.721">def tag_configure (self,colorName,**keys):
    pass

tag_config = tag_configure</t>
<t tx="ekr.20070626112754.722">def tkColorToWxColor (self, color):

    d = {
        'black':        wx.BLACK,
        "red":          wx.RED,
        "blue":         wx.BLUE,
        "#00aa00":      wx.GREEN,
        "firebrick3":   wx.RED,
        'white':        wx.WHITE,
    }

    return d.get(color)</t>
<t tx="ekr.20070626112754.723">def tag_delete (self,tagName,*args,**keys):

    pass # g.trace(tagName,args,keys)</t>
<t tx="ekr.20070626112754.724">def tag_names (self, *args):

    return []
</t>
<t tx="ekr.20070626112754.725">def tag_ranges(self,tagName):

    return tuple() ###

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
</t>
<t tx="ekr.20070626112754.726">def tag_remove(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ### Not ready yet.

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)</t>
<t tx="ekr.20070626112754.727">def yview (self,*args):

    '''w.yview('moveto',y) or w.yview()'''

    return 0,0</t>
<t tx="ekr.20070626112754.728">def xyToPythonIndex (self,x,y):
    return 0
</t>
<t tx="ekr.20070626112754.729">class leoBody:

    """The base class for the body pane in Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.730">def __init__ (self,frame,parentFrame):

    self.frame = frame
    self.c = c = frame.c
    self.editorWidgets = {} # keys are pane names, values are text widgets
    self.forceFullRecolorFlag = False
    frame.body = self

    # May be overridden in subclasses...
    self.bodyCtrl = self.widget = None ### self
    self.numberOfEditors = 1
    self.pb = None # paned body widget.

    self.use_chapters = c.config.getBool('use_chapters')

    # Must be overridden in subclasses...
    self.colorizer = None
</t>
<t tx="ekr.20070626112754.731">mustBeDefinedInSubclasses = (
    # Birth, death &amp; config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
    # 'tag_add',
    # 'tag_bind',
    # 'tag_configure',
    # 'tag_delete',
    # 'tag_remove',
)
</t>
<t tx="ekr.20070626112754.732">mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasTextSelection',
    'oops',
    'onBodyChanged',
    'onClick',
    'recolor',
    'recolor_now',
    'recolor_range',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
    # Editors... (These may be overridden)
    # 'addEditor',
    # 'cycleEditorFocus',
    # 'deleteEditor',
    # 'selectEditor',
    # 'selectLabel',
    # 'unselectLabel',
    # 'updateEditors',
)
</t>
<t tx="ekr.20070626112754.733"># Birth, death &amp; config
def createBindings (self,w=None):               self.oops()
def createControl (self,frame,parentFrame,p):   self.oops()
def setColorFromConfig (self,w=None):           self.oops()
def setFontFromConfig (self,w=None):            self.oops()
# Editor
def createEditorLabel (self,pane):              self.oops()
def setEditorColors (self,bg,fg):               self.oops()
# Events...
def scheduleIdleTimeRoutine (self,function,*args,**keys): self.oops()
</t>
<t tx="ekr.20070626112754.734"></t>
<t tx="ekr.20070626112754.735">def getColorizer(self):

    return self.colorizer

def recolor_now(self,p,incremental=False):

    self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):

    self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=False):

    if 0: # Do immediately
        self.colorizer.colorize(p.copy(),incremental)
    else: # Do at idle time
        self.colorizer.schedule(p.copy(),incremental)

def updateSyntaxColorer(self,p):

    return self.colorizer.updateSyntaxColorer(p.copy())
</t>
<t tx="ekr.20070626112754.736">@ Notes:
- body.bodyCtrl and body.frame.bodyCtrl must always be the same.

- This code uses self.pb, a paned body widget, created by tkBody.finishCreate.


</t>
<t tx="ekr.20070626112754.737"></t>
<t tx="ekr.20070626112754.738">def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    c = self.c ; p = c.currentPosition()

    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        w_old = self.editorWidgets.get('1')
        self.updateInjectedIvars(w_old,p)
        self.selectLabel(w_old) # Immediately create the label in the old editor.

    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    f = self.createEditorFrame(pane)
    &lt;&lt; create text widget w &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.739">w = self.createTextWidget(self.frame,f,name=name,p=p)
w.delete(0,'end')
w.insert('end',p.bodyString())
w.see(0)

self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
</t>
<t tx="ekr.20070626112754.740">def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
</t>
<t tx="ekr.20070626112754.741">def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    w = self.bodyCtrl ; d = self.editorWidgets

    if len(d.keys()) == 1: return

    name = w.leo_name

    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)

    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20070626112754.742">def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    d = self.editorWidgets ; values = d.values()

    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w,'leo_p') and w.leo_p and w.leo_p.equal(p)):
                # g.trace('***',id(w),'match chapter and p',p.headString())
                return w

    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # g.trace('***',id(w),'match only chapter',p.headString())
            return w

    # As a last resort, return the present editor widget.
    # g.trace('***',id(self.bodyCtrl),'no match',p.headString())
    return self.bodyCtrl
</t>
<t tx="ekr.20070626112754.743">def unselectLabel (self,w):

    self.createChapterIvar(w)
    self.packEditorLabelWidget(w)
    s = self.computeLabel(w)
    w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    if self.numberOfEditors &gt; 1:
        self.createChapterIvar(w)
        self.packEditorLabelWidget(w)
        s = self.computeLabel(w)
        # g.trace(s,g.callers())
        w.leo_label.configure(text=s,bg='white')
    elif w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None</t>
<t tx="ekr.20070626112754.744">def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController ; w = self.bodyCtrl

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)

    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.headString())
</t>
<t tx="ekr.20070626112754.745"># Called from addEditor and assignPositionToEditor

def updateEditors (self):

    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete(0,'end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.746"></t>
<t tx="ekr.20070626112754.747">def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
</t>
<t tx="ekr.20070626112754.748">def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters: ### c.config.getBool('use_chapters'):
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
</t>
<t tx="ekr.20070626112754.749">def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        g.trace('***** does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v and p2.v == w.leo_v:
                w.leo_p = p2.copy()
                return True
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            return False
</t>
<t tx="ekr.20070626112754.750">def inactivateActiveEditor(self,w):

    '''Inactivate all the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            # g.trace('inactivate',id(w2))
            break
    else:
        if trace: g.trace('no active editor!')</t>
<t tx="ekr.20070626112754.751">def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl

    # g.trace(id(w),c.currentPosition().headString())

    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w

    c.recolor_now(interruptable=False) # Force a complete recoloring.

    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w</t>
<t tx="ekr.20070626112754.752">def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.753"># Called from addEditor and assignPositionToEditor.

def updateInjectedIvars (self,w,p):

    c = self.c ; cc = c.chapterController ; 

    if cc and self.use_chapters: ### c.config.getBool('use_chapters'):
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
    w.leo_v = w.leo_p.v
    w.leo_label_s = p.headString()

    # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.headString())
</t>
<t tx="ekr.20070626112754.754"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.currentPosition()
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText),g.callers())
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.bodyString() ; changed = True
    else:
        changed = oldText != newText
    # g.trace(repr(ch),'changed:',changed,'newText:',repr(newText))
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20070626112754.755">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False

if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
</t>
<t tx="ekr.20070626112754.756">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True

    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    # g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '&lt;None&gt;')
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
</t>
<t tx="ekr.20070626112754.757">def onClick (self,event):

    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)

    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
</t>
<t tx="ekr.20070626112754.758">def oops (self):

    g.trace("leoBody oops:", g.callers(), "should be overridden in subclass")
</t>
<t tx="ekr.20070626112754.759"></t>
<t tx="ekr.20070626112754.760">def getSelectionAreas (self):

    """Return before,sel,after where:

    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    w = self.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j: j = i + 1

    before = s[0:i]
    sel    = s[i:j]
    after  = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    sel    = g.toUnicode(sel,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)
    return before,sel,after</t>
<t tx="ekr.20070626112754.761">def getYScrollPosition (self):
    return self.bodyCtrl.getYScrollPosition()

def setYScrollPosition (self,scrollPosition):
    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.setYScrollPosition(first)
</t>
<t tx="ekr.20070626112754.762">def getAllText (self):                  return self.bodyCtrl.getAllText()
def getInsertPoint(self):               return self.bodyCtrl.getInsertPoint()
def getSelectedText (self):             return self.bodyCtrl.getSelectedText()
def getSelectionRange (self,sort=True): return self.bodyCtrl.getSelectionRange(sort)
def hasTextSelection (self):            return self.bodyCtrl.hasSelection()
# def scrollDown (self):                g.app.gui.yscroll(self.bodyCtrl,1,'units')
# def scrollUp (self):                  g.app.gui.yscroll(self.bodyCtrl,-1,'units')
def see (self,index):                   self.bodyCtrl.see(index)
def seeInsertPoint (self):              self.bodyCtrl.seeInsertPoint()
def selectAllText (self,event=None): # This is a command.
    w = g.app.gui.eventWidget(event) or self.bodyCtrl
    return w.selectAllText()
def setInsertPoint (self,pos):          return self.bodyCtrl.setInsertPoint(pos) # was getInsertPoint.
def setSelectionRange (self,sel):       i,j = sel ; self.bodyCtrl.setSelectionRange(i,j)
</t>
<t tx="ekr.20070626112754.763">class leoGui:

    """The base class of all gui classes.

    Subclasses are expected to override all do-nothing methods of this class."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    &lt;&lt; define leoGui file types &gt;&gt;

    @others
</t>
<t tx="ekr.20070626112754.764">allFullFiletypes = [
    ("All files",   "*"),
    ("C/C++ files", "*.c"),
    ("C/C++ files", "*.cpp"),
    ("C/C++ files", "*.h"),
    ("C/C++ files", "*.hpp"),
    ("Java files",  "*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py")]
    # To do: *.php, *.php3, *.php4")
pythonFullFiletypes = [
    ("Python files","*.py"),
    ("All files","*"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas")]
    # To do: *.php, *.php3, *.php4")
textFullFiletypes = [
    ("Text files","*.txt"),
    ("C/C++ files","*.c"),
    ("C/C++ files","*.cpp"),
    ("C/C++ files","*.h"),
    ("C/C++ files","*.hpp"),
    ("Java files","*.java"),
    ("Lua files",   "*.lua"),
    ("Pascal files","*.pas"),
    ("Python files","*.py"),
    ("All files","*")]
    # To do: *.php, *.php3, *.php4")
CWEBTextAllFiletypes = [
    ("CWEB files","*.w"),
    ("Text files","*.txt"),
    ("All files", "*")]
leoAllFiletypes = [
    ("Leo files","*.leo"),
    ("All files","*")]
leoFiletypes = [
    ("Leo files","*.leo")]
nowebTextAllFiletypes = [
    ("Noweb files","*.nw"),
    ("Text files", "*.txt"),
    ("All files",  "*")]
textAllFiletypes = [
    ("Text files","*.txt"),
    ("All files", "*")]
</t>
<t tx="ekr.20070626112754.765"></t>
<t tx="ekr.20070626112754.766">def __init__ (self,guiName):

    # g.trace("leoGui",guiName,g.callers())

    self.lastFrame = None
    self.leoIcon = None
    self.mGuiName = guiName
    self.mainLoop = None
    self.root = None
    self.script = None
    self.utils = None
    self.isNullGui = False
    self.bodyTextWidget = None
    self.plainTextWidget = None
    self.trace = False

</t>
<t tx="ekr.20070626112754.767">mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)</t>
<t tx="ekr.20070626112754.768">mustBeDefinedInSubclasses = (
    # Startup &amp; shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    #'createFindPanel',             # optional
    'createFindTab',
    'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    'eventChar',
    'eventKeysym',
    'eventWidget',
    'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
</t>
<t tx="ekr.20070626112754.769"></t>
<t tx="ekr.20070626112754.770">def guiName(self):

    try:
        return self.mGuiName
    except:
        return "invalid gui name"
</t>
<t tx="ekr.20070626112754.771">def setScript (self,script=None,scriptFileName=None):

    self.script = script
    self.scriptFileName = scriptFileName
</t>
<t tx="ekr.20070626112754.772"></t>
<t tx="ekr.20070626112754.773"></t>
<t tx="ekr.20070626112754.774">def createRootWindow(self):

    """Create the hidden root window for the gui.

    Nothing needs to be done if the root window need not exist."""

    self.oops()
</t>
<t tx="ekr.20070626112754.775">def destroySelf (self):

    self.oops()
</t>
<t tx="ekr.20070626112754.776">def killGui(self,exitFlag=True):

    """Destroy the gui.

    The entire Leo application should terminate if exitFlag is True."""

    self.oops()
</t>
<t tx="ekr.20070626112754.777">def recreateRootWindow(self):

    """Create the hidden root window of the gui
    after a previous gui has terminated with killGui(False)."""

    self.oops()
</t>
<t tx="ekr.20070626112754.778">def runMainLoop(self):

    """Run the gui's main loop."""

    self.oops()
</t>
<t tx="ekr.20070626112754.779">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()
</t>
<t tx="ekr.20070626112754.780">def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    self.oops()

    # import leoKeys # Do this here to break a circular dependency.

    # return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)</t>
<t tx="ekr.20070626112754.781">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    self.oops()

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""

    self.oops()
</t>
<t tx="ekr.20070626112754.782">def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    self.oops()

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    self.oops()
</t>
<t tx="ekr.20070626112754.783">@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for None returns.

The type of commander passed to methods depends on the type of frame or dialog being created.  The commander may be a Commands instance or one of its subcommanders.
</t>
<t tx="ekr.20070626112754.784">def replaceClipboardWith (self,s):

    self.oops()

def getTextFromClipboard (self):

    self.oops()
</t>
<t tx="ekr.20070626112754.785"># g.es calls gui.color to do the translation,
# so most code in Leo's core can simply use Tk color names.

def color (self,color):
    '''Return the gui-specific color corresponding to the Tk color name.'''
    return color # Do not call oops: this method is essential for the config classes.
</t>
<t tx="ekr.20070626112754.786">def attachLeoIcon (self,window):
    """Attach the Leo icon to a window."""
    self.oops()

def center_dialog(self,dialog):
    """Center a dialog."""
    self.oops()

def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
    """Create a labeled frame."""
    self.oops()

def get_window_info (self,window):
    """Return the window information."""
    self.oops()
</t>
<t tx="ekr.20070626112754.787">def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''   
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0</t>
<t tx="ekr.20070626112754.788">def getFullVersion (self,c):

    return 'leoGui: dummy version'
</t>
<t tx="ekr.20070626112754.789">def get_focus(self,frame):
    """Return the widget that has focus, or the body widget if None."""
    self.oops()

def set_focus(self,commander,widget):
    """Set the focus of the widget in the given commander if it needs to be changed."""
    self.oops()
</t>
<t tx="ekr.20070626112754.790">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    pass
    # self.oops()
</t>
<t tx="ekr.20070626112754.791">def setIdleTimeHook (self,idleTimeHookHandler):

    # print 'leoGui:setIdleTimeHook'
    pass # Not an error.

def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):

    # print 'leoGui:setIdleTimeHookAfterDelay'
    pass # Not an error.
</t>
<t tx="ekr.20070626112754.792">def makeScriptButton (
    self,c,
    p=None,
    script=None,
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,
    bg='LightSteelBlue1',
    define_g=True,
    define_name='__main__',
    silent=False, 
):

    self.oops()
</t>
<t tx="ekr.20070626112754.793"></t>
<t tx="ekr.20070626112754.794">def finishCreate (self):

    pass</t>
<t tx="ekr.20070626112754.795">def oops (self):

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        print "leoGui oops", g.callers(), "should be overridden in subclass"
</t>
<t tx="ekr.20070626112754.796">def widget_name (self,w):

    # First try the widget's getName method.
    if hasattr(w,'getName'):
        return w.getName()
    elif hasattr(w,'_name'):
        return w._name
    else:
        return repr(w)
</t>
<t tx="ekr.20070626112754.797">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20070626112754.798">class leoLog:

    """The base class for the log pane in Leo windows."""

    __pychecker__ = '--no-argsused' # base classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.799">def __init__ (self,frame,parentFrame):

    self.frame = frame
    if frame: # 7/16/05: Allow no commander for Null logs.
        self.c = frame.c
    else:
        self.c = None
    self.enabled = True
    self.newlines = 0
    self.isNull = False

    # Official status variables.  Can be used by client code.
    self.logCtrl = None # Set below. Same as self.textDict.get(self.tabName)
    self.tabName = None # The name of the active tab.
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)

    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    self.textDict = {}  # Keys are page names. Values are logCtrl's (text widgets).


</t>
<t tx="ekr.20070626112754.800">def onActivateLog (self,event=None):

    self.c.setLog()

def disable (self):

    self.enabled = False

def enable (self,enabled=True):

    self.enabled = enabled

</t>
<t tx="ekr.20070626112754.801">def configure (self,*args,**keys):      pass
def configureBorder(self,border):       pass
def createControl (self,parentFrame):   pass
def finishCreate (self):                pass
def setColorFromConfig (self):          pass
def setFontFromConfig (self):           pass
</t>
<t tx="ekr.20070626112754.802">def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    w and w.delete(0,'end')
</t>
<t tx="ekr.20070626112754.803">def createTab (self,tabName,createText=True,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k

    if createText:
        w = self.createTextWidget(tabFrame)
        self.textDict [tabName] = w
    else:
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabName # tabFrame
</t>
<t tx="ekr.20070626112754.804">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)

    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20070626112754.805">def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass
    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')
    else:
        for d in (self.textDict,self.frameDict):
            if tabName in d.keys():
                del d[tabName]
        self.tabName = None
        self.selectTab('Log')

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.806">def hideTab (self,tabName):

    __pychecker__ = '--no-argsused' # tabName

    self.selectTab('Log')
</t>
<t tx="ekr.20070626112754.807">def getSelectedTab (self):

    return self.tabName
</t>
<t tx="ekr.20070626112754.808">def lowerTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.809">def numberOfVisibleTabs (self):

    return len([val for val in self.frameDict.values() if val != None])
</t>
<t tx="ekr.20070626112754.810">def renameTab (self,oldName,newName):
    pass
</t>
<t tx="ekr.20070626112754.811">def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c
    tabFrame = self.frameDict.get(tabName)
    if not tabFrame:
        self.createTab(tabName,createText=createText)

    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0:
        # Absolutely do not do this here!
        # It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)

    return tabFrame
</t>
<t tx="ekr.20070626112754.812"># All output to the log stream eventually comes here.

def put (self,s,color=None,tabName='Log'):
    self.oops()

def putnl (self,tabName='Log'):
    self.oops()
</t>
<t tx="ekr.20070626112754.813">def oops (self):

    print "leoLog oops:", g.callers(), "should be overridden in subclass"
</t>
<t tx="ekr.20070626112754.814">class leoTkinterLog (leoFrame.leoLog):

    """A class that represents the log pane of a Tkinter window."""

    @others
</t>
<t tx="ekr.20070626112754.815"></t>
<t tx="ekr.20070626112754.816">def __init__ (self,frame,parentFrame):

    # g.trace("leoTkinterLog")

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.

    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")

    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()



</t>
<t tx="ekr.20070626112754.817">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        return self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # Create and activate the default tabs.

    return self.logCtrl
</t>
<t tx="ekr.20070626112754.818">def createTextWidget (self,parentFrame):

    self.logNumber += 1
    log = g.app.gui.plainTextWidget(
        parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")

    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview

    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
</t>
<t tx="ekr.20070626112754.819">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    # g.trace(tabName,g.callers())

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.

    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)

    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            return self.deleteTab(tabName)

        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)

        def renameTabCallback():
            return self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
</t>
<t tx="ekr.20070626112754.820"></t>
<t tx="ekr.20070626112754.821">def configureBorder(self,border):

    self.logCtrl.configure(bd=border)

def configureFont(self,font):

    self.logCtrl.configure(font=font)
</t>
<t tx="ekr.20070626112754.822">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
</t>
<t tx="ekr.20070626112754.823">def restoreAllState (self,d):

    '''Restore the log from a dict created by saveAllState.'''

    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
</t>
<t tx="ekr.20070626112754.824">def saveAllState (self):

    '''Return a dict containing all data needed to recreate the log in another widget.'''

    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.getAllText()

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)

    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
</t>
<t tx="ekr.20070626112754.825">def setColorFromConfig (self):

    c = self.c

    bg = c.config.getColor("log_pane_background_color") or 'white'

    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
</t>
<t tx="ekr.20070626112754.826">def SetWidgetFontFromConfig (self,logCtrl=None):

    c = self.c

    if not logCtrl: logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant", "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)

    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass

    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass

setFontFromConfig = SetWidgetFontFromConfig # Renaming supresses a pychecker warning.
</t>
<t tx="ekr.20070626112754.827"></t>
<t tx="ekr.20070626112754.828">def onActivateLog (self,event=None):

    try:
        self.c.setLog()
        self.frame.tree.OnDeactivate()
        self.c.logWantsFocus()
    except:
        g.es_event_exception("activate log")
</t>
<t tx="ekr.20070626112754.829">def hasFocus (self):

    return self.c.get_focus() == self.logCtrl
</t>
<t tx="ekr.20070626112754.830">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()
</t>
<t tx="ekr.20070626112754.831">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
</t>
<t tx="ekr.20070626112754.832"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c

    # print 'tkLog.put',self.c.shortFileName(),tabName,g.callers()

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)

    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
        self.logCtrl.update_idletasks()
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;
</t>
<t tx="ekr.20070626112754.833">if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see('end')
self.forceLogUpdate(s)
</t>
<t tx="ekr.20070626112754.834">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
</t>
<t tx="ekr.20070626112754.835">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)

    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see('end')
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20070626112754.836"></t>
<t tx="ekr.20070626112754.837">def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    w and w.delete(0,'end')
</t>
<t tx="ekr.20070626112754.838">def createTab (self,tabName,createText=True,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    if createText:
        &lt;&lt; Create the tab's text widget &gt;&gt;
        if tabName != 'Log':
            # c.k doesn't exist when the log pane is created.
            # k.makeAllBindings will call setTabBindings('Log')
            self.setTabBindings(tabName)
    else:
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabFrame
</t>
<t tx="ekr.20070626112754.839">w = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'

if wrap not in ('none','char','word'): wrap = 'none'
try: w.configure(bg=bg,wrap=wrap)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=w)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = w

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags
</t>
<t tx="ekr.20070626112754.840">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20070626112754.841">def hideTab (self,tabName):

    __pychecker__ = '--no-argsused' # tabName

    self.selectTab('Log')
</t>
<t tx="ekr.20070626112754.842">def getSelectedTab (self):

    return self.tabName
</t>
<t tx="ekr.20070626112754.843">def lowerTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.844">def numberOfVisibleTabs (self):

    return len([val for val in self.frameDict.values() if val != None])
</t>
<t tx="ekr.20070626112754.845">def renameTab (self,oldName,newName):

    # g.trace('newName',newName)

    label = self.nb.tab(oldName)
    label.configure(text=newName)
</t>
<t tx="ekr.20070626112754.846">def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c

    tabFrame = self.frameDict.get(tabName)
    logCtrl = self.textDict.get(tabName)

    if tabFrame and logCtrl:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    elif not tabFrame:
        self.createTab(tabName,createText=createText,wrap=wrap)

    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
</t>
<t tx="ekr.20070626112754.847"></t>
<t tx="ekr.20070626112754.848">def onRightClick (self,event,menu):

    c = self.c
    menu.post(event.x_root,event.y_root)


def onClick (self,event,tabName):

    self.selectTab(tabName)
</t>
<t tx="ekr.20070626112754.849">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)

    # This is called by getTabName.
    def selectTabCallback (newName):
        return self.selectTab(newName)

    self.getTabName(selectTabCallback)
</t>
<t tx="ekr.20070626112754.850">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            return self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
</t>
<t tx="ekr.20070626112754.851">def getTabName (self,exitCallback):

    canvas = self.nb.component('hull')

    # Overlay what is there!
    c = self.c
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)

    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)

    def closeTabNameCallback (event=None):
        f.pack_forget()

    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)

    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    g.app.gui.set_focus(c,e)
    e.bind('&lt;Return&gt;',getNameCallback)
</t>
<t tx="ekr.20070626112754.852">def createColorPicker (self,tabName):

    log = self

    &lt;&lt; define colors &gt;&gt;

    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    colors = list(colors)
    bg = parent.cget('background')

    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)

    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')

    label = g.app.gui.plainTextWidget(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;
</t>
<t tx="ekr.20070626112754.853">colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
</t>
<t tx="ekr.20070626112754.854">def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
</t>
<t tx="ekr.20070626112754.855">colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
</t>
<t tx="ekr.20070626112754.856"></t>
<t tx="ekr.20070626112754.857">def createFontPicker (self,tabName):

    log = self
    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    bg = parent.cget('background')
    font = self.getFont()
    &lt;&lt; create the frames &gt;&gt;
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    &lt;&lt; create the sample text widget &gt;&gt;
    &lt;&lt; create and bind the callbacks &gt;&gt;
    self.createBindings()
</t>
<t tx="ekr.20070626112754.858">f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
</t>
<t tx="ekr.20070626112754.859">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

self.familyBox = familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.860">Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4)
sizeEntry.insert(0,'12')
sizeEntry.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.861">weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.862">slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.863">self.sampleWidget = sample = g.app.gui.plainTextWidget(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert(0,s)
</t>
<t tx="ekr.20070626112754.864">def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('&lt;Return&gt;',fontCallback)
</t>
<t tx="ekr.20070626112754.865">def createBindings (self):

    c = self.c ; k = c.k

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ("&lt;Escape&gt;",    self.hideFontTab),
    )

    w = self.sampleWidget
    for event, callback in table:
        w.bind(event,callback)

    k.completeAllBindingsForWidget(w)
</t>
<t tx="ekr.20070626112754.866">def getFont(self,family=None,size=12,slant='roman',weight='normal'):

    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
</t>
<t tx="ekr.20070626112754.867">def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','&lt;none&gt;',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
</t>
<t tx="ekr.20070626112754.868">def hideFontTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.869">class nullBody (leoBody):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.870">def __init__ (self,frame,parentFrame):

    # g.trace('nullBody','frame',frame,g.callers())

    leoBody.__init__ (self,frame,parentFrame) # Init the base class.

    self.insertPoint = 0
    self.selection = 0,0
    self.s = "" # The body text

    w = stringTextWidget(c=self.c,name='body')
    self.bodyCtrl = self.widget = w
    self.editorWidgets['1'] = w
    self.colorizer = leoColor.nullColorizer(self.c)
</t>
<t tx="ekr.20070626112754.871"></t>
<t tx="ekr.20070626112754.872">def findStartOfLine (self,lineNumber):

    lines = g.splitLines(self.s)
    i = 0 ; index = 0
    for line in lines:
        if i == lineNumber: break
        i += 1
        index += len(line)
    return index
</t>
<t tx="ekr.20070626112754.873">def scanToStartOfLine (self,i):

    if i &lt;= 0:
        return 0

    assert(self.s[i] != '\n')

    while i &gt;= 0:
        if self.s[i] == '\n':
            return i + 1

    return 0
</t>
<t tx="ekr.20070626112754.874">def scanToEndOfLine (self,i):

    if i &gt;= len(self.s):
        return len(self.s)

    assert(self.s[i] != '\n')

    while i &lt; len(self.s):
        if self.s[i] == '\n':
            return i - 1

    return i
</t>
<t tx="ekr.20070626112754.875"># Birth, death &amp; config
def bind(self,*args,**keys):                pass
def createBindings (self,w=None):           pass
def createControl (self,frame,parentFrame,p): pass
def setColorFromConfig (self,w=None):       pass
def setFontFromConfig (self,w=None):        pass
# Editors...
def addEditor (self,event=None):            pass
def assignPositionToEditor (self,p):        pass
def createEditorFrame (self,w):             pass
def cycleEditorFocus (self,event=None):     pass
def deleteEditor (self,event=None):         pass
def selectEditor(self,w):                   pass
def selectLabel (self,w):                   pass
def setEditorColors (self,bg,fg):           pass
def unselectLabel (self,w):                 pass
def updateEditors (self):                   pass
# Events...
def forceFullRecolor (self,*args,**keys):   pass
def scheduleIdleTimeRoutine (self,function,*args,**keys): pass
# Low-level gui...
def getBodyPaneHeight (self):               return 500
def getBodyPaneWidth (self):                return 600
def hasFocus (self):                        pass
def setFocus (self):                        pass
def tag_add (self,tagName,index1,index2):   pass
def tag_bind (self,tagName,event,callback): pass
def tag_configure (self,colorName,**keys):  pass
def tag_delete(self,tagName):               pass
def tag_remove (self,tagName,index1,index2):pass
</t>
<t tx="ekr.20070626112754.876">class nullFindTab (findTab):

    @others</t>
<t tx="ekr.20070626112754.877"></t>
<t tx="ekr.20070626112754.878">if 0: # Use the base-class ctor.

    def __init__ (self,c,parentFrame):

        findTab.__init__(self,c,parentFrame)
            # Init the base class.
            # Calls initGui, createFrame, createBindings &amp; init(c), in that order.
</t>
<t tx="ekr.20070626112754.879"># Called from findTab.ctor.

def initGui (self):

    self.svarDict = {} # Keys are ivar names, values are svar objects.

    for key in self.intKeys:
        self.svarDict[key] = self.svar() # Was Tk.IntVar.

    for key in self.newStringKeys:
        self.svarDict[key] = self.svar() # Was Tk.StringVar.
</t>
<t tx="ekr.20070626112754.880"># Called from findTab.ctor.

def init (self,c):

    # Separate c.ivars are much more convenient than a svarDict.
    for key in self.intKeys:
        # Get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0)
        svar = self.svarDict.get(key)
        if svar: svar.set(val)
        #g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;
    &lt;&lt; set checkboxes from ivars &gt;&gt;
</t>
<t tx="ekr.20070626112754.881">self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
</t>
<t tx="ekr.20070626112754.882"># In Tk, setting the var also sets the widget.
# Here, we do so explicitly.
d = self.widgetsDict
for ivar,key in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-find-type"].set(key)
        w = d.get(key)
        if w: w.set(True)
        break
else:
    self.svarDict["radio-find-type"].set("plain-search")

for ivar,key in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    svar = self.svarDict[ivar].get()
    if svar:
        self.svarDict["radio-search-scope"].set(key)
        break
else:
    key = 'entire-outline'
    self.svarDict["radio-search-scope"].set(key)
    w = self.widgetsDict.get(key)
    if w: w.set(True)
</t>
<t tx="ekr.20070626112754.883">for ivar in (
    'ignore_case',
    'mark_changes',
    'mark_finds',
    'pattern_match',
    'reverse',
    'search_body',
    'search_headline',
    'whole_word',
    'wrap',
):
    svar = self.svarDict[ivar].get()
    if svar:
        w = self.widgetsDict.get(ivar)
        if w: w.set(True)
</t>
<t tx="ekr.20070626112754.884">def createBindings (self):
    pass</t>
<t tx="ekr.20070626112754.885">def createFrame (self,parentFrame):

    self.parentFrame = self.top = parentFrame

    self.createFindChangeAreas()
    self.createBoxes()</t>
<t tx="ekr.20070626112754.886">def createFindChangeAreas (self):

    c = self.c

    # A plainTextWidget must be a stringTextWidget
    plainTextWidget = g.app.gui.plainTextWidget

    import leoFrame
    assert issubclass(plainTextWidget,leoFrame.stringTextWidget)

    self.find_ctrl   = plainTextWidget(c,name='find-text')
    self.change_ctrl = plainTextWidget(c,name='change-text')
</t>
<t tx="ekr.20070626112754.887">def createBoxes (self):

    '''Create two columns of radio buttons &amp; check boxes.'''

    c = self.c
    # f = self.parentFrame
    self.boxes = []
    self.widgetsDict = {} # Keys are ivars, values are checkboxes or radio buttons.

    data = ( # Leading star denotes a radio button.
        ('Whole &amp;Word', 'whole_word',),
        ('&amp;Ignore Case','ignore_case'),
        ('Wrap &amp;Around','wrap'),
        ('&amp;Reverse',    'reverse'),
        ('Rege&amp;xp',     'pattern_match'),
        ('Mark &amp;Finds', 'mark_finds'),
        ("*&amp;Entire Outline","entire-outline"),
        ("*&amp;Suboutline Only","suboutline-only"),  
        ("*&amp;Node Only","node-only"),
        ('Search &amp;Headline','search_headline'),
        ('Search &amp;Body','search_body'),
        ('Mark &amp;Changes','mark_changes'),
    )

    # Important: changing these controls merely changes entries in self.svarDict.
    # First, leoFind.update_ivars sets the find ivars from self.svarDict.
    # Second, self.init sets the values of widgets from the ivars.
    # inGroup = False
    for label,ivar in data:
        if label.startswith('*'):
            label = label[1:]
            # style = g.choose(inGroup,0,wx.RB_GROUP)
            # inGroup = True
            # w = wx.RadioButton(f,label=label,style=style)
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
            # def radioButtonCallback(event=None,ivar=ivar):
                # svar = self.svarDict["radio-search-scope"]
                # svar.set(ivar)
            # w.Bind(wx.EVT_RADIOBUTTON,radioButtonCallback)
        else:
            #w = wx.CheckBox(f,label=label)
            w = self.buttonWidget(label)
            self.widgetsDict[ivar] = w
            # def checkBoxCallback(event=None,ivar=ivar):
                # svar = self.svarDict.get(ivar)
                # val = svar.get()
                # svar.set(g.choose(val,False,True))
                # # g.trace(ivar,val)
            # w.Bind(wx.EVT_CHECKBOX,checkBoxCallback)
        self.boxes.append(w)</t>
<t tx="ekr.20070626112754.888">def createButtons (self):

    '''Create two columns of buttons.'''

    # # Create the alignment panes.
    # buttons  = Tk.Frame(outer,background=bg)
    # buttons1 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons2 = Tk.Frame(buttons,bd=1,background=bg)
    # buttons.pack(side='top',expand=1)
    # buttons1.pack(side='left')
    # buttons2.pack(side='right')

    # width = 15 ; defaultText = 'Find' ; buttons = []

    # for text,boxKind,frame,callback in (
        # # Column 1...
        # ('Find','button',buttons1,self.findButtonCallback),
        # ('Find All','button',buttons1,self.findAllButton),
        # # Column 2...
        # ('Change','button',buttons2,self.changeButton),
        # ('Change, Then Find','button',buttons2,self.changeThenFindButton),
        # ('Change All','button',buttons2,self.changeAllButton),
    # ):
        # w = underlinedTkButton(boxKind,frame,
            # text=text,command=callback)
        # buttons.append(w)
        # if text == defaultText:
            # w.button.configure(width=width-1,bd=4)
        # elif boxKind != 'check':
            # w.button.configure(width=width)
        # w.button.pack(side='top',anchor='w',pady=2,padx=2)
</t>
<t tx="ekr.20070626112754.889">class svar:
    '''A class like Tk's IntVar and StringVar classes.'''
    def __init__(self):
        self.val = None
    def get (self):
        return self.val
    def set (self,val):
        self.val = val

    SetValue = set # SetValue is the wxWidgets spelling.</t>
<t tx="ekr.20070626112754.890">class buttonWidget:

    '''A class to simulate a Tk.Button.'''

    def __init__ (self,label):
        self.label = label
        self.val = False

    def __repr (self):
        return 'nullFindTab.buttonWidget: %s' % self.label

    def get (self):
        return self.val

    def set (self,val):
        self.val = val
</t>
<t tx="ekr.20070626112754.891"># This is the same as the Tk code because we simulate Tk svars.</t>
<t tx="ekr.20070626112754.892">def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
</t>
<t tx="ekr.20070626112754.893">def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.894">def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.895">class nullFrame (leoFrame):

    """A null frame class for tests and batch execution."""

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.896">def __init__ (self,title,gui,useNullUndoer=False):

    # g.trace('nullFrame')

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)

    self.body = None
    self.bodyCtrl = None
    self.iconBar = nullIconBarClass(self.c,self)
    # self.iconBarClass = self.nullIconBarClass
    self.isNullFrame = True
    self.outerFrame = None
    self.statusLineClass = nullStatusLineClass
    self.title = title
    self.useNullUndoer = useNullUndoer

    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
</t>
<t tx="ekr.20070626112754.897">def destroySelf (self):

    pass
</t>
<t tx="ekr.20070626112754.898">def finishCreate(self,c):

    self.c = c

    # print 'nullFrame'

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)

    c.setLog()

    # Set the official ivar.
    self.bodyCtrl = self.body.bodyCtrl

    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)


</t>
<t tx="ekr.20070626112754.899"></t>
<t tx="ekr.20070626112754.900">def resizePanesToRatio (self,ratio,secondary_ratio):    pass
def setInitialWindowGeometry (self):                    pass
def setMinibufferBindings(self):                        pass
</t>
<t tx="ekr.20070626112754.901">def setTopGeometry (self,w,h,x,y,adjustSize=True):

    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.

    self.w = w
    self.h = h
    self.x = x
    self.y = y
</t>
<t tx="ekr.20070626112754.902"># Expanding and contracting panes.
def contractPane         (self,event=None): pass
def expandPane           (self,event=None): pass
def contractBodyPane     (self,event=None): pass
def contractLogPane      (self,event=None): pass
def contractOutlinePane  (self,event=None): pass
def expandBodyPane       (self,event=None): pass
def expandLogPane        (self,event=None): pass
def expandOutlinePane    (self,event=None): pass
def fullyExpandBodyPane  (self,event=None): pass
def fullyExpandLogPane   (self,event=None): pass
def fullyExpandPane      (self,event=None): pass
def fullyExpandOutlinePane (self,event=None): pass
def hideBodyPane         (self,event=None): pass
def hideLogPane          (self,event=None): pass
def hidePane             (self,event=None): pass
def hideOutlinePane      (self,event=None): pass

# In the Window menu...
def cascade              (self,event=None): pass
def equalSizedPanes      (self,event=None): pass
def hideLogWindow        (self,event=None): pass
def minimizeAll          (self,event=None): pass
def resizeToScreen       (self,event=None): pass
def toggleActivePane     (self,event=None): pass
def toggleSplitDirection (self,event=None): pass

# In help menu...
def leoHelp (self,event=None): pass</t>
<t tx="ekr.20070626112754.903">def bringToFront (self):    pass
def deiconify (self):       pass
def get_window_info(self):
    # Set w,h,x,y to a reasonable size and position.
    return 600,500,20,20
def lift (self):            pass
def setWrap (self,flag):    pass
def update (self):          pass
</t>
<t tx="ekr.20070626112754.904">class nullGui(leoGui):

    """Null gui class."""

    __pychecker__ = '--no-argsused' # This class has many unused args.

    @others
</t>
<t tx="ekr.20070626112754.905"></t>
<t tx="ekr.20070626112754.906">def __init__ (self,guiName):

    leoGui.__init__ (self,guiName) # init the base class.

    self.clipboardContents = ''
    self.dict = {}
    self.focusWidget = None
    self.script = None
    self.lastFrame = None
    self.isNullGui = True
    self.bodyTextWidget  = leoFrame.stringTextWidget
    self.plainTextWidget = leoFrame.stringTextWidget
</t>
<t tx="ekr.20070626112754.907">def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    import leoKeys # Do this here to break a circular dependency.

    return leoKeys.keyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)</t>
<t tx="ekr.20070626112754.908">def runMainLoop(self):

    """Run the gui's main loop."""

    if self.script:
        frame = self.lastFrame
        g.app.log = frame.log
        # g.es("Start of batch script...\n")
        self.lastFrame.c.executeScript(script=self.script)
        # g.es("\nEnd of batch script")

    # Getting here will terminate Leo.
</t>
<t tx="ekr.20070626112754.909">def isTextWidget (self,w):

    '''Return True if w is a Text widget suitable for text-oriented commands.'''

    return w and isinstance(w,leoFrame.baseTextWidget)
</t>
<t tx="ekr.20070626112754.910">def oops(self):

    """Default do-nothing method for nullGui class.

    It is NOT an error to use this method."""

    # It is not usually an error to call methods of this class.
    # However, this message is useful when writing gui plugins.
    if 1:
        g.trace("nullGui",g.callers())
</t>
<t tx="ekr.20070626112754.911">def attachLeoIcon (self,w):
    pass

def createRootWindow(self):
    pass

def destroySelf (self):
    pass

def finishCreate (self):
    pass

def getTextFromClipboard (self):
    return self.clipboardContents

def get_focus(self,frame):
    return self.focusWidget or frame.body.bodyCtrl

def get_window_info (self,window):
    return 0,0,0,0

def replaceClipboardWith (self,s):
    self.clipboardContents = s

def set_focus(self,commander,widget):
    self.focusWidget = widget</t>
<t tx="ekr.20070626112754.912">def createComparePanel(self,c):
    """Create Compare panel."""
    self.oops()

def createFindPanel(self,c):
    """Create a hidden Find panel."""
    self.oops()

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    return leoFind.nullFindTab(c,parentFrame)

def createLeoFrame(self,title):
    """Create a null Leo Frame."""
    gui = self
    self.lastFrame = leoFrame.nullFrame(title,gui)
    return self.lastFrame
</t>
<t tx="ekr.20070626112754.913">def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
</t>
<t tx="ekr.20070626112754.914">def simulateDialog (self,key,defaultVal=None):

    val = self.dict.get(key,defaultVal)

    if self.trace:
        print key, val

    return val
</t>
<t tx="ekr.20070626112754.915">class nullLog (leoLog):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.916"></t>
<t tx="ekr.20070626112754.917">def __init__ (self,frame=None,parentFrame=None):

    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)

    self.isNull = True
    self.logCtrl = self.createControl(parentFrame)
</t>
<t tx="ekr.20070626112754.918">def createControl (self,parentFrame):

    return self.createTextWidget(parentFrame)
</t>
<t tx="ekr.20070626112754.919">def createTextWidget (self,parentFrame=None):

    self.logNumber += 1

    c = self.c

    gui = c and c.frame and c.frame.gui or g.app.gui

    log = gui.plainTextWidget( ### was g.app.gui.
        c = self.c,
        name="log-%d" % self.logNumber,
    )

    return log
</t>
<t tx="ekr.20070626112754.920">def oops(self):

    g.trace("nullLog:", g.callers())
</t>
<t tx="ekr.20070626112754.921">def clearTab        (self,tabName):     pass
def createTab (self,tabName,createText=True,wrap='none'): pass
def deleteTab       (self,tabName,force=False):     pass
def getSelectedTab          (self):     pass
def lowerTab        (self,tabName):     pass
def raiseTab        (self,tabName):     pass
def renameTab (self,oldName,newName):   pass
def selectTab (self,tabName,createText=True,wrap='none'): pass
def setTabBindings  (self,tabName):     pass
</t>
<t tx="ekr.20070626112754.922">class nullStatusLineClass:

    '''A do-nothing status line.'''

    @others</t>
<t tx="ekr.20070626112754.923">def __init__ (self,c,parentFrame):

    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame

    gui = c and c.frame and c.frame.gui or g.app.gui

    self.textWidget = w = gui.plainTextWidget(c,name='status-line')

    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText  = self.textWidget
</t>
<t tx="ekr.20070626112754.924">def disable (self,background=None):
    self.enabled = False
    self.c.bodyWantsFocus()

def enable (self,background="white"):
    if w: self.c.widgetWantsFocus(self.textWidget)
    self.enabled = True

def clear (self):                   self.textWidget.delete(0,'end')
def get (self):                     return self.textWidget.getAllText()
def isEnabled(self):                return self.enabled
def getFrame (self):                return None
def onActivate (self,event=None):   pass 
def pack (self):                    pass
def put(self,s,color=None):         self.textWidget.insert('end',s)
def unpack (self):                  pass
def update (self):                  pass

hide = unpack
show = pack
</t>
<t tx="ekr.20070626112754.925">class nullTree (leoTree):

    __pychecker__ = '--no-argsused' # null classes have many unused args.

    @others
</t>
<t tx="ekr.20070626112754.926">def __init__ (self,frame):

    leoTree.__init__(self,frame) # Init the base class.

    assert(self.frame)

    self.editWidgetsDict = {} # Keys are tnodes, values are stringTextWidgets.
    self.font = None
    self.fontName = None
    self.canvas = None
    self.stayInTree = True
    self.trace_edit = False
    self.trace_select = False
    self.updateCount = 0
</t>
<t tx="ekr.20070626112754.927">def printWidgets(self):

    d = self.editWidgetsDict
    keys = d.keys()
    for key in keys:
        # keys are tnodes, values are stringTextWidgets.
        w = d.get(key)
        print 'w',w,'t.headString:',key.headString,'s:',repr(w.s)

</t>
<t tx="ekr.20070626112754.928"></t>
<t tx="ekr.20070626112754.929">def getFont(self):
    return self.font

# def setColorFromConfig (self):
    # pass

def setBindings (self):
    pass

def setFont(self,font=None,fontName=None):
    self.font,self.fontName = font,fontName

def setFontFromConfig (self):
    pass
</t>
<t tx="ekr.20070626112754.930">def beginUpdate (self):
    self.updateCount += 1

def endUpdate (self,flag,scroll=False):
    self.updateCount -= 1
    if flag and self.updateCount &lt;= 0:
        self.redraw_now()

def drawIcon(self,v,x=None,y=None):
    pass

def redraw_now(self,scroll=True):
    self.redrawCount += 1
    # g.trace('nullTree')

def scrollTo(self,p):
    pass
</t>
<t tx="ekr.20070626112754.931">def edit_widget (self,p):
    d = self.editWidgetsDict ; w = d.get(p.v.t)
    if not w:
        d[p.v.t] = w = stringTextWidget(
            c=self.c,
            name='head-%d' % (1 + len(d.keys())))
        w.setAllText(p.headString())
    # g.trace('w',w,'p',p.headString())
    return w

def headWidth(self,p=None,s=''):
    return len(s)

def setEditLabelState(self,v,selectAll=False):
    pass

def setSelectedLabelState(self,*args,**keys):
    pass

def setUnselectedLabelState(self,*args,**keys):
    pass
</t>
<t tx="ekr.20070626112754.932">def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p

    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

    if p and c.edit_widget(p):
        # g.trace('selectAll',selectAll,g.callers())
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
</t>
<t tx="ekr.20070626112754.933">def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    # g.trace('p',p.headString(),'s',repr(s),g.callers())

    w = self.edit_widget(p)
    if w:
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-'*20,'oops')
</t>
<t tx="ekr.20070626112754.934">class stringTextWidget (baseTextWidget):

    '''A class that represents text as a Python string.'''

    @others
</t>
<t tx="ekr.20070626112754.935">def __init__ (self,c,name):

    # Init the base class
    baseTextWidget.__init__ (self,c=c,
        baseClassName='stringTextWidget',name=name,widget=None)

    self.ins = 0
    self.sel = 0,0
    self.s = ''
    self.trace = False
</t>
<t tx="ekr.20070626112754.936">def _appendText(self,s):
    #if self.trace: g.trace(self,'len(s)',len(s))
    if self.trace: g.trace(self,'ins',self.ins,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = self.s + s
    self.ins = len(self.s)
    self.sel = self.ins,self.ins
def _get(self,i,j):                 return self.s[i:j]
def _getAllText(self):              return self.s
def _getFocus(self):                return self
def _getInsertPoint(self):
    # if self.trace: g.trace(self,self.ins)
    return self.ins
def _getLastPosition(self):         return len(self.s)
def _getSelectedText(self):         i,j = self.sel ; return self.s[i:j]
def _getSelectionRange(self):       return self.sel
def _getYScrollPosition(self):      return None # A flag.
def _hitTest(self,pos):             pass
def _insertText(self,i,s):
    s1 = s
    self.s = self.s[:i] + s1 + self.s[i:]
    # if self.trace: g.trace(self,'s',repr(s),'self.s',repr(self.s))
    # if self.trace: g.trace(self,'i',i,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'i',i,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    i += len(s1)
    self.ins = i
    self.sel = i,i
def _scrollLines(self,n):           pass
def _see(self,i):                   pass
def _setAllText(self,s):
    if self.trace: g.trace(self,'len(s)',len(s),g.callers())
    if self.trace: g.trace(self,'s',repr(s[-10:]),g.callers())
    # g.trace(repr(s),g.callers())
    self.s = s
    i = len(self.s)
    self.ins = i
    self.sel = i,i
def _setBackgroundColor(self,color): pass
def _setFocus(self):                pass
def _setInsertPoint(self,i):
    if self.trace: g.trace(self,'i',i)
    self.ins = i
    self.sel = i,i</t>
<t tx="ekr.20070626112754.937">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    self.sel = i,j

    if insert is not None: 
        self.ins = w.toPythonIndex(insert)
    else:
        self.ins = j

    if self.trace: g.trace('i',i,'j',j,'insert',repr(insert))</t>
<t tx="ekr.20070626112754.938">class unitTestGui(nullGui):

    '''A gui class for use by unit tests.'''

    # Presently used only by the import/export unit tests.

    @others
</t>
<t tx="ekr.20070626112754.939">def __init__ (self,dict={},trace=False):

    self.oldGui = g.app.gui

    # Init the base class
    nullGui.__init__ (self,"unitTestGui")

    # Use the same kind of widgets as the old gui.
    self.bodyTextWidget = self.oldGui.bodyTextWidget
    self.plainTextWidget = self.oldGui.plainTextWidget

    self.dict = dict
    self.trace = trace
    g.app.gui = self

def destroySelf (self):

    g.app.gui = self.oldGui
</t>
<t tx="ekr.20070626112754.940"></t>
<t tx="ekr.20070626112754.941">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4169720
By: ktenney

from https://sourceforge.net/forum/message.php?msg_id=4167714

&gt;So now the answer is clear: Leo searches for leoPluginsManager 
&gt;first in the g.app.homeDir directory, and second, in the leo/plugins
directory.

I work from several machines, keep my files synced via 
a svn server at home.

I would really like to use a single pluginsManager.txt
and sync it with the files.

Here's a +1 on Leo looking in the directory of the Leo
file being opened.

This would make pluginsManager.txt behave like leoSettings.leo
</t>
<t tx="ekr.20070626112754.942"></t>
<t tx="ekr.20070626112754.943">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict(self):         return g.app.config.getAbbrevDict(self.c)
def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getOpenWith  (self):         return g.app.config.getOpenWith (self.c)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting,):return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
</t>
<t tx="ekr.20070626112754.944"></t>
<t tx="ekr.20070626112754.945">def canonicalizeSettingName (self,name):

    if name is None:
        return None

    name = name.lower()
    for ch in ('-','_',' ','\n'):
        name = name.replace(ch,'')

    return g.choose(name,name,None)

munge = canonicalizeSettingName
</t>
<t tx="ekr.20070626112754.946">def findSettingsPosition (self,c,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = self.munge

    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()

    return c.nullPosition()
</t>
<t tx="ekr.20070626112754.947">def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val

    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val

    return None
</t>
<t tx="ekr.20070626112754.948">def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            s = (
                'Warning: ignoring %s:%s not %s\n' +
                'There may be conflicting settings!')
            g.es_print(s % (bunch.kind,setting,requestedType),color='red')
            # g.trace(g.callers())
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
</t>
<t tx="ekr.20070626112754.949">def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
</t>
<t tx="ekr.20070626112754.950">def exists (self,c,setting,kind):

    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True

    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False
</t>
<t tx="ekr.20070626112754.951">def getAbbrevDict (self,c):

    """Search all dictionaries for the setting &amp; check it's type"""

    d = self.get(c,'abbrev','abbrev')
    return d or {}
</t>
<t tx="ekr.20070626112754.952">def getBool (self,c,setting,default=None):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"bool")

    if val in (True,False):
        return val
    else:
        return default
</t>
<t tx="ekr.20070626112754.953">def getColor (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    return self.get(c,setting,"color")
</t>
<t tx="ekr.20070626112754.954">def getDirectory (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    theDir = self.getString(c,setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
         return theDir
    else:
        return None
</t>
<t tx="ekr.20070626112754.955">def getEnabledPlugins (self):

    """Search all dictionaries for the setting &amp; check it's type"""

    return g.app.config.enabledPluginsString
</t>
<t tx="ekr.20070626112754.956">def getFloat (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20070626112754.957">def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize

    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"

    # g.trace(g.callers(3),family,size,slant,weight,g.shortFileName(c.mFileName))

    return g.app.gui.getFontFromParams(family,size,slant,weight)
</t>
<t tx="ekr.20070626112754.958">def getInt (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20070626112754.959">def getLanguage (self,c,setting):

    """Return the setting whose value should be a language known to Leo."""

    language = self.getString(c,setting)
    # g.trace(setting,language)

    return language
</t>
<t tx="ekr.20070626112754.960">def getOpenWith (self,c):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,'openwithtable','openwithtable')

    return val
</t>
<t tx="ekr.20070626112754.961">def getRatio (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    val = self.get(c,setting,"ratio")
    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None
</t>
<t tx="ekr.20070626112754.962">def getRecentFiles (self):

    return self.recentFiles
</t>
<t tx="ekr.20070626112754.963">def getShortcut (self,c,shortcutName):

    '''Return rawKey,accel for shortcutName'''

    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.

    bunchList = self.get(c,key,"shortcut")
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
</t>
<t tx="ekr.20070626112754.964">def getString (self,c,setting):

    """Search all dictionaries for the setting &amp; check it's type"""

    return self.get(c,setting,"string")
</t>
<t tx="ekr.20070626112754.965"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

    data = (
        ("default_tangle_directory","tangle_directory","directory"),
        ("default_target_language","target_language","language"),
        ("output_doc_chunks","output_doc_flag","bool"),
        ("page_width","page_width","int"),
        ("run_tangle_done.py","tangle_batch_flag","bool"),
        ("run_untangle_done.py","untangle_batch_flag","bool"),
        ("tab_width","tab_width","int"),
        ("tangle_outputs_header","use_header_flag","bool"),
    )

    for setting,ivar,theType in data:
        val = g.app.config.get(c,setting,theType)
        if val is None:
            if not hasattr(c,setting):
                setattr(c,setting,None)
                # g.trace(setting,None)
        else:
            setattr(c,setting,val)
            # g.trace(setting,val)
</t>
<t tx="ekr.20070626112754.966">def settingsRoot (self,c):

    # g.trace(c,c.rootPosition())

    for p in c.allNodes_iter():
        if p.headString().rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
</t>
<t tx="ekr.20070626112754.967"></t>
<t tx="ekr.20070626112754.968">def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
</t>
<t tx="ekr.20070626112754.969">def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.970">def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.971">def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
</t>
<t tx="ekr.20070626112754.972">def doEnabledPlugins (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '&lt;no settings file&gt;'
</t>
<t tx="ekr.20070626112754.973">def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.974">def doFont (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind not used.

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
</t>
<t tx="ekr.20070626112754.975">def doIf(self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
</t>
<t tx="ekr.20070626112754.976">@ Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        __pychecker__ = '--no-argsused' # args not used.

        # g.trace(repr(name))

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
</t>
<t tx="ekr.20070626112754.977">def doIfPlatform (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
</t>
<t tx="ekr.20070626112754.978">def doIgnore(self,p,kind,name,val):

    return "skip"
</t>
<t tx="ekr.20070626112754.979">def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.980">def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.981">def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''

    __pychecker__ = '--no-argsused' # val not used.

    c = self.c ; k = c.k

    # g.trace('%20s' % (name),c.fileName())
    &lt;&lt; Compute modeName &gt;&gt;

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,d)
</t>
<t tx="ekr.20070626112754.982">name = name.strip().lower()
j = name.find(' ')
if j &gt; -1: name = name[:j]
if name.endswith('mode'):
    name = name[:-4].strip()
if name.endswith('-'):
    name = name[:-1]
modeName = name + '-mode'
</t>
<t tx="ekr.20070626112754.983">def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
</t>
<t tx="ekr.20070626112754.984">def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
</t>
<t tx="ekr.20070626112754.985">def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.986">def doShortcuts(self,p,kind,name,val,s=None):

    __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                # A regular shortcut.
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)
</t>
<t tx="ekr.20070626112754.987">def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.988">def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 &lt; i &lt; j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
</t>
<t tx="ekr.20070626112754.989">def loadOnePlugin (moduleOrFileName, verbose=False):

    global loadedModules,loadingModuleNameStack

    verbose = verbose or g.app.config.getBool(c=None,setting='trace_plugins')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            g.es_print(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        if hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                if init_result:
                    loadedModules[moduleName] = result
                else:
                    if verbose and not g.app.initing: ## or not g.app.unitTesting:
                        g.es_print('loadOnePlugin: loading module %s failed' % (moduleName),color="red")
                    result = None
            except Exception:
                g.es('Exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.
            g.trace('no init()',moduleName)
            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if result is None:
        if verbose and not g.app.initing: # or not g.app.unitTesting:
            s = 'can not load enabled %s plugin' % moduleName
            g.es_print(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        g.es_print(s,color="blue")

    return result</t>
<t tx="ekr.20070626112754.990">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame</t>
<t tx="ekr.20070626112754.991">def doPlugins(tag,keywords):

    if g.app.killed:
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
</t>
<t tx="ekr.20070626112754.992"># To do: use baseTextWidget class.  There seem to be problems :-)</t>
<t tx="ekr.20070626112754.993"># To be removed outside of tk-specific files.
'cget'  # removed
'clipboard_append' # uses gui, so ok.
'clipboard_clear' # uses gui, so ok.
'config' # removed
'configure' # removed
'focus_force' # removed
'focus_set' # removed

# Ok: defined in leoTkTextWidget, plainTextWidget, etc.
'_name'
'delete'
'deleteTextSelection'
'flashCharacter'
'get'
'getAllText'
'getInsertPoint'
'getName'
'getSelectedText'
'getSelectionRange'
'getYScrollPosition'
# 'getWidth' # optional.
'hasSelection'
'insert'
'replace'
'rowColToGuiIndex'
'see'
'seeInsertPoint'
'selectAllText'
'setAllText'
'setBackgroundColor'
'setInsertPoint'
'setSelectionRange'
'setYScrollPosition'
'tag_add'
'tag_bind'
'tag_config'
'tag_delete'
'tag_names'
'tag_ranges'
'toGuiIndex'
'toPythonIndex'
'xyToPythonIndex'

# Ok: in leoTkinterTree.
'leo_active'
'leo_frame'
'leo_insertSpot'
'leo_label'
'leo_label_s'
'leo_name'
'leo_p'
'leo_position'
'leo_scrollBarSpot'
'leo_selection'
'leo_v'
'leo_window_id'

# Ok only if in tk-specific files.
'bind'
'bind_all'
'bind_class'
'bindtags'
'button'
'columnconfigure'
'compare'
'dlineinfo'
'event_generate'
'grid'
'image_create'
'index'
'mark_set'
'pack'
'pack_forget'
'rowconfigure'
'search'
'selection_clear'
'selection_get'
'update'
'update_idletasks'
'winfo_id'
'winfo_toplevel'
'wm_iconbitmap'
'yview'</t>
<t tx="ekr.20070626112754.994">import string
import leoTkinterFrame
words = {}
word_chars = string.ascii_letters + string.digits + '_'
p = g.findTopLevelNode(c,'Code')
p1 = p.copy()
baseClass = leoTkinterFrame.leoTkTextWidget
allMatches = True
seen = {}
for p in p.self_and_subtree_iter():
    if seen.get(p.v.t): continue # search clones once.
    seen[p.v.t] = True
    s = p.bodyString()
    i = 0
    while 1:
        j = s.find('w.',i)
        if j == -1: break
        ch = s[j-1]
        if j == 0 or ch not in word_chars:
            j += 2
            k = g.skip_c_id(s,j)
            word = s[j:k]
            if allMatches or not hasattr(baseClass,word):
                words[word] = 1 + words.get(word,0)
            i = k
        else:
            i += 2
keys = words.keys()
keys.sort()
aList = ['%3d %s' % (words.get(key),str(key)) for key in keys]
print g.listToString(aList)
g.es('searched %s' % p1.headString())</t>
<t tx="ekr.20070626112754.995">if g.app.gui.guiName() != 'tkinter':
    return g.es('command not ready yet',color='blue')

# To be removed.
'  6 index' # later.  Disabled commands that use unless gui is tkinter.
'  1 flashCharacter'  # Calls wrapper function.
'  3 search' # later. Disabled commands that use this unless gui is tkinter.
'  7 tag_add' # Used by Yank.  
'  8 tag_config'
' 10 tag_delete'
'  5 tag_ranges'

# Can't be removed.
'  1 update_idletasks' # In an emergency global function. (also top.geometry)

# Ok.
'  1 bind'
' 73 delete'
'  2 deleteTextSelection'
'  1 event_generate' # ok.
' 21 get'
'123 getAllText'
' 96 getInsertPoint'
' 21 getSelectedText'
' 63 getSelectionRange'
'  1 getYScrollPosition'
' 12 hasSelection'
'  2 indexIsVisible'
' 77 insert'
'  1 rowColToGuiIndex'
'  4 see'
' 14 seeInsertPoint'
'  3 selectAllText'
' 16 setAllText'
'  2 setBackgroundColor'
' 54 setInsertPoint'
' 76 setSelectionRange'
'  4 setWidth'
'  1 setYScrollPosition'
'  7 toGuiIndex'
'  4 toPythonIndex'
'  3 xyToPythonIndex'
</t>
<t tx="ekr.20070626112754.996">@nocolor

- Moved makeScriptButton to the gui class.
  This is optional: it is not needed by the wxGui plugin.

- Removed calls to w.focus_force from move-line-up/down commands.

- Removed w.configure &amp; w.cget from Leo's core.
  This affected pasteText, cutText commands and c.setHeadString.
  ** The only remaining calls are in classes that are to be refactored into gui-dependent/independent parts.

@color</t>
<t tx="ekr.20070626112754.997"></t>
<t tx="ekr.20070626112754.998"></t>
<t tx="ekr.20070626112754.999">def copyText (self,event=None):

    '''Copy the selected text from the widget to the clipboard.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)

OnCopyFromMenu = copyText
</t>
<t tx="ekr.20070626112754.1000">def cutText (self,event=None):

    '''Invoked from the mini-buffer and from shortcuts.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()

    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        width = f.tree.headWidth(p=None,s=s)
        w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20070626112754.1001">def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    # g.trace('isText',g.app.gui.isTextWidget(w),w)
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()

    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)

    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()

    singleLine = wname.startswith('head') or wname.startswith('minibuffer')

    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)

        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                width = f.tree.headWidth(p=None,s=s)
                w.setWidth(width)
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.

    return 'break' # Essential

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20070626112754.1002">def OnPaste (self,event=None):

    return self.pasteText(event=event,middleButton=True)</t>
<t tx="ekr.20070626112754.1003"></t>
<t tx="ekr.20070626112754.1004">@

- Oh joy, tk headlines are plain text widgets!
- We can declare the colorizer to be gui-specific because it isn't used in other guis.</t>
<t tx="ekr.20070626112754.1005">def setHeadString (self,p,s,encoding="utf-8"):

    c = self
    w = c.edit_widget(p) # w only exists for the Tk gui.

    p.initHeadString(s,encoding)

    if w:
        w.setAllText(s)
        width = c.frame.tree.headWidth(p=None,s=s)
        w.setWidth(width)

    p.setDirty()</t>
<t tx="ekr.20070626112754.1006"># The minibufferFind class now calls the finder's get/set/toggle methods.</t>
<t tx="ekr.20070626112754.1007"></t>
<t tx="ekr.20070626112754.1008">def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
</t>
<t tx="ekr.20070626112754.1009">def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.1010">def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
</t>
<t tx="ekr.20070626112754.1011"></t>
<t tx="ekr.20070626112754.1012">def showColors (self,event):

    '''Open a tab in the log pane showing various color pickers.'''

    c = self.c ; log = c.frame.log ; tabName = 'Colors'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createColorPicker(tabName)
</t>
<t tx="ekr.20070626112754.1013"></t>
<t tx="ekr.20070626112754.1014">def showFonts (self,event):

    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createFontPicker(tabName)
</t>
<t tx="ekr.20070626112754.1015"># The spellTabHandler class is now separate from the tkSpellTab class.
# Added g.app.gui.createSpellTab.</t>
<t tx="ekr.20070626112754.1016">def createSpellTab(self,c,spellHandler,tabName):

    return leoTkinterFind.tkSpellTab(c,spellHandler,tabName)
</t>
<t tx="ekr.20070626112754.1017">class spellTabHandler (leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""

    @others
</t>
<t tx="ekr.20070626112754.1018"></t>
<t tx="ekr.20070626112754.1019">def __init__(self,c,tabName):

    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.

    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
</t>
<t tx="ekr.20070626112754.1020">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))

    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)

    if self.aspell.aspell:
        self.dictionary = self.readDictionary(dictionaryFileName)
    else:
        self.dictionary = False
        # g.es_print('Can not open Aspell',color='red')

    return self.aspell.aspell
</t>
<t tx="ekr.20070626112754.1021">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary

    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""

    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
</t>
<t tx="ekr.20070626112754.1022"></t>
<t tx="ekr.20070626112754.1023">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""

    if not self.currentWord: return

    # g.trace(self.currentWord)

    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20070626112754.1024">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; w = body.bodyCtrl

    selection = self.tab.getSuggestion()
    if selection:
        start,end = oldSel = w.getSelectionRange()
        if start:
            if start &gt; end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20070626112754.1025">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = self.workCtrl.getSelectionRange()
        w.setSelectionRange(start,end)
        w.see(start)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.1026">def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None

    try:
        while 1:
            # g.trace('p',p and p.headString())
            p, word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20070626112754.1027">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20070626112754.1028">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
    return None,None</t>
<t tx="ekr.20070626112754.1029">def hide (self,event=None):

    self.c.frame.log.selectTab('Log')

    for message in self.messages:
        g.es(message,color='blue')

    self.messages = []
</t>
<t tx="ekr.20070626112754.1030">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""

    if not self.currentWord: return

    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.tab.onFindButton()
</t>
<t tx="ekr.20070626112754.1031">class tkSpellTab:

    @others
</t>
<t tx="ekr.20070626112754.1032">def __init__ (self,c,handler,tabName):

    self.c = c
    self.handler = handler
    self.tabName = tabName

    self.createFrame()
    self.createBindings()
    self.fillbox([])
</t>
<t tx="ekr.20070626112754.1033">def createBindings (self):

    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.handler.hide),
            ('spell-add',               self.handler.add),
            ('spell-find',              self.handler.find),
            ('spell-ignore',            self.handler.ignore),
            ('spell-change-then-find',  self.handler.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)

    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20070626112754.1034">def createFrame (self):

    c = self.c ; log = c.frame.log ; tabName = self.tabName

    parentFrame = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'

    fontSize = g.choose(sys.platform.startswith('win'),9,14)

    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;

    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
</t>
<t tx="ekr.20070626112754.1035">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
</t>
<t tx="ekr.20070626112754.1036">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',fontSize,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',fontSize,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
</t>
<t tx="ekr.20070626112754.1037"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = []
font = ('verdana',fontSize,'normal')
width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
</t>
<t tx="ekr.20070626112754.1038"></t>
<t tx="ekr.20070626112754.1039">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.handler.add()
</t>
<t tx="ekr.20070626112754.1040">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.handler.change()
    self.updateButtons()


def onChangeThenFindButton(self,event=None):

    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.handler.change():
        self.handler.find()
    self.updateButtons()
</t>
<t tx="ekr.20070626112754.1041">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070626112754.1042">def onHideButton(self):

    """Handle a click in the Hide button in the Spell tab."""

    self.handler.hide()
</t>
<t tx="ekr.20070626112754.1043">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.handler.ignore()
</t>
<t tx="ekr.20070626112754.1044">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""

    self.update(show= False, fill= False)
</t>
<t tx="ekr.20070626112754.1045">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""

    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1046"></t>
<t tx="ekr.20070626112754.1047">def bringToFront (self):

    self.c.frame.log.selectTab('Spell')
</t>
<t tx="ekr.20070626112754.1048">def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""

    self.suggestions = alts

    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])

    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
</t>
<t tx="ekr.20070626112754.1049">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""

    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
</t>
<t tx="ekr.20070626112754.1050">def update(self,show=True,fill=False):

    """Update the Spell Check dialog."""

    c = self.c

    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1051">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
</t>
<t tx="ekr.20070626112754.1052"></t>
<t tx="ekr.20070626112754.1053"></t>
<t tx="ekr.20070626112754.1054">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
</t>
<t tx="ekr.20070626112754.1055">def getTextFromClipboard (self):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
</t>
<t tx="ekr.20070626112754.1056"></t>
<t tx="ekr.20070626112754.1057">def readAbbreviations (self,event):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        for x in f:
            a, b = x.split('=')
            b = b [:-1]
            self.abbrevs [a] = b
        f.close()
    except IOError:
        g.es('Can not open',fileName)
</t>
<t tx="ekr.20070626112754.1058">def writeAbbreviations (self,event):

    '''Write abbreviations to a file.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'w')
        for x in self.abbrevs:
            f.write('%s=%s\n' % (x,self.abbrevs[x]))
        f.close()
    except IOError:
        g.es('Can not create',fileName)
</t>
<t tx="ekr.20070626112754.1059">def getReadableTextFile (self):

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return None, None

    try:
        f = open(fileName,'rt')
        return f, fileName
    except IOError:
        g.es('Can not open',fileName)
        return None,None
</t>
<t tx="ekr.20070626112754.1060">def loadFile (self,event):

    '''Asks for a macro file name to load.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Macro File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName)
        self._loadMacros(f)
    except IOError:
        g.es('Can not open',fileName)
</t>
<t tx="ekr.20070626112754.1061">def _loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    k = self.k
    macros = cPickle.load(f)
    for z in macros:
        k.addToDoAltX(z,macros[z])
</t>
<t tx="ekr.20070626112754.1062">def saveFile (self,event):

    '''Prompt for the name of a file and put the body text of the selected node into it..'''

    w = self.editWidget(event)
    if not w: return

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='save-file',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        s = w.getAllText()
        f = open(fileName,'w')
        f.write(s)
        f.close()
    except IOError:
        g.es('Can not create',fileName)
</t>
<t tx="ekr.20070626112754.1063">def saveMacros (self,event,macname):

    '''Asks for a file name and saves it.'''

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Save Macros',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = file(fileName,'a+')
        f.seek(0)
        if f:
            self._saveMacros(f,macname)
    except IOError:
        g.es('Can not create',fileName)

</t>
<t tx="ekr.20070626112754.1064">def _saveMacros( self, f , name ):
    '''Saves the macros as a pickled dictionary'''
    import cPickle
    fname = f.name
    try:
        macs = cPickle.load( f )
    except:
        macs = {}
    f.close()
    if self.namedMacros.has_key( name ):
        macs[ name ] = self.namedMacros[ name ]
        f = file( fname, 'w' )
        cPickle.dump( macs, f )
        f.close()
</t>
<t tx="ekr.20070626112754.1065"></t>
<t tx="ekr.20070626112754.1066">def _executeMacro (self,macro,w):

    c = self.c ; k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('&lt;Key&gt;',keycode=z[0],keysym=z[1])
        else:
            meth = g.stripBrackets(z[0])
            bunchList = k.bindingsDict.get(meth,[]) ### Probably should not strip &lt; and &gt;
            if bunchList:
                b = bunchList [0]
                # ev = Tk.Event()
                # ev.widget = w
                # ev.keycode = z [1]
                # ev.keysym = z [2]
                # ev.char = z [3]
                event = g.Bunch(c=c,widget=w,keycode=z[1],keysym=z[2],char=z[3])
                k.masterCommand(event,b.f,'&lt;%s&gt;' % meth)
</t>
<t tx="ekr.20070626112754.1067">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info

    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass

    else: version = sys.platform

    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
    g.enl()
</t>
<t tx="ekr.20070626112754.1068">def getFullVersion (self,c):

    tkLevel = c.frame.top.getvar("tk_patchLevel")

    return 'Tk %s, Pmw %s' % (tkLevel,Pmw.version())
</t>
<t tx="ekr.20070626112754.1069"># This must be defined in leoGlobals: g.app.gui doesn't exist yet.

def createStandAloneTkApp(pluginName=''):

    '''Create a Tk version of the g.app object for 'stand-alone' plugins.'''

    if not g.app:
        # Important: these references do not make Leo's core gui-dependent.
        # In other words, this function is called only when Tkinter should be the gui.
        import Tkinter as Tk
        Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
        if Tk and Pmw:
            import leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            Pmw.initialise(g.app.root)
            g.app.gui = leoGui.nullGui('&lt;stand-alone app gui&gt;')
            g.computeStandardDirectories()
    return g.app
</t>
<t tx="ekr.20070626112754.1070">def cantImportDialog (pluginName,moduleName):

    '''Attempt to show a Tk dialog if an import fails.
    Yes, this is a small Tk dependency, but it can't be helped.'''

    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if 1: # Requires minimal further imports.
        try:
            import Tkinter as Tk
            root = g.app.root or Tk.Tk()
            title = 'Can not import %s' % moduleName
            top = createDialogFrame(Tk,root,title,message)
            root.wait_window(top)
        except ImportError:
            print 'Can not import %s' % moduleName
            print 'Can not import Tkinter'
            print 'Leo must now exit'

    else: # Can cause import problems during startup.
        import leoTkinterDialog

        d = leoTkinterDialog.tkinterAskOk(
            c=None,title='Can not import %s' %(moduleName),
            message=message)
        d.run(modal=True)
</t>
<t tx="ekr.20070626112754.1071">def createDialogFrame(Tk,root,title,message):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("&lt;Key&gt;",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")

    label = Tk.Label(f,text=message)
    label.pack(pady=10)

    def okButton(top=top):
        top.destroy()

    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)

    center(top)
    top.lift()
    top.focus_force()

    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)

    return top
</t>
<t tx="ekr.20070626112754.1072">def createDialogButtons (Tk,top,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
</t>
<t tx="ekr.20070626112754.1073">def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = g.get_window_info(top)

    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))

    return w,h,x,y
</t>
<t tx="ekr.20070626112754.1074"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):

    # This is an emergency measure: this call is NOT a major Tk-dependency.
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)

    return w,h,x,y
</t>
<t tx="ekr.20070626112754.1075">class leoTkTextWidget (Tk.Text):

    '''A class to wrap the Tk.Text widget.
    Translates Python (integer) indices to and from Tk (string) indices.

    This class inherits almost all tkText methods: you call use them as usual.'''

    # The signatures of tag_add and insert are different from the Tk.Text signatures.
    __pychecker__ = '--no-override' # suppress warning about changed signature.

    def __repr__(self):
        name = hasattr(self,'_name') and self._name or '&lt;no name&gt;'
        return 'leoTkTextWidget id: %s name: %s' % (id(self),name)

    @others</t>
<t tx="ekr.20070626112754.1076">if 0:
    def __init__ (self,c,*args,**keys):

        w = self

        # Create the actual gui widget.
        self.widget = Tk.Text(*args,**keys)

        # Init the base class.
        name = keys.get('name') or '&lt;unknown plainTextWidget&gt;'
        baseTextWidget.__init__(self,c=c,
            baseClassName='plainTextWidget',name=name,widget=self.widget)

        # self.defaultFont = font = wx.Font(pointSize=10,
            # family = wx.FONTFAMILY_TELETYPE, # wx.FONTFAMILY_ROMAN,
            # style  = wx.FONTSTYLE_NORMAL,
            # weight = wx.FONTWEIGHT_NORMAL,)
</t>
<t tx="ekr.20070626112754.1077"># Specify the names of widget-specific methods.
# These particular names are the names of wx.TextCtrl methods.

# def _appendText(self,s):            return self.widget.insert(s)
# def _get(self,i,j):                 return self.widget.get(i,j)
# def _getAllText(self):              return self.widget.get('1.0','end')
# def _getFocus(self):                return self.widget.focus_get()
# def _getInsertPoint(self):          return self.widget.index('insert')
# def _getLastPosition(self):         return self.widget.index('end')
# def _getSelectedText(self):         return self.widget.get('sel.start','sel.end')
# def _getSelectionRange(self):       return self.widget.index('sel.start'),self.widget.index('sel.end')
# def _hitTest(self,pos):             pass ###
# def _insertText(self,i,s):          return self.widget.insert(i,s)
# def _scrollLines(self,n):           pass ###
# def _see(self,i):                   return self.widget.see(i)
# def _setAllText(self,s):            self.widget.delete('1.0','end') ; self.widget.insert('1.0',s)
# def _setBackgroundColor(self,color): return self.widget.configure(background=color)
# def _setFocus(self):                return self.widget.focus_set()
# def _setInsertPoint(self,i):        return self.widget.mark_set('insert',i)
# # def _setSelectionRange(self,i,j):   return self.widget.SetSelection(i,j)
</t>
<t tx="ekr.20070626112754.1078">def getName (self):

    w = self
    return hasattr(w,'_name') and w._name or repr(w)</t>
<t tx="ekr.20070626112754.1079">if 0:
    def _setSelectionRange (self,i,j,insert=None):

        w = self.widget

        i,j = w.toGuiIndex(i),w.toGuiIndex(j)

        # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())

        # g.trace('i,j,insert',i,j,repr(insert))
        if w.compare(w,i, "&gt;", j): i,j = j,i
        w.tag_remove(w,"sel","1.0",i)
        w.tag_add(w,"sel",i,j)
        w.tag_remove(w,"sel",j,"end")

        if insert is not None:
            w.setInsertPoint(insert)
</t>
<t tx="ekr.20070626112754.1080"></t>
<t tx="ekr.20070626112754.1081">def delete(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.delete(w,i)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.delete(w,i,j)
</t>
<t tx="ekr.20070626112754.1082">def get(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        return Tk.Text.get(w,i)
    else:
        j = w.toGuiIndex(j)
        return Tk.Text.get(w,i,j)
</t>
<t tx="ekr.20070626112754.1083">def getAllText (self): # tkTextWidget.

    """Return all the text of Tk.Text widget w converted to unicode."""

    w = self
    s = Tk.Text.get(w,"1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.1084">def getInsertPoint(self): # tkTextWidget.

    w = self
    i = Tk.Text.index(w,'insert')
    i = w.toPythonIndex(i)
    return i
</t>
<t tx="ekr.20070626112754.1085">def getSelectedText (self): # tkTextWidget.

    w = self
    i,j = w.getSelectionRange()
    if i != j:
        i,j = w.toGuiIndex(i),w.toGuiIndex(j)
        s = Tk.Text.get(w,i,j)
        return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
</t>
<t tx="ekr.20070626112754.1086">def getSelectionRange (self,sort=True): # tkTextWidget.

    """Return a tuple representing the selected range.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        i,j = sel
    else:
        i = j = Tk.Text.index(w,"insert")

    i,j = w.toPythonIndex(i),w.toPythonIndex(j)  
    if sort and i &gt; j: i,j = j,i
    return i,j</t>
<t tx="ekr.20070626112754.1087">def getYScrollPosition (self):

     w = self
     return w.yview()
</t>
<t tx="ekr.20070626112754.1088">def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return w.cget('width')
</t>
<t tx="ekr.20070626112754.1089">def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20070626112754.1090"># The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.insert(w,i,s)

</t>
<t tx="ekr.20070626112754.1091">def indexIsVisible (self,i):

    w = self

    return w.dlineinfo(i)</t>
<t tx="ekr.20070626112754.1092"># def mark_set(self,markName,i):

    # w = self
    # i = w.toGuiIndex(i)
    # Tk.Text.mark_set(w,markName,i)
</t>
<t tx="ekr.20070626112754.1093">def replace (self,i,j,s): # tkTextWidget

    w = self
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    Tk.Text.delete(w,i,j)
    Tk.Text.insert(w,i,s)
</t>
<t tx="ekr.20070626112754.1094">def see (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.see(w,i)
</t>
<t tx="ekr.20070626112754.1095">def seeInsertPoint (self): # tkTextWidget.

    w = self
    Tk.Text.see(w,'insert')
</t>
<t tx="ekr.20070626112754.1096">def setAllText (self,s): # tkTextWidget

    w = self

    state = Tk.Text.cget(w,"state")
    Tk.Text.configure(w,state="normal")

    Tk.Text.delete(w,'1.0','end')
    Tk.Text.insert(w,'1.0',s)

    Tk.Text.configure(w,state=state)
</t>
<t tx="ekr.20070626112754.1097">def setBackgroundColor (self,color):

    w = self
    w.configure(background=color)</t>
<t tx="ekr.20070626112754.1098">def setYScrollPosition (self,i):

     w = self
     w.yview('moveto',i)</t>
<t tx="ekr.20070626112754.1099">def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    w.configure(width=width)
</t>
<t tx="ekr.20070626112754.1100">def tag_ranges(self,tagName):

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
</t>
<t tx="ekr.20070626112754.1101">def tag_remove (self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_remove(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_remove(w,tagName,i,j,*args)


</t>
<t tx="ekr.20070626112754.1102">def deleteTextSelection (self): # tkTextWidget

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        start,end = sel
        if Tk.Text.compare(w,start,"!=",end):
            Tk.Text.delete(w,start,end)
</t>
<t tx="ekr.20070626112754.1103">def xyToGuiIndex (self,x,y): # tkTextWidget

    w = self
    return Tk.Text.index(w,"@%d,%d" % (x,y))

def xyToPythonIndex(self,x,y): # tkTextWidget

    w = self
    i = Tk.Text.index(w,"@%d,%d" % (x,y))
    i = w.toPythonIndex(i)
    return i
</t>
<t tx="ekr.20070626112754.1104"></t>
<t tx="ekr.20070626112754.1105"># Indices of the form %s.%s are benign because of w.rowColToGuiIndex.
</t>
<t tx="ekr.20070626112754.1106">def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i &gt; 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1107">def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))

    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j &lt; len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1108">def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''
    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region')

    s = w.getAllText()
    s1,s2 = w.getSelectionRange()
    w.setInsertPoint(s1)
    self.backwardParagraph(event)
    i = w.getInsertPoint()
    i,junk = g.getLine(s,i)
    if i == 0:
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.getInsertPoint() &gt; s2:
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1109">def fillRegionAsParagraph (self,event):

    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region-as-paragraph')

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1110">def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend ;
        self.insert = w.getInsertPoint()
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' &amp; extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        c.frame.clearStatusLine()
        k.clearState()</t>
<t tx="ekr.20070626112754.1111">def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
</t>
<t tx="ekr.20070626112754.1112">def lineNumber (self,event):

    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    percent = int((i*100)/len(s))

    k.setLabelGrey(
        'char: %s row: %d col: %d pos: %d (%d%% of %d)' % (
            repr(s[i]),row,col,i,percent,len(s)))
</t>
<t tx="ekr.20070626112754.1113">def measure (self,w):

    s = w.getAllText()
    ins = w.getInsertPoint()
    start, junk = g.convertPythonIndexToRowCol(s,ins)
    start += 1 ; delta = 0

    ustart = start - 1
    while ustart &gt;= 1 and w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart -= 1

    ustart = start + 1
    while w.indexIsVisible('%s.0' % ustart):
        delta += 1 ; ustart += 1

    return delta
</t>
<t tx="ekr.20070626112754.1114">def setCommentColumn (self,event):

    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,ins)
    self.ccolumn = col</t>
<t tx="ekr.20070626112754.1115">def shellCommandOnRegion (self,event):

    '''Execute a command taken from the selected text in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if subprocess:
        if w.hasSelection():
            command = w.getSelectedText()
            k.commandName = 'shell-command: %s' % command
            self.executeSubprocess(event,command,input=None)
        else:
            k.clearState()
            k.resetLabel()
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
</t>
<t tx="ekr.20070626112754.1116">def sortFields (self,event,which=None):

    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')

    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = s[i:j] # bug reported by pychecker.
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    #w.delete('%s linestart' % is1,'%s lineend' % is2)
    w.delete(i,j)
    #i = is1.split('.')
    #int1 = int(i[0])
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1117">def swapWords (self,event,swapspots):

    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('swap-words command not ready yet',color='blue')

    s = w.getAllText()

    txt = w.get('insert wordstart','insert wordend') ###
    if not txt: return

    i = w.index('insert wordstart') ###

    self.beginCommand(undoType='swap-words')

    if len(swapspots):
        if i &gt; swapspots[1]:
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif i &lt; swapspots[1]:
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1118">def whatLine (self,event):

    '''Print the line number of the line containing the cursor.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)

    k.keyboardQuit(event)
    k.setLabel("Line %s" % row)
</t>
<t tx="ekr.20070626112754.1119"></t>
<t tx="ekr.20070626112754.1120"></t>
<t tx="ekr.20070626112754.1121">class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
</t>
<t tx="ekr.20070626112754.1122">def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.object = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
</t>
<t tx="ekr.20070626112754.1123">def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('&lt;class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
</t>
<t tx="ekr.20070626112754.1124">def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
</t>
<t tx="ekr.20070626112754.1125"></t>
<t tx="ekr.20070626112754.1126">def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
</t>
<t tx="ekr.20070626112754.1127">def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
</t>
<t tx="ekr.20070626112754.1128">def autoCompleterStateHandler (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20070626112754.1129">def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20070626112754.1130">def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.object = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
</t>
<t tx="ekr.20070626112754.1131">def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
</t>
<t tx="ekr.20070626112754.1132">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')</t>
<t tx="ekr.20070626112754.1133"></t>
<t tx="ekr.20070626112754.1134">def abort (self):

    k = self.k
    k.keyboardQuit(event=None)
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.object = None
</t>
<t tx="ekr.20070626112754.1135">def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20070626112754.1136">def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
</t>
<t tx="ekr.20070626112754.1137">def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        &lt;&lt; try to set s from a Python global function &gt;&gt;

    if not s:
        &lt;&lt; get s using inspect &gt;&gt;

    &lt;&lt; remove 'self' from s, but not from args &gt;&gt;
    if isStringMethod:
        &lt;&lt; remove 's' from s *and* args &gt;&gt;

    s = s.rstrip(')') # Convenient.
    &lt;&lt; insert the text and set j1 and j2 &gt;&gt;

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    &lt;&lt; put the status line &gt;&gt;
</t>
<t tx="ekr.20070626112754.1138"># The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i &gt; -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
</t>
<t tx="ekr.20070626112754.1139">isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
</t>
<t tx="ekr.20070626112754.1140">if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
</t>
<t tx="ekr.20070626112754.1141">if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
</t>
<t tx="ekr.20070626112754.1142">junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
</t>
<t tx="ekr.20070626112754.1143">c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
</t>
<t tx="ekr.20070626112754.1144">def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.object

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.object = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.object = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.object)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
</t>
<t tx="ekr.20070626112754.1145">def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) &lt; 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList

    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        g.es('%s' % (name),tabName=self.tabName)
</t>
<t tx="ekr.20070626112754.1146">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    # g.trace(self.prefix,self.object,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.object:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.object
        # g.trace(self.object,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 &lt;= i-1 &lt; len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.object = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            </t>
<t tx="ekr.20070626112754.1147">def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20070626112754.1148">def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')</t>
<t tx="ekr.20070626112754.1149">def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    while i &gt; 0 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word</t>
<t tx="ekr.20070626112754.1150">def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i &gt; 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''</t>
<t tx="ekr.20070626112754.1151">def finish (self):

    c = self.c ; k = self.k

    k.keyboardQuit(event=None)

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.object = None
</t>
<t tx="ekr.20070626112754.1152"># The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
</t>
<t tx="ekr.20070626112754.1153">def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.object,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.object:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 &lt;= i &lt; start and i &lt;len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.object:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
</t>
<t tx="ekr.20070626112754.1154">def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
</t>
<t tx="ekr.20070626112754.1155">def info (self):

    c = self.c ; doc = None ; obj = self.object ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word): return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es(doc,tabName='Info')
</t>
<t tx="ekr.20070626112754.1156">def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20070626112754.1157">def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
</t>
<t tx="ekr.20070626112754.1158">def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.object = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.object)
        self.object = 'aString'
        self.membersList = self.getMembersList(self.object)
    elif self.object:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.object,len(self.membersList))
</t>
<t tx="ekr.20070626112754.1159">def getObjectFromAttribute (self,word):

    obj = self.object

    if obj and self.hasAttr(obj,word):
        self.push(self.object)
        self.object = self.getAttr(obj,word)
        self.appendToKnownObjects(self.object)
        self.membersList = self.getMembersList(self.object)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.object = None
</t>
<t tx="ekr.20070626112754.1160">def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.object = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20070626112754.1161">def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.object = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20070626112754.1162">def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20070626112754.1163">def start (self,event=None,w=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i &gt; 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        self.autoCompleterStateHandler(event)
    else:
        self.abort()
</t>
<t tx="ekr.20070626112754.1164"># Not used at present, but soon.
</t>
<t tx="ekr.20070626112754.1165"># Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
</t>
<t tx="ekr.20070626112754.1166">def scan (self,event=None,verbose=True,thread=True):

    __pychecker__ = '--no-argsused' # thread arg not used at present.

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
</t>
<t tx="ekr.20070626112754.1167">def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars </t>
<t tx="ekr.20070626112754.1168">def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('Scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        keys = self.watchwords.keys() ; keys.sort()
        for key in keys:
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        keys = self.calltips.keys() ; keys.sort()
        for key in keys:
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
</t>
<t tx="ekr.20070626112754.1169">def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
</t>
<t tx="ekr.20070626112754.1170">def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i &lt; n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
</t>
<t tx="ekr.20070626112754.1171">def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i &gt;= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
</t>
<t tx="ekr.20070626112754.1172">def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i &gt;= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
</t>
<t tx="ekr.20070626112754.1173">def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
</t>
<t tx="ekr.20070626112754.1174"></t>
<t tx="ekr.20070626112754.1175">def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in xrange(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
</t>
<t tx="ekr.20070626112754.1176">def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec s

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in computeProxyObject')
            g.es_exception()
        return None
</t>
<t tx="ekr.20070626112754.1177">class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
</t>
<t tx="ekr.20070626112754.1178">def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
</t>
<t tx="ekr.20070626112754.1179">def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Bug fix: 4/29/07: Don't put a return in a finally clause.


</t>
<t tx="ekr.20070626112754.1180">def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('Syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('Syntax error: deleting %s' % p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
</t>
<t tx="ekr.20070626112754.1181">def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n &gt;= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
</t>
<t tx="ekr.20070626112754.1182">def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
</t>
<t tx="ekr.20070626112754.1183">class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
</t>
<t tx="ekr.20070626112754.1184">def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
</t>
<t tx="ekr.20070626112754.1185">def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
</t>
<t tx="ekr.20070626112754.1186">def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p

    return None,None,None
</t>
<t tx="ekr.20070626112754.1187">def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
</t>
<t tx="ekr.20070626112754.1188">def endsDoc (self,s):

    return s.startswith('@c')
</t>
<t tx="ekr.20070626112754.1189">def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
</t>
<t tx="ekr.20070626112754.1190">def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
</t>
<t tx="ekr.20070626112754.1191">def dynamicExpansion (self,event=None):

    '''Expand the word in the buffer before point as a dynamic abbrev,
    by searching in the buffer for words starting with that abbreviation (dabbrev-expand).
    This corresponds to M-/ in Emacs.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() not in ('null','tkinter'):
        return g.es('command not ready yet',color='blue')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if not rlist: return
    prefix = reduce(g.longestCommonPrefix,rlist)
    if prefix and prefix != txt:
        w.delete(i,j)
        w.insert(i,prefix)
    else:
        self.dynamicExpandHelper(prefix,rlist,w)
</t>
<t tx="ekr.20070626112754.1192">def dynamicExpandHelper (self,prefix=None,rlist=None,w=None):

    k = self.k ; tag = 'dabbrev-expand'
    state = k.getState(tag)

    if state == 0:
        self.w = w
        names = rlist ; event = None
        prefix2 = 'dabbrev-expand: '
        k.setLabelBlue(prefix2+prefix,protect=True)
        k.getArg(event,tag,1,self.dynamicExpandHelper,prefix=prefix2,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ins = w.getInsertPoint()
            i,j = g.getWord(s,ins)
            w.delete(i,j)
            w.insert(i,k.arg)

</t>
<t tx="ekr.20070626112754.1193">def dynamicCompletion (self,event=None):

    '''Insert the common prefix of all dynamic abbrev's matching the present word.
    This corresponds to C-M-/ in Emacs.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    txt = w.get(i,j)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    if rlist:
        prefix = reduce(g.longestCommonPrefix,rlist)
        if prefix:
            w.delete(i,j)
            w.insert(i,prefix)
</t>
<t tx="ekr.20070626112754.1194">def executeSubprocess (self,event,command,input):

    '''Execute a command in a separate process.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    k.setLabelBlue('started  shell-command: %s' % command)
    try:
        ofile = os.tmpfile()
        efile = os.tmpfile()
        process = subprocess.Popen(command,bufsize=-1,
            stdout = ofile.fileno(), stderr = ofile.fileno(),
            stdin = subprocess.PIPE, shell = True)
        if input: process.communicate(input)
        process.wait()
        efile.seek(0)
        errinfo = efile.read()
        if errinfo: w.insert('insert',errinfo)
        ofile.seek(0)
        okout = ofile.read()
        if okout: w.insert('insert',okout)
    except Exception, x:
        w.insert('insert',x)

    k.setLabelGrey('finished shell-command: %s' % command)
</t>
<t tx="ekr.20070626112754.1195">def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')

    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1196">def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Insert to buffer: ')
    self.getBufferName(self.insertToBufferFinisher)

def insertToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('insert-to-buffer: %s' % p.headString())
            i = w.getInsertPoint()
            w.insert(i,s)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20070626112754.1197">def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Prepend to buffer: ')
    self.getBufferName(self.prependToBufferFinisher)

def prependToBufferFinisher (self,event,name):

    c = self.c ; k = self.k ; w = self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
            self.beginCommand('prepend-to-buffer: %s' % p.headString())
            w.insert(0,s)
            w.setInsertPoint(0)
            w.seeInsertPoint()
            self.endCommand()
        finally:
            c.endUpdate()
            c.recolor_now()

</t>
<t tx="ekr.20070626112754.1198">def doOneReplace (self,event):

    w = self.editWidget(event)
    if not w: return

    i = w.tag_ranges('qR')
    w.delete(i[0],i[1])
    w.insert('insert',self.qR)
    self.replaced += 1
</t>
<t tx="ekr.20070626112754.1199">def findNextMatch (self,event):

    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if g.app.gui.guiName() != 'tkinter':
        return g.es('command not ready yet',color='blue')

    w.tag_delete('qR')
    if self.regexp:
        &lt;&lt; handle regexp &gt;&gt;
    else:
        &lt;&lt; handle plain search &gt;&gt;
</t>
<t tx="ekr.20070626112754.1200">try:
    regex = re.compile(self.qQ)
except:
    self.quitSearch(event,'Illegal regular expression')
    return False

txt = w.get('insert','end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    i = w.getInsertPoint()
    w.setInsertPoint(i+start)
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    txt = w.get('insert','insert +%sc' % length)
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20070626112754.1201">i = w.search(self.qQ,'insert',stopindex='end')

if i:
    w.setInsertPoint(i)
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False
</t>
<t tx="ekr.20070626112754.1202">def regionalExpandAbbrev (self,event):

    '''Exapand abbreviations throughout a region.'''

    k = self.k ; w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    i1,i2 = w.getSelectionRange()
    ins = w.getInsertPoint()
    &lt;&lt; define a new generator searchXR &gt;&gt;

    # EKR: the 'result' of calling searchXR is a generator object.
    k.regx.iter = searchXR(i1,i2,ins,event)
    k.regx.iter.next() # Call it the first time.</t>
<t tx="ekr.20070626112754.1203">@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.setInsertPoint(ins,ins,insert=ins)
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
</t>
<t tx="ekr.20070626112754.1204">'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
</t>
<t tx="ekr.20070626112754.1205">def sortLines (self,event,which=None):

    '''Sort lines of the selected text by comparing the entire text of a line.
    A prefix argument means sort in descending order.'''

    c = self.c ; k = c.k
    w = self.editWidget(event)
    if not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        aList = g.splitLines(s[i:j])
        aList.sort()
        if which: aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1206">def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        ins = w.getInsertPoint()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in xrange(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = zip(columns,aList)
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1207"></t>
<t tx="ekr.20070626112754.1208">@
At present the only colorizer is only used in by the Tk gui.
There will be no need to deal with this unless a new gui plugin uses the old colorizer.</t>
<t tx="ekr.20070626112754.1209">def setFontFromConfig (self):

    c = self.c

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bold_font:
        self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    self.image_references = []
</t>
<t tx="ekr.20070626112754.1210">def removeAllImages (self):

    for photo,image,line_index,i in self.image_references:
        try:
            ### self.body.deleteCharacter(image)
            s = self.allBodyText
            w = self.body.bodyCtrl
            index = g.convertRowColToPythonIndex(s,line_index,i)
            w.delete(index)
            self.allBodyText = w.getAllText()
        except:
            pass # The image may have been deleted earlier.

    self.image_references = []
</t>
<t tx="ekr.20070626112754.1211"></t>
<t tx="ekr.20070626112754.1212">def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('c',self.c)

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
</t>
<t tx="ekr.20070626112754.1213">if type(data) == type(''):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&amp;','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data</t>
<t tx="ekr.20070626112754.1214"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
</t>
<t tx="ekr.20070626112754.1215">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
</t>
<t tx="ekr.20070626112754.1216">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
</t>
<t tx="ekr.20070626112754.1217"></t>
<t tx="ekr.20070626112754.1218">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    # pychecker complains about initAllEditCommanders.

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20070626112754.1219">def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''   
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0</t>
<t tx="ekr.20070626112754.1220">def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to Tkinter.'''

    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)

    if stroke and w:
        # g.trace(stroke)
        g.app.gui.event_generate(w,stroke)
    else:
        g.trace('no shortcut for %s' % (commandName),color='red')
</t>
<t tx="ekr.20070626112754.1221"></t>
<t tx="ekr.20070626112754.1222">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c ; gui = g.app.gui
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = not g.app.unitTesting and (False or k.trace_masterClickHandler)

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1

    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x,y = gui.eventXY(event)
        x = w.xyToPythonIndex(x,y)
        i,j = k.getEditableTextRange()
        if i &lt;= x &lt;= j:
            w.setSelectionRange(x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'
    if event and func:
        if trace: g.trace(func.__name__)
        val = func(event) # Don't even *think* of overriding this.
        c.masterFocusHandler()
        if trace: g.trace('val:',val,g.callers())
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20070626112754.1223">def masterDoubleClickHandler (self,event,func=None):

    k = self ; c = k.c ; w = event and event.widget

    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        gui = g.app.gui
        x,y = gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        s = w.getAllText()
        start,end = g.getWord(s,i)
        w.setSelectionRange(start,end)
        return 'break'
</t>
<t tx="ekr.20070626112754.1224">def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c ; w = c.frame.getFocus()

    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
</t>
<t tx="ekr.20070626112754.1225">def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
</t>
<t tx="ekr.20070626112754.1226">def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = not g.app.unitTesting and (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(True)

    self.setEditPosition(p) # That is, self._editPosition = p

    if trace: g.trace(c.edit_widget(p))

    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
</t>
<t tx="ekr.20070626112754.1227"></t>
<t tx="ekr.20070626112754.1228"></t>
<t tx="ekr.20070626112754.1229">@ 

- It is True by default. In effect, this setting was False in previous versions
of Leo, which might be considered a bug.

- Fixed docs.</t>
<t tx="ekr.20070626112754.1230"># oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    if self.write_strips_blank_lines:
        s = self.cleanLines(p,s)
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind4(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
</t>
<t tx="ekr.20070626112754.1231">@

If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if (at.sentinels or at.force_newlines_in_at_nosent_bodies) and not trailingNewlineFlag:
        # g.trace('Added newline',repr(s))
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
</t>
<t tx="ekr.20070626112754.1232">if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
</t>
<t tx="ekr.20070626112754.1233">def putCodeLine (self,s,i):

    """Put a normal code line."""

    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.trace('atRaw',at.raw,'line',repr(line),g.callers(4))

    if self.write_strips_blank_lines:
        # Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)

            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)

        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
</t>
<t tx="ekr.20070626112754.1234"></t>
<t tx="ekr.20070626112754.1235"></t>
<t tx="ekr.20070626112754.1236">def printPlugins ():

    g.es_print('Enabled plugins...')
    keys = loadedModules.keys()
    keys = [s.lower() for s in keys]
    keys.sort()
    for key in keys:
        g.es_print(key)
</t>
<t tx="ekr.20070626112754.1237"></t>
<t tx="ekr.20070626112754.1238">def printSettings (self,c):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following letters indicate where the active setting came from:

    - D indicates default settings.
    - F indicates the file being loaded,
    - L indicates leoSettings.leo,
    - M indicates myLeoSettings.leo,
    '''

    settings = {} # Keys are setting names, values are (letter,val)

    if c:
        d = self.localOptionsDict.get(c.hash())
        self.printSettingsHelper(settings,d,letter='[F]')

    for d in self.localOptionsList:
        self.printSettingsHelper(settings,d)

    for d in self.dictList:
        self.printSettingsHelper(settings,d)

    keys = settings.keys() ; keys.sort()
    for key in keys:
        data = settings.get(key)
        letter,val = data
        print '%45s = %s %s' % (key,letter,val)
        g.es('%s %s = %s' % (letter,key,val))</t>
<t tx="ekr.20070626112754.1239">def printSettingsHelper(self,settings,d,letter=None):

    suppressKind = ('shortcut','shortcuts','openwithtable')
    suppressKeys = (None,'_hash','shortcut')

    if d:
        &lt;&lt; set letter &gt;&gt;
        for key in d.keys():
            if key not in suppressKeys and key not in settings.keys():
                bunch = d.get(key)
                if bunch.kind not in suppressKind:
                    settings[key] = (letter,bunch.val)</t>
<t tx="ekr.20070626112754.1240">theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

# g.trace(letter,theHash)</t>
<t tx="ekr.20070626112754.1241">
</t>
<t tx="ekr.20070626112754.1242">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3737745

http://sourceforge.net/forum/message.php?msg_id=3785897

Would it be possible to have the table of "Open With" editors to be part of
the config system? I find myself patching the list every time I D/L a new Leo
version to add the editor I use. This would also help isolate the user from
the "guts" of Leo, theereby being less intimidating.
</t>
<t tx="ekr.20070626112754.1243"></t>
<t tx="ekr.20070626112754.1244">def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    __pychecker__ = '--no-argsused' # p used in subclasses, not here.

    c = self.c ; key = self.munge(name)
    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')

</t>
<t tx="ekr.20070626112754.1245">def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
</t>
<t tx="ekr.20070626112754.1246">def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
</t>
<t tx="ekr.20070626112754.1247">def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20070626112754.1248">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
</t>
<t tx="ekr.20070626112754.1249">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
</t>
<t tx="ekr.20070626112754.1250">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20070626112754.1251">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
</t>
<t tx="ekr.20070626112754.1252">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
</t>
<t tx="ekr.20070626112754.1253">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
</t>
<t tx="ekr.20070626112754.1254">def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
</t>
<t tx="ekr.20070626112754.1255">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
</t>
<t tx="ekr.20070626112754.1256">def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
</t>
<t tx="ekr.20070626112754.1257">def createOpenWithMenuFromTable (self,table):

    '''Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.'''

    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &amp;With...")
    amp_index = label.find("&amp;")
    label = label.replace("&amp;","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
</t>
<t tx="ekr.20070626112754.1258">def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;
        # g.trace(label,accelerator)
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        callback = self.defineOpenWithMenuCallback(openWithData)

        self.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
</t>
<t tx="ekr.20070626112754.1259">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)

if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
</t>
<t tx="ekr.20070626112754.1260">def bindOpenWith (self,shortcut,name,data):

    '''Register an open-with command.'''

    k = self ; c = k.c

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
</t>
<t tx="ekr.20070626112754.1261"></t>
<t tx="ekr.20070626112754.1262">def cleanAllLines (self,event):

    '''Clean all lines in the selected tree.'''

    c = self.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl
    if not w: return

    c.beginUpdate()
    try:
        for p in current.self_and_subtree_iter():
            c.selectPosition(p)
            w.setSelectionRange(0,0,insert=0)
            c.editCommands.cleanLines(event)
        c.selectPosition(current)
    finally:
        c.endUpdate(False)
</t>
<t tx="ekr.20070626112754.1263">def cleanLines (self,event):

    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = changed or '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1264"></t>
<t tx="ekr.20070626112754.1265">@nocolor

Leo now supports zipped .leo files:

- Leo now has save-file-as-zipped and save-file-as-unzipped commands, and
corresponding Save File As Zipped and Save File as Unzipped items in the File
menu. These are exactly the same as Leo's Save As commands except that they
temporarily force Leo to write the file in either zipped or unzipped format.

- Leo remembers whether a file was originally zipped. The read logic handles
either zipped or unzipped .leo files automatically. The write logic will zip the
file if it was originally zipped or if the save-file-as-zipped command is being
executed.

- Leo writes files with .leo extension, regardless of whether the file is zipped
or not. Zipped .leo files contain a single archive, whose name is the same as
the .leo file itself.

These seem like the simplest conventions:

- The new save commands suffice to compress and expand .leo files on a
file-by-file basis. In particular, there is no need for any user settings.

- Outside of Leo you can change the extension to .leo.zip and use stuffit or
other program to expand the .leo file contained within. I've only tested this on
XP, but it should work everywhere...

At present the code uses Python's zipfile module to read and write zipped files.
In turn, the zipfile module uses the zlib module to do the compression.
Conceivably somebody might want Leo to use some other compression technique, say
Python's tarfile module. However, I think the present way should suffice for
most people.</t>
<t tx="ekr.20070626112754.1266">@nocolor

By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57

Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
</t>
<t tx="ekr.20070626112754.1267">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().

The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?</t>
<t tx="ekr.20070626112754.1268">def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    if not self.use_sax:
        &lt;&lt; read the entire file into the buffer &gt;&gt;
        theFile.close()
        self.fileIndex = 0
    &lt;&lt; Set the default directory &gt;&gt;
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    if not self.use_sax: # Delete the file buffer
        self.fileBuffer = ""
    return ok</t>
<t tx="ekr.20070626112754.1269">isZipped = zipfile.is_zipfile(fileName)

if isZipped:
    aList = theFile.infolist()
    contentsName = aList[0].filename
    self.fileBuffer = theFile.read(contentsName)
else:
    self.fileBuffer = theFile.read()
</t>
<t tx="ekr.20070626112754.1270">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) &gt; 0:
    c.openDirectory = theDir
</t>
<t tx="ekr.20070626112754.1271">def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            theFile = file(fileName,'rb')
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName),color="blue")
        return None,False</t>
<t tx="ekr.20070626112754.1272"></t>
<t tx="ekr.20070626112754.1273">def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
</t>
<t tx="ekr.20070626112754.1274">def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()</t>
<t tx="ekr.20070626112754.1275">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20070626112754.1276">def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
</t>
<t tx="ekr.20070626112754.1277">def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)</t>
<t tx="ekr.20070626112754.1278">def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
</t>
<t tx="ekr.20070626112754.1279">def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
</t>
<t tx="ekr.20070626112754.1280">def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
</t>
<t tx="ekr.20070626112754.1281">def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20070626112754.1282"></t>
<t tx="ekr.20070626112754.1283">def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)
    # redraw_flag = g.app.gui.guiName() == 'tkinter'
    if ok is None:
        c.beginUpdate()
        try:
            c.endEditing()# Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
            if ok:
                c.setChanged(False) # Clears all dirty bits.
                self.putSavedMessage(fileName)
                if c.config.save_clears_undo_buffer:
                    g.es("clearing undo")
                    c.undoer.clearUndoState()
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
</t>
<t tx="ekr.20070626112754.1284">def saveAs(self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.beginUpdate()
        try:
            c.endEditing() # Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            if self.write_Leo_file(fileName,False): # outlineOnlyFlag
                c.setChanged(False) # Clears all dirty bits.
                self.putSavedMessage(fileName)
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
</t>
<t tx="ekr.20070626112754.1285">def saveTo (self,fileName):

    c = self.c ; v = c.currentVnode()

    if not g.doHook("save1",c=c,p=v,v=v,fileName=fileName):
        c.beginUpdate()
        try:
            c.endEditing()# Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            self.write_Leo_file(fileName,False) # outlineOnlyFlag
            self.putSavedMessage(fileName)
        finally:
            c.endUpdate() # We must redraw in order to clear dirty node icons.
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
</t>
<t tx="ekr.20070626112754.1286">def putSavedMessage (self,fileName):

    c = self.c

    zipMark = g.choose(c.isZipped,'[zipped] ','')

    g.es("saved: %s%s" % (zipMark,g.shortFileName(fileName)))</t>
<t tx="ekr.20070626112754.1287">def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    self.putCount = 0
    self.toString = toString
    self.assignFileIndices()
    theActualFile = None
    toZip = False
    if not outlineOnlyFlag or toOPML:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        if toOPML:
            &lt;&lt; ensure that filename ends with .opml &gt;&gt;
        self.outputFile = cStringIO.StringIO()
        &lt;&lt; create theActualFile &gt;&gt;
        # t1 = time.clock()
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        # t2 = time.clock()
        s = self.outputFile.getvalue()
        # g.trace(self.leo_file_encoding)
        if toZip:
            self.writeZipFile(s)
        elif toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            &lt;&lt; delete backup file &gt;&gt;
            # t3 = time.clock()
            # g.es_print('len %d, putCount %d' % (len(s),self.putCount)) # 'put',t2-t1,'write&amp;close',t3-t2)
        self.outputFile = None
        self.toString = False
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=True)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        if backupName:
            &lt;&lt; delete fileName &gt;&gt;
            &lt;&lt; rename backupName to fileName &gt;&gt;
        self.toString = False
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20070626112754.1288">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
</t>
<t tx="ekr.20070626112754.1289"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
</t>
<t tx="ekr.20070626112754.1290">backupName = None

# rename fileName to fileName.bak if fileName exists.
if not toString and g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(c,fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False</t>
<t tx="ekr.20070626112754.1291">if not self.mFileName.endswith('opml'):
    self.mFileName = self.mFileName + '.opml'
fileName = self.mFileName</t>
<t tx="ekr.20070626112754.1292">if toString:
    theActualFile = None
elif c.isZipped:
    self.toString = toString = True
    theActualFile = None
    toZip = True
else:
    theActualFile = open(fileName, 'wb')
</t>
<t tx="ekr.20070626112754.1293">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
</t>
<t tx="ekr.20070626112754.1294">if fileName and g.os_path_exists(fileName):

    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20070626112754.1295">if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(c,backupName,fileName)
</t>
<t tx="ekr.20070626112754.1296">def writeZipFile (self,s):

    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding,reportErrors=True)

    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding,reportErrors=True)

    # Write the archive.
    theFile = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName,s)
    theFile.close()
</t>
<t tx="ekr.20070626112754.1297"></t>
<t tx="ekr.20070626112754.1298"># Found via unit test.  Happens regardless of chapters.</t>
<t tx="ekr.20070626112754.1299"># Returns in finally clauses prevent the re-raising of the saved exception(!!)</t>
<t tx="ekr.20070626112754.1300">https://sourceforge.net/forum/message.php?msg_id=4283692</t>
<t tx="ekr.20070626112754.1301"></t>
<t tx="ekr.20070626112754.1302">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))

    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]

    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)

    try:
        import ctypes
        import ctypes.util
        self.use_ctypes = True
    except ImportError:
        self.use_ctypes = False
    self.aspell = self.sc = None

    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
</t>
<t tx="ekr.20070626112754.1303">def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=None,verbose=True)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
</t>
<t tx="ekr.20070626112754.1304">def getAspellWithCtypes (self):

    import ctypes
    import ctypes.util
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    try:
        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        if not sys.platform.startswith('win'):
            g.es_exception()
        g.es('Can not load %s' % (path),color='blue')
        self.aspell = None
        self.check = None
        self.sc = None
        return

    &lt;&lt; define and configure aspell entry points &gt;&gt;

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
</t>
<t tx="ekr.20070626112754.1305"># new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]</t>
<t tx="ekr.20070626112754.1306"></t>
<t tx="ekr.20070626112754.1307">def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('No previous command',color='blue')
    return 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui

    keysym = gui.eventKeysym(event)
    # g.trace('state',k.state.kind,'event',repr(event),g.callers())
    if keysym == 'Return' and k.mb_history:
    # if k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return 'break'
    else:
        g.trace('oops')
        return k.keyboardQuit(event)
</t>
<t tx="ekr.20070626112754.1308">def keyboardQuit (self,event,hideTabs=True,setDefaultUnboundKeyAction=True):

    '''This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.'''

    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')

    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()

    if setDefaultUnboundKeyAction: k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20070626112754.1309">def setState (self,kind,n,handler=None):

    k = self
    if kind and n != None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()

    # k.showStateAndMode()
</t>
<t tx="ekr.20070626112754.1310">@

Possibilities:

- Destroy all tree widgets only when switching chapters.
- Create unique tree for each chapter.
- Remember canvas from which each widget was allocated.</t>
<t tx="ekr.20070626112754.1311">def createTab (self,tabName,select=True):

    tt = self

    if tabName not in tt.tabNames:
        tt.tabNames.append(tabName)
        tt.setNames()
</t>
<t tx="ekr.20070626112754.1312">def chapterSelectHelper (self,w=None,selectEditor=True):

    c = self.c ; cc = self.cc ; name = self.name

    # g.trace(name,'self.p',self.p) # ,'self.root',self.root) # 'w.leo_p',w and w.leo_p)

    cc.selectedChapter = self

    # Next, recompute p and possibly select a new editor.
    if w:
        assert w == c.frame.body.bodyCtrl
        assert w == c.frame.bodyCtrl
        assert w.leo_p
        # g.trace(name,'w.leo_p',w.leo_p,'p',p)
        self.p = p = self.findPositionInChapter(w.leo_p)
        if p != w.leo_p: g.trace('****** can not happen: lost p',w.leo_p)
    else:
        # This must be done *after* switching roots.
        target_p = self.p or self.root.firstChild() or self.root
        #g.trace(name,'target_p',target_p)
        #g.trace(name,'self.p',self.p,'self.root',self.root)
        self.p = p = self.findPositionInChapter(target_p)
        if selectEditor:
            w = self.findEditorInChapter(p)
            c.frame.body.selectEditor(w) # Switches text.

    c.beginUpdate()
    try:
        if name == 'main' and cc.chaptersNode:
            cc.chaptersNode.contract()    
        c.hoistStack = self.hoistStack[:]
        c.selectPosition(p)
    finally:
        c.endUpdate()
        g.doHook('hoist-changed',c=c)
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20070626112754.1313">def selectTab (self,tabName):

    tt = self

    if tabName not in self.tabNames:
        tt.createTab(tabName)

    tt.cc.selectChapterByName(tabName)
</t>
<t tx="ekr.20070626112754.1314">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # g.printGcAll()

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    if c.chapterController: # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.chapterController)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)

    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)

</t>
<t tx="ekr.20070626112754.1315"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
</t>
<t tx="ekr.20070626112754.1316"></t>
<t tx="ekr.20070626112754.1317">def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.

    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''

    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
</t>
<t tx="ekr.20070626112754.1318"># This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories)

    if c:
        if not c.config.create_nonexistent_directories:
            return None
    elif not app.config.create_nonexistent_directories:
        return None

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) &gt; 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es("created directory: "+path)
            except:
                g.es("exception creating directory: "+path)
                g.es_exception()
                return None
    return dir1 # All have been created.
</t>
<t tx="ekr.20070626112754.1319"></t>
<t tx="ekr.20070626112754.1320">&lt;&lt; about os.rename &gt;&gt;

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.

    Change the mode of the renamed file if mode is given.

    Return True if all went well.'''

    c = self.c
    head,tail=g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head,c=c)

    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
</t>
<t tx="ekr.20070626112754.1321">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
</t>
<t tx="ekr.20070626112754.1322">if g.unitTesting:

    __pychecker__ = '--no-reimport'

    import os
    c,p = g.getTestVars()
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')

    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)

    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)
</t>
<t tx="ekr.20070626112754.1323">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):

    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    &lt;&lt; Set ivars &gt;&gt;
    &lt;&lt; Set path from @file node &gt;&gt;
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set current directory &gt;&gt;
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        &lt;&lt; Set comment strings from delims &gt;&gt;
</t>
<t tx="ekr.20070626112754.1324">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
</t>
<t tx="ekr.20070626112754.1325"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) &gt; 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20070626112754.1326"># We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            &lt;&lt; handle absolute path &gt;&gt;
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20070626112754.1327">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
</t>
<t tx="ekr.20070626112754.1328"># path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20070626112754.1329">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20070626112754.1330"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
</t>
<t tx="ekr.20070626112754.1331"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
</t>
<t tx="ekr.20070626112754.1332">if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
</t>
<t tx="ekr.20070626112754.1333">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w &gt; 0:
        self.page_width = w
</t>
<t tx="ekr.20070626112754.1334">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20070626112754.1335"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
</t>
<t tx="ekr.20070626112754.1336">if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
</t>
<t tx="ekr.20070626112754.1337">def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    &lt;&lt; Set path from @file node &gt;&gt;
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            &lt;&lt; handle @path &gt;&gt;
            return

    &lt;&lt; Set current directory &gt;&gt;
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
</t>
<t tx="ekr.20070626112754.1338"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
</t>
<t tx="ekr.20070626112754.1339"># We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
&lt;&lt; compute relative path from s[k:] &gt;&gt;

if path and len(path) &gt; 0:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        &lt;&lt; handle absolute path &gt;&gt;
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
</t>
<t tx="ekr.20070626112754.1340">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
</t>
<t tx="ekr.20070626112754.1341"># path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
</t>
<t tx="ekr.20070626112754.1342"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
</t>
<t tx="ekr.20070626112754.1343">&lt;&lt; about os.rename &gt;&gt;

def utils_rename (c,src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''

    head, tail = g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head,c=c)

    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
    try:
        # New in Leo 4.4b1: try using shutil first.
        try:
            import shutil # shutil is new in Python 2.3
            shutil.move(src,dst)
        except ImportError:
            if sys.platform == "win32":
                os.rename(src,dst)
            else:
                try:
                    # Alas, distutils.file_util may not exist.
                    from distutils.file_util import move_file
                    move_file(src,dst)
                except ImportError:
                    # Desperation: may give: 'Invalid cross-device link'
                    os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True
    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False
</t>
<t tx="ekr.20070626112754.1344">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
</t>
<t tx="ekr.20070626112754.1345">if g.unitTesting:

    __pychecker__ = '--no-reimport'
    import os
    exists = g.os_path_exists

    c,p = g.getTestVars()

    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)

    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)

    f = file(path,'w')
    f.write('test')
    f.close()

    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
</t>
<t tx="ekr.20070626112754.1346">@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        &lt;&lt; Collect @first attributes &gt;&gt;
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for print modes directives &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @root &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @header and @noheader &gt;&gt;
        old.update(theDict)
    &lt;&lt; Set self.tangle_directory &gt;&gt;
</t>
<t tx="ekr.20070626112754.1347">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
</t>
<t tx="ekr.20070626112754.1348">if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
</t>
<t tx="ekr.20070626112754.1349">if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
</t>
<t tx="ekr.20070626112754.1350">if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
</t>
<t tx="ekr.20070626112754.1351">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
</t>
<t tx="ekr.20070626112754.1352">if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;
    if len(theDir) &gt; 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) &gt; 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                &lt;&lt; handle absolute @path &gt;&gt;
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
</t>
<t tx="ekr.20070626112754.1353">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
</t>
<t tx="ekr.20070626112754.1354">if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) &gt; 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) &gt; 0:
                g.es("relative path in @path directive: " + relative_path)
</t>
<t tx="ekr.20070626112754.1355">if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w &gt; 0:
        self.page_width = w
</t>
<t tx="ekr.20070626112754.1356">@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
</t>
<t tx="ekr.20070626112754.1357">if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
</t>
<t tx="ekr.20070626112754.1358">if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.

elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
</t>
<t tx="ekr.20070626112754.1359">@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) &gt; 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) &gt; 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                &lt;&lt; handle absolute path &gt;&gt;

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
</t>
<t tx="ekr.20070626112754.1360">if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir,c=c)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) &gt; 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) &gt; 0:
            g.es(kind + " directory: " + dir2)
</t>
<t tx="ekr.20070626112754.1361"></t>
<t tx="ekr.20070626112754.1362"># This is part of the tangle code.

def update_file_if_changed(c,file_name,temp_name):

    """Compares two files.

    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(c,temp_name,file_name,mode)
    else:
        kind = 'creating'
        ok = g.utils_rename(c,temp_name,file_name)

    if ok:
        g.es('%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es(file_name," may be read-only or in use")
</t>
<t tx="ekr.20070626112754.1363">@ An interesting change:

- Replaced frame.treeBar ivar by injected frame.canvas.leo_treeBar ivar.</t>
<t tx="ekr.20070626112754.1364">def createTkTreeCanvas (self,parentFrame,scrolls,pack):

    frame = self

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    treeBar = Tk.Scrollbar(parentFrame,name="treeBar")

    # New in Leo 4.4.3 b1: inject the ivar into the canvas.
    canvas.leo_treeBar = treeBar

    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;

    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")

    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 0:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;

    # g.print_bindings("canvas",canvas)
    return canvas
</t>
<t tx="ekr.20070626112754.1365"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)
</t>
<t tx="ekr.20070626112754.1366"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')

def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay

def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)
</t>
<t tx="ekr.20070626112754.1367">def setCallback (self,*args,**keys):

    """Callback to adjust the scrollbar.

    Args is a tuple of two floats describing the fraction of the visible area."""

    #g.trace(self.tree.redrawCount,args,g.callers())

    apply(self.canvas.leo_treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)

def yviewCallback (self,*args,**keys):

    """Tell the canvas to scroll"""

    #g.trace(vyiewCallback,args,keys,g.callers())

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20070626112754.1368">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4215654
By: rogererens

There's a bug with ordinary hoisting: in the "Outline" menu the "Delete Node"
menu item is not disabled when the local root is selected.

@color</t>
<t tx="ekr.20070626112754.1369">def canDeleteHeadline (self):

    c = self ; p = c.currentPosition()

    if c.hoistStack:
         bunch = c.hoistStack[0]
         if p == bunch.p: return False

    return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline
</t>
<t tx="ekr.20070626112754.1370">@nocolor

Added c argument to topLevelMenu function in leoupdate.py:

exception executing command
Traceback (most recent call last):
  File "C:\Programme\Leo\src\leoCommands.py", line 269, in doCommand
    val = command(event)
  File "C:\Programme\Leo\plugins\plugins_menu.py", line 120, in callback
    p.hastoplevel(c)
TypeError: topLevelMenu() takes no arguments (1 given)
</t>
<t tx="ekr.20070626112754.1371"></t>
<t tx="ekr.20070626112754.1372">def putVnodes (self):

    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("&lt;vnodes&gt;\n")

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.rootPosition    = c.rootPosition()
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("&lt;/vnodes&gt;\n")</t>
<t tx="ekr.20070626112754.1373">def putVnode (self,p,isIgnore=False):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    &lt;&lt; Set gnx = tnode index &gt;&gt;
    attrs = []
    &lt;&lt; Append attribute bits to attrs &gt;&gt;
    &lt;&lt; Append tnodeList and unKnownAttributes to attrs &gt;&gt;
    attrs = ''.join(attrs)
    v_head = '&lt;v t="%s"%s&gt;&lt;vh&gt;%s&lt;/vh&gt;' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('&lt;/v&gt;\n')
    else:
        fc.put('%s&lt;/v&gt;\n' % v_head) # Call put only once.</t>
<t tx="ekr.20070626112754.1374"># New in Leo 4.4.3
if not v.t.fileIndex:
    g.trace('*** missing t.fileIndex','v',repr(v))
    # c.dumpOutline() # Can be called inside pdb.
    if 1:
        # Print the @chapters tree
        c.chapterController.printChaptersTree()
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)
if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.

# old code.
# if v.t.fileIndex:
    # gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    # if forceWrite or self.usingClipboard:
        # v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
# else:
    # g.trace(v.t.fileIndex,v)
    # g.es("error writing file(bad v.t.fileIndex)!")
    # g.es("try using the Save To command")
</t>
<t tx="ekr.20070626112754.1375"># These string catenations are benign because they rarely happen.
attr = ""
if v.isExpanded(): attr += "E"
if v.isMarked():   attr += "M"
if v.isOrphan():   attr += "O"

# No longer a bottleneck now that we use p.equal rather than p.__cmp__
# Almost 30% of the entire writing time came from here!!!
if not self.use_sax:
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr:
    attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions &lt;v&gt; element.
if self.use_sax and p.equal(self.rootPosition):
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d</t>
<t tx="ekr.20070626112754.1376"># Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

# Debugging.
# if v.isAnyAtFileNode():
    # if hasattr(v.t,"tnodeList"):
        # g.trace(v.headString(),len(v.t.tnodeList))
    # else:
        # g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))</t>
<t tx="ekr.20070626112754.1377">if isOrphan and isThin:
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

# For testing.
# if p.isAtIgnoreNode():
     # for p2 in p.self_and_subtree_iter():
            # if p2.isAtThinFileNode():
                # g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
</t>
<t tx="ekr.20070626112754.1378">def putTnodeList (self,v):

    """Put the tnodeList attribute of a tnode."""

    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
    nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        for t in tnodeList:
            try: # Will fail for None or any pre 4.1 file index.
                theId,time,n = t.fileIndex
            except:
                g.trace("assigning gnx for ",v,t)
                gnx = nodeIndices.getNewIndex()
                v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
        s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        return ' tnodeList="%s"' % (s)
    else:
        return ''</t>
<t tx="ekr.20070626112754.1379">def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    if 1: # New in Leo 4.4.2 b2.
        # Put each tnode in the list only once.
        # This should have been done long ago.
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            t = p.v.t
            if p.isMarked() and p.v.t not in marks:
                marks.append(t)
            if p.hasChildren() and p.isExpanded() and t not in expanded:
                expanded.append(t)

        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for t in theList:
                    gnx = t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))
    else:
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            if p.isMarked() and not p in marks:
                marks.append(p.copy())
            if p.hasChildren() and p.isExpanded() and not p in expanded:
                expanded.append(p.copy())

        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for p in theList:
                    gnx = p.v.t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)</t>
<t tx="ekr.20070626112754.1380">def putDescendentUnknownAttributes (self,p):

    # pychecker complains about dumps.

    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    python23 = g.CheckVersion(version,'2.3')

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    tnodesData = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                # g.trace(p2.headString(),t)
                tnodes.append(t) # Bug fix: 10/4/06.
                tnodesData.append((p2,t),)

    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodesData:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.

            for key in d.keys():
                try:
                    # We don't actually save the pickled values here.
                    if python23:
                        pickle.dumps(d[key],protocol=1) # Requires Python 2.3
                    else:
                        pickle.dumps(d[key],bin=True) # Requires earlier versions of Python.
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
                except Exception:
                    del d[key]
                    g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
                    g.es_exception()
            data.append((t,d),)

    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d

    if 0:
        print "resultDict..."
        for key in resultDict:
            print repr(key),repr(resultDict.get(key))

    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            if python23:
                s = pickle.dumps(resultDict,protocol=1) # Requires Python 2.3
                # g.trace('protocol=1')
            else:
                s = pickle.dumps(resultDict,bin=True) # Requires Earlier version of Python.
                # g.trace('bin=True')
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            return field
        except pickle.PicklingError:
            g.trace("putDescendentUnknownAttributes can't happen 1",color="red")
        except Exception:
            g.es("putDescendentUnknownAttributes can't happen 2",color='red')
            g.es_exception()
    return ''
</t>
<t tx="ekr.20070626112754.1381">@nocolor

So I'm still getting no trash tab / context menu on startup, so to 
get them I have to use the new file menu.

The content loss on save I'm thinking may be related to a really 
obnoxious habit I have, I know I shouldn't do this, but I often 
click the window manager close box when I want to 'save and exit'. 
That should work, but it's not safe... leo's not the only app. that 
can give trouble when you do that.

Anyway, I don't lose content when I select the Save menu item 
explicitly, but I do when I just click the close box and answer 
'yes' to the 'do you want to save' question.

@color</t>
<t tx="ekr.20070626112754.1382">def closeLeoWindow (self,frame):

    """Attempt to close a Leo window.

    Return False if the user veto's the close."""

    c = frame.c

    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.

    g.doHook("close-frame",c=c) # This may remove frame from the window list.

    if frame in g.app.windowList:
        g.app.destroyWindow(frame)

    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        frame = g.app.windowList[0]
        frame.deiconify()
        frame.lift()
        frame.c.setLog()
        frame.c.bodyWantsFocusNow()
    elif not g.app.unitTesting:
        g.app.finishQuit()

    return True # The window has been closed.
</t>
<t tx="ekr.20070626112754.1383">def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    theType = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(c,
        "Confirm",
        'Save changes to %s before %s' % (name,theType))

    # print answer
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            &lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
</t>
<t tx="ekr.20070626112754.1384"># Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")
c.bringToFront()
</t>
<t tx="ekr.20070626112754.1385"></t>
<t tx="ekr.20070626112754.1386">@
The fix was in &lt; &lt; activate this window &gt; &gt;
Happily, the active ivar is now set only in this section, and important simplification.
</t>
<t tx="ekr.20070626112754.1387">def setEditHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())

    fg    = self.headline_text_editing_foreground_color or 'black'
    bg    = self.headline_text_editing_background_color or 'white'
    selfg = self.headline_text_editing_selection_foreground_color or 'white'
    selbg = self.headline_text_editing_selection_background_color or 'black'

    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()
</t>
<t tx="ekr.20070626112754.1388">set_focus_count = 0

def set_focus(self,c,w):

    __pychecker__ = '--no-argsused' # c not used at present.

    """Put the focus on the widget."""

    if not g.app.unitTesting and c and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        # Do not call trace here: that might affect focus!
        print 'gui.set_focus: %4d %10s %s' % (
            self.set_focus_count,c and c.shortFileName(),
            c and c.widget_name(w)), g.callers(5)

    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
</t>
<t tx="ekr.20070626112754.1389"></t>
<t tx="ekr.20070626112754.1390">def bringToFront(self,set_focus=True):

    # g.trace(g.callers())

    c = self
    c.frame.deiconify()

    if set_focus:
        c.frame.body.setFocus()

BringToFront = bringToFront # Compatibility with old scripts
</t>
<t tx="ekr.20070626112754.1391">def bringToFront (self):
    # g.trace(g.callers())
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.bodyCtrl

def getTitle (self):
    return self.top.title()

def setTitle (self,title):
    return self.top.title(title)

def get_window_info(self):
    return g.app.gui.get_window_info(self.top)

def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()

def lift (self):
    self.top.lift()

def update (self):
    self.top.update()
</t>
<t tx="ekr.20070626112754.1392">def onHeadlineClick (self,event,p=None):

    # g.trace('p',p)
    c = self.c ; w = event.widget

    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'

    # g.trace(g.app.gui.widget_name(w)) #p.headString())

    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
</t>
<t tx="ekr.20070626112754.1393">def OnActivateHeadline (self,p,event=None):

    '''Handle common process when any part of a headline is clicked.'''

    # g.trace(p.headString())

    returnVal = 'break' # Default: do nothing more.
    trace = False

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")

    return returnVal
</t>
<t tx="ekr.20070626112754.1394">if p == c.currentPosition():

    if trace: g.trace('current','active',self.active)
    self.editLabel(p) # sets focus.
    # If we are active, pass the event along so the click gets handled.
    # Otherwise, do *not* pass the event along so the focus stays the same.
    returnVal = g.choose(self.active,'continue','break')
    self.active = True
else:
    if trace: g.trace("not current")
    self.select(p,scroll=False)
    w  = c.frame.body.bodyCtrl
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        spot = p.v.t.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)
    # An important detail.
    # The *canvas* (not the headline) gets the focus so that
    # tree bindings take priority over text bindings.
    c.treeWantsFocus()
    self.active = False
    returnVal = 'break'</t>
<t tx="ekr.20070626112754.1395"></t>
<t tx="ekr.20070626112754.1396">def renameChapterHelper (self,cc,tabName):

    '''Called from cc.renameChapter to prompt for a new name.'''

    tt = self ; c = tt.c
    tab = tt.getButton(tabName)

    f = Tk.Frame(tab)
    # Elegant code.  Setting e's textvariable to chapter.sv
    # immediately updates the chapter labels as e changes.
    sv = tt.stringVarDict.get(tabName)
    e = Tk.Entry(f,background='white',textvariable=sv)
    b = Tk.Button(f,text="Close")
    f.pack(side='top')
    e.pack(side='left')
    b.pack(side='right')
    def changeCallback (event=None,f=f,sv=sv):
        newName = sv.get()
        f.pack_forget()
        tt.renameTab(newName)
        # g.trace(tabName,newName)
        theChapter = cc.getChapter(tabName)
        # c.setBodyString(theChapter.root,newName)
        cc.completeChapterRename(theChapter,newName)
        c.bodyWantsFocusNow()
    e.bind('&lt;Return&gt;',changeCallback)
    e.selection_range(0,'end')
    b.configure(command=changeCallback)
    c.widgetWantsFocusNow(e)</t>
<t tx="ekr.20070626112754.1397">def createChapter (self,event=None):

    '''create-chapter command.
    Create a chapter with a dummy first node.'''

    cc = self ; k = cc.c.k ; tag = 'create-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        k.setLabelBlue('Create chapter: ',protect=True)
        k.getArg(event,tag,1,self.createChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=None,
                undoType='Create Chapter')</t>
<t tx="ekr.20070626112754.1398">def createTopLevelMenuItems (self,tmenu):

    cc = self.cc ; menu = tmenu

    for kind,label,command in (
        ('','New Chapter',cc.createChapter),
        ('','Remove This Chapter',cc.removeChapter),
        ('','Rename This Chapter',cc.renameChapter),
        ('-',None,None),
        ('...','Clone Node To Chapter...',cc.cloneToChapter),
        ('...','Copy Node To Chapter...',cc.copyToChapter),
        ('...','Move Node To Chapter...',cc.moveToChapter),
    ):
        if kind == '-':
            menu.add_separator()
        elif kind == '...':
            submenu = Tk.Menu(menu,tearoff=0)
            menu.add_cascade(menu=submenu,label=label)
            def chapterMenuCallback(event=None,cc=cc,command=command,submenu=submenu):
                self.setupChaptersMenu(submenu,command)
            submenu.configure(postcommand=chapterMenuCallback)
        else:
            menu.add_command(label=label,command=command)</t>
<t tx="ekr.20070626112754.1399"></t>
<t tx="ekr.20070626112754.1400">def __init__(self,c,frame,canvas):

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Configuration and debugging settings.
    # These must be defined here to eliminate memory leaks.
    self.allow_clone_drags          = c.config.getBool('allow_clone_drags')
    self.center_selected_tree_node  = c.config.getBool('center_selected_tree_node')
    self.enable_drag_messages       = c.config.getBool("enable_drag_messages")
    self.expanded_click_area        = c.config.getBool('expanded_click_area')
    self.gc_before_redraw           = c.config.getBool('gc_before_redraw')

    self.headline_text_editing_foreground_color = c.config.getColor(
        'headline_text_editing_foreground_color')
    self.headline_text_editing_background_color = c.config.getColor(
        'headline_text_editing_background_color')
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        'headline_text_editing_selection_foreground_color')
    self.headline_text_editing_selection_background_color = c.config.getColor(
        'headline_text_editing_selection_background_color')
    self.headline_text_selected_foreground_color = c.config.getColor(
        "headline_text_selected_foreground_color")
    self.headline_text_selected_background_color = c.config.getColor(
        "headline_text_selected_background_color")
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        "headline_text_editing_selection_foreground_color")
    self.headline_text_editing_selection_background_color = c.config.getColor(
        "headline_text_editing_selection_background_color")
    self.headline_text_unselected_foreground_color = c.config.getColor(
        'headline_text_unselected_foreground_color')
    self.headline_text_unselected_background_color = c.config.getColor(
        'headline_text_unselected_background_color')

    self.idle_redraw = c.config.getBool('idle_redraw')
    self.initialClickExpandsOrContractsNode = c.config.getBool(
        'initialClickExpandsOrContractsNode')
    self.look_for_control_drag_on_mouse_down = c.config.getBool(
        'look_for_control_drag_on_mouse_down')
    self.select_all_text_when_editing_headlines = c.config.getBool(
        'select_all_text_when_editing_headlines')

    self.stayInTree     = c.config.getBool('stayInTreeAfterSelect')
    self.trace          = c.config.getBool('trace_tree')
    self.trace_alloc    = c.config.getBool('trace_tree_alloc')
    self.trace_chapters = c.config.getBool('trace_chapters')
    self.trace_edit     = c.config.getBool('trace_tree_edit')
    self.trace_gc       = c.config.getBool('trace_tree_gc')
    self.trace_redraw   = c.config.getBool('trace_tree_redraw')
    self.trace_select   = c.config.getBool('trace_select')
    self.trace_stats    = c.config.getBool('show_tree_stats')
    self.use_chapters   = c.config.getBool('use_chapters')

    # Objects associated with this tree.
    self.canvas = canvas

    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;

    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.

    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True

    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()

    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets

    self.freeUserIcons = []
</t>
<t tx="ekr.20070626112754.1401">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
</t>
<t tx="ekr.20070626112754.1402"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if present headline is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = 0.0
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)
</t>
<t tx="ekr.20070626112754.1403"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
</t>
<t tx="ekr.20070626112754.1404">def setCanvasBindings (self,canvas):

    k = self.c.k

    canvas.bind('&lt;Key&gt;',k.masterKeyHandler)
    canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    &lt;&lt; make bindings for tagged items on the canvas &gt;&gt;
    &lt;&lt; create baloon bindings for tagged items on the canvas &gt;&gt;</t>
<t tx="ekr.20070626112754.1405">where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '&lt;Button-1&gt;',self.onClickBoxClick),
    ('iconBox','&lt;Button-1&gt;',self.onIconBoxClick),
    ('iconBox','&lt;Double-1&gt;',self.onIconBoxDoubleClick),
    ('iconBox','&lt;Button-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;Double-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;B1-Motion&gt;',self.onDrag),
    ('iconBox','&lt;Any-ButtonRelease-1&gt;',self.onEndDrag),
)
for tag,event,callback in table:
    canvas.tag_bind(tag,event,callback)
</t>
<t tx="ekr.20070626112754.1406">if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
</t>
<t tx="ekr.20070626112754.1407">def newText (self,p,x,y):

    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k
    if self.freeText:
        w,theId = self.freeText.pop()
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.
    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        w = g.app.gui.plainTextWidget(
            canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        w.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;

        theId = canvas.create_window(x,y,anchor="nw",window=w,tag=tag)
        w.leo_window_id = theId # Never changes.

        if self.trace_alloc: g.trace('%3d %6s' % (theId,id(w)),align=-20)

    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')

    if p:
        self.ids[theId] = p # Add the id of the *window*
        self.setHeadlineText(theId,w,p.headString())
        w.configure(width=self.headWidth(p=p))
        w.leo_position = p # This p never changes.
            # *Required*: onHeadlineClick uses w.leo_position to get p.

        # Keys are p.key().  Entries are (w,theId)
        self.visibleText [p.key()] = w,theId
    else:
        g.trace('**** can not happen.  No p')

    return w
</t>
<t tx="ekr.20070626112754.1408">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

instance_tag = w.bindtags()[0]
w.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
w.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
w.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)
</t>
<t tx="ekr.20070626112754.1409"></t>
<t tx="ekr.20070626112754.1410">def completeAllBindingsForWidget (self,w):

    k = self ; d = k.bindingsDict

    # g.trace('w',w,d.has_key('Alt+Key-4'))

    for stroke in d.keys():
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20070626112754.1411">def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict.keys():
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20070626112754.1412">def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    __pychecker__ = '--no-argsused' # w not used (except for debugging).

    k = self ; c = k.c

    # g.trace(g.listToString(d.keys()))

    for commandName in d.keys():
        if commandName == '*entry-commands*': continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('No such command: %s. Referenced from %s' % (
                commandName,modeName))
            continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
</t>
<t tx="ekr.20070626112754.1413">def finishCreate (self):

    '''Find or make the @chapters and @chapter trash nodes.'''

    # This must be called late in the init process:
    # at present, called by g.openWithFileName and c.new.

    cc = self ; c = cc.c

    # Create the @chapters node if needed, and set cc.chaptersNode.
    if not cc.chaptersNode and not cc.findChaptersNode():
        cc.createChaptersNode()

    # Create the main chapter
    cc.chaptersDict['main'] = chapter(c=c,chapterController=cc,name='main',root=c.rootPosition())

    tag = '@chapter'
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith(tag) and not h.startswith('@chapters'):
            tabName = h[len(tag):].strip()
            if tabName and tabName not in ('main',):
                if cc.chaptersDict.get(tabName):
                    self.error('duplicate chapter name: %s' % tabName)
                else:
                    cc.chaptersDict[tabName] = chapter(c=c,chapterController=cc,name=tabName,root=p)

    cc.selectChapterByName('main')
</t>
<t tx="ekr.20070626112754.1414">@
The major problem was that the code that recycled widgets was initially disabled when using multiple trees.</t>
<t tx="ekr.20070626112754.1415"></t>
<t tx="ekr.20070626112754.1416">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""

    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
</t>
<t tx="ekr.20070626112754.1417">def destroySelf (self):

    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c

    # Indicate that the commander is no longer valid.
    c.exists = False 

    # g.trace(self)

    # Important: this destroys all the objects of the commander too.
    self.destroyAllObjects()

    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
</t>
<t tx="ekr.20070626112754.1418"></t>
<t tx="ekr.20070626112754.1419"></t>
<t tx="ekr.20070626112754.1420">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler

    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
</t>
<t tx="ekr.20070626112754.1421"># Disables the "idle" hook.
def disableIdleTimeHook():

    g.app.idleTimeHook = False
</t>
<t tx="ekr.20070626112754.1422"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):

    __pychecker__ = '--no-argsused' # args &amp; keys not used.

    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for z in g.app.windowList:
                c = z.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return

    for z in g.app.windowList:
        c = z.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
</t>
<t tx="ekr.20070626112754.1423">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. c.hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):

    if g.app.killed or g.app.hookError: # or (g.app.gui and g.app.gui.isNullGui):
        return None

    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag in ('open0','start1'):
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            g.es_print(s,color="blue")
        return None

    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins

    try:
        # Pass the hook to the hook handler.
        # print 'doHook',f.__name__,keywords.get('c')
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
</t>
<t tx="ekr.20070626112754.1424">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    # g.trace('base keyHandler',g.callers())

    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter_initially')
    self.enable_calltips                = c.config.getBool('enable_calltips_initially')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = c.config.getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = c.config.getBool('trace_masterClickHandler')
    self.traceMasterCommand             = c.config.getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = c.config.getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = c.config.getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = c.config.getBool('warn_about_redefined_shortcuts')
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;

    self.defineTkNames()
    self.defineSpecialKeys()
    self.autoCompleter = autoCompleterClass(self)
    self.setDefaultUnboundKeyAction()
</t>
<t tx="ekr.20070626112754.1425">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
</t>
<t tx="ekr.20070626112754.1426">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
</t>
<t tx="ekr.20070626112754.1427"># debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
</t>
<t tx="ekr.20070626112754.1428">def clearAllIvars (o):

    """Clear all ivars of o, a member of some class."""

    if o:
        o.__dict__.clear()
</t>
<t tx="ekr.20070626112754.1429">def collectGarbage():

    try:
        if not g.app.trace_gc_inited:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            # print('Collecting garbage',g.callers())
            print 'collectGarbage:'

        gc.collect()
    except Exception:
        pass

    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True
</t>
<t tx="ekr.20070626112754.1430">no_gc_message = False

def enable_gc_debug(event=None):

    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
        # else:
            # gc.set_debug(gc.DEBUG_STATS)
    elif not g.no_gc_message:
        g.no_gc_message = True
        g.es('Can not import gc module',color='blue')
</t>
<t tx="ekr.20070626112754.1431"># Formerly called from unit tests.

def printGc(tag=None):

    if not g.app.trace_gc: return None

    tag = tag or g._callerName(n=2)

    printGcObjects(tag=tag)
    printGcRefs(tag=tag)

    if g.app.trace_gc_verbose:
        printGcVerbose(tag=tag)
</t>
<t tx="ekr.20070626112754.1432">def printGcRefs (tag=''):

    refs = gc.get_referrers(app.windowList[0])
    print('-' * 30,tag)

    if g.app.trace_gc_verbose:
        print("refs of", app.windowList[0])
        for ref in refs:
            print(type(ref))
    else:
        print("%d referers" % len(refs))
</t>
<t tx="ekr.20070626112754.1433">def printGcAll (tag=''):

    # Suppress warning about keywords arg not supported in sort.

    tag = tag or g._callerName(n=2)
    d = {} ; objects = gc.get_objects()
    print('-' * 30)
    print('%s: %d objects' % (tag,len(objects)))

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        # if type(obj) == type(()):
            # print id(obj),repr(obj)
        d[t] = d.get(t,0) + 1

    if 1: # Sort by n
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            print '%40s %7d' % (z[0],z[1])
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            print '%40s %7d' % (t,d.get(t))
</t>
<t tx="ekr.20070626112754.1434">def printGcObjects(tag=''):

    '''Print newly allocated objects.'''

    tag = tag or g._callerName(n=2)
    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        if delta == 0: return
        lastObjectCount = n2

        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

    except Exception:
        traceback.print_exc()

printNewObjects = pno = printGcObjects

</t>
<t tx="ekr.20070626112754.1435">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    t = type(obj)
    if t == 'instance' and t not in types.StringTypes:
        try: t = obj.__class__
        except: pass
    if t != types.FrameType:
        r = repr(t) # was type(obj) instead of repr(t)
        n = typesDict.get(r,0) 
        typesDict[r] = n + 1

# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

empty = True
for key in keys:
    n3 = lastTypesDict.get(key,0)
    n4 = typesDict.get(key,0)
    delta2 = n4-n3
    if delta2 != 0:
        empty = False
        break

if not empty:
    # keys = [repr(key) for key in keys]
    keys.sort()
    print '-' * 30
    print "%s: garbage: %d, objects: %d, delta: %d" % (tag,n,n2,delta)

    if 0:
        for key in keys:
            n1 = lastTypesDict.get(key,0)
            n2 = typesDict.get(key,0)
            delta2 = n2-n1
            if delta2 != 0:
                print("%+6d =%7d %s" % (delta2,n2,key))

lastTypesDict = typesDict
typesDict = {}
</t>
<t tx="ekr.20070626112754.1436"># import types
import inspect

global lastFunctionsDict

funcDict = {}

# Don't print more than 50 objects.
n = 0
for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        n += 1

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if n &lt; 50 and not lastFunctionsDict.has_key(key):
            print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            print("args", args)
            if varargs: print("varargs",varargs)
            if varkw: print("varkw",varkw)
            if defaults:
                print("defaults...")
                for s in defaults: print(s)

lastFunctionsDict = funcDict
funcDict = {}
</t>
<t tx="ekr.20070626112754.1437">def printGcSummary (tag=''):

    tag = tag or g._callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = '%s: printGCSummary: garbage: %d, objects: %d' % (tag,n,n2)
        print s
    except:
        traceback.print_exc()
</t>
<t tx="ekr.20070626112754.1438"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(tag=''):

    tag = tag or g._callerName(n=2)
    global lastObjectsDict
    objects = gc.get_objects()
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]

    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o

    dicts = 0 ; seqs = 0

    i = 0 ; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            #print id(o),repr(o)
            seqs += 1
        #else:
        #    print(o)
        i += 1
    print('=' * 40)
    print('dicts: %d, sequences: %d' % (dicts,seqs))
    print("%s: %d new, %d total objects" % (tag,len(newObjects),len(objects)))
    print('-' * 40)
</t>
<t tx="ekr.20070626112754.1439"></t>
<t tx="ekr.20070626112754.1440"></t>
<t tx="ekr.20070626112754.1441"></t>
<t tx="ekr.20070626112754.1442">@ The fix was to g.skip_to_end_of_line (!)

All such functions now return len(s) as a boundary condition.
This is a major change.  All unit tests pass.</t>
<t tx="ekr.20070626112754.1443">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4315027
By: billpage

In Leo 4.4.3 alpha 2 using "Import noweb files" causes Leo to crash. I first
tried omething more complex but I found that even if I create a simple one node
test outline, use "Export Outline to noweb" to create a .nw file then try to
import that noweb file I get the same result.

https://sourceforge.net/forum/message.php?msg_id=4318521
By: billpage

On May 15, 2007 9:48 AM Ralf Hemmecke (another Axiom developer)
sent to me the following example:

Then the first thing I tried was to import a noweb file. I used 
leo-4-4-3-alpha-2 on the following file (dont put the %--- line into the 
file but keep the final empty line.

%---BEGIN asfiles.pl.nw
&lt;&lt;*&gt;&gt;=
Here is the code
@

%---END asfile.pl.nw

LEO hangs itself up. I seem to be unlucky. Unfortunately, I am not a 
python programmer myself so that I could dig into the problem.

I now give up for the second time. The empty line at the end seems not 
the only problem.

I know that LEO has some good ideas, especially I like the cloning 
stuff, but I cannot appreciate LEO not only for the reason that it 
doesn't let me import my files.

-----
http://sourceforge.net/forum/message.php?msg_id=4318542
By: billpage

Here is last part of the the error message traceback that I get
when doing the above test on OpenSuSE 10.2 with Leo 4.4.3 alpha 2:

  ... 
  File "/home/wspage/leo-4-4-3-alpha-2/src/leoImport.py", line 3118, in
isDocStart
    if not g.match(s,i,"@"):

  File "/home/wspage/leo-4-4-3-alpha-2/src/leoGlobals.py", line 3432, in match
    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i

KeyboardInterrupt

wrote /home/wspage/.leoRecentFiles.txt

--------

after hitting Control-C in the console window that started Leo.

</t>
<t tx="ekr.20070626112754.1444">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4315078
By: billpage

I have a similar problem to that described by the author of this thread. I am
one of the developers of the Axiom open source project (see:
http://wiki.axiom-developer.org ). Axiom uses noweb format for all source files
in the distribution and includes C, Lisp, make, awk scripts, Boot, and Spad
code (the last two programming languages specific to Axiom).

Pervasive use of Literate Programming is a accepted goal of the project but
it is not yet fully achieved. We still have many discussions concerning the
merits of different approaches to adding documentation to such a large "illiterate"
legacy code base. (Some of the code in Axiom was written more than 30 years
ago and was never properly documented.) The issue of building "traditional"
(Knuth-style) monolithic book-sized volumes for the various components of Axiom
by merging large numbers of legacy source code files and newly developed
documentation into a small number of noweb files is especially contentious.
Based on information on the Leo web site and experience with the Leo tutorials,
I have repeatedly advocated the use of Leo as an alternative to this traditional
approach. Now some of the other Axiom developers might finally be listening...

But as I said, I have a problem. When I try to import the Axiom noweb files
into Leo I get "odd" results. These files are processed properly by noweb's
notangle and noweave commands but I can not reproduce this using Leo. The
documentation and code chunks (sections) are not always represented as nodes
in the outline in the way I would expect, e.g. I see nodes named "Limbo", "avoiding"
and "center" in addition to most (but not all) of the &lt;&lt; chunk names &gt;&gt; in the
noweb file.  Plus Leo's "Export Weave" command does not produce output that
sufficiently closely resembles the noweave output of noweb. We need/expect to
be able to process this output of weave by LaTeX but it contains other generated
text that is clearly not LaTeX compatible.

More specifically: I do not see any @ignore directive in the root node following
import of the noweb file. Nor do I see any generated @file, @root or other
directives. At the moment I am using "Leo 4.4.2.1 final, build  1.83 , October
29, 2006" from the Windows exe install file, but my comments also apply to the
same version of Leo on Linux.

I have other questions as well concerning customization of Leo's parsing and
generation of comments in target source languages other than Java and C which
I have not found answered in the Leo users guide or tutorials. But I will save
that for another time.

http://wiki.axiom-developer.org
</t>
<t tx="ekr.20070626112754.1445"></t>
<t tx="ekr.20070626112754.1446">def createOutline (self,fileName,parent):

    c = self.c ; u = c.undoer
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".lua", ".pas", ".py", ".pyw", ".php")
    &lt;&lt; Read file into s &gt;&gt;
    # Create the top-level headline.
    undoData = u.beforeInsertNode(parent)
    p = parent.insertAsLastChild()
    if self.treeType == "@file":
        p.initHeadString("@file " + fileName)
    else:
        p.initHeadString(fileName)
    u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        c.setBodyString(p,body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p)
    elif ext == ".el":
        self.scanElispText(s,p)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,p)
    elif ext == ".java":
        self.scanJavaText(s,p,True) #outer level
    elif ext == ".lua":
        self.scanLuaText(s,p)
    elif ext == ".pas":
        self.scanPascalText(s,p)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p)
    elif ext == ".php":
        self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return p
</t>
<t tx="ekr.20070626112754.1447">try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
</t>
<t tx="ekr.20070626112754.1448">def getTabWidth (self):

    d = g.scanDirectives(self.c)
    w = d.get("tabwidth")
    if w not in (0,None):
        return w
    else:
        return self.c.tab_width
</t>
<t tx="ekr.20070626112754.1449">def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1450">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
</t>
<t tx="ekr.20070626112754.1451">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
</t>
<t tx="ekr.20070626112754.1452">def importFilesCommand (self,files=None,treeType=None,
    perfectImport=True,testing=False,verbose=False):
        # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                perfectImport = False ###
                testing = True; verbose = True
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
</t>
<t tx="ekr.20070626112754.1453">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
</t>
<t tx="ekr.20070626112754.1454"></t>
<t tx="ekr.20070626112754.1455"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

    __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    c.beginUpdate()
    try: # range of update...
        firstLevel, junk = self.moreHeadlineLevel(strings[0])
        lastLevel = -1 ; theRoot = lastVnode = None
        index = 0
        while index &lt; len(strings):
            progress = index
            s = strings[index]
            level, newFlag = self.moreHeadlineLevel(s)
            level -= firstLevel
            if level &gt;= 0:
                &lt;&lt; Link a new vnode v into the outline &gt;&gt;
                &lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
                &lt;&lt; Count the number of following body lines &gt;&gt;
                &lt;&lt; Add the lines to the body text of v &gt;&gt;
                v.setDirty()
            else: index += 1
            assert progress &lt; index
        if theRoot:
            theRoot.setDirty()
            c.setChanged(True)
    finally:
        c.endUpdate()
    return theRoot
</t>
<t tx="ekr.20070626112754.1456">assert(level &gt;= 0)
if lastVnode is None:
    # g.trace(firstVnode)
    theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
    v = lastVnode.insertAfter()
elif level == lastLevel + 1:
    v = lastVnode.insertAsNthChild(0)
else:
    assert(level &lt; lastLevel)
    while level &lt; lastLevel:
        lastLevel -= 1
        lastVnode = lastVnode.parent()
        assert(lastVnode)
        assert(lastLevel &gt;= 0)
    v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level
</t>
<t tx="ekr.20070626112754.1457">j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

v.initHeadString(s[j:])
</t>
<t tx="ekr.20070626112754.1458">bodyLines = 0
index += 1 # Skip the headline.
while index &lt; len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level &gt;= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
</t>
<t tx="ekr.20070626112754.1459">if bodyLines &gt; 0:
    body = ""
    n = index - bodyLines
    while n &lt; index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    v.setTnodeText(body)
</t>
<t tx="ekr.20070626112754.1460">def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) &lt; 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    &lt;&lt; Read the file into array &gt;&gt;

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
</t>
<t tx="ekr.20070626112754.1461">try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
</t>
<t tx="ekr.20070626112754.1462"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
</t>
<t tx="ekr.20070626112754.1463"># Used by paste logic.

def stringIsValidMoreFile (self,s):

    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

    if len(strings) &lt; 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i &lt; len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level &gt; 0:
            if level &lt; level1 or level &gt; lastLevel + 1:
                return False # improper level.
            elif level &gt; lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
</t>
<t tx="ekr.20070626112754.1464"></t>
<t tx="ekr.20070626112754.1465">def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)

    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
</t>
<t tx="ekr.20070626112754.1466">def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1467">def findFunctionDef (self,s,i):

    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i &lt; k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
</t>
<t tx="ekr.20070626112754.1468">@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):

    if self.webType == "cweb":
        &lt;&lt; scan cweb body for headline &gt;&gt;
    else:
        &lt;&lt; scan noweb body for headline &gt;&gt;
    return "@" # default.
</t>
<t tx="ekr.20070626112754.1469">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @&lt;.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i &lt; len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@&lt;"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@&gt;")
        if k &gt; -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20070626112754.1470">i = 0
while i &lt; len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"&lt;&lt;"):
        k = g.find_on_line(s,i,"&gt;&gt;=")
        if k &gt; -1:
            ref = s[i:k+2]
            name = string.strip(s[i+2:k])
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
</t>
<t tx="ekr.20070626112754.1471">def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    &lt;&lt; Create a symbol table of all section names &gt;&gt;
    &lt;&lt; Create nodes for limbo text and the root section &gt;&gt;
    while i &lt; len(s):
        outer_progress = i
        &lt;&lt; Create a node for the next module &gt;&gt;
        assert(i &gt; outer_progress)</t>
<t tx="ekr.20070626112754.1472">i = 0 ; self.web_st = []

while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k &gt; -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i &gt; progress)

# g.trace(self.cstDump())
</t>
<t tx="ekr.20070626112754.1473">i = 0
while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i &gt; progress)

j = g.skip_ws(s,0)
if j &lt; i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i &gt; progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
</t>
<t tx="ekr.20070626112754.1474">if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i &lt; len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i &gt; progress)
    &lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i &gt; progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20070626112754.1475">if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i &lt; len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i &gt; progress)
    i = g.skip_ws_and_nl(s,i)

while i &lt; len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i &gt; progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i &lt; len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i &gt; progress)
</t>
<t tx="ekr.20070626112754.1476"></t>
<t tx="ekr.20070626112754.1477"># We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):

    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
</t>
<t tx="ekr.20070626112754.1478">def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
</t>
<t tx="ekr.20070626112754.1479"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return

    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
</t>
<t tx="ekr.20070626112754.1480"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):

    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
</t>
<t tx="ekr.20070626112754.1481">def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):

    __pychecker__ = 'maxlines=500'

    &lt;&lt; about this algorithm &gt;&gt;
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        &lt;&lt; clear all dirty bits &gt;&gt;
    &lt;&lt; Assign file indices &gt;&gt;
    &lt;&lt; Write root's tree to to string s &gt;&gt;

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()

    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            &lt;&lt; put the corrected fat lines in a new node &gt;&gt;
        &lt;&lt; correct root's tree using write_lines &gt;&gt;
    if verify:
        &lt;&lt; verify that writing the tree would produce the original file &gt;&gt;
</t>
<t tx="ekr.20070626112754.1482">@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
</t>
<t tx="ekr.20070626112754.1483">for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
</t>
<t tx="ekr.20070626112754.1484">nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
</t>
<t tx="ekr.20070626112754.1485">at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
</t>
<t tx="ekr.20070626112754.1486">write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
</t>
<t tx="ekr.20070626112754.1487">@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "&lt;perfectImport string-file&gt;"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
</t>
<t tx="ekr.20070626112754.1488">try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()

    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)

    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)

    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            &lt;&lt; dump the files &gt;&gt;
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
</t>
<t tx="ekr.20070626112754.1489">print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j &lt; i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k &lt; i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
</t>
<t tx="ekr.20070626112754.1490"></t>
<t tx="ekr.20070626112754.1491"></t>
<t tx="ekr.20070626112754.1492">def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace(g.get_line(s,i))
    c = self.c
    class_indent = self.getLeadingIndent(s,i)
    &lt;&lt; set class_name and headline &gt;&gt;
    if not class_name: return i
    i = g.skip_line(s,i) # Skip the class line.
    i,prefix,body = self.createClassNodeText(s,i,start)
    class_vnode = self.createHeadline(parent,prefix + body,headline)
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,class_indent,indent_parent_ref_flag=True)
    start,i = self.scanPythonClassHelper(s,i,class_indent,class_name,class_vnode)
    s2 = s[start:i]
    if s2: c.appendStringToBody(class_vnode,s2)
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20070626112754.1493"># Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    class_name = s[j:i]
    headline = "class " + class_name
else:
    headline = ''
    class_name = ''
</t>
<t tx="ekr.20070626112754.1494">def scanPythonClassHelper(self,s,i,class_indent,class_name,class_vnode):

    indent =  self.getLeadingIndent(s,i)
    start = i = g.skip_blank_lines(s,i)
    parent_vnode = None
    while i &lt; len(s):
        progress = i
        # New in Leo 4.4.1: ignore comment lines, whatever their indentation.
        if indent &lt;= class_indent:
            j = g.skip_ws(s,i)
            if g.match(s,j,'#'):
                i = g.skip_to_end_of_line(s,j)
            else: break
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            j = g.skip_nl(s,i)
            if not backslashNewline:
                indent = self.getLeadingIndent(s,j)
                if indent &gt; class_indent: i = j
                else: break
            else: i = j
        elif g.match_c_word(s,i,"def"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonDef(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif g.match_c_word(s,i,"class"):
            if not parent_vnode:
                self.createParentText(class_vnode,class_name)
                parent_vnode = class_vnode
            i = start = self.scanPythonClass(s,i,start,parent_vnode)
            indent = self.getLeadingIndent(s,i)
        elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
        elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
        else: i += 1
        assert(progress &lt; i)
    return start,i
</t>
<t tx="ekr.20070626112754.1495">def createParentText (self,class_vnode,class_name):

    '''Insert the proper body text in the class_vnode.'''

    c = self.c

    # This must be done after the declaration reference is generated.
    if self.treeType == "@file":
        c.appendStringToBody(class_vnode,"\t@others\n")
    else:
        ref = g.angleBrackets(' class %s methods ' % (class_name))
        c.appendStringToBody(class_vnode,"\t" + ref + "\n\n")
</t>
<t tx="ekr.20070626112754.1496">def createClassNodeText (self,s,i,start):

    # Create the section name using the old value of self.methodName.
    if  self.treeType == "@file":
        prefix = ""
    else:
        prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
        self.methodsSeen = True

    # i points just after the class line.

    # Add a docstring to the class node.
    docStringSeen = False
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j != len(s): # No scanning error.
            i = j ; docStringSeen = True

    body = s[start:i]
    body = self.undentBody(body)
    if docStringSeen: body = body + '\n'

    return i,prefix,body
</t>
<t tx="ekr.20070626112754.1497">def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    &lt;&lt; set headline or return i &gt;&gt;
    i = self.skipPythonDef(s,i,start)
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    &lt;&lt; Create def node &gt;&gt;
    self.methodName = savedMethodName
    return i
</t>
<t tx="ekr.20070626112754.1498">i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
</t>
<t tx="ekr.20070626112754.1499"># Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)
</t>
<t tx="ekr.20070626112754.1500">def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):

    c = self.c
    done = False ; start = i
    while not done and i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent &lt;= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; break on def or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j &lt; i:
        &lt;&lt; Create a child node for declarations &gt;&gt;
    return i
</t>
<t tx="ekr.20070626112754.1501">if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)
</t>
<t tx="ekr.20070626112754.1502">headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
c.appendStringToBody(parent,leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20070626112754.1503"># See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    c = self.c
    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i &lt; len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            &lt;&lt; handle possible Python function or class &gt;&gt;
        else: i += 1
        assert(progress &lt; i)
    if not decls_seen: # 2/17/03
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
    &lt;&lt; Append a reference to the methods of this file &gt;&gt;
    &lt;&lt; Append any unused python text to the parent's body text &gt;&gt;
</t>
<t tx="ekr.20070626112754.1504">if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file":
            c.appendStringToBody(parent,"@others\n")
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
</t>
<t tx="ekr.20070626112754.1505">if self.treeType == "@root" and self.methodsSeen:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
</t>
<t tx="ekr.20070626112754.1506"># Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i &lt; len(s):
    c.appendStringToBody(parent,s[start:])
</t>
<t tx="ekr.20070626112754.1507">def skipPythonDef (self,s,i,start):

    # g.trace(g.get_line(s,i))

    # Set defIndent to the indentation of the def line.
    defIndent = self.getLeadingIndent(s,start)
    parenCount = 0
    &lt;&lt; skip the entire signature &gt;&gt;
    indent = self.getLeadingIndent(s,i)
    while i &lt; len(s): # and indent &gt; defIndent
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            if not backslashNewline:
                # New in Leo 4.4.1: don't set indent for comment lines.
                j = g.skip_ws(s,i)
                if not g.match(s,j,'#'):
                    indent = self.getLeadingIndent(s,i)
                    if indent &lt;= defIndent and parenCount == 0:
                        break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress &lt; i)

    return i
</t>
<t tx="ekr.20070626112754.1508"># Now that we count parens, we must be careful to skip the entire signature.

j = s.find('(',i)
if j != -1:
    j = g.skip_matching_python_parens(s,j)

if j == -1 or not g.match(s,j+1,':'):
    g.es_print('Warning: improper signature: %s' % g.get_line(s,i))
    return i
else:
    i = g.skip_line(s,j) # Still not quite 100% correct.
</t>
<t tx="ekr.20070626112754.1509">if g.unitTesting:

    c,p = g.getTestVars()
    self = c.importCommands

    # global c # Get syntax warning if this is not first.
    # if self: c = self.c             # Run from @test node: c not global
    # else: self = c.importCommands   # Run from @suite: c *is* global
    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    &lt;&lt; define s &gt;&gt;
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('pass'),'result:\n%s' % result
</t>
<t tx="ekr.20070626112754.1510">s = '''\
def test1():
    aList = (a,
b,c)
# underindented comment.
    return 1

def test2():
# underindented comment.
    pass
'''

s = g.adjustTripleString(s,self.tab_width)
</t>
<t tx="ekr.20070626112754.1511">if g.unitTesting:

    c,p = g.getTestVars()
    self = c.importCommands

    # global c # Get syntax warning if this is not first.
    # if self: c = self.c             # Run from @test node: c not global
    # else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    &lt;&lt; define s &gt;&gt;
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test1') and result.endswith('return 1'),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('def test2') and result.endswith('return 2'),'result:\n%s' % result
</t>
<t tx="ekr.20070626112754.1512">s = '''\
def test1(
        a=2):
    return 1

def test2(
a=3):
    return 2
'''

s = g.adjustTripleString(s,self.tab_width)
</t>
<t tx="ekr.20070626112754.1513">if g.unitTesting:

    c,p = g.getTestVars()
    self = c.importCommands

    # global c # Get syntax warning if this is not first.
    # if self: c = self.c             # Run from @test node: c not global
    # else: self = c.importCommands   # Run from @suite: c *is* global

    d = g.scanDirectives(c)
    self.tab_width = d.get("tabwidth")
    verbose = False
    &lt;&lt; define s &gt;&gt;
    start = 0
    i = self.skipPythonDef(s,i=0,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass') and result.endswith("'eggs'"),'result:\n%s' % result
    start = i
    i = self.skipPythonDef(s,i=i,start=start)
    result = s[start:i].strip()
    if verbose: g.trace(result)
    assert result.startswith('class aClass2') and result.endswith("'twit'"),'result:\n%s' % result
</t>
<t tx="ekr.20070626112754.1514">s = '''\
class aClass:
    def spam():
        return 'spam'
# underindented comment line
    def eggs():
        return 'eggs'

class aClass2:
    def twit():
        return 'twit'
'''

s = g.adjustTripleString(s,self.tab_width)
</t>
<t tx="ekr.20070626112754.1515">def scanElispText(self,s,p):

    c = self.c
    c.appendStringToBody(p,"@ignore\n@language elisp\n")
    i = 0 ; start = 0
    while i &lt; len(s):
        progress = i
        ch = s[i] ; # g.trace(g.get_line(s,i))
        if ch == ';':
            i = g.skip_line(s,i)
        elif ch == '(':
            j = self.skipElispParens(s,i)
            k = g.skip_ws(s,i+1)
            if g.match_word(s,k,"defun") or g.match_word(s,k,"defconst") or g.match_word(s,k,"defvar"):
                data = s[start:i]
                if data.strip():
                    self.createElispDataNode(p,data)
                self.createElispFunction(p,s[i:j+1])
                start = j+1
            i = j
        else:
            i += 1
        assert(progress &lt; i)
    data = s[start:len(s)]
    if data.strip():
        self.createElispDataNode(p,data)
</t>
<t tx="ekr.20070626112754.1516">def skipElispParens (self,s,i):

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))

    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:
                return i
            i += 1
        elif c == '"': i = g.skip_string(s,i) # Single-quotes are not strings.
        elif g.match(s,i,";"):  i = g.skip_line(s,i)
        else: i += 1
    return i
</t>
<t tx="ekr.20070626112754.1517">def skipElispId (self,s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20070626112754.1518">def createElispFunction (self,p,s):

    body = s
    i = 1 # Skip the '('
    i = g.skip_ws(s,i)

    # Set the prefix in the headline.
    assert(g.match(s,i,"defun") or g.match_word(s,i,"defconst") or g.match_word(s,i,"defvar"))
    if g.match_word(s,i,"defconst"):
        prefix = "const "
    elif g.match_word(s,i,"defvar"):
        prefix = "var "
    else:
        prefix = ""

    # Skip the "defun" or "defconst" or "defvar"
    i = self.skipElispId(s,i)

    # Get the following id.
    i = g.skip_ws(s,i)
    j = self.skipElispId(s,i)
    theId = prefix + s[i:j]

    self.createHeadline(p,body,theId)
</t>
<t tx="ekr.20070626112754.1519">def createElispDataNode (self,p,s):

    data = s
    # g.trace(len(data))

    # Skip blank lines and comment lines.
    i = 0
    while i &lt; len(s):
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,';'):
            i = g.skip_line(s,i)
        else: break

    # Find the next id, probably prefixed by an open paren.
    if g.match(s,i,"("):
        i = g.skip_ws(s,i+1)
    j = self.skipElispId(s,i)
    theId = s[i:j]
    if not theId:
        theId = "unnamed data"

    self.createHeadline(p,data,theId)
</t>
<t tx="ekr.20070626112754.1520">def scanForthText (self,s,parent):

    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    self.c.setBodyString(parent,"@ignore\n" + "@language forth\n" + self.rootLine + s)
</t>
<t tx="ekr.20070626112754.1521"># Creates a child of parent for each Java function definition seen.

def scanJavaText (self,s,parent,outerFlag): # True if at outer level.

    __pychecker__ = 'maxlines=500'

    &lt;&lt; define scanJavaText vars &gt;&gt;
    # if not outerFlag: g.trace("inner:",s)
    while i &lt; len(s):
        # g.trace(g.get_line(s,i))
        ch = s[i]
        # These cases skip tokens.
        if ch == '/':
            &lt;&lt; handle possible Java comments &gt;&gt;
        elif ch == '"' or ch == '\'': i = g.skip_string(s,i)
        # These cases help determine where functions start.
        elif ch == '=':
            &lt;&lt; handle equal sign in Java &gt;&gt;
        elif ch == '(':
            &lt;&lt; handle open paren in Java &gt;&gt;
        elif ch == ';':
            &lt;&lt; handle semicolon in Java &gt;&gt;
            class_seen = False
        # These cases can create child nodes.
        elif ch == '{':
            &lt;&lt; handle open curly bracket in Java &gt;&gt;
        elif g.is_c_id(s[i]):
            &lt;&lt; skip and remember the Java id &gt;&gt;
        else: i += 1
    &lt;&lt; Append any unused text to the parent's body text &gt;&gt;
</t>
<t tx="ekr.20070626112754.1522">c = self.c
method_seen = False
class_seen = False # True: class keyword seen at outer level.
interface_seen = False # True: interface keyword seen at outer level.
lparen = None  # not None if '(' seen at outer level.
scan_start = 0
name = None
function_start = 0 # g.choose(outerFlag, None, 0)
i = 0
</t>
<t tx="ekr.20070626112754.1523">if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1524">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = 0 # 3/23/03: (bug fix: was None) We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if g.match(s,i,'='):
    i = g.skip_braces(s,i)
</t>
<t tx="ekr.20070626112754.1525">lparen = i
# This will skip any equal signs inside the paren.
i = g.skip_parens(s,i)
if g.match(s,i,')'):
    i += 1
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        lparen = None # not a function definition.
else: lparen = None
</t>
<t tx="ekr.20070626112754.1526">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
    function_start = i + 1 # The semicolon ends the declaration.
</t>
<t tx="ekr.20070626112754.1527">brace_ip1 = i
i = g.skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i

if not g.match (s,i,'}'):
    g.es("unmatched '{'")
elif not name:
    i += 1
elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
    # g.trace("starting:",name)
    # g.trace("outerFlag:",outerFlag)
    # g.trace("lparen:",lparen)
    # g.trace("class_seen:",class_seen)
    # g.trace("scan_start:",g.get_line_after(s,scan_start))
    # g.trace("func_start:",g.get_line_after(s,function_start))
    # g.trace("s:",g.get_line(s,i))

    # Point i _after_ the last character of the method.
    i += 1
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
    function_end = i
    headline = name
    if outerFlag:
        leader = "" ; decl_leader = ""
        if class_seen:
            headline = "class " + headline
            methodKind = "classes"
        else:
            headline = "interface " + headline
            methodKind = "interfaces"
    else:
        leader = "\t" # Indent only inner references.
        decl_leader = "\n"  # Declaration leader for inner references.
        methodKind = "methods"
    if method_seen:
        # Include everything after the last fucntion.
        function_start = scan_start
    else:
        &lt;&lt; create a Java declaration node &gt;&gt;
        &lt;&lt; append Java method reference to parent node &gt;&gt;
    if outerFlag: # Create a class.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:brace_ip1+1]
        body = self.massageBody(body,methodKind)
        v = self.createHeadline(parent,body,headline)
        &lt;&lt; recursively scan the text &gt;&gt;
        # Append the brace to the parent.
        c.appendStringToBody(v,"}")
        i = brace_ip2 + 1 # Start after the closing brace.
    else: # Create a method.
        # Backtrack so we remove leading whitespace.
        function_start = g.find_line_start(s,function_start)
        body = s[function_start:function_end]
        body = self.massageBody(body,methodKind)
        self.createHeadline(parent,body,headline)
        i = function_end
    method_seen = True
    scan_start = function_start = i # Set the start of the _next_ function.
    lparen = None ; class_seen = False
else: i += 1
</t>
<t tx="ekr.20070626112754.1528">save_ip = i
i = scan_start
while i &lt; function_start and g.is_ws_or_nl(s,i):
    i += 1

if outerFlag:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language java\n")

if i &lt; function_start:
    decl_headline = g.angleBrackets(" " + self.methodName + " declarations ")

    # Append the headline to the parent's body.
    c.appendStringToBody(parent,decl_leader + leader + decl_headline + "\n")
    scan_start = g.find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
    decls = s[scan_start:function_start]
    decls = self.undentBody(decls)
    body = g.choose(self.treeType == "@file",decls,"@code\n\n" + decls)
    self.createHeadline(parent,body,decl_headline)

i = save_ip
scan_start = i
</t>
<t tx="ekr.20070626112754.1529">if self.treeType == "@file":
    if outerFlag:
        c.appendStringToBody(parent,"\n@others\n")
    else:
        c.appendStringToBody(parent,"\n\t@others\n")
else:
    kind = g.choose(outerFlag,"classes","methods")
    ref_name = g.angleBrackets(" " + self.methodName + " " + kind + " ")
    c.appendStringToBody(parent,leader + ref_name + "\n")
</t>
<t tx="ekr.20070626112754.1530"># These mark the points in the present function.
# g.trace("recursive scan:",g.get_line(s,brace_ip1+ 1))
oldMethodName = self.methodName
self.methodName = headline
self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
    v,False) # inner level
self.methodName = oldMethodName
</t>
<t tx="ekr.20070626112754.1531">if g.match_c_word(s,i,"class") or g.match_c_word(s,i,"interface"):
    if g.match_c_word(s,i,"class"):
        class_seen = True
    else:
        interface_seen = True
    i = g.skip_c_id(s,i) # Skip the class or interface keyword.
    i = g.skip_ws_and_nl(s,i)
    if i &lt; len(s) and g.is_c_id(s[i]):
        # Remember the class or interface name.
        j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
else:
    j = i ; i = g.skip_c_id(s,i)
    if not lparen and not class_seen:
        name = s[j:i] # Remember the name.
</t>
<t tx="ekr.20070626112754.1532"># Used by the Java and Pascal scanners.

i = g.skip_ws_and_nl(s,scan_start)
if i &lt; len(s):
    c.appendStringToBody(parent,s[scan_start:])
</t>
<t tx="ekr.20070626112754.1533">def scanLuaText (self,s,parent):

    """Minimal Lua scanner - leave it to user to create nodes as they see fit."""

    self.c.setBodyString(parent,"@ignore\n" + "@language lua\n" + self.rootLine + s)
</t>
<t tx="ekr.20070626112754.1534"># Creates a child of parent for each Pascal function definition seen.

def scanPascalText (self,s,parent):

    c = self.c
    method_seen = False ; methodKind = "methods"
    scan_start = function_start = i = 0
    name = None
    while i &lt; len(s):
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(s[i]):
            &lt;&lt; handle possible Pascal function &gt;&gt;
        else: i += 1
    &lt;&lt; Append any unused text to the parent's body text &gt;&gt;
</t>
<t tx="ekr.20070626112754.1535">if g.match_c_word(s,i,"begin"):
    i = g.skip_pascal_begin_end(s,i)
    if g.match_c_word(s,i,"end"):
        i = g.skip_c_id(s,i)
elif (g.match_c_word(s,i,"function")  or g.match_c_word(s,i,"procedure") or
    g.match_c_word(s,i,"constructor") or g.match_c_word(s,i,"destructor")):

    # line = g.get_line(s,i) ; g.trace(line)

    start = i
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    &lt;&lt; remember the function name, or continue &gt;&gt;
    &lt;&lt; skip the function definition, or continue &gt;&gt;
    if not method_seen:
        method_seen = True
        &lt;&lt; create a child node for leading declarations &gt;&gt;
        &lt;&lt; append noweb method reference to the parent node &gt;&gt;
        function_start = start
    else: function_start = scan_start
    &lt;&lt; create a child node for the function &gt;&gt;
else: i = g.skip_c_id(s,i)
</t>
<t tx="ekr.20070626112754.1536">if i &lt; len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    while i + 1 &lt; len(s) and s[i] == '.' and g.is_c_id(s[i+1]):
        i += 1 ; j = i
        i = g.skip_c_id(s,i)
    name = s[j:i]
else: continue
</t>
<t tx="ekr.20070626112754.1537">&lt;&lt; skip past the semicolon &gt;&gt;

if not g.match_c_word(s,i,"begin"):
    continue
# Skip to the matching end.
i = g.skip_pascal_begin_end(s,i)
if g.match_c_word(s,i,"end"):
    i = g.skip_c_id(s,i)
    i = g.skip_ws_and_nl(s,i)
    if g.match(s,i,';'):
        i += 1
    i = g.skip_ws(s,i)
    if g.is_nl(s,i):
        i = g.skip_nl(s,i)
else: continue
</t>
<t tx="ekr.20070626112754.1538">while i &lt; len(s) and s[i] != ';':
    # The paremeter list may contain "inner" semicolons.
    if s[i] == '(':
        i = g.skip_parens(s,i)
        if g.match(s,i,')'):
            i += 1
        else: break
    else: i += 1
if g.match(s,i,';'):
    i += 1
i = g.skip_ws_and_nl(s,i)

if g.match_c_word(s,i,"var"):
    # Skip to the next begin.
    i = g.skip_c_id(s,i)
    done = False
    while i &lt; len(s) and not done:
        ch = s[i]
        if ch == '{': i = g.skip_pascal_braces(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.is_c_id(ch):
            if g.match_c_word(s,i,"begin"): done = True
            else: i = g.skip_c_id(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_pascal_string(s,i)
        else: i += 1
</t>
<t tx="ekr.20070626112754.1539">save_ip = i
i = scan_start
while i &lt; start and g.is_ws_or_nl(s,i):
    i += 1
if i &lt; start:
    c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language pascal\n")
    headline = g.angleBrackets(self.methodName + " declarations ")
    # Append the headline to the parent's body.
    c.appendStringToBody(parent,headline + "\n")
    if self.treeType == "@file":
        body = s[scan_start:start]
    else:
        body = "@code\n\n" + s[scan_start:start]
    body = self.undentBody(body)
    self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i
</t>
<t tx="ekr.20070626112754.1540"># Append the headline to the parent's body.
if self.treeType == "@file":
    c.appendStringToBody(parent,"@others\n")
else:
    c.appendStringToBody(parent,
        g.angleBrackets(" " + self.methodName + " methods ") + "\n")
</t>
<t tx="ekr.20070626112754.1541"># Point i _after_ the last character of the function.
i = g.skip_ws(s,i)
if g.is_nl(s,i):
    i = g.skip_nl(s,i)
function_end = i
headline = name
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i
</t>
<t tx="ekr.20070626112754.1542"># 08-SEP-2002 DTHEIN: Added for PHP import support.
#
# PHP uses both # and // as line comments, and /* */ as block comments

def scanPHPText (self,s,parent):

    __pychecker__ = 'maxlines=500'

    """Creates a child of parent for each class and function definition seen."""

    &lt;&lt; define scanPHPText vars &gt;&gt;
    &lt;&lt; Append file if not pure PHP &gt;&gt;

    # 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
    c.appendStringToBody(parent,"@first ")
    c.appendStringToBody(parent,s[:startOfCode])
    scan_start = i = startOfCode
    while i &lt; endOfCode:
        # line = g.get_line(s,i) ; g.trace(line)
        ch = s[i]
        # These cases skip tokens.
        if ch == '/' or ch == '#':
            &lt;&lt; handle possible PHP comments &gt;&gt;
        elif ch == '&lt;':
            &lt;&lt; handle possible heredoc string &gt;&gt;
        elif ch == '"' or ch == '\'':
            i = g.skip_string(s,i)
        # These cases help determine where functions start.
        # FIXME: probably want to capture 'var's as class member data
        elif ch == 'f' or ch =='c':
            &lt;&lt; handle possible class or function &gt;&gt;
        elif class_start and (ch == '}'):
            &lt;&lt; handle end of class &gt;&gt;
        else: i += 1
    &lt;&lt; Append any unused text to the parent's body text &gt;&gt;
    # 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
    c.appendStringToBody(parent,"@last ")
    c.appendStringToBody(parent,s[endOfCode:])
</t>
<t tx="ekr.20070626112754.1543">c = self.c
scan_start = 0
class_start = 0
function_start = 0
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial &lt;?php
endOfCode = s.rfind("?&gt;") # this should be the line containing the last ?&gt;
</t>
<t tx="ekr.20070626112754.1544"># If the file does not begin with &lt;?php or end with ?&gt; then
# it is simply appended like a generic import would do.

s.strip() # Remove inadvertent whitespace.

if (
    not (
        s.startswith("&lt;?P") or
        s.startswith("&lt;?p") or
        s.startswith("&lt;?=") or
        s.startswith("&lt;?\n") or
        s.startswith("&lt;?\r") or
        s.startswith("&lt;? ") or
        s.startswith("&lt;?\t")
    ) or not (
        s.endswith("?&gt;\n") or
        s.endswith("?&gt;\r") or
        s.endswith("?&gt;\r\n")
    )
):
    g.es("File seems to be mixed HTML and PHP; importing as plain text file.")
    c.setBodyString(parent,"@ignore\n" + self.rootLine + s)
    return
</t>
<t tx="ekr.20070626112754.1545">if g.match(s,i,"//"):
    i = g.skip_line(s,i)
elif g.match(s,i,"#"):
    i = g.skip_line(s,i)
elif g.match(s,i,"/*"):
    i = g.skip_block_comment(s,i)
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1546">if g.match(s,i,"&lt;&lt;&lt;"):
    i = g.skip_heredoc_string(s,i)
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1547">@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if g.match(s,i,"function "):
    #we want to make the function a subnode of either the @file node or a class node
    # 1. get the function name
    # 2. make a reference in the parent
    # 3. create the child node, and dump the function in it.
    function_start = i
    m = phpFunctionName.match(s[i:])
    if (None == m): # function keyword without function name
        i += len("function ")
    else:
        headline = g.angleBrackets(" function " + m.group(1) + " ")
        # find the end of the function
        openingBrace = s.find('{',i)
        function_end = g.skip_php_braces(s,openingBrace)
        function_end = g.skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
        # Insert skipped text into parent's body.
        if class_start:
            class_body += s[scan_start:function_start]
        else:
            c.appendStringToBody(parent,s[scan_start:function_start])
        # Append the headline to the parent's body.
        if class_start:
            class_body += (headline + "\n")
        else:
            c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (function_start &gt; 0) and (s[function_start - 1] in [" ", "\t"]):
            function_start -= 1
        # Get the body and undent it
        function_body = s[function_start:function_end]
        function_body = self.undentBody(function_body)
        if self.treeType != "@file":
            function_body = "@code\n\n" + function_body
        # Create the new node
        if class_start:
            self.createHeadline(class_node,function_body,headline)
        else:
            self.createHeadline(parent,function_body,headline)
        i = function_end
        scan_start = i
        function_end = 0
        function_start = 0 #done with this function
        function_body = ""

elif g.match(s,i,"class "):
    # we want to make the class a subnode of the @file node
    # 1. get the class name
    # 2. make a reference in the parent
    # 3. create the child node and dump the function in it
    class_start = i
    class_body = ""
    m = phpClassName.match(s[i:])
    if (None == m): # class keyword without class name
        i += len("class ")
    else:
        # Insert skipped text into parent's body.
        c.appendStringToBody(parent,s[scan_start:class_start])
        # create the headline name
        headline = g.angleBrackets(" class " + m.group(1) + " ")
        # find the place to start looking for methods (functions)
        openingBrace = s.find('{',i)
        # find the end of the class
        class_end = g.skip_php_braces(s,openingBrace)
        class_end = g.skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
        # Append the headline to the parent's body.
        c.appendStringToBody(parent,headline + "\n")
        # Backup to capture leading whitespace (for undent purposes)
        while (class_start &gt; 0) and (s[class_start - 1] in [" ", "\t"]):
            class_start -= 1
        scan_start = class_start
        # Create the new node
        class_node = self.createHeadline(parent,"",headline)
        i = openingBrace

else:
    i += 1
</t>
<t tx="ekr.20070626112754.1548"># Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
    class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
c.appendStringToBody(class_node,class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
</t>
<t tx="ekr.20070626112754.1549">c.appendStringToBody(parent,s[scan_start:endOfCode])
</t>
<t tx="ekr.20070626112754.1550"></t>
<t tx="ekr.20070626112754.1551">def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    v = parent.insertAsLastChild()
    v.initHeadString(headline,self.encoding)
    # Set the body.
    if len(body) &gt; 0:
        self.c.setBodyString(v,body,self.encoding)
    return v
</t>
<t tx="ekr.20070626112754.1552">def error (self,s): g.es(s)
</t>
<t tx="ekr.20070626112754.1553">def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i &lt; len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
</t>
<t tx="ekr.20070626112754.1554"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):

    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
</t>
<t tx="ekr.20070626112754.1555">def massageBody (self,s,methodKind):

    # g.trace(s)
    # g.trace(g.get_line(s,0))
    c = self.c
    if self.treeType == "@file":
        if self.fileType == ".py": # 7/31/02: was "py"
            return self.undentBody(s)
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) &gt; 0:
                return comment + "\n@c" + newLine + newBody
            else:
                return newBody
    else:
        # Inserts &lt; &lt; self.methodName methodKind &gt; &gt; =
        cweb = self.fileType == "c" and not c.use_noweb_flag
        lb = g.choose(cweb,"@&lt;","&lt;&lt;")
        rb = g.choose(cweb,"@&gt;=","&gt;&gt;=")
        intro = lb + " " + self.methodName + " " + methodKind + " " + rb
        if self.fileType == ".py": # 7/31/02: was "py"
            newBody = self.undentBody(s)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            return intro + newLine + newBody
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) &gt; 0:
                return comment + "\n" + intro + newLine + newBody
            else:
                return intro + newLine + newBody
</t>
<t tx="ekr.20070626112754.1556">def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.

    Also removes leading and trailing whitespace."""

    # g.trace(g.get_line(s,0))
    s = string.strip(s)
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"\r"," ")
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
</t>
<t tx="ekr.20070626112754.1557">def massageWebBody (self,s):

    theType = self.webType
    lb = g.choose(theType=="cweb","@&lt;","&lt;&lt;")
    rb = g.choose(theType=="cweb","@&gt;","&gt;&gt;")
    &lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;
    &lt;&lt; Replace abbreviated names with full names &gt;&gt;
    s = string.rstrip(s)
    return s
</t>
<t tx="ekr.20070626112754.1558">i = 0
while i &lt; len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isDocStart(s,i):
        # Scan to end of the doc part.
        if g.match(s,i,"@ %def"):
            # Don't remove the newline following %def
            i = g.skip_line(s,i) ; start = end = i
        else:
            start = end = i ; i += 2
        while i &lt; len(s):
            progress2 = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                end = i ; break
            elif theType == "cweb": i += 1
            else: i = g.skip_to_end_of_line(s,i)
            assert (i &gt; progress2)
        # Remove newlines from start to end.
        doc = s[start:end]
        doc = string.replace(doc,"\n"," ")
        doc = string.replace(doc,"\r","")
        doc = string.strip(doc)
        if doc and len(doc) &gt; 0:
            if doc == "@":
                doc = g.choose(self.webType=="cweb", "@ ","@\n")
            else:
                doc += "\n\n"
            # g.trace("new doc:",doc)
            s = s[:start] + doc + s[end:]
            i = start + len(doc)
    else: i = g.skip_line(s,i)
    assert (i &gt; progress)
</t>
<t tx="ekr.20070626112754.1559">i = 0
while i &lt; len(s):
    progress = i
    # g.trace(g.get_line(s,i))
    if g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k &gt; -1:
            name = s[j:k]
            name2 = self.cstLookup(name)
            if name != name2:
                # Replace name by name2 in s.
                # g.trace("replacing %s by %s" % (name,name2))
                s = s[:j] + name2 + s[k:]
                i = j + len(name2)
    i = g.skip_line(s,i)
    assert (i &gt; progress)
</t>
<t tx="ekr.20070626112754.1560">def setEncoding (self):

    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
</t>
<t tx="ekr.20070626112754.1561">def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        &lt;&lt; scan for C-style comments &gt;&gt;
    elif self.fileType == ".lua":
        &lt;&lt; scan for Lua comments &gt;&gt;
    elif self.fileType == ".pas":
        &lt;&lt; scan for Pascal comments &gt;&gt;
    elif self.fileType == ".py":
        &lt;&lt; scan for Python comments &gt;&gt;
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
</t>
<t tx="ekr.20070626112754.1562">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.1563">while i &lt; len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.1564">while i &lt; len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
</t>
<t tx="ekr.20070626112754.1565">while i &lt; len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
</t>
<t tx="ekr.20070626112754.1566"># We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i &lt; len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
</t>
<t tx="ekr.20070626112754.1567">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i &gt;= len(s): return len(s)
    if i &lt;= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
</t>
<t tx="ekr.20070626112754.1568"></t>
<t tx="ekr.20070626112754.1569">def makeAllBindings (self):

    k = self ; c = k.c

    # g.trace(c.fileName(),g.callers())

    k.bindingsDict = {}
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20070626112754.1570">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4320971
By: rickardlindberg

------

http://sourceforge.net/forum/message.php?msg_id=4325739


I created a cmd file like this:

script.cmd:
@echo off
echo Hello World

Then I wrote some python code to execute it:

import subprocess
output = subprocess.Popen(["script.cmd"],
stdout=subprocess.PIPE).communicate()[0]
print output

When I saved this script to test.py and ran the file, I got the correct output;
when I entered the script in the python prompt, I got the correct output; but
when I pasted the code in a leo node and executed it, I got the error message
described in my first post.

---------

exception executing script
    TypeError: an integer is required
    --------------------
      line 634:                                    GetCurrentProcess(), 0, 1,
    * line 635:                                    DUPLICATE_SAME_ACCESS)
      line 636: 
      line 637: 

If I remove the `stdout=subprocess.PIPE` part, it works fine, but then I cannot
get the output of the command.</t>
<t tx="ekr.20070626112754.1571">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4309448

Still to do: update urls for tigris.</t>
<t tx="ekr.20070626112754.1572">http://sourceforge.net/forum/message.php?msg_id=4301021
</t>
<t tx="ekr.20070626112754.1573">def openFileForWritingHelper (self,fileName):

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
</t>
<t tx="ekr.20070626112754.1574">@nocolor

- Select a node by clicking on it.
- The node is selected, but shift-arrow does not work.

However, clicking the canvas does work.

The fix was to give the canvas, not the headline focus when clicking on a headline.
This results in canvas bindings, not text bindings, having priority.
This is not a kludge: the text widget isn't active, so text bindings should not be in effect.

@color</t>
<t tx="ekr.20070626112754.1575"></t>
<t tx="ekr.20070626112754.1576">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4336648
By: terry_n_brown

Just a nit, but I notice that the default empty file that you get when first
running Leo is still marked 'changed' (current CVS).  I.e. it asks for confirmation
on closing, which it didn't need previously.</t>
<t tx="ekr.20070626112754.1577">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4340244
By: vransmayr

Traceback (most recent call last):

  File "C:\CVS-Reps\leo\src\leoGlobals.py", line 2545, in doHook
    return f(tag,keywords)

  File "C:\CVS-Reps\leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "C:\CVS-Reps\leo\src\leoPlugins.py", line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "C:\CVS-Reps\leo\src\leoPlugins.py", line 49, in callTagHandler
    result = handler(tag,keywords)

  File "C:\CVS-Reps\leo\plugins\maximizeNewWindows.py", line 29, in
maximize_window
    c.frame.top.state("zoomed")

AttributeError: nullFrame instance has no attribute 'top'</t>
<t tx="ekr.20070626112754.1578"></t>
<t tx="ekr.20070626112754.1579">@nocolor

https://sourceforge.net/forum/message.php?msg_id=4339681
By: ktenney

Try this;

- create new chapter, default node is 'Chapter n node 1'
- insert a node
- delete node 'Chapter n node 1'
- tab to another chapter and return to this chapter

Now there is a node '@chapters'
with children for each chapter
'@chapter &lt;chapter name&gt;'
</t>
<t tx="ekr.20070626112754.1580">def deleteOutline (self,event=None,op_name="Delete Node"):

    """Deletes the selected outline."""

    c = self ; cc = c.chapterController ; u = c.undoer
    p = c.currentPosition()
    if not p: return

    if p.hasVisBack(c): newNode = p.visBack(c)
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
    finally:
        c.endUpdate(False)

    if cc: # Special cases for @chapter and @chapters nodes.
        chapter = '@chapter ' ; chapters = '@chapters ' 
        h = p.headString()
        if h.startswith(chapters):
            if p.hasChildren():
               return cc.error('Can not delete @chapters node with children.')
        elif h.startswith(chapter):
            name = h[len(chapter):].strip()
            if name:
                return cc.removeChapterByName(name)

    c.beginUpdate()
    try:
        undoData = u.beforeDeleteNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.doDelete()
        c.selectPosition(newNode)
        c.setChanged(True)
        u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
</t>
<t tx="ekr.20070626112754.1581">def positionExists(self,p,root=None):

    """Return True if a position exists in c's tree"""

    c = self ; p = p.copy()

    # This code must be fast.
    if not root:
        root = c.rootPosition()

    while p:
        # g.trace(p.headString())
        if p.equal(root):
            # g.trace('True')
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()

    return False
</t>
<t tx="ekr.20070626112754.1582">def setRootPosition(self,p):

    """Set the root positioin."""

    c = self

    # g.trace(p and p.headString(),g.callers())

    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None</t>
<t tx="ekr.20070626112754.1583"></t>
<t tx="ekr.20070626112754.1584">def cutOutline (self,event=None):

    '''Delete the selected outline and send it to the clipboard.'''

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
</t>
<t tx="ekr.20070626112754.1585">def copyOutline (self,event=None):

    '''Copy the selected outline to the clipboard.'''

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
</t>
<t tx="ekr.20070626112754.1586"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
        undoData = u.beforeInsertNode(current,
            pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
        c.recolor()
</t>
<t tx="ekr.20070626112754.1587">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
</t>
<t tx="ekr.20070626112754.1588"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
</t>
<t tx="ekr.20070626112754.1589">def pasteOutlineRetainingClones (self,event=None):

    '''Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.'''

    c = self

    return c.pasteOutline(reassignIndices=False)
</t>
<t tx="ekr.20070626112754.1590">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
</t>
<t tx="ekr.20070626112754.1591">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4337221
By: ktenney

This is reproducible for me with current cvs;

- From a Leo file, click File-&gt;New
- paste a node into into the new file
- delete the default new file node "New Headline",
  leaving the pasted node
- click the 'trash' tab
- click the main tab

the pasted node is gone, the "New Headline" node is visible .


What I did:

tree.select was doing nothing if c.positionExists(p) was false.
But this is wrong: we may be in the process of changing roots.</t>
<t tx="ekr.20070626112754.1592"># Added c.suppressHeadChanged and related logic.U</t>
<t tx="ekr.20070626112754.1593">def setChanged (self,changedFlag):

    c = self
    if not c.frame: return

    # if changedFlag: g.trace('***',g.callers())

    # Clear all dirty bits _before_ setting the caption.
    # Clear all dirty bits except orphaned @file nodes
    if not changedFlag:
        # g.trace("clearing all dirty bits")
        for p in c.allNodes_iter():
            if p.isDirty() and not (p.isAtFileNode() or p.isAtNorefFileNode()):
                p.clearDirty()

    # Update all derived changed markers.
    c.changed = changedFlag
    s = c.frame.getTitle()
    if len(s) &gt; 2 and not c.loading: # don't update while loading.
        if changedFlag:
            if s [0] != '*': c.frame.setTitle("* " + s)
        else:
            if s[0:2]=="* ": c.frame.setTitle(s[2:])
</t>
<t tx="ekr.20070626112754.1594">@nocolor

Selecting a node found the first node that matches, rather than the correct position.

Example:

A'
- B
A'
- B

A' are clones.

Select the second B.
Switch chapters, then back again.
Now the first B is selected.

@color</t>
<t tx="ekr.20070626112754.1595">def setPositionsFromStacks (self):

    c = self.c

    current = self.convertStackToPosition(self.currentVnodeStack)

    if current:
        # g.trace('using convertStackToPosition',current)
        c.setCurrentPosition(current)
    else:
        # g.trace(self.currentVnodeStack)
        c.setCurrentPosition(c.rootPosition())

    # At present this is useless: the drawing code doesn't set the top position properly.
    if 0:
        top = self.convertStackToPosition(self.topVnodeStack)
        if top:
            c.setTopPosition(top)</t>
<t tx="ekr.20070626112754.1596">def selectChapterByName (self,name):

    cc = self ; c = cc.c ; chapter = cc.chaptersDict.get(name)

    if chapter:
        if chapter != cc.selectedChapter:
            if cc.selectedChapter:
                cc.selectedChapter.unselect()
            chapter.select()
            c.setCurrentPosition(chapter.p)
            cc.selectedChapter = chapter
    else:
        cc.error('cc.selectShapter: no such chapter: %s' % name)
</t>
<t tx="ekr.20070626112754.1597">def findPositionInChapter (self,p1,strict=False):

    '''Return a valid position p such that p.v == v.'''

    # Do nothing if the present position is in the proper chapter.
    c = self.c ; name = self.name 

    root = g.choose(self.name=='main',c.rootPosition(),self.root)
    # g.trace('p1',p1)
    if p1 and c.positionExists(p1,root=root):
        # g.trace('using existing position',p)
        return p1

    if name == 'main':
        for p in self.c.allNodes_iter():
            if p.v == p1.v:
                # g.trace('*** found in main chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = c.rootPosition()
    else:
        for p in self.root.self_and_subtree_iter():
            # g.trace('testing',p,p1)
            if p.v == p1.v:
                # g.trace('*** found in chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = self.root.copy()

    if 0:
        self.error('***** chapter: %s findPositionInChapter: lost %s' % (
            self.name,p1.v.t.headString))
        g.trace(g.callers())

    return self.p.copy()
</t>
<t tx="ekr.20070626112754.1598">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4341644
Viktor Ransmayr

When you save an outline, the focus switches from the body pane
to the outline pane.

@color</t>
<t tx="ekr.20070626112754.1599"></t>
<t tx="ekr.20070626112754.1600">def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')

def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')

def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=undoType)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    sel = g.choose(way=='low',s[i:j].lower(),s[i:j].upper())
    s2 = s[:i] + sel + s[j:]
    # g.trace('sel',repr(sel),'s2',repr(s2))
    changed = s2 != s
    if changed:
        w.setAllText(s2)
        w.setSelectionRange(i,j,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1601"></t>
<t tx="ekr.20070626112754.1602">def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
</t>
<t tx="ekr.20070626112754.1603"># New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
</t>
<t tx="ekr.20070626112754.1604"># New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    c = self.c ; b = self.undoData ; k = self.k

    # g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20070626112754.1605"></t>
<t tx="ekr.20070626112754.1606">def capitalizeWord (self,event):
    '''Capitalize the word at the cursor.'''
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    '''Convert all characters of the word at the cursor to lower case.'''
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    '''Convert all characters of the word at the cursor to UPPER CASE.'''
    self.capitalizeHelper(event,'up','upcase-word')
</t>
<t tx="ekr.20070626112754.1607">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    self.beginCommand(undoType='change-previous-word')
    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
         self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20070626112754.1608">def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    word = s[i:j]
    # g.trace('word',repr(word))
    if not word.strip(): return

    self.beginCommand(undoType=undoType)

    if   which == 'cap':  word2 = word.capitalize()
    elif which == 'low':  word2 = word.lower()
    elif which == 'up':   word2 = word.upper()
    else: g.trace('can not happen: which = %s' %s (which))

    changed = word != word2
    # g.trace('changed',changed,'word2',repr(word2))

    if changed:
        w.delete(i,j)
        w.insert(i,word2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
</t>
<t tx="ekr.20070626112754.1609">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4353416
By: mstarzyk

When you hoist a node, then while in the tree panel - you can navigate to nodes
outside of the hosted subtree.

@color</t>
<t tx="ekr.20070626112754.1610">def lastVisible(self):

    """Move to the last visible node of the present chapter or hoist."""

    c = self ; p = c.currentPosition()

    while 1:
        next = p.visNext(c)
        # g.trace('next',next)
        if next and next.isVisible(c):
            p = next
        else: break
    return p
</t>
<t tx="ekr.20070626112754.1611">def visLimit (self):

    '''Return the topmost visible node.
    This is affected by chapters and hoists.'''

    c = self ; cc = c.chapterController

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p
        limitIsVisible = not cc or not p.headString().startswith('@chapter')
        return p,limitIsVisible
    else:
        return None,None
</t>
<t tx="ekr.20070626112754.1612">def canMoveOutlineDown (self):

    c = self ; current = c.currentPosition()

    return current and current.visNext(c)
</t>
<t tx="ekr.20070626112754.1613">def canMoveOutlineUp (self):

    c = self ; current = c.currentPosition()

    visBack = current and current.visBack(c)

    if not visBack:
        return False
    elif visBack.visBack(c):
        return True
    elif c.hoistStack:
        limit,limitIsVisible = c.visLimit()
        if limitIsVisible: # A hoist
            return current != limit
        else: # A chapter.
            return current != limit.firstChild()
    else:
        return current != c.rootPosition()
</t>
<t tx="ekr.20070626112754.1614">def canSelectThreadBack (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadBack()

def canSelectThreadNext (self):
    c = self ; p = c.currentPosition()
    return p.hasThreadNext()

def canSelectVisBack (self):
    c = self ; p = c.currentPosition()
    return p.visBack(c)

def canSelectVisNext (self):
    c = self ; p = c.currentPosition()
    return p.visNext(c)
</t>
<t tx="ekr.20070626112754.1615">def isVisible (self,c):

    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self ; cc = c.chapterController ; trace = False
    limit,limitIsVisible = c.visLimit()
    limit_v = limit and limit.v or None
    if p.v == limit_v:
        if trace: g.trace('*** at limit','limitIsVisible',limitIsVisible,p.v.headString())
        return limitIsVisible

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if v == limit_v:  # We are at a descendant of limit.
            if trace: g.trace('*** descendant of limit',
                'limitIsVisible',limitIsVisible,
                'limit.isExpanded()',limit.isExpanded(),'v',v)
            if limitIsVisible:
                return limit.isExpanded()
            else: # Ignore the expansion state of @chapter nodes.
                return True
        if not v.isExpanded():
            if trace: g.trace('*** non-limit parent is not expanded',v)
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True
</t>
<t tx="ekr.20070626112754.1616">def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
</t>
<t tx="ekr.20070626112754.1617">def moveToThreadNext (self):

    """Move a position to the next a position in threading order."""

    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.

    return p
</t>
<t tx="ekr.20070626112754.1618">def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            if limit == p:
                if trace: g.trace('at limit',p)
                return True,g.choose(limitIsVisible and p.isVisible(c),p,None)
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        back = p.back()
        if back and (not back.hasChildren() or not back.isExpanded()):
            p.moveToBack()
        else:
            p.moveToThreadBack()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20070626112754.1619">def moveToVisNext (self,c):

    """Move a position to the position of the next visible node."""

    p = self ; limit,limitIsVisible = c.visLimit() ; trace = False

    def checkLimit (p):
        '''Return done, return-val'''
        if limit:
            # Unlike moveToVisBack, being at the limit does not terminate.
            if limit == p:
                return False, None
            elif limit.isAncestorOf(p):
                return False,None
            else:
                if trace: g.trace('outside limit tree')
                return True,None
        else:
            return False,None

    while p:
        # Short-circuit if possible.
        if p.hasNext() and (not p.hasChildren() or not p.isExpanded()):
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if trace: g.trace('*p',p.headString())
            done,val = checkLimit(p)
            if done: return val
            if p.isVisible(c):
                return p.copy()
    else:
        # assert not p.
        return p</t>
<t tx="ekr.20070626112754.1620">@
Also, tree.endDrag and tree.onHeadChanged now redraw the screen only if the drag
actually happened or the headline actually changed.
</t>
<t tx="ekr.20070626112754.1621">def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers()) # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
</t>
<t tx="ekr.20070626112754.1622"></t>
<t tx="ekr.20070626112754.1623">http://sourceforge.net/forum/message.php?msg_id=4356197</t>
<t tx="ekr.20070626112754.1624">def canDemote (self):

    c = self
    return c.currentPosition().hasNext()
</t>
<t tx="ekr.20070626112754.1625">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
</t>
<t tx="ekr.20070626112754.1626"></t>
<t tx="ekr.20070626112754.1627"></t>
<t tx="ekr.20070626112754.1628">def norefWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atNorefFileNodeName()
        at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            return
        &lt;&lt; write root's tree &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)

rawWrite = norefWrite
</t>
<t tx="ekr.20070626112754.1629">&lt;&lt; put all @first lines in root &gt;&gt;
at.putOpenLeoSentinel("@+leo-ver=4")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

for p in root.self_and_subtree_iter():
    &lt;&lt; Write p's node &gt;&gt;

at.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;
</t>
<t tx="ekr.20070626112754.1630">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)
</t>
<t tx="ekr.20070626112754.1631">s2 = c.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)&gt; 0:
            at.putSentinel("@comment " + line)
</t>
<t tx="ekr.20070626112754.1632">at.putOpenNodeSentinel(p)

s = p.bodyString()

if self.write_strips_blank_lines:
    s = self.cleanLines(p,s)

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True)
    at.outputStringWithLineEndings(s)

# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20070626112754.1633">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()
</t>
<t tx="ekr.20070626112754.1634">def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString): return
        for p in root.self_and_subtree_iter():
            &lt;&lt; Write p's headline if it starts with @@ &gt;&gt;
            &lt;&lt; Write p's body &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)

silentWrite = asisWrite # Compatibility with old scripts.
</t>
<t tx="ekr.20070626112754.1635">s = p.headString()

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) &gt; 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
</t>
<t tx="ekr.20070626112754.1636">s = p.bodyString()

if self.write_strips_blank_lines:
    s = self.cleanLines(p,s)

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
</t>
<t tx="ekr.20070626112754.1637">def cleanLines (self,p,s):

    '''Return a copy of s, with all trailing whitespace removed.
    If a change was made, update p's body text and set c dirty.'''

    c = self.c ; cleanLines = [] ; changed = False
    lines = g.splitLines(s)
    for line in lines:
        if line.strip():
            cleanLines.append(line)
        elif line.endswith('\n'):
            cleanLines.append('\n')
            if line != '\n': changed = True
        else:
            cleanLines.append('')
            if line != '': changed = True
    s = g.joinLines(cleanLines)

    if changed and not g.app.unitTesting:
        p.setTnodeText(s)
        c.setBodyString(p,s)
        c.setChanged(True)

    return s</t>
<t tx="ekr.20070626112754.1638"></t>
<t tx="ekr.20070626112754.1639"># Run all @test and @suite nodes in this .leo file.

import leoTest
leoTest.doTests(c,all=True,verbosity=1)</t>
<t tx="ekr.20070626112754.1640">import unittest

class testRoutineTestCase(unittest.TestCase):
    @others

p = c.currentPosition() ; p1 = p.copy()

try:
    g.app.unitTesting = True
    g.app.unitTestDict["fail"] = False
    changed = c.isChanged()
    suite = unittest.makeSuite(unittest.TestCase)
    for p in c.allNodes_iter():
        h = p.headString()
        if h.startswith('test_') and p.bodyString().strip():
            testCase = testRoutineTestCase(c,g,p)
            suite.addTest(testCase)
    # Verbosity: 1: print just dots.
    unittest.TextTestRunner(verbosity=1).run(suite)
finally:
    c.setChanged(changed) # Restore changed state.
    c.selectPosition(p1)
    g.app.unitTesting = False
</t>
<t tx="ekr.20070626112754.1641">def __init__ (self,c,g,p,verbose=False):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.g = g
    self.p = p.copy()
    self.verbose = verbose

    self.name = p.headString().strip()
    self.code = p.bodyString()
</t>
<t tx="ekr.20070626112754.1642">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20070626112754.1643">def runTest (self):

    c = self.c ; g = self.g ; p = self.p ; name = self.name

    d = {'c':c,'g':g,'p':p}

    script = g.getScript(c,p).strip()
    script = self.removeLeadingWs(script)

    isMethod = self.isMethod(script)

    # Create a call to the function.
    if isMethod:
        s = '%s\n%s(self=None)\n' % (script,name)
    else:
        s = '%s\n%s()\n' % (script,name)

    if self.verbose:
        g.trace('executing...\n\n%s' % s)

    exec s in d # Execute s in a environment containing c, g and p.
</t>
<t tx="ekr.20070626112754.1644">def isMethod (self,s):

    '''Return True if the test_ method's first arg is self.'''

    if s.find('self') == -1:
        return False

    name = self.name
    i = s.find('def %s' % name)
    if i == -1:
        g.trace('%s not defined' % name)
    else:
        i += (4 + len(name))
        i = g.skip_ws(s,i)
        if g.match(s,i,'('):
            return g.match_word(s,i+1,'self')
        else:
            g.trace('%s not defined 2' % name)
            g.trace(repr(s[i:i+10]))</t>
<t tx="ekr.20070626112754.1645">def shortDescription (self):

    return 'test function',repr(self.name)</t>
<t tx="ekr.20070626112754.1646">def removeLeadingWs (self,code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            print 'removeLeadingWs:underindented line:%s' % repr(line)
            result.append(line)

    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result</t>
<t tx="ekr.20070626112754.1647">(done) create-chapter
(done) show-chapters
(done) hide-chapters
(done) Allow permanent chapter renames.
(done) Eliminate error messages.</t>
<t tx="ekr.20070626112754.1648">def getPublicCommands (self):

    c = self.c ; cc = c.chapterController

    # g.trace('cc',cc,g.callers())

    if cc:
        return {
            'clone-node-to-chapter':    cc.cloneNodeToChapter,
            'convert-node-to-chapter':  cc.convertNodeToChapter,
            'copy-node-to-chapter':     cc.copyNodeToChapter,
            'create-chapter':           cc.createChapter,
            'create-chapter-from-node': cc.createChapterFromNode,
            'move-node-to-chapter':     cc.moveNodeToChapter,
            'remove-chapter':           cc.removeChapter,
            'rename-chapter':           cc.renameChapter,
            'select-chapter':           cc.selectChapter,
        }
    else:
        return {}
</t>
<t tx="ekr.20070626112754.1649">@nocolor

Made installing aspell easier.

http://sourceforge.net/forum/message.php?msg_id=4318634
By: billpage

What I did:

- Use ctypes.util.find_library('aspell') to find aspell lib.
- Return in several places if currentWord is None.
  This fixes crashers if no suggestions are found.

@color</t>
<t tx="ekr.20070626112754.1650">@others
</t>
<t tx="ekr.20070626112754.1651">class spellCommandsClass (baseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20070626112754.1652">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20070626112754.1653">def getPublicCommands (self):

    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20070626112754.1654">class AspellClass:

    """A wrapper class for Aspell spell checker"""

    @others
</t>
<t tx="ekr.20070626112754.1655">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
</t>
<t tx="ekr.20070626112754.1656">def suggestions(self,word):

    "return list of words found"

    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList</t>
<t tx="ekr.20070626112754.1657">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.

    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False
</t>
<t tx="ekr.20070626112754.1658">Added globalDynamicAbbrevs setting.</t>
<t tx="ekr.20070626112754.1659">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4255709

I have some questions about the usage of dynamic abbreviations in Leo. As an
Emacs user, I know how they work in Emacs: they expand partially entered words
using a dictionary of words from the currently open buffers.

- I found a thread in the SF Forums titled "dynamic-abbreviations increases
its scope", 07-20-2005. The functionality described in this thread seems to
be the functionality I am familiar with as an Emacs uses. Is this the functionality
accessed through the commands dabbrev-completion and dabbrev-expands ?
- What is the difference between dabbrev-completion and dabbrev-expands ? 
- I often get a TK exception when I use dabbrev-completion "TypeError: reduce()
of empty sequence with no initial value". What am I doing wrong ?

Can somebody answer these questions for me or point me to documentation that
describes Leo's support for dynamic abbreviations?

-----------
http://sourceforge.net/forum/message.php?msg_id=4260706

command completion is shell or readline functionality to automatically finish
what you've typed so far, thus "completing" the type-in of the command for you.

abbreviation expansion is actually going to put a bunch of characters in your
buffer where you only had to enter the abbreviation for it.

---------
http://sourceforge.net/forum/message.php?msg_id=4263851

Already solved a part of it. The exception is raised when the characters entered
cannot be completed to a previously typed word. In LeoPy.leo, Code--&gt;Core
classes...--&gt;@thin leoEditCommands.py--&gt;editCommandsClass--&gt;dynamic
abbreviation...--&gt;dynamicExpansion2, no check is made that the call to
self.getDynamicList does not retrieve an empty list. I've added this check (locally)
and at least the exception is not raised anymore. Apparently I am the only one
using this functionality, otherwise taht person surely would have also encountered
the problem.

Unfortunately, when looking at the code it seems that only those words are completed
in the current node :( Is there another mechanism for completion (that also
considers other, e.g. previously viewed, nodes) or am I overlooking something ?</t>
<t tx="ekr.20070626112754.1660">@nocolor

The abbrev facility described above operates automatically as you insert text, but all abbrevs must be defined explicitly.

By contrast, dynamic abbrevs allow the meanings of abbrevs to be determined automatically from the contents of the buffer, but dynamic abbrev expansion happens only when you request it explicitly.

M-/
    Expand the word in the buffer before point as a dynamic abbrev, by searching in the buffer for words starting with that abbreviation (dabbrev-expand).
    (EKR: Inserts first found matching work.  Repeated searches finds previous matches)

C-M-/
    Complete the word before point as a dynamic abbrev (dabbrev-completion).
    (EKR: inserts commen prefix of all abbreviations found)

 For example, if the buffer contains `does this follow ' and you type f o M-/, the effect is to insert `follow' because that is the last word in the buffer that starts with `fo'. A numeric argument to M-/ says to take the second, third, etc. distinct expansion found looking backward from point. Repeating M-/ searches for an alternative expansion by looking farther back. After scanning all the text before point, it searches the text after point. The variable dabbrev-limit, if non-nil, specifies how far in the buffer to search for an expansion.

After scanning the current buffer, M-/ normally searches other buffers, unless you have set dabbrev-check-all-buffers to nil.

For finer control over which buffers to scan, customize the variable dabbrev-ignored-buffer-regexps. Its value is a list of regular expressions. If a buffer's name matches any of these regular expressions, dynamic abbrev expansion skips that buffer.

A negative argument to M-/, as in C-u - M-/, says to search first for expansions after point, and second for expansions before point. If you repeat the M-/ to look for another expansion, do not specify an argument. This tries all the expansions after point and then the expansions before point.

After you have expanded a dynamic abbrev, you can copy additional words that follow the expansion in its original context. Simply type SPC M-/ for each word you want to copy. The spacing and punctuation between words is copied along with the words.

The command C-M-/ (dabbrev-completion) performs completion of a dynamic abbreviation. Instead of trying the possible expansions one by one, it finds all of them, then inserts the text that they have in common. If they have nothing in common, C-M-/ displays a list of completions, from which you can select a choice in the usual manner. See section E.3 Completion. </t>
<t tx="ekr.20070626112754.1661"></t>
<t tx="ekr.20070626112754.1662">def getDynamicList (self,w,txt,rlist):

    items = []
    if self.globalDynamicAbbrevs:
        for p in self.c.allNodes_iter():
            s = p.bodyString()
            if s:
                items.extend(self.dynaregex.findall(s))
    else:
        # Make a big list of what we are considering a 'word'
        s = w.getAllText()
        items.append(self.dynaregex.findall(s))

    # g.trace('txt',repr(txt),'len(items)',len(items))

    if items:
        for word in items:
             if not word.startswith(txt) or word == txt:
                 continue
                # dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)

    # g.trace('rlist',rlist)
</t>
<t tx="ekr.20070626112754.1663"># Also made all code gui-independent.</t>
<t tx="ekr.20070626112754.1664"></t>
<t tx="ekr.20070626112754.1665">def dehoist (self,event=None):

    '''Undo a previous hoist of an outline.'''

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        c.beginUpdate()
        try:
            if bunch.expanded: p.expand()
            else:              p.contract()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')
        g.doHook('hoist-changed',c=c)

def hoist (self,event=None):

    '''Make only the selected outline visible.'''

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        c.beginUpdate()
        try:
            p.expand()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
        g.doHook('hoist-changed',c=c)
</t>
<t tx="ekr.20070626112754.1666">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4134565

The following are now enabled by default:

# Plugin_manager.py needs plugins_menu.py
plugins_menu.py
plugin_manager.py
open_with.py
mod_scripting.py
rst3.py
UNL.py

# Enabled by default in Leo 4.4.3. (order is important)
nav_buttons.py
hoist.py
image.py
leo_to_html.py

I left out cleo because it has been reported not to be fully functional with Leo 4.4.3.</t>
<t tx="ekr.20070626112754.1667"></t>
<t tx="ekr.20070626112754.1668"></t>
<t tx="ekr.20070626112754.1669">@nocolor

- Standardized icon-area button fonts.

- Deleting/cutting an @chapter node 'by hand' equivalent to deleting a chapter.

- Added hoist-changed hook and use the hook in the hoist plugin.

- Added support for chapters to hoist/dehoist commands and hoist plugin.
    - Do not allow de-hoist of an @chapter node.
    - Created c.hoistLevel that subtracts one from len(c.hoistStack) when in a chapter.

- Don't expand parent of @chapers node when switching to main chapter.

- Don't show @chapter node in hoist.

- fix 'No inverse for &lt;chapter command&gt;' messages.</t>
<t tx="ekr.20070626112754.1670"></t>
<t tx="ekr.20070626112754.1671"></t>
<t tx="ekr.20070626112754.1672">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
</t>
<t tx="ekr.20070626112754.1673">def contract(self):

    self.statusBits &amp;= ~ self.expandedBit

    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit

    # g.trace(self,g.callers())

    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
</t>
<t tx="ekr.20070626112754.1674">def expandAllAncestors (self,p):

    '''Expand all ancestors without redrawing.

    Return a flag telling whether a redraw is needed.'''

    c = self.c ; cc = c.chapterController ; redraw_flag = False
    # inChapter = cc and cc.inChapter()

    c.beginUpdate()
    try:
        for p in p.parents_iter():
            # g.trace('testing',p)
            if cc and p.headString().startswith('@chapter'):
                break
            if not p.isExpanded():
                # g.trace('inChapter',inChapter,'p',p,g.callers())
                p.expand()
                redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag
</t>
<t tx="ekr.20070626112754.1675"></t>
<t tx="ekr.20070626112754.1676"></t>
<t tx="ekr.20070626112754.1677">def insertHeadline (self,event=None,op_name="Insert Node"):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20070626112754.1678">def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone()
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
</t>
<t tx="ekr.20070626112754.1679"># Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self

    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
</t>
<t tx="ekr.20070626112754.1680">def createChild (self,parent,s):

    '''Create a child node of parent without changing the undo stack.
    set the headString of the new node to s.'''

    c = self.c
    p = parent.insertAsLastChild()
    p.initHeadString(s)
    c.setChanged(True)

    return p
</t>
<t tx="ekr.20070626112754.1681"></t>
<t tx="ekr.20070626112754.1682">@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):

    '''Return the root position of the outline containing p.'''

    c = self ; p = p.copy()

    while p and p.hasParent():
        p.moveToParent()
        # g.trace(p.headString(),g.callers())

    while p and p.hasBack():
        p.moveToBack()

    # g.trace(p and p.headString())

    return p</t>
<t tx="ekr.20070626112754.1683"></t>
<t tx="ekr.20070626112754.1684">def select (self,w=None,selectEditor=True):

    '''Restore chapter information and redraw the tree when a chapter is selected.'''

    if self.selectLockout: return

    try:
        self.selectLockout = True
        self.chapterSelectHelper(w,selectEditor)
        if self.cc.tt:
            self.cc.tt.setTabLabel(self.name)
    finally:
        self.selectLockout = False
</t>
<t tx="ekr.20070626112754.1685">def findEditorInChapter (self,p):

    '''return w, an editor displaying position p.'''

    chapter = self ; c = self.c

    w = c.frame.body.findEditorForChapter(chapter,p)
    w.leo_chapter = chapter
    w.leo_p = p and p.copy()
    return w</t>
<t tx="ekr.20070626112754.1686">def positionIsInChapter (self,p):

    p2 = self.findPositionInChapter (p,strict=True)

    # g.trace(self.name,'returns',p2)
    return p2</t>
<t tx="ekr.20070626112754.1687">def rename (self,newName):

    p = self.root
    s = '@chapter ' + newName
    p.setHeadString(s)
</t>
<t tx="ekr.20070626112754.1688">class leoTkinterTreeTab (leoFrame.leoTreeTab):

    '''A class representing a tabbed outline pane drawn with Tkinter.'''

    @others</t>
<t tx="ekr.20070626112754.1689"></t>
<t tx="ekr.20070626112754.1690">def __init__ (self,c,parentFrame,chapterController):

    leoFrame.leoTreeTab.__init__ (self,c,chapterController,parentFrame)
        # Init the base class.  Sets self.c, self.cc and self.parentFrame.

    self.tabNames = [] # The list of tab names.  Changes when tabs are renamed.

    self.createControl()
</t>
<t tx="ekr.20070626112754.1691">def createControl (self):

    tt = self ; c = tt.c

    # Create the main container.
    tt.frame = Tk.Frame(c.frame.iconFrame)
    tt.frame.pack(side="left")

    # Create the chapter menu.
    self.chapterVar = var = Tk.StringVar()
    var.set('main')

    tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
        labelpos = 'w', label_text = 'chapter',
        menubutton_textvariable = var,
        items = [],
        command = tt.selectTab,
    )
    menu.pack(side='left',padx=5)</t>
<t tx="ekr.20070626112754.1692"></t>
<t tx="ekr.20070626112754.1693">def destroyTab (self,tabName):

    tt = self

    if tabName in tt.tabNames:
        tt.tabNames.remove(tabName)
        tt.setNames()
</t>
<t tx="ekr.20070626112754.1694">def setTabLabel (self,tabName):

    tt = self
    tt.chapterVar.set(tabName)
</t>
<t tx="ekr.20070626112754.1695">def setNames (self):

    '''Recreate the list of items.'''

    tt = self
    names = tt.tabNames[:]
    if 'main' in names: names.remove('main')
    names.sort()
    names.insert(0,'main')
    tt.chapterMenu.setitems(names)
</t>
<t tx="ekr.20070626112754.1696"></t>
<t tx="ekr.20070626112754.1697">class chapterCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20070626112754.1698">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # c.chapterController does not exist yet.
</t>
<t tx="ekr.20070626112754.1699">def canDehoist(self):

    c = self
    return c.hoistLevel() &gt; 0

def canHoist(self):

    # N.B.  This is called at idle time, so minimizing positions is crucial!
    c = self
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return bunch.p and not c.isCurrentPosition(bunch.p)
    elif c.currentPositionIsRootPosition():
        return c.currentPositionHasNext()
    else:
        return True
</t>
<t tx="ekr.20070626112754.1700"></t>
<t tx="ekr.20070626112754.1701">@

c.finishCreate was being called twice, once for the setting file, and again for the 'actual file.'
The first time cc was None, and error messages were generated.

The fix was to define the Cmds:Chapters menu only if c.chapterController exists.</t>
<t tx="ekr.20070626112754.1702">def __init__ (self,c):

    self.c = c

    self.chaptersDict = {}
        # Keys are chapter names, values are chapters.
        # Important: chapter names never change, even if their @chapter node changes.

    self.chaptersNode = None # Set later
    self.selectedChapter = None
    self.trace = False
    self.tt = None # May be set in finishCreate.
    self.use_tabs = c.config.getBool('use_chapter_tabs')

    # g.trace('chapterController',g.callers())
</t>
<t tx="ekr.20070626112754.1703">def newLeoCommanderAndFrame(self,fileName=None,gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ""
    if not gui: gui = g.app.gui
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
</t>
<t tx="ekr.20070626112754.1704"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20070626112754.1705"># remove-chapter does not remove @chapter node.</t>
<t tx="ekr.20070626112754.1706"></t>
<t tx="ekr.20070626112754.1707"></t>
<t tx="ekr.20070626112754.1708">def sortChildren (self,event=None):

    '''Sort the children of a node.'''

    c = self ; u = c.undoer ; undoType = 'Sort Children'
    p = c.currentPosition()
    if not p or not p.hasChildren(): return

    c.beginUpdate()
    try: # In update
        c.endEditing()
        u.beforeChangeGroup(p,undoType)
        c.sortChildrenHelper(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(p,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1709">def sortChildrenHelper (self,p):

    c = self ; u = c.undoer

    # Create a list of tuples sorted on headlines.
    pairs = [(child.headString().lower(),child.copy()) for child in p.children_iter()]
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        undoData = u.beforeMoveNode(child)
        child.moveToNthChildOf(p,index)
        u.afterMoveNode(child,'Sort',undoData)
        index += 1</t>
<t tx="ekr.20070626112754.1710">def sortSiblings (self,event=None):

    '''Sort the siblings of a node.'''

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    p = c.currentPosition()
    if not p: return

    parent = p.parent()
    if not parent:
        c.sortTopLevel()
    else:
        c.beginUpdate()
        try: # In update...
            c.endEditing()
            u.beforeChangeGroup(p,undoType)
            c.sortChildrenHelper(parent)
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            c.setChanged(True)
            u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20070626112754.1711">def sortTopLevel (self,event=None):

    '''Sort the top-level nodes of an outline.'''

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    root = c.rootPosition()
    if not root: return

    # Create a list of tuples sorted by headlines.
    pairs = [(p.headString().lower(),p.copy())
        for p in root.self_and_siblings_iter()]
    pairs.sort()

    c.beginUpdate()
    try: # In update...
        dirtyVnodeList = []
        u.beforeChangeGroup(root,undoType)
        if 1: # In group...
            h,p = pairs[0]
            if p != root:
                undoData = u.beforeMoveNode(p)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                p.moveToRoot(oldRoot=root)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMoveNode(p,'Sort',undoData)
            for h,next in pairs[1:]:
                undoData = u.beforeMoveNode(next)
                next.moveAfter(p)
                u.afterMoveNode(next,'Sort',undoData)
                p = next
            c.setRootPosition(c.findRootPosition(root)) # New in 4.4.2.
        u.afterChangeGroup(root,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1712"></t>
<t tx="ekr.20070626112754.1713">def checkOutline (self,event=None,verbose=True,unittest=False,full=True):

    """Report any possible clone errors in the outline.

    Remove any unused tnodeLists."""

    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    for p in c.allNodes_iter():
        try:
            count += 1
            &lt;&lt; remove unused tnodeList &gt;&gt;
            if full: # Unit tests usually set this false.
                &lt;&lt; do full tests &gt;&gt;
        except AssertionError,message:
            errors += 1
            &lt;&lt; give test failed message &gt;&gt;
    if verbose or not unittest:
        &lt;&lt; print summary message &gt;&gt;
    return errors
</t>
<t tx="ekr.20070626112754.1714"># Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; g.es_print(s,color="blue")
    delattr(v.t,"tnodeList")
    v.t._p_changed = True
</t>
<t tx="ekr.20070626112754.1715">if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
</t>
<t tx="ekr.20070626112754.1716">threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
</t>
<t tx="ekr.20070626112754.1717">back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"

if next:
    assert p == next.back(), "p==next.back"
</t>
<t tx="ekr.20070626112754.1718">if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"

for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"

if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
</t>
<t tx="ekr.20070626112754.1719">if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
</t>
<t tx="ekr.20070626112754.1720">if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
</t>
<t tx="ekr.20070626112754.1721">if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
</t>
<t tx="ekr.20070626112754.1722">vnodeList = p.v.t.vnodeList

for v in vnodeList:

    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) &gt; 1, "len(vnodeList) &gt; 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
</t>
<t tx="ekr.20070626112754.1723"># Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = c.edit_widget(p)
    if t:
        s = t.getAllText()
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
</t>
<t tx="ekr.20070626112754.1724">s = "test failed: %s %s" % (message,repr(p))
print s ; g.es_print(s,color="red")
</t>
<t tx="ekr.20070626112754.1725">if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    g.es_print(s,color="red")
elif verbose:
    g.es(s,color="green")
</t>
<t tx="ekr.20070626112754.1726"></t>
<t tx="ekr.20070626112754.1727">def checkAllPythonCode(self,event=None,unittest=False,ignoreAtIgnore=True):

    '''Check all nodes in the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():

        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.

    if not unittest:
        g.es("Check complete",color="blue")

    return result
</t>
<t tx="ekr.20070626112754.1728">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
</t>
<t tx="ekr.20070626112754.1729">def checkPythonCode (self,event=None,unittest=False,ignoreAtIgnore=True,suppressErrors=False):

    '''Check the selected tree for syntax and tab errors.'''

    c = self ; count = 0 ; result = "ok"

    if not unittest:
        g.es("checking Python code   ")

    for p in c.currentPosition().self_and_subtree_iter():

        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (parser.ParserError,SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    g.es("surprise in checkPythonNode")
                    g.es_exception()
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")

    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
</t>
<t tx="ekr.20070626112754.1730">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
</t>
<t tx="ekr.20070626112754.1731">def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self

    h = p.headString()
    # We must call getScript so that we can ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
        if unittest: raise
        else:
            g.es_exception(full=False,color="black")
            c.setMarked(p)

    c.tabNannyNode(p,h,body,unittest,suppressErrors)
</t>
<t tx="ekr.20070626112754.1732"># This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    c = self

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return

    except parser.ParserError, msg:
        if not suppressErrors:
            g.es("ParserError in %s" % headline,color="blue")
            g.es(str(msg))

    except tokenize.TokenError, msg:
        if not suppressErrors:
            g.es("TokenError in %s" % headline,color="blue")
            g.es(str(msg))

    except tabnanny.NannyNag, nag:
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])

    except:
        g.trace("unexpected exception")
        g.es_exception()

    if unittest: raise
    else: c.setMarked(p)
</t>
<t tx="ekr.20070626112754.1733">def dumpOutline (self,event=None):

    """ Dump all nodes in the outline."""

    c = self

    for p in c.allNodes_iter():
        p.dump()
</t>
<t tx="ekr.20070626112754.1734"></t>
<t tx="ekr.20070626112754.1735">def prettyPrintAllPythonCode (self,event=None,dump=False):

    '''Reformat all Python code in the outline to make it look more beautiful.'''

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():

        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyAllPythonCode (self,event=None,dump=False):
    return self.prettyPrintAllPythonCode (event,dump)</t>
<t tx="ekr.20070626112754.1736">def prettyPrintPythonCode (self,event=None,p=None,dump=False):

    '''Reformat all Python code in the selected tree to make it look more beautiful.'''

    c = self

    if p: root = p.copy()
    else: root = c.currentPosition();

    pp = c.prettyPrinter(c)

    for p in root.self_and_subtree_iter():

        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()

# For unit test of inverse commands dict.
def beautifyPythonCode (self,event=None,dump=False):
    return self.prettyPrintPythonCode (event,dump)

</t>
<t tx="ekr.20070626112754.1737">def prettyPrintPythonNode (self,p=None,dump=False):

    c = self

    if not p:
        p = c.currentPosition()

    pp = c.prettyPrinter(c)

    # Unlike scanDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)

    pp.endUndo()
</t>
<t tx="ekr.20070626112754.1738">class prettyPrinter:

    @others
</t>
<t tx="ekr.20070626112754.1739">def __init__ (self,c):

    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    &lt;&lt; define dispatch dict &gt;&gt;
</t>
<t tx="ekr.20070626112754.1740">self.dispatchDict = {

    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
</t>
<t tx="ekr.20070626112754.1741">def clear (self):
    self.lines = []
</t>
<t tx="ekr.20070626112754.1742">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding

    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
</t>
<t tx="ekr.20070626112754.1743">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
</t>
<t tx="ekr.20070626112754.1744">def endUndo (self):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()

    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
</t>
<t tx="ekr.20070626112754.1745">def get (self):

    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()

    return self.lines
</t>
<t tx="ekr.20070626112754.1746">def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return

    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
</t>
<t tx="ekr.20070626112754.1747">def put (self,s,strip=True):

    """Put s to self.array, and strip trailing whitespace if strip is True."""

    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
</t>
<t tx="ekr.20070626112754.1748">def putArray (self):

    """Add the next text by joining all the strings is self.array"""

    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
</t>
<t tx="ekr.20070626112754.1749">def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
</t>
<t tx="ekr.20070626112754.1750">def doEndMarker (self):

    self.putArray()
</t>
<t tx="ekr.20070626112754.1751">def doErrorToken (self):

    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
</t>
<t tx="ekr.20070626112754.1752">def doDedent (self):

    pass

def doIndent (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20070626112754.1753">def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.

    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()

    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')

    # Suppress start-of-line logic.
    self.line = self.erow
</t>
<t tx="ekr.20070626112754.1754">def doName(self):

    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=&lt;&gt;*-+&amp;|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
</t>
<t tx="ekr.20070626112754.1755">def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
</t>
<t tx="ekr.20070626112754.1756">def doNumber (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20070626112754.1757">def doOp (self):

    val = self.val
    outer = self.lineParenLevel &lt;= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','&lt;=','&gt;=','&lt;','&gt;','&lt;&gt;','*','**','+','&amp;','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '&gt;&gt;':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '&lt;&lt;':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
</t>
<t tx="ekr.20070626112754.1758">def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]

    if self.ws:
        self.array.append(self.ws)
</t>
<t tx="ekr.20070626112754.1759">def oops(self):

    print "unknown PrettyPrinting code: %s" % (self.name)
</t>
<t tx="ekr.20070626112754.1760">def trace(self):

    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
</t>
<t tx="ekr.20070626112754.1761">def putToken (self,token5tuple):

    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
</t>
<t tx="ekr.20070626112754.1762">def replaceBody (self,p,lines):

    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    sel = c.frame.body.getInsertPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')

    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        c.setBodyString(p,body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
</t>
<t tx="ekr.20070626112754.1763"></t>
<t tx="ekr.20070626112754.1764"></t>
<t tx="ekr.20070626112754.1765">def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()
</t>
<t tx="ekr.20070626112754.1766">def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    c.beginUpdate()
    try:
        while v and v != last:
            v.expand()
            v = v.threadNext()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1767">def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    try:
        current = c.currentPosition()
        n = current.level()
        for p in current.self_and_subtree_iter():
            if p.level() - n + 1 &lt; level:
                p.expand()
            else:
                p.contract()
        c.expansionLevel = level
        c.expansionNode = c.currentPosition()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1768"></t>
<t tx="ekr.20070626112754.1769">def markChangedHeadlines (self,event=None):

    '''Mark all nodes that have been changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1770">def markChangedRoots (self,event=None):

    '''Mark all changed @root nodes.'''

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                s = p.bodyString()
                flag, i = g.is_special(s,0,"@root")
                if flag:
                    bunch = u.beforeMark(p,undoType)
                    c.setMarked(p)
                    c.setChanged(True)
                    u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1771">def markAllAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes as changed.'''

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    try: # In update...
        while p:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1772">def markAtFileNodesDirty (self,event=None):

    '''Mark all @file nodes in the selected tree as changed.'''

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    c.beginUpdate()
    try: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1773">def markClones (self,event=None):

    '''Mark all clones of the selected node.'''

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1774">def markHeadline (self,event=None):

    '''Toggle the mark of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            c.clearMarked(p)
        else:
            c.setMarked(p)
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1775">def markSubheads (self,event=None):

    '''Mark all children of the selected node as changed.'''

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.setMarked(p)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1776">def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        changed = False
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.clearMarked(p)
                p.v.t.setDirty()
                u.afterMark(p,undoType,bunch)
        dirtyVnodeList = [p.v for p in c.allNodes_iter() if p.v.isDirty()]
        if changed: c.setChanged(True)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()</t>
<t tx="ekr.20070626112754.1777"></t>
<t tx="ekr.20070626112754.1778">def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20070626112754.1779">def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()

    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone &amp; dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20070626112754.1780">def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
</t>
<t tx="ekr.20070626112754.1781">def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="ekr.20070626112754.1782"></t>
<t tx="ekr.20070626112754.1783">def cloneNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then clone the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'clone-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Clone node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.cloneNodeToChapterHelper(k.arg)</t>
<t tx="ekr.20070626112754.1784">def cloneNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ;  u = c.undoer ; undoType = 'Clone Node To Chapter'
    p = c.currentPosition() ; h = p.headString()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if fromChapter.name == 'main' and h.startswith('@chapter'):
        return cc.error('can not clone @chapter node')
    # g.trace('from',fromChapter.name,'to',toChapter)

    c.beginUpdate()
    try:
        # Open the group undo.
        c.undoer.beforeChangeGroup(p,undoType)
        # Do the clone.  c.clone handles the inner undo.
        clone = c.clone()
        # Do the move.
        undoData2 = u.beforeMoveNode(clone)
        clone.unlink()
        if toChapter.name == 'main':
            clone.moveAfter(toChapter.p)
        else:
            parent = cc.getChapterNode(toChapter.name)
            clone.moveToLastChildOf(parent)
        u.afterMoveNode(clone,'Move Node',undoData2,dirtyVnodeList=[])
        c.selectPosition(clone)
        c.setChanged(True)
        # Close the group undo.
        # Only the ancestors of the moved node get set dirty.
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.undoer.afterChangeGroup(clone,undoType,reportFlag=False,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False)

    toChapter.p = clone.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070626112754.1785">def convertNodeToChapter (self,event=None):

    '''convert-node-to-chapter command.

    Make the selected node into a new chapter, 'in place'.
    That is, create the new @chapter node as the next sibling of the node,
    then move the node as the first child of the new @chapter node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'convert-node-to-chapter'
    state = k.getState(tag)

    p = c.currentPosition()
    if p.headString().startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = cc.chaptersDict.keys()
        k.setLabelBlue('Convert node to chapter: ',protect=True)
        k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=c.currentPosition(),
                undoType='Convert Node To Chapter')
</t>
<t tx="ekr.20070626112754.1786">def copyNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then copy the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'copy-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.copyNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.copyNodeToChapterHelper(k.arg)</t>
<t tx="ekr.20070626112754.1787">def copyNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Copy Node To Chapter'
    p = c.currentPosition() ; h = p.headString()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if fromChapter.name == 'main' and h.startswith('@chapter'):
        return cc.error('can not copy @chapter node')
    # g.trace('from',fromChapter.name,'to',toChapter.name)

    c.beginUpdate()
    try:
        # For undo, we treat the copy like a pasted (inserted) node.
        # Use parent as the node to select for undo.
        parent = cc.getChapterNode(toChapter.name)
        undoData = u.beforeInsertNode(parent,pasteAsClone=False,copiedBunchList=[])
        s = c.fileCommands.putLeoOutline()
        p2 = c.fileCommands.getLeoOutline(s)
        p2.unlink()
        p2.moveToLastChildOf(parent)
        c.selectPosition(p2)
        u.afterInsertNode(p2,undoType,undoData)
        c.setChanged(True)
    finally:
        c.endUpdate(False)

    toChapter.p = p2.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070626112754.1788">def createChapterByName (self,name,p,undoType):

    cc = self ; c = cc.c

    if not name:
        return cc.error('No name')

    oldChapter = cc.getSelectedChapter()
    theChapter = cc.chaptersDict.get(name)
    if theChapter:
        return cc.error('Duplicate chapter name: %s' % name)

    bunch = cc.beforeCreateChapter(c.currentPosition(),oldChapter.name,name,undoType)
    if undoType == 'Convert Node To Chapter':
        root = p.insertAfter()
        root.initHeadString('@chapter %s' % name)
        p.moveToFirstChildOf(root)
    elif undoType in ('Create Chapter From Node','Create Chapter'):
        # Create the @chapter node.
        # If p exists, clone it as the first child, else create a dummy first child.
        root = cc.getChapterNode(name,p=p)
    else:
        return g.trace('Can not happen: bad undoType: %s' % undoType)

    cc.chaptersDict[name] = chapter(c=c,chapterController=cc,name=name,root=root)
    cc.selectChapterByName(name)
    cc.afterCreateChapter(bunch,c.currentPosition())

    # g.es('created chapter %s' % (name),color='blue')
    return True
</t>
<t tx="ekr.20070626112754.1789">def createChapterFromNode (self,event=None):

    '''create-chapter-from-node command.

    Create a chapter whose first node is a clone of the presently selected node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'create-chapter-from-node'
    state = k.getState(tag)

    p = c.currentPosition()
    if p.headString().startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = cc.chaptersDict.keys()
        k.setLabelBlue('Create chapter from node: ',protect=True)
        k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=p,
                undoType='Create Chapter From Node')
</t>
<t tx="ekr.20070626112754.1790">def moveNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then move the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'move-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.moveNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.moveNodeToChapterHelper(k.arg)</t>
<t tx="ekr.20070626112754.1791">def moveNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Move Node To Chapter'
    p = c.currentPosition()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)

    if 1: # Defensive code: should never happen.
        if fromChapter.name == 'main' and p.headString().startswith('@chapter'):
            return cc.error('can not move @chapter node')

    c.beginUpdate()
    try:
        if toChapter.name == 'main':
            sel = (p.threadBack() != fromChapter.root and p.threadBack()) or p.nodeAfterTree()
        else:
            sel = p.threadBack() or p.nodeAfterTree()
        if sel:
            # Get 'before' undo data.
            inAtIgnoreRange = p.inAtIgnoreRange()
            undoData = u.beforeMoveNode(p)
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
            # Do the move.
            if toChapter.name == 'main':
                p.unlink()
                p.moveAfter(toChapter.p)
            else:
                p.unlink()
                p.moveToLastChildOf(toChapter.root)
            c.selectPosition(sel)
            c.setChanged(True)
            # Do the 'after' undo operation.
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False) # toChapter.select will do the drawing.

    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.error('Can not move the last node of a chapter.')
</t>
<t tx="ekr.20070626112754.1792">def removeChapter (self,event=None):

    cc = self ; c = cc.c

    theChapter = cc.selectedChapter
    if not theChapter: return

    name = theChapter.name

    if name == 'main':
        return cc.error('Can not remove the main chapter')
    else:
        cc.removeChapterByName(name)
</t>
<t tx="ekr.20070626112754.1793">def removeChapterByName (self,name):

    cc = self ; c = cc.c ; tt = cc.tt

    theChapter = cc.chaptersDict.get(name)
    if not theChapter: return

    c.beginUpdate()
    try:
        savedRoot = theChapter.root
        bunch = cc.beforeRemoveChapter(c.currentPosition(),name,savedRoot)
        cc.deleteChapterNode(name)
        del cc.chaptersDict[name] # Do this after calling deleteChapterNode.
        if tt:tt.destroyTab(name)
        cc.selectChapterByName('main')
        cc.afterRemoveChapter(bunch,c.currentPosition())
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20070626112754.1794"># newName is for unitTesting.

def renameChapter (self,event=None,newName=None):

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc = self ; c = cc.c ; k = cc.c.k ; tt = cc.tt
    tag = 'rename-chapter'
    theChapter = cc.selectedChapter
    if not theChapter: return
    if theChapter.name == 'main':
        return cc.error('Can not rename the main chapter')

    state = k.getState(tag)

    if state == 0 and not newName:
        names = cc.chaptersDict.keys()
        prefix = 'Rename this chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if newName: k.arg = newName
        if k.arg and k.arg != theChapter.name:
            oldChapterName = theChapter.name
            del cc.chaptersDict[theChapter.name]
            cc.chaptersDict[k.arg] = theChapter
            theChapter.name = k.arg
            root = theChapter.root
            root.initHeadString('@chapter %s' % k.arg)
            if tt:
                tt.setTabLabel(k.arg)
                tt.destroyTab(oldChapterName)
                tt.createTab(k.arg)
            c.redraw_now()
</t>
<t tx="ekr.20070626112754.1795">def selectChapter (self,event=None):

    '''Use the minibuffer to get a chapter name,
    then create the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'select-chapter'
    state = k.getState(tag)

    if state == 0:
        names = cc.chaptersDict.keys()
        prefix = 'Select chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.selectChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.selectChapterByName(k.arg)
</t>
<t tx="ekr.20070626112754.1796"></t>
<t tx="ekr.20070626112754.1797"></t>
<t tx="ekr.20070626112754.1798"># ctypes comes standard with Python 2.5, but can be installed for Python 2.4.
</t>
<t tx="ekr.20070626112754.1799"></t>
<t tx="ekr.20070626112754.1800"># Created menu-command-key command that just returns 'continue'.</t>
<t tx="ekr.20070626112754.1801">@

This should fix the nodenavigator plugin.

Added goto-first-visible command.</t>
<t tx="ekr.20070626112754.1802">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4362825
By: rcy3cornelledu

The "Home" key selects first node in main outline, regardless of which chapter
is currently displayed.</t>
<t tx="ekr.20070626112754.1803">def firstVisible(self):

    """Move to the first visible node of the present chapter or hoist."""

    c = self ; p = c.currentPosition()

    while 1:
        back = p.visBack(c)
        if back and back.isVisible(c):
            p = back
        else: break
    return p
</t>
<t tx="ekr.20070626112754.1804">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter: return

    # g.trace('selected:',theChapter.name)
    firstName = theChapter.name
    if firstName != 'main':
        if theChapter.positionIsInChapter(p): return

    for name in cc.chaptersDict.keys():
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                cc.selectChapterByName(name)
                return
    else:
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20070626112754.1805">@
Selecting a node now never truncates the beadList.</t>
<t tx="ekr.20070626112754.1806">class nodeHistory:

    '''A class encapsulating knowledge of visited nodes.'''

    @others
</t>
<t tx="ekr.20070626112754.1807">def canGoToNextVisited (self):

    return self.beadPointer + 1 &lt; len(self.beadList)

def canGoToPrevVisited (self):

    return self.beadPointer &gt; 0
</t>
<t tx="ekr.20070626112754.1808">def clear (self):

    self.visitedList = []
</t>
<t tx="ekr.20070626112754.1809">def goNext (self):

    '''Return the next visited node, or None.'''
    if self.beadPointer + 1 &lt; len(self.beadList):
        self.beadPointer += 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None

def goPrev (self):

    '''Return the previous visited node, or None.'''
    if self.beadPointer &gt; 0:
        self.beadPointer -= 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None
</t>
<t tx="ekr.20070626112754.1810">def __init__ (self,c):

    self.c = c

    self.beadList = [] # list of (position,chapter) tuples for the Back and Forward commands.
    self.beadPointer = -1
    self.visitedList = [] # list of (position,chapter) tuples for the Nodes dialog.
</t>
<t tx="ekr.20070626112754.1811">def remove (self,p):

    for data in self.visitedList:
        p2,chapter = data
        if p == p2:
            self.visitedList.remove(data)
            break
</t>
<t tx="ekr.20070626112754.1812">def selectChapter (self,chapter):

    c = self.c ; cc = c.chapterController
    if not cc or not chapter: return

    if chapter != cc.getSelectedChapter():
        cc.selectChapterByName(chapter.name)
</t>
<t tx="ekr.20070626112754.1813">def update (self,p,updateBeadList):

    if updateBeadList:
        self.updatePositionList(p)
    self.updateVisitedList(p)
</t>
<t tx="ekr.20070626112754.1814">def updatePositionList (self,p):

    # Don't change the list if p is already in it.
    c = self.c ; cc = c.chapterController
    update = True
    for data in self.beadList:
        p2,chapter = data
        if p2 == p:
            update = False
        if not c.positionExists(p2,root=c.rootPosition()):
            self.beadList.remove(data)
            update = True ; break

    # Add the node to the end, and set the bead pointer to the end.
    if update:
        theChapter = cc and cc.getSelectedChapter()
        data = p.copy(),theChapter
        self.beadList.append(data)
        self.beadPointer = len(self.beadList)-1
        #g.trace('updating bead list',p.headString())
        #print [p.headString() for p in self.beadList]
</t>
<t tx="ekr.20070626112754.1815">def updateVisitedList (self,p):

    '''Make p the most recently visited position.'''

    c = self.c ; cc = c.chapterController
    for data in self.visitedList:
        p2,chapter = data
        if p2 == p:
            self.visitedList.remove(data)
            break

    chapter = cc and cc.getSelectedChapter()
    data = p.copy(),chapter
    self.visitedList.insert(0,data)

    # g.trace('len(c.visitedList)',len(c.visitedList))
    # g.trace([z.headString()[:10] for z in self.visitedList]) # don't assign to p!
</t>
<t tx="ekr.20070626112754.1816">def visitedPositions (self):

    return [p.copy() for p,chapter in self.visitedList]
</t>
<t tx="ekr.20070626112754.1817">menu = frame.menu.getMenu("Go To...")
enable(menu,"Go To Prev Visited",c.nodeHistory.canGoToPrevVisited())
enable(menu,"Go To Next Visited",c.nodeHistory.canGoToNextVisited())
enable(menu,"Go To Prev Visible",c.canSelectVisBack())
enable(menu,"Go To Next Visible",c.canSelectVisNext())
if 0: # These are too slow.
    enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
    enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
enable(menu,"Go To Next Clone",isCloned)
enable(menu,"Go To Prev Node",c.canSelectThreadBack())
enable(menu,"Go To Next Node",c.canSelectThreadNext())
enable(menu,"Go To Parent",hasParent)
enable(menu,"Go To Prev Sibling",hasBack)
enable(menu,"Go To Next Sibling",hasNext)
</t>
<t tx="ekr.20070626112754.1818"># CleanLines was adding a trailing newline.
# The fix was to suppress this during unit tests.</t>
<t tx="ekr.20070626112754.1819">@nocolor

By: mstarzyk

There is a problem with coloring of @file (@thin, and others) nodes. 
After you navigate in the tree out of the node, then the node you just
left does not get the proper (unselected) color - until you close and 
reopen the parent node.

This is a problem when you have several @thin nodes and switch 
between them, because it is difficult in the tree which node is the 
current - they are all dark green. 
Please see below for a patch that fixes this problem. 

Cheers, 
Maciek

Index: plugins/cleo.py
===================================================================
RCS file: /cvs/leo/plugins/cleo.py,v
retrieving revision 1.9
diff -r1.9 cleo.py
504c504
&lt;     def custom_colours(self,v):
---
&gt;     def custom_colours(self, v, node_is_selected):
520c520
&lt;                 if h == MeSelf:
---
&gt;                 if node_is_selected:
527c527
&lt;             if h == MeSelf:
---
&gt;             if node_is_selected:
814c814
&lt;         fg, bg = self.custom_colours(p.v)
---
&gt;         fg, bg = self.custom_colours(p.v, node_is_selected=False)
835c835
&lt;         fg, bg = self.custom_colours(p.v)
---
&gt;         fg, bg = self.custom_colours(p.v, node_is_selected=True)
</t>
<t tx="ekr.20070626112754.1820"></t>
<t tx="ekr.20070626112754.1821">@nocolor

The coloring for PHP has 2 major issues that

 1 - it wont trigger on multiple line comments: /* */

 2 - Enlarged Keywords sometimes bug on key up end key down movement of cursor
in the body, it sucks visualy too,.


What I did:

- Added /* and */ to php delims.  This solves 1.

- @settings--&gt;Colors--&gt;Syntax colors &amp; options--&gt;Options for jEdit colorer--&gt;Langauge-specific colors--&gt;php--&gt;@font php keyword fonts (old colorizer)

The new settings:

php_keyword_font_size = None
php_keyword_font_slant = roman
    # roman, italic
php_keyword_font_weight = normal
    # normal, bold
</t>
<t tx="ekr.20070626112754.1822">self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}

# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns

    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.

    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective

    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword

    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword

    if self.language == "php":
        dict1 ['&lt;'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword

    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["&lt;&lt;"] = self.doPossibleSectionRefOrDef

    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)

    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
</t>
<t tx="ekr.20070626112754.1823"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "// /* */", # 6/23/07: was "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.

self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20070626112754.1824">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
</t>
<t tx="ekr.20070626112754.1825">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
</t>
<t tx="ekr.20070626112754.1826">def doNormalState (self,s,i):

    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&amp;*()_+-={}|[];':\",./&lt;&gt;?")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state
</t>
<t tx="ekr.20070626112754.1827"></t>
<t tx="ekr.20070626112754.1828">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
elif self.language == "forth":
    &lt;&lt; handle possible forth keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j
</t>
<t tx="ekr.20070626112754.1829">if g.match(s,i,"\\"):
    if i + 1 &lt; len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
</t>
<t tx="ekr.20070626112754.1830">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20070626112754.1831">j = self.skip_id(s,i+1,chars="`~!@#$%^&amp;*()-_=+[]{};:'\\\",./&lt;&gt;?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True

    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
</t>
<t tx="ekr.20070626112754.1832">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
</t>
<t tx="ekr.20070626112754.1833">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20070626112754.1834"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
</t>
<t tx="ekr.20070626112754.1835"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
</t>
<t tx="ekr.20070626112754.1836">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
</t>
<t tx="ekr.20070626112754.1837">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
</t>
<t tx="ekr.20070626112754.1838"></t>
<t tx="ekr.20070626112754.1839">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1840"></t>
<t tx="ekr.20070626112754.1841"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20070626112754.1842"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
</t>
<t tx="ekr.20070626112754.1843">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1844">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1845"># self.tag("normal",i,i+1)
i += 1
</t>
<t tx="ekr.20070626112754.1846"></t>
<t tx="ekr.20070626112754.1847"></t>
<t tx="ekr.20070626112754.1848"></t>
<t tx="ekr.20070626112754.1849">Alt-home is now bound to goto-first-visible rather than goto-first.</t>
<t tx="ekr.20070626112754.1850">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319356

Pythonistas have come to expect that::

 $ easy_install &lt;app&gt;

will locate and install the most recent version of app and install it.
</t>
<t tx="ekr.20070626112754.1851">@nocolor

http://sourceforge.net/forum/message.php?msg_id=4359597

These are no longer needed now that the user can use the Debian package manager or easy_install.</t>
<t tx="ekr.20070626112754.1852">@nocolor

This script runs all @test nodes as follows:

- Copies all @suite and @tests nodes to dynamicUnitTests.leo.

- Runs leoDynamicTest.py in a separate process. In turn, leoDynamicTest.py
  use the leoBridge module to run dynamicUnitTests.leo.
  (test.leo contains the source code for leoDynamicTest.py.)

Thus, all unit tests will be run with the latest Leo sources.

Allowing @test nodes in leoPy.leo is important: unit tests can be placed near
the code they are intended to test.</t>
<t tx="ekr.20070626112754.1853"></t>
<t tx="ekr.20070626112754.1854">@nocolor

What I did:

- use g.getTestVars()
- Replaced test_ functions with @test.
- Removed the code in unitTest.leo that looks for test_functions.
</t>
<t tx="ekr.20070626112754.1855"></t>
<t tx="ekr.20070626112754.1856">The chapter commands provide a good example.  In this file, see the node:

Code--&gt;Core classes...--&gt;@thin leoChapters.py--&gt;class chapterController--&gt;Undo

The general plan is this:

1. The command handler calls a **beforeCommand** method before changing the outline.

The beforeCommand method creates a g.Bunch that contains all the information needed to
restore the outline to its previous state. Typically, the beforeCommand method
will call c.undoer.createCommonBunch(p), where p is, as usual,
c.currentPosition().

2. After changing the outline the command handler calls an **afterCommand** method.

This method should take as one argument the g.Bunch returned by the
beforeCommand method. In the discussion below, denote this bunch by b. The
afterCommand method adds any information required to redo the operation after
the operation has been undone.

The afterCommand method also sets b.undoHelper and b.redoHelper to two method
that actually perform the undo and redo operations. (Actually, the beforeCommand
method could also set these two entries).

When the afterCommand method has 'filled in' all the entries of b, the
afterCommand method must call u.pushBead(b). This pushes all the undo
operation on a stack managed by the Leo's undoer, i.e., c.commands.undoer.

3. The undoer calls the undoHelper and redoHelper methods to perform the actual undo and redo operations.

The undoer handles most of the housekeeping chores related to undo and redo.  All the undoHelper and redoHelper methods have to do is actually alter Leo's outline.

**Note**: the undoer creates an ivar (instance variable) of the *undoer* class for every entry in the bunch b passed as an argument to u.pushBead(b).  For example, suppose u = c.commands.under and that b has ivars 'a','b' and 'c'.  Then, on entry to the undoHelper and the redoHelper the u.a, u.b and u.c ivars will be defined.  This makes it unnecessary for the undoHelper or the redoHelper to 'unpack' b explicitly.

Writing correct undo and redo helpers is usually a bit tricky.  The code is often subtly different from the original code that implements a command.  That just can't be helped.




</t>
<t tx="ekr.20070626112754.1857"></t>
<t tx="ekr.20070626112754.1858">def afterCreateChapter (self,bunch,p):

    cc = self ; u = cc.c.undoer
    if u.redoing or u.undoing: return

    bunch.kind = 'create-chapter'
    bunch.newP = p.copy()

    # Set helpers
    bunch.undoHelper = cc.undoInsertChapter
    bunch.redoHelper = cc.redoInsertChapter

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.1859">def afterRemoveChapter (self,bunch,p):

    cc = self ; u = cc.c.undoer
    if u.redoing or u.undoing: return

    bunch.kind = 'remove-chapter'
    bunch.newP = p.copy()

    # Set helpers
    bunch.undoHelper = cc.undoRemoveChapter
    bunch.redoHelper = cc.redoRemoveChapter

    u.pushBead(bunch)
</t>
<t tx="ekr.20070626112754.1860">def beforeCreateChapter (self,p,oldChapterName,newChapterName,undoType):

    cc = self ; u = cc.c.undoer

    bunch = u.createCommonBunch(p)

    bunch.oldChapterName = oldChapterName
    bunch.newChapterName = newChapterName
    bunch.savedRoot = None
    bunch.undoType = undoType

    return bunch
</t>
<t tx="ekr.20070626112754.1861">def beforeRemoveChapter (self,p,newChapterName,savedRoot):

    cc = self ; u = cc.c.undoer

    bunch = u.createCommonBunch(p)

    bunch.newChapterName = newChapterName
    bunch.savedRoot = savedRoot
    bunch.undoType = 'Remove Chapter'

    return bunch
</t>
<t tx="ekr.20070626112754.1862">def redoInsertChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    # g.trace(u.newChapterName,u.oldChapterName,u.p)

    cc.createChapterByName(u.newChapterName,p=u.savedRoot,undoType=u.undoType)
    theChapter = cc.getChapter(u.newChapterName)

    if u.undoType == 'Convert Node To Chapter':
        pass
    elif u.undoType in ('Create Chapter From Node','Create Chapter'):
        root = theChapter.root
        firstChild = root.firstChild()
        firstChild.unlink()
        firstChild = u.savedRoot.firstChild()
        firstChild.linkAsNthChild(root,0)
    else:
        return g.trace('Can not happen: bad undoType: %s' % u.undoType)
</t>
<t tx="ekr.20070626112754.1863">def redoRemoveChapter (self):

    cc = self ; u = cc.c.undoer

    cc.removeChapterByName(u.newChapterName)
    cc.selectChapterByName('main')</t>
<t tx="ekr.20070626112754.1864">def undoInsertChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    newChapter = cc.getChapter(u.newChapterName)

    bunch = u.beads[u.bead]
    bunch.savedRoot = root = newChapter.root

    if u.undoType == 'Convert Node To Chapter':
        p = root.firstChild()
        p.moveAfter(root)
    else:
        pass # deleting the chapter will delete the node.

    cc.removeChapterByName(u.newChapterName)
    cc.selectChapterByName('main')
</t>
<t tx="ekr.20070626112754.1865">def undoRemoveChapter (self):

    cc = self ; c = cc.c ; u = c.undoer

    # u.savedRoot is the entire @chapter tree.
    # Link it as the last child of the @chapters node.
    parent = cc.findChaptersNode()
    u.savedRoot.linkAsNthChild(parent,parent.numberOfChildren())

    # Now recreate the chapter.
    name = u.newChapterName
    cc.chaptersDict[name] = chapter(c=c,chapterController=cc,name=name,root=u.savedRoot)
    cc.selectChapterByName(name)
</t>
<t tx="ekr.20070626112754.1866"></t>
<t tx="ekr.20070626112754.1867">leoGlobals.py:127: No module attribute (leo_config_directory) found # wrong
leoGlobals.py:3884: Statement appears to have no effect # wrong
leoGlobals.py:3884: No module attribute (CODESET) found # wrong
leoGlobals.py:4448: No module attribute (mtime) found # wrong

leoKeys.py:2438: No module attribute (initAllEditCommanders) found

leoChapters.py:463: Invalid arguments to (select), got 0, expected between 1 and 3 # wrong

leoFind.py:1355: No module attribute (__init__) found # wrong

leoTkinterFrame.py:1767: Object (body) has no attribute (leo_p) # wrong.

leoTkinterGui.py:563: Local variable (tkIcon) not used # Wrong.
</t>
<t tx="ekr.20070626112754.1868"># fixed: leoGlobals.py:2213: Variable (no_gc_message) used before being set

# fixed: leoConfig.py:1663: (hash) shadows builtin

# fixed: leoCommands.py:5170: Local variable (backBack) not used

# fixed: leoChapters.py:10: Imported module (leoNodes) not used
# fixed: leoChapters.py:574: Redefining attribute (updateChapterName) original line (59)
# fixed: leoChapters.py:519: Local variable (tt) not used
# fixed: leoChapters.py:660: Local variable (b) not used

# fixed: leoTkinterTree.py:548: Parameter (theId) not used

# fixed: leoTkinterFrame.py:2482: No global (cc) found.
# fixed: leoTkinterFrame.py:2940: Local variable (hull) not used
# fixed: leoTkinterFrame.py:3085: Parameter (theChapter) not used
# fixed: leoTkinterFrame.py:3120: Local variable (nb) not used
# fixed: leoTkinterFrame.py:3122: Local variable (frame) not used
</t>
<t tx="ekr.20070626112754.1869"># (fixed) leoGlobals.py:4102: Local variable (data) not used
# (fixed) leoKeys.py:241: Variable (key) used before being set
# (fixed) leoChapters.py:105: Local variable (groupUndoData) not used
# (fixed) leoChapters.py:648: No global (c) found
# (fixed) leoTkinterFrame.py:534: Local variable (tracewidget) not used
# (fixed) leoTkinterFrame.py:538: Local variable (untracewidget) not used

</t>
<t tx="ekr.20070703172620"></t>
<t tx="ekr.20070703172620.1"></t>
<t tx="ekr.20070703172620.2"># can not open: C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
</t>
<t tx="ekr.20070703172620.3">def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es("%s not found in %s" % (name,configDir))
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es("%s not found in %s or %s" % (name,configDir,homeDir))
</t>
<t tx="ekr.20070703172620.4">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame</t>
<t tx="ekr.20070703172620.5">@

It's a bit tricky to ensure that leo/src is in sys.path
The code now changes the working directory to leo/src,
and leoDynamicTest.py adds os.getcwd() to sys.path if it is not there.
This is a dubious plan.

# import os,sys
# print 'cwd', os.getcwd()
# for s in sys.path: print s
</t>
<t tx="ekr.20070703172620.6">class debugCommandsClass (baseEditCommandsClass):

    @others
</t>
<t tx="ekr.20070703172620.7">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
</t>
<t tx="ekr.20070703172620.8">def getPublicCommands (self):

    k = self

    return {
        'collect-garbage':              self.collectGarbage,
        'debug':                        self.debug,
        'disable-gc-trace':             self.disableGcTrace,
        'dump-all-objects':             self.dumpAllObjects,
        'dump-new-objects':             self.dumpNewObjects,
        'enable-gc-trace':              self.enableGcTrace,
        'free-tree-widgets':            self.freeTreeWidgets,
        'print-focus':                  self.printFocus,
        'print-stats':                  self.printStats,
        'print-gc-summary':             self.printGcSummary,
        'run-all-unit-tests':           self.runAllUnitTests, # The new way...
        'run-unit-tests':               self.runUnitTests,
        'run-all-unit-tests-locally':   self.runAllUnitTestsLocally, # The old way...
        'run-unit-tests-locally':       self.runUnitTestsLocally,
        'verbose-dump-objects':         self.verboseDumpObjects,
    }
</t>
<t tx="ekr.20070703172620.9">def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
</t>
<t tx="ekr.20070703172620.10">def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
</t>
<t tx="ekr.20070703172620.11">def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
</t>
<t tx="ekr.20070703172620.12">def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
</t>
<t tx="ekr.20070703172620.13">def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = True
    g.enable_gc_debug()

    if g.app.trace_gc_verbose:
        g.es('enabled verbose gc stats',color='blue')
    else:
        g.es('enabled brief gc stats',color='blue')
</t>
<t tx="ekr.20070703172620.14">def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
</t>
<t tx="ekr.20070703172620.15"># Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
</t>
<t tx="ekr.20070703172620.16">def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
</t>
<t tx="ekr.20070703172620.17">def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
</t>
<t tx="ekr.20070703172620.18">def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=True)

def runUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=False)

def runAllUnitTests (self,event=None):
    '''Run all unit tests contained in the entire outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True)

def runUnitTests(self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False)
</t>
<t tx="ekr.20070703172620.19"></t>
<t tx="ekr.20070703172620.20">def computeGlobalConfigDir():

    # Suppresses warning about sys.leo_config_directory
    #__pychecker__ = '--limit = 0'
    #__pychecker__ = '--no-classattr --no-objattrs'

    import leoGlobals as g

    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")

    if theDir:
        theDir = g.os_path_abspath(theDir)

    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None

    return theDir
</t>
<t tx="ekr.20070703172620.21">def computeHomeDir():

    """Returns the user's home directory."""

    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) &gt; 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
</t>
<t tx="ekr.20070703172620.22">def computeLeoDir ():

    loadDir = g.app.loadDir

    g.app.leoDir = theDir = g.os_path_dirname(loadDir)

    if theDir not in sys.path:
        sys.path.append(theDir)

    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
</t>
<t tx="ekr.20070703172620.23">def computeLoadDir():

    """Returns the directory containing leo.py."""

    import leoGlobals as g
    import sys

    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) &gt; 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None

        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        raise
        #import traceback ; traceback.print_exc()
        #return None
</t>
<t tx="ekr.20070703172620.24">def computeStandardDirectories():

    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''

    if 0:
        import sys
        for s in sys.path: g.trace(s)

    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.

    g.app.leoDir = g.computeLeoDir()

    g.app.homeDir = g.computeHomeDir()

    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))

    g.app.globalConfigDir = g.computeGlobalConfigDir()

    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))

    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
</t>
<t tx="ekr.20070703172620.25">def startupEncoding ():

    import leoGlobals as g
    import sys

    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding

    return encoding
</t>
<t tx="ekr.20070703172620.26">def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()</t>
<t tx="ekr.20070703172620.27">class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
</t>
<t tx="ekr.20070703172620.28">def __init__(self,c,all):

    self.c = c
    self.all = all

    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
</t>
<t tx="ekr.20070703172620.29">def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
</t>
<t tx="ekr.20070703172620.30">def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c
    c2root = c2.rootPosition()
    c2root.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    c2.beginUpdate()
    if self.all:
        p = c.rootPosition() ; limit_p = None
    else:
        p = self.root ; p = c.currentPosition()
        limit_p = p.nodeAfterTree()
    try:
        c2root.expand()
        while p and p != limit_p:
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    # print h
                    p2 = p.copyTreeAfter()
                    p2.unlink()
                    p2.moveToLastChildOf(c2root)
                    p.moveToNodeAfterTree()
                    break
            else:
                p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
</t>
<t tx="ekr.20070703172620.31">def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
</t>
<t tx="ekr.20070703172620.32">def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    args = [sys.executable, path, '--silent']

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
</t>
<t tx="ekr.20070703172620.33">def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = p.copy()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    return False
</t>
<t tx="ekr.20070703172620.34">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4385604
By: rich_ries

From: Rich

Coupla problems:

(1) I pressed Alt+9 (just fooling around -- err, experimenting!) and got the
following error window:

====================================================================
Error: 1
AttributeError Exception in Tk callback
  Function: &lt;function masterBindKeyCallback at 0x01461F30&gt; (type: &lt;type
'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x00F85260&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line
1747, in __call__
    return apply(self.func, args)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
2150, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
3086, in masterKeyHandler
    return k.masterCommand(event,b.func,b.stroke,b.commandName)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
2272, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 283, in doCommand
    c.redraw_now()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 5720, in redraw_now
    c.frame.tree.redraw_now()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 822, in redraw_now
    self.redrawHelper(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 838, in redrawHelper
    self.drawTopTree()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1185, in drawTopTree
    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1213, in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 976, in drawNode
    return self.force_draw_node(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1004, in force_draw_node
    h2 = self.drawText(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1031, in drawText
    self.configureTextState(p)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1890, in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 2349, in setUnselectedLabelState
    self.setUnselectedHeadlineColors(p)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
818, in setUnselectedHeadlineColors
    fg, bg = self.custom_colours(p.v,node_is_selected=False)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
520, in custom_colours
    MeSelf = self.c.currentPosition().headString()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoNodes.py", line
1330, in headString
    return self.v.headString()
AttributeError: 'NoneType' object has no attribute 'headString'

================================================
  Event contents:
    char: 9
    delta: 57
    height: ??
    keycode: 57
    keysym: 9
    keysym_num: 57
    num: ??
    serial: 1993
    state: 131072
    time: 91071250
    type: 2
    widget: .21028576.21057624.21057784.21057824.21057944.21058024.canvas
    width: ??
    x: 318
    x_root: 352
    y: 87
    y_root: 191
--------------------------------------------------------------------
and the following in the Log Pane:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 270, in doCommand
    val = command(event)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 4228, in expandAllHeadlines
    c.endUpdate()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 5597, in endUpdate
    c.frame.tree.endUpdate(flag,scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 777, in endUpdate
    self.redraw_now(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 822, in redraw_now
    self.redrawHelper(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 838, in redrawHelper
    self.drawTopTree()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1185, in drawTopTree
    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1213, in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 976, in drawNode
    return self.force_draw_node(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1004, in force_draw_node
    h2 = self.drawText(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1031, in drawText
    self.configureTextState(p)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1890, in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 2349, in setUnselectedLabelState
    self.setUnselectedHeadlineColors(p)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
818, in setUnselectedHeadlineColors
    fg, bg = self.custom_colours(p.v,node_is_selected=False)
====================================================================

(2) Looking through the key bindings, I saw
"@shortcuts Gui operations focus-to-body = Alt-D"
but when I tried it, it actually moves to a headline that starts with "D"


--Rich
</t>
<t tx="ekr.20070703172620.35"># Misspelled words not selected properly on Linux.</t>
<t tx="ekr.20070703172620.36">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20070703172620.37">def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None

    try:
        while 1:
            # g.trace('p',p and p.headString())
            p, word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                try:
                    c.frame.tree.expandAllAncestors(p)
                    c.selectPosition(p)
                finally:
                    c.endUpdate()
                    w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20070703172620.38">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20070703172620.39">def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i &lt; len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i &lt; len(s):
            # A non-empty word has been found.
            j = i
            while j &lt; len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
    return None,None</t>
<t tx="ekr.20070703172620.40">@nocolor
https://sourceforge.net/forum/message.php?msg_id=4385699
By: rich_ries

From: Rich

Trying the Group Operations gave the following error message:

Traceback (most recent call last):
  File "C:\Software Engineering\Literate Programming\Leo\src\leoGlobals.py",
line 2553, in doHook
    return f(tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoPlugins.py",
line 91, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoPlugins.py",
line 70, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoPlugins.py",
line 49, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\groupOperations.py",
line 235, in drawImages
    if lassoer.moveNode and lassoer.moveNode.isVisible():
TypeError: isVisible() takes exactly 2 arguments (1 given)

=====================================================================

--Rich

</t>
<t tx="ekr.20070703172620.41"># Moving into a chapters node from the main chapter does an automatic hoist.</t>
<t tx="ekr.20070703172620.42">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''
    cc = self ; c = cc.c

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter: return

    # g.trace('selected:',theChapter.name)
    # First, try the presently selected chapter.
    firstName = theChapter.name
    if firstName == 'main' or theChapter.positionIsInChapter(p):
        return # Bug fix: 7/2/07. All position are in the main chapter.

    for name in cc.chaptersDict.keys():
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                cc.selectChapterByName(name)
                return
    else:
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20070703172620.43">@nocolor

- Made inter-outline moves &amp; copies work again.
- Also, warn that inter-outline clones transfer have no effect.  An oversight in the original code?
- Note: none of these operations are presently undoable.

In short, this code is no worse than it has ever been, but I cannot recommend either this code or its functionality as a model of good practice.
</t>
<t tx="ekr.20070703172620.44">def getLeoOutlineFromClipboard (self,s,reassignIndices=True):

    '''Read a Leo outline from string s in clipboard format.'''

    try:
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=False)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    return v

getLeoOutline = getLeoOutlineFromClipboard # for compatibility</t>
<t tx="ekr.20070703172620.45">def finishPaste(self,reassignIndices=True):

    """Finish pasting an outline from the clipboard.

    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        &lt;&lt; reassign tnode indices &gt;&gt;
    c.selectPosition(current)
    return current
</t>
<t tx="ekr.20070703172620.46">@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

nodeIndices = g.app.nodeIndices

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        # New in Leo 4.4.2 b2: use gnx's.  maxTnodeIndex is no longer used.
        t.fileIndex = nodeIndices.getNewIndex()
        # g.trace(t.fileIndex)</t>
<t tx="ekr.20070703172620.47">def getLeoOutlineHelper (self,s,reassignIndices,checking):

    self.checking = checking
    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.descendentUnknownAttributesDictList = []
    v = None

    self.tnodesDict = {}
    if not reassignIndices:
        &lt;&lt; recreate tnodesDict &gt;&gt;
    try:
        self.getXmlVersionTag()
        self.getXmlStylesheetTag()
        self.getTag("&lt;leo_file&gt;")
        self.getClipboardHeader()
        self.getDummyElements()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("&lt;/leo_file&gt;")
        if not checking:
            v = self.finishPaste(reassignIndices)
    finally:
        self.fileBuffer = None ; self.fileIndex = 0
        self.usingClipboard = False
        self.tnodesDict = {}
    return v
</t>
<t tx="ekr.20070703172620.48">nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t

if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
</t>
<t tx="ekr.20070703172620.49">def getClipboardHeader (self):

    if self.getOpenTag("&lt;leo_header"):
        return # &lt;leo_header&gt; or &lt;leo_header/&gt; has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("&gt;&lt;/leo_header&gt;"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/&gt;")
            break</t>
<t tx="ekr.20070703172620.50"># Added calls to c,p = g.getTestVars()

(fixed) leoNodes.py:2801: No global (p) found
(fixed) leoNodes.py:2804: No global (c) found

(fixed) leoConfig.py:1739: No global (c) found

(fixed) leoKeys.py:4446: No global (c) found

(fixed) leoEditCommands.py:7823: No global (c) found
(fixed) leoEditCommands.py:8508: No global (e) found
</t>
<t tx="ekr.20070703172620.51"></t>
<t tx="ekr.20070703172620.52">selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    #  Called by body.onClick and whenever w must be selected.

    if self.selectEditorLockout:
        return

    if w and self.bodyCtrl == w:
        # Bug fix: 7-3-2007.
        c = self.c
        if w.leo_p and w.leo_p != c.currentPosition():
            c.selectPosition(w.leo_p)
            c.bodyWantsFocusNow()
        return

    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(w)
    finally:
        self.selectEditorLockout = False

    return val # Don't put a return in a finally clause.
</t>
<t tx="ekr.20070703172620.53">def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if 0:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    self.inactivateActiveEditor(w)

    # The actual switch.
    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if 0:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.headString())

    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls assignPositionToEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20070703172620.54"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20070703172620.55"></t>
<t tx="ekr.20070703172620.56"></t>
<t tx="ekr.20070703172620.57">def es_print(s,*args,**keys):

    print g.toEncodedString(s,'ascii')

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
</t>
<t tx="ekr.20070703172620.58">if g.unitTesting:
    if 0: # Not usually enabled.
        g.es_print('\ntest of es_print: Ă',color='red')
</t>
<t tx="ekr.20070703172620.59">def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    log = app.log
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
</t>
<t tx="ekr.20070703172620.60"></t>
<t tx="ekr.20070703172620.61">@nocolor

For full details, see: http://sourceforge.net/forum/forum.php?thread_id=1765685&amp;forum_id=10226

What I did:

- Added support for @unit-tests: the entire tree is copied to the dynamic.leo file
- Put most unit tests in @thin unitTests.txt (with @all).
- Added support for -silent command-line option.  It suppresses most startup messages.
- Modified run-unit-test command so it runs dynamically.
    - The new commands are run-unit-tests, run-all-unit-tests,
      run-unit-tests-locally and run-all-unit-tests-locally.
- Created unit test buttons with Alt-4 and Alt-5 bindings.
- Tell how long it took to create .leo file.
- @testcase not needed: @suite is good enough

@color</t>
<t tx="ekr.20070703172620.62">def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        for p in theIter:
            if isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p): # @suite
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
            # elif isTestCaseNode(p): # @testcase or @test-case
                # test = makeTestClass(c,p)
                # if test: suite.addTest(test)

        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
</t>
<t tx="ekr.20070703172620.63">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
</t>
<t tx="ekr.20070703172620.64">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20070703172620.65">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20070703172620.66">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
</t>
<t tx="ekr.20070703172620.67">def tearDown (self):

    pass

    # To do: restore the outline.
</t>
<t tx="ekr.20070703172620.68">def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!
    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
</t>
<t tx="ekr.20070703172620.69">def shortDescription (self):

    return self.p.headString() + '\n'
</t>
<t tx="ekr.20070703172620.70">@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
</t>
<t tx="ekr.20070703172620.71">def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
</t>
<t tx="ekr.20070703172620.72">@
It is essential to rotect them with::

     if g.unitTesting:

A new unit test ensures that this is so.</t>
<t tx="ekr.20070703172620.73">@nocolor
http://sourceforge.net/forum/message.php?msg_id=4382336
By: rich_ries

&gt;&gt; Offhand, I don't have a great solution to this.
&gt;&gt; Anyone have an idea?

The rst3 plugin sends its error message solely to the console; can not
the spell-check do the same?
</t>
</tnodes>
</leo_file>
