<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="120" left="340" height="749" width="909"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20061029091830" a="ETV"><vh>4.4.2 projects</vh>
<v t="ekr.20061029091751.1"><vh>Leo 4.4.2.1 final projects</vh>
<v t="ekr.20061029091751.2"><vh>Fixed bug reading recent files</vh>
<v t="ekr.20061029091751.3"><vh>appendToRecentFiles (g.app.config)</vh></v>
<v t="ekr.20061029091751.4"><vh>initSettingsFiles</vh></v>
<v t="ekr.20061029091751.5"><vh>g.app.config.readSettingsFiles</vh>
<v t="ekr.20061029091751.6"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091751.7"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20061029091751.8"><vh>createRecentFiles</vh></v>
<v t="ekr.20061029091751.9"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061029091751.10"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061029091751.11"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061029091811"><vh>Leo 4.4.2 final projects</vh>
<v t="ekr.20061029091811.1"><vh>Bugs</vh>
<v t="ekr.20061029091811.2"><vh>Changed leo_rst.css to pass the w3 validator</vh></v>
<v t="ekr.20061029091811.3"><vh>Fixed 'Run on string' message when typing ( with no @color in effect</vh>
<v t="ekr.20061029091811.4"><vh>skip_string</vh></v>
<v t="ekr.20061029091811.5"><vh>selfInsertCommand &amp; helpers</vh>
<v t="ekr.20061029091811.6"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20061029091811.7"><vh>test_selfInsertCommand</vh></v>
<v t="ekr.20061029091811.8"><vh>initBracketMatcher</vh></v>
<v t="ekr.20061029091811.9"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20061029091811.10"><vh>flashCharacter</vh></v>
<v t="ekr.20061029091811.11"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20061029091811.12"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20061029091811.13"><vh>updateTab</vh></v>
</v>
<v t="ekr.20061029091811.14"><vh>skip_matching_python_delims</vh></v>
</v>
<v t="ekr.20061029091811.15"><vh>Fixed problem with c++ extensions</vh>
<v t="ekr.20061029091811.16"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20061029091811.17"><vh>Move on if regexp matches an empty string</vh>
<v t="ekr.20061029091811.18"><vh>regexHelper</vh></v>
</v>
<v t="ekr.20061029091811.19"><vh>Fixed several bugs related to multiple body panes</vh>
<v t="ekr.20061029091811.20"><vh>selectEditor</vh>
<v t="ekr.20061029091811.21"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091811.22"><vh>masterClickHandler</vh></v>
<v t="ekr.20061029091811.23"><vh>onClick</vh></v>
<v t="ekr.20061029091811.24"><vh>tkBody.createTextWidget</vh></v>
</v>
<v t="ekr.20061029091811.25"><vh>Fixed multipath plugin so it works with new colorizier</vh>
<v t="ekr.20061029091811.26" a="M"><vh>directiveKind4 &amp; test</vh>
<v t="ekr.20061029091811.27"><vh>test_directiveKind4</vh></v>
</v>
<v t="ekr.20061029091811.28"><vh>&lt;&lt; define leo keywords &gt;&gt;</vh></v>
<v t="ekr.20061029091811.29"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20061029091811.30"><vh>&lt;&lt; set theDict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20061029091811.31"><vh>&lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061029091811.32"><vh>Fixed bug in new colorizer</vh></v>
<v t="ekr.20061029091811.33"><vh>Fixed config bug</vh>
<v t="ekr.20061029091811.34"><vh>setInitialWindowGeometry</vh></v>
</v>
<v t="ekr.20061029091811.35"><vh>Investigated problems with leoRecentFiles.txt</vh>
<v t="ekr.20061029091811.36"><vh>Compute directories... (leoGlobals)</vh>
<v t="ekr.20061029091811.37"><vh>computeGlobalConfigDir</vh></v>
<v t="ekr.20061029091811.38"><vh>computeHomeDir</vh></v>
<v t="ekr.20061029091811.39"><vh>computeLeoDir</vh></v>
<v t="ekr.20061029091811.40"><vh>computeLoadDir</vh></v>
<v t="ekr.20061029091811.41"><vh>computeStandardDirectories</vh></v>
<v t="ekr.20061029091811.42"><vh>startupEncoding</vh></v>
</v>
<v t="ekr.20061029091811.43"><vh>Reading and writing .leoRecentFiles.txt (g.app.config)</vh>
<v t="ekr.20061029091811.44"><vh>createRecentFiles</vh></v>
<v t="ekr.20061029091811.45"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061029091811.46"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061029091811.47"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20061029091811.48"><vh>New features</vh>
<v t="ekr.20061029091811.49"><vh>Created leoPymacs.py for interaction with pymacs</vh></v>
<v t="ekr.20061029091811.50"><vh>Further improvements to leoPymacs</vh>
<v t="ekr.20061029091811.51"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20061029091811.52"><vh>app.newLeoCommanderAndFrame</vh>
<v t="ekr.20061029091811.53"><vh>&lt;&lt; compute the window title &gt;&gt;</vh></v>
</v>
<v t="ekr.20061029091811.54"><vh>g.openWithFileName</vh></v>
<v t="ekr.20061029091811.55"><vh>run &amp; allies</vh>
<v t="ekr.20061029091811.56"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20061029091811.57"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20061029091811.58"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20061029091811.59"><vh>isValidPython</vh></v>
<v t="ekr.20061029091811.60"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20061029091811.51"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20061029091811.61"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20061029091811.62"><vh>getBatchScript</vh></v>
<v t="ekr.20061029091811.63"><vh>reportDirectories</vh></v>
</v>
</v>
<v t="ekr.20061029091811.64"><vh>Added forward-end-word/-extend-selection commands</vh>
<v t="ekr.20061029091811.65"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061029091811.66"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20061029091811.67"><vh>words</vh></v>
<v t="ekr.20061029091811.68"><vh>moveWordHelper</vh></v>
<v t="ekr.20061029091811.69"><vh>runEditCommandTest</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014"><vh>4.4.2 b3 projects</vh>
<v t="ekr.20061021144014.1"><vh>Bugs</vh>
<v t="ekr.20061021144014.2"><vh>Fixed crash when searching for headllines containing unicode chars</vh>
<v t="ekr.20061021144014.3"><vh>&lt;&lt; init the gui-independent ivars &gt;&gt;</vh>
<v t="ekr.20061021144014.4"><vh>&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.5"><vh>findWord</vh></v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
</v>
<v t="ekr.20061021144014.7"><vh>Fixed failed unit test</vh>
<v t="ekr.20061021144014.8"><vh>k.initAbbrev</vh></v>
</v>
<v t="ekr.20061021144014.9"><vh>Fixed bugs in cycle-all-focus command</vh>
<v t="ekr.20061021144014.10"><vh>cycleFocus</vh></v>
<v t="ekr.20061021144014.11"><vh>cycleAllFocus</vh></v>
<v t="ekr.20061021144014.12"><vh>selectTab</vh></v>
<v t="ekr.20061021144014.13"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20061021144014.14"><vh>cycleTabFocus</vh></v>
<v t="ekr.20061021144014.15"><vh>callAltXFunction</vh></v>
<v t="ekr.20061021144014.16"><vh>endCommand</vh></v>
<v t="ekr.20061021144014.17"><vh>c.traceFocus</vh></v>
<v t="ekr.20061021144014.18"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20061021144014.19"><vh>masterKeyHandler</vh>
<v t="ekr.20061021144014.20"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20061021144014.21"><vh>&lt;&lt; do key traces &gt;&gt;</vh></v>
<v t="ekr.20061021144014.22"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.23"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.24"><vh>&lt;&lt; handle keys without bindings &gt;&gt;</vh></v>
<v t="ekr.20061021144014.25"><vh>handleMiniBindings</vh></v>
</v>
<v t="ekr.20061021144014.26"><vh>c.get/request/set_focus</vh></v>
</v>
<v t="ekr.20061021144014.27"><vh>Fixed bug: with Alt-n keys</vh>
<v t="ekr.20061021144014.28"><vh>k.registerCommand</vh></v>
<v t="ekr.20061021144014.29"><vh>makeMasterGuiBinding</vh></v>
<v t="ekr.20061021144014.30"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20061021144014.31"><vh>printBindings &amp; helper</vh>
<v t="ekr.20061021144014.32"><vh>printBindingsHelper</vh></v>
</v>
<v t="ekr.20061021144014.33"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20061021144014.34"><vh>Fix bug in ops plugin</vh></v>
<v t="ekr.20061021144014.35"><vh>Fixed crasher on script button balloons</vh></v>
<v t="ekr.20061021144014.36"><vh>Fix bug: closing a window after removing a script button can crash</vh></v>
<v t="ekr.20061021144014.37"><vh>The end-of-script message no longer yanks focus from tabs</vh>
<v t="ekr.20061021144014.38"><vh>c.executeScript</vh>
<v t="ekr.20061021144014.39"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20061021144014.40"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.41"><vh>Fixed  warning if minibuffer command does not exist when making menus</vh>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.47"><vh>Fixed new unicode bug</vh>
<v t="ekr.20061021144014.48"><vh>Found: string.letters</vh>
<v t="ekr.20061021144014.5"><vh>findWord</vh></v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
<v t="ekr.20061021144014.49"><vh>insertNormalChar</vh></v>
<v t="ekr.20061021144014.50"><vh>doOp</vh></v>
<v t="ekr.20061021144014.51"><vh>appendToRegister</vh></v>
<v t="ekr.20061021144014.52"><vh>prependToRegister</vh></v>
<v t="ekr.20061021144014.53"><vh>copyRectangleToRegister</vh></v>
<v t="ekr.20061021144014.54"><vh>copyToRegister</vh></v>
<v t="ekr.20061021144014.55"><vh>incrementRegister</vh></v>
<v t="ekr.20061021144014.56"><vh>insertRegister</vh></v>
<v t="ekr.20061021144014.57"><vh>jumpToRegister</vh></v>
<v t="ekr.20061021144014.58"><vh>numberToRegister (not used)</vh></v>
<v t="ekr.20061021144014.59"><vh>pointToRegister</vh></v>
<v t="ekr.20061021144014.60"><vh>viewRegister</vh></v>
<v t="ekr.20061021144014.61"><vh>&lt;&lt; create press-buttonText-button command &gt;&gt;</vh></v>
<v t="ekr.20061021144014.62"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20061021144014.63"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
</v>
<v t="ekr.20061021144014.64"><vh>Found: string.digits</vh>
<v t="ekr.20061021144014.65"><vh>zapToCharacter</vh></v>
<v t="ekr.20061021144014.66" a="M"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.67"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.68"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="ekr.20061021144014.69"><vh>skip_id</vh></v>
<v t="ekr.20061021144014.70"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
<v t="ekr.20061021144014.71"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20061021144014.72"><vh>getDouble</vh></v>
<v t="ekr.20061021144014.73"><vh>getLong</vh></v>
<v t="ekr.20061021144014.74"><vh>is_c_id</vh></v>
<v t="ekr.20061021144014.75"><vh>match_word</vh></v>
<v t="ekr.20061021144014.76"><vh>skip_c_id</vh></v>
<v t="ekr.20061021144014.77"><vh>skip_id</vh></v>
<v t="ekr.20061021144014.78"><vh>skip_long</vh></v>
<v t="ekr.20061021144014.79"><vh>skipElispId</vh></v>
<v t="ekr.20061021144014.80"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20061021144014.81"><vh>universalDispatcher &amp; helpers</vh>
<v t="ekr.20061021144014.82"><vh>&lt;&lt; about repeat counts &gt;&gt;</vh></v>
<v t="ekr.20061021144014.83"><vh>executeNTimes</vh></v>
<v t="ekr.20061021144014.84"><vh>doControlU</vh></v>
</v>
<v t="ekr.20061021144014.85"><vh>scan_short_val</vh></v>
<v t="ekr.20061021144014.86"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="ekr.20061021144014.87"><vh>computeOldStyleShortcutKey</vh></v>
<v t="ekr.20061021144014.88"><vh>&lt;&lt; eliminate invalid characters &gt;&gt;</vh></v>
<v t="ekr.20061021144014.89"><vh>&lt;&lt; eliminate non-numbers &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.90"><vh>Found: string.</vh>
<v t="ekr.20061021144014.91" a="M"><vh>doNormalState</vh>
<v t="ekr.20061021144014.92"><vh>Valid regardless of latex mode</vh>
<v t="ekr.20061021144014.93"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="ekr.20061021144014.94"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.95"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.96"><vh>&lt;&lt; handle possible forth keyword &gt;&gt;</vh></v>
<v t="ekr.20061021144014.97"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.98"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="ekr.20061021144014.99"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
<v t="ekr.20061021144014.100"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.101"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="ekr.20061021144014.102"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="ekr.20061021144014.103"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.104"><vh>Vaid only in latex mode</vh>
<v t="ekr.20061021144014.105"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.106"><vh>Valid when not in latex_mode</vh>
<v t="ekr.20061021144014.107"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="ekr.20061021144014.108"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="ekr.20061021144014.109"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="ekr.20061021144014.110"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="ekr.20061021144014.111"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="ekr.20061021144014.112"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.113" a="M"><vh>getCwebWord</vh></v>
<v t="ekr.20061021144014.114" a="M"><vh>init_trace</vh></v>
<v t="ekr.20061021144014.115" a="M"><vh>sanitize_filename</vh></v>
<v t="ekr.20061021144014.116" a="M"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="ekr.20061021144014.117" a="M"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="ekr.20061021144014.66" a="M"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="ekr.20061021144014.118" a="M"><vh>definePatterns</vh></v>
<v t="ekr.20061021144014.119" a="M"><vh>autoCompleterStateHandler</vh></v>
<v t="ekr.20061021144014.120" a="M"><vh>directiveKind4 &amp; test</vh>
<v t="ekr.20061021144014.121"><vh>test_directiveKind4</vh></v>
</v>
<v t="ekr.20061021144014.122" a="M"><vh>test_isPlainKey</vh></v>
</v>
</v>
<v t="ekr.20061021144014.123"><vh>Made 'About Plugin' dialog scrollable</vh></v>
<v t="ekr.20061021144014.124"><vh>Removed unwanted key-state message</vh></v>
<v t="ekr.20061021144014.125"><vh>Removed datenodes.ini from cvs</vh></v>
<v t="ekr.20061021144014.126"><vh>Made sure all kill commands do a full recolor</vh>
<v t="ekr.20061021144014.127"><vh>killBufferCommandsClass (add docstrings)</vh>
<v t="ekr.20061021144014.128"><vh> ctor &amp; finishCreate</vh></v>
<v t="ekr.20061021144014.129"><vh> getPublicCommands</vh></v>
<v t="ekr.20061021144014.130"><vh>addToKillBuffer</vh></v>
<v t="ekr.20061021144014.131"><vh>backwardKillSentence</vh></v>
<v t="ekr.20061021144014.132"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20061021144014.133"><vh>clearKillRing</vh></v>
<v t="ekr.20061021144014.134"><vh>getClipboard</vh></v>
<v t="ekr.20061021144014.135"><vh>iterateKillBuffer</vh></v>
<v t="ekr.20061021144014.136"><vh>kill, killLine</vh></v>
<v t="ekr.20061021144014.137"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20061021144014.138"><vh>killSentence</vh></v>
<v t="ekr.20061021144014.139"><vh>killWs</vh></v>
<v t="ekr.20061021144014.140"><vh>yank</vh></v>
<v t="ekr.20061021144014.141"><vh>yankPop</vh></v>
<v t="ekr.20061021144014.65"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20061021144014.142"><vh>begin/endCommand</vh>
<v t="ekr.20061021144014.143"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20061021144014.144"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20061021144014.145"><vh>endCommand</vh></v>
</v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.149"><vh>Fixed bug in new colorizer</vh>
<v t="ekr.20061021144014.150"><vh>Edit Body submenu</vh>
<v t="ekr.20061021144014.151"><vh>convertAllBlanks</vh></v>
<v t="ekr.20061021144014.152"><vh>convertAllTabs</vh></v>
<v t="ekr.20061021144014.153"><vh>convertBlanks</vh></v>
<v t="ekr.20061021144014.154"><vh>convertTabs</vh></v>
<v t="ekr.20061021144014.155"><vh>createLastChildNode</vh></v>
<v t="ekr.20061021144014.156"><vh>dedentBody</vh></v>
<v t="ekr.20061021144014.157"><vh>extract</vh></v>
<v t="ekr.20061021144014.158"><vh>extractSection</vh>
<v t="ekr.20061021144014.159"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.160"><vh>extractSectionNames</vh>
<v t="ekr.20061021144014.161"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.162"><vh>findBoundParagraph</vh>
<v t="ekr.20061021144014.163"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.164"><vh>findMatchingBracket</vh>
<v t="ekr.20061021144014.165"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20061021144014.166"><vh>getBodyLines</vh></v>
<v t="ekr.20061021144014.167"><vh>indentBody</vh></v>
<v t="ekr.20061021144014.168"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20061021144014.169"><vh>getTime &amp; test</vh></v>
</v>
<v t="ekr.20061021144014.170"><vh>insert/removeComments</vh>
<v t="ekr.20061021144014.171"><vh>addComments</vh></v>
<v t="ekr.20061021144014.172"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20061021144014.173"><vh>reformatParagraph</vh>
<v t="ekr.20061021144014.174"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20061021144014.175"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20061021144014.176"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20061021144014.177"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.178"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20061021144014.178"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.179"><vh>setSelection</vh></v>
</v>
<v t="ekr.20061021144014.180"><vh>Removed set-mark-command and all calls to removeRKeys</vh>
<v t="ekr.20061021144014.181"><vh>Found: removeRKeys</vh>
<v t="ekr.20061021144014.137"><vh>killRegion &amp; killRegionSave &amp; helper</vh></v>
<v t="ekr.20061021144014.182"><vh>testinrange</vh></v>
<v t="ekr.20061021144014.183"><vh>indentRegion (not used: use c.indentBody instead)</vh></v>
<v t="ekr.20061021144014.184"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
</v>
<v t="ekr.20061021144014.185"><vh>Fixed body editor problems</vh>
<v t="ekr.20061021144014.186"><vh>masterClickHandler</vh></v>
<v t="ekr.20061021144014.11"><vh>cycleAllFocus</vh></v>
<v t="ekr.20061021144014.187"><vh>class leoTkinterBody</vh>
<v t="ekr.20061021144014.188"><vh> Birth &amp; death</vh>
<v t="ekr.20061021144014.189"><vh>tkBody. __init__</vh></v>
<v t="ekr.20061021144014.190"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20061021144014.191"><vh>tkBody.createControl</vh></v>
<v t="ekr.20061021144014.192"><vh>tkBody.createTextWidget</vh></v>
</v>
<v t="ekr.20061021144014.193"><vh>Editors</vh>
<v t="ekr.20061021144014.194"><vh>recolorWidget</vh></v>
<v t="ekr.20061021144014.195"><vh>create/select/unselect/Label</vh></v>
<v t="ekr.20061021144014.196"><vh>addEditor</vh>
<v t="ekr.20061021144014.197"><vh>&lt;&lt; create label and text widgets &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.198"><vh>setEditorColors</vh></v>
<v t="ekr.20061021144014.13"><vh>cycleEditorFocus</vh></v>
<v t="ekr.20061021144014.199"><vh>deleteEditor</vh></v>
<v t="ekr.20061021144014.200"><vh>onClick</vh></v>
<v t="ekr.20061021144014.201"><vh>selectEditor</vh>
<v t="ekr.20061021144014.202"><vh>&lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.203"><vh>selectMainEditor</vh></v>
<v t="ekr.20061021144014.204"><vh>updateEditors</vh></v>
</v>
<v t="ekr.20061021144014.205"><vh>tkBody.setColorFromConfig</vh></v>
<v t="ekr.20061021144014.206"><vh>tkBody.setFontFromConfig</vh></v>
<v t="ekr.20061021144014.146"><vh>onBodyChanged (tkBody)</vh>
<v t="ekr.20061021144014.147"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20061021144014.148"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.207"><vh>Focus (tkBody)</vh></v>
<v t="ekr.20061021144014.208"><vh>forceRecolor</vh></v>
<v t="ekr.20061021144014.209"><vh>Tk bindings (tkBbody)</vh>
<v t="ekr.20061021144014.210"><vh>Bounding box (Tk spelling)</vh></v>
<v t="ekr.20061021144014.211"><vh>Color tags (Tk spelling)</vh></v>
<v t="ekr.20061021144014.212"><vh>Configuration (Tk spelling)</vh></v>
<v t="ekr.20061021144014.213"><vh>Height &amp; width</vh></v>
<v t="ekr.20061021144014.214"><vh>Idle time...</vh></v>
<v t="ekr.20061021144014.215"><vh>Indices (leoTkinterBody)</vh>
<v t="ekr.20061021144014.216"><vh>adjustIndex</vh></v>
<v t="ekr.20061021144014.217"><vh>compareIndices</vh></v>
<v t="ekr.20061021144014.218"><vh>convertRowColumnToIndex</vh></v>
<v t="ekr.20061021144014.219"><vh>convertIndexToRowColumn</vh></v>
<v t="ekr.20061021144014.220"><vh>getImageIndex</vh></v>
<v t="ekr.20061021144014.221"><vh>tkIndex (internal use only)</vh></v>
</v>
<v t="ekr.20061021144014.222"><vh>Insert point</vh>
<v t="ekr.20061021144014.223"><vh>get/setPythonInsertionPoint</vh></v>
<v t="ekr.20061021144014.224"><vh>getInsertionPoint &amp; getBeforeInsertionPoint</vh></v>
<v t="ekr.20061021144014.225"><vh>getCharAtInsertPoint &amp; getCharBeforeInsertPoint</vh></v>
<v t="ekr.20061021144014.226"><vh>makeInsertPointVisible</vh></v>
<v t="ekr.20061021144014.227"><vh>setInsertionPointTo...</vh></v>
</v>
<v t="ekr.20061021144014.228"><vh>Menus</vh></v>
<v t="ekr.20061021144014.229"><vh>Selection</vh>
<v t="ekr.20061021144014.230"><vh>deleteTextSelection</vh></v>
<v t="ekr.20061021144014.231"><vh>getSelectedText</vh></v>
<v t="ekr.20061021144014.232"><vh>getTextSelection</vh></v>
<v t="ekr.20061021144014.233"><vh>getPythonTextSelection</vh></v>
<v t="ekr.20061021144014.234"><vh>setPythonTextSelection</vh></v>
<v t="ekr.20061021144014.235"><vh>hasTextSelection</vh></v>
<v t="ekr.20061021144014.236"><vh>selectAllText</vh></v>
<v t="ekr.20061021144014.237"><vh>setTextSelection (tkinterBody)</vh></v>
</v>
<v t="ekr.20061021144014.238"><vh>Text</vh>
<v t="ekr.20061021144014.239"><vh>delete...</vh></v>
<v t="ekr.20061021144014.240"><vh>get...</vh>
<v t="ekr.20061021144014.241"><vh>tkBody.getAllText</vh></v>
<v t="ekr.20061021144014.242"><vh>getCharAtIndex</vh></v>
<v t="ekr.20061021144014.243"><vh>getInsertLines</vh></v>
<v t="ekr.20061021144014.244"><vh>getSelectionAreas</vh></v>
<v t="ekr.20061021144014.245"><vh>getSelectionLines (tkBody)</vh></v>
<v t="ekr.20061021144014.246"><vh>getTextRange</vh></v>
</v>
<v t="ekr.20061021144014.247"><vh>Insert...</vh>
<v t="ekr.20061021144014.248"><vh>insertAtInsertPoint</vh></v>
<v t="ekr.20061021144014.249"><vh>insertAtEnd</vh></v>
<v t="ekr.20061021144014.250"><vh>insertAtStartOfLine</vh></v>
</v>
<v t="ekr.20061021144014.251"><vh>setSelectionAreas (tkinterBody)</vh></v>
</v>
<v t="ekr.20061021144014.252"><vh>Visibility &amp; scrolling</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.253"><vh>Fixed rst3 crash</vh></v>
<v t="ekr.20061021144014.254"><vh>Moved @import to top of doc/default.css</vh></v>
<v t="ekr.20061021144014.255"><vh>Fixed focus problem when double-clicking @url nodes</vh>
<v t="ekr.20061021144014.256"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20061021144014.257"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="ekr.20061021144014.258"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="ekr.20061021144014.259"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="ekr.20061021144014.260"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.261"><vh>onTreeClick</vh></v>
<v t="ekr.20061021144014.262"><vh>set_focus (app.gui)</vh></v>
</v>
</v>
<v t="ekr.20061021144014.263"><vh>Features</vh>
<v t="ekr.20061021144014.264"><vh>Removed .leoRecentFiles.txt from distribution and cvs</vh>
<v t="ekr.20061021144014.265"><vh>ctor (configClass)</vh></v>
<v t="ekr.20061021144014.266"><vh>g.app.config.readSettingsFiles</vh></v>
<v t="ekr.20061021144014.267"><vh>readRecentFilesFile</vh></v>
<v t="ekr.20061021144014.268"><vh>createRecentFiles</vh></v>
<v t="ekr.20061021144014.269"><vh>writeRecentFilesFile &amp; helper</vh>
<v t="ekr.20061021144014.270"><vh>writeRecentFilesFileHelper</vh></v>
</v>
</v>
<v t="ekr.20061021144014.271"><vh>Added minibuffer and Settings menus</vh>
<v t="ekr.20061021144014.272"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.273"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20061021144014.274"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20061021144014.275"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20061021144014.276"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061021144014.277"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20061021144014.278"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20061021144014.279"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20061021144014.280"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20061021144014.281"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20061021144014.282"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20061021144014.283"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20061021144014.284"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20061021144014.285"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20061021144014.286"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20061021144014.287"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20061021144014.288" a="M"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20061021144014.290"><vh>Created do-nothing command and tested binding to unicode character</vh>
<v t="ekr.20061021144014.291"><vh>doNothing</vh></v>
</v>
<v t="ekr.20061021144014.292"><vh>Toggling autocompleter and calltips now write to log (in red) instead of the statusLine</vh>
<v t="ekr.20061021144014.293"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20061021144014.294"><vh>Finished collapse-on-move-left</vh>
<v t="ekr.20061021144014.295"><vh>Move... (Commands)</vh>
<v t="ekr.20061021144014.296"><vh>demote</vh></v>
<v t="ekr.20061021144014.297"><vh>moveOutlineDown</vh>
<v t="ekr.20061021144014.298"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.299"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20061021144014.300"><vh>moveOutlineRight</vh></v>
<v t="ekr.20061021144014.301"><vh>moveOutlineUp</vh>
<v t="ekr.20061021144014.302"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.303"><vh>promote</vh></v>
</v>
</v>
<v t="ekr.20061021144014.304"><vh>Properly create Help menu on the Mac</vh>
<v t="ekr.20061021144014.305" a="M"><vh>createHelpMenuFromTable</vh></v>
<v t="ekr.20061021144014.306" a="M"><vh>getMacHelpMenu</vh></v>
</v>
<v t="ekr.20061021144014.307"><vh>'*command-name' in headline means convert '-' to blanks</vh></v>
<v t="ekr.20061021144014.308"><vh>Removed all references to commands from menu tables</vh>
<v t="ekr.20061021144014.309"><vh>regexp</vh></v>
<v t="ekr.20061021144014.310"><vh>capitalizeMinibufferMenuName</vh></v>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.311"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.312"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.313"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20061021144014.314"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20061021144014.315"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20061021144014.316"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20061021144014.317"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20061021144014.318"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.319"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20061021144014.320"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20061021144014.321"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20061021144014.322"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20061021144014.323"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20061021144014.324"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20061021144014.325"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20061021144014.326"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20061021144014.327"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.328"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20061021144014.329"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20061021144014.330"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20061021144014.331"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20061021144014.332"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20061021144014.333"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20061021144014.272"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20061021144014.273"><vh>defineCmdsMenuAbbrevTable</vh></v>
<v t="ekr.20061021144014.274"><vh>defineCmdsMenuBodyEditorsTable</vh></v>
<v t="ekr.20061021144014.275"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20061021144014.276"><vh>defineCmdsMenuCursorTable</vh></v>
<v t="ekr.20061021144014.277"><vh>defineCmdsMenuFocusTable</vh></v>
<v t="ekr.20061021144014.278"><vh>defineCmdsMenuMacroTable</vh></v>
<v t="ekr.20061021144014.279"><vh>defineCmdsMenuMinibufferTable</vh></v>
<v t="ekr.20061021144014.280"><vh>defineCmdsMenuPanesTable</vh></v>
<v t="ekr.20061021144014.281"><vh>defineCmdsMenuPickersTable</vh></v>
<v t="ekr.20061021144014.282"><vh>defineCmdsMenuRectanglesTable</vh></v>
<v t="ekr.20061021144014.283"><vh>defineCmdsMenuRegistersTable</vh></v>
<v t="ekr.20061021144014.284"><vh>defineCmdsMenuScrollTable</vh></v>
<v t="ekr.20061021144014.285"><vh>defineCmdsMenuSpellCheckTable</vh></v>
<v t="ekr.20061021144014.286"><vh>defineCmdsMenuTextTable</vh></v>
<v t="ekr.20061021144014.287"><vh>defineCmdsMenuToggleTable</vh></v>
</v>
<v t="ekr.20061021144014.334"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20061021144014.335"><vh>Add Open scripts.leo to help menu</vh>
<v t="ekr.20061021144014.336"><vh>openLeoScripts</vh></v>
<v t="ekr.20061021144014.289"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20061021144014.337"><vh>The spell tab now uses ctypes for Python 2.5</vh>
<v t="ekr.20061021144014.338"><vh>Spell classes</vh>
<v t="ekr.20061021144014.339"><vh>class spellCommandsClass</vh>
<v t="ekr.20061021144014.340"><vh>ctor</vh></v>
<v t="ekr.20061021144014.341"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20061021144014.342"><vh>openSpellTab</vh></v>
<v t="ekr.20061021144014.343"><vh>commands...</vh></v>
</v>
<v t="ekr.20061021144014.344"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20061021144014.345"><vh>Birth &amp; death</vh>
<v t="ekr.20061021144014.346"><vh>spellTab.__init__</vh></v>
<v t="ekr.20061021144014.347"><vh>init_aspell</vh></v>
<v t="ekr.20061021144014.348"><vh>createSpellTab</vh>
<v t="ekr.20061021144014.349"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20061021144014.350"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20061021144014.351"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.352"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20061021144014.353"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20061021144014.354"><vh>Buttons</vh>
<v t="ekr.20061021144014.355"><vh>onAddButton</vh></v>
<v t="ekr.20061021144014.356"><vh>onIgnoreButton</vh></v>
<v t="ekr.20061021144014.357"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20061021144014.358"><vh>onFindButton</vh></v>
<v t="ekr.20061021144014.359"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20061021144014.360"><vh>Commands</vh>
<v t="ekr.20061021144014.361"><vh>add</vh></v>
<v t="ekr.20061021144014.362"><vh>change</vh></v>
<v t="ekr.20061021144014.363"><vh>find</vh></v>
<v t="ekr.20061021144014.364"><vh>hide</vh></v>
<v t="ekr.20061021144014.365"><vh>ignore</vh></v>
</v>
<v t="ekr.20061021144014.366"><vh>Helpers</vh>
<v t="ekr.20061021144014.367"><vh>bringToFront</vh></v>
<v t="ekr.20061021144014.368"><vh>fillbox</vh></v>
<v t="ekr.20061021144014.369"><vh>findNextMisspelledWord</vh>
<v t="ekr.20061021144014.370"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.6"><vh>findNextWord</vh></v>
<v t="ekr.20061021144014.371"><vh>getSuggestion</vh></v>
<v t="ekr.20061021144014.372"><vh>onMap</vh></v>
<v t="ekr.20061021144014.373"><vh>onSelectListBox</vh></v>
<v t="ekr.20061021144014.374"><vh>update</vh></v>
<v t="ekr.20061021144014.375"><vh>updateButtons</vh></v>
</v>
</v>
<v t="ekr.20061021144014.376"><vh>class AspellClass</vh>
<v t="ekr.20061021144014.377"><vh>Birth &amp; death</vh>
<v t="ekr.20061021144014.378"><vh>__init__</vh></v>
<v t="ekr.20061021144014.379"><vh>getAspell</vh></v>
<v t="ekr.20061021144014.380"><vh>getAspellWithCtypes</vh>
<v t="ekr.20061021144014.381"><vh>&lt;&lt; define and configure aspell entry points &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20061021144014.382"><vh>processWord</vh></v>
<v t="ekr.20061021144014.383"><vh>suggestions</vh></v>
<v t="ekr.20061021144014.384"><vh>updateDictionary</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.385"><vh>Simulated x-windows middle-button paste</vh>
<v t="ekr.20061021144014.386"><vh>Request</vh></v>
<v t="ekr.20061021144014.387"><vh>Fix new middle-button problem</vh></v>
<v t="ekr.20061021144014.42"><vh>createMenuEntries</vh>
<v t="ekr.20061021144014.43"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20061021144014.44"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20061021144014.45"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.46"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20061021144014.190"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20061021144014.388"><vh>OnPaste (To support middle-button paste)</vh></v>
<v t="ekr.20061021144014.186"><vh>masterClickHandler</vh></v>
<v t="ekr.20061021144014.389"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20061021144014.390"><vh>copyText</vh></v>
<v t="ekr.20061021144014.391"><vh>cutText</vh></v>
<v t="ekr.20061021144014.392"><vh>pasteText</vh></v>
</v>
</v>
</v>
<v t="ekr.20061021144014.393"><vh>Plugins</vh>
<v t="ekr.20061021144014.394"><vh>Fixed keyBindings plugin</vh></v>
<v t="ekr.20061021144014.395"><vh>The scripting plugin now creates a delete-x-script-button command for each script button</vh></v>
<v t="ekr.20061021144014.396"><vh>Fixed (sorta) the nodenavigator plugin</vh></v>
<v t="ekr.20061021144014.397"><vh>Rewrote the multifile plugin for the 4.x code base.</vh></v>
<v t="ekr.20061021144014.398"><vh>Replaced __name__ with __plugin_name__ in four plugins</vh></v>
<v t="ekr.20061021144014.399"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20061021144014.400"><vh>Fixed bugs in multi-file plugin</vh></v>
<v t="ekr.20061021144014.401"><vh>More work on multifile plugin</vh></v>
<v t="ekr.20061021144014.402"><vh>Fix bug in shortcut_button plugin</vh></v>
</v>
<v t="ekr.20061021144014.403"><vh>Settings</vh>
<v t="ekr.20061021144014.404"><vh>Made unlimited undo the default</vh></v>
<v t="ekr.20061021144014.405"><vh>Added @bool select_all_text_when_editing_headlines</vh>
<v t="ekr.20061021144014.406"><vh>setEditLabelState</vh></v>
<v t="ekr.20061021144014.407"><vh>editLabel</vh></v>
<v t="ekr.20061021144014.408"><vh>c.insertHeadline</vh></v>
<v t="ekr.20061021144014.409"><vh>c.editPosition</vh></v>
</v>
<v t="ekr.20061021144014.410"><vh>Added bindings to toggle-autocompleter and toggle-calltips</vh></v>
<v t="ekr.20061021144014.411"><vh>Added 'Candidates for myLeoSettings.leo' to leoSettings.leo</vh></v>
<v t="ekr.20061021144014.412"><vh>Recent changes to settings</vh></v>
<v t="ekr.20061021144014.413"><vh>Added @boo insert_new_nodes_at_end</vh>
<v t="ekr.20061021144014.408"><vh>c.insertHeadline</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20061021144014"></t>
<t tx="ekr.20061021144014.1"></t>
<t tx="ekr.20061021144014.2">leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\unitTest.leo
FAILED (failures=1)
UnicodeDecodeError Exception in Tk callback
  Function: &lt;function masterBindKeyCallback at 0x018BD970&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x02B0B5F8&gt;,)
  Event type: KeyPress (type num: 2)
  
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2118, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 3133, in masterKeyHandler
    return k.getArg(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2755, in getArg
    if handler: handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7191, in searchWithPresentOptions
    self.generalSearchHelper(k.arg)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7066, in generalSearchHelper
    self.finder.findNextCommand()
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7676, in findNextCommand
    self.findNext()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 684, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 711, in findNextMatch
    pos, newpos = self.search()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 746, in search
    regexp=self.pattern_match,word=self.whole_word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 780, in searchHelper
    pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 856, in plainHelper
    elif self.matchWord(s,k,pattern):
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 871, in matchWord
    s[i-1] not in self.word_chars or
UnicodeDecodeError: 'ascii' codec can't decode byte 0x83 in position 52: ordinal not in range(128)

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 49425
    state: 0
    time: 17007655
    type: 2
    widget: .21619056.21619656.24867464.minibuffer
    width: ??
    x: 526
    x_root: 782
    y: -648
    y_root: 240

</t>
<t tx="ekr.20061021144014.3">self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated (in the subclass by update_ivars) just before doing any find.
@c

&lt;&lt; do dummy initialization to keep Pychecker happy &gt;&gt;

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = None # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos &gt;= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
</t>
<t tx="ekr.20061021144014.4">if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None
</t>
<t tx="ekr.20061021144014.5">def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            while i &lt; len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1]))
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()

</t>
<t tx="ekr.20061021144014.6"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and not g.isWordChar1(line[i]):
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and g.isWordChar(line[j]):
                j += 1
            word = line[i:j]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.</t>
<t tx="ekr.20061021144014.7">@nocolor

FAIL: @test k.inverseCommandsDict is inverse of c.commandsDict
AssertionError: cl not in inverseCommandsDict.values()

I just hacked the unit test not to complain about abbreviations.
Another solution would be to allow the values of k.inverseCommandsDict to be lists.</t>
<t tx="ekr.20061021144014.8">def initAbbrev (self):
    
    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d.keys():
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev: %s: unknown command name: %s' %
                (key,commandName),color='blue')
</t>
<t tx="ekr.20061021144014.9">@

The logic in cycleAllFocus is now much cleaner.
The cycle focus commands work in the minibuffer *only* if not tab-completion is done.
I think this is the old, horrible problems with Pmw focus: it's a very small nit.</t>
<t tx="ekr.20061021144014.10">def cycleFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget
   
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i &gt;= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body
    
    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)
    
    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane</t>
<t tx="ekr.20061021144014.11">editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        # g.trace(self.editWidgetCount,n)
        if n &gt; 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount &gt; n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n &gt; 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount &gt; n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = 1 ; self.logWidgetCount = 0
        
    if trace: print 'old: %10s new: %10s' % (w_name(w),w_name(pane))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)</t>
<t tx="ekr.20061021144014.12">def selectTab (self,tabName,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName,wrap=wrap)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
</t>
<t tx="ekr.20061021144014.13">def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) &gt; 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.selectEditor(w2)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
</t>
<t tx="ekr.20061021144014.14">def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() &gt; 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return </t>
<t tx="ekr.20061021144014.15">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    
    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.16">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20061021144014.17">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        print '%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8)
</t>
<t tx="ekr.20061021144014.18">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if trace: print \
        'requested',c.widget_name(c.requestedFocusWidget),\
        'present',c.widget_name(c.hasFocusWidget)
    
    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        if trace: print 'no change.',c.widget_name(w)
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        if trace: print '*'*20,'oops: moving to body pane.'
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
</t>
<t tx="ekr.20061021144014.19">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    &lt;&lt; define vars &gt;&gt;

    if keysym in special_keys:
        return None

    &lt;&lt; do key traces &gt;&gt;

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;
        
    &lt;&lt; handle per-pane bindings &gt;&gt;
    &lt;&lt; handle keys without bindings &gt;&gt;
</t>
<t tx="ekr.20061021144014.20">k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
    
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
</t>
<t tx="ekr.20061021144014.21">self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(
        # 'keysym',repr(event.keysym or ''),
        'stroke',repr(stroke),
        'state',state,
        'unboundKeyAction',k.unboundKeyAction)
</t>
<t tx="ekr.20061021144014.22"># First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
</t>
<t tx="ekr.20061021144014.23">key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(g.app.gui.isTextWidget(w),w_name,key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
</t>
<t tx="ekr.20061021144014.24">if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
    # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif event and event.keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    # g.trace(stroke,event.char,event.keysym)
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20061021144014.25">def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
</t>
<t tx="ekr.20061021144014.26">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
        c.traceFocus(w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
</t>
<t tx="ekr.20061021144014.27">@

@command whaterver @key Alt-1 didn't work
Actually, no Alt-n keys worked for n in (1,2,3,4,5) in any context.

Happily, the problem was a confusion about what Alt-1 means.
Apparently it means Alt-Button-1 rather than Alt-Key-1.

The solution was to insert an explicit Key- prefix in k.tkBindingFromStroke.
I also made a minor mod to printBindings.</t>
<t tx="ekr.20061021144014.28">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = verbose and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                if stroke: break
        else: stroke = None
  
    if stroke:
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
             g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')
                
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break</t>
<t tx="ekr.20061021144014.29">def makeMasterGuiBinding (self,stroke,w=None):
    
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    
    k = self ; c = k.c ; f = c.frame
   
    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)
    
    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        widgets=(c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)
    
    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
</t>
<t tx="ekr.20061021144014.30">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    # g.trace('&lt;%s&gt;' % stroke)
    return '&lt;%s&gt;' % stroke
</t>
<t tx="ekr.20061021144014.31">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)
            
    # Print keys by type:
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        g.es('%s %s' % (sep, prefix),tabName=tabName)
        self.printBindingsHelper(data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    g.es('%s %s' % (sep, 'Plain Keys',),tabName=tabName)
    self.printBindingsHelper(data,n1,n2,prefix=None)
    state = k.unboundKeyAction 
    k.showStateAndMode()
</t>
<t tx="ekr.20061021144014.32">def printBindingsHelper (self,data,n1,n2,prefix):
        
    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.
    
    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) &gt;  1]
        # The list of all other items.
                
    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
</t>
<t tx="ekr.20061021144014.33">def prettyPrintKey (self,stroke,brief=False):
    
    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.tkBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'&lt;%s&gt;' % s)
</t>
<t tx="ekr.20061021144014.34">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3956836

p.clone(p) -&gt; p.clone() in the big reorg.
</t>
<t tx="ekr.20061021144014.35">http://sourceforge.net/forum/message.php?msg_id=3958333
By: mstarzyk

I get the following exception while opening a leo file:

Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoGlobals.py", line 2441, in doHook
    return f(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 69, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 48, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 193, in onCreate
    sc.createAllButtons()
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 249,
in createAllButtons
    self.createAtButtonButton(p)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 316,
in createAtButtonButton
    b = self.createAtButtonIconButton(p,buttonText,statusLine,shortcut)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 588,
in createAtButtonIconButton
    b = self.createIconButton(text=buttonText,statusLine=statusLine,bg=bg)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 431,
in createIconButton
    self.createBalloon(b,statusLine)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 459,
in createBalloon
    balloon.bind(w,label)
  File "C:\Program Files\Leo\extensions\Pmw\Pmw_1_2\lib\PmwBalloon.py", line
76, in bind
    enterId = widget.bind('&lt;Enter&gt;',
AttributeError: 'NoneType' object has no attribute 'bind'

@nocolor

This is strange: I never have a problem with it.
The fix: don't call balloon.bind if balloon is None.</t>
<t tx="ekr.20061021144014.36"></t>
<t tx="ekr.20061021144014.37">@nocolor

Do *not* bother with trying to preserve the focus.
Instead, the 'end of script' message should just go to whatever log pane is on top.

@color</t>
<t tx="ekr.20061021144014.38">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    &lt;&lt; redirect output &gt;&gt;
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally: # New in 4.3 beta 2: unredirect output last.
        &lt;&lt; unredirect output &gt;&gt;
</t>
<t tx="ekr.20061021144014.39">if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20061021144014.40">if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
</t>
<t tx="ekr.20061021144014.41">@ The warning was disabled due to a programming error (not not)
Enabling this found two errors: view-lossage (missing comma) and
find-with-present-options --&gt; search-with-present-options.</t>
<t tx="ekr.20061021144014.42">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
</t>
<t tx="ekr.20061021144014.43">if type(data) == type(''):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&amp;','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data
            
        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data</t>
<t tx="ekr.20061021144014.44"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
</t>
<t tx="ekr.20061021144014.45">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
</t>
<t tx="ekr.20061021144014.46">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
</t>
<t tx="ekr.20061021144014.47">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3957980
By: dcbbcd

This was a major effort.

What I did:
    
- Defined g.isWordChar in terms of ch.isalnum()

- Replace almost all instances of string.letters and string.digits by calls to
  ch.isalnum(), ch.isalpha(), ch.isdigit(), etc.
  
- Similarly, replaced word_chars.

- The new code uses string literals only for

a) small constants like '+-' and
b) constants in a very limited context, as in the input to regexp.

To do: look for string.printable

@color</t>
<t tx="ekr.20061021144014.48"># most uses of these should be converted to g.isWordChar.</t>
<t tx="ekr.20061021144014.49">def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = g.app.gui.getSelectedText(w) + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = g.app.gui.getSelectedText(w)
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = g.app.gui.getSelectedText(w)
        if keysym == 'parenleft':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20061021144014.50">def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel &lt;= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','&lt;=','&gt;=','&lt;','&gt;','&lt;&gt;','*','**','+','&amp;','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '&gt;&gt;':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '&lt;&lt;':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
</t>
<t tx="ekr.20061021144014.51">def appendToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('append-to-reg')
    
    if state == 0:
        k.setLabelBlue('Append to register: ',protect=True)
        k.setState('append-to-reg',1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = val + w.get('sel.first','sel.last')
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.52">def prependToRegister (self,event):
    
    '''Prompt for a register name and prepend the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('prepend-to-reg')
    
    if state == 0:
        k.setLabelBlue('Prepend to register: ',protect=True)
        k.setState('prepend-to-reg',1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = w.get('sel.first','sel.last') + val
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.53">def copyRectangleToRegister (self,event):
    
    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 &lt;= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.54">def copyToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('copy-to-reg')
    
    if state == 0:
        k.commandName = 'copy-to-register'
        k.setLabelBlue('Copy to register: ',protect=True)
        k.setState('copy-to-reg',1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                try:
                    val = w.get('sel.first','sel.last')
                except Exception:
                    g.es_exception()
                    val = ''
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.55">def incrementRegister (self,event):
    
    '''Prompt for a register name and increment its value if it has a numeric value.'''
    
    c = self.c ; k = self.k ; state = k.getState('increment-reg')
    
    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.56">def insertRegister (self,event):
    
    '''Prompt for a register name and and insert the value of another register into its contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('insert-reg')
    
    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.57">def jumpToRegister (self,event):
    
    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            if self._checkIfRectangle(event): return
            key = event.keysym.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.mark_set('insert',val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.58">@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):
    
    k = self.k ; state = k.getState('number-to-reg')
    
    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            # self.registers[event.keysym.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
</t>
<t tx="ekr.20061021144014.59">def pointToRegister (self,event):
    
    '''Prompt for a register name and put a value indicating the insert point in the register.'''
    
    c = self.c ; k = self.k ; state = k.getState('point-to-reg')
    
    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = w.index('insert')
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.60">def viewRegister (self,event):
    
    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')
    
    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.61">aList = [g.choose(ch.isalnum(),ch,'-') for ch in buttonText]

buttonCommandName = ''.join(aList)
buttonCommandName = buttonCommandName.replace('--','-')
buttonCommandName = 'press-%s-button' % buttonCommandName.lower()

# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName,None,executeScriptCallback,pane='button',verbose=False)
</t>
<t tx="ekr.20061021144014.62">def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
</t>
<t tx="ekr.20061021144014.63">def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        accel_ch = (string.digits + string.letters.upper()) # Not a unicode problem.
        label = "%s %s" % (accel_ch[i-2],g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
</t>
<t tx="ekr.20061021144014.64"></t>
<t tx="ekr.20061021144014.65">def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        c = k.c
        ch = event and event.char
        k.resetLabel()
        k.clearState()
        if len(event.char) != 0 and not ch.isspace():
            i = w.search(ch,'insert',stopindex='end')
            if i != -1:
                s = w.get('insert','%s' % i)
                self.addToKillBuffer(s)
                w.delete('insert','%s' % i)
</t>
<t tx="ekr.20061021144014.66">i = g.skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i].isdigit():
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
</t>
<t tx="ekr.20061021144014.67">while i &lt; len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i &lt; len(s) and s[i].isdigit():
            i += 1
        if j &lt; i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
</t>
<t tx="ekr.20061021144014.68">new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i &lt; len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1

    if j &lt; i:
        pass
    else:
        valid = False
</t>
<t tx="ekr.20061021144014.69">def skip_id(self,s,i,chars=None):

    n = len(s)
    chars = chars and g.toUnicode(chars,encoding='ascii') or u''
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
            i += 1
    return i
</t>
<t tx="ekr.20061021144014.70">if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i &gt; -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1].isdigit():
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
</t>
<t tx="ekr.20061021144014.71">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
</t>
<t tx="ekr.20061021144014.72">def getDouble (self):

    self.skipWs()
    i = self.fileIndex ; buf = self.fileBuffer
    floatChars = 'eE.+-'
    n = len(buf)
    while i &lt; n and (buf[i].isdigit() or buf[i] in floatChars):
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting float constant")
    val = float(buf[self.fileIndex:i])
    self.fileIndex = i
    return val
</t>
<t tx="ekr.20061021144014.73">def getLong (self):

    self.skipWs() # guarantees at least one more character.
    i = self.fileIndex
    if self.fileBuffer[i] == u'-':
        i += 1
    n = len(self.fileBuffer)
    while i &lt; n and self.fileBuffer[i].isdigit():
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting int constant")
    val = int(self.fileBuffer[self.fileIndex:i])
    self.fileIndex = i
    return val
</t>
<t tx="ekr.20061021144014.74">def is_c_id(ch):

    return g.isWordChar(ch)

</t>
<t tx="ekr.20061021144014.75">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
</t>
<t tx="ekr.20061021144014.76">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20061021144014.77">def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i</t>
<t tx="ekr.20061021144014.78">def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or (not s[i].isdigit() and s[i] not in u'+-'):
        return i, None
    j = i
    if s[i] in u'+-': # Allow sign before the first digit
        i +=1
    while i &lt; n and s[i].isdigit():
        i += 1
    try: # There may be no digits.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20061021144014.79">def skipElispId (self,s,i):

    n = len(s)
    while i &lt; n and g.isWordChar(s[i]):
        i += 1
    return i
</t>
<t tx="ekr.20061021144014.80">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
            
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)
</t>
<t tx="ekr.20061021144014.81">def universalDispatcher (self,event):
    
    '''Handle accumulation of universal argument.'''
    
    &lt;&lt; about repeat counts &gt;&gt;

    k = self ; state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = event.keysym
            # Stroke is &lt;Key&gt; for plain keys, &lt;Control-u&gt; (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '&lt;Key&gt;' and (keysym.isdigit() or keysym == u'-'):
            k.updateLabel(event)
        elif stroke == '&lt;Key&gt;' and keysym in (
            'Alt_L','Alt_R','Shift_L','Shift_R','Control_L','Control_R'):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '&lt;Control-x&gt;':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
</t>
<t tx="ekr.20061021144014.82">@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
</t>
<t tx="ekr.20061021144014.83">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)
</t>
<t tx="ekr.20061021144014.84">def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
</t>
<t tx="ekr.20061021144014.85"># This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):
    
    
    if i &gt;= len(s) or not s[i].isdigit():
        return i, -1
    j = i
    while i &lt; len(s) and s[i].isdigit():
        i += 1
    val = int(s[j:i])
    # g.trace(s[j:i],val)
    return i, val</t>
<t tx="ekr.20061021144014.86">def canonicalizeMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch.isalnum()])
    
def canonicalizeTranslatedMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch not in u'&amp; \t\n\r'])

</t>
<t tx="ekr.20061021144014.87">def computeOldStyleShortcutKey (self,s):
    
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    
    return ''.join([ch for ch in s.strip().lower() if ch.isalnum()])
</t>
<t tx="ekr.20061021144014.88">e = self.id_entry
s = e.get().strip()
i = 0 ; ok = True
while i &lt; len(s):
    ch = s[i]
    if not ch.isalnum():
        e.delete(str(i))
        s = e.get()
        ok = False
    else:
        i += 1
if not ok: return
</t>
<t tx="ekr.20061021144014.89">e = self.number_entry
s = e.get().strip()

i = 0
while i &lt; len(s):
    ch = s[i]
    if not ch.isdigit():
        e.delete(str(i))
        s = e.get()
    else:
        i += 1
</t>
<t tx="ekr.20061021144014.90"></t>
<t tx="ekr.20061021144014.91">def doNormalState (self,s,i):
    
    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&amp;&lt;&gt;' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&amp;*()_+-={}|[];':\",./&lt;&gt;?")
    ):
        &lt;&lt; handle possible keyword &gt;&gt;
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        &lt;&lt; handle at keyword &gt;&gt;
    elif g.match(s,i,self.single_comment_start):
        &lt;&lt; handle single-line comment &gt;&gt;
    elif g.match(s,i,self.block_comment_start):
        &lt;&lt; start block comment &gt;&gt;
    elif ch == '%' and self.language=="cweb":
        &lt;&lt; handle latex line &gt;&gt;
    elif self.language=="latex":
        &lt;&lt; handle latex normal character &gt;&gt;
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        &lt;&lt; handle string &gt;&gt;
    elif ch == '#' and self.has_pp_directives:
        &lt;&lt; handle C preprocessor line &gt;&gt;
    elif self.language == "php" and (g.match(s,i,"&lt;") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        &lt;&lt; handle special php keywords &gt;&gt;
    elif ch == ' ':
        &lt;&lt; handle blank &gt;&gt;
    elif ch == '\t':
        &lt;&lt; handle tab &gt;&gt;
    else:
        &lt;&lt; handle normal character &gt;&gt;

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress &lt; i)
    return i,state
</t>
<t tx="ekr.20061021144014.92"></t>
<t tx="ekr.20061021144014.93">if self.language == "latex":
    &lt;&lt; handle possible latex keyword &gt;&gt;
elif self.language == "html":
    &lt;&lt; handle possible html keyword &gt;&gt;
elif self.language == "forth":
    &lt;&lt; handle possible forth keyword &gt;&gt;
else:
    &lt;&lt; handle general keyword &gt;&gt;
i = j
</t>
<t tx="ekr.20061021144014.94">if g.match(s,i,"\\"):
    if i + 1 &lt; len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
</t>
<t tx="ekr.20061021144014.95">if g.match(s,i,"&lt;!---") or g.match(s,i,"&lt;!--"):
    if g.match(s,i,"&lt;!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"&lt;"):
    if g.match(s,i,"&lt;/"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&amp;"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/&gt;"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,"&gt;"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
</t>
<t tx="ekr.20061021144014.96">j = self.skip_id(s,i+1,chars="`~!@#$%^&amp;*()-_=+[]{};:'\\\",./&lt;&gt;?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
</t>
<t tx="ekr.20061021144014.97">if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
</t>
<t tx="ekr.20061021144014.98">if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@&lt;"):
        &lt;&lt; handle cweb ref or def &gt;&gt;
    else:
        word = self.getCwebWord(s,i)
        if word:
            &lt;&lt; Handle cweb control word &gt;&gt;
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
</t>
<t tx="ekr.20061021144014.99">self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@&gt;=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@&gt;",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
</t>
<t tx="ekr.20061021144014.100"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
    j = s.find("@&gt;",i)
    if j &gt; -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
</t>
<t tx="ekr.20061021144014.101"># print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i&gt;0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
</t>
<t tx="ekr.20061021144014.102">k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
</t>
<t tx="ekr.20061021144014.103">self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
</t>
<t tx="ekr.20061021144014.104"></t>
<t tx="ekr.20061021144014.105">if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.106"></t>
<t tx="ekr.20061021144014.107"># g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
</t>
<t tx="ekr.20061021144014.108"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
</t>
<t tx="ekr.20061021144014.109">if g.match(s.lower(),i,"&lt;?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?&gt;"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
</t>
<t tx="ekr.20061021144014.110">if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.111">if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.112"># self.tag("normal",i,i+1)
i += 1
</t>
<t tx="ekr.20061021144014.113">def getCwebWord (self,s,i):
    
    # g.trace(g.get_line(s,i))
    if not g.match(s,i,"@"):
        return None
    
    ch1 = ch2 = word = None
    if i + 1 &lt; len(s): ch1 = s[i+1]
    if i + 2 &lt; len(s): ch2 = s[i+2]

    if g.match(s,i,"@**"):
        word = "@**"
    elif not ch1:
        word = "@"
    elif not ch2:
        word = s[i:i+2]
    elif (
        (ch1 in string.ascii_letters and not ch2 in string.ascii_letters) or # single-letter control code
        ch1 not in string.ascii_letters # non-letter control code
    ):
        word = s[i:i+2]

    # if word: g.trace(word)
        
    return word
</t>
<t tx="ekr.20061021144014.114">def init_trace(args,echo=1):

    t = app.trace_list
    args = g.get_Sherlock_args(args)

    for arg in args:
        if arg[0] in string.ascii_letters: prefix = '+'
        else: prefix = arg[0] ; arg = arg[1:]
        
        if prefix == '?':
            print "trace list:", t
        elif prefix == '+' and not arg in t:
            t.append(string.lower(arg))
            if echo:
                print "enabling:", arg
        elif prefix == '-' and arg in t:
            t.remove(string.lower(arg))
            if echo:
                print "disabling:", arg
        else:
            print "ignoring:", prefix + arg
</t>
<t tx="ekr.20061021144014.115">def sanitize_filename(s):

    """Prepares string s to be a valid file name:
    
    - substitute '_' whitespace and characters used special path characters.
    - eliminate all other non-alphabetic characters.
    - strip leading and trailing whitespace.
    - return at most 128 characters."""

    result = ""
    for ch in s.strip():
        if ch in string.ascii_letters:
            result += ch
        elif ch in string.whitespace: # Translate whitespace.
            result += '_'
        elif ch in ('.','\\','/',':'): # Translate special path characters.
            result += '_'
    while 1:
        n = len(result)
        result = result.replace('__','_')
        if len(result) == n:
            break
    result = result.strip()
    return result [:128]
</t>
<t tx="ekr.20061021144014.116">i = g.skip_ws(s,i)
if g.match(s,i,"@*") or g.match(s,i,"@ "): kind = at_doc
elif g.match(s,i,"@&lt;"): i, kind, end = self.skip_section_name(s,i)
elif g.match(s,i,"@@"): kind = at_at
elif g.match_word(s,i,"@c") or g.match_word(s,i,"@p"): kind = at_code
elif i &lt; len(s) and s[i] == '@':
    if   i + 1 &gt;= len(s): kind = at_doc
    elif i + 1 &lt; len(s) and s[i+1] not in string.ascii_letters:
        kind = at_web
    else: kind = at_other # Set kind later
else: kind = plain_line
</t>
<t tx="ekr.20061021144014.117">self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}
    
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns
    
    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.
    
    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective
                
    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword
    
    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword
        
    if self.language == "php":
        dict1 ['&lt;'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword
    
    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["&lt;&lt;"] = self.doPossibleSectionRefOrDef
        
    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
    
    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
</t>
<t tx="ekr.20061021144014.118">def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars </t>
<t tx="ekr.20061021144014.119">def autoCompleterStateHandler (self,event):
    
    c = self.c ; k = self.k
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = event and event.keysym
    ch = event and event.char or ''
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in ('space','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == 'period':
        self.chain()
    elif keysym == 'question':
        self.info()
    elif keysym == 'exclam':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20061021144014.120">def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if s[i+1] not in string.ascii_letters:
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
</t>
<t tx="ekr.20061021144014.121">def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20061021144014.122">def test_isPlainKey (self):
    
    import string
    
    k = c.k # self is a dummy argument
    
    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)
        
    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
</t>
<t tx="ekr.20061021144014.123">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3960993

I happen to select Plugins-&gt;Scripting and the "About Scripting" window opened...a
huge, long, "about" window with no scroll-bars that was taller than my screen.

Can the "About" info be put into a resizable window (with scroll-bars) instead,
with a reasonable initial size?

Kam-Yung

</t>
<t tx="ekr.20061021144014.124">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3961623
By: vpe

Leo periodically prints 'Key state: Insert' message in the status area even
though I never change insert mode. It does not seem to be necessary and it destroys
UNL info. I get this message when I open new file, insert new node, type (,
type . in Python nodes, and probably on other events.

To get rid of it, I added one line to showStateAndMode(self) in
Code--&gt;@thin leoKeys.py--&gt;class keyHandlerClass--&gt;Input
State--&gt;showStateAndMode

....if hasattr(frame,'clearStatusLine'):
........if not state.capitalize()=='Insert': # &lt;---- added
............frame.clearStatusLine()
............put = frame.putStatusLine
............put('Key state: ',color='blue')
............put('%s' % state.capitalize())

There should be a more intelligent solution. 


Also, command set-overwrite-state works but generates a Tk error.

specs:
Leo 4.4.2 beta 2, build  1.69 , October 9, 2006
Python 2.5.0, Tk 8.4.12, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4
</t>
<t tx="ekr.20061021144014.125">@nocolor

No longer needed now that the datenodes plugins gets settings from cvs.</t>
<t tx="ekr.20061021144014.126">@ To force a recolor there must be a non-None undoType passed to kill.
or an explicit call to self.c.frame.body.forceFullRecolor() before calling endCommand.
</t>
<t tx="ekr.20061021144014.127">class killBufferCommandsClass (baseEditCommandsClass):
    
    '''A class to manage the kill buffer.'''

    @others
</t>
<t tx="ekr.20061021144014.128">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):
    
    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
    
    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
</t>
<t tx="ekr.20061021144014.129">def getPublicCommands (self):
    
    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20061021144014.130">def addToKillBuffer (self,text):
    
    killKeys =(
        '&lt;Control-k&gt;', '&lt;Control-w&gt;',
        '&lt;Alt-d&gt;', '&lt;Alt-Delete', '&lt;Alt-z&gt;', '&lt;Delete&gt;',
        '&lt;Control-Alt-w&gt;')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
</t>
<t tx="ekr.20061021144014.131">def backwardKillSentence (self,event):
    
    '''Kill the previous sentence.'''
    
    w = self.editWidget(event)
    if not w: return

    i = w.search('.','insert',backwards=True,stopindex='1.0')

    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='backward-kill-sentence')
</t>
<t tx="ekr.20061021144014.132">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

</t>
<t tx="ekr.20061021144014.133">def clearKillRing (self,event=None):
    
    '''Clear the kill ring.'''
    
    self.killBuffer = []
</t>
<t tx="ekr.20061021144014.134">def getClipboard (self,w):

    try:
        ctxt = w.selection_get(selection='CLIPBOARD')
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except: pass

    return None
</t>
<t tx="ekr.20061021144014.135">def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
</t>
<t tx="ekr.20061021144014.136">def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    w.delete(frm,to)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    self.kill(event,'insert linestart','insert lineend+1c',undoType='kill-line')</t>
<t tx="ekr.20061021144014.137">def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return
    
    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.138">def killSentence (self,event):
    
    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return

    i  = w.search('.','insert',stopindex='end')
    if i:
        self.beginCommand(undoType='kill-sentence')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='kill-sentence')
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.139">def killWs (self,event,undoType=None):
    
    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break
   
    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.140">def yank (self,event):
    
    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20061021144014.141">def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert') ; t, t1 = i.split('.')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        if clip_text: s = clip_text
        else:         s = self.kbiterator.next()
        t1 = str(int(t1)+len(s))
        r = w.tag_ranges('kb')
        if r and r [0] == i:
            w.delete(r[0],r[-1])
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
</t>
<t tx="ekr.20061021144014.142"></t>
<t tx="ekr.20061021144014.143">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
</t>
<t tx="ekr.20061021144014.144"># New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
</t>
<t tx="ekr.20061021144014.145"># New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20061021144014.146"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = g.app.gui.getAllText(bodyCtrl) # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText))
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        g.trace('newText:',repr(newText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        &lt;&lt; recolor the body &gt;&gt;
        if not c.changed: c.setChanged(True)
        self.updateEditors()
        &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20061021144014.147">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
</t>
<t tx="ekr.20061021144014.148">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
</t>
<t tx="ekr.20061021144014.149"># Did not restore selection after indent/undent commands.
</t>
<t tx="ekr.20061021144014.150"></t>
<t tx="ekr.20061021144014.151">def convertAllBlanks (self,event=None):
    
    '''Convert all blanks to tabs in the selected outline.'''
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count &gt; 0)
</t>
<t tx="ekr.20061021144014.152">def convertAllTabs (self,event=None):
    
    '''Convert all tabs to blanks in the selected outline.'''

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count &gt; 0)
</t>
<t tx="ekr.20061021144014.153">def convertBlanks (self,event=None):
    
    '''Convert all blanks to tabs in the selected node.'''

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
</t>
<t tx="ekr.20061021144014.154">def convertTabs (self,event=None):
    
    '''Convert all tabs to blanks in the selected node.'''

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False,None

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
</t>
<t tx="ekr.20061021144014.155">def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
</t>
<t tx="ekr.20061021144014.156">def dedentBody (self,event=None):
    
    '''Remove one tab's worth of indentation from all presently selected lines.'''
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.157">def extract (self,event=None):
    
    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20061021144014.158">def extractSection (self,event=None):
    
    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20061021144014.159">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
</t>
<t tx="ekr.20061021144014.160">def extractSectionNames(self,event=None):
    
    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
</t>
<t tx="ekr.20061021144014.161">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)
        
if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]
</t>
<t tx="ekr.20061021144014.162">def findBoundParagraph (self,event=None):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        &lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;

    # Scan backwards.
    i = len(head_lines)
    while i &gt; 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i &lt; len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#   para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
</t>
<t tx="ekr.20061021144014.163">if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
</t>
<t tx="ekr.20061021144014.164">def findMatchingBracket (self,event=None):
    
    '''Selecte the text between matching brackets.'''
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"&lt;=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
</t>
<t tx="ekr.20061021144014.165"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,"&gt;=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level &lt;= 0:
                return index
        if not forward and body.compareIndices(index,"&lt;=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
</t>
<t tx="ekr.20061021144014.166">def getBodyLines (self,expandSelection=False):
    
    """Return head,lines,tail where:
        
    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use g.splitLines.

    return head,lines,tail,oldSel,oldVview
</t>
<t tx="ekr.20061021144014.167">def indentBody (self,event=None):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; undoType = 'Indent Region' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.168">def insertBodyTime (self,event=None):
    
    '''Insert a time/date stamp at the cursor.'''
    
    c = self ; undoType = 'Insert Body Time'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)
</t>
<t tx="ekr.20061021144014.169">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20061021144014.170"></t>
<t tx="ekr.20061021144014.171">def addComments (self,event=None):
    
    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.172">def deleteComments (self,event=None):
    
    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20061021144014.173">def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;
</t>
<t tx="ekr.20061021144014.174">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
</t>
<t tx="ekr.20061021144014.175">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20061021144014.176"># Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
</t>
<t tx="ekr.20061021144014.177">sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
</t>
<t tx="ekr.20061021144014.178">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
</t>
<t tx="ekr.20061021144014.179">def setSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = g.app.gui.getInsertPoint(w)
        
    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    # g.trace(i,j)
    g.app.gui.setSelectionRange(w,i,j,insert=j)
    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20061021144014.180">@
The 'hang' was due to removeRKeys, which removes the bindings create by
setRegion (set-mark-command) by *also* cleared all the other bindings!
For now I have simply disabled the set-mark-command and commented out all
calls to removeRKeys.

Note that toggle-extend-mode (Alt-3) is a good way to define regions.</t>
<t tx="ekr.20061021144014.181"></t>
<t tx="ekr.20061021144014.182">def testinrange (self,w):

    if not self.inRange(w,'sel') or not self.contRanges(w,'sel'):
        # self.removeRKeys(w)
        return False
    else:
        return True
</t>
<t tx="ekr.20061021144014.183">def indentRegion (self,event):
    w = self.editWidget(event)
    if not w: return

    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.184">def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')
    
def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')
    
def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w: return

    trange = w.tag_ranges('sel')
    if len(trange) != 0:
        self.beginCommand(undoType=undoType)
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)
        self.endCommand(changed=True,setLabel=True)

    # self.removeRKeys(w)
</t>
<t tx="ekr.20061021144014.185">@nocolor
@

onFocusIn and its associated binding were a very bad idea.  It is not needed:
k.masterClickHandler simply calls the new onClick method.

What I did:
    
- Eliminating onFocusIn and its associated binding.
  Hurray: this also fixed the Find problem.
- Fixed problem with deleting nodes when multiple editors are present.
- Fixed minor problem with cycle-all-focus.
- Removed title bar when penultimate editor is deleted.

@color</t>
<t tx="ekr.20061021144014.186">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        # g.trace(event.x,event.y)
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = g.app.gui.getSelectionRange(w)
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
        c.frame.body.onClick(w) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20061021144014.187">class leoTkinterBody (leoFrame.leoBody):
    
    """A class that represents the body pane of a Tkinter window."""

    @others
</t>
<t tx="ekr.20061021144014.188"></t>
<t tx="ekr.20061021144014.189">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterBody")
    
    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)
    
    c = self.c ; p = c.currentPosition()
    self.editor_name = None
    self.editor_v = None
    self.editorWidgets = {} # keys are pane names, values are Tk.Text widgets

    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.bodyCtrl = self.createControl(frame,parentFrame,p)
    self.colorizer = leoColor.colorizer(c)
</t>
<t tx="ekr.20061021144014.190">def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl
    
    w.bind('&lt;Key&gt;', k.masterKeyHandler)

    for kind,func,handler in (
        ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
        ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
        ('&lt;Button-2&gt;',  frame.OnPaste,              k.masterClickHandler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        w.bind(kind,bodyClickCallback)</t>
<t tx="ekr.20061021144014.191">def createControl (self,frame,parentFrame,p):
    
    c = self.c
    
    # New in 4.4.1: make the parent frame a Pmw.PanedWidget.
    self.numberOfEditors = 1 ; name = '1'
    self.totalNumberOfEditors = 1
    
    orient = c.config.getString('editor_orientation') or 'horizontal'
    if orient not in ('horizontal','vertical'): orient = 'horizontal'
   
    self.pb = pb = Pmw.PanedWidget(parentFrame,orient=orient)
    parentFrame = pb.add(name)
    pb.pack(expand=1,fill='both') # Must be done after the first page created.
   
    w = self.createTextWidget(frame,parentFrame,p,name)
    self.editorWidgets[name] = w

    return w
</t>
<t tx="ekr.20061021144014.192">def createTextWidget (self,frame,parentFrame,p,name):
    
    c = self.c
    
    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = w = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
        
    # g.trace(id(w))
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
    w.leo_active = True
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w</t>
<t tx="ekr.20061021144014.193">@ **Important**: body.bodyCtrl and body.frame.bodyCtrl must always be the same.
</t>
<t tx="ekr.20061021144014.194">def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl
    
    # g.trace(id(w),c.currentPosition().headString())
    
    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w
    
    c.recolor_now(interruptable=False) # Force a complete recoloring.
    
    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w</t>
<t tx="ekr.20061021144014.195">def unselectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='LightSteelBlue1')
        
def selectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    # g.trace(self.numberOfEditors)
    if self.numberOfEditors &gt; 1:
        if not w.leo_label: self.createLabel(w)
        w.leo_label.configure(text=w.leo_label_s,bg='white')
    elif w.leo_label:
        w.leo_label.pack_forget()
        w.leo_label = None

def createLabel (self,w):

    w.leo_label = Tk.Label(w.leo_frame)
    w.pack_forget()
    w.leo_label.pack(side='top')
    w.pack(expand=1,fill='both')
</t>
<t tx="ekr.20061021144014.196">def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
     
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        w = self.editorWidgets.get('1')
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w) # Immediately create the label in the old editor.
   
    name = '%d' % self.totalNumberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    &lt;&lt; create label and text widgets &gt;&gt;
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.197">f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,f,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
w.see('1.0')
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
</t>
<t tx="ekr.20061021144014.198">def setEditorColors (self,bg,fg):
    
    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
</t>
<t tx="ekr.20061021144014.199">def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.numberOfEditors -= 1
    self.selectEditor(w)
</t>
<t tx="ekr.20061021144014.200">def onClick (self,w):
    
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('body'):
        g.trace('can not happen')
        return

    self.selectEditor(w)</t>
<t tx="ekr.20061021144014.201">def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
        # Inactivate the previously active editor.
        # Don't capture ivars here! selectMainEditor keeps them up-to-date.
        for key in d.keys():
            w2 = d.get(key)
            if w2 != w and w2.leo_active:
                w2.leo_active = False
                self.unselectLabel(w2)
                w2.leo_scrollBarSpot = w2.yview()
                w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
                w2.leo_selection = g.app.gui.getSelectionRange(w2)
                break
        else:
            if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20061021144014.202">if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20061021144014.203">def selectMainEditor (self,p):
    
    
    '''Called from tree.select to select the present body editor.'''

    c = self.c ; p = c.currentPosition() ; w = self.bodyCtrl

    # Don't inject ivars if there is only one editor.
    if w.leo_p is not None:
        # Keep w's ivars up-to-date.
        w.leo_p = p.copy()
        w.leo_v = p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w)
        # g.trace(w.leo_name,p.headString())
</t>
<t tx="ekr.20061021144014.204">def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) &lt; 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.frame.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.205">def setColorFromConfig (self,w=None):
    
    c = self.c
    if not w: w = self.bodyCtrl
    
    bg = c.config.getColor("body_text_background_color") or 'white'
    # g.trace(id(w),bg)
    
    try: w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: w.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20061021144014.206">def setFontFromConfig (self,w=None):

    c = self.c
    
    if not w: w = self.bodyCtrl
    
    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)
    
    self.fontRef = font # ESSENTIAL: retain a link to font.
    w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
</t>
<t tx="ekr.20061021144014.207">def hasFocus (self):
    
    return self.bodyCtrl == self.frame.top.focus_displayof()
    
def setFocus (self):
    
    self.c.widgetWantsFocus(self.bodyCtrl)
</t>
<t tx="ekr.20061021144014.208">def forceFullRecolor (self):
    
    self.forceFullRecolorFlag = True
</t>
<t tx="ekr.20061021144014.209">@
I could have used this to redirect all calls from the body class and the bodyCtrl to Tk. OTOH:

1. Most of the wrappers do more than the old Tk routines now and
2. The wrapper names are more discriptive than the Tk names.

Still, using the Tk names would have had its own appeal.  If I had prefixed the tk routine with tk_ the __getatt__ routine could have stripped it off!
@c

if 0: # This works.
    def __getattr__(self,attr):
        return getattr(self.bodyCtrl,attr)
        
if 0: # This would work if all tk wrapper routines were prefixed with tk_
    def __getattr__(self,attr):
        if attr[0:2] == "tk_":
            return getattr(self.bodyCtrl,attr[3:])
</t>
<t tx="ekr.20061021144014.210">def bbox(self,index):

    return self.bodyCtrl.bbox(index)
</t>
<t tx="ekr.20061021144014.211"># Could have been replaced by the __getattr__ routine above...
# 12/19/03: no: that would cause more problems.

def tag_add (self,tagName,index1,index2):
    self.bodyCtrl.tag_add(tagName,index1,index2)

def tag_bind (self,tagName,event,callback):
    self.bodyCtrl.tag_bind(tagName,event,callback)

def tag_configure (self,colorName,**keys):
    self.bodyCtrl.tag_configure(colorName,keys)

def tag_delete(self,tagName):
    self.bodyCtrl.tag_delete(tagName)
    
def tag_names(self,*args): # New in Leo 4.4.1.
    return self.bodyCtrl.tag_names(*args)

def tag_remove (self,tagName,index1,index2):
    return self.bodyCtrl.tag_remove(tagName,index1,index2)
</t>
<t tx="ekr.20061021144014.212">def cget(self,*args,**keys):
    
    val = self.bodyCtrl.cget(*args,**keys)
    
    if g.app.trace:
        g.trace(val,args,keys)

    return val
    
def configure (self,*args,**keys):
    
    # g.trace(args,keys)
    
    return self.bodyCtrl.configure(*args,**keys)
</t>
<t tx="ekr.20061021144014.213">def getBodyPaneHeight (self):
    
    return self.bodyCtrl.winfo_height()

def getBodyPaneWidth (self):
    
    return self.bodyCtrl.winfo_width()
</t>
<t tx="ekr.20061021144014.214">def scheduleIdleTimeRoutine (self,function,*args,**keys):

    self.bodyCtrl.after_idle(function,*args,**keys)
</t>
<t tx="ekr.20061021144014.215"></t>
<t tx="ekr.20061021144014.216">def adjustIndex (self,index,offset):
    
    t = self.bodyCtrl
    return t.index("%s + %dc" % (t.index(index),offset))
</t>
<t tx="ekr.20061021144014.217">def compareIndices(self,i,rel,j):

    return self.bodyCtrl.compare(i,rel,j)
</t>
<t tx="ekr.20061021144014.218">def convertRowColumnToIndex (self,row,column):
    
    return self.bodyCtrl.index("%s.%s" % (row,column))
</t>
<t tx="ekr.20061021144014.219">def convertIndexToRowColumn (self,index):
    
    index = self.bodyCtrl.index(index)
    start, end = string.split(index,'.')
    return int(start),int(end)
</t>
<t tx="ekr.20061021144014.220">def getImageIndex (self,image):
    
    return self.bodyCtrl.index(image)
</t>
<t tx="ekr.20061021144014.221">def tkIndex(self,index):
    
    """Returns the canonicalized Tk index."""
    
    if index == "start": index = "1.0"
    
    return self.bodyCtrl.index(index)
</t>
<t tx="ekr.20061021144014.222"></t>
<t tx="ekr.20061021144014.223">def getPythonInsertionPoint (self,t=None,s=None):
    
    b = self
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    i = t.index("insert")
    row,col = b.convertIndexToRowColumn(i)
    
    return g.convertRowColToPythonIndex(s,row-1,col)
    
def setPythonInsertionPoint (self,i,t=None,s=None):
    
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    t.mark_set( 'insert','%d.%d' % (row+1,col))
</t>
<t tx="ekr.20061021144014.224">def getBeforeInsertionPoint (self):
    
    return self.bodyCtrl.index("insert-1c")

def getInsertionPoint (self):
    
    return self.bodyCtrl.index("insert")
</t>
<t tx="ekr.20061021144014.225">def getCharAtInsertPoint (self):
    
    s = self.bodyCtrl.get("insert")
    return g.toUnicode(s,g.app.tkEncoding)

def getCharBeforeInsertPoint (self):

    s = self.bodyCtrl.get("insert -1c")
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.226">def makeInsertPointVisible (self):
    
    self.bodyCtrl.see("insert") # -5l")
</t>
<t tx="ekr.20061021144014.227">def setInsertionPoint (self,index):
    self.bodyCtrl.mark_set("insert",index)

def setInsertionPointToEnd (self):
    self.bodyCtrl.mark_set("insert","end")
    
def setInsertPointToStartOfLine (self,lineNumber): # zero-based line number
    self.bodyCtrl.mark_set("insert",str(1+lineNumber)+".0 linestart")
</t>
<t tx="ekr.20061021144014.228">def bind (self,*args,**keys):
    
    return self.bodyCtrl.bind(*args,**keys)
</t>
<t tx="ekr.20061021144014.229"></t>
<t tx="ekr.20061021144014.230">def deleteTextSelection (self):
    
    t = self.bodyCtrl
    sel = t.tag_ranges("sel")
    if len(sel) == 2:
        start,end = sel
        if t.compare(start,"!=",end):
            t.delete(start,end)
</t>
<t tx="ekr.20061021144014.231">def getSelectedText (self):
    
    """Return the selected text of the body frame, converted to unicode."""

    start, end = self.getTextSelection()
    if start and end and start != end:
        s = self.bodyCtrl.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u'' # Bug fix: 1/8/06
</t>
<t tx="ekr.20061021144014.232">def getTextSelection (self,sort=True):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    w = self.bodyCtrl
    
    sel = w.tag_ranges("sel")

    if len(sel) == 2:
        # New in 4.4a5: match behavior of g.app.gui.getTextSelection.
        if sort:
            i,j = sel
            if w.compare(i, "&gt;", j):
                i,j = j,i
        return sel
    else:
        # Return the insertion point if there is no selected text.
        insert = w.index("insert")
        return insert,insert
</t>
<t tx="ekr.20061021144014.233">def getPythonTextSelection (self):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    b = self ; t = self.bodyCtrl
    sel = t.tag_ranges("sel")

    if len(sel) == 2:
        s = t.get('1.0','end')
        i,j = sel
        row,col = b.convertIndexToRowColumn(i)
        i1 = g.convertRowColToPythonIndex(s,row-1,col)
        row,col = b.convertIndexToRowColumn(j)
        i2 = g.convertRowColToPythonIndex(s,row-1,col)
        return i1,i2
    else:
        # Return the insertion point if there is no selected text.
        i = self.getPythonTextSelection()
        return i,i
</t>
<t tx="ekr.20061021144014.234">def setPythonTextSelection(self,i,j):

    t = self.bodyCtrl
    s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    i1 = '%d.%d' % (row+1,col)
    row,col = g.convertPythonIndexToRowCol(s,j)
    i2 = '%d.%d' % (row+1,col)
    g.app.gui.setTextSelection(self.bodyCtrl,i1,i2)
</t>
<t tx="ekr.20061021144014.235">def hasTextSelection (self):

    sel = self.bodyCtrl.tag_ranges("sel")
    return sel and len(sel) == 2
</t>
<t tx="ekr.20061021144014.236">def selectAllText (self,event=None):
    
    '''Select all text in the presently selected pane.'''
    
    c = self.c ; k = c.k

    try:
        w = c.get_focus() ; wname = c.widget_name(w)
        n = 0
        if wname.startswith('head'):
            s = w.get('1.0','end')
            while s.endswith('\n') or s.endswith('\r'):
                s = s[:-1] ; n += 1
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
        elif wname.startswith('mini'):
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j)
        else:
            g.app.gui.setTextSelection(w,'1.0','end - %dc' % (n))
    except:
        # g.es_exception()
        pass
</t>
<t tx="ekr.20061021144014.237">def setTextSelection (self,i,j=None,insert='sel.end'):
    
    # Allow the user to pass either a 2-tuple or two separate args.
    if i is None:
        i,j = "1.0","1.0"
    elif len(i) == 2:
        i,j = i

    g.app.gui.setTextSelection(self.bodyCtrl,i,j,insert)
</t>
<t tx="ekr.20061021144014.238"></t>
<t tx="ekr.20061021144014.239">def deleteAllText(self):
    self.bodyCtrl.delete("1.0","end")

def deleteCharacter (self,index):
    t = self.bodyCtrl
    t.delete(t.index(index))
    
def deleteLastChar (self):
    self.bodyCtrl.delete("end-1c")
    
def deleteLine (self,lineNumber): # zero based line number.
    self.bodyCtrl.delete(str(1+lineNumber)+".0","end")
    
def deleteLines (self,line1,numberOfLines): # zero based line numbers.
    self.bodyCtrl.delete(str(1+line1)+".0",str(1+line1+numberOfLines-1)+".0 lineend")
    
def deleteRange (self,index1,index2):
    t = self.bodyCtrl
    t.delete(t.index(index1),t.index(index2))
</t>
<t tx="ekr.20061021144014.240"></t>
<t tx="ekr.20061021144014.241">def getAllText (self):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get("1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.242">def getCharAtIndex (self,index):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get(index)
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20061021144014.243">def getInsertLines (self):
    
    """Return before,after where:
        
    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.
    
    All lines end in a newline, except possibly the last line."""
    
    t = self.bodyCtrl

    before = t.get("1.0","insert linestart")
    ins    = t.get("insert linestart","insert lineend + 1c")
    after  = t.get("insert lineend + 1c","end")

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
</t>
<t tx="ekr.20061021144014.244">def getSelectionAreas (self):
    
    """Return before,sel,after where:
        
    before is the text before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is the text after the selected text
    (or the text after the insert point if no selection)"""

    t = self.bodyCtrl
    
    sel_index = t.getTextSelection()
    if len(sel_index) == 2:
        i,j = sel_index
        sel = t.get(i,j)
    else:
        i = j = t.index("insert")
        sel = ""

    before = t.get("1.0",i)
    after  = t.get(j,"end")
    
    before = g.toUnicode(before,g.app.tkEncoding)
    sel    = g.toUnicode(sel,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)
    return before,sel,after
</t>
<t tx="ekr.20061021144014.245">def getSelectionLines (self):
    
    """Return before,sel,after where:
        
    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""
    
    # At present, called only by c.getBodyLines.

    t = self.bodyCtrl
    sel_index = t.tag_ranges("sel") 
    if len(sel_index) != 2:
        if 1: # Choose the insert line.
            index = t.index("insert")
            sel_index = index,index
        else:
            return "","","" # Choose everything.

    i,j = sel_index
    i = t.index(i + "linestart")
    j = t.index(j + "lineend") # 10/24/03: -1c  # 11/4/03: no -1c.
    before = g.toUnicode(t.get("1.0",i),g.app.tkEncoding)
    sel    = g.toUnicode(t.get(i,j),    g.app.tkEncoding)
    after  = g.toUnicode(t.get(j,"end-1c"),g.app.tkEncoding)
    
    # g.trace(i,j)
    return before,sel,after
</t>
<t tx="ekr.20061021144014.246">def getTextRange (self,index1,index2):
    
    t = self.bodyCtrl
    return t.get(t.index(index1),t.index(index2))
</t>
<t tx="ekr.20061021144014.247"></t>
<t tx="ekr.20061021144014.248">def insertAtInsertPoint (self,s):
    
    self.bodyCtrl.insert("insert",s)
</t>
<t tx="ekr.20061021144014.249">def insertAtEnd (self,s):
    
    self.bodyCtrl.insert("end",s)
</t>
<t tx="ekr.20061021144014.250">def insertAtStartOfLine (self,lineNumber,s):
    
    self.bodyCtrl.insert(str(1+lineNumber)+".0",s)
</t>
<t tx="ekr.20061021144014.251">def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)
</t>
<t tx="ekr.20061021144014.252">def makeIndexVisible (self,index):
    
    self.bodyCtrl.see(index)
    
def setFirstVisibleIndex (self,index):
    
    self.bodyCtrl.yview("moveto",index)
    
def getYScrollPosition (self):
    
    return self.bodyCtrl.yview()
    
def setYScrollPosition (self,scrollPosition):

    if len(scrollPosition) == 2:
        first,last = scrollPosition
    else:
        first = scrollPosition
    self.bodyCtrl.yview("moveto",first)
    
def scrollUp (self):
    
    self.bodyCtrl.yview("scroll",-1,"units")
    
def scrollDown (self):

    self.bodyCtrl.yview("scroll",1,"units")
</t>
<t tx="ekr.20061021144014.253">@nocolor

I hate to constantly be the bearer of bad news, but:

exception executing command
Traceback (most recent call last):
   File 
"/mnt/usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/src/leoCommands.py", 
line 263, in doCommand
     val = command(event)
   File 
"/mnt/usr1/home/tbrown/.gnome-desktop/Package/leo/cvs/leo/plugins/rst3.py", 
line 677, in rst3PluginCallback
     self.processTopTree(c.currentPosition())
TypeError: processTopTree() takes exactly 3 arguments (2 given)

Cheers -Terry

</t>
<t tx="ekr.20061021144014.254">@nocolor

&gt;&gt; Sorry, the css in the .html doesn't include leo_rst.css 
&gt;&gt; silver_city.css, that's just in the default.css it's looking in 
&gt;&gt; the wrong place for.

&gt; Coming in in the middle of a conversation like this, I have no 
&gt; idea what you are talking about.

Hmmm, my second email amending my first email must have reached you 
before my first email... not helpful.  My first email is repeated 
below, the second email was just saying I mispoke about where those
include statements were.

But maybe you should just address these two points, as they 
represent the current state of my understanding of rst3 css 
problems.

1) On 'Write restructured text' I get "stylesheet does not exist: 
/mnt/proj/ItascaLegacy/default.css" - leo seems to be looking one 
directory too high, the .html file being written and the .css 
files are in /mnt/proj/ItascaLegacy/app/

2) http://www.w3.org/TR/REC-CSS2/cascade.html#at-import 
unfortunately says "Any @import rules must precede all rule sets in 
a style sheet." and Firefox at least ignores them otherwise, so your 
default.css, which has them at the end, needs looking at on this 
point.

Cheers -Terry

---------- Forwarded message ----------
From: Terry Brown &lt;tbrown@nrri.umn.edu&gt;
To: Edward K. Ream &lt;edreamleo@charter.net&gt;
Date: Wed, 18 Oct 2006 14:03:02 -0500 (CDT)
Subject: rst3...


Some problems with rst3

     ignoring unknown option: doc_mode_only

no problem, but it was in the example on Leo's homepage

     stylesheet does not exist: /mnt/proj/ItascaLegacy/default.css

This is true, but /mnt/proj/ItascaLegacy/app/default.css does
exist, and /mnt/proj/ItascaLegacy/app/ is where Leo's writing
the .html file to.  The @rst node just says
'@rst itascatooldoc.html', and the .leo file's in /mnt/proj/ItascaLegacy/app/.

I.e. it seems to be looking one directory higher than it should for 
default.css.

The .html file includes a default rst3 style sheet within it that
includes leo_rst.css  silver_city.css, but the .html file never
refers to default.css.  But maybe this is just a flow on effect
of looking for it in the wrong place.

Cheers -Terry
</t>
<t tx="ekr.20061021144014.255">@

Double-clicking  @url &lt;leo-fille&gt; did not bring Leo file to top

onTreeClick was being called after the double-click handling.
The fix was the c.doubleClickFlag logic.</t>
<t tx="ekr.20061021144014.256"></t>
<t tx="ekr.20061021144014.257">def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            &lt;&lt; stop the url after any whitespace &gt;&gt;
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            &lt;&lt; check the url; return if bad &gt;&gt;
            &lt;&lt; pass the url to the web browser &gt;&gt;
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06</t>
<t tx="ekr.20061021144014.258"># For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i &gt; -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i &gt; -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
</t>
<t tx="ekr.20061021144014.259">if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
</t>
<t tx="ekr.20061021144014.260">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()</t>
<t tx="ekr.20061021144014.261">def onTreeClick (self,event=None):
    
    '''Handle an event in the tree canvas, outside of any tree widget.'''
    
    c = self.c
    
    # New in Leo 4.4.2: a kludge: disable later event handling after a double-click.
    # This allows focus to stick in newly-opened files opened by double-clicking an @url node.
    if c.doubleClickFlag:
        c.doubleClickFlag = False
    else:
        c.treeWantsFocusNow()
    
    return 'break'
</t>
<t tx="ekr.20061021144014.262">set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""

                
    if not g.app.unitTesting and c and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        # Do not call trace here: that might affect focus!
        print 'gui.set_focus: %4d %10s %s' % (
            self.set_focus_count,c and c.shortFileName(),
            c and c.widget_name(w)), g.callers(5)
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
</t>
<t tx="ekr.20061021144014.263"></t>
<t tx="ekr.20061021144014.264">@nocolor

- @bool write_recent_files_as_needed = True

People who don't want Leo to update .leoRecentFiles.txt can set this to False.

- Remove .leoRecentFiles from cvs
- Remove .leoRecentFiles from distribution list.

@color</t>
<t tx="ekr.20061021144014.265">def __init__ (self):
    
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.modeCommandsDict = {} # For use by @mode logic. Keys are command names, values are g.Bunches.
    self.myGlobalConfigFile = None
    self.myHomeConfigFile = None
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
</t>
<t tx="ekr.20061021144014.266">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []

    # This can't be done in initSettingsFiles because the local directory does not exits.
    localDirectory = g.os_path_dirname(fileName)
    
    #  Set the local leoSettings.leo file.
    localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
    if not g.os_path_exists(localConfigFile): localConfigFile = None
    
    # Set the local myLeoSetting.leo file.
    myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
    if not g.os_path_exists(myLocalConfigFile): myLocalConfigFile = None
    
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Init settings from leoSettings.leo files, including myLeoSettings.leo.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            if c and localFlag:
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
            self.readRecentFilesFile(c,path)
    if self.write_recent_files_as_needed:
        self.createRecentFiles(fileName)

    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20061021144014.267">def readRecentFilesFile (self,c,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'
    
    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    if not g.os_path_exists(fileName):
        # g.trace('does not exist',fileName)
        return
        
    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return

    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
        self.appendToRecentFiles(lines)</t>
<t tx="ekr.20061021144014.268">def createRecentFiles (self,fileName):
    
    localPath,junk = g.os_path_split(fileName)

    for path in (g.app.homeDir,g.app.globalConfigDir,localPath):
        fileName = g.os_path_join(path,'.leoRecentFiles.txt')
        if g.os_path_exists(fileName):
            # g.es_print('found %s' % fileName)
            return

    # Create the file in the home directory.
    try:
        fileName = g.os_path_join(g.app.homeDir,'.leoRecentFiles.txt')
        f = file(fileName,'w')
        f.close()
        g.es_print('Created %s' % (fileName),color='red')
        return
    except Exception:
        g.es_print('Exception creating %s' % (fileName),color='red')
        g.es_exception()</t>
<t tx="ekr.20061021144014.269">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,'.leoRecentFiles.txt')
            if g.os_path_exists(fileName):
                # g.es_print('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        g.trace('----- not found:',localFileName)
        return
</t>
<t tx="ekr.20061021144014.270">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061021144014.271">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3588148
By: vpe

One way to make Leo more newbie friendly is to add menu items for key features
that are likely to cause confusion in the beginning.

What I did:
    
- Added minibuffer submenu.
- Renamed help to help-for-minibuffer
- Added Pickers submenu
- Added help-for-settings command

@color</t>
<t tx="ekr.20061021144014.272">def defineCmdsMenuTables (self):
    
    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPanesTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()</t>
<t tx="ekr.20061021144014.273">def defineCmdsMenuAbbrevTable (self):
    
    self.cmdsMenuAbbrevTable = [
        # &amp;: a,e,i,k,l,r,w,v
        'abbre&amp;v-mode',
        '-',
        '&amp;list-abbrevs',
        '&amp;read-abbrev-file',
        '&amp;write-abbrev-file',
        '-',
        '&amp;add-global-abbrev',
        '&amp;inverse-add-global-abbrev',
        '&amp;kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&amp;expand-region-abbrevs',
    ]
</t>
<t tx="ekr.20061021144014.274">def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &amp;: a,c,d
        '&amp;add-editor',
        '&amp;cycle-editor-focus',
        '&amp;delete-editor',
    ]</t>
<t tx="ekr.20061021144014.275">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&amp;append-to-buffer',
        '&amp;kill-buffer',
        'list-&amp;buffers',
        '&amp;list-buffers-alphabetically',
        '&amp;prepend-to-buffer',
        '&amp;rename-buffer',
        '&amp;switch-to-buffer',
    ]
</t>
<t tx="ekr.20061021144014.276">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]
    
    self.cursorMenuForwardTable = [
        # &amp;: b,c,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20061021144014.277">def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&amp;cycle-all-focus',
        'focus-to-&amp;body',          
        'focus-to-&amp;log',             
        'focus-to-&amp;minibuffer',     
        'focus-to-&amp;tree',             
    ]
</t>
<t tx="ekr.20061021144014.278">def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&amp;load-file',
        '-',
        '&amp;start-kbd-macro',
        '&amp;end-kbd-macro',
        '&amp;name-last-kbd-macro',
        '-',
        '&amp;call-last-keyboard-macro',
        '&amp;insert-keyboard-macro',
    ]
</t>
<t tx="ekr.20061021144014.279">def defineCmdsMenuMinibufferTable (self):
    
    self.cmdsMenuMinibufferTable = [
        # &amp;: f,h,i,q,r,s,v
        '&amp;full-command',
        'keyboard-&amp;quit',
        '&amp;repeat-complex-command',
        '&amp;view-lossage',
        '-',
        '&amp;show-mini-buffer',
        'h&amp;ide-mini-buffer',
        '-',
        '&amp;help-for-minibuffer',
    ]
</t>
<t tx="ekr.20061021144014.280">def defineCmdsMenuPanesTable (self):

    self.cmdsMenuPanesTable = [
        # &amp;: a,b,d,f,l,n,o,p,u,x,y
        'contract-&amp;body-pane',
        'contract-&amp;log-pane',
        'contract-&amp;outline-pane',
        'contract-&amp;pane',
        '-',
        'expand-bo&amp;dy-pane',
        'expand-lo&amp;g-pane',
        'expand-o&amp;utline-pane',
        'expand-pa&amp;ne',
        '-',
        '&amp;fully-expand-body-pane',
        'full&amp;y-expand-log-pane',
        'fully-e&amp;xpand-outline-pane',
        'fully-exp&amp;and-pane',
    ]
    </t>
<t tx="ekr.20061021144014.281">def defineCmdsMenuPickersTable (self):
    
    self. cmdsMenuPickersTable = [
        'show-&amp;colors',
        'show-find-&amp;options',
        'show-&amp;fonts',
    ]</t>
<t tx="ekr.20061021144014.282">def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&amp;clear-rectangle',
        'c&amp;lose-rectangle',
        '&amp;delete-rectangle',
        '&amp;kill-rectangle',
        '&amp;open-rectangle',
        '&amp;string-rectangle',
        '&amp;yank-rectangle',
    ]
</t>
<t tx="ekr.20061021144014.283">def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &amp;: a,c,e,i,j,n,p,r,v
        '&amp;append-to-register',
        'copy-r&amp;ectangle-to-register',
        '&amp;copy-to-register',
        'i&amp;ncrement-register',
        '&amp;insert-register',
        '&amp;jump-to-register',
        # 'number-to-register',
        '&amp;point-to-register',
        'p&amp;repend-to-register',
        '&amp;view-register',
    ]
</t>
<t tx="ekr.20061021144014.284">def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &amp;: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&amp;line',
        'scroll-outline-down-&amp;page',
        'scroll-outline-le&amp;ft',
        'scroll-outline-&amp;right',
        's&amp;croll-outline-up-line',
        'scr&amp;oll-outline-up-page',
        '-',
        'scroll-&amp;down',
        'scroll-&amp;up',
        '-',
        'scroll-down-&amp;extend-selection',
        'scroll-up-e&amp;xtend-selection',
    ]</t>
<t tx="ekr.20061021144014.285">def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&amp;open-spell-tab',
        'spell-&amp;change',
        'spell-change-&amp;then-find',
        'spell-&amp;find',
        'spell-&amp;ignore',
    ]
</t>
<t tx="ekr.20061021144014.286">def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &amp;: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&amp;beautify',
        'beautify-&amp;all',
        '-',
        'center-&amp;line',
        'center-&amp;region',
        '-',
        '&amp;capitalize-word',
        '&amp;downcase-word',
        '&amp;upcase-word',
        '-',
        'd&amp;owncase-region',
        'u&amp;pcase-region',
        '-',
        '&amp;indent-region',
        'indent-r&amp;elative',
        'indent-ri&amp;gidly',
        'u&amp;nindent-region',
        '-',
        'sort-colu&amp;mns',
        'sort-&amp;fields',
        '&amp;sort-lines',
    ]</t>
<t tx="ekr.20061021144014.287">def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &amp;: d,e,m,s,t,u,v
        'toggle-a&amp;utocompleter',
        'toggle-call&amp;tips',
        'toggle-&amp;extend-mode',
        'toggle-input-&amp;state',
        'toggle-in&amp;visibles',
        'toggle-&amp;mini-buffer',
        'toggle-split-&amp;direction',
        '-',
        # &amp;: a,b,c,f,h,i,r,w,x
        'toggle-find-&amp;ignore-case-option',
        'toggle-find-in-&amp;body-option',
        'toggle-find-in-&amp;headline-option',
        'toggle-find-mark-&amp;changes-option',
        'toggle-find-mark-&amp;finds-option',
        'toggle-find-rege&amp;x-option',
        'toggle-find-&amp;reverse-option',
        'toggle-find-&amp;word-option',
        'toggle-find-wrap-&amp;around-option',
    ]
</t>
<t tx="ekr.20061021144014.288">def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&amp;Cmds')
    
    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &amp;: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t
        ('&amp;Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&amp;ditors',       self.cmdsMenuBodyEditorsTable),
        ('&amp;Buffers...',         self.cmdsMenuBuffersTable),
        ('&amp;Cursor/Selection...',[]),
        ('&amp;Focus...',           self.cmdsMenuFocusTable),
        ('&amp;Macro...',           self.cmdsMenuMacroTable),
        ('M&amp;inibuffer',         self.cmdsMenuMinibufferTable),
        ('&amp;Panes...',           self.cmdsMenuPanesTable),
        ('Pic&amp;kers...',         self.cmdsMenuPickersTable),
        ('&amp;Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&amp;gisters...',       self.cmdsMenuRegistersTable),
        ('Scr&amp;olling...',       self.cmdsMenuScrollTable),
        ('Spell C&amp;heck...',     self.cmdsMenuSpellCheckTable),
        ('&amp;Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&amp;ngs',     self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&amp;Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &amp;: b,e,f,s,t,x
        ('Cursor &amp;Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &amp;Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &amp;To...',                self.cursorMenuExtendTable),
        ('Cursor &amp;Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&amp;xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&amp;ursor/Selection...')
        self.createMenuEntries(menu,table)</t>
<t tx="ekr.20061021144014.289">def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &amp;: a,b,c,d,f,h,l,m,n,o,p,r,s,t,u
        ('&amp;About Leo...',           'about-leo'),
        ('Online &amp;Home Page',       'open-online-home'),
        '*open-online-&amp;tutorial',
        '*open-&amp;users-guide',
        '-',
        ('Open Leo&amp;Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&amp;Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&amp;Settings.leo',   'open-leoSettings-leo'),
        ('Open &amp;myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&amp;ipts.leo',       'open-scripts-leo'),
        '-',
        '*he&amp;lp-for-minibuffer',
        '*help-for-&amp;command',
        '-',
        '*&amp;apropos-autocompletion',
        '*apropos-&amp;bindings',
        '*apropos-&amp;find-commands',
        '-',
        '*pri&amp;nt-bindings',
        '*print-c&amp;ommands',
    ]
</t>
<t tx="ekr.20061021144014.290"># It's not clear how to specify a setting for unicode characters.
# Leo crashes on do-nothing = ц</t>
<t tx="ekr.20061021144014.291">def doNothing (self,event):
    
    '''A placeholder command, useful for testing bindings.'''

    g.trace()</t>
<t tx="ekr.20061021144014.292"># This is much more visible.</t>
<t tx="ekr.20061021144014.293">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''
    
    k = self.k
    
    if 1:
        g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Autocompleter ',color='blue')
        frame.putStatusLine(g.choose(k.enable_autocompleter,'On','Off'))
    
def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    if 1:
        g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Calltips ',color='blue')
        frame.putStatusLine(g.choose(k.enable_calltips,'On','Off'))</t>
<t tx="ekr.20061021144014.294">@nocolor

Added support for @bool sparse_move_outline_left

When True, Leo collapses the (former) parent of a node when moving that node left.
Takes getting used to, but I like it.

Note that the move-outline-up/down commands can have the effect of moving an outline left.

@color</t>
<t tx="ekr.20061021144014.295"></t>
<t tx="ekr.20061021144014.296">def demote (self,event=None):
    
    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext():
        c.treeWantsFocusNow()
        return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            c.treeWantsFocusNow()
            return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(current)  # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.297">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):
    
    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next:
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.298">parent = p.parent()

if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)
        
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20061021144014.299">def moveOutlineLeft (self,event=None):
    
    '''Move the selected node left if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasParent():
        c.treeWantsFocusNow()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20061021144014.300">def moveOutlineRight (self,event=None):
    
    '''Move the selected node right if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasBack:
        c.treeWantsFocusNow()
        return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeWantsFocusNow()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.301">def moveOutlineUp (self,event=None):
    
    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.302">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())
    
parent = p.parent()

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(oldRoot=c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20061021144014.303">def promote (self,event=None):
    
    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        c.treeWantsFocusNow()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
</t>
<t tx="ekr.20061021144014.304"># At long last Leo creates a proper help menu on the Mac.</t>
<t tx="ekr.20061021144014.305">def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&amp;Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)</t>
<t tx="ekr.20061021144014.306">def getMacHelpMenu (self):
    
    try:
        topMenu = self.getMenu('top')
        # Use the name argument to create the special Macintosh Help menu.
        helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        self.createMenuEntries(helpMenu,self.helpMenuTable)
        return helpMenu

    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None</t>
<t tx="ekr.20061021144014.307">This would greatly simplify menu entries.</t>
<t tx="ekr.20061021144014.308"># This is an important step towards making all menus configurable.</t>
<t tx="ekr.20061021144014.309"># \(\"(.*)\",.*\),  --&gt; '\1',</t>
<t tx="ekr.20061021144014.310">def capitalizeMinibufferMenuName (self,s,removeHyphens):
    
    result = []
    for i in xrange(len(s)):
        ch = s[i]
        prev = i &gt; 0 and s[i-1] or ''
        prevprev = i &gt; 1 and s[i-2] or ''
        if (
            i == 0 or
            i == 1 and prev == '&amp;' or
            prev == '-' or
            prev == '&amp;' and prevprev == '-'
        ):
            result.append(ch.capitalize())
        elif removeHyphens and ch == '-':
            result.append(' ')
        else:
            result.append(ch)
    return ''.join(result)</t>
<t tx="ekr.20061021144014.311">def defineMenuTables (self):
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

</t>
<t tx="ekr.20061021144014.312">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
</t>
<t tx="ekr.20061021144014.313">def defineEditMenuTopTable (self):
    
    self.editMenuTopTable = [
        # &amp;: u,r reserved for undo/redo: a,d,p,t,y.
        # &amp; (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&amp;t','cut-text'),
        ('Cop&amp;y','copy-text'),
        ('&amp;Paste','paste-text'),
        ('&amp;Delete','backward-delete-char'),
        ('Select &amp;All','select-all'),
        '-',
    ]
</t>
<t tx="ekr.20061021144014.314">def defineEditMenuEditBodyTable (self):
    
    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&amp;section',
        '*extract-&amp;names',
        '*&amp;extract',
        '-',
        '*convert-all-b&amp;lanks',
        '*convert-all-t&amp;abs',
        '*convert-&amp;blanks',
        '*convert-&amp;tabs',
        '*insert-body-&amp;time',
        '*&amp;reformat-paragraph',
        '-',
        '*&amp;indent-region',
        '*&amp;unindent-region',
        '*&amp;match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
</t>
<t tx="ekr.20061021144014.315">def defineEditMenuEditHeadlineTable (self):
    
    self.editMenuEditHeadlineTable = [
        '*edit-&amp;headline',
        '*&amp;end-edit-headline',
        '*&amp;abort-edit-headline',
        '*insert-headline-&amp;time',
        '*toggle-&amp;angle-brackets',
    ]
</t>
<t tx="ekr.20061021144014.316">def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &amp;: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&amp;open-find-tab',
        '*&amp;hide-find-tab',
        '*search-&amp;with-present-options',
        '-',
        '*find-tab-find-&amp;next',
        '*find-tab-find-&amp;prev',
        '*find-tab-&amp;change',
        '*find-tab-find-&amp;all',
        '*clone-fi&amp;nd-all',
        '*find-tab-change-a&amp;ll',
        '-',
        '*&amp;find-character',
        '*find-character-extend-&amp;selection',
        '*&amp;backward-find-character',
        '*backward-find-character-&amp;extend-selection',
        '-',
        '*&amp;isearch-forward',
        '*isea&amp;rch-backward',
        '*isearch-forward-rege&amp;xp',
        '*isearch-backward-regex&amp;p',
        '-',
        '*&amp;query-replace',
        '*q&amp;uery-replace-regex',
    ]
</t>
<t tx="ekr.20061021144014.317">def defineEditMenuTop2Table (self):
    
    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        '*&amp;goto-global-line',
        '*&amp;execute-script',
        (label,'toggle-invisibles'),
        ("Setti&amp;ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
</t>
<t tx="ekr.20061021144014.318">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
</t>
<t tx="ekr.20061021144014.319">def defineFileMenuTopTable (self):
    
    self.fileMenuTopTable = [
        '*&amp;new',
        ('&amp;Open...','open-outline'),
    ]
</t>
<t tx="ekr.20061021144014.320">def defineFileMenuTop2Table (self):
    
    self.fileMenuTop2Table = [
        '-',
        ('&amp;Close','close-window'),
        ('&amp;Save','save-file'),
        ('Save &amp;As','save-file-as'),
        ('Save &amp;To','save-file-to'),
        ('Re&amp;vert To Saved','revert'),
    ]
</t>
<t tx="ekr.20061021144014.321">def defineFileMenuReadWriteMenuTable (self):
    
    self.fileMenuReadWriteMenuTable = [
        '*&amp;read-outline-only',
        ('Read @file &amp;Nodes','read-at-file-nodes'),
        ('Write &amp;Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &amp;Missing @file Nodes','write-missing-at-file-nodes'),
        '*write-&amp;outline-only',
        ('&amp;Write @file Nodes','write-at-file-nodes'),
    ]
</t>
<t tx="ekr.20061021144014.322">def defineFileMenuTangleMenuTable (self):
    
    self.fileMenuTangleMenuTable = [
        '*tangle-&amp;all',
        '*tangle-&amp;marked',
        '*&amp;tangle',
    ]
</t>
<t tx="ekr.20061021144014.323">def defineFileMenuUntangleMenuTable (self):
    
    self.fileMenuUntangleMenuTable = [
        '*untangle-&amp;all',
        '*untangle-&amp;marked',
        '*&amp;untangle',
    ]
</t>
<t tx="ekr.20061021144014.324">def defineFileMenuImportMenuTable (self):
    
    self.fileMenuImportMenuTable = [
        #&amp;: c,d,f,n,o,r,
        '*import-&amp;derived-file',
        ('Import To @&amp;file','import-at-file'),
        ('Import To @&amp;root','import-at-root'),
        '*import-&amp;cweb-files',
        '*import-&amp;noweb-files',
        '*import-flattened-&amp;outline',
    ]
</t>
<t tx="ekr.20061021144014.325">def defineFileMenuExportMenuTable (self):
    
    self.fileMenuExportMenuTable = [
        '*export-&amp;headlines',
        '*outline-to-&amp;cweb',
        '*outline-to-&amp;noweb',
        '*&amp;flatten-outline',
        '*&amp;remove-sentinels',
        '*&amp;weave',
    ]
</t>
<t tx="ekr.20061021144014.326">def defineFileMenuTop3MenuTable (self):
    
    self.fileMenuTop3MenuTable = [
        ('E&amp;xit','exit-leo'),
    ]
</t>
<t tx="ekr.20061021144014.327">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
</t>
<t tx="ekr.20061021144014.328">def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&amp;ut-node',
        '*c&amp;opy-node',
        '*&amp;paste-node',
        ('Pas&amp;te Node As Clone','paste-retaining-clones'),
        '*&amp;delete-node',
        '-',
        '*&amp;insert-node',
        '*&amp;clone-node',
        '*sort-childre&amp;n',
        '*&amp;sort-siblings',
        '-',
        '*&amp;hoist',
        ('D&amp;e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
</t>
<t tx="ekr.20061021144014.329">def defineOutlineMenuCheckOutlineMenuTable (self):
    
    self.outlineMenuCheckOutlineMenuTable = [
        # &amp;: a,c,d,o
        '*check-&amp;outline',
        '*&amp;dump-outline',
        '-',
        '*check-&amp;all-python-code',
        '*&amp;check-python-code',
    ]
</t>
<t tx="ekr.20061021144014.330">def defineOutlineMenuExpandContractMenuTable (self):
    
    self.outlineMenuExpandContractMenuTable = [
        '*&amp;contract-all',
        '*contract-&amp;node',
        '*contract-&amp;parent',
        '*contract-or-go-&amp;left',
        '-',
        '*expand-p&amp;rev-level',
        '*expand-n&amp;ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&amp;1',
        '*expand-to-level-&amp;2',
        '*expand-to-level-&amp;3',
        '*expand-to-level-&amp;4',
        '*expand-to-level-&amp;5',
        '*expand-to-level-&amp;6',
        '*expand-to-level-&amp;7',
        '*expand-to-level-&amp;8',
        '-',
        '*expand-&amp;all',
        '*expand-n&amp;ode',
    ]
</t>
<t tx="ekr.20061021144014.331">def defineOutlineMenuMoveMenuTable (self):
    
    self.outlineMenuMoveMenuTable = [
        ('Move &amp;Down','move-outline-down'),
        ('Move &amp;Left','move-outline-left'),
        ('Move &amp;Right','move-outline-right'),
        ('Move &amp;Up','move-outline-up'),
        '-',
        '*&amp;promote',
        '*&amp;demote',
    ]
</t>
<t tx="ekr.20061021144014.332">def defineOutlineMenuMarkMenuTable (self):
    
    self.outlineMenuMarkMenuTable = [
        '*&amp;mark',
        '*mark-&amp;subheads',
        '*mark-changed-&amp;items',
        '*mark-changed-&amp;roots',
        '*mark-&amp;clones',
        '*&amp;unmark-all',
    ]
</t>
<t tx="ekr.20061021144014.333">def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &amp;: a,c,d,e,g,i,l,m,n,o,p,r,s,t,v,x
        ('Go Prev Visite&amp;d','go-back'),
        ('Go Next Visited','go-forward'),
        ('Go To P&amp;rev Node','goto-prev-node'),
        ('Go To N&amp;ext Node','goto-next-node'),
        '-',
        ('Go To Next &amp;Marked','goto-next-marked'),
        ('Go To Next &amp;Changed','goto-next-changed'),
        ('Go To Next &amp;Clone','goto-next-clone'),
        '-',
        ('&amp;Go To First Node','goto-first-node'),
        ('G&amp;o To Prev Visible','goto-prev-visible'),
        ('Go To Ne&amp;xt Visible','goto-next-visible'),
        ('Go To L&amp;ast Node','goto-last-node'),
        ('Go To Last &amp;Visible','goto-last-visible'),
        '-',
        ('Go To &amp;Parent','goto-parent'),
        ('Go To First &amp;Sibling','goto-first-sibling'),
        ('Go To Last S&amp;ibling','goto-last-sibling'),
        ('Go To Prev Sibli&amp;ng','goto-prev-sibling'),
        ('Go To Next Siblin&amp;g','goto-next-sibling'),
    ]
</t>
<t tx="ekr.20061021144014.334">def defineWindowMenuTables (self):
    
    self.windowMenuTopTable = [
        # &amp;: a,c,e,m,o,p,r,s
        '*&amp;equal-sized-panes',
        '*toggle-&amp;active-pane',
        '*toggle-&amp;split-direction',
        '-',
        '*&amp;resize-to-screen',
        '*&amp;cascade-windows',
        '*&amp;minimize-all',
        '-',
        '*&amp;open-compare-window',
        '*open-&amp;python-window',
    ]
</t>
<t tx="ekr.20061021144014.335"># The open-scripts-leo command.</t>
<t tx="ekr.20061021144014.336">def openLeoScripts (self,event=None):
    
    c = self
    fileName = g.os_path_join(g.app.loadDir,'..','scripts','scripts.leo')

    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es('not found: %s' % fileName)
</t>
<t tx="ekr.20061021144014.337"></t>
<t tx="ekr.20061021144014.338">@others
</t>
<t tx="ekr.20061021144014.339">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others
</t>
<t tx="ekr.20061021144014.340">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.
</t>
<t tx="ekr.20061021144014.341">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }
</t>
<t tx="ekr.20061021144014.342">def openSpellTab (self,event=None):
    
    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()
</t>
<t tx="ekr.20061021144014.343"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
</t>
<t tx="ekr.20061021144014.344">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others
</t>
<t tx="ekr.20061021144014.345"></t>
<t tx="ekr.20061021144014.346">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()
</t>
<t tx="ekr.20061021144014.347">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = AspellClass(c,dictionaryFileName,self.local_language_code)
    
    # if not self.aspell.aspell:
    if not self.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
</t>
<t tx="ekr.20061021144014.348">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)
</t>
<t tx="ekr.20061021144014.349">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
</t>
<t tx="ekr.20061021144014.350">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
</t>
<t tx="ekr.20061021144014.351"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
</t>
<t tx="ekr.20061021144014.352">def createBindings (self):
    
    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
</t>
<t tx="ekr.20061021144014.353">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d
</t>
<t tx="ekr.20061021144014.354"></t>
<t tx="ekr.20061021144014.355">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()
</t>
<t tx="ekr.20061021144014.356">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()
</t>
<t tx="ekr.20061021144014.357">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
</t>
<t tx="ekr.20061021144014.358">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.359">def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()
</t>
<t tx="ekr.20061021144014.360"></t>
<t tx="ekr.20061021144014.361">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
</t>
<t tx="ekr.20061021144014.362">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocusNow()
            return True

    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20061021144014.363">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20061021144014.364">def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []
</t>
<t tx="ekr.20061021144014.365">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()
</t>
<t tx="ekr.20061021144014.366"></t>
<t tx="ekr.20061021144014.367">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')
</t>
<t tx="ekr.20061021144014.368">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
</t>
<t tx="ekr.20061021144014.369">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word
</t>
<t tx="ekr.20061021144014.370">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
</t>
<t tx="ekr.20061021144014.371">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
</t>
<t tx="ekr.20061021144014.372">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)
</t>
<t tx="ekr.20061021144014.373">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.374">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.bodyWantsFocus()
</t>
<t tx="ekr.20061021144014.375">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
</t>
<t tx="ekr.20061021144014.376">class AspellClass:
    
    """A wrapper class for Aspell spell checker"""
    
    @others
</t>
<t tx="ekr.20061021144014.377"></t>
<t tx="ekr.20061021144014.378">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))
    
    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]
    
    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)
    
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    self.use_ctypes = g.CheckVersion(version,'2.5')
    self.aspell = self.sc = None
    
    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
</t>
<t tx="ekr.20061021144014.379">def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)</t>
<t tx="ekr.20061021144014.380">def getAspellWithCtypes (self):
    
    import ctypes
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    aspell = ctypes.CDLL(g.os_path_join(self.aspell_bin_dir, "aspell-15.dll"))

    &lt;&lt; define and configure aspell entry points &gt;&gt;

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
</t>
<t tx="ekr.20061021144014.381"># new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]</t>
<t tx="ekr.20061021144014.382">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it 
    """
    
    if self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
</t>
<t tx="ekr.20061021144014.383">def suggestions(self,word):

    "return list of words found"
    
    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList</t>
<t tx="ekr.20061021144014.384">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False
</t>
<t tx="ekr.20061021144014.385"></t>
<t tx="ekr.20061021144014.386">@nocolor

I think to make it as X-windowish as possible it should paste the 
selection, rather than the contents of the clipboard, when there is 
a selection.

Perhaps paste is the wrong word. In X-windows, when you middle-button-click in a
text frame, and there is a selection somewhere in the text frame, the contents
of that selection is inserted at the point you clicked - even if the insertion
cursor is elsewhere (e.g. at the end of the selection).
</t>
<t tx="ekr.20061021144014.387">@nocolor

If the selection is in a different frame, e.g. the log frame, middle 
button click in the body frame first pastes the clipboard text, then 
pastes the selected text in the middle of it :-} It should just 
paste the selected text.
</t>
<t tx="ekr.20061021144014.388">def OnPaste (self,event=None):
    
    return self.pasteText(event=event,middleButton=True)</t>
<t tx="ekr.20061021144014.389"></t>
<t tx="ekr.20061021144014.390">def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
</t>
<t tx="ekr.20061021144014.391">def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = g.app.gui.getAllText(w)
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s=g.app.gui.getAllText(w)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20061021144014.392">def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = g.app.gui.getTextSelection(w)  # Returns insert point if no selection.
    oldText = w.get('1.0','end')
    
    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)
    
    if middleButton and c.k.previousSelection:
        start,end = c.k.previousSelection
        s = w.get(start,end)
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20061021144014.393"></t>
<t tx="ekr.20061021144014.394">http://sourceforge.net/forum/message.php?msg_id=3958380
By: paulpaterson

Printing from the KeyBindings plugin is broken. The fix is,

Change (line 306, printKeys()): 

fname = os.path.abspath(g.os_path_join("..", "plugins", "keyreport.html"))

To:

fname = os.path.abspath(g.os_path_join("..", "..", "plugins",
"keyreport.html"))


(Note the additional "..")

It appears that the current directory in use when running Leo has changed to
/Leo/test/plugins ?!</t>
<t tx="ekr.20061021144014.395">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?</t>
<t tx="ekr.20061021144014.396">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3959003
By: nobody

The node navigator plugin does not show up in the plugins menu (also happens
in Leo4.4.1.1)

The quick fix was to revert to the default module-level __name__ attribute.
Presumably a better fix involves the plugins manager plugin.

The use of this plugin decreases when moving through the outline without the
mouse. Maybe some setting could be introduced to only include a node to the
'Recent' list when it has had focus for more than, say, 5 seconds? Or being
edited, of course.

Another suggestion might be to set _named_ marks for a (line in a?) node a la
vim (where its shortcut is m&lt;markname&gt;). I can remember about 3 or 4 marks when
analyzing code, and switching by only using the keyboard (shortcuts '&lt;markname&gt;
or `&lt;markname&gt;) works very good (for me) in vim. Switching between the two most
recent marks is done in vim using the shortcut '' or ``.
</t>
<t tx="ekr.20061021144014.397">@nocolor

(via email) Terry Brown</t>
<t tx="ekr.20061021144014.398">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3962632
By: paulpaterson

This isn't a problem in the manager or plugins menu as such - the plugins_menu
uses the __name__ attribute of a module to identify what to display. This shouldn't
be changed or the plugin wont display in the menu.

If you want to display a nice name in the plugins menu then you set the
__plugin_name__ attribute of a plugin.

There are four current plugins that break this rule,

nodenavigator
wordexport
newbuttons
rowcol

(ironically I had a hand in a few of those!)

All these plugins should have the line,

__name__ = "ldaldjalks"

replaced with

__plugin_name__ = "kjldldasd"


Regards,

Paul

</t>
<t tx="ekr.20061021144014.399">- Every button created by the plugin creates a corresponding command.  The command name is the 'cleaned' version of the button name.

- Every button created by the plugin also creates a delete-x-button command, where x is the command name as just discussed.  So now you can delete script buttons without right-clicking.

- I took the time to revise, refactor, clean up, reorganize and better document the code.  This was overdue: the previous code had grown difficult to understand through multiple small accretions.  I can actually understand the new code.

- This *might* have fixed the following crasher:

http://sourceforge.net/forum/message.php?msg_id=3962483
By: ktenney

right click on icon bar @button results in TK exception

TclError Exception in Tk callback
  Function: &lt;bound method Balloon._destroy of &lt;_Pmw.Pmw_1_2.lib.PmwBalloon.Balloon
instance at 0x020B2EB8&gt;&gt; (type: &lt;type 'instancemethod'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x01FB93C8&gt;,)
  Event type: DestroyNotify (type num: 17)
Traceback (innermost last):
  File "c:\python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747,
in __call__
    return apply(self.func, args)
  File "c:\python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBalloon.py", line 283,
in _destroy
    self.withdraw()
  File "&lt;string&gt;", line 1, in withdraw
    None
  File "c:\python24\lib\lib-tk\Tkinter.py", line 1541, in wm_withdraw
    return self.tk.call('wm', 'withdraw', self._w)
TclError: bad window path name ".20325440.23282432.23282712.34285688.33264144"
</t>
<t tx="ekr.20061021144014.400"></t>
<t tx="ekr.20061021144014.401">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3963935
By: terry_n_brown

Not working for me, with

@multipath /mnt/120/usr1/home/tbrown

or

@multipath /home/tbrown

the former being the symbolic link free form of the latter, but both fail the
same way, so I don't think  it's a symbolic link problem.

If /home/tbrown/itaseval.py doesn't exist I get:

multifile:  
Cant write itaseval.py to /mnt/120/usr1/home/tbrown
IOError, [Errno 2] No such file or directory: u'itaseval.py'

If I make it a zero length file I get

multifile:
Cant write itaseval.py to /mnt/120/usr1/home/tbrown
Error, `itaseval.py` and `/mnt/120/usr1/home/tbrown/itaseval.py` are the same
file

As I said /mnt/120/usr1/home/tbrown and /home/tbrown are equivalent, I was just
trying both to see if it's a symbolic link problem, but it doesn't seem to be.
</t>
<t tx="ekr.20061021144014.402">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3963657

This crash was due to the recent changes in the mod_scripting plugin, which the
shortcut_button plugin uses. The new code is much simpler than the old, and does
more.</t>
<t tx="ekr.20061021144014.403"></t>
<t tx="ekr.20061021144014.404">@nocolor

As always, you can set max_undo_stack_size in myLeoSettings.leo.</t>
<t tx="ekr.20061021144014.405">A highly useful option.
However, creating a new node always selects the entire text, regardless of this options.
</t>
<t tx="ekr.20061021144014.406">def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove('sel','1.0','end')
        selectAll = selectAll or c.config.getBool('select_all_text_when_editing_headlines')
        start = g.choose(selectAll,'1.0','end')
        w.tag_add('sel',start,'end')
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
</t>
<t tx="ekr.20061021144014.407">def editLabel (self,p,selectAll=False):
    
    """Start editing p's headline."""

    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
</t>
<t tx="ekr.20061021144014.408">def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20061021144014.409"># Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)
        c.frame.tree.editLabel(p,selectAll=selectAll)
        
        if k:
            k.setDefaultUnboundKeyAction()
            k.showStateAndMode()
</t>
<t tx="ekr.20061021144014.410">@nocolor

- Added bindings for toggle-autocompleter (Alt-1) and toggle-calltips (Alt-2)

- Ctrl-. and ctrl-( do not seem to do anything.

** Mystery solved: there was a trace in the calltip logic!

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off. It's been added to a 'later'
section of the to-do list.</t>
<t tx="ekr.20061021144014.411">@nocolor

Added the node: Candidates for settings in myLeoSettings.leo. This lists the
most 'controversial' settings in leoSetting.leo, and is a quick-start to
creating myLeoSettings.leo."
</t>
<t tx="ekr.20061021144014.412">- Added shift-ctrl keys to extend the selection.
focus-to-body = Alt-D
focus-to-tree = Alt-T
toggle-extend-mode = Alt-3</t>
<t tx="ekr.20061021144014.413">@nocolor

By: tibi ( Thiébaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
&lt; v = current.insertAsNthChild(0)
---
&gt; v = current.insertAsLastChild()

What I did:
    
Added @bool insert_new_nodes_at_end

@color</t>
<t tx="ekr.20061029091751.1"></t>
<t tx="ekr.20061029091751.2"></t>
<t tx="ekr.20061029091751.3">def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
</t>
<t tx="ekr.20061029091751.4">def initSettingsFiles (self):
    
    """Set self.globalConfigFile, self.homeFile and self.myConfigFile."""
    
    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    
    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)</t>
<t tx="ekr.20061029091751.5">def readSettingsFiles (self,fileName,verbose=True):
        
    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
    # Read all .leoRecentFiles.txt files.
    # The order of files in this list affects the order of the recent files list.
    seen = []
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20061029091751.6"># This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20061029091751.7"></t>
<t tx="ekr.20061029091751.8">def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()</t>
<t tx="ekr.20061029091751.9">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok</t>
<t tx="ekr.20061029091751.10">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20061029091751.11">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061029091811"></t>
<t tx="ekr.20061029091811.1"></t>
<t tx="ekr.20061029091811.2"></t>
<t tx="ekr.20061029091811.3">Typing in leoDocs.leo will show the problem.</t>
<t tx="ekr.20061029091811.4">def skip_string(s,i,verbose=True):
    
    '''Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True'''
    
    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')
    
    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20061029091811.5">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = self.editWidget(event)
    if not w: return 'break'

    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w) or (None,None)
    oldText = name.startswith('body') and p.bodyString() or ''
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    brackets = self.openBracketsList + self.closeBracketsList
    inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
    
    if trace: g.trace(name,repr(ch),ch in brackets)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)
        if inBrackets and self.flashMatchingBrackets: # New in 4.4.1.
           self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'
        
    # New in 4.4.1: Set the column for up and down keys.
    spot = w.index('insert')
    c.editCommands.setMoveCol(spot)

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20061029091811.6">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    if (
        (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
        undoType != "Change"
    ):
        # No auto-indent if in @nocolor mode or after a Change command.
        self.updateAutoIndent(p,w)
</t>
<t tx="ekr.20061029091811.7">def test_selfInsertCommand(self):
    
    self = c.editCommands
    event = g.Bunch(char='É',keysym=None,widget=c.frame.body.bodyCtrl)
    self.selfInsertCommand(event)</t>
<t tx="ekr.20061029091811.8">def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20061029091811.9">def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20061029091811.10">def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    def addFlashCallback(w,count,index):
        w.tag_add('flash',index,'%s+1c' % (index))
        w.after(delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        w.tag_remove('flash','1.0','end')
        if count &gt; 0:
            w.after(delay,addFlashCallback,w,count,index)

    try:
        w.tag_configure('flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass
</t>
<t tx="ekr.20061029091811.11">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
</t>
<t tx="ekr.20061029091811.12"># By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
</t>
<t tx="ekr.20061029091811.13">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
</t>
<t tx="ekr.20061029091811.14">def skip_matching_python_delims(s,i,delim1,delim2,reverse=False):
    
    '''Skip from the opening delim to the matching delim2.
    
    Return the index of the matching ')', or -1'''
    
    level = 0 ; n = len(s)
    assert(g.match(s,i,delim1))
    if reverse:
         while i &gt;= 0:
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i -= 1
            # Doesn't handle strings and comments properly...
            else: i -= 1
    else:
        while i &lt; n:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1
                if level &lt;= 0:  return i
                i += 1
            elif ch == '\'' or ch == '"': i = g.skip_string(s,i,verbose=False)
            elif g.match(s,i,'#'):  i = g.skip_to_end_of_line(s,i)
            else: i += 1
            if i == progress: return -1
    return -1
</t>
<t tx="ekr.20061029091811.15">@nocolor
@language python

http://sourceforge.net/forum/message.php?msg_id=3971242
By: nobody

I just tried to use mod_shadow plugin the first time and it took me sometime
to figure out that I immediately triggered a bug.

The problem is, that I use c++ as programming language, but leo only provides an
\@language c directive. This is OK for colorizing, but it prevents the mod_shadow
plugin to derive the correct file name extension from the language directive (at
least that´s what I guessed from the error messages). To fix it I simply copied
all c language entries in leoApp.py to create cpp new similar cpp language
entries. I have not tried to understand the code that triggers this error in
detail, so I don´t know if this fixes all issues, but at least it seems to work
at the moment.

@color</t>
<t tx="ekr.20061029091811.16"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20061029091811.17"></t>
<t tx="ekr.20061029091811.18">def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
</t>
<t tx="ekr.20061029091811.19">@nocolor

Two body editors open looking at the same node, so you can write 
code at the bottom of the body based on something close to the top. 
Let's say the top pane's showing a data structure defined a page or 
so down from the start of the body, and the bottom pane's showing a
method you're writing at the bottom on the body.

As soon as you enter a character in the bottom pane the point of 
view of the top pane snaps back to the first line of the body, no 
damage caused but now you can't see the datastructure definition you 
were using for reference.

This probably indicates that the body should be split into more than 
one node... but thought I'd let you know it was doing that anyway.

--------------

Still something funky I'm afraid.  Two body panes one above the 
other looking at the same body text.

Say each one is displaying 10 lines.

In one I scroll down to view lines 80-90 by dragging the scroll bar 
on the right, but when I click line 85 to position the cursor it 
jumps to line 5.

@color</t>
<t tx="ekr.20061029091811.20">def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    # Inactivate the previously active editor.
    # Don't capture ivars here! selectMainEditor keeps them up-to-date.
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
            w2.leo_selection = g.app.gui.getSelectionRange(w2)
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            break
    else:
        if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    &lt;&lt; restore the selection, insertion point and the scrollbar &gt;&gt;
    c.bodyWantsFocusNow()
    return 'break'</t>
<t tx="ekr.20061029091811.21"># g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
</t>
<t tx="ekr.20061029091811.22">def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol &lt;= xcol &lt;= jcol)
        if icol &lt;= xcol &lt;= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20061029091811.23">def onClick (self,event):
    
    c = self.c ; k = c.k
    w = event and event.widget
    wname = c.widget_name(w)
    
    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        x, y = event.x, event.y
        k.previousSelection = g.app.gui.getSelectionRange(w)
        i = w.index('@%s,%s' % (x,y))
        # g.trace(x,y,i)
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')</t>
<t tx="ekr.20061029091811.24">def createTextWidget (self,frame,parentFrame,p,name):
    
    c = self.c
    
    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = w = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    
    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y)
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)
   
    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
    w.leo_active = True
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w</t>
<t tx="ekr.20061029091811.25">@nocolor

The new colorizer was innocent: the problem is that at.directiveKind4 uses leoColor.leoKeywords,
so multipath must add entroes to leoColor.leoColors.

This should be changed, but it is too late in the development cycle to do more than put a band-aid on the problem.

@color</t>
<t tx="ekr.20061029091811.26">def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 &gt;= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
</t>
<t tx="ekr.20061029091811.27">def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
</t>
<t tx="ekr.20061029091811.28"># leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" ]
</t>
<t tx="ekr.20061029091811.29"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i &lt; n:
        if s[i] == '@' and i+1 &lt; n:
            &lt;&lt; set theDict for @ directives &gt;&gt;
        elif root and g.match(s,i,"&lt;&lt;"):
            &lt;&lt; set theDict["root"] for noweb * chunks &gt;&gt;
        i = g.skip_line(s,i)
    return theDict
</t>
<t tx="ekr.20061029091811.30">j = g.skip_c_id(s,i+1)
word = s[i+1:j]

global globalDirectiveList

if word in globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
</t>
<t tx="ekr.20061029091811.31">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
</t>
<t tx="ekr.20061029091811.32">@ 

New colorizer did not handle @&lt;newline&gt; properly.
(It required a space after the '@').</t>
<t tx="ekr.20061029091811.33">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3975898

If the setting "@int initial_window_left" has a value of 0 (zero), leo starts
up without showing a single pane.

@color</t>
<t tx="ekr.20061029091811.34">def setInitialWindowGeometry(self):
    
    """Set the position and size of the frame to config params."""
    
    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10
    
    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
</t>
<t tx="ekr.20061029091811.35">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3978307
By: johnmwhite

The auto-creation of .leoRecentFiles.txt doesn't seem to work. Everything is
fine if myLeoSettings.leo is in the home directory along with .leoRecentFiles.txt,
but strange things happen if .leoRecentFiles.txt does not exist.

----

I simply removed a very misleading message in writeRecentFiles.</t>
<t tx="ekr.20061029091811.36"></t>
<t tx="ekr.20061029091811.37">def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
</t>
<t tx="ekr.20061029091811.38">def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) &gt; 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
</t>
<t tx="ekr.20061029091811.39">def computeLeoDir ():
    
    loadDir = g.app.loadDir
    
    g.app.leoDir = theDir = g.os_path_dirname(loadDir)
    
    if theDir not in sys.path:
        sys.path.append(theDir)
        
    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
</t>
<t tx="ekr.20061029091811.40">def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        ### import leo
        import sys
        
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) &gt; 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
</t>
<t tx="ekr.20061029091811.41">def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    if 0:
        import sys
        for s in sys.path: g.trace(s)
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
        
    g.app.leoDir = g.computeLeoDir()
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
        
    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
</t>
<t tx="ekr.20061029091811.42">def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
</t>
<t tx="ekr.20061029091811.43"></t>
<t tx="ekr.20061029091811.44">def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()</t>
<t tx="ekr.20061029091811.45">def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        print ('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok</t>
<t tx="ekr.20061029091811.46">def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
</t>
<t tx="ekr.20061029091811.47">def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
</t>
<t tx="ekr.20061029091811.48"></t>
<t tx="ekr.20061029091811.49">@nocolor

See the node Users Guide--&gt;Chapter 18: Emacs and Leo in LeoDocs.leo for full details.</t>
<t tx="ekr.20061029091811.50"># It is set by tkFrame.finishCreate</t>
<t tx="ekr.20061029091811.51">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame</t>
<t tx="ekr.20061029091811.52">def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    app = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    &lt;&lt; compute the window title &gt;&gt;

    # Create an unfinished frame to pass to the commanders.
    frame = app.gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
        
    frame.finishCreate(c)
    c.finishCreate()
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
</t>
<t tx="ekr.20061029091811.53"># Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n &gt; 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
</t>
<t tx="ekr.20061029091811.54">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            if c.config.getBool('outline_pane_has_initial_focus'):
                c.treeWantsFocusNow()
            else:
                c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20061029091811.55">def run(fileName=None,pymacs=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    &lt;&lt; start psycho &gt;&gt;
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20061029091811.56"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
</t>
<t tx="ekr.20061029091811.57">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
</t>
<t tx="ekr.20061029091811.58">if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        g.app.use_psyco = False
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
        g.app.use_psyco = False
</t>
<t tx="ekr.20061029091811.59">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20061029091811.60">def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
</t>
<t tx="ekr.20061029091811.61">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20061029091811.62">def getBatchScript ():
    
    import leoGlobals as g
    windowFlag = False
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script, windowFlag
</t>
<t tx="ekr.20061029091811.63">def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
</t>
<t tx="ekr.20061029091811.64">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3980193

What I'm needing is 2 commands:

1) move cursor to the end of the current word (if cursor is in a word) or end
of next word (if cursor is not in a word), WITHOUT SELECTING - the functionality
of Ctrl-RtArrow in normal editors

2) extend selection from current cursor position to the end of the current or
next word - the functionality of Shift-Ctrl-RtArrow in normal editors.

EKR: The term 'normal' editor is misleading.  There are two different ways of moving forward:
forward-word and forward-end-word.

@color</t>
<t tx="ekr.20061029091811.65">def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char',
        'back-&amp;paragraph',
        'back-&amp;sentence',
        'back-&amp;word',
        '-',
        'beginning-of-&amp;buffer',
        'beginning-of-&amp;line',
        '-',
        'pre&amp;vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &amp;: b,c,l,p,s,v,w
        'back-&amp;char-extend-selection',
        'back-&amp;paragraph-extend-selection',
        'back-&amp;sentence-extend-selection',
        'back-&amp;word-extend-selection',
        '-',
        'beginning-of-&amp;buffer-extend-selection',
        'beginning-of-&amp;line-extend-selection',
        '-',
        'pre&amp;vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &amp;: l,p,s,w
        'extend-to-&amp;line',
        'extend-to-&amp;paragraph',
        'extend-to-&amp;sentence',
        'extend-to-&amp;word',
    ]
    
    self.cursorMenuForwardTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer',
        'end-of-&amp;line',
        '-',
        'forward-&amp;char',
        'forward-&amp;paragraph',
        'forward-&amp;sentence',
        'forward-&amp;end-word',
        'forward-&amp;word',
        '-',
        '&amp;next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &amp;: b,c,e,l,n,p,s,w
        'end-of-&amp;buffer-extend-selection',
        'end-of-&amp;line-extend-selection',
        '-',
        'forward-&amp;char-extend-selection',
        'forward-&amp;paragraph-extend-selection',
        'forward-&amp;sentence-extend-selection',
        'forward-&amp;end-word-extend-selection',
        'forward-&amp;word-extend-selection',#
        '-',
        '&amp;next-line-extend-selection',    
    ]</t>
<t tx="ekr.20061029091811.66">def getPublicCommands (self):        

    c = self.c ; k = self.k 

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20061029091811.67">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)
    
def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)
        
def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20061029091811.68">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    c.widgetWantsFocusNow(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)

    i = toPython(w.index('insert'))
    
    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1
    
    self.moveToHelper(event,toGui(i),extend)</t>
<t tx="ekr.20061029091811.69">def runEditCommandTest (c,p):
    
    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)
    
    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    
    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        g.app.gui.setTextSelection(w,sel1[0],sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'expected body: %s, got: %s' % (repr(s1),repr(s2))
        sel3 = g.app.gui.getTextSelection(w)
        assert sel2 == sel3, 'expected sel: %s, got: %s' % (sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20061029091830"></t>
</tnodes>
</leo_file>
