<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="5467" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="5" left="125" height="827" width="953"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20040801060323" a="E"><vh>Old Projects</vh>
<v t="ekr.20031218072017.1924"><vh> Waiting for help from Linux people</vh>
<v t="ekr.20031218072017.1925"><vh>Paste bug (Linux only)</vh>
<v t="ekr.20031218072017.1331"><vh>onBodyWillChange</vh></v>
<v t="ekr.20031218072017.843"><vh>frame.OnPaste &amp; OnPasteFromMenu</vh></v>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1926"><vh>Linux headline bug</vh></v>
</v>
<v t="ekr.20050924073836" a="E"><vh>4.4 projects</vh>
<v t="ekr.20060227101317" a="E"><vh>Found memory leaks</vh></v>
<v t="ekr.20060106104442"><vh>4.4a5 projects</vh>
<v t="ekr.20060106104442.1"><vh>cvs snapshot 1</vh>
<v t="ekr.20060106104442.2"><vh>Bugs fixed</vh>
<v t="ekr.20060106104442.3"><vh>Made sure focus doesn't go to log during tab completion or after writes to log</vh>
<v t="ekr.20060106104442.4"><vh>put</vh>
<v t="ekr.20060106104442.5"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20060106104442.6"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.7"><vh>Fixed problem with getScript in batch mode</vh>
<v t="ekr.20060106104442.8"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20060106104442.9"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
</v>
<v t="ekr.20060106104442.10"><vh>Select text box in goto-line-number command</vh>
<v t="ekr.20060106104442.11"><vh>Report</vh></v>
<v t="ekr.20060106104442.12"><vh>tkinterAskOKCancelNumber.createFrame</vh></v>
</v>
<v t="ekr.20060106104442.13"><vh>Restored headkey hooks</vh>
<v t="ekr.20060106104442.14"><vh>Report</vh></v>
<v t="ekr.20060106104442.15"><vh>head key handlers</vh>
<v t="ekr.20060106104442.16"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.18"><vh>onHeadChanged</vh>
<v t="ekr.20060106104442.19"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.20"><vh>Restored bodykey hooks</vh>
<v t="ekr.20060106104442.21"><vh>Report</vh></v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.28"><vh>Fixed ancient bug in read error logic that hung Leo</vh>
<v t="ekr.20060106104442.29"><vh>Report &amp; what I did</vh></v>
<v t="ekr.20060106104442.30"><vh>readError</vh></v>
<v t="ekr.20060106104442.31"><vh>atFile.error</vh></v>
<v t="ekr.20060106104442.32"><vh>readOpenFile</vh>
<v t="ekr.20060106104442.33"><vh>&lt;&lt; handle first and last lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.34"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20060106104442.35"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20060106104442.36"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20060106104442.37"><vh>readNormalLine</vh>
<v t="ekr.20060106104442.38"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20060106104442.39"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.40"><vh>start sentinels</vh>
<v t="ekr.20060106104442.41"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20060106104442.42"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20060106104442.43"><vh>readStartLeo</vh></v>
<v t="ekr.20060106104442.44"><vh>readStartMiddle</vh></v>
<v t="ekr.20060106104442.45"><vh>readStartNode (4.x)</vh>
<v t="ekr.20060106104442.46"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20060106104442.47"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20060106104442.48"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.49"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20060106104442.50"><vh>end sentinels</vh>
<v t="ekr.20060106104442.51"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20060106104442.52"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20060106104442.53"><vh>readEndLeo</vh></v>
<v t="ekr.20060106104442.54"><vh>readEndMiddle</vh></v>
<v t="ekr.20060106104442.55"><vh>readEndNode (4.x)</vh>
<v t="ekr.20060106104442.56"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20060106104442.57"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.58"><vh>readEndOthers</vh></v>
<v t="ekr.20060106104442.59"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20060106104442.60"><vh>Unpaired sentinels</vh>
<v t="ekr.20060106104442.61"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20060106104442.62"><vh>readAfterRef</vh></v>
<v t="ekr.20060106104442.63"><vh>readClone</vh></v>
<v t="ekr.20060106104442.64"><vh>readComment</vh></v>
<v t="ekr.20060106104442.65"><vh>readDelims</vh></v>
<v t="ekr.20060106104442.66"><vh>readDirective (@@)</vh>
<v t="ekr.20060106104442.67"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20060106104442.68"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.69"><vh>readNl</vh></v>
<v t="ekr.20060106104442.70"><vh>readNonl</vh></v>
<v t="ekr.20060106104442.71"><vh>readRef</vh></v>
<v t="ekr.20060106104442.72"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20060106104442.73"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
<v t="ekr.20060106104442.74"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20060106104442.75"><vh>Fixed minor headline problems</vh>
<v t="ekr.20060106104442.76"><vh>Report</vh></v>
<v t="ekr.20060106104442.77"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060106104442.78"><vh>copyText</vh></v>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060106104442.81"><vh>Fixed problem in reformatParagraph</vh></v>
<v t="ekr.20060106104442.82"><vh>Investigated secondary ratio problems</vh>
<v t="ekr.20060106104442.83"><vh>Notes</vh></v>
<v t="ekr.20060106104442.84"><vh>initialRatios</vh></v>
</v>
<v t="ekr.20060106104442.85"><vh>Installed LeoUsers patch for the Read @file Nodes command</vh>
<v t="ekr.20060106104442.86"><vh>What I did</vh></v>
<v t="ekr.20060106104442.87"><vh>atFile.__init__ &amp; initIvars</vh>
<v t="ekr.20060106104442.88"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.89"><vh>createThinChild4</vh></v>
<v t="ekr.20060106104442.90"><vh>atFile.__init__ and initIvars NEW</vh>
<v t="ekr.20060106104442.91"><vh> define the dispatch dictionary used by scanText4</vh></v>
</v>
<v t="ekr.20060106104442.92"><vh>createThinChild4 NEW</vh></v>
</v>
<v t="ekr.20060106104442.93"><vh>Fixed bug: clicking in the expand/contract box didn't save the headline</vh>
<v t="ekr.20060106104442.94"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060106104442.95"><vh>Installed LeoUser's patch for Read derived files</vh>
<v t="ekr.20060106104442.96"><vh>atFile.forceGnxOnPosition</vh></v>
<v t="ekr.20060106104442.97" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20060106104442.98"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.99"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.100"><vh>New features</vh>
<v t="ekr.20060106104442.101"><vh>created ut.leo, ut.py and ut.bat</vh></v>
<v t="ekr.20060106104442.102"><vh>Added modes/*.xml to distribution</vh></v>
<v t="ekr.20060106104442.103"><vh>Added 'insert' keyword to setTextSelection methods</vh>
<v t="ekr.20060106104442.104"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060106104442.105"><vh>(Revised cursor movement commands and added selection-extension commands)</vh>
<v t="ekr.20060106104442.106"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.125"><vh>Code changes</vh>
<v t="ekr.20060106104442.126"><vh>(Rewrote cut/copy/paste code)</vh>
<v t="ekr.20060106104442.77"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060106104442.78"><vh>copyText</vh></v>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060106104442.127"><vh>(Revised headline handlers)</vh>
<v t="ekr.20060106104442.128"><vh> What I did</vh>
<v t="ekr.20060106104442.129"><vh>Replaced calls to onHeadChanged by calls to c.endEditing</vh>
<v t="ekr.20060106104442.130"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20060106104442.131"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060106104442.132"><vh>renameBuffer</vh></v>
</v>
</v>
<v t="ekr.20060106104442.133"><vh>Notes</vh></v>
<v t="ekr.20060106104442.134"><vh>Selecting &amp; editing... (tkTree)</vh>
<v t="ekr.20060106104442.135"><vh>tree.endEditLabel</vh></v>
<v t="ekr.20060106104442.136"><vh>editLabel</vh></v>
<v t="ekr.20060106104442.137" a="M"><vh>tree.select</vh>
<v t="ekr.20060106104442.138"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.139"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.140"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060106104442.141"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060106104442.142"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.143"><vh>tree.set...LabelState</vh>
<v t="ekr.20060106104442.144"><vh>setEditLabelState</vh></v>
<v t="ekr.20060106104442.145"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20060106104442.146"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20060106104442.147"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20060106104442.148"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20060106104442.149"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20060106104442.150"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20060106104442.151"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20060106104442.15"><vh>head key handlers</vh>
<v t="ekr.20060106104442.16"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.18"><vh>onHeadChanged</vh>
<v t="ekr.20060106104442.19"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.152"><vh>Calls to tree.endEditLabel</vh>
<v t="ekr.20060106104442.153"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20060106104442.17"><vh>updateHead</vh></v>
<v t="ekr.20060106104442.154"><vh>Icon Box...</vh>
<v t="ekr.20060106104442.155"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060106104442.156"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060106104442.157"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060106104442.158"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060106104442.159"><vh>Calls to onHeadChanged</vh>
<v t="ekr.20060106104442.160"><vh>toggleAngleBrackets</vh></v>
<v t="ekr.20060106104442.161"><vh>changeSelection</vh></v>
<v t="ekr.20060106104442.162"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20060106104442.163"><vh>Should *not* call onHeadChanged</vh>
<v t="ekr.20060106104442.79"><vh>cutText</vh></v>
<v t="ekr.20060106104442.80"><vh>pasteText</vh></v>
</v>
<v t="ekr.20060106104442.164"><vh>(Restored c.begin/endUpdate)</vh>
<v t="ekr.20060106104442.165"><vh>What I did</vh></v>
<v t="ekr.20060106104442.166"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20060106104442.167"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20060106104442.168"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20060106104442.169"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20060106104442.170"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060106104442.171" a="M"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060106104442.172"><vh>c.bringToFront</vh></v>
<v t="ekr.20060106104442.173"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060106104442.174"><vh>c.recolor_now</vh></v>
<v t="ekr.20060106104442.175"><vh>c.redraw_now</vh></v>
</v>
<v t="ekr.20060106104442.176"><vh>Drawing... (tkTree)</vh>
<v t="ekr.20060106104442.177"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20060106104442.178"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060106104442.179"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060106104442.180"><vh>idle_second_redraw</vh></v>
<v t="ekr.20060106104442.181"><vh>drawX...</vh>
<v t="ekr.20060106104442.182"><vh>drawBox</vh></v>
<v t="ekr.20060106104442.183"><vh>drawClickBox</vh>
<v t="ekr.20060106104442.184"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.185"><vh>drawIcon</vh>
<v t="ekr.20060106104442.186"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.187"><vh>drawLine</vh></v>
<v t="ekr.20060106104442.188"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20060106104442.189"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20060106104442.190"><vh>drawText</vh>
<v t="ekr.20060106104442.191"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.192"><vh>drawUserIcons</vh></v>
<v t="ekr.20060106104442.193"><vh>drawUserIcon</vh>
<v t="ekr.20060106104442.194"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20060106104442.195"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20060106104442.196"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.197"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.198"><vh>drawTopTree</vh></v>
<v t="ekr.20060106104442.199"><vh>drawTree</vh></v>
</v>
<v t="ekr.20060106104442.200"><vh>Helpers...</vh>
<v t="ekr.20060106104442.201"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20060106104442.202"><vh>getIconImage</vh></v>
<v t="ekr.20060106104442.203"><vh>scrollTo</vh>
<v t="ekr.20060106104442.204"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20060106104442.205"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.206"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20060106104442.207"><vh>yoffset</vh></v>
</v>
</v>
<v t="ekr.20060106104442.208"><vh>@@button insert begin/endUpdate</vh></v>
</v>
</v>
<v t="ekr.20060106104442.209"><vh>(Revised key binding code)</vh>
<v t="ekr.20060106104442.210"><vh>Notes</vh>
<v t="ekr.20060106104442.211"><vh>Create commands for all Tk defaults key</vh></v>
<v t="ekr.20060106104442.212"><vh>Create selection mode</vh>
<v t="ekr.20060106104442.213"><vh>Posting</vh></v>
</v>
<v t="ekr.20060106104442.214"><vh>Problems</vh>
<v t="ekr.20060106104442.215"><vh>forward-sentence-extend-selection doesn't work when invoked by long name</vh></v>
<v t="ekr.20060106104442.216"><vh>Backspace  deletes 2 chars everywhere</vh></v>
</v>
<v t="ekr.20060106104442.217"><vh>Make arrow keys work properly both in the canvas and in headlines</vh></v>
</v>
<v t="ekr.20060106104442.218"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20060106104442.219"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20060106104442.220"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20060106104442.221"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20060106104442.222"><vh>Dialog</vh>
<v t="ekr.20060106104442.223"><vh>get_window_info</vh></v>
<v t="ekr.20060106104442.224"><vh>center_dialog</vh></v>
<v t="ekr.20060106104442.225"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20060106104442.226"><vh>Focus</vh>
<v t="ekr.20060106104442.227"><vh>get_focus</vh></v>
<v t="ekr.20060106104442.228" a="M"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20060106104442.229"><vh>widget_wants_focus (tk.gui)</vh></v>
</v>
<v t="ekr.20060106104442.230"><vh>Font</vh>
<v t="ekr.20060106104442.231"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20060106104442.232"><vh>Icons</vh>
<v t="ekr.20060106104442.233"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20060106104442.234"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20060106104442.235"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20060106104442.236"><vh>Idle Time</vh>
<v t="ekr.20060106104442.237"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20060106104442.238"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20060106104442.239"><vh>Indices (Tk)</vh>
<v t="ekr.20060106104442.240"><vh>firstIndex</vh></v>
<v t="ekr.20060106104442.241"><vh>lastIndex</vh></v>
<v t="ekr.20060106104442.242"><vh>moveIndexBackward</vh></v>
<v t="ekr.20060106104442.243"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20060106104442.244"><vh>compareIndices</vh></v>
<v t="ekr.20060106104442.245"><vh>getindex</vh></v>
</v>
<v t="ekr.20060106104442.246"><vh>Insert Point</vh>
<v t="ekr.20060106104442.247"><vh>getInsertPoint</vh></v>
<v t="ekr.20060106104442.248"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20060106104442.249"><vh>Selection</vh>
<v t="ekr.20060106104442.250"><vh>getSelectionRange (to be deleted?)</vh></v>
<v t="ekr.20060106104442.251"><vh>getSelectedText</vh></v>
<v t="ekr.20060106104442.252"><vh>getTextSelection</vh></v>
<v t="ekr.20060106104442.253"><vh>hasSelection</vh></v>
<v t="ekr.20060106104442.254"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20060106104442.104"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20060106104442.255"><vh>Text</vh>
<v t="ekr.20060106104442.256"><vh>getAllText</vh></v>
<v t="ekr.20060106104442.257"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20060106104442.258"><vh>getCharAtIndex</vh></v>
<v t="ekr.20060106104442.259"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20060106104442.260"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20060106104442.261"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20060106104442.262"><vh>Visibility</vh>
<v t="ekr.20060106104442.263"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20060106104442.264"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060106104442.265"><vh>class editCommandsClass</vh>
<v t="ekr.20060106104442.266"><vh> birth</vh>
<v t="ekr.20060106104442.267"><vh> ctor</vh></v>
<v t="ekr.20060106104442.106"><vh> getPublicCommands (editCommandsClass)</vh></v>
</v>
<v t="ekr.20060106104442.268"><vh>capitalization &amp; case</vh>
<v t="ekr.20060106104442.269"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20060106104442.270" a="M"><vh>changePreviousWord</vh></v>
<v t="ekr.20060106104442.271"><vh>capitalizeHelper</vh></v>
</v>
<v t="ekr.20060106104442.272"><vh>color &amp; font</vh>
<v t="ekr.20060106104442.273"><vh>show-colors</vh>
<v t="ekr.20060106104442.274"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
<v t="ekr.20060106104442.275"><vh>createColorPicker</vh>
<v t="ekr.20060106104442.276"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20060106104442.277"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060106104442.278"><vh>show-fonts &amp; helpers</vh>
<v t="ekr.20060106104442.279"><vh>createFontPicker</vh>
<v t="ekr.20060106104442.280"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20060106104442.281"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20060106104442.282"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20060106104442.283"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20060106104442.284"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20060106104442.285"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20060106104442.286"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.287" a="M"><vh>getFont</vh></v>
<v t="ekr.20060106104442.288"><vh>setFont</vh></v>
</v>
</v>
<v t="ekr.20060106104442.289"><vh>comment column...</vh>
<v t="ekr.20060106104442.290"><vh>setCommentColumn</vh></v>
<v t="ekr.20060106104442.291"><vh>indentToCommentColumn</vh></v>
</v>
<v t="ekr.20060106104442.292"><vh>dynamic abbreviation...</vh>
<v t="ekr.20060106104442.293"><vh>dynamicExpansion</vh></v>
<v t="ekr.20060106104442.294"><vh>dynamicExpansion2</vh></v>
<v t="ekr.20060106104442.295"><vh>getDynamicList (helper)</vh></v>
</v>
<v t="ekr.20060106104442.296"><vh>esc methods for Python evaluation</vh>
<v t="ekr.20060106104442.297"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20060106104442.298"><vh>escEvaluate (Revise)</vh></v>
</v>
<v t="ekr.20060106104442.299"><vh>evalExpression</vh></v>
<v t="ekr.20060106104442.300"><vh>focus (editCommandsClass)</vh>
<v t="ekr.20060106104442.301"><vh>focusToBody/Log/Tree/Minibuffer</vh></v>
<v t="ekr.20060106104442.302"><vh>cycleFocus</vh></v>
</v>
<v t="ekr.20060106104442.303"><vh>fill column and centering</vh>
<v t="ekr.20060106104442.304"><vh>centerLine</vh></v>
<v t="ekr.20060106104442.305"><vh>setFillColumn</vh></v>
<v t="ekr.20060106104442.306"><vh>centerRegion</vh></v>
<v t="ekr.20060106104442.307"><vh>setFillPrefix</vh></v>
<v t="ekr.20060106104442.308"><vh>_addPrefix</vh></v>
</v>
<v t="ekr.20060106104442.309"><vh>goto...</vh>
<v t="ekr.20060106104442.310"><vh>gotoCharacter</vh></v>
<v t="ekr.20060106104442.311"><vh>gotoLine</vh></v>
</v>
<v t="ekr.20060106104442.312"><vh>indent... (To do: undo)</vh>
<v t="ekr.20060106104442.313"><vh>backToIndentation</vh></v>
<v t="ekr.20060106104442.314"><vh>deleteIndentation</vh></v>
<v t="ekr.20060106104442.315"><vh>insertNewLineIndent</vh></v>
<v t="ekr.20060106104442.316"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20060106104442.317"><vh>insert &amp; delete...</vh>
<v t="ekr.20060106104442.318" a="M"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060106104442.319"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.320"><vh>deleteNextChar</vh></v>
<v t="ekr.20060106104442.321"><vh>deleteSpaces</vh></v>
<v t="ekr.20060106104442.322"><vh>removeBlankLines</vh></v>
<v t="ekr.20060106104442.323"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060106104442.324"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060106104442.325"><vh>insertParentheses</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.326"><vh>info...</vh>
<v t="ekr.20060106104442.327"><vh>howMany</vh></v>
<v t="ekr.20060106104442.328"><vh>lineNumber</vh></v>
<v t="ekr.20060106104442.329"><vh>viewLossage</vh></v>
<v t="ekr.20060106104442.330"><vh>whatLine</vh></v>
</v>
<v t="ekr.20060106104442.331"><vh>line...</vh>
<v t="ekr.20060106104442.332"><vh>flushLines</vh></v>
<v t="ekr.20060106104442.333"><vh>keepLines</vh></v>
<v t="ekr.20060106104442.334"><vh>linesHelper</vh></v>
</v>
<v t="ekr.20060106104442.335"><vh>measure</vh></v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
<v t="ekr.20060106104442.336"><vh>paragraph...</vh>
<v t="ekr.20060106104442.337"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20060106104442.338"><vh>fillParagraph</vh></v>
<v t="ekr.20060106104442.339"><vh>fillRegion</vh></v>
<v t="ekr.20060106104442.340"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20060106104442.341"><vh>killParagraph (Test)</vh></v>
<v t="ekr.20060106104442.342"><vh>selectParagraph &amp; helper</vh>
<v t="ekr.20060106104442.343"><vh>selectParagraphHelper</vh></v>
</v>
</v>
<v t="ekr.20060106104442.344"><vh>region...</vh>
<v t="ekr.20060106104442.345"><vh>setRegion</vh>
<v t="ekr.20060106104442.346"><vh>down</vh></v>
<v t="ekr.20060106104442.347"><vh>extend</vh></v>
<v t="ekr.20060106104442.348"><vh>truncate</vh></v>
<v t="ekr.20060106104442.349"><vh>up</vh></v>
</v>
<v t="ekr.20060106104442.350"><vh>indentRegion</vh></v>
<v t="ekr.20060106104442.351"><vh>tabIndentRegion</vh></v>
<v t="ekr.20060106104442.352"><vh>countRegion</vh></v>
<v t="ekr.20060106104442.353"><vh>reverseRegion</vh></v>
<v t="ekr.20060106104442.354"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
<v t="ekr.20060106104442.355"><vh>replace...</vh>
<v t="ekr.20060106104442.356"><vh>replaceString</vh>
<v t="ekr.20060106104442.357"><vh>&lt;&lt; do the replace &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.358"><vh>activateReplaceRegex</vh></v>
</v>
<v t="ekr.20060106104442.359"><vh>scrollUp/Down</vh></v>
<v t="ekr.20060106104442.360"><vh>sort...</vh>
<v t="ekr.20060106104442.361"><vh>sortLines</vh></v>
<v t="ekr.20060106104442.362"><vh>sortColumns</vh></v>
<v t="ekr.20060106104442.363"><vh>sortFields</vh></v>
</v>
<v t="ekr.20060106104442.364"><vh>swap/transpose...</vh>
<v t="ekr.20060106104442.365"><vh>transposeLines</vh></v>
<v t="ekr.20060106104442.366"><vh>swapWords &amp; transposeWords</vh></v>
<v t="ekr.20060106104442.367"><vh>swapCharacters &amp; transeposeCharacters</vh></v>
</v>
<v t="ekr.20060106104442.368"><vh>tabify &amp; untabify</vh></v>
</v>
<v t="ekr.20060106104442.107"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20060106104442.108"><vh> helpers</vh>
<v t="ekr.20060106104442.109" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20060106104442.110" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20060106104442.111" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060106104442.112" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060106104442.113" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060106104442.114" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060106104442.115" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060106104442.116" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20060106104442.117" a="M"><vh>extendMode</vh></v>
<v t="ekr.20060106104442.118"><vh>buffers</vh></v>
<v t="ekr.20060106104442.119"><vh>characters</vh></v>
<v t="ekr.20060106104442.120"><vh>lines</vh></v>
<v t="ekr.20060106104442.121"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060106104442.122"><vh>paragraphs</vh></v>
<v t="ekr.20060106104442.123"><vh>sentences</vh></v>
<v t="ekr.20060106104442.124"><vh>words</vh></v>
</v>
<v t="ekr.20060106104442.317"><vh>insert &amp; delete...</vh>
<v t="ekr.20060106104442.318" a="M"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060106104442.319"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.320"><vh>deleteNextChar</vh></v>
<v t="ekr.20060106104442.321"><vh>deleteSpaces</vh></v>
<v t="ekr.20060106104442.322"><vh>removeBlankLines</vh></v>
<v t="ekr.20060106104442.323"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20060106104442.324"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20060106104442.325"><vh>insertParentheses</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20060106104442.369"><vh>tkTtree.setBindings</vh></v>
</v>
<v t="ekr.20060106104442.370"><vh>(Revised general text widget handlers)</vh>
<v t="ekr.20060106104442.371"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060106104442.372"><vh>k.onTextWidgetKey &amp; insertString</vh></v>
</v>
<v t="ekr.20060106104442.373"><vh>(Moved headline coloring code out of endEditLabel and into select)</vh>
<v t="ekr.20060106104442.374"><vh>What I did</vh></v>
<v t="ekr.20060106104442.137" a="M"><vh>tree.select</vh>
<v t="ekr.20060106104442.138"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.139"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060106104442.140"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060106104442.141"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060106104442.142"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.131"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060106104442.135"><vh>tree.endEditLabel</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.375"><vh>Bugs</vh>
<v t="ekr.20060106104442.376"><vh>Installed Brian's patch for Import Derived files</vh>
<v t="ekr.20060106104442.97" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20060106104442.98"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20060106104442.99"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
<v t="ekr.20060106104442.377"><vh>Fixed crasher in backwardDeleteCharacter</vh></v>
<v t="ekr.20060106104442.378"><vh>Fixed recent bug: dialogs now get focus properly when first opened.</vh></v>
<v t="ekr.20060106104442.379"><vh>Made sure shortcuts are printed clearly by k.registerCommand</vh>
<v t="ekr.20060106104442.380"><vh>prettyPrintKey</vh></v>
<v t="ekr.20060106104442.381"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20060106104442.382"><vh>Suppressed crash undoing a clone followed by a drag</vh>
<v t="ekr.20060106104442.383"><vh>trace</vh></v>
<v t="ekr.20060106104442.384"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20060106104442.385"><vh>Code level</vh>
<v t="ekr.20060106104442.386"><vh>Removed calls to update followed by xWantsFocus</vh></v>
<v t="ekr.20060106104442.387"><vh>Added g.app.gui.isTextWidget</vh>
<v t="ekr.20060106104442.264"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20060106104442.388"><vh>(Moving focus out of limbo)</vh>
<v t="ekr.20060106104442.389"><vh>Focus</vh>
<v t="ekr.20060106104442.390"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20060106104442.391" a="M"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20060106104442.392"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20060106104442.228" a="M"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060106104442.393"><vh>Find methods</vh>
<v t="ekr.20060106104442.394"><vh>restore</vh></v>
<v t="ekr.20060106104442.395"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060106104442.396"><vh>class leoTkinterLog</vh>
<v t="ekr.20060106104442.397"><vh>tkLog Birth</vh>
<v t="ekr.20060106104442.398"><vh>tkLog.__init__</vh></v>
<v t="ekr.20060106104442.399"><vh>tkLog.createControl</vh></v>
<v t="ekr.20060106104442.400"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20060106104442.401"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20060106104442.402"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20060106104442.403"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20060106104442.404"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20060106104442.405"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20060106104442.406"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20060106104442.407"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20060106104442.408"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20060106104442.409"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20060106104442.410"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20060106104442.411"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20060106104442.412"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20060106104442.413"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20060106104442.4"><vh>put</vh>
<v t="ekr.20060106104442.5"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20060106104442.6"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.414"><vh>putnl</vh></v>
</v>
<v t="ekr.20060106104442.415"><vh>Tab (TkLog)</vh>
<v t="ekr.20060106104442.416"><vh>clearTab</vh></v>
<v t="ekr.20060106104442.417" a="M"><vh>createTab</vh>
<v t="ekr.20060106104442.418"><vh>&lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;</vh></v>
<v t="ekr.20060106104442.419"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.420" a="M"><vh>deleteTab</vh></v>
<v t="ekr.20060106104442.421"><vh>getSelectedTab</vh></v>
<v t="ekr.20060106104442.422" a="M"><vh>lower/raiseTab</vh></v>
<v t="ekr.20060106104442.423"><vh>renameTab</vh></v>
<v t="ekr.20060106104442.424" a="M"><vh>selectTab</vh></v>
<v t="ekr.20060106104442.425"><vh>setTabBindings</vh></v>
<v t="ekr.20060106104442.426"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20060106104442.427"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20060106104442.428"><vh>newTabFromMenu</vh></v>
<v t="ekr.20060106104442.429"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20060106104442.430"><vh>getTabName</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20060106104442.431"><vh>New features</vh>
<v t="ekr.20060106104442.432"><vh>*** Allow multiple bindings to the same command</vh>
<v t="ekr.20060106104442.433"><vh>To do</vh></v>
<v t="ekr.20060106104442.434"><vh>From leoConfig.py</vh>
<v t="ekr.20060106104442.435"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20060106104442.436"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20060106104442.437"><vh>doShortcut</vh></v>
<v t="ekr.20060106104442.438"><vh>doShortcuts</vh></v>
<v t="ekr.20060106104442.439"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20060106104442.440"><vh>getShortcut (config)</vh></v>
</v>
<v t="ekr.20060106104442.441"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060106104442.442"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20060106104442.443"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.444"><vh>bindKey</vh>
<v t="ekr.20060106104442.445"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.446"><vh>bindOpenWith</vh></v>
<v t="ekr.20060106104442.447"><vh>bindShortcut</vh></v>
<v t="ekr.20060106104442.448"><vh>checkBindings</vh></v>
<v t="ekr.20060106104442.371"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20060106104442.449"><vh>makeAllBindings</vh></v>
<v t="ekr.20060106104442.450"><vh>addModeCommands</vh></v>
<v t="ekr.20060106104442.451"><vh>makeHardBindings</vh></v>
<v t="ekr.20060106104442.452"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060106104442.453"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060106104442.454"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060106104442.455"><vh>canonicalizeShortcut</vh>
<v t="ekr.20060106104442.456"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20060106104442.457"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20060106104442.458"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20060106104442.459"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.460"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.461"><vh>Calls to getShortcut</vh>
<v t="ekr.20060106104442.462" a="M"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060106104442.463" a="M"><vh>createBindings</vh></v>
<v t="ekr.20060106104442.452"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060106104442.453"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060106104442.454"><vh>makeBindingsFromCommandsDict</vh></v>
<v t="ekr.20060106104442.464"><vh>createMenuEntries</vh>
<v t="ekr.20060106104442.465"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20060106104442.466"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20060106104442.467"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.468"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106104442.469"><vh>Settings command is now the same as open-leoettings-leo</vh>
<v t="ekr.20060106104442.470"><vh>defineEditMenuTop2Table</vh></v>
<v t="ekr.20060106104442.471"><vh>preferences</vh></v>
</v>
</v>
<v t="ekr.20060106104442.472"><vh>Full input modes</vh>
<v t="ekr.20060106104442.473"><vh>To do</vh></v>
<v t="ekr.20060106104442.474"><vh>@url http://vimdoc.sourceforge.net/htmldoc/usr_03.html</vh></v>
<v t="ekr.20060106104442.23" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20060106104442.24"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060106104442.25"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060106104442.26"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060106104442.27"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060106104442.475"><vh>From leoConfig.py</vh>
<v t="ekr.20060106104442.476"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060106104442.477"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060106104442.478" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060106104442.479"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.480"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.481"><vh>createModeCommand</vh></v>
<v t="ekr.20060106104442.482"><vh>doMode</vh></v>
<v t="ekr.20060106104442.438"><vh>doShortcuts</vh></v>
</v>
<v t="ekr.20060106104442.483"><vh>From leoKeys.py</vh>
<v t="ekr.20060106104442.476"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060106104442.477"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060106104442.478" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060106104442.479"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.480"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106104442.484"><vh>finishCreate (keyHandler) &amp; helpers</vh>
<v t="ekr.20060106104442.485"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060106104442.486"><vh>keyboardQuit</vh></v>
<v t="ekr.20060106104442.449"><vh>makeAllBindings</vh></v>
<v t="ekr.20060106104442.450"><vh>addModeCommands</vh></v>
<v t="ekr.20060106104442.487"><vh>Dispatching...</vh>
<v t="ekr.20060106104442.488"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20060106104442.489"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060106104442.490"><vh>callStateFunction</vh></v>
<v t="ekr.20060106104442.491"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060106104442.492"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060106104442.493"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060106104442.494"><vh>quickCommand  (ctrl-c) &amp; helpers</vh>
<v t="ekr.20060106104442.495"><vh>rCommand</vh></v>
<v t="ekr.20060106104442.496"><vh>processKey</vh>
<v t="ekr.20060106104442.497"><vh>processAbbreviation</vh></v>
</v>
</v>
<v t="ekr.20060106104442.498"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060106104442.499"><vh>matchKeys</vh></v>
<v t="ekr.20060106104442.500"><vh>enterNamedMode &amp;helpers</vh>
<v t="ekr.20060106104442.501"><vh>generalModeHandler</vh></v>
<v t="ekr.20060106104442.502"><vh>modeHelp/Helper</vh>
<v t="ekr.20060106104442.503"><vh>modeHelpHelper</vh></v>
</v>
</v>
<v t="ekr.20060106104442.22"><vh>handleDefaultChar</vh></v>
<v t="ekr.20060106104442.504"><vh>set(ignore, insert, overwrite)Mode</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136"><vh>4.4b1 projects</vh>
<v t="ekr.20060120105136.1"><vh>Bugs fixed</vh>
<v t="ekr.20060120105136.2"><vh>Fixed minor headline problems</vh>
<v t="ekr.20060120105136.3"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20060120105136.4"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.5"><vh>deleteNextChar</vh></v>
<v t="ekr.20060120105136.6"><vh>begin/endCommand</vh>
<v t="ekr.20060120105136.7"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20060120105136.8"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20060120105136.9"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060120105136.10"><vh>head key handlers</vh>
<v t="ekr.20060120105136.11"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060120105136.12"><vh>updateHead</vh></v>
<v t="ekr.20060120105136.13"><vh>onHeadChanged</vh>
<v t="ekr.20060120105136.14"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.15"><vh>Removed all calls to g.top() from Leo's core</vh>
<v t="ekr.20060120105136.16"><vh>Changed</vh>
<v t="ekr.20060120105136.17"><vh>createFrame (tkComparePanel)</vh>
<v t="ekr.20060120105136.18"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="ekr.20060120105136.19"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="ekr.20060120105136.20"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="ekr.20060120105136.21"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="ekr.20060120105136.22"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="ekr.20060120105136.23"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.24"><vh>From leoGlobals.py</vh>
<v t="ekr.20060120105136.25"><vh>callers</vh></v>
<v t="ekr.20060120105136.26"><vh>createTopologyList</vh></v>
<v t="ekr.20060120105136.27"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20060120105136.28"><vh>g.scanDirectives</vh>
<v t="ekr.20060120105136.29"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20060120105136.30"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20060120105136.31"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20060120105136.32"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20060120105136.33"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20060120105136.34"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20060120105136.35"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.36"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20060120105136.37"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.38"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20060120105136.39"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
</v>
<v t="ekr.20060120105136.40"><vh>From leoTest.py</vh>
<v t="ekr.20060120105136.41"><vh>doTests...</vh>
<v t="ekr.20060120105136.42"><vh>class generalTestCase</vh>
<v t="ekr.20060120105136.43"><vh>__init__</vh></v>
<v t="ekr.20060120105136.44"><vh> fail</vh></v>
<v t="ekr.20060120105136.45"><vh>setUp</vh></v>
<v t="ekr.20060120105136.46"><vh>tearDown</vh></v>
<v t="ekr.20060120105136.47"><vh>runTest</vh></v>
<v t="ekr.20060120105136.48"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20060120105136.49"><vh>makeTestSuite</vh></v>
<v t="ekr.20060120105136.50"><vh>makeTestCase</vh></v>
</v>
<v t="ekr.20060120105136.51"><vh>runTimerOnNode</vh></v>
<v t="ekr.20060120105136.52"><vh>numberOfClonesInOutline</vh></v>
<v t="ekr.20060120105136.53"><vh>numberOfNodesInOutline</vh></v>
<v t="ekr.20060120105136.54"><vh>leoTest.runLeoTest</vh></v>
<v t="ekr.20060120105136.55"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20060120105136.56"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20060120105136.57"><vh>runPerfectImportTest</vh></v>
</v>
<v t="ekr.20060120105136.58"><vh>From leoNodes.py</vh>
<v t="ekr.20060120105136.59"><vh>p.__init__</vh></v>
<v t="ekr.20060120105136.60"><vh>p.copy</vh></v>
</v>
<v t="ekr.20060120105136.61"><vh>scanError</vh></v>
</v>
</v>
<v t="ekr.20060120105136.62"><vh>Fixed undo problems</vh>
<v t="ekr.20060120105136.63"><vh>Report</vh></v>
<v t="ekr.20060120105136.64"><vh>top level</vh>
<v t="ekr.20060120105136.65"><vh>new</vh></v>
<v t="ekr.20060120105136.66"><vh>open</vh>
<v t="ekr.20060120105136.67"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.68"><vh>openWith and allies</vh>
<v t="ekr.20060120105136.69"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20060120105136.70"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20060120105136.71"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20060120105136.72"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20060120105136.73"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060120105136.74"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20060120105136.75"><vh>createOpenWithTempFile</vh>
<v t="ekr.20060120105136.76"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.77"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20060120105136.78"><vh>close</vh></v>
<v t="ekr.20060120105136.79"><vh>save</vh></v>
<v t="ekr.20060120105136.80"><vh>saveAs</vh></v>
<v t="ekr.20060120105136.81"><vh>saveTo</vh></v>
<v t="ekr.20060120105136.82"><vh>revert</vh></v>
</v>
<v t="ekr.20060120105136.83"><vh>g.openWithFileName</vh></v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060120105136.85"><vh>Improved word-export plugin</vh></v>
<v t="ekr.20060120105136.86"><vh>Removed a bad use of g.app.log in the find panel</vh></v>
<v t="ekr.20060120105136.87"><vh>Fix crash: tab in minibuffer</vh>
<v t="ekr.20060120105136.88"><vh>traceback</vh></v>
</v>
<v t="ekr.20060120105136.89"><vh>Installed patch for headline width</vh>
<v t="ekr.20060120105136.90"><vh>Report</vh></v>
<v t="ekr.20060120105136.91"><vh>__init__</vh>
<v t="ekr.20060120105136.92"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20060120105136.93"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20060120105136.94"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.95"><vh>headWidth &amp; widthInPixels</vh></v>
</v>
<v t="ekr.20060120105136.96"><vh>Redraw screen properly after Move To Next Dirty</vh>
<v t="ekr.20060120105136.97"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20060120105136.98"><vh>goToNextMarkedHeadline</vh></v>
</v>
<v t="ekr.20060120105136.99"><vh>Fixed focus bug</vh>
<v t="ekr.20060120105136.100"><vh>Report</vh></v>
<v t="ekr.20060120105136.101"><vh>c.begin/endUpdate</vh></v>
</v>
<v t="ekr.20060120105136.102"><vh>Made sure to bring proper window on top in settings.leo button</vh>
<v t="ekr.20060120105136.83"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20060120105136.103"><vh>Fixed problem with arrow keys</vh>
<v t="ekr.20060120105136.104"><vh>Report</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
</v>
<v t="ekr.20060120105136.106"><vh>Investigated cut/paste problem</vh>
<v t="ekr.20060120105136.107"><vh>Report</vh></v>
<v t="ekr.20060120105136.108"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060120105136.109"><vh>copyText</vh></v>
<v t="ekr.20060120105136.110"><vh>cutText</vh></v>
<v t="ekr.20060120105136.111"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060120105136.112"><vh>Fixed several bugs</vh></v>
<v t="ekr.20060120105136.113"><vh>Fixed recent bug: text in new headline was not selected</vh>
<v t="ekr.20060120105136.114"><vh>c.insertHeadline</vh></v>
<v t="ekr.20060120105136.101"><vh>c.begin/endUpdate</vh></v>
</v>
<v t="ekr.20060120105136.115"><vh>Fixed problem with Mac enter key</vh>
<v t="ekr.20060120105136.116"><vh>Report</vh></v>
</v>
<v t="ekr.20060120105136.117"><vh>Fixed problems with plugins</vh>
<v t="ekr.20060120105136.118"><vh>Report</vh></v>
<v t="ekr.20060120105136.119"><vh>Report 2</vh></v>
</v>
<v t="ekr.20060120105136.120"><vh>Installed patch to cleo plugin</vh></v>
<v t="ekr.20060120105136.121"><vh>Fixed old file handling bug</vh>
<v t="ekr.20060120105136.122"><vh>Report</vh></v>
<v t="ekr.20060120105136.123"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20060120105136.124"><vh>Use shutil.move in g.utils_rename</vh>
<v t="ekr.20060120105136.125"><vh>Report</vh></v>
<v t="ekr.20060120105136.126"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20060120105136.127"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20060120105136.128"><vh>test_g_utils_rename</vh></v>
</v>
</v>
<v t="ekr.20060120105136.129"><vh>Simplified k.copyBindingsToWidget and eliminated k.onTextWidgetKey</vh>
<v t="ekr.20060120105136.130"><vh>Notes</vh></v>
<v t="ekr.20060120105136.131"><vh>Dispatching...</vh>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.137"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060120105136.138"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060120105136.139"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060120105136.140"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060120105136.141"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20060120105136.142"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.143"><vh>bindKey</vh>
<v t="ekr.20060120105136.144"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060120105136.145"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20060120105136.146"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120105136.147"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20060120105136.148"><vh>bindOpenWith</vh></v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
<v t="ekr.20060120105136.150"><vh>checkBindings</vh></v>
<v t="ekr.20060120105136.151"><vh>computeKeysym_numDicts</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.154"><vh>isPlainKey</vh></v>
<v t="ekr.20060120105136.155"><vh>makeAllBindings</vh></v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.157"><vh>makeHardBindings</vh></v>
<v t="ekr.20060120105136.158"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060120105136.159"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060120105136.160"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060120105136.161"><vh>setTabBindings</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
</v>
<v t="ekr.20060120105136.162"><vh>Made sure that focus stays in body during tab completion</vh>
<v t="ekr.20060120105136.163"><vh>Notes</vh></v>
<v t="ekr.20060120105136.164"><vh>clearTab</vh></v>
</v>
<v t="ekr.20060120105136.165"><vh>Leo now puts focus in body pane after deleting a window</vh></v>
<v t="ekr.20060120105136.166"><vh>Fixed many binding problems</vh>
<v t="ekr.20060120105136.167"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.143"><vh>bindKey</vh>
<v t="ekr.20060120105136.144"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060120105136.145"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20060120105136.146"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120105136.147"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20060120105136.168"><vh>All uses of prettyPrintKey</vh>
<v t="ekr.20060120105136.169"><vh>printBindings</vh></v>
<v t="ekr.20060120105136.170"><vh>printCommands</vh></v>
<v t="ekr.20060120105136.171"><vh>k.registerCommand</vh></v>
<v t="ekr.20060120105136.172"><vh>prettyPrintKey</vh></v>
</v>
<v t="ekr.20060120105136.173"><vh>All uses of inverseCommandsDict</vh>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.174"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20060120105136.175"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.176"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
<v t="ekr.20060120105136.177" a="M"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20060120105136.178"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20060120105136.179"><vh>createInverseCommandsDict</vh></v>
<v t="ekr.20060120105136.171"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20060120105136.180"><vh>All uses of inverseBindingDict</vh>
<v t="ekr.20060120105136.169"><vh>printBindings</vh></v>
<v t="ekr.20060120105136.170"><vh>printCommands</vh></v>
<v t="ekr.20060120105136.181"><vh>computeCompletionList</vh></v>
<v t="ekr.20060120105136.182"><vh>computeInverseBindingDict</vh></v>
</v>
<v t="ekr.20060120105136.183"><vh>All uses of bindingsDict</vh>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.184"><vh>_executeMacro (revise)</vh></v>
<v t="ekr.20060120105136.169"><vh>printBindings</vh></v>
<v t="ekr.20060120105136.185"><vh>executeNTimes</vh></v>
<v t="ekr.20060120105136.182"><vh>computeInverseBindingDict</vh></v>
<v t="ekr.20060120105136.186"><vh>getShortcutForCommand/Name (should return lists)</vh></v>
</v>
</v>
<v t="ekr.20060120105136.187"><vh>Fixed extend-selection problems</vh>
<v t="ekr.20060120105136.188"><vh>extendHelper</vh></v>
</v>
<v t="ekr.20060120105136.189"><vh>Fixed per-pane bindings!</vh>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.167"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20060120105136.158"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060120105136.159"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060120105136.190"><vh>traceBinding</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.191"><vh>All calls to copyBindingsToWidget</vh>
<v t="ekr.20060120105136.161"><vh>setTabBindings</vh></v>
<v t="ekr.20060120105136.167"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20060120105136.192"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060120105136.193"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20060120105136.194"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20060120105136.195"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.196"><vh>Always redraw the screen after editing a label</vh></v>
</v>
<v t="ekr.20060120105136.197"><vh>Code level</vh>
<v t="ekr.20060120105136.198"><vh>Added support for plugin menu commands</vh>
<v t="ekr.20060120105136.199"><vh>defineMenuCallback</vh></v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060120105136.200"><vh>Removed g.top from all plugins</vh></v>
<v t="ekr.20060120105136.201"><vh>Created c.exists ivar and related logic</vh>
<v t="ekr.20060120105136.202"><vh> c.Birth &amp; death</vh>
<v t="ekr.20060120105136.203"><vh>c.__init__</vh></v>
<v t="ekr.20060120105136.204"><vh>c.initIvars</vh>
<v t="ekr.20060120105136.205"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.206"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20060120105136.207"><vh>c.hash</vh></v>
<v t="ekr.20060120105136.208"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20060120105136.209"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20060120105136.210"><vh>destroySelf (tkFrame)</vh></v>
<v t="ekr.20060120105136.211"><vh>app.destroyWindow</vh></v>
<v t="ekr.20060120105136.212"><vh>callTagHandler</vh></v>
</v>
<v t="ekr.20060120105136.213"><vh>Cleaned up code</vh>
<v t="ekr.20060120105136.214"><vh>Won't do</vh></v>
</v>
<v t="ekr.20060120105136.215"><vh>Call c.setLog in all entries into code</vh>
<v t="ekr.20060120105136.216"><vh>app.setLog, lockLog, unlocklog</vh></v>
<v t="ekr.20060120105136.217"><vh>c.setLog</vh></v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.218"><vh>Event handlers (tkTree)</vh>
<v t="ekr.20060120105136.219"><vh>Helpers</vh>
<v t="ekr.20060120105136.220"><vh>checkWidgetList</vh></v>
<v t="ekr.20060120105136.221"><vh>dumpWidgetList</vh></v>
<v t="ekr.20060120105136.222"><vh>edit_widget</vh></v>
<v t="ekr.20060120105136.223"><vh>eventToPosition</vh></v>
<v t="ekr.20060120105136.224"><vh>findEditWidget</vh></v>
<v t="ekr.20060120105136.225"><vh>findVnodeWithIconId</vh></v>
</v>
<v t="ekr.20060120105136.226"><vh>Click Box...</vh>
<v t="ekr.20060120105136.227"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060120105136.228"><vh>Dragging</vh>
<v t="ekr.20060120105136.229"><vh>endDrag</vh>
<v t="ekr.20060120105136.230"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20060120105136.231"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.232"><vh>startDrag</vh></v>
<v t="ekr.20060120105136.233"><vh>onContinueDrag</vh>
<v t="ekr.20060120105136.234"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.235"><vh>onDrag</vh></v>
<v t="ekr.20060120105136.236"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20060120105136.10"><vh>head key handlers</vh>
<v t="ekr.20060120105136.11"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060120105136.12"><vh>updateHead</vh></v>
<v t="ekr.20060120105136.13"><vh>onHeadChanged</vh>
<v t="ekr.20060120105136.14"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060120105136.237"><vh>Icon Box...</vh>
<v t="ekr.20060120105136.238"><vh>onIconBoxClick</vh></v>
<v t="ekr.20060120105136.239"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20060120105136.240"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20060120105136.241"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20060120105136.242"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.243"><vh>onTreeClick</vh></v>
<v t="ekr.20060120105136.244"><vh>Text Box...</vh>
<v t="ekr.20060120105136.245"><vh>configureTextState</vh></v>
<v t="ekr.20060120105136.246"><vh>onCtontrolT</vh></v>
<v t="ekr.20060120105136.247"><vh>onHeadlineClick</vh></v>
<v t="ekr.20060120105136.248"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20060120105136.249"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20060120105136.250"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20060120105136.251"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20060120105136.252"><vh>createPopupMenu</vh>
<v t="ekr.20060120105136.253"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.254"><vh>enablePopupMenuItems</vh>
<v t="ekr.20060120105136.255"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.256"><vh>showPopupMenu</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.257"><vh>Generalized doCommand</vh>
<v t="ekr.20060120105136.132"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060120105136.133"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060120105136.134"><vh>callStateFunction</vh></v>
<v t="ekr.20060120105136.135"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060120105136.136"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060120105136.84"><vh> doCommand</vh></v>
<v t="ekr.20060120105136.174"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20060120105136.175"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
</v>
</v>
<v t="ekr.20060120105136.258"><vh>Documentation</vh>
<v t="ekr.20060120105136.259"><vh>Updated docs with warnings about deleting children of clones</vh></v>
</v>
<v t="ekr.20060120105136.260"><vh>New features</vh>
<v t="ekr.20060120105136.261"><vh>Installed new standard bindings</vh>
<v t="ekr.20060120105136.262"><vh>From Manfred</vh></v>
<v t="ekr.20060120105136.263"><vh>From Speed</vh></v>
</v>
<v t="ekr.20060120105136.264"><vh>Added script check bindings in leoSettings.leo</vh></v>
<v t="ekr.20060120105136.265"><vh>Scripts now maintain original focus</vh>
<v t="ekr.20060120105136.266"><vh>Report</vh></v>
<v t="ekr.20060120105136.267"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20060120105136.268"><vh>writeFromString (new in 4.3 beta2)</vh></v>
</v>
<v t="ekr.20060120105136.269"><vh>Added scroll-up/down-extend-selection commands</vh>
<v t="ekr.20060120105136.270"><vh>Notes</vh></v>
<v t="ekr.20060120105136.271"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
<v t="ekr.20060120105136.272"><vh>scrollUp/Down/extendSelection</vh>
<v t="ekr.20060120105136.273"><vh>scrollHelper</vh></v>
</v>
</v>
<v t="ekr.20060120105136.274"><vh>Improved cursor move/extend commands</vh>
<v t="ekr.20060120105136.275"><vh>What I did</vh></v>
<v t="ekr.20060120105136.276"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20060120105136.277"><vh>tree.moveUpDown (Reference)</vh></v>
<v t="ekr.20060120105136.278"><vh>move... (leoEditCommands)</vh>
<v t="ekr.20060120105136.279"><vh> helpers</vh>
<v t="ekr.20060120105136.188"><vh>extendHelper</vh></v>
<v t="ekr.20060120105136.280"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
<v t="ekr.20060120105136.281"><vh>moveWordHelper</vh></v>
<v t="ekr.20060120105136.282"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20060120105136.283"><vh>backSentenceHelper</vh></v>
<v t="ekr.20060120105136.284"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20060120105136.285"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20060120105136.286"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20060120105136.287"><vh>exchangePointMark</vh></v>
<v t="ekr.20060120105136.288"><vh>extendMode</vh></v>
<v t="ekr.20060120105136.289"><vh>buffers</vh></v>
<v t="ekr.20060120105136.290"><vh>characters</vh></v>
<v t="ekr.20060120105136.291"><vh>lines</vh></v>
<v t="ekr.20060120105136.292"><vh>movePastClose (test)</vh></v>
<v t="ekr.20060120105136.293"><vh>paragraphs</vh></v>
<v t="ekr.20060120105136.294"><vh>sentences</vh></v>
<v t="ekr.20060120105136.295"><vh>words</vh></v>
</v>
<v t="ekr.20060120105136.291"><vh>lines</vh></v>
<v t="ekr.20060120105136.105"><vh>moveToHelper</vh></v>
<v t="ekr.20060120105136.280"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060120105136.273"><vh>scrollHelper</vh></v>
<v t="ekr.20060120105136.188"><vh>extendHelper</vh></v>
</v>
<v t="ekr.20060120105136.296"><vh>Made edit command keys work in headlines</vh></v>
<v t="ekr.20060120105136.297"><vh>Use pretty keys in tab completion tab</vh></v>
<v t="ekr.20060120105136.298"><vh>Finish support for @mode nodes</vh>
<v t="ekr.20060120105136.299"><vh>Notes</vh></v>
<v t="ekr.20060120105136.177" a="M"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20060120105136.300"><vh>From leoConfig</vh>
<v t="ekr.20060120105136.301"><vh>createModeCommand</vh></v>
<v t="ekr.20060120105136.302"><vh>doMode</vh></v>
</v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.140"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060120105136.141"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20060120105136.142"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.143"><vh>bindKey</vh>
<v t="ekr.20060120105136.144"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060120105136.145"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20060120105136.146"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120105136.147"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20060120105136.148"><vh>bindOpenWith</vh></v>
<v t="ekr.20060120105136.149"><vh>bindShortcut</vh></v>
<v t="ekr.20060120105136.150"><vh>checkBindings</vh></v>
<v t="ekr.20060120105136.151"><vh>computeKeysym_numDicts</vh></v>
<v t="ekr.20060120105136.152"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060120105136.153"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120105136.154"><vh>isPlainKey</vh></v>
<v t="ekr.20060120105136.155"><vh>makeAllBindings</vh></v>
<v t="ekr.20060120105136.156"><vh>addModeCommands</vh></v>
<v t="ekr.20060120105136.157"><vh>makeHardBindings</vh></v>
<v t="ekr.20060120105136.158"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20060120105136.159"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060120105136.160"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060120105136.303"><vh>Modes</vh>
<v t="ekr.20060120105136.304"><vh>enterNamedMode</vh></v>
<v t="ekr.20060120105136.305"><vh>modeHelp &amp; helper</vh>
<v t="ekr.20060120105136.306"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060120105136.307"><vh>generalModeHandler &amp; helpers</vh>
<v t="ekr.20060120105136.308"><vh>badMode</vh></v>
<v t="ekr.20060120105136.309"><vh>createModeBindings</vh>
<v t="ekr.20060120105136.310"><vh>&lt;&lt; define modeCallback &gt;&gt;</vh></v>
<v t="ekr.20060120105136.311"><vh>&lt;&lt; define modeHelpCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060120105136.312"><vh>initMode</vh></v>
<v t="ekr.20060120105136.313"><vh>endMode</vh></v>
</v>
</v>
</v>
<v t="ekr.20060120105136.314"><vh>keyboard-quit restores default input mode</vh>
<v t="ekr.20060120105136.315"><vh>keyboardQuit</vh></v>
<v t="ekr.20060120105136.316"><vh>set-xxx-Mode</vh></v>
<v t="ekr.20060120105136.317"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431"><vh>4.4b2 projects</vh>
<v t="ekr.20060214141244"><vh>Part 1</vh>
<v t="ekr.20060206111431.1"><vh>Bugs</vh>
<v t="ekr.20060206111431.2"><vh>Fixed crasher in Save button</vh></v>
<v t="ekr.20060206111431.3"><vh>Fixed minor bugs &amp; made minor improvements</vh>
<v t="ekr.20060206111431.4"><vh>Fixed two annoying headline glitches</vh>
<v t="ekr.20060206111431.5"><vh>tree.set...LabelState</vh>
<v t="ekr.20060206111431.6"><vh>setEditLabelState</vh></v>
<v t="ekr.20060206111431.7"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20060206111431.8"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20060206111431.9"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20060206111431.10"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20060206111431.11"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20060206111431.12"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060206111431.13"><vh>Insert headline didn't redraw headline properly in vim mode</vh>
<v t="ekr.20060206111431.14"><vh>printBindings</vh></v>
<v t="ekr.20060206111431.15"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060206111431.16"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060206111431.17"><vh>callStateFunction</vh></v>
<v t="ekr.20060206111431.18"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060206111431.19"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060206111431.20"><vh>head key handlers</vh>
<v t="ekr.20060206111431.21"><vh>onHeadlineKey</vh></v>
<v t="ekr.20060206111431.22"><vh>updateHead</vh></v>
<v t="ekr.20060206111431.23"><vh>onHeadChanged</vh>
<v t="ekr.20060206111431.24"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060206111431.25"><vh>Modes</vh>
<v t="ekr.20060206111431.26"><vh>badMode</vh></v>
<v t="ekr.20060206111431.27"><vh>createModeBindings</vh></v>
<v t="ekr.20060206111431.28"><vh>endMode</vh></v>
<v t="ekr.20060206111431.29"><vh>enterNamedMode</vh></v>
<v t="ekr.20060206111431.30"><vh>exitNamedMode</vh></v>
<v t="ekr.20060206111431.31"><vh>generalModeHandler</vh></v>
<v t="ekr.20060206111431.32"><vh>initMode</vh></v>
<v t="ekr.20060206111431.33"><vh>reinitMode</vh></v>
<v t="ekr.20060206111431.34"><vh>modeHelp</vh>
<v t="ekr.20060206111431.35"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060206111431.36"><vh>set-xxx-State</vh></v>
<v t="ekr.20060206111431.37"><vh>setInputState</vh></v>
<v t="ekr.20060206111431.38"><vh>showStateAndMode</vh></v>
</v>
</v>
<v t="ekr.20060206111431.39"><vh>Improved printBindings, printCommands &amp; modeHelp</vh>
<v t="ekr.20060206111431.40"><vh>Externally visible commands</vh>
<v t="ekr.20060206111431.41"><vh>digitArgument &amp; universalArgument</vh></v>
<v t="ekr.20060206111431.42"><vh>k.show/hide/toggleMinibuffer</vh></v>
<v t="ekr.20060206111431.43"><vh>negativeArgument (redo?)</vh></v>
<v t="ekr.20060206111431.44"><vh>numberCommand</vh></v>
<v t="ekr.20060206111431.14"><vh>printBindings</vh></v>
<v t="ekr.20060206111431.45"><vh>printCommands</vh></v>
<v t="ekr.20060206111431.46"><vh>repeatComplexCommand &amp; helper</vh></v>
</v>
<v t="ekr.20060206111431.14"><vh>printBindings</vh></v>
<v t="ekr.20060206111431.45"><vh>printCommands</vh></v>
<v t="ekr.20060206111431.35"><vh>modeHelpHelper</vh></v>
<v t="ekr.20060206111431.34"><vh>modeHelp</vh>
<v t="ekr.20060206111431.35"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.47"><vh>Fixed crasher re BackSpace in log window</vh></v>
<v t="ekr.20060206111431.48"><vh>Fixed crashers in cut/copy/paste commands</vh>
<v t="ekr.20060206111431.49"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060206111431.50"><vh>copyText</vh></v>
<v t="ekr.20060206111431.51"><vh>cutText</vh></v>
<v t="ekr.20060206111431.52"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060206111431.53"><vh>Fixed crasher when clicking the close box during a long command</vh>
<v t="ekr.20060206111431.54"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="ekr.20060206111431.55"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20060206111431.56"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060206111431.57"><vh>cloneFindAll now honor present find settings</vh></v>
<v t="ekr.20060206111431.58"><vh>(Added prettyPrintKey in various places)</vh>
<v t="ekr.20060206111431.59"><vh>k.prettyPrintKey</vh></v>
<v t="ekr.20060206111431.14"><vh>printBindings</vh></v>
<v t="ekr.20060206111431.45"><vh>printCommands</vh></v>
<v t="ekr.20060206111431.34"><vh>modeHelp</vh>
<v t="ekr.20060206111431.35"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060206111431.60"><vh>computeCompletionList</vh></v>
<v t="ekr.20060206111431.61"><vh>computeInverseBindingDict</vh></v>
</v>
<v t="ekr.20060206111431.62"><vh>Double-click didn't work in the body pane.</vh>
<v t="ekr.20060206111431.63"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20060206111431.64"><vh>masterKeyHandler</vh>
<v t="ekr.20060206111431.65"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060206111431.66"><vh>masterClickHandler</vh></v>
<v t="ekr.20060206111431.67"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20060206111431.68"><vh>masterMenuHandler</vh></v>
</v>
<v t="ekr.20060206111431.69"><vh>tree.OnDeactivate</vh></v>
<v t="ekr.20060206111431.70"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20060206111431.71"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20060206111431.72"><vh>OnBodyDoubleClick (Events)</vh></v>
</v>
<v t="ekr.20060206111431.73"><vh>Improved body.makeInsertPointVisible</vh></v>
<v t="ekr.20060206111431.74"><vh>Fixed cut/copy/paste from menu</vh></v>
</v>
<v t="ekr.20060206111431.75"><vh>Made modes work</vh>
<v t="ekr.20060206111431.76"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060206111431.77"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060206111431.78"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20060206111431.79"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.80"><vh>Dispatching (keyHandler)</vh>
<v t="ekr.20060206111431.15"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060206111431.16"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060206111431.17"><vh>callStateFunction</vh></v>
<v t="ekr.20060206111431.18"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060206111431.19"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060206111431.81"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060206111431.82"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060206111431.83"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060206111431.84"><vh>addModeCommands</vh></v>
<v t="ekr.20060206111431.85"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20060206111431.86"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060206111431.87"><vh>bindKey</vh>
<v t="ekr.20060206111431.88"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060206111431.89"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.90"><vh>bindKeyToDict</vh></v>
<v t="ekr.20060206111431.91"><vh>bindOpenWith</vh></v>
<v t="ekr.20060206111431.92"><vh>checkBindings</vh></v>
<v t="ekr.20060206111431.93"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20060206111431.84"><vh>addModeCommands</vh></v>
<v t="ekr.20060206111431.94"><vh>initSpecialIvars</vh></v>
<v t="ekr.20060206111431.95"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060206111431.25"><vh>Modes</vh>
<v t="ekr.20060206111431.26"><vh>badMode</vh></v>
<v t="ekr.20060206111431.27"><vh>createModeBindings</vh></v>
<v t="ekr.20060206111431.28"><vh>endMode</vh></v>
<v t="ekr.20060206111431.29"><vh>enterNamedMode</vh></v>
<v t="ekr.20060206111431.30"><vh>exitNamedMode</vh></v>
<v t="ekr.20060206111431.31"><vh>generalModeHandler</vh></v>
<v t="ekr.20060206111431.32"><vh>initMode</vh></v>
<v t="ekr.20060206111431.33"><vh>reinitMode</vh></v>
<v t="ekr.20060206111431.34"><vh>modeHelp</vh>
<v t="ekr.20060206111431.35"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060206111431.36"><vh>set-xxx-State</vh></v>
<v t="ekr.20060206111431.37"><vh>setInputState</vh></v>
<v t="ekr.20060206111431.38"><vh>showStateAndMode</vh></v>
</v>
</v>
<v t="ekr.20060206111431.96"><vh>Disabled plain-key bindings in insert/overwrite modes</vh>
<v t="ekr.20060206111431.36"><vh>set-xxx-State</vh></v>
<v t="ekr.20060206111431.97"><vh>selfInsertCommand</vh>
<v t="ekr.20060206111431.98"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060206111431.99"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060206111431.100"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060206111431.101"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060206111431.86"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060206111431.87"><vh>bindKey</vh>
<v t="ekr.20060206111431.88"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060206111431.89"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.90"><vh>bindKeyToDict</vh></v>
<v t="ekr.20060206111431.91"><vh>bindOpenWith</vh></v>
<v t="ekr.20060206111431.92"><vh>checkBindings</vh></v>
<v t="ekr.20060206111431.93"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20060206111431.84"><vh>addModeCommands</vh></v>
<v t="ekr.20060206111431.94"><vh>initSpecialIvars</vh></v>
<v t="ekr.20060206111431.95"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20060206111431.102"><vh>Disabled auto-scrolling in outline pane on clicks</vh>
<v t="ekr.20060206111431.103"><vh>Drawing... (tkTree)</vh>
<v t="ekr.20060206111431.104"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20060206111431.105"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060206111431.106"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060206111431.107"><vh>idle_second_redraw</vh></v>
<v t="ekr.20060206111431.108"><vh>drawX...</vh>
<v t="ekr.20060206111431.109"><vh>drawBox</vh></v>
<v t="ekr.20060206111431.110"><vh>drawClickBox</vh>
<v t="ekr.20060206111431.111"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.112"><vh>drawIcon</vh>
<v t="ekr.20060206111431.113"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.114"><vh>drawLine</vh></v>
<v t="ekr.20060206111431.115"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20060206111431.116"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20060206111431.117"><vh>drawText</vh>
<v t="ekr.20060206111431.118"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.119"><vh>drawUserIcons</vh></v>
<v t="ekr.20060206111431.120"><vh>drawUserIcon</vh>
<v t="ekr.20060206111431.121"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20060206111431.122"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20060206111431.123"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20060206111431.124"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.125"><vh>drawTopTree</vh></v>
<v t="ekr.20060206111431.126"><vh>drawTree</vh></v>
</v>
<v t="ekr.20060206111431.127"><vh>Helpers...</vh>
<v t="ekr.20060206111431.128"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20060206111431.129"><vh>getIconImage</vh></v>
<v t="ekr.20060206111431.130"><vh>scrollTo</vh>
<v t="ekr.20060206111431.131"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20060206111431.132"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.133"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20060206111431.134"><vh>yoffset</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.135"><vh>move-outline and find commands force a screen scroll</vh>
<v t="ekr.20060206111431.136"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060206111431.137"><vh>(Limited undo)</vh>
<v t="ekr.20060206111431.138"><vh>class undoer</vh>
<v t="ekr.20060206111431.139"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="ekr.20060206111431.140"><vh>clearIvars</vh></v>
</v>
<v t="ekr.20060206111431.141"><vh>Internal helpers</vh>
<v t="ekr.20060206111431.142"><vh>cutStack</vh></v>
<v t="ekr.20060206111431.143"><vh>getBead</vh></v>
<v t="ekr.20060206111431.144"><vh>peekBead</vh></v>
<v t="ekr.20060206111431.145"><vh>pushBead</vh></v>
<v t="ekr.20060206111431.146"><vh>setIvarsFromBunch</vh></v>
<v t="ekr.20060206111431.147"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20060206111431.148"><vh>redoMenuName, undoMenuName</vh></v>
<v t="ekr.20060206111431.149"><vh>setRedoType, setUndoType</vh></v>
<v t="ekr.20060206111431.150"><vh>setUndoTypes</vh></v>
<v t="ekr.20060206111431.151"><vh>u.restoreTree &amp; helpers</vh>
<v t="ekr.20060206111431.152"><vh>restoreVnodeUndoInfo</vh></v>
<v t="ekr.20060206111431.153"><vh>restoreTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20060206111431.154"><vh>u.saveTree &amp; helpers</vh>
<v t="ekr.20060206111431.155"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
<v t="ekr.20060206111431.156"><vh>createVnodeUndoInfo</vh></v>
<v t="ekr.20060206111431.157"><vh>createTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20060206111431.158"><vh>u.trace</vh></v>
<v t="ekr.20060206111431.159"><vh>updateMarks</vh></v>
</v>
<v t="ekr.20060206111431.160"><vh>Externally visible entries</vh>
<v t="ekr.20060206111431.161"><vh>afterX...</vh>
<v t="ekr.20060206111431.162"><vh>afterChangeGroup</vh></v>
<v t="ekr.20060206111431.163"><vh>afterChangeNodeContents</vh></v>
<v t="ekr.20060206111431.164"><vh>afterChangeTree</vh></v>
<v t="ekr.20060206111431.165"><vh>afterClearRecentFiles</vh></v>
<v t="ekr.20060206111431.166"><vh>afterCloneNode</vh></v>
<v t="ekr.20060206111431.167"><vh>afterDehoist</vh></v>
<v t="ekr.20060206111431.168"><vh>afterDeleteNode</vh></v>
<v t="ekr.20060206111431.169"><vh>afterHoist</vh></v>
<v t="ekr.20060206111431.170"><vh>afterInsertNode</vh></v>
<v t="ekr.20060206111431.171"><vh>afterMark</vh></v>
<v t="ekr.20060206111431.172"><vh>afterMoveNode</vh></v>
</v>
<v t="ekr.20060206111431.173"><vh>beforeX...</vh>
<v t="ekr.20060206111431.174"><vh>beforeChangeGroup</vh></v>
<v t="ekr.20060206111431.175"><vh>beforeChangeNodeContents</vh></v>
<v t="ekr.20060206111431.176"><vh>beforeChangeTree</vh></v>
<v t="ekr.20060206111431.177"><vh>beforeClearRecentFiles</vh></v>
<v t="ekr.20060206111431.178"><vh>beforeCloneNode</vh></v>
<v t="ekr.20060206111431.179"><vh>beforeDeleteNode</vh></v>
<v t="ekr.20060206111431.180"><vh>beforeInsertNode</vh></v>
<v t="ekr.20060206111431.181"><vh>beforeMark</vh></v>
<v t="ekr.20060206111431.182"><vh>beforeMoveNode</vh></v>
<v t="ekr.20060206111431.183"><vh>createCommonBunch</vh></v>
</v>
<v t="ekr.20060206111431.184"><vh>canRedo &amp; canUndo</vh></v>
<v t="ekr.20060206111431.185"><vh>clearUndoState</vh></v>
<v t="ekr.20060206111431.186"><vh>enableMenuItems</vh></v>
<v t="ekr.20060206111431.187"><vh>getMark &amp; rollbackToMark (no longer used)</vh></v>
<v t="ekr.20060206111431.188"><vh>setUndoTypingParams</vh>
<v t="ekr.20060206111431.189"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20060206111431.190"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20060206111431.191"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20060206111431.192"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20060206111431.193"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20060206111431.194"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20060206111431.195"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20060206111431.196"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111431.197"><vh>redo &amp; helpers...</vh>
<v t="ekr.20060206111431.198"><vh>redoClearRecentFiles</vh></v>
<v t="ekr.20060206111431.199"><vh>redoCloneNode</vh></v>
<v t="ekr.20060206111431.200"><vh>redoDeleteNode</vh></v>
<v t="ekr.20060206111431.201"><vh>redoInsertNode</vh></v>
<v t="ekr.20060206111431.202"><vh>redoHoistNode &amp; redoDehoistNode</vh></v>
<v t="ekr.20060206111431.203"><vh>redoGroup</vh></v>
<v t="ekr.20060206111431.204"><vh>redoNodeContents</vh></v>
<v t="ekr.20060206111431.205"><vh>redoMark</vh></v>
<v t="ekr.20060206111431.206"><vh>redoMove</vh></v>
<v t="ekr.20060206111431.207"><vh>redoTree</vh></v>
<v t="ekr.20060206111431.208"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20060206111431.209"><vh>undo &amp; helpers...</vh>
<v t="ekr.20060206111431.210"><vh>undoClearRecentFiles</vh></v>
<v t="ekr.20060206111431.211"><vh>undoCloneNode</vh></v>
<v t="ekr.20060206111431.212"><vh>undoDeleteNode</vh></v>
<v t="ekr.20060206111431.213"><vh>undoGroup</vh></v>
<v t="ekr.20060206111431.214"><vh>undoHoistNode &amp; undoDehoistNode</vh></v>
<v t="ekr.20060206111431.215"><vh>undoInsertNode</vh></v>
<v t="ekr.20060206111431.216"><vh>undoMark</vh></v>
<v t="ekr.20060206111431.217"><vh>undoMove</vh></v>
<v t="ekr.20060206111431.218"><vh>undoNodeContents</vh></v>
<v t="ekr.20060206111431.219"><vh>undoTree</vh></v>
<v t="ekr.20060206111431.220"><vh>undoRedoTree</vh></v>
<v t="ekr.20060206111431.221"><vh>undoTyping</vh></v>
<v t="ekr.20060206111431.222"><vh>undoRedoText</vh>
<v t="ekr.20060206111431.223"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20060206111431.224"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
<v t="ekr.20060206111431.225"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20060206111431.226"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.149"><vh>setRedoType, setUndoType</vh></v>
<v t="ekr.20060206111431.142"><vh>cutStack</vh></v>
<v t="ekr.20060206111431.213"><vh>undoGroup</vh></v>
<v t="ekr.20060206111431.203"><vh>redoGroup</vh></v>
<v t="ekr.20060206111431.227"><vh>c.insertHeadline</vh></v>
<v t="ekr.20060206111431.170"><vh>afterInsertNode</vh></v>
<v t="ekr.20060206111431.162"><vh>afterChangeGroup</vh></v>
</v>
<v t="ekr.20060206111431.228"><vh>(Added event arg to all legacy commands)</vh>
<v t="ekr.20060206111431.56"><vh> doCommand</vh></v>
<v t="ekr.20060206111431.229"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20060206111431.230"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.231"><vh>Command handlers...</vh>
<v t="ekr.20060206111431.232"><vh>File Menu</vh>
<v t="ekr.20060206111431.233"><vh>top level</vh>
<v t="ekr.20060206111431.234"><vh>new</vh></v>
<v t="ekr.20060206111431.235"><vh>open</vh>
<v t="ekr.20060206111431.236"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.237"><vh>openWith and allies</vh>
<v t="ekr.20060206111431.238"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20060206111431.239"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20060206111431.240"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20060206111431.241"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20060206111431.242"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060206111431.243"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20060206111431.244"><vh>createOpenWithTempFile</vh>
<v t="ekr.20060206111431.245"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.246"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20060206111431.247"><vh>close</vh></v>
<v t="ekr.20060206111431.248"><vh>save</vh></v>
<v t="ekr.20060206111431.249"><vh>saveAs</vh></v>
<v t="ekr.20060206111431.250"><vh>saveTo</vh></v>
<v t="ekr.20060206111431.251"><vh>revert</vh></v>
</v>
<v t="ekr.20060206111431.252"><vh>Recent Files submenu &amp; allies</vh>
<v t="ekr.20060206111431.253"><vh>clearRecentFiles</vh></v>
<v t="ekr.20060206111431.254"><vh>openRecentFile</vh>
<v t="ekr.20060206111431.255"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.256"><vh>c.updateRecentFiles</vh></v>
</v>
<v t="ekr.20060206111431.257"><vh>Read/Write submenu</vh>
<v t="ekr.20060206111431.258"><vh>readOutlineOnly</vh></v>
<v t="ekr.20060206111431.259"><vh>readAtFileNodes (commands)</vh></v>
<v t="ekr.20060206111431.260"><vh>4.0 Commands</vh>
<v t="ekr.20060206111431.261"><vh>importDerivedFile</vh></v>
</v>
</v>
<v t="ekr.20060206111431.262"><vh>Tangle submenu</vh>
<v t="ekr.20060206111431.263"><vh>tangleAll</vh></v>
<v t="ekr.20060206111431.264"><vh>tangleMarked</vh></v>
<v t="ekr.20060206111431.265"><vh>tangle</vh></v>
</v>
<v t="ekr.20060206111431.266"><vh>Untangle submenu</vh>
<v t="ekr.20060206111431.267"><vh>untangleAll</vh></v>
<v t="ekr.20060206111431.268"><vh>untangleMarked</vh></v>
<v t="ekr.20060206111431.269"><vh>untangle</vh></v>
</v>
<v t="ekr.20060206111431.270"><vh>Import&amp;Export submenu</vh>
<v t="ekr.20060206111431.271"><vh>exportHeadlines</vh></v>
<v t="ekr.20060206111431.272"><vh>flattenOutline</vh></v>
<v t="ekr.20060206111431.273"><vh>importAtRoot</vh></v>
<v t="ekr.20060206111431.274"><vh>importAtFile</vh></v>
<v t="ekr.20060206111431.275"><vh>importCWEBFiles</vh></v>
<v t="ekr.20060206111431.276"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20060206111431.277"><vh>importNowebFiles</vh></v>
<v t="ekr.20060206111431.278"><vh>outlineToCWEB</vh></v>
<v t="ekr.20060206111431.279"><vh>outlineToNoweb</vh></v>
<v t="ekr.20060206111431.280"><vh>removeSentinels</vh></v>
<v t="ekr.20060206111431.281"><vh>weave</vh></v>
</v>
</v>
<v t="ekr.20060206111431.282"><vh>Edit Menu...</vh>
<v t="ekr.20060206111431.283"><vh>Edit top level</vh>
<v t="ekr.20060206111431.284"><vh>c.executeScript</vh>
<v t="ekr.20060206111431.285"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20060206111431.286"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20060206111431.287"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.288"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.289"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20060206111431.290"><vh>&lt;&lt; set root &gt;&gt;</vh></v>
<v t="ekr.20060206111431.291"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20060206111431.292"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20060206111431.293"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20060206111431.294"><vh>&lt;&lt; set p to the node given by vnodeName, etc. &gt;&gt;</vh>
<v t="ekr.20060206111431.295"><vh>&lt;&lt; just scan for the node name &gt;&gt;</vh></v>
<v t="ekr.20060206111431.296"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20060206111431.297"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20060206111431.298"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20060206111431.299"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20060206111431.300"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.301"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.302"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20060206111431.303"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20060206111431.304"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20060206111431.305"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20060206111431.306"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20060206111431.307"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.308"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.309"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="ekr.20060206111431.310"><vh>gotoLineNumberOpen</vh></v>
<v t="ekr.20060206111431.311"><vh>applyLineNumberMappingIfAny</vh></v>
<v t="ekr.20060206111431.312"><vh>goToScriptLineNumber</vh></v>
<v t="ekr.20060206111431.313"><vh>fontPanel</vh></v>
<v t="ekr.20060206111431.314"><vh>colorPanel</vh></v>
<v t="ekr.20060206111431.315"><vh>viewAllCharacters</vh></v>
<v t="ekr.20060206111431.316"><vh>preferences</vh></v>
</v>
<v t="ekr.20060206111431.317"><vh>Edit Body submenu</vh>
<v t="ekr.20060206111431.318"><vh>convertAllBlanks</vh></v>
<v t="ekr.20060206111431.319"><vh>convertAllTabs</vh></v>
<v t="ekr.20060206111431.320"><vh>convertBlanks</vh></v>
<v t="ekr.20060206111431.321"><vh>convertTabs</vh></v>
<v t="ekr.20060206111431.322"><vh>createLastChildNode</vh></v>
<v t="ekr.20060206111431.323"><vh>dedentBody</vh></v>
<v t="ekr.20060206111431.324"><vh>extract</vh></v>
<v t="ekr.20060206111431.325"><vh>extractSection</vh>
<v t="ekr.20060206111431.326"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.327"><vh>extractSectionNames</vh>
<v t="ekr.20060206111431.328"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.329"><vh>findBoundParagraph</vh>
<v t="ekr.20060206111431.330"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.331"><vh>findMatchingBracket</vh>
<v t="ekr.20060206111431.332"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20060206111431.333"><vh>getBodyLines</vh></v>
<v t="ekr.20060206111431.334"><vh>indentBody</vh></v>
<v t="ekr.20060206111431.335"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20060206111431.336"><vh>getTime</vh></v>
</v>
<v t="ekr.20060206111431.337"><vh>insert/removeComments</vh>
<v t="ekr.20060206111431.338"><vh>addComments</vh></v>
<v t="ekr.20060206111431.339"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20060206111431.340"><vh>reformatParagraph</vh>
<v t="ekr.20060206111431.341"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20060206111431.342"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20060206111431.343"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20060206111431.344"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.345"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20060206111431.346"><vh>Edit Headline submenu</vh>
<v t="ekr.20060206111431.347"><vh>editHeadline</vh></v>
<v t="ekr.20060206111431.348"><vh>toggleAngleBrackets</vh></v>
</v>
<v t="ekr.20060206111431.349"><vh>Find submenu (frame methods)</vh>
<v t="ekr.20060206111431.350"><vh>dismissFindPanel</vh></v>
<v t="ekr.20060206111431.351"><vh>showFindPanel</vh></v>
<v t="ekr.20060206111431.352"><vh>findNext</vh></v>
<v t="ekr.20060206111431.353"><vh>findPrevious</vh></v>
<v t="ekr.20060206111431.354"><vh>replace</vh></v>
<v t="ekr.20060206111431.355"><vh>replaceThenFind</vh></v>
<v t="ekr.20060206111431.356"><vh>replaceAll</vh></v>
</v>
<v t="ekr.20060206111431.357"><vh>notValidInBatchMode</vh></v>
</v>
<v t="ekr.20060206111431.358"><vh>Outline menu...</vh>
<v t="ekr.20060206111431.359"><vh> Top Level... (Commands)</vh>
<v t="ekr.20060206111431.360"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20060206111431.361"><vh>cutOutline</vh></v>
<v t="ekr.20060206111431.362"><vh>copyOutline</vh></v>
<v t="ekr.20060206111431.363"><vh>pasteOutline</vh>
<v t="ekr.20060206111431.364"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20060206111431.365"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.366"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20060206111431.367"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20060206111431.368"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20060206111431.369"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20060206111431.370"><vh>c.deleteOutline</vh></v>
<v t="ekr.20060206111431.227"><vh>c.insertHeadline</vh></v>
<v t="ekr.20060206111431.371"><vh>c.clone</vh></v>
<v t="ekr.20060206111431.372"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20060206111431.373"><vh>c.sortChildren</vh></v>
<v t="ekr.20060206111431.374"><vh>c.sortChildrenHelper</vh></v>
<v t="ekr.20060206111431.375"><vh>c.sortSiblings</vh></v>
<v t="ekr.20060206111431.376"><vh>c.sortTopLevel</vh></v>
</v>
<v t="ekr.20060206111431.377"><vh>Check Outline submenu...</vh>
<v t="ekr.20060206111431.378"><vh>c.checkOutline</vh>
<v t="ekr.20060206111431.379"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20060206111431.380"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20060206111431.381"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20060206111431.382"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20060206111431.383"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20060206111431.384"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20060206111431.385"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20060206111431.386"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20060206111431.387"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20060206111431.388"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20060206111431.389"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20060206111431.390"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
<v t="ekr.20060206111431.391"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.392"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20060206111431.393"><vh>checkAllPythonCode</vh>
<v t="ekr.20060206111431.394"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.395"><vh>checkPythonCode</vh>
<v t="ekr.20060206111431.396"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.397"><vh>checkPythonNode</vh></v>
<v t="ekr.20060206111431.398"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20060206111431.399"><vh>c.dumpOutline</vh></v>
<v t="ekr.20060206111431.400"><vh>Pretty Print commands</vh>
<v t="ekr.20060206111431.401"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20060206111431.402"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20060206111431.403"><vh>prettyPrintPythonNode</vh></v>
<v t="ekr.20060206111431.404"><vh>class prettyPrinter</vh>
<v t="ekr.20060206111431.405"><vh>__init__</vh>
<v t="ekr.20060206111431.406"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.407"><vh>clear</vh></v>
<v t="ekr.20060206111431.408"><vh>dumpLines</vh></v>
<v t="ekr.20060206111431.409"><vh>dumpToken</vh></v>
<v t="ekr.20060206111431.410"><vh>endUndo</vh></v>
<v t="ekr.20060206111431.411"><vh>get</vh></v>
<v t="ekr.20060206111431.412"><vh>prettyPrintNode</vh></v>
<v t="ekr.20060206111431.413"><vh>put</vh></v>
<v t="ekr.20060206111431.414"><vh>putArray</vh></v>
<v t="ekr.20060206111431.415"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20060206111431.416"><vh>doEndMarker</vh></v>
<v t="ekr.20060206111431.417"><vh>doErrorToken</vh></v>
<v t="ekr.20060206111431.418"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20060206111431.419"><vh>doMultiLine (strings, etc).</vh></v>
<v t="ekr.20060206111431.420"><vh>doName</vh></v>
<v t="ekr.20060206111431.421"><vh>doNewline</vh></v>
<v t="ekr.20060206111431.422"><vh>doNumber</vh></v>
<v t="ekr.20060206111431.423"><vh>doOp</vh></v>
<v t="ekr.20060206111431.424"><vh>doStartLine</vh></v>
<v t="ekr.20060206111431.425"><vh>oops</vh></v>
<v t="ekr.20060206111431.426"><vh>trace</vh></v>
</v>
<v t="ekr.20060206111431.427"><vh>putToken</vh></v>
<v t="ekr.20060206111431.428"><vh>replaceBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.429"><vh>Expand &amp; Contract...</vh>
<v t="ekr.20060206111431.430"><vh>Commands</vh>
<v t="ekr.20060206111431.431"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20060206111431.432"><vh>contractNode</vh></v>
<v t="ekr.20060206111431.433"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20060206111431.434"><vh>contractParent</vh></v>
<v t="ekr.20060206111431.435"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20060206111431.436"><vh>expandAllSubheads</vh></v>
<v t="ekr.20060206111431.437"><vh>expandLevel1..9</vh></v>
<v t="ekr.20060206111431.438"><vh>expandNextLevel</vh></v>
<v t="ekr.20060206111431.439"><vh>expandNode</vh></v>
<v t="ekr.20060206111431.440"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20060206111431.441"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20060206111431.442"><vh>Utilities</vh>
<v t="ekr.20060206111431.443"><vh>contractSubtree</vh></v>
<v t="ekr.20060206111431.444"><vh>expandSubtree</vh></v>
<v t="ekr.20060206111431.445"><vh>expandToLevel (rewritten in 4.4)</vh></v>
</v>
</v>
<v t="ekr.20060206111431.446"><vh>Goto</vh>
<v t="ekr.20060206111431.447"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20060206111431.448"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20060206111431.449"><vh>goToFirstNode</vh></v>
<v t="ekr.20060206111431.450"><vh>goToFirstSibling (New in 4.4)</vh></v>
<v t="ekr.20060206111431.451"><vh>goToLastNode (Bug fix in 4.4)</vh></v>
<v t="ekr.20060206111431.452"><vh>goToLastSibling (New in 4.4)</vh></v>
<v t="ekr.20060206111431.453"><vh>goToLastVisibleNode</vh></v>
<v t="ekr.20060206111431.454"><vh>goToNextClone</vh></v>
<v t="ekr.20060206111431.455"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20060206111431.456"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20060206111431.457"><vh>goToNextSibling</vh></v>
<v t="ekr.20060206111431.458"><vh>goToParent</vh></v>
<v t="ekr.20060206111431.459"><vh>goToPrevSibling</vh></v>
<v t="ekr.20060206111431.460"><vh>selectThreadNext</vh></v>
<v t="ekr.20060206111431.461"><vh>selectThreadBack</vh></v>
<v t="ekr.20060206111431.462"><vh>selectVisBack</vh></v>
<v t="ekr.20060206111431.463"><vh>selectVisNext</vh></v>
</v>
<v t="ekr.20060206111431.464"><vh>Mark...</vh>
<v t="ekr.20060206111431.465"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20060206111431.466"><vh>markChangedRoots</vh></v>
<v t="ekr.20060206111431.467"><vh>markAllAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20060206111431.468"><vh>markAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20060206111431.469"><vh>markClones</vh></v>
<v t="ekr.20060206111431.470"><vh>markHeadline</vh></v>
<v t="ekr.20060206111431.471"><vh>markSubheads</vh></v>
<v t="ekr.20060206111431.472"><vh>unmarkAll</vh></v>
</v>
<v t="ekr.20060206111431.473"><vh>Move... (Commands)</vh>
<v t="ekr.20060206111431.474"><vh>demote</vh></v>
<v t="ekr.20060206111431.475"><vh>moveOutlineDown</vh>
<v t="ekr.20060206111431.476"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.477"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20060206111431.478"><vh>moveOutlineRight</vh></v>
<v t="ekr.20060206111431.479"><vh>moveOutlineUp</vh>
<v t="ekr.20060206111431.480"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.481"><vh>promote</vh></v>
</v>
</v>
<v t="ekr.20060206111431.482"><vh>Window Menu</vh>
<v t="ekr.20060206111431.483"><vh>openCompareWindow</vh></v>
<v t="ekr.20060206111431.484"><vh>openPythonWindow (Dave Hein)</vh>
<v t="ekr.20060206111431.485"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="ekr.20060206111431.486"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="ekr.20060206111431.487"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
<v t="ekr.20060206111431.488"><vh>&lt;&lt; Try to open idle in Python 2.2 systems&gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.489"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="ekr.20060206111431.490"><vh>Help Menu</vh>
<v t="ekr.20060206111431.491"><vh>about (version number &amp; date)</vh></v>
<v t="ekr.20060206111431.492"><vh>leoConfig</vh></v>
<v t="ekr.20060206111431.493"><vh>leoDocumentation</vh></v>
<v t="ekr.20060206111431.494"><vh>leoHome</vh></v>
<v t="ekr.20060206111431.495"><vh>leoPlugins</vh></v>
<v t="ekr.20060206111431.496"><vh>leoTutorial (version number)</vh></v>
</v>
</v>
<v t="ekr.20060206111431.497"><vh>Gui-dependent commands</vh>
<v t="ekr.20060206111431.498"><vh>Edit Menu...</vh>
<v t="ekr.20060206111431.499"><vh>abortEditLabelCommand</vh></v>
<v t="ekr.20060206111431.49"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060206111431.50"><vh>copyText</vh></v>
<v t="ekr.20060206111431.51"><vh>cutText</vh></v>
<v t="ekr.20060206111431.52"><vh>pasteText</vh></v>
</v>
<v t="ekr.20060206111431.500"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060206111431.501"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20060206111431.502"><vh>Window Menu...</vh>
<v t="ekr.20060206111431.503"><vh>toggleActivePane</vh></v>
<v t="ekr.20060206111431.504"><vh>cascade</vh></v>
<v t="ekr.20060206111431.505"><vh>equalSizedPanes</vh></v>
<v t="ekr.20060206111431.506"><vh>hideLogWindow</vh></v>
<v t="ekr.20060206111431.507"><vh>minimizeAll</vh></v>
<v t="ekr.20060206111431.508"><vh>toggleSplitDirection (tkFrame)</vh>
<v t="ekr.20060206111431.509"><vh>togglePmwSplitDirection</vh></v>
<v t="ekr.20060206111431.510"><vh>toggleTkSplitDirection</vh></v>
</v>
<v t="ekr.20060206111431.511"><vh>resizeToScreen</vh></v>
</v>
<v t="ekr.20060206111431.512"><vh>Help Menu...</vh>
<v t="ekr.20060206111431.513"><vh>leoHelp</vh>
<v t="ekr.20060206111431.514"><vh>showProgressBar</vh>
<v t="ekr.20060206111431.515"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111431.516"><vh>(Improved gc stats)</vh>
<v t="ekr.20060206111431.517"><vh>app.__init__</vh>
<v t="ekr.20060206111431.518"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20060206111431.519"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20060206111431.520"><vh>run &amp; allies</vh>
<v t="ekr.20060206111431.521"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20060206111431.522"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20060206111431.523"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20060206111431.524"><vh>isValidPython</vh></v>
<v t="ekr.20060206111431.525"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20060206111431.526"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20060206111431.527"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20060206111431.528"><vh>getBatchScript</vh></v>
<v t="ekr.20060206111431.529"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20060206111431.105"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060206111431.106"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060206111431.530"><vh>Garbage Collection</vh>
<v t="ekr.20060206111431.531"><vh>enable_gc_debug</vh></v>
<v t="ekr.20060206111431.532"><vh>clearAllIvars</vh></v>
<v t="ekr.20060206111431.533"><vh>Called from commands</vh>
<v t="ekr.20060206111431.534"><vh>collectGarbage</vh></v>
<v t="ekr.20060206111431.535"><vh>printGcSummary</vh></v>
<v t="ekr.20060206111431.536"><vh>printGcAll</vh></v>
<v t="ekr.20060206111431.537"><vh>printGcObjects</vh>
<v t="ekr.20060206111431.538"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
<v t="ekr.20060206111431.539"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.540"><vh>printGcVerbose</vh></v>
</v>
<v t="ekr.20060206111431.541"><vh>Called from unit tests</vh>
<v t="ekr.20060206111431.542"><vh>printGc</vh>
<v t="ekr.20060206111431.543"><vh>printGcRefs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111431.58"><vh>(Added prettyPrintKey in various places)</vh>
<v t="ekr.20060206111431.59"><vh>k.prettyPrintKey</vh></v>
<v t="ekr.20060206111431.14"><vh>printBindings</vh></v>
<v t="ekr.20060206111431.45"><vh>printCommands</vh></v>
<v t="ekr.20060206111431.34"><vh>modeHelp</vh>
<v t="ekr.20060206111431.35"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060206111431.60"><vh>computeCompletionList</vh></v>
<v t="ekr.20060206111431.61"><vh>computeInverseBindingDict</vh></v>
</v>
<v t="ekr.20060206111431.62"><vh>Double-click didn't work in the body pane.</vh>
<v t="ekr.20060206111431.63"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20060206111431.64"><vh>masterKeyHandler</vh>
<v t="ekr.20060206111431.65"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060206111431.66"><vh>masterClickHandler</vh></v>
<v t="ekr.20060206111431.67"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20060206111431.68"><vh>masterMenuHandler</vh></v>
</v>
<v t="ekr.20060206111431.69"><vh>tree.OnDeactivate</vh></v>
<v t="ekr.20060206111431.70"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20060206111431.71"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20060206111431.72"><vh>OnBodyDoubleClick (Events)</vh></v>
</v>
<v t="ekr.20060206111431.544"><vh>Added free-text-widgets, dump-all-objects, dump-new-objects, verbose-dump-objects commands</vh></v>
<v t="ekr.20060206111431.545"><vh>Added gc_stats to print-stats command</vh></v>
<v t="ekr.20060206111431.546"><vh>Code issues</vh>
<v t="ekr.20060206111431.228"><vh>(Added event arg to all legacy commands)</vh>
<v t="ekr.20060206111431.56"><vh> doCommand</vh></v>
<v t="ekr.20060206111431.229"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20060206111431.230"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.231"><vh>Command handlers...</vh>
<v t="ekr.20060206111431.232"><vh>File Menu</vh>
<v t="ekr.20060206111431.233"><vh>top level</vh>
<v t="ekr.20060206111431.234"><vh>new</vh></v>
<v t="ekr.20060206111431.235"><vh>open</vh>
<v t="ekr.20060206111431.236"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.237"><vh>openWith and allies</vh>
<v t="ekr.20060206111431.238"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20060206111431.239"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20060206111431.240"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20060206111431.241"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20060206111431.242"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060206111431.243"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20060206111431.244"><vh>createOpenWithTempFile</vh>
<v t="ekr.20060206111431.245"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.246"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20060206111431.247"><vh>close</vh></v>
<v t="ekr.20060206111431.248"><vh>save</vh></v>
<v t="ekr.20060206111431.249"><vh>saveAs</vh></v>
<v t="ekr.20060206111431.250"><vh>saveTo</vh></v>
<v t="ekr.20060206111431.251"><vh>revert</vh></v>
</v>
<v t="ekr.20060206111431.252"><vh>Recent Files submenu &amp; allies</vh>
<v t="ekr.20060206111431.253"><vh>clearRecentFiles</vh></v>
<v t="ekr.20060206111431.254"><vh>openRecentFile</vh>
<v t="ekr.20060206111431.255"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.256"><vh>c.updateRecentFiles</vh></v>
</v>
<v t="ekr.20060206111431.257"><vh>Read/Write submenu</vh>
<v t="ekr.20060206111431.258"><vh>readOutlineOnly</vh></v>
<v t="ekr.20060206111431.259"><vh>readAtFileNodes (commands)</vh></v>
<v t="ekr.20060206111431.260"><vh>4.0 Commands</vh>
<v t="ekr.20060206111431.261"><vh>importDerivedFile</vh></v>
</v>
</v>
<v t="ekr.20060206111431.262"><vh>Tangle submenu</vh>
<v t="ekr.20060206111431.263"><vh>tangleAll</vh></v>
<v t="ekr.20060206111431.264"><vh>tangleMarked</vh></v>
<v t="ekr.20060206111431.265"><vh>tangle</vh></v>
</v>
<v t="ekr.20060206111431.266"><vh>Untangle submenu</vh>
<v t="ekr.20060206111431.267"><vh>untangleAll</vh></v>
<v t="ekr.20060206111431.268"><vh>untangleMarked</vh></v>
<v t="ekr.20060206111431.269"><vh>untangle</vh></v>
</v>
<v t="ekr.20060206111431.270"><vh>Import&amp;Export submenu</vh>
<v t="ekr.20060206111431.271"><vh>exportHeadlines</vh></v>
<v t="ekr.20060206111431.272"><vh>flattenOutline</vh></v>
<v t="ekr.20060206111431.273"><vh>importAtRoot</vh></v>
<v t="ekr.20060206111431.274"><vh>importAtFile</vh></v>
<v t="ekr.20060206111431.275"><vh>importCWEBFiles</vh></v>
<v t="ekr.20060206111431.276"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20060206111431.277"><vh>importNowebFiles</vh></v>
<v t="ekr.20060206111431.278"><vh>outlineToCWEB</vh></v>
<v t="ekr.20060206111431.279"><vh>outlineToNoweb</vh></v>
<v t="ekr.20060206111431.280"><vh>removeSentinels</vh></v>
<v t="ekr.20060206111431.281"><vh>weave</vh></v>
</v>
</v>
<v t="ekr.20060206111431.282"><vh>Edit Menu...</vh>
<v t="ekr.20060206111431.283"><vh>Edit top level</vh>
<v t="ekr.20060206111431.284"><vh>c.executeScript</vh>
<v t="ekr.20060206111431.285"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="ekr.20060206111431.286"><vh>&lt;&lt; handle an exception in the script &gt;&gt;</vh>
<v t="ekr.20060206111431.287"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.288"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.289"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20060206111431.290"><vh>&lt;&lt; set root &gt;&gt;</vh></v>
<v t="ekr.20060206111431.291"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20060206111431.292"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20060206111431.293"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20060206111431.294"><vh>&lt;&lt; set p to the node given by vnodeName, etc. &gt;&gt;</vh>
<v t="ekr.20060206111431.295"><vh>&lt;&lt; just scan for the node name &gt;&gt;</vh></v>
<v t="ekr.20060206111431.296"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20060206111431.297"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20060206111431.298"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20060206111431.299"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20060206111431.300"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.301"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.302"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20060206111431.303"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20060206111431.304"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20060206111431.305"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20060206111431.306"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20060206111431.307"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.308"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.309"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="ekr.20060206111431.310"><vh>gotoLineNumberOpen</vh></v>
<v t="ekr.20060206111431.311"><vh>applyLineNumberMappingIfAny</vh></v>
<v t="ekr.20060206111431.312"><vh>goToScriptLineNumber</vh></v>
<v t="ekr.20060206111431.313"><vh>fontPanel</vh></v>
<v t="ekr.20060206111431.314"><vh>colorPanel</vh></v>
<v t="ekr.20060206111431.315"><vh>viewAllCharacters</vh></v>
<v t="ekr.20060206111431.316"><vh>preferences</vh></v>
</v>
<v t="ekr.20060206111431.317"><vh>Edit Body submenu</vh>
<v t="ekr.20060206111431.318"><vh>convertAllBlanks</vh></v>
<v t="ekr.20060206111431.319"><vh>convertAllTabs</vh></v>
<v t="ekr.20060206111431.320"><vh>convertBlanks</vh></v>
<v t="ekr.20060206111431.321"><vh>convertTabs</vh></v>
<v t="ekr.20060206111431.322"><vh>createLastChildNode</vh></v>
<v t="ekr.20060206111431.323"><vh>dedentBody</vh></v>
<v t="ekr.20060206111431.324"><vh>extract</vh></v>
<v t="ekr.20060206111431.325"><vh>extractSection</vh>
<v t="ekr.20060206111431.326"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.327"><vh>extractSectionNames</vh>
<v t="ekr.20060206111431.328"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.329"><vh>findBoundParagraph</vh>
<v t="ekr.20060206111431.330"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.331"><vh>findMatchingBracket</vh>
<v t="ekr.20060206111431.332"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20060206111431.333"><vh>getBodyLines</vh></v>
<v t="ekr.20060206111431.334"><vh>indentBody</vh></v>
<v t="ekr.20060206111431.335"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20060206111431.336"><vh>getTime</vh></v>
</v>
<v t="ekr.20060206111431.337"><vh>insert/removeComments</vh>
<v t="ekr.20060206111431.338"><vh>addComments</vh></v>
<v t="ekr.20060206111431.339"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20060206111431.340"><vh>reformatParagraph</vh>
<v t="ekr.20060206111431.341"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20060206111431.342"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20060206111431.343"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20060206111431.344"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.345"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20060206111431.346"><vh>Edit Headline submenu</vh>
<v t="ekr.20060206111431.347"><vh>editHeadline</vh></v>
<v t="ekr.20060206111431.348"><vh>toggleAngleBrackets</vh></v>
</v>
<v t="ekr.20060206111431.349"><vh>Find submenu (frame methods)</vh>
<v t="ekr.20060206111431.350"><vh>dismissFindPanel</vh></v>
<v t="ekr.20060206111431.351"><vh>showFindPanel</vh></v>
<v t="ekr.20060206111431.352"><vh>findNext</vh></v>
<v t="ekr.20060206111431.353"><vh>findPrevious</vh></v>
<v t="ekr.20060206111431.354"><vh>replace</vh></v>
<v t="ekr.20060206111431.355"><vh>replaceThenFind</vh></v>
<v t="ekr.20060206111431.356"><vh>replaceAll</vh></v>
</v>
<v t="ekr.20060206111431.357"><vh>notValidInBatchMode</vh></v>
</v>
<v t="ekr.20060206111431.358"><vh>Outline menu...</vh>
<v t="ekr.20060206111431.359"><vh> Top Level... (Commands)</vh>
<v t="ekr.20060206111431.360"><vh>Cut &amp; Paste Outlines</vh>
<v t="ekr.20060206111431.361"><vh>cutOutline</vh></v>
<v t="ekr.20060206111431.362"><vh>copyOutline</vh></v>
<v t="ekr.20060206111431.363"><vh>pasteOutline</vh>
<v t="ekr.20060206111431.364"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20060206111431.365"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.366"><vh>pasteOutlineRetainingClones</vh></v>
</v>
<v t="ekr.20060206111431.367"><vh>Hoist &amp; dehoist</vh></v>
<v t="ekr.20060206111431.368"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="ekr.20060206111431.369"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20060206111431.370"><vh>c.deleteOutline</vh></v>
<v t="ekr.20060206111431.227"><vh>c.insertHeadline</vh></v>
<v t="ekr.20060206111431.371"><vh>c.clone</vh></v>
<v t="ekr.20060206111431.372"><vh>c.validateOutline</vh></v>
</v>
<v t="ekr.20060206111431.373"><vh>c.sortChildren</vh></v>
<v t="ekr.20060206111431.374"><vh>c.sortChildrenHelper</vh></v>
<v t="ekr.20060206111431.375"><vh>c.sortSiblings</vh></v>
<v t="ekr.20060206111431.376"><vh>c.sortTopLevel</vh></v>
</v>
<v t="ekr.20060206111431.377"><vh>Check Outline submenu...</vh>
<v t="ekr.20060206111431.378"><vh>c.checkOutline</vh>
<v t="ekr.20060206111431.379"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20060206111431.380"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20060206111431.381"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20060206111431.382"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20060206111431.383"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20060206111431.384"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20060206111431.385"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20060206111431.386"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20060206111431.387"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20060206111431.388"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20060206111431.389"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20060206111431.390"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
<v t="ekr.20060206111431.391"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.392"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20060206111431.393"><vh>checkAllPythonCode</vh>
<v t="ekr.20060206111431.394"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.395"><vh>checkPythonCode</vh>
<v t="ekr.20060206111431.396"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.397"><vh>checkPythonNode</vh></v>
<v t="ekr.20060206111431.398"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20060206111431.399"><vh>c.dumpOutline</vh></v>
<v t="ekr.20060206111431.400"><vh>Pretty Print commands</vh>
<v t="ekr.20060206111431.401"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20060206111431.402"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20060206111431.403"><vh>prettyPrintPythonNode</vh></v>
<v t="ekr.20060206111431.404"><vh>class prettyPrinter</vh>
<v t="ekr.20060206111431.405"><vh>__init__</vh>
<v t="ekr.20060206111431.406"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.407"><vh>clear</vh></v>
<v t="ekr.20060206111431.408"><vh>dumpLines</vh></v>
<v t="ekr.20060206111431.409"><vh>dumpToken</vh></v>
<v t="ekr.20060206111431.410"><vh>endUndo</vh></v>
<v t="ekr.20060206111431.411"><vh>get</vh></v>
<v t="ekr.20060206111431.412"><vh>prettyPrintNode</vh></v>
<v t="ekr.20060206111431.413"><vh>put</vh></v>
<v t="ekr.20060206111431.414"><vh>putArray</vh></v>
<v t="ekr.20060206111431.415"><vh>putNormalToken &amp; allies</vh>
<v t="ekr.20060206111431.416"><vh>doEndMarker</vh></v>
<v t="ekr.20060206111431.417"><vh>doErrorToken</vh></v>
<v t="ekr.20060206111431.418"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20060206111431.419"><vh>doMultiLine (strings, etc).</vh></v>
<v t="ekr.20060206111431.420"><vh>doName</vh></v>
<v t="ekr.20060206111431.421"><vh>doNewline</vh></v>
<v t="ekr.20060206111431.422"><vh>doNumber</vh></v>
<v t="ekr.20060206111431.423"><vh>doOp</vh></v>
<v t="ekr.20060206111431.424"><vh>doStartLine</vh></v>
<v t="ekr.20060206111431.425"><vh>oops</vh></v>
<v t="ekr.20060206111431.426"><vh>trace</vh></v>
</v>
<v t="ekr.20060206111431.427"><vh>putToken</vh></v>
<v t="ekr.20060206111431.428"><vh>replaceBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.429"><vh>Expand &amp; Contract...</vh>
<v t="ekr.20060206111431.430"><vh>Commands</vh>
<v t="ekr.20060206111431.431"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20060206111431.432"><vh>contractNode</vh></v>
<v t="ekr.20060206111431.433"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20060206111431.434"><vh>contractParent</vh></v>
<v t="ekr.20060206111431.435"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20060206111431.436"><vh>expandAllSubheads</vh></v>
<v t="ekr.20060206111431.437"><vh>expandLevel1..9</vh></v>
<v t="ekr.20060206111431.438"><vh>expandNextLevel</vh></v>
<v t="ekr.20060206111431.439"><vh>expandNode</vh></v>
<v t="ekr.20060206111431.440"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20060206111431.441"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20060206111431.442"><vh>Utilities</vh>
<v t="ekr.20060206111431.443"><vh>contractSubtree</vh></v>
<v t="ekr.20060206111431.444"><vh>expandSubtree</vh></v>
<v t="ekr.20060206111431.445"><vh>expandToLevel (rewritten in 4.4)</vh></v>
</v>
</v>
<v t="ekr.20060206111431.446"><vh>Goto</vh>
<v t="ekr.20060206111431.447"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20060206111431.448"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20060206111431.449"><vh>goToFirstNode</vh></v>
<v t="ekr.20060206111431.450"><vh>goToFirstSibling (New in 4.4)</vh></v>
<v t="ekr.20060206111431.451"><vh>goToLastNode (Bug fix in 4.4)</vh></v>
<v t="ekr.20060206111431.452"><vh>goToLastSibling (New in 4.4)</vh></v>
<v t="ekr.20060206111431.453"><vh>goToLastVisibleNode</vh></v>
<v t="ekr.20060206111431.454"><vh>goToNextClone</vh></v>
<v t="ekr.20060206111431.455"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20060206111431.456"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20060206111431.457"><vh>goToNextSibling</vh></v>
<v t="ekr.20060206111431.458"><vh>goToParent</vh></v>
<v t="ekr.20060206111431.459"><vh>goToPrevSibling</vh></v>
<v t="ekr.20060206111431.460"><vh>selectThreadNext</vh></v>
<v t="ekr.20060206111431.461"><vh>selectThreadBack</vh></v>
<v t="ekr.20060206111431.462"><vh>selectVisBack</vh></v>
<v t="ekr.20060206111431.463"><vh>selectVisNext</vh></v>
</v>
<v t="ekr.20060206111431.464"><vh>Mark...</vh>
<v t="ekr.20060206111431.465"><vh>markChangedHeadlines</vh></v>
<v t="ekr.20060206111431.466"><vh>markChangedRoots</vh></v>
<v t="ekr.20060206111431.467"><vh>markAllAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20060206111431.468"><vh>markAtFileNodesDirty (not used)</vh></v>
<v t="ekr.20060206111431.469"><vh>markClones</vh></v>
<v t="ekr.20060206111431.470"><vh>markHeadline</vh></v>
<v t="ekr.20060206111431.471"><vh>markSubheads</vh></v>
<v t="ekr.20060206111431.472"><vh>unmarkAll</vh></v>
</v>
<v t="ekr.20060206111431.473"><vh>Move... (Commands)</vh>
<v t="ekr.20060206111431.474"><vh>demote</vh></v>
<v t="ekr.20060206111431.475"><vh>moveOutlineDown</vh>
<v t="ekr.20060206111431.476"><vh>&lt;&lt; Move p down &amp; set moved if successful &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.477"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20060206111431.478"><vh>moveOutlineRight</vh></v>
<v t="ekr.20060206111431.479"><vh>moveOutlineUp</vh>
<v t="ekr.20060206111431.480"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.481"><vh>promote</vh></v>
</v>
</v>
<v t="ekr.20060206111431.482"><vh>Window Menu</vh>
<v t="ekr.20060206111431.483"><vh>openCompareWindow</vh></v>
<v t="ekr.20060206111431.484"><vh>openPythonWindow (Dave Hein)</vh>
<v t="ekr.20060206111431.485"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="ekr.20060206111431.486"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="ekr.20060206111431.487"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
<v t="ekr.20060206111431.488"><vh>&lt;&lt; Try to open idle in Python 2.2 systems&gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.489"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="ekr.20060206111431.490"><vh>Help Menu</vh>
<v t="ekr.20060206111431.491"><vh>about (version number &amp; date)</vh></v>
<v t="ekr.20060206111431.492"><vh>leoConfig</vh></v>
<v t="ekr.20060206111431.493"><vh>leoDocumentation</vh></v>
<v t="ekr.20060206111431.494"><vh>leoHome</vh></v>
<v t="ekr.20060206111431.495"><vh>leoPlugins</vh></v>
<v t="ekr.20060206111431.496"><vh>leoTutorial (version number)</vh></v>
</v>
</v>
<v t="ekr.20060206111431.497"><vh>Gui-dependent commands</vh>
<v t="ekr.20060206111431.498"><vh>Edit Menu...</vh>
<v t="ekr.20060206111431.499"><vh>abortEditLabelCommand</vh></v>
<v t="ekr.20060206111431.49"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20060206111431.50"><vh>copyText</vh></v>
<v t="ekr.20060206111431.51"><vh>cutText</vh></v>
<v t="ekr.20060206111431.52"><vh>pasteText</vh></v>
</v>
<v t="ekr.20060206111431.500"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20060206111431.501"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20060206111431.502"><vh>Window Menu...</vh>
<v t="ekr.20060206111431.503"><vh>toggleActivePane</vh></v>
<v t="ekr.20060206111431.504"><vh>cascade</vh></v>
<v t="ekr.20060206111431.505"><vh>equalSizedPanes</vh></v>
<v t="ekr.20060206111431.506"><vh>hideLogWindow</vh></v>
<v t="ekr.20060206111431.507"><vh>minimizeAll</vh></v>
<v t="ekr.20060206111431.508"><vh>toggleSplitDirection (tkFrame)</vh>
<v t="ekr.20060206111431.509"><vh>togglePmwSplitDirection</vh></v>
<v t="ekr.20060206111431.510"><vh>toggleTkSplitDirection</vh></v>
</v>
<v t="ekr.20060206111431.511"><vh>resizeToScreen</vh></v>
</v>
<v t="ekr.20060206111431.512"><vh>Help Menu...</vh>
<v t="ekr.20060206111431.513"><vh>leoHelp</vh>
<v t="ekr.20060206111431.514"><vh>showProgressBar</vh>
<v t="ekr.20060206111431.515"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111431.547"><vh>Code cleanup</vh></v>
</v>
<v t="ekr.20060206111431.548"><vh>Focus issues</vh>
<v t="ekr.20060206111431.549"><vh>Removed code in c.begin/EndUpdate and c.endEditLabel that tried to save/restore focus</vh></v>
<v t="ekr.20060206111431.550"><vh>Put back the call to w.upate in g.app.gui.set_focus</vh></v>
<v t="ekr.20060206111431.551"><vh>Focus goes to body if minibuffer command does not exist</vh></v>
<v t="ekr.20060206111431.552"><vh>Fixed major blunder: tree.onHeadChanged sets focus only if there was a real change</vh></v>
</v>
<v t="ekr.20060206111431.553"><vh>Scrolling issues</vh>
<v t="ekr.20060206111431.102"><vh>Disabled auto-scrolling in outline pane on clicks</vh>
<v t="ekr.20060206111431.103"><vh>Drawing... (tkTree)</vh>
<v t="ekr.20060206111431.104"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20060206111431.105"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060206111431.106"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060206111431.107"><vh>idle_second_redraw</vh></v>
<v t="ekr.20060206111431.108"><vh>drawX...</vh>
<v t="ekr.20060206111431.109"><vh>drawBox</vh></v>
<v t="ekr.20060206111431.110"><vh>drawClickBox</vh>
<v t="ekr.20060206111431.111"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.112"><vh>drawIcon</vh>
<v t="ekr.20060206111431.113"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.114"><vh>drawLine</vh></v>
<v t="ekr.20060206111431.115"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20060206111431.116"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20060206111431.117"><vh>drawText</vh>
<v t="ekr.20060206111431.118"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.119"><vh>drawUserIcons</vh></v>
<v t="ekr.20060206111431.120"><vh>drawUserIcon</vh>
<v t="ekr.20060206111431.121"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20060206111431.122"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20060206111431.123"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20060206111431.124"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.125"><vh>drawTopTree</vh></v>
<v t="ekr.20060206111431.126"><vh>drawTree</vh></v>
</v>
<v t="ekr.20060206111431.127"><vh>Helpers...</vh>
<v t="ekr.20060206111431.128"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20060206111431.129"><vh>getIconImage</vh></v>
<v t="ekr.20060206111431.130"><vh>scrollTo</vh>
<v t="ekr.20060206111431.131"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20060206111431.132"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.133"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20060206111431.134"><vh>yoffset</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.135"><vh>move-outline and find commands force a screen scroll</vh>
<v t="ekr.20060206111431.136"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060206111431.554"><vh>Several commands force screen scrollling</vh></v>
</v>
<v t="ekr.20060206111431.555"><vh>Features</vh>
<v t="ekr.20060206111431.75"><vh>Made modes work</vh>
<v t="ekr.20060206111431.76"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060206111431.77"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060206111431.78"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20060206111431.79"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.80"><vh>Dispatching (keyHandler)</vh>
<v t="ekr.20060206111431.15"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060206111431.16"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060206111431.17"><vh>callStateFunction</vh></v>
<v t="ekr.20060206111431.18"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060206111431.19"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060206111431.81"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060206111431.82"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060206111431.83"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060206111431.84"><vh>addModeCommands</vh></v>
<v t="ekr.20060206111431.85"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20060206111431.86"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060206111431.87"><vh>bindKey</vh>
<v t="ekr.20060206111431.88"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060206111431.89"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.90"><vh>bindKeyToDict</vh></v>
<v t="ekr.20060206111431.91"><vh>bindOpenWith</vh></v>
<v t="ekr.20060206111431.92"><vh>checkBindings</vh></v>
<v t="ekr.20060206111431.93"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20060206111431.84"><vh>addModeCommands</vh></v>
<v t="ekr.20060206111431.94"><vh>initSpecialIvars</vh></v>
<v t="ekr.20060206111431.95"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060206111431.25"><vh>Modes</vh>
<v t="ekr.20060206111431.26"><vh>badMode</vh></v>
<v t="ekr.20060206111431.27"><vh>createModeBindings</vh></v>
<v t="ekr.20060206111431.28"><vh>endMode</vh></v>
<v t="ekr.20060206111431.29"><vh>enterNamedMode</vh></v>
<v t="ekr.20060206111431.30"><vh>exitNamedMode</vh></v>
<v t="ekr.20060206111431.31"><vh>generalModeHandler</vh></v>
<v t="ekr.20060206111431.32"><vh>initMode</vh></v>
<v t="ekr.20060206111431.33"><vh>reinitMode</vh></v>
<v t="ekr.20060206111431.34"><vh>modeHelp</vh>
<v t="ekr.20060206111431.35"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060206111431.36"><vh>set-xxx-State</vh></v>
<v t="ekr.20060206111431.37"><vh>setInputState</vh></v>
<v t="ekr.20060206111431.38"><vh>showStateAndMode</vh></v>
</v>
</v>
<v t="ekr.20060206111431.96"><vh>Disabled plain-key bindings in insert/overwrite modes</vh>
<v t="ekr.20060206111431.36"><vh>set-xxx-State</vh></v>
<v t="ekr.20060206111431.97"><vh>selfInsertCommand</vh>
<v t="ekr.20060206111431.98"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060206111431.99"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060206111431.100"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060206111431.101"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060206111431.86"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060206111431.87"><vh>bindKey</vh>
<v t="ekr.20060206111431.88"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060206111431.89"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.90"><vh>bindKeyToDict</vh></v>
<v t="ekr.20060206111431.91"><vh>bindOpenWith</vh></v>
<v t="ekr.20060206111431.92"><vh>checkBindings</vh></v>
<v t="ekr.20060206111431.93"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20060206111431.84"><vh>addModeCommands</vh></v>
<v t="ekr.20060206111431.94"><vh>initSpecialIvars</vh></v>
<v t="ekr.20060206111431.95"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20060206111431.137"><vh>(Limited undo)</vh>
<v t="ekr.20060206111431.138"><vh>class undoer</vh>
<v t="ekr.20060206111431.139"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="ekr.20060206111431.140"><vh>clearIvars</vh></v>
</v>
<v t="ekr.20060206111431.141"><vh>Internal helpers</vh>
<v t="ekr.20060206111431.142"><vh>cutStack</vh></v>
<v t="ekr.20060206111431.143"><vh>getBead</vh></v>
<v t="ekr.20060206111431.144"><vh>peekBead</vh></v>
<v t="ekr.20060206111431.145"><vh>pushBead</vh></v>
<v t="ekr.20060206111431.146"><vh>setIvarsFromBunch</vh></v>
<v t="ekr.20060206111431.147"><vh>recognizeStartOfTypingWord</vh></v>
<v t="ekr.20060206111431.148"><vh>redoMenuName, undoMenuName</vh></v>
<v t="ekr.20060206111431.149"><vh>setRedoType, setUndoType</vh></v>
<v t="ekr.20060206111431.150"><vh>setUndoTypes</vh></v>
<v t="ekr.20060206111431.151"><vh>u.restoreTree &amp; helpers</vh>
<v t="ekr.20060206111431.152"><vh>restoreVnodeUndoInfo</vh></v>
<v t="ekr.20060206111431.153"><vh>restoreTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20060206111431.154"><vh>u.saveTree &amp; helpers</vh>
<v t="ekr.20060206111431.155"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
<v t="ekr.20060206111431.156"><vh>createVnodeUndoInfo</vh></v>
<v t="ekr.20060206111431.157"><vh>createTnodeUndoInfo</vh></v>
</v>
<v t="ekr.20060206111431.158"><vh>u.trace</vh></v>
<v t="ekr.20060206111431.159"><vh>updateMarks</vh></v>
</v>
<v t="ekr.20060206111431.160"><vh>Externally visible entries</vh>
<v t="ekr.20060206111431.161"><vh>afterX...</vh>
<v t="ekr.20060206111431.162"><vh>afterChangeGroup</vh></v>
<v t="ekr.20060206111431.163"><vh>afterChangeNodeContents</vh></v>
<v t="ekr.20060206111431.164"><vh>afterChangeTree</vh></v>
<v t="ekr.20060206111431.165"><vh>afterClearRecentFiles</vh></v>
<v t="ekr.20060206111431.166"><vh>afterCloneNode</vh></v>
<v t="ekr.20060206111431.167"><vh>afterDehoist</vh></v>
<v t="ekr.20060206111431.168"><vh>afterDeleteNode</vh></v>
<v t="ekr.20060206111431.169"><vh>afterHoist</vh></v>
<v t="ekr.20060206111431.170"><vh>afterInsertNode</vh></v>
<v t="ekr.20060206111431.171"><vh>afterMark</vh></v>
<v t="ekr.20060206111431.172"><vh>afterMoveNode</vh></v>
</v>
<v t="ekr.20060206111431.173"><vh>beforeX...</vh>
<v t="ekr.20060206111431.174"><vh>beforeChangeGroup</vh></v>
<v t="ekr.20060206111431.175"><vh>beforeChangeNodeContents</vh></v>
<v t="ekr.20060206111431.176"><vh>beforeChangeTree</vh></v>
<v t="ekr.20060206111431.177"><vh>beforeClearRecentFiles</vh></v>
<v t="ekr.20060206111431.178"><vh>beforeCloneNode</vh></v>
<v t="ekr.20060206111431.179"><vh>beforeDeleteNode</vh></v>
<v t="ekr.20060206111431.180"><vh>beforeInsertNode</vh></v>
<v t="ekr.20060206111431.181"><vh>beforeMark</vh></v>
<v t="ekr.20060206111431.182"><vh>beforeMoveNode</vh></v>
<v t="ekr.20060206111431.183"><vh>createCommonBunch</vh></v>
</v>
<v t="ekr.20060206111431.184"><vh>canRedo &amp; canUndo</vh></v>
<v t="ekr.20060206111431.185"><vh>clearUndoState</vh></v>
<v t="ekr.20060206111431.186"><vh>enableMenuItems</vh></v>
<v t="ekr.20060206111431.187"><vh>getMark &amp; rollbackToMark (no longer used)</vh></v>
<v t="ekr.20060206111431.188"><vh>setUndoTypingParams</vh>
<v t="ekr.20060206111431.189"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20060206111431.190"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20060206111431.191"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20060206111431.192"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20060206111431.193"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20060206111431.194"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20060206111431.195"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20060206111431.196"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060206111431.197"><vh>redo &amp; helpers...</vh>
<v t="ekr.20060206111431.198"><vh>redoClearRecentFiles</vh></v>
<v t="ekr.20060206111431.199"><vh>redoCloneNode</vh></v>
<v t="ekr.20060206111431.200"><vh>redoDeleteNode</vh></v>
<v t="ekr.20060206111431.201"><vh>redoInsertNode</vh></v>
<v t="ekr.20060206111431.202"><vh>redoHoistNode &amp; redoDehoistNode</vh></v>
<v t="ekr.20060206111431.203"><vh>redoGroup</vh></v>
<v t="ekr.20060206111431.204"><vh>redoNodeContents</vh></v>
<v t="ekr.20060206111431.205"><vh>redoMark</vh></v>
<v t="ekr.20060206111431.206"><vh>redoMove</vh></v>
<v t="ekr.20060206111431.207"><vh>redoTree</vh></v>
<v t="ekr.20060206111431.208"><vh>redoTyping</vh></v>
</v>
<v t="ekr.20060206111431.209"><vh>undo &amp; helpers...</vh>
<v t="ekr.20060206111431.210"><vh>undoClearRecentFiles</vh></v>
<v t="ekr.20060206111431.211"><vh>undoCloneNode</vh></v>
<v t="ekr.20060206111431.212"><vh>undoDeleteNode</vh></v>
<v t="ekr.20060206111431.213"><vh>undoGroup</vh></v>
<v t="ekr.20060206111431.214"><vh>undoHoistNode &amp; undoDehoistNode</vh></v>
<v t="ekr.20060206111431.215"><vh>undoInsertNode</vh></v>
<v t="ekr.20060206111431.216"><vh>undoMark</vh></v>
<v t="ekr.20060206111431.217"><vh>undoMove</vh></v>
<v t="ekr.20060206111431.218"><vh>undoNodeContents</vh></v>
<v t="ekr.20060206111431.219"><vh>undoTree</vh></v>
<v t="ekr.20060206111431.220"><vh>undoRedoTree</vh></v>
<v t="ekr.20060206111431.221"><vh>undoTyping</vh></v>
<v t="ekr.20060206111431.222"><vh>undoRedoText</vh>
<v t="ekr.20060206111431.223"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20060206111431.224"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
<v t="ekr.20060206111431.225"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20060206111431.226"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.149"><vh>setRedoType, setUndoType</vh></v>
<v t="ekr.20060206111431.142"><vh>cutStack</vh></v>
<v t="ekr.20060206111431.213"><vh>undoGroup</vh></v>
<v t="ekr.20060206111431.203"><vh>redoGroup</vh></v>
<v t="ekr.20060206111431.227"><vh>c.insertHeadline</vh></v>
<v t="ekr.20060206111431.170"><vh>afterInsertNode</vh></v>
<v t="ekr.20060206111431.162"><vh>afterChangeGroup</vh></v>
</v>
<v t="ekr.20060206111431.544"><vh>Added free-text-widgets, dump-all-objects, dump-new-objects, verbose-dump-objects commands</vh></v>
<v t="ekr.20060206111431.545"><vh>Added gc_stats to print-stats command</vh></v>
</v>
<v t="ekr.20060206111431.556"><vh>Made proper bindings for the log pane</vh>
<v t="ekr.20060206111431.557"><vh>class leoTkinterLog</vh>
<v t="ekr.20060206111431.558"><vh>tkLog Birth</vh>
<v t="ekr.20060206111431.559"><vh>tkLog.__init__</vh></v>
<v t="ekr.20060206111431.560"><vh>tkLog.createControl</vh></v>
<v t="ekr.20060206111431.561"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20060206111431.562"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20060206111431.563"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20060206111431.564"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20060206111431.565"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20060206111431.566"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20060206111431.567"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20060206111431.568"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20060206111431.569"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20060206111431.570"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20060206111431.571"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20060206111431.572"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20060206111431.573"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20060206111431.574"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20060206111431.575"><vh>put</vh>
<v t="ekr.20060206111431.576"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="ekr.20060206111431.577"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.578"><vh>putnl</vh></v>
</v>
<v t="ekr.20060206111431.579"><vh>Tab (TkLog)</vh>
<v t="ekr.20060206111431.580"><vh>clearTab</vh></v>
<v t="ekr.20060206111431.581"><vh>createTab</vh>
<v t="ekr.20060206111431.582"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.583"><vh>deleteTab</vh></v>
<v t="ekr.20060206111431.584"><vh>hideTab</vh></v>
<v t="ekr.20060206111431.585"><vh>getSelectedTab</vh></v>
<v t="ekr.20060206111431.586"><vh>lower/raiseTab</vh></v>
<v t="ekr.20060206111431.587"><vh>renameTab</vh></v>
<v t="ekr.20060206111431.588"><vh>selectTab</vh></v>
<v t="ekr.20060206111431.589"><vh>setTabBindings</vh></v>
<v t="ekr.20060206111431.590"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20060206111431.591"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20060206111431.592"><vh>newTabFromMenu</vh></v>
<v t="ekr.20060206111431.593"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20060206111431.594"><vh>getTabName</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206111431.589"><vh>setTabBindings</vh></v>
<v t="ekr.20060206111431.581"><vh>createTab</vh>
<v t="ekr.20060206111431.582"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060206111431.547"><vh>Code cleanup</vh></v>
<v t="ekr.20060206111431.595"><vh>Improved tree allocation</vh>
<v t="ekr.20060206111431.596"><vh>What I did</vh></v>
<v t="ekr.20060206111431.597"><vh>tree.select</vh>
<v t="ekr.20060206111431.598"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20060206111431.599"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20060206111431.600"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20060206111431.601"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20060206111431.602"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.603"><vh>__init__ (tkTree)</vh>
<v t="ekr.20060206111431.604"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20060206111431.605"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20060206111431.606"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.125"><vh>drawTopTree</vh></v>
<v t="ekr.20060206111431.607"><vh>findEditWidget</vh></v>
<v t="ekr.20060206111431.608"><vh>setText</vh></v>
<v t="ekr.20060206111431.609"><vh>Allocation...</vh>
<v t="ekr.20060206111431.610"><vh>newBox</vh></v>
<v t="ekr.20060206111431.611"><vh>newClickBox</vh></v>
<v t="ekr.20060206111431.612"><vh>newIcon</vh></v>
<v t="ekr.20060206111431.613"><vh>newLine</vh></v>
<v t="ekr.20060206111431.614"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20060206111431.615"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
<v t="ekr.20060206111431.616"><vh>recycleWidgets</vh></v>
<v t="ekr.20060206111431.617"><vh>destroyWidgets</vh></v>
<v t="ekr.20060206111431.618"><vh>showStats</vh></v>
</v>
</v>
<v t="ekr.20060206111431.619"><vh>What I did earlier</vh></v>
<v t="ekr.20060206111431.620"><vh>What I did: 2-4-06</vh></v>
<v t="ekr.20060206111431.621"><vh>What I did: 2-5-06</vh></v>
<v t="ekr.20060206111431.622"><vh>What I did: 2-6-05</vh></v>
</v>
<v t="ekr.20060214141244.1"><vh>Part 2</vh>
<v t="ekr.20060214141244.2"><vh>Fixed multiple pastes into find tab</vh>
<v t="ekr.20060214141244.3"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060214141244.4"><vh>pasteText</vh></v>
</v>
<v t="ekr.20060214141244.5"><vh>catch exceptions in pasteText</vh></v>
<v t="ekr.20060214141244.6"><vh>Made sure yield works with Python 2.2</vh></v>
<v t="ekr.20060214141244.7"><vh>Fixed the alt key on Linux</vh>
<v t="ekr.20060214141244.8"><vh>k.strokeFromEvent</vh></v>
</v>
<v t="ekr.20060214141244.9"><vh>Fixed problem with body_gmt_time setting</vh>
<v t="ekr.20060214141244.10"><vh>Report</vh></v>
<v t="ekr.20060214141244.11"><vh>getTime &amp; test</vh></v>
</v>
<v t="ekr.20060214141244.12"><vh>Use os.getenv('User") if it exists to get initial cvs name</vh>
<v t="ekr.20060214141244.13"><vh>Report</vh></v>
<v t="ekr.20060214141244.14"><vh>app.setLeoID</vh>
<v t="ekr.20060214141244.15"><vh>&lt;&lt; return if we can set leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20060214141244.16"><vh>&lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20060214141244.17"><vh>&lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;</vh></v>
<v t="ekr.20060214141244.18"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="ekr.20060214141244.19"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060214141244.20"><vh>Made sure save updates the open directory</vh>
<v t="ekr.20060214141244.21"><vh>top level</vh>
<v t="ekr.20060214141244.22"><vh>new</vh></v>
<v t="ekr.20060214141244.23"><vh>open</vh>
<v t="ekr.20060214141244.24"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060214141244.25"><vh>openWith and allies</vh>
<v t="ekr.20060214141244.26"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20060214141244.27"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20060214141244.28"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20060214141244.29"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20060214141244.30"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060214141244.31"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20060214141244.32"><vh>createOpenWithTempFile</vh>
<v t="ekr.20060214141244.33"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20060214141244.34"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20060214141244.35"><vh>close</vh></v>
<v t="ekr.20060214141244.36"><vh>save</vh></v>
<v t="ekr.20060214141244.37"><vh>saveAs</vh></v>
<v t="ekr.20060214141244.38"><vh>saveTo</vh></v>
<v t="ekr.20060214141244.39"><vh>revert</vh></v>
</v>
<v t="ekr.20060214141244.40"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20060214141244.41"><vh>Fix sort-lines problems</vh>
<v t="ekr.20060214141244.42"><vh>What I did</vh></v>
<v t="ekr.20060214141244.43"><vh>sortLines</vh></v>
<v t="ekr.20060214141244.44"><vh>begin/endCommand</vh>
<v t="ekr.20060214141244.45"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20060214141244.46"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20060214141244.47"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060214141244.48"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060214141244.49"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060214141244.50"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060214141244.51"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20060214141244.52"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20060214141244.53"><vh>c.bringToFront</vh></v>
<v t="ekr.20060214141244.54"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060214141244.55"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060214141244.50"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060214141244.56"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20060214141244.57"><vh>c.recolor_now</vh></v>
<v t="ekr.20060214141244.58"><vh>c.redraw_now</vh></v>
<v t="ekr.20060214141244.59"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060214141244.60"><vh>c.traceFocus</vh></v>
<v t="ekr.20060214141244.61"><vh>c.widget_name</vh></v>
<v t="ekr.20060214141244.62"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060214141244.63"><vh>c.xWantsFocusNow</vh></v>
</v>
</v>
<v t="ekr.20060214141244.64"><vh>Call updateAllMenus only if c.exists</vh></v>
<v t="ekr.20060214141244.65"><vh>Fixed problem with view plugin</vh></v>
<v t="ekr.20060214141244.66"><vh>Installed cleo patch</vh></v>
<v t="ekr.20060214141244.67"><vh>Remember previous open directory</vh>
<v t="ekr.20060214141244.68"><vh>Request</vh></v>
<v t="ekr.20060214141244.40"><vh>g.openWithFileName</vh></v>
<v t="ekr.20060214141244.21"><vh>top level</vh>
<v t="ekr.20060214141244.22"><vh>new</vh></v>
<v t="ekr.20060214141244.23"><vh>open</vh>
<v t="ekr.20060214141244.24"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20060214141244.25"><vh>openWith and allies</vh>
<v t="ekr.20060214141244.26"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20060214141244.27"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20060214141244.28"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20060214141244.29"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20060214141244.30"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060214141244.31"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20060214141244.32"><vh>createOpenWithTempFile</vh>
<v t="ekr.20060214141244.33"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20060214141244.34"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20060214141244.35"><vh>close</vh></v>
<v t="ekr.20060214141244.36"><vh>save</vh></v>
<v t="ekr.20060214141244.37"><vh>saveAs</vh></v>
<v t="ekr.20060214141244.38"><vh>saveTo</vh></v>
<v t="ekr.20060214141244.39"><vh>revert</vh></v>
</v>
<v t="ekr.20060214141244.69"><vh>app.gui.Tkinter file dialogs</vh>
<v t="ekr.20060214141244.70"><vh>runOpenFileDialog</vh></v>
<v t="ekr.20060214141244.71"><vh>runSaveFileDialog</vh></v>
</v>
</v>
<v t="ekr.20060214141244.72"><vh>Improved gc tracing</vh>
<v t="ekr.20060214141244.73"><vh>__init__ (tkTree)</vh>
<v t="ekr.20060214141244.74"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20060214141244.75"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20060214141244.76"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20060214141244.77"><vh>enable/disableGcTrace</vh></v>
<v t="ekr.20060214141244.78"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20060214141244.79"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20060214141244.80"><vh>Garbage Collection</vh>
<v t="ekr.20060214141244.81"><vh>enable_gc_debug</vh></v>
<v t="ekr.20060214141244.82"><vh>clearAllIvars</vh></v>
<v t="ekr.20060214141244.83"><vh>Called from commands</vh>
<v t="ekr.20060214141244.84"><vh>collectGarbage</vh></v>
<v t="ekr.20060214141244.85"><vh>printGcSummary</vh></v>
<v t="ekr.20060214141244.86"><vh>printGcAll</vh></v>
<v t="ekr.20060214141244.87"><vh>printGcObjects</vh>
<v t="ekr.20060214141244.88"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
<v t="ekr.20060214141244.89"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
</v>
<v t="ekr.20060214141244.90"><vh>printGcVerbose</vh></v>
</v>
<v t="ekr.20060214141244.91"><vh>Called from unit tests</vh>
<v t="ekr.20060214141244.92"><vh>printGc</vh>
<v t="ekr.20060214141244.93"><vh>printGcRefs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060214141244.94"><vh>Typing non-ascii keys in the minibuffer</vh>
<v t="ekr.20060214141244.95"><vh>masterKeyHandlerHelper</vh></v>
<v t="ekr.20060214141244.8"><vh>k.strokeFromEvent</vh></v>
</v>
<v t="ekr.20060214141244.96"><vh>Fixed recent bug in Import Derived Files command</vh>
<v t="ekr.20060214141244.97"><vh>importDerivedFile</vh></v>
<v t="ekr.20060214141244.98"><vh>importDerivedFiles</vh>
<v t="ekr.20060214141244.99"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20060214141244.100"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
<v t="ekr.20060214141244.101"><vh>Fixed bug: paste outline lost headline editing</vh>
<v t="ekr.20060214141244.102"><vh>pasteOutline</vh>
<v t="ekr.20060214141244.103"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20060214141244.104"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060214141244.105"><vh>Fixed crasher cutText</vh></v>
</v>
</v>
<v t="ekr.20060226131237"><vh>4.4 x1 projects</vh>
<v t="ekr.20060226131237.1"><vh>Restored some legacy bindings</vh></v>
<v t="ekr.20060226131237.2"><vh>Fixed crasher in Go To Line command</vh>
<v t="ekr.20060226131237.3"><vh>Report</vh></v>
<v t="ekr.20060226131237.4"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20060226131237.5"><vh>Fixed menu problem on Linux</vh>
<v t="ekr.20060226131237.6"><vh>Report</vh></v>
<v t="ekr.20060226131237.7"><vh>tkMenu.activateMenu</vh></v>
</v>
<v t="ekr.20060226131237.8"><vh>Fixed (maybe) problems with unicode characters &amp; caps lock</vh>
<v t="ekr.20060226131237.9"><vh>To do &amp; what I did</vh></v>
<v t="ekr.20060226131237.10"><vh> Birth (keyHandler)</vh>
<v t="ekr.20060226131237.11"><vh> ctor (keyHandler)</vh>
<v t="ekr.20060226131237.12"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20060226131237.13"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20060226131237.14"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.15"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20060226131237.16"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060226131237.17"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
<v t="ekr.20060226131237.18"><vh>canonicalizeShortcut (4.3.3)</vh>
<v t="ekr.20060226131237.19"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20060226131237.20"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20060226131237.21"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20060226131237.22"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.23"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.24"><vh>createMenuEntries</vh>
<v t="ekr.20060226131237.25"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20060226131237.26"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20060226131237.27"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.28"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.29"><vh>Shortcuts (keyHandler)</vh>
<v t="ekr.20060226131237.30"><vh>isPlainKey</vh></v>
<v t="ekr.20060226131237.31"><vh>shortcutFromSetting</vh>
<v t="ekr.20060226131237.32"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060226131237.33"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060226131237.34"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060226131237.35"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060226131237.36"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.37"><vh>k.strokeFromEvent</vh></v>
<v t="ekr.20060226131237.38"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060226131237.39"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20060226131237.40"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060226131237.41"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060226131237.42"><vh>callStateFunction</vh></v>
<v t="ekr.20060226131237.43"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060226131237.44"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060226131237.45"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060226131237.46"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060226131237.47"><vh>getArg</vh>
<v t="ekr.20060226131237.48"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.49"><vh>updateLabel</vh></v>
<v t="ekr.20060226131237.50"><vh>selfInsertCommand</vh>
<v t="ekr.20060226131237.51"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20060226131237.52"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20060226131237.53"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20060226131237.54"><vh>updateTab</vh></v>
</v>
<v t="ekr.20060226131237.55"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20060226131237.56"><vh>callAltXFunction</vh></v>
</v>
</v>
</v>
<v t="ekr.20060226131237.57"><vh>4.4 a6 projects</vh>
<v t="ekr.20060226131237.58"><vh>What I did</vh></v>
<v t="ekr.20060226131237.59"><vh>Added support for trace_minibuffer setting</vh>
<v t="ekr.20060226131237.60"><vh>Label...</vh>
<v t="ekr.20060226131237.61"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20060226131237.62"><vh>getLabel</vh></v>
<v t="ekr.20060226131237.63"><vh>protectLabel</vh></v>
<v t="ekr.20060226131237.64"><vh>resetLabel</vh></v>
<v t="ekr.20060226131237.65"><vh>setLabel</vh></v>
<v t="ekr.20060226131237.66"><vh>extendLabel</vh></v>
<v t="ekr.20060226131237.67"><vh>setLabelBlue</vh></v>
<v t="ekr.20060226131237.68"><vh>setLabelGrey</vh></v>
<v t="ekr.20060226131237.69"><vh>updateLabel</vh></v>
<v t="ekr.20060226131237.70"><vh>getEditableTextRange</vh></v>
</v>
</v>
<v t="ekr.20060226131237.71"><vh>Bind to strokes, not commands</vh>
<v t="ekr.20060226131237.72"><vh>Key report 1</vh></v>
<v t="ekr.20060226131237.73"><vh>Key report  2 (and bug report)</vh></v>
<v t="ekr.20060226131237.74"><vh>Handle num-lock key properly</vh></v>
<v t="ekr.20060226131237.75"><vh>Calls to bind: no change</vh>
<v t="ekr.20060226131237.76"><vh>f.setMinibufferBindings</vh></v>
<v t="ekr.20060226131237.77"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20060226131237.78"><vh>setTabBindings</vh></v>
<v t="ekr.20060226131237.79"><vh>tkTtree.setBindings</vh>
<v t="ekr.20060226131237.80"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
<v t="ekr.20060226131237.81"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.82"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060226131237.83"><vh>createSpellTab</vh>
<v t="ekr.20060226131237.84"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20060226131237.85"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20060226131237.86"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.87"><vh>createBindings (spellTab)</vh></v>
</v>
<v t="ekr.20060226131237.88"><vh>Binding (keyHandler)</vh>
<v t="ekr.20060226131237.89"><vh>bindKey</vh>
<v t="ekr.20060226131237.90"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060226131237.91"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.92"><vh>bindKeyToDict</vh></v>
<v t="ekr.20060226131237.93"><vh>bindOpenWith</vh></v>
<v t="ekr.20060226131237.94"><vh>checkBindings</vh></v>
<v t="ekr.20060226131237.95"><vh>k.completeAllBindings</vh>
<v t="ekr.20060226131237.96"><vh>completeAllBindingsForWidget</vh></v>
</v>
<v t="ekr.20060226131237.97"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20060226131237.98"><vh>addModeCommands</vh></v>
<v t="ekr.20060226131237.99"><vh>initSpecialIvars</vh></v>
<v t="ekr.20060226131237.100"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060226131237.101"><vh>Shortcuts (keyHandler)</vh>
<v t="ekr.20060226131237.102"><vh>isPlainKey</vh></v>
<v t="ekr.20060226131237.103"><vh>shortcutFromSetting</vh>
<v t="ekr.20060226131237.104"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060226131237.105"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060226131237.106"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060226131237.107"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060226131237.108"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.109"><vh>k.strokeFromEvent</vh></v>
<v t="ekr.20060226131237.110"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060226131237.111"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20060226131237.112"><vh>replaceString</vh></v>
<v t="ekr.20060226131237.113"><vh>getArg</vh>
<v t="ekr.20060226131237.114"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.115"><vh>masterMenuHandler</vh></v>
<v t="ekr.20060226131237.116"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060226131237.117"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060226131237.118"><vh>createMenuEntries</vh>
<v t="ekr.20060226131237.119"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20060226131237.120"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20060226131237.121"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060226131237.122"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060226131237.123"><vh>Fixed crasher in k.masterCommand</vh>
<v t="ekr.20060226131237.124"><vh>Report</vh></v>
<v t="ekr.20060226131237.125"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20060226131237.126"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20060226131237.127"><vh>callStateFunction</vh></v>
<v t="ekr.20060226131237.128"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20060226131237.129"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060226131237.130"><vh>g.safeStringCompare &amp; test</vh></v>
</v>
<v t="ekr.20060226131237.131"><vh>Arrow keys no longer destroy UNL line</vh>
<v t="ekr.20060226131237.132"><vh>Report</vh></v>
<v t="ekr.20060226131237.60"><vh>Label...</vh>
<v t="ekr.20060226131237.61"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20060226131237.62"><vh>getLabel</vh></v>
<v t="ekr.20060226131237.63"><vh>protectLabel</vh></v>
<v t="ekr.20060226131237.64"><vh>resetLabel</vh></v>
<v t="ekr.20060226131237.65"><vh>setLabel</vh></v>
<v t="ekr.20060226131237.66"><vh>extendLabel</vh></v>
<v t="ekr.20060226131237.67"><vh>setLabelBlue</vh></v>
<v t="ekr.20060226131237.68"><vh>setLabelGrey</vh></v>
<v t="ekr.20060226131237.69"><vh>updateLabel</vh></v>
<v t="ekr.20060226131237.70"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20060226131237.133"><vh>class statusLineClass</vh>
<v t="ekr.20060226131237.134"><vh> ctor</vh></v>
<v t="ekr.20060226131237.135"><vh>clear</vh></v>
<v t="ekr.20060226131237.136"><vh>enable, disable &amp; isEnabled</vh></v>
<v t="ekr.20060226131237.137"><vh>get</vh></v>
<v t="ekr.20060226131237.138"><vh>getFrame</vh></v>
<v t="ekr.20060226131237.139"><vh>onActivate</vh></v>
<v t="ekr.20060226131237.140"><vh>pack &amp; show</vh></v>
<v t="ekr.20060226131237.141"><vh>put (leoTkinterFrame:statusLineClass)</vh></v>
<v t="ekr.20060226131237.142"><vh>unpack &amp; hide</vh></v>
<v t="ekr.20060226131237.143"><vh>update</vh></v>
</v>
<v t="ekr.20060226131237.144"><vh>tree.endEditLabel</vh></v>
</v>
</v>
<v t="ekr.20060329122352" a="TV"><vh>4.4 a7 projects</vh>
<v t="ekr.20060329122352.1"><vh>Bugs</vh>
<v t="ekr.20060329122352.2"><vh>Fixed binding bug</vh>
<v t="ekr.20060329122352.3"><vh>R</vh></v>
<v t="ekr.20060329122352.4"><vh>k.completeAllBindings &amp; helpers</vh>
<v t="ekr.20060329122352.5"><vh>completeAllBindingsForWidget</vh></v>
<v t="ekr.20060329122352.6"><vh>completeOneBindingForWidget</vh></v>
</v>
<v t="ekr.20060329122352.7"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060329122352.8"><vh>shortcutFromSetting</vh>
<v t="ekr.20060329122352.9"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060329122352.10"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060329122352.11"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060329122352.12"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060329122352.13"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060329122352.14"><vh>Fixed bug in open-find-dialog</vh></v>
<v t="ekr.20060329122352.15"><vh>Ensured dialogs properly get focus</vh></v>
<v t="ekr.20060329122352.16"><vh>Disabled autocompleter in headlines</vh></v>
<v t="ekr.20060329122352.17"><vh>Removed horrible g.app.dialogs hack</vh></v>
<v t="ekr.20060329122352.18"><vh>Fix crasher in plugin</vh></v>
</v>
<v t="ekr.20060329122352.19"><vh>Added typing completion in Find commands</vh>
<v t="ekr.20060329122352.20"><vh>Search classes</vh>
<v t="ekr.20060329122352.21"><vh>class minibufferFind (the findHandler)</vh>
<v t="ekr.20060329122352.22"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20060329122352.23"><vh> Options</vh>
<v t="ekr.20060329122352.24"><vh>setFindScope</vh></v>
<v t="ekr.20060329122352.25"><vh>setOption</vh></v>
<v t="ekr.20060329122352.26"><vh>getOption</vh></v>
<v t="ekr.20060329122352.27"><vh>showFindOptions</vh></v>
<v t="ekr.20060329122352.28"><vh>toggleOption</vh></v>
<v t="ekr.20060329122352.29"><vh>setupChangePattern</vh></v>
<v t="ekr.20060329122352.30"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20060329122352.31"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20060329122352.32"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20060329122352.33"><vh>cloneFindAll</vh></v>
<v t="ekr.20060329122352.34"><vh>findAgain</vh></v>
<v t="ekr.20060329122352.35"><vh>findAll</vh></v>
<v t="ekr.20060329122352.36"><vh>generalChangeHelper</vh></v>
<v t="ekr.20060329122352.37"><vh>generalSearchHelper</vh></v>
<v t="ekr.20060329122352.38"><vh>lastStateHelper</vh></v>
<v t="ekr.20060329122352.39"><vh>replaceString</vh></v>
<v t="ekr.20060329122352.40"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060329122352.41"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060329122352.42"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060329122352.43"><vh>setupArgs</vh></v>
<v t="ekr.20060329122352.44"><vh>stateZeroHelper</vh></v>
<v t="ekr.20060329122352.45"><vh>updateChange/FindList</vh></v>
<v t="ekr.20060329122352.46"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20060329122352.47"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20060329122352.48"><vh>Birth &amp; death</vh>
<v t="ekr.20060329122352.49"><vh>__init__</vh>
<v t="ekr.20060329122352.50"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060329122352.51"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20060329122352.52"><vh>createFrame (findTab)</vh>
<v t="ekr.20060329122352.53"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20060329122352.54"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20060329122352.55"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20060329122352.56"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20060329122352.57"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060329122352.58"><vh>find.init</vh>
<v t="ekr.20060329122352.59"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20060329122352.60"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060329122352.61"><vh>find.update_ivars</vh></v>
<v t="ekr.20060329122352.62"><vh>Callbacks</vh>
<v t="ekr.20060329122352.63"><vh>findButtonCallback</vh></v>
<v t="ekr.20060329122352.64"><vh>hideTab</vh></v>
</v>
<v t="ekr.20060329122352.65"><vh> Top level</vh>
<v t="ekr.20060329122352.66"><vh>findAllCommand</vh></v>
<v t="ekr.20060329122352.67"><vh>findAgainCommand</vh></v>
<v t="ekr.20060329122352.68"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20060329122352.69"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20060329122352.70"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20060329122352.71"><vh>bringToFront</vh></v>
<v t="ekr.20060329122352.72"><vh>selectAllFindText</vh></v>
<v t="ekr.20060329122352.73"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20060329122352.74"><vh>class underlinedTkButton</vh>
<v t="ekr.20060329122352.75"><vh>__init__</vh>
<v t="ekr.20060329122352.76"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20060329122352.77"><vh>bindHotKey</vh></v>
<v t="ekr.20060329122352.78"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20060329122352.79"><vh>class searchCommandsClass</vh>
<v t="ekr.20060329122352.80"><vh> ctor</vh></v>
<v t="ekr.20060329122352.81"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20060329122352.82"><vh>Top-level methods</vh>
<v t="ekr.20060329122352.83"><vh>openFindTab</vh></v>
<v t="ekr.20060329122352.84"><vh>Find Tab commands</vh></v>
<v t="ekr.20060329122352.85"><vh>getHandler</vh></v>
<v t="ekr.20060329122352.86"><vh>Find options wrappers</vh></v>
<v t="ekr.20060329122352.87"><vh>Find wrappers</vh></v>
<v t="ekr.20060329122352.88"><vh>findAgain</vh></v>
</v>
<v t="ekr.20060329122352.89"><vh>incremental search...</vh>
<v t="ekr.20060329122352.90"><vh>startIncremental</vh></v>
<v t="ekr.20060329122352.91"><vh>iSearchStateHandler &amp; helper</vh></v>
<v t="ekr.20060329122352.92"><vh>scolorizer</vh></v>
<v t="ekr.20060329122352.93"><vh>iSearchHelper</vh></v>
<v t="ekr.20060329122352.94"><vh>endSearch</vh></v>
</v>
</v>
</v>
<v t="ekr.20060329122352.95"><vh>Label...</vh>
<v t="ekr.20060329122352.96"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20060329122352.97"><vh>getLabel</vh></v>
<v t="ekr.20060329122352.98"><vh>protectLabel</vh></v>
<v t="ekr.20060329122352.99"><vh>resetLabel</vh></v>
<v t="ekr.20060329122352.100"><vh>setLabel</vh></v>
<v t="ekr.20060329122352.101"><vh>extendLabel</vh></v>
<v t="ekr.20060329122352.102"><vh>setLabelBlue</vh></v>
<v t="ekr.20060329122352.103"><vh>setLabelGrey</vh></v>
<v t="ekr.20060329122352.104"><vh>updateLabel</vh></v>
<v t="ekr.20060329122352.105"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20060329122352.106"><vh>getArg</vh>
<v t="ekr.20060329122352.107"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060329122352.44"><vh>stateZeroHelper</vh></v>
<v t="ekr.20060329122352.108"><vh>computeCompletionList</vh></v>
<v t="ekr.20060329122352.109"><vh>k.doTabCompletion</vh></v>
<v t="ekr.20060329122352.110"><vh>k.doBackSpace</vh></v>
</v>
<v t="ekr.20060329122352.111"><vh>Finished autocompletion</vh>
<v t="ekr.20060329122352.112"><vh>What I did</vh></v>
<v t="ekr.20060329122352.113"><vh>class autoCompleterClass</vh>
<v t="ekr.20060329122352.114"><vh> ctor (autocompleter)</vh>
<v t="ekr.20060329122352.115"><vh>defineClassesDict</vh></v>
<v t="ekr.20060329122352.116"><vh>defineObjectDict</vh></v>
</v>
<v t="ekr.20060329122352.117"><vh>Top level</vh>
<v t="ekr.20060329122352.118"><vh>autoComplete</vh></v>
<v t="ekr.20060329122352.119"><vh>autoCompleteForce</vh></v>
<v t="ekr.20060329122352.120"><vh>enable/disableAutocompleter/Calltips</vh></v>
<v t="ekr.20060329122352.121"><vh>showCalltips</vh></v>
<v t="ekr.20060329122352.122"><vh>showCalltipsForce</vh></v>
<v t="ekr.20060329122352.123"><vh>autoCompleterStateHandler</vh></v>
</v>
<v t="ekr.20060329122352.124"><vh>Helpers</vh>
<v t="ekr.20060329122352.125"><vh>abort &amp; exit</vh></v>
<v t="ekr.20060329122352.126"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20060329122352.127"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20060329122352.128"><vh>calltip</vh>
<v t="ekr.20060329122352.129"><vh>&lt;&lt; try to set s from a Python global function &gt;&gt;</vh></v>
<v t="ekr.20060329122352.130"><vh>&lt;&lt; get s using inspect &gt;&gt;</vh></v>
<v t="ekr.20060329122352.131"><vh>&lt;&lt; remove 'self' from s, but not from args &gt;&gt;</vh></v>
<v t="ekr.20060329122352.132"><vh>&lt;&lt; remove 's' from s *and* args &gt;&gt;</vh></v>
<v t="ekr.20060329122352.133"><vh>&lt;&lt; insert the text and set j1 and j2 &gt;&gt;</vh></v>
<v t="ekr.20060329122352.134"><vh>&lt;&lt; put the status line &gt;&gt;</vh></v>
</v>
<v t="ekr.20060329122352.135"><vh>chain</vh></v>
<v t="ekr.20060329122352.136"><vh>computeCompletionList</vh></v>
<v t="ekr.20060329122352.137"><vh>doBackSpace (autocompleter)</vh></v>
<v t="ekr.20060329122352.138"><vh>doTabCompletion</vh></v>
<v t="ekr.20060329122352.139"><vh>extendSelection</vh></v>
<v t="ekr.20060329122352.140"><vh>findAnchor</vh></v>
<v t="ekr.20060329122352.141"><vh>findCalltipWord</vh></v>
<v t="ekr.20060329122352.142"><vh>finish</vh></v>
<v t="ekr.20060329122352.143"><vh>getAttr and hasAttr</vh></v>
<v t="ekr.20060329122352.144"><vh>getLeadinWord</vh></v>
<v t="ekr.20060329122352.145"><vh>getMembersList</vh></v>
<v t="ekr.20060329122352.146"><vh>info</vh></v>
<v t="ekr.20060329122352.147"><vh>insertNormalChar</vh></v>
<v t="ekr.20060329122352.148"><vh>push, pop, clear, stackNames</vh></v>
<v t="ekr.20060329122352.149"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20060329122352.150"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20060329122352.151"><vh>completeSelf</vh></v>
<v t="ekr.20060329122352.152"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20060329122352.153"><vh>setSelection</vh></v>
<v t="ekr.20060329122352.154"><vh>start</vh></v>
</v>
<v t="ekr.20060329122352.155"><vh>Scanning</vh>
<v t="ekr.20060329122352.156"><vh>initialScan</vh></v>
<v t="ekr.20060329122352.157"><vh>scan</vh></v>
<v t="ekr.20060329122352.158"><vh>definePatterns</vh></v>
<v t="ekr.20060329122352.159"><vh>scanOutline</vh></v>
<v t="ekr.20060329122352.160"><vh>scanForCallTip</vh></v>
<v t="ekr.20060329122352.161"><vh>scanForAutoCompleter</vh>
<v t="ekr.20060329122352.162"><vh>makeAutocompletionList</vh>
<v t="ekr.20060329122352.163"><vh>reverseFindWhitespace</vh></v>
<v t="ekr.20060329122352.164"><vh>getCleanString</vh></v>
</v>
</v>
</v>
<v t="ekr.20060329122352.165"><vh>Proxy classes and objects</vh>
<v t="ekr.20060329122352.166"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20060329122352.167"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20060329122352.168"><vh>class forgivingParserClass</vh>
<v t="ekr.20060329122352.169"><vh>ctor (forgivingParserClass)</vh></v>
<v t="ekr.20060329122352.170"><vh>parse</vh></v>
<v t="ekr.20060329122352.171"><vh>forgivingParser</vh></v>
<v t="ekr.20060329122352.172"><vh>computeErrorNode</vh></v>
<v t="ekr.20060329122352.173"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20060329122352.174"><vh>class classScannerClass</vh>
<v t="ekr.20060329122352.175"><vh>ctor</vh></v>
<v t="ekr.20060329122352.176"><vh>scan</vh></v>
<v t="ekr.20060329122352.177"><vh>findParentClass</vh></v>
<v t="ekr.20060329122352.178"><vh>findClass &amp; helpers</vh>
<v t="ekr.20060329122352.179"><vh>endsDoc</vh></v>
<v t="ekr.20060329122352.180"><vh>startsClass</vh></v>
<v t="ekr.20060329122352.181"><vh>startsDoc</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060329122352.182"><vh>aproposAutocompletion</vh>
<v t="ekr.20060329122352.183"><vh>test_aproposAutocompletion</vh></v>
</v>
<v t="ekr.20060329122352.184"><vh>made __builtin__reduce( work</vh>
<v t="ekr.20060329122352.128"><vh>calltip</vh>
<v t="ekr.20060329122352.129"><vh>&lt;&lt; try to set s from a Python global function &gt;&gt;</vh></v>
<v t="ekr.20060329122352.130"><vh>&lt;&lt; get s using inspect &gt;&gt;</vh></v>
<v t="ekr.20060329122352.131"><vh>&lt;&lt; remove 'self' from s, but not from args &gt;&gt;</vh></v>
<v t="ekr.20060329122352.132"><vh>&lt;&lt; remove 's' from s *and* args &gt;&gt;</vh></v>
<v t="ekr.20060329122352.133"><vh>&lt;&lt; insert the text and set j1 and j2 &gt;&gt;</vh></v>
<v t="ekr.20060329122352.134"><vh>&lt;&lt; put the status line &gt;&gt;</vh></v>
</v>
<v t="ekr.20060329122352.144"><vh>getLeadinWord</vh></v>
</v>
<v t="ekr.20060329122352.185"><vh>Applied rst3 patch from Kent Tenney</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040604090913"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")</t>
<t tx="ekr.20031218072017.843">def OnPaste (self,event=None):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    # Activate the body key handler by hand.
    frame.body.forceFullRecolor()
    frame.body.onBodyWillChange(v,"Paste")
    
def OnPasteFromMenu (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode()

    w = self.getFocus()
    w.event_generate(g.virtual_event_name("Paste"))
    
    if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
        frame.tree.onHeadChanged(v)
</t>
<t tx="ekr.20031218072017.1321">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if p != c.currentPosition(): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            &lt;&lt; Do auto indent &gt;&gt;
        elif ch == '\t' and tab_width &lt; 0:
            &lt;&lt; convert tab to blanks &gt;&gt;
        elif ch in (chr(8)) and tab_width &lt; 0:
            &lt;&lt; handle backspace with negative tab_width &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
</t>
<t tx="ekr.20031218072017.1322"># 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20031218072017.1323">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20031218072017.1324"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18</t>
<t tx="ekr.20031218072017.1325"># Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20031218072017.1326">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"</t>
<t tx="ekr.20031218072017.1327">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20031218072017.1328">redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20031218072017.1331"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)</t>
<t tx="ekr.20031218072017.1924"></t>
<t tx="ekr.20031218072017.1925"></t>
<t tx="ekr.20031218072017.1926">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2257820
By: wtrenker

When I edit a Headline and select the existing text, then I paste in some other
text, the original selected text remains instead of being overwritten by the
newly pasted text.

Here's a simple, repeatable example.  Start a new Leo file.  As expected, the
new file is initialized with a single node with a headline containing the text
"NewHeadline".  The text is pre-selected, ready to edit.  Now do a copy and
then paste.  The text will now read "NewHeadlineNewHeadline".  The original
text was not overwritten.

Here's my configuration:

Leo Log Window...
Leo 4.0.3, build  1.99 , October 25, 2003
Python 2.3.2, Tk 8.3.3

Linux 2.4.19; libc.so.6 2.2.5; gcc 2.95.3
KDE: 3.0.0 Qt: 3.0.4
GNU ld version 2.13.90.0.4 20020814
GNU Make 3.80
pkg-config 0.14.0
Python 2.3.2 (#1, Oct 27 2003, 10:19:56) [GCC 2.95.3 20010315 (release)]

Regards,
Bill
</t>
<t tx="ekr.20040801060323">@ This file contains seldom-used project nodes.

I created this file by copying project nodes from leoPy.leo and pasting them
with the Paste Retaining Clones command.</t>
<t tx="ekr.20050526080309">d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width &lt; 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width &lt; 0:
    &lt;&lt; handle backspace with negative tab_width &gt;&gt;</t>
<t tx="ekr.20050526081024">w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050526081024.1"># Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20060106104442"></t>
<t tx="ekr.20060106104442.1"></t>
<t tx="ekr.20060106104442.2"></t>
<t tx="ekr.20060106104442.3"></t>
<t tx="ekr.20060106104442.4"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;</t>
<t tx="ekr.20060106104442.5">if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

# New in 4.4b1: Restore the focus to a standard place.
frame = self.c.frame
focus_widget = g.app.gui.get_focus(frame)
name = g.app.gui.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
frame.widgetWantsFocus(focus_widget)
</t>
<t tx="ekr.20060106104442.6">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="ekr.20060106104442.7"></t>
<t tx="ekr.20060106104442.8">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script</t>
<t tx="ekr.20060106104442.9">def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)</t>
<t tx="ekr.20060106104442.10"></t>
<t tx="ekr.20060106104442.11">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3464874
By: davidmcnab

* The 'goto line number' dialog pops up without the text field active, so I'm
forced into a Compulsory Mouse Click to activate the field before I can type
in the line number (I'm one who regards unnecessary Compulsory Mouse Clicks as bugs).</t>
<t tx="ekr.20060106104442.12">def createFrame (self,message):
    
    """Create the frame for a number dialog."""
    
    if g.app.unitTesting: return
    
    f = self.frame
    
    lab = Tk.Label(f,text=message)
    lab.pack(pady=10,side="left")
    
    self.number_entry = t = Tk.Entry(f,width=20)
    t.pack(side="left")
    
    g.app.gui.set_focus(self.c,t)</t>
<t tx="ekr.20060106104442.13">@

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headling, and ch is always '\r', regardless of
platform.</t>
<t tx="ekr.20060106104442.14">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3466412
By: ktenney

&gt;Use the read_only_nodes plugin. 

It has a great feature list, but I can't get it to
update after the file changes on the filesystem.

I then looked at at_view.py, and the @view node
plugin. (which I worked on way back when :-])

It also doesn't work.
I put a g.es(..) at the top of the icondclick2 method which is registered in
the onCreate method
of at_view.py;

leoPlugins.registerHandler("icondclick2", myView.icondclick2)

It seems that the method does not get called
when the icon is doubleclicked.

Could this behaviour be related to recent changes
in Leo?
</t>
<t tx="ekr.20060106104442.15"></t>
<t tx="ekr.20060106104442.16">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060106104442.17">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060106104442.18"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20060106104442.19"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.20"></t>
<t tx="ekr.20060106104442.21">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3462294
By: nobody

apparently the bodykey hooks are no longer used
is why trace_keys plugin doesn't work.
in leoKeys.py I see this trace can be turned on:
.   if c.config.getBool('trace_masterCommand'):</t>
<t tx="ekr.20060106104442.22">def handleDefaultChar(self,event):
    
    c = self.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)

    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = self.unboundKeyAction
        if action in ('insert','replace'):
            c.editCommands.selfInsertCommand(event,action=action)
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060106104442.23">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'replace':   w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20060106104442.24">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20060106104442.25">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20060106104442.26"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20060106104442.27">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20060106104442.28"></t>
<t tx="ekr.20060106104442.29">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3467558
By: ktenney

Current CVS, W2K

I open a small Leo file, and from File-&gt;Open, select
..\src\LeoPyRef.py. the log pane shows;

----- error reading @file: ../doc/leoToDo.txt
Ignoring @-node sentinel. Expecting @-all

At this point Leo locks up tight, must kill process.

What I did:

** atFile.readError delete's root's entire subtree.
** atFile.read only warns about unvisited node if there is no error.
</t>
<t tx="ekr.20060106104442.30">def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
        
    # g.trace(self.root,g.callers())
    
    self.error(message)
    
    # Bug fix: 12/10/05: Delete all of root's tree.
    self.root.v.t._firstChild = None
    
    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20060106104442.31">def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1

    # g.trace('errors',self.errors)</t>
<t tx="ekr.20060106104442.32">def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;</t>
<t tx="ekr.20060106104442.33">try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s</t>
<t tx="ekr.20060106104442.34">def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20060106104442.35"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20060106104442.36">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20060106104442.37">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20060106104442.38">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20060106104442.39">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20060106104442.40"></t>
<t tx="ekr.20060106104442.41">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)</t>
<t tx="ekr.20060106104442.42">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20060106104442.43">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20060106104442.44">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="ekr.20060106104442.45">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)</t>
<t tx="ekr.20060106104442.46"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="ekr.20060106104442.47"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20060106104442.48">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20060106104442.49">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)</t>
<t tx="ekr.20060106104442.50"></t>
<t tx="ekr.20060106104442.51">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)</t>
<t tx="ekr.20060106104442.52">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True</t>
<t tx="ekr.20060106104442.53">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20060106104442.54">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="ekr.20060106104442.55">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)</t>
<t tx="ekr.20060106104442.56">if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)</t>
<t tx="ekr.20060106104442.57"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20060106104442.58">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)</t>
<t tx="ekr.20060106104442.59">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    </t>
<t tx="ekr.20060106104442.60"></t>
<t tx="ekr.20060106104442.61">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20060106104442.62">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)</t>
<t tx="ekr.20060106104442.63">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="ekr.20060106104442.64">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20060106104442.65">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20060106104442.66">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20060106104442.67"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="ekr.20060106104442.68">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="ekr.20060106104442.69">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20060106104442.70">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20060106104442.71">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20060106104442.72">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20060106104442.73">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20060106104442.74">def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; c = p.c ; dirtyVnodeList = []

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList</t>
<t tx="ekr.20060106104442.75"></t>
<t tx="ekr.20060106104442.76">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3461068
By: vpe

1) Strange behaviour after pasting in headlines:
Start editing a headline in outline pane. Let's say it's 'Settings and
buttons'.
Select all text and copy (ctrl+c).
Place cursor at the end and paste (ctrl+v). What I see is 'Settings and
buttonsSetti'. That is text area does not expand to accomodate new text length.
And I cannot move beyond that point.
If I move to another headline I see that pasting was done correctly. 

2) (done) I always make these changes without any problems:
Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt;Config
&amp; Measuring...--&gt;headWidth &amp; widthInPixels
return max(self.minimum_headline_width,5 + len(s))  ##change to 1

Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt; Birth...
(tkTree)--&gt;__init__--&gt;&lt;&lt; define drawing constants &gt;&gt;
self.minimum_headline_width = 20 # In characters. ##change to 2


Leo 4.4 alpha 4, build  1.346 , December 5, 2005
Python 2.4.2, Tk 8.4.7, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4    &lt;--- nice!
</t>
<t tx="ekr.20060106104442.77"></t>
<t tx="ekr.20060106104442.78">def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20060106104442.79">def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20060106104442.80">def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060106104442.81">@nocolor

The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.</t>
<t tx="ekr.20060106104442.82"></t>
<t tx="ekr.20060106104442.83">@nocolor

I've just investigated how Leo handles pane settings, and I believe all is
working as intended. This is somewhat confusing, but there has been no change in
this code for a long time: it has nothing whatever to do with the 4.4 code
base.

The so-called 'primary' ratio is the ratio between the body pane and the pane
containing the other two panes. The so-called secondary ratio is the ratio
between sizes of the log pane and the outline pane.

The thing to keep in mind is that Leo saves *only* the primary ratio in .leo
files. Leo does not save the so-called 'secondary' ratio in .leo files, because
doing so would change Leo's file format.

Because Leo **does** save the primary ratio in .leo files, Leo will open a file
with the same primary ratio that you had when you last saved the file.

Because Leo does **not** save the secondary ratio in the .leo file Leo
determines the relative sizes of the log and outline panes from settings in
leoSettings.leo. One of the two settings is used:

- initial_horizontal_secondary_ratio or

- initial_vertical_secondary_ratio

Which one is used depends on the initial_splitter_orientation setting.

**Important** If you change these settings you must restart Leo for them to take effect.

I have been able to set the secondary ratio as I please from leoSettings.leo,
and have observed that Leo properly saves and restores the primary ratio in .leo
files.

In short, everything works as it should.</t>
<t tx="ekr.20060106104442.84">def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2</t>
<t tx="ekr.20060106104442.85"># From Brian re Read @file nodes w/o creating copy of root node</t>
<t tx="ekr.20060106104442.86">@nocolor

- self._forcedGnxPositionList = [] in ctor.

- </t>
<t tx="ekr.20060106104442.87">def __init__(self,c):

    # Note: Pychecker complains if we assign to at.x instead of self.x.
    
    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.
    # New in Leo 4.4a5: For createThinChild4 (LeoUser).
    self._forcedGnxPositionList = []
        # Must be here, putting it in initReadIvars doesn't work.

    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</t>
<t tx="ekr.20060106104442.88">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20060106104442.89">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20060106104442.90">def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    leoBaseAtFile.__init__( self )
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self._forcedGnxPositionList = [] #This has to be here, puttin it in initReadIvars renders it useless

    c.checksums = {}
    self.md5 = None
    @others</t>
<t tx="ekr.20060106104442.91">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20060106104442.92">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove( last )
        
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.


    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        child.vid = gnxString
        #print 'gnxString is %s' % gnxString
        leoNodes.vid_vnode[ gnxString ] = child
        leoNodes.tid_tnode[ gnxString ] = t
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20060106104442.93"></t>
<t tx="ekr.20060106104442.94">def onClickBoxClick (self,event):
    
    c = self.c ; p = self.eventToPosition(event)

    c.beginUpdate()
    try:
	    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
	        if p.isExpanded(): p.contract()
	        else:              p.expand()
	        self.active = True
	        self.select(p)
	        if c.frame.findPanel:
	            c.frame.findPanel.handleUserClick(p)
	        if self.stayInTree:
	            c.frame.treeWantsFocus()
	        else:
	            c.frame.bodyWantsFocus()
	    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060106104442.95">@

This handles the root node properly so that Leo draws no duplicate node. The
code is from LeoUser; thanks Brian.

I also fixed a recent bugs: the screen was not being redrawn afterwards.</t>
<t tx="ekr.20060106104442.96">def forceGnxOnPosition (self,p):
    
    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20060106104442.97">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060106104442.98">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20060106104442.99">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20060106104442.100"></t>
<t tx="ekr.20060106104442.101"></t>
<t tx="ekr.20060106104442.102"></t>
<t tx="ekr.20060106104442.103">@
The change was logical, but it caused problems.

The new 'insert' keyword arg must have the value 'sel.end' for compatibility with old code.</t>
<t tx="ekr.20060106104442.104">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20060106104442.105"></t>
<t tx="ekr.20060106104442.106">def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-up':                            self.scrollUp,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20060106104442.107"></t>
<t tx="ekr.20060106104442.108"></t>
<t tx="ekr.20060106104442.109">def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=True)
    spot = w.index(spot) # Capture initial value.
    ins = w.index('insert')
    w.mark_set('insert',spot)
    if extend or self.extendMode:
        if w.compare(spot,'&lt;=',i):
            g.app.gui.setTextSelection (w,spot,j,insert=None)
        else:
            g.app.gui.setTextSelection (w,i,spot,insert=None)
    w.see(spot)</t>
<t tx="ekr.20060106104442.110">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.frame.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20060106104442.111">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.112">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.113">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    ins = w.index('insert')
    sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060106104442.114">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060106104442.115">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060106104442.116">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20060106104442.117">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060106104442.118">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20060106104442.119">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20060106104442.120">def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=True)</t>
<t tx="ekr.20060106104442.121">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.122">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.123">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20060106104442.124">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20060106104442.125"></t>
<t tx="ekr.20060106104442.126"></t>
<t tx="ekr.20060106104442.127"></t>
<t tx="ekr.20060106104442.128">@nocolor

- As before, tree.select always sets tree.revertHeadline.  This is the revert point.

- endEditLabel now simply unselects the widget.  It has *no* responsibility for keeping the headline in synch with p.headString.  This is a major advance in reliability.

- tree.onHeadChanged sets changed = s != oldRevert.  This is more reliable than previously.</t>
<t tx="ekr.20060106104442.129"></t>
<t tx="ekr.20060106104442.130">def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.endEditing() # Required.
        g.app.setLog(frame.log,"OnActivateBody")
        w = g.app.gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        frame.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'</t>
<t tx="ekr.20060106104442.131">def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.frame.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.132">def renameBuffer (self,event):
    
    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)
    
def renameBufferFinisher1 (self,name):
    
    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)
    
def renameBufferFinisher2 (self,name):
    
    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.frame.tree.editLabel(p)
        w = p.edit_widget()
        if w:
            w.delete("1.0","end")
            w.insert("1.0",name)
            c.endEditing()
            ### c.frame.tree.onHeadChanged(p,'rename-buffer %s' % p.headString())</t>
<t tx="ekr.20060106104442.133">@nocolor

Bug 1: OnActivateBody *must* call onHeadChanged: select is not always called!

But 2: c.endEditing and tree.endEditLabel **must** call tree.onHeadChanged.</t>
<t tx="ekr.20060106104442.134"></t>
<t tx="ekr.20060106104442.135">def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)</t>
<t tx="ekr.20060106104442.136">def editLabel (self,p):
    
    """Start editing p's headline."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p) # That is, self._editPosition = p
    
    # g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget!'))

    if p and p.edit_widget():
        self.setEditLabelState(p) # Sets the focus immediately.
        self.frame.headlineWantsFocus(p) # Make sure the focus sticks.</t>
<t tx="ekr.20060106104442.137">@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)</t>
<t tx="ekr.20060106104442.138"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20060106104442.139"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20060106104442.140">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20060106104442.141"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20060106104442.142">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.143"></t>
<t tx="ekr.20060106104442.144">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20060106104442.145">def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20060106104442.146">def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20060106104442.147">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.148">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.149">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060106104442.150"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20060106104442.151">def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
	    for p in p.parents_iter():
	        if not p.isExpanded():
	            p.expand()
	            redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag</t>
<t tx="ekr.20060106104442.152"></t>
<t tx="ekr.20060106104442.153"># Ends the editing in the outline.

def endEditing(self):

    self.frame.tree.endEditLabel()
</t>
<t tx="ekr.20060106104442.154"></t>
<t tx="ekr.20060106104442.155">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20060106104442.156">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20060106104442.157">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20060106104442.158">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20060106104442.159"></t>
<t tx="ekr.20060106104442.160">def toggleAngleBrackets (self):
    
    c = self ; v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return
        
    c.endEditing()

    s = v.headString().strip()
    if (s[0:2] == "&lt;&lt;"
        or s[-2:] == "&gt;&gt;"): # Must be on separate line.
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    
    c.frame.tree.editLabel(v)
    w = v.edit_widget()
    if w:
        w.delete("1.0","end")
        w.insert("1.0",s)
        c.frame.tree.onHeadChanged(v,'Toggle Angle Brackets')</t>
<t tx="ekr.20060106104442.161"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    gui.replaceSelectionRangeWithText(t,          start,end,self.change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,self.change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.frame.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
	    if self.mark_changes:
	        p.setMarked()
	    if self.in_headline:
	        c.frame.tree.onHeadChanged(p,'Change')
	    else:
	        c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
</t>
<t tx="ekr.20060106104442.162">def insertHeadlineTime (self):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = p.edit_widget()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')</t>
<t tx="ekr.20060106104442.163"></t>
<t tx="ekr.20060106104442.164"></t>
<t tx="ekr.20060106104442.165">@nocolor

To do:

- Test abortEditLabelCommand.

- c.redraw() redraws conditionally.
- Create c.xxx methods that call the corresponding c.frame.tree methods.

** Find is not selecting headlines properly.
- Test drags.

What I did:

- Made c.begin/endUpdate and tree.begin/endUpdate functional again.
- Created a script to add c.begin/endUpdate().
- Removed redraw_flag from deleteOutline.
- Tested undo/redo delete node.
- Removed redraw_flag from insertHeadline.
- Removed redraw_flag from onBodyChanged.
- c.redraw_now() redraws undconditionally: it is used seldom.
- Replaced c.redraw_now by c.redraw or c.begin/endUpdate.
- Removed redraw_flag from c.selectPosition, tree.select, tree.onHeadChanged, body.onBodyChanged.

</t>
<t tx="ekr.20060106104442.166"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    # g.trace(removeTrailing,repr(ch),repr(newText))
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20060106104442.167">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20060106104442.168">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20060106104442.169">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True</t>
<t tx="ekr.20060106104442.170"></t>
<t tx="ekr.20060106104442.171">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20060106104442.172">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20060106104442.173">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20060106104442.174">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20060106104442.175">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20060106104442.176"></t>
<t tx="ekr.20060106104442.177">def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount &lt;= 0:
        if flag:
            self.redraw_now()
        if self.updateCount &lt; 0:
            g.trace("Can't happen: negative updateCount")</t>
<t tx="ekr.20060106104442.178"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20060106104442.179">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20060106104442.180">def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount</t>
<t tx="ekr.20060106104442.181"></t>
<t tx="ekr.20060106104442.182">def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId</t>
<t tx="ekr.20060106104442.183">def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20060106104442.184">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060106104442.185">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20060106104442.186">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20060106104442.187">def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
</t>
<t tx="ekr.20060106104442.188">def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20060106104442.189">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20060106104442.190">def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        &lt;&lt; highlight text widget on enter events &gt;&gt;
   
    self.configureTextState(p)

    return self.line_height</t>
<t tx="ekr.20060106104442.191"># t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060106104442.192">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20060106104442.193">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20060106104442.194">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20060106104442.195">pass</t>
<t tx="ekr.20060106104442.196">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20060106104442.197">pass</t>
<t tx="ekr.20060106104442.198">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20060106104442.199">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20060106104442.200"></t>
<t tx="ekr.20060106104442.201">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20060106104442.202">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20060106104442.203">def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.</t>
<t tx="ekr.20060106104442.204">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20060106104442.205">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20060106104442.206">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20060106104442.207">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20060106104442.208">u = c.undoer ; w = c.frame.body.bodyCtrl

s1 = '''\
    c.beginUpdate()
    try:'''
s2 = '''\
    finally:
        c.endUpdate()'''

b = u.beforeChangeNodeContents(p)

i, j = g.app.gui.getTextSelection(w)
if i != j:
    s = w.get(i,j)
    s = ''.join(['\t'+line for line in g.splitLines(s)])
    w.delete(i,j)
    w.insert(i,s1+'\n'+s+'\n'+s2)
else:
    w.insert(i,s1+'\n\t\t\n'+s2)

c.recolor()
u.afterChangeNodeContents(p,'add-begin/endUpdate',b)</t>
<t tx="ekr.20060106104442.209">No change was actually needed, just new bindings.

What I did:
    
- fixed a bug in copyBindingsToWidget
- textBindingsRedirectionCallback now returns 'break', not None.</t>
<t tx="ekr.20060106104442.210">@nocolor

Key bindings

Leo must have commands to do what Tk text widgets do for all their standard bindings.  This is the only way I know of to allow users to choose different bindings for those actions.

Therefore, Leo should pass *no* key events to Tk for 'default' handling.  That is, all of Leo's key handlers will return 'break', not None.  In particular, all text widgets must have something like selfInsertCommand so they can handle ordinary keystrokes.

Typing in headlines *still* does not always stick.  The present event handlers for headlines have way too many paths through them.  The problems are caused in large part by the abort-edit-headline command: it requires state info.  I may add a beginEditHeadline command that will remember the state.  This will allow Leo to save the headline text on *every* keystroke, rather than only at the end.  This is *much* safer than trying to ensure that endEditHeadline gets called on every path.  The new endEditHeadline will have no responsibility for state except to clear the info set by beginEditHeadline.  Nothing much bad will ever happen if endEditHeadline doesn't get called once in a while.

I hope to get all the necessary bindings and commands done this week.

Undo

Undo is well defined only for headlines and body text.  There is little or no use, alas, for event.widget in leoEditCommands.py.  Brian's suggestion of having beginUndo/endUndo markers makes a lot of sense: such markers simplify the code and hide implementation and policy details that should be hidden.

Focus

Getting focus exactly right is crucial: some of the present commands in leoEditCommands.py don't work if they are invoked by their long name rather than from a keystroke.

In short, the combination of bindings, undo and focus creates a lot of problems that must be handled with extreme care.  It's frustrating to rewrite essentially every line of Brian's temacs code, but I believe it must be done.

And we are not done yet.  Leo creates an environment different from Emacs:  incremental search must be expanded to move from node to node, the notion of the 'mark' must be generalized (in some, but not all situations), etc.  Sometimes, though, the generalization is also a simplification: as I have said before, Leo's nodes can and should be treated as exactly synonymous with Emacs's buffers.

Edward
</t>
<t tx="ekr.20060106104442.211"></t>
<t tx="ekr.20060106104442.212"></t>
<t tx="ekr.20060106104442.213">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3464605
leouser

You really need to think about using Ctrl-Space for starting selection mode.
Its a wonderful thing.  Once in selection mode you just move around with your
arrows and things get selected.  Or if you want to move quickly you can do stuff
like Ctrl-a or Ctrl-e or Ctrl-&lt; or Ctrl-&gt;.  Combining selection mode and fast
movement keystrokes is good...</t>
<t tx="ekr.20060106104442.214"></t>
<t tx="ekr.20060106104442.215"></t>
<t tx="ekr.20060106104442.216"></t>
<t tx="ekr.20060106104442.217">make the default bindings work differently when editing
the headline as opposed to when traversing the tree with the arrow keys.</t>
<t tx="ekr.20060106104442.218"></t>
<t tx="ekr.20060106104442.219">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20060106104442.220">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20060106104442.221">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20060106104442.222"></t>
<t tx="ekr.20060106104442.223"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20060106104442.224">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20060106104442.225"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20060106104442.226"></t>
<t tx="ekr.20060106104442.227">def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()</t>
<t tx="ekr.20060106104442.228">def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # I am not happy with this, but it seems preferable to trying to figure out
            # all the places where the code must call update()
            
            # New in 4.4b1: the place to call update is *after* log pane operations.
            w.update() 

        w.focus_set()</t>
<t tx="ekr.20060106104442.229">def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus</t>
<t tx="ekr.20060106104442.230"></t>
<t tx="ekr.20060106104442.231">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060106104442.232"></t>
<t tx="ekr.20060106104442.233">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20060106104442.234">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20060106104442.235"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20060106104442.236"></t>
<t tx="ekr.20060106104442.237">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20060106104442.238">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20060106104442.239"></t>
<t tx="ekr.20060106104442.240">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20060106104442.241">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20060106104442.242">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20060106104442.243">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20060106104442.244">def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)</t>
<t tx="ekr.20060106104442.245">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20060106104442.246"></t>
<t tx="ekr.20060106104442.247">def getInsertPoint(self,t):

    return t.index("insert")</t>
<t tx="ekr.20060106104442.248">def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)</t>
<t tx="ekr.20060106104442.249"></t>
<t tx="ekr.20060106104442.250">def getSelectionRange (self,t):

    return t.tag_ranges("sel")</t>
<t tx="ekr.20060106104442.251">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return None</t>
<t tx="ekr.20060106104442.252">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine instead!!
    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20060106104442.253">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20060106104442.254">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20060106104442.255"></t>
<t tx="ekr.20060106104442.256">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.257">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.258">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.259">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.260">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20060106104442.261">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20060106104442.262"></t>
<t tx="ekr.20060106104442.263">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20060106104442.264">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20060106104442.265">class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others</t>
<t tx="ekr.20060106104442.266"></t>
<t tx="ekr.20060106104442.267">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20060106104442.268"></t>
<t tx="ekr.20060106104442.269">def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up')</t>
<t tx="ekr.20060106104442.270">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')

    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
         self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.271">def capitalizeHelper (self,event,which):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
</t>
<t tx="ekr.20060106104442.272"></t>
<t tx="ekr.20060106104442.273">def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    &lt;&lt; define colors &gt;&gt;
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
</t>
<t tx="ekr.20060106104442.274">colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )</t>
<t tx="ekr.20060106104442.275">def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;</t>
<t tx="ekr.20060106104442.276">colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)</t>
<t tx="ekr.20060106104442.277">def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)</t>
<t tx="ekr.20060106104442.278">def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)</t>
<t tx="ekr.20060106104442.279">def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    &lt;&lt; create the frames &gt;&gt;
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    &lt;&lt; create the sample text widget &gt;&gt;
    &lt;&lt; create and bind the callbacks &gt;&gt;</t>
<t tx="ekr.20060106104442.280">f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')</t>
<t tx="ekr.20060106104442.281">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.282">Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20060106104442.283">weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.284">slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20060106104442.285">sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)</t>
<t tx="ekr.20060106104442.286">def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('&lt;Return&gt;',fontCallback)</t>
<t tx="ekr.20060106104442.287">def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20060106104442.288">def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','&lt;none&gt;',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)</t>
<t tx="ekr.20060106104442.289"></t>
<t tx="ekr.20060106104442.290">def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2</t>
<t tx="ekr.20060106104442.291">def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 &lt; c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 &gt;= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')</t>
<t tx="ekr.20060106104442.292"></t>
<t tx="ekr.20060106104442.293">def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
</t>
<t tx="ekr.20060106104442.294">def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)</t>
<t tx="ekr.20060106104442.295">def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)</t>
<t tx="ekr.20060106104442.296"></t>
<t tx="ekr.20060106104442.297">def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)</t>
<t tx="ekr.20060106104442.298">def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)</t>
<t tx="ekr.20060106104442.299">def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)</t>
<t tx="ekr.20060106104442.300"></t>
<t tx="ekr.20060106104442.301">def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus()

def focusToLog (self,event):

    self.c.frame.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.frame.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.frame.treeWantsFocus()</t>
<t tx="ekr.20060106104442.302">def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i &gt;= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane)</t>
<t tx="ekr.20060106104442.303">@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others</t>
<t tx="ekr.20060106104442.304">def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) &gt;= self.fillColumn: return

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)</t>
<t tx="ekr.20060106104442.305">def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()</t>
<t tx="ekr.20060106104442.306">def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex &lt;= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) &gt;= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1</t>
<t tx="ekr.20060106104442.307">def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt</t>
<t tx="ekr.20060106104442.308">def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt</t>
<t tx="ekr.20060106104442.309"></t>
<t tx="ekr.20060106104442.310">def gotoCharacter (self,event):

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060106104442.311">def gotoLine (self,event):

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20060106104442.312"></t>
<t tx="ekr.20060106104442.313">def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)</t>
<t tx="ekr.20060106104442.314">def deleteIndentation (self,event):

    k = self.k ; w = event.widget

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.315">def insertNewLineIndent (self,event):

    w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = self.getWSString(txt)
    i = w.index('insert')
    w.insert(i,txt)
    w.mark_set('insert',i)
    self.insertNewLine(event)
</t>
<t tx="ekr.20060106104442.316">def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'Indent Relative'
    
    k = self.k ; w = event.widget
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 &lt; 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) &lt;= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.317"></t>
<t tx="ekr.20060106104442.318">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return
    
    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
    # g.trace(i,j)

    if name.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=changed)
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20060106104442.319">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20060106104442.320">def deleteNextChar (self,event):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed)</t>
<t tx="ekr.20060106104442.321">def deleteSpaces (self,event,insertspace=False):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)</t>
<t tx="ekr.20060106104442.322">def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060106104442.323">def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
</t>
<t tx="ekr.20060106104442.324">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)</t>
<t tx="ekr.20060106104442.325">def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')</t>
<t tx="ekr.20060106104442.326"></t>
<t tx="ekr.20060106104442.327">def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))</t>
<t tx="ekr.20060106104442.328">def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))</t>
<t tx="ekr.20060106104442.329">def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)</t>
<t tx="ekr.20060106104442.330">def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)</t>
<t tx="ekr.20060106104442.331"></t>
<t tx="ekr.20060106104442.332">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg</t>
<t tx="ekr.20060106104442.333">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg</t>
<t tx="ekr.20060106104442.334">def linesHelper (self,event,pattern,which):

    k = self.k ; w = event.widget
   
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)</t>
<t tx="ekr.20060106104442.335">def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart &lt; 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom</t>
<t tx="ekr.20060106104442.336">@others</t>
<t tx="ekr.20060106104442.337">def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060106104442.338">def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )</t>
<t tx="ekr.20060106104442.339">def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','&gt;',s2):
            break
        self.fillParagraph(event)</t>
<t tx="ekr.20060106104442.340">def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)</t>
<t tx="ekr.20060106104442.341">def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.rstrip().lstrip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20060106104442.342">def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.lstrip().rstrip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break</t>
<t tx="ekr.20060106104442.343">def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)</t>
<t tx="ekr.20060106104442.344">@others</t>
<t tx="ekr.20060106104442.345">def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('&lt;Right&gt;',extend,'+')
    w.bind('&lt;Left&gt;',truncate,'+')
    w.bind('&lt;Up&gt;',up,'+')
    w.bind('&lt;Down&gt;',down,'+')

    return 'break'</t>
<t tx="ekr.20060106104442.346">def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'</t>
<t tx="ekr.20060106104442.347">def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

</t>
<t tx="ekr.20060106104442.348">def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'</t>
<t tx="ekr.20060106104442.349">def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'</t>
<t tx="ekr.20060106104442.350">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20060106104442.351">def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)</t>
<t tx="ekr.20060106104442.352">def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))</t>
<t tx="ekr.20060106104442.353">def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()</t>
<t tx="ekr.20060106104442.354">def downCaseRegion (self,event):
    self.caseHelper(event,'low')

def upCaseRegion (self,event):
    self.caseHelper(event,'up')

def caseHelper (self,event,way):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)

    self.removeRKeys(w)</t>
<t tx="ekr.20060106104442.355"></t>
<t tx="ekr.20060106104442.356">def replaceString (self,event):

    k = self.k ; state = k.getState('replace-string')
    prompt = 'Replace ' + g.choose(self._useRegex,'Regex','String')

    if state == 0:
        self.widget = event.widget
        self._sString = self._rpString = ''
        s = '%s: ' % prompt
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',1,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',2,self.replaceString)
    elif state == 2:
        k.clearState()
        self._rpString = k.arg ; w = self.widget
        &lt;&lt; do the replace &gt;&gt;
        k.setLabelGrey('Replaced %s occurance%s' % (count,g.choose(count==1,'','s')))
        self._useRegex = False</t>
<t tx="ekr.20060106104442.357"># g.es('%s %s by %s' % (prompt,repr(self._sString),repr(self._rpString)),color='blue')
i = 'insert' ; end = 'end' ; count = 0
if w.tag_ranges('sel'):
    i = w.index('sel.first')
    end = w.index('sel.last')
if self._useRegex:
    txt = w.get(i,end)
    try:
        pattern = re.compile(self._sString)
    except:
        k.keyboardQuit(event)
        k.setLabel("Illegal regular expression")
        return
    count = len(pattern.findall(txt))
    if count:
        ntxt = pattern.sub(self._rpString,txt)
        w.delete(i,end)
        w.insert(i,ntxt)
else:
    # Problem: adds newline at end of text.
    txt = w.get(i,end)
    count = txt.count(self._sString)
    if count:
        ntxt = txt.replace(self._sString,self._rpString)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20060106104442.358">def activateReplaceRegex( self ):
    
    '''This method turns regex replace on for replaceString'''

    self._useRegex = True
    return True</t>
<t tx="ekr.20060106104442.359">def scrollDown (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) + chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')

def scrollUp (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) - chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')</t>
<t tx="ekr.20060106104442.360">'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
</t>
<t tx="ekr.20060106104442.361">def sortLines (self,event,which=None): # event IS used.

    k = self.k ; w = event.widget
    if not self._chckSel(event):
        return
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.362">def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i &lt;= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.363">def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20060106104442.364"></t>
<t tx="ekr.20060106104442.365">def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')</t>
<t tx="ekr.20060106104442.366">def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    if len(swapspots) != 0:
        if w.compare(i,'&gt;',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'&lt;',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

def transposeWords (self,event):
    self.swapWords(event,self.swapSpots)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
</t>
<t tx="ekr.20060106104442.367">def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)

transposeCharacters = swapCharacters</t>
<t tx="ekr.20060106104442.368">def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20060106104442.369"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20060106104442.370"></t>
<t tx="ekr.20060106104442.371">def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes

    # Keys are requests, values are list of panes that match.
    matchingPanesDict = {
        'all':  ['all','body','log','mini','text','tree'],
        'body': ['all','body'],
        'log':  ['all','log'],
        # 'menu': [menu], # Not used.  Probably dubious.
        'mini': ['all','mini'],                   
        'text': ['all','body','log','text'],  # Text = body+log
        'tree': ['all','tree'],
    }

    matchingPanes = []
    for pane in panes:
        matches = matchingPanesDict.get(pane,[])
        for match in matches:
            if match not in matchingPanes:
                matchingPanes.append(match)

    # g.trace(widget._name,'matchingPanes',matchingPanes,g.callers(3))
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in matchingPanes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('**binding',bunch.pane,shortcut,commandName,widget._name)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                __pychecker__ = '--no-argsused' # widget and commandName.
                # g.trace(commandName,func,g.app.gui.widget_name(widget))
                func(event)
                return 'break'

            widget.bind(shortcut,textBindingsRedirectionCallback)
            
    # New in 4.4a5: create the all-purpose binding.
    # This allows Leo always to return 'break' in key handlers.
    widget.bind('&lt;Key&gt;',k.onTextWidgetKey)</t>
<t tx="ekr.20060106104442.372">def onTextWidgetKey (self,event):
    
    '''This is the default key handler for all text widgets.
    It should never be called for keys bound to any command.'''

    ch = event and event.char or ''
    w  = event and event.widget

    if w and ch:
        i,j = g.app.gui.getTextSelection(w)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)

    return 'break'</t>
<t tx="ekr.20060106104442.373"></t>
<t tx="ekr.20060106104442.374">@nocolor

- &lt;&lt; unselect the old node &gt;&gt; in tree.select now calls
    self.setUnselectedLabelState(old_p)

- tree.endEditLabel no longer calls setUnselectedLabelState.
    (This is important)</t>
<t tx="ekr.20060106104442.375"></t>
<t tx="ekr.20060106104442.376"></t>
<t tx="ekr.20060106104442.377">Error: 1
AttributeError Exception in Tk callback
  Function: &lt;function keyCallback2 at 0x01378630&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x034905D0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 814, in keyCallback2
    def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1143, in masterCommand
    if stroke == k.abortAllModesKey: # 'Control-g'
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 811, in menuFuncCallback
    def menuFuncCallback (event,command=command):
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 2250, in backwardDeleteCharacter
    oldText = w.get('1.0','end')
AttributeError: Canvas instance has no attribute 'get'

</t>
<t tx="ekr.20060106104442.378"></t>
<t tx="ekr.20060106104442.379"></t>
<t tx="ekr.20060106104442.380">def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    if not key:
        return ''
        
    ch = key[-2]

    if ch in string.ascii_uppercase:
        return '%sShift-%s&gt;' % (key[:-2],ch.lower())
    else:
        return key</t>
<t tx="ekr.20060106104442.381">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(shortcut)),color='blue')
    else:
        if verbose:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20060106104442.382"># The reason for this assert is unclear.</t>
<t tx="ekr.20060106104442.383">Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 239, in doCommand
    val = command()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1579, in undo
    u.undoHelper()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1729, in undoMove
    u.p.moveToNthChildOf(u.oldParent,u.oldN)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 2767, in moveToNthChildOf
    p.unlink()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3310, in unlink
    assert(parent.v in p.v.directParents())
AssertionError</t>
<t tx="ekr.20060106104442.384">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")</t>
<t tx="ekr.20060106104442.385"></t>
<t tx="ekr.20060106104442.386"></t>
<t tx="ekr.20060106104442.387"></t>
<t tx="ekr.20060106104442.388">@ Ripping focus away from widgets is odious and bug prone.

A much better solution: call update *after* log-pane operations.</t>
<t tx="ekr.20060106104442.389"></t>
<t tx="ekr.20060106104442.390">@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.</t>
<t tx="ekr.20060106104442.391">def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
</t>
<t tx="ekr.20060106104442.392"># New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '&lt;no name&gt;'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20060106104442.393"></t>
<t tx="ekr.20060106104442.394"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    if not in_headline:

        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
        c.frame.widgetWantsFocus(t)</t>
<t tx="ekr.20060106104442.395">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
	    c.selectPosition(p)
    finally:
        c.endUpdate()
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    gui.setInsertPoint(t,insert)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos)
    if self.reverse:
        gui.setInsertPoint(t,pos)
    gui.makeIndexVisible(t,insert)
    c.frame.widgetWantsFocus(t)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20060106104442.396">class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others</t>
<t tx="ekr.20060106104442.397"></t>
<t tx="ekr.20060106104442.398">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
</t>
<t tx="ekr.20060106104442.399">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl</t>
<t tx="ekr.20060106104442.400">def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log</t>
<t tx="ekr.20060106104442.401">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu</t>
<t tx="ekr.20060106104442.402"></t>
<t tx="ekr.20060106104442.403">def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)</t>
<t tx="ekr.20060106104442.404">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font</t>
<t tx="ekr.20060106104442.405">def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)</t>
<t tx="ekr.20060106104442.406">def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d</t>
<t tx="ekr.20060106104442.407">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20060106104442.408">def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass</t>
<t tx="ekr.20060106104442.409"></t>
<t tx="ekr.20060106104442.410">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20060106104442.411">def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl</t>
<t tx="ekr.20060106104442.412">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()</t>
<t tx="ekr.20060106104442.413">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...</t>
<t tx="ekr.20060106104442.414">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20060106104442.415"></t>
<t tx="ekr.20060106104442.416">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')</t>
<t tx="ekr.20060106104442.417">def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    &lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;
    &lt;&lt; Create the tab's text widget &gt;&gt;
    self.setTabBindings(tabName)
    
    # New in 4.4b1: call update explicitly.
    textWidget and textWidget.update()</t>
<t tx="ekr.20060106104442.418">menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20060106104442.419">textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("&lt;Button-1&gt;",self.onActivateLog)
textWidget.tag_config('black',foreground='black')</t>
<t tx="ekr.20060106104442.420">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.421">def getSelectedTab (self):
    
    return self.tabName</t>
<t tx="ekr.20060106104442.422">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        logCtrl and logCtrl.update()
        self.c.frame.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        if logCtrl:
            logCtrl.update()
            self.c.frame.widgetWantsFocus(logCtrl)</t>
<t tx="ekr.20060106104442.423">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20060106104442.424">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    # c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    
    # New in 4.4b1: call update *after* creating the tab.
    tabFrame and tabFrame.update()

    return tabFrame</t>
<t tx="ekr.20060106104442.425">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['all','log','text'],w)

        # A wretched kludge: put the bindings in the tab!
        # We can't seem to get focus away from it.
        tab = self.nb.tab(tabName) # b is a Tk.Button.
        k.copyBindingsToWidget(['all','log','text'],tab)</t>
<t tx="ekr.20060106104442.426"></t>
<t tx="ekr.20060106104442.427">def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)</t>
<t tx="ekr.20060106104442.428">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)</t>
<t tx="ekr.20060106104442.429">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)</t>
<t tx="ekr.20060106104442.430">def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20060106104442.431"></t>
<t tx="ekr.20060106104442.432"></t>
<t tx="ekr.20060106104442.433"></t>
<t tx="ekr.20060106104442.434"></t>
<t tx="ekr.20060106104442.435">def __init__ (self,c):
    
    self.c = c
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    
    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        self.doIfGui,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'mode':         self.doMode, # New in 4.4b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        'shortcut':     self.doShortcut,
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }</t>
<t tx="ekr.20060106104442.436">def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(pane=pane,val=val)</t>
<t tx="ekr.20060106104442.437">def doShortcut(self,p,kind,name,val):
    
    # Note:  kind,name,val are as returned from self.parseHeadline(p.headString())

    self.set(p,kind,name,val)
    self.setShortcut(name,val)</t>
<t tx="ekr.20060106104442.438">def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind,val not used.
    
    # g.trace(self.c.fileName(),p.headString(),g.callers())
    
    d = self.shortcutsDict # To detect duplicates.
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # g.trace(name,bunch)
            if bunch is not None:
                # New in 4.4a5:
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)</t>
<t tx="ekr.20060106104442.439">def setShortcut (self,name,bunch):
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",bunch)
    
    # g.trace(bunch.pane,rawKey,bunch.val)</t>
<t tx="ekr.20060106104442.440">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.
    
    if 1:
        bunchList = self.get(c,key,"shortcut")
        if bunchList:
            bunchList = [bunch for bunch in bunchList
                if bunch.val and bunch.val.lower() != 'none']
            return key,bunchList
        else:
            return key,[]
    else:
        bunch = self.get(c,key,"shortcut")
        if bunch and bunch.val:
            # g.trace(bunch.pane,key,repr(bunch.val))
            if bunch.val.lower() == 'none':
                return key,None
            else:
                return key,bunch
        else:
            return key,None</t>
<t tx="ekr.20060106104442.441"></t>
<t tx="ekr.20060106104442.442">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20060106104442.443">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20060106104442.444">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c 

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    ## if shortcut == '&lt;None&gt;': return
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        # g.trace('Not bound',shortcut)
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return
        
    # g.trace(pane,shortcut,commandName)

    try:
        &lt;&lt; bind callback to shortcut in pane &gt;&gt;

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20060106104442.445"># Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or '').lower(),[])

if shortcut == '&lt;Key&gt;':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20060106104442.446">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20060106104442.447">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20060106104442.448">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20060106104442.449">def makeAllBindings (self):
    
    k = self ; c = k.c
    
    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings()
    k.makeBindingsFromCommandsDict()
    k.add_ekr_altx_commands()
    k.addModeCommands()
    k.checkBindings()</t>
<t tx="ekr.20060106104442.450">def addModeCommands (self):
    
    '''Add commands created by @mode settings..'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060106104442.451">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
    
    self.rCommandDict = {
        'space':    c.registerCommands.pointToRegister,
        'a':        c.registerCommands.appendToRegister,
        'i':        c.registerCommands.insertRegister,
        'j':        c.registerCommands.jumpToRegister,
        'n':        c.registerCommands.numberToRegister,
        'p':        c.registerCommands.prependToRegister,
        'r':        c.rectangleCommands.enterRectangleState,
        's':        c.registerCommands.copyToRegister,
        'v':        c.registerCommands.viewRegister,
        'plus':     c.registerCommands.incrementRegister,
    }
    
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }
    
    self.xcommands = {
        '&lt;Control-t&gt;':  c.editCommands.transposeLines,
        '&lt;Control-u&gt;':  c.editCommands.upCaseRegion,
        '&lt;Control-l&gt;':  c.editCommands.downCaseRegion,
        '&lt;Control-o&gt;':  c.editCommands.removeBlankLines,
        '&lt;Control-i&gt;':  c.editFileCommands.insertFile,
        '&lt;Control-s&gt;':  c.editFileCommands.saveFile,
        '&lt;Control-x&gt;':  c.editCommands.exchangePointMark,
        '&lt;Control-c&gt;':  c.controlCommands.shutdown,
        '&lt;Control-b&gt;':  c.bufferCommands.listBuffers,
        '&lt;Control-Shift-at&gt;': lambda event: event.widget.selection_clear(),
        '&lt;Delete&gt;':     c.killBufferCommands.backwardKillSentence,
    }</t>
<t tx="ekr.20060106104442.452">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20060106104442.453">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(stroke,accel,shortcut,func.__name__)
    if pane == 'mini' and func != k.keyboardQuit:
        # Call a strange callback that bypasses k.masterCommand.
        def minibufferKeyCallback(event,func=func,shortcut=shortcut):
            k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

        k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
        # Create two-levels of callbacks.
        def specialCallback (event,func=func):
            return func(event)

        def keyCallback (event,func=specialCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)

        k.bindKey(pane,shortcut,keyCallback,commandName)

    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20060106104442.454">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20060106104442.455">@ This code "canonicalizes" both the shortcuts that appear in menus and the
arguments to bind, mostly ignoring case and the order in which special keys are
specified.

For example, Ctrl+Shift+a is the same as Shift+Control+A. Each generates
Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print repr(shortcut),repr(bind_shortcut),repr(menu_shortcut)
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20060106104442.456">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20060106104442.457">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20060106104442.458"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20060106104442.459"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9</t>
<t tx="ekr.20060106104442.460">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20060106104442.461"></t>
<t tx="ekr.20060106104442.462">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)
</t>
<t tx="ekr.20060106104442.463">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
                    
                </t>
<t tx="ekr.20060106104442.464">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        &lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)</t>
<t tx="ekr.20060106104442.465">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20060106104442.466"># First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunchList = c.config.getShortcut(commandName)
bunch = bunchList and bunchList[0]
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    &lt;&lt; compute emacs_name &gt;&gt;
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunchList = c.config.getShortcut(emacs_name)
        bunch = bunchList and bunchList[0]
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20060106104442.467">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060106104442.468">if rawKey:
    amp_index = rawKey.find("&amp;")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&amp;")</t>
<t tx="ekr.20060106104442.469">@ This is the end of the ill-fated settings dialog.

Important: you can use the show-colors and show-fonts commands to help set
colors and fonts in leoSettings.leo.</t>
<t tx="ekr.20060106104442.470">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20060106104442.471">def preferences(self):
    
    '''Handle the preferences command.'''
    
    c = self
    c.openLeoSettings()</t>
<t tx="ekr.20060106104442.472"></t>
<t tx="ekr.20060106104442.473">@nocolor

- set-insert, set-replace commands.
- Fancier mode-help.
- Use tabs in print-commands &amp; print-bindings.

Docs
- Document @mode and how to use it.
- Move most settings docs to Customizing chapter.

Cleanup
- Default modes should set the label.
- Create tkinterKeyHandler.
- Complete vim emulation</t>
<t tx="ekr.20060106104442.474"></t>
<t tx="ekr.20060106104442.475"></t>
<t tx="ekr.20060106104442.476">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20060106104442.477">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20060106104442.478">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
&lt;&lt; set self.unboundKeyAction &gt;&gt;</t>
<t tx="ekr.20060106104442.479">defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
defaultAction.lower()
if defaultAction in ('insert','replace','ignore'):
    self.unboundKeyAction = defaultAction
else:
    g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
    self.unboundKeyAction = 'insert'</t>
<t tx="ekr.20060106104442.480"># Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0</t>
<t tx="ekr.20060106104442.481">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060106104442.482">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060106104442.483"></t>
<t tx="ekr.20060106104442.484">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 0: # Hurray.  This was a massive kludge.
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)</t>
<t tx="ekr.20060106104442.485">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20060106104442.486">def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return
        
    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    k.inputModeName = None
        
    k.clearState()
    k.resetLabel()
    
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060106104442.487"></t>
<t tx="ekr.20060106104442.488">def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '&lt;Key&gt;'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060106104442.489"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060106104442.490">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060106104442.491">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060106104442.492">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060106104442.493">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20060106104442.494">def quickCommand (self,event):
    
    '''Handle 'quick-command' (control-c) mode.'''
    
    k = self ; stroke = k.stroke ; state = k.getState('quick-command')
    
    if state == 0:
        k.setState('quick-command',1,handler=k.quickCommand)
        k.setLabelBlue('quick command: ',protect=True)
    else:
        k.previous.insert(0,event.keysym)
        if len(k.previous) &gt; 10: k.previous.pop()
        
        # g.trace('stroke',stroke,event.keysym)
        if stroke == '&lt;Key&gt;' and event.keysym == 'r':
            k.rCommand(event)
        elif stroke in ('&lt;Key&gt;','&lt;Escape&gt;'):
            if k.processKey(event): # Weird command-specific stuff.
                k.clearState()
        elif stroke in k.xcommands:
            k.clearState()
            k.xcommands [stroke](event)

        k.endCommand(event,stroke)
        
    return 'break'</t>
<t tx="ekr.20060106104442.495">def rCommand (self,event):
    
    k = self ; state = k.getState('r-command') ; ch = event.keysym
    if state == 0:
        k.setLabel ('quick-command r: ',protect=True)
        k.setState('r-command',1,k.rCommand)
    elif ch in ('Control_L','Alt_L','Shift_L'):
        return
    else:
        k.clearState()
        
        # g.trace(repr(ch))
        func = k.rCommandDict.get(ch)
        if func:
            k.commandName = 'quick-command r: '
            k.resetLabel()
            func(event)
        else:
            k.setLabelGrey('Unknown r command: %s' % repr(ch))</t>
<t tx="ekr.20060106104442.496">def processKey (self,event):
    
    '''Handle special keys in quickCommand mode.
    Return True if we should exit quickCommand mode.'''

    k = self ; c = k.c ; previous = k.previous
    
    if event.keysym in ('Shift_L','Shift_R'): return False
    # g.trace(event.keysym)

    func = k.variety_commands.get(event.keysym)
    if func:
        k.keyboardQuit(event)
        func(event)
        return True

    if event.keysym in ('a','i','e'):
        if k.processAbbreviation(event):
            return False # 'a e' or 'a i e' typed.
        
    if event.keysym == 'g': # Execute the abbreviation in the minibuffer.
        s = k.getLabel(ignorePrompt=True)
        if k.abbreviationFuncDict.has_key(s):
            k.clearState()
            k.keyboardQuit(event)
            k.abbreviationFuncDict [s](event)
            return True
    
    if event.keysym == 'e': # Execute the last macro.
        k.keyboardQuit(event)
        c.macroCommands.callLastKeyboardMacro(event)
        return True

    if event.keysym == 'x' and previous [1] not in ('Control_L','Control_R'):
        event.keysym = 's'
        k.setState('quick-command',1)
        c.registerCommands.setNextRegister(event)
        return True

    if event.keysym == 'Escape' and len(previous) &gt; 1 and previous [1] == 'Escape':
        k.repeatComplexCommand(event)
        return True
        
    else:
        return False</t>
<t tx="ekr.20060106104442.497">def processAbbreviation (self,event):
    
    '''Handle a e or a i e.
    Return True when the 'e' has been seen.'''
    
    k = self ; char = event.char

    if k.getLabel() != 'a' and event.keysym == 'a':
        k.setLabel('a')
        return False

    elif k.getLabel() == 'a':

        if char == 'i':
            k.setLabel('a i')
            return False
        elif char == 'e':
            event.char = ''
            k.expandAbbrev(event)
            return True
            
    return False</t>
<t tx="ekr.20060106104442.498">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20060106104442.499">def matchKeys (self,event,shortcut):
    
    '''Return true if a binding matches the key specified by the event.'''
    
    k = self ; c = k.c
    
    if not k.stroke or not event: return False
    
    stroke = k.stroke ; keysym = event.keysym
    shortcut2, junk = c.frame.menu.canonicalizeShortcut(shortcut)
    
    if stroke == '&lt;Key&gt;':
        val = shortcut == keysym or shortcut.startswith('Key-') and shortcut.endswith(keysym)
    else:
        val = stroke == shortcut2
        
    if 0:
        g.trace('returns',val,
            'stroke',stroke,'keysym',keysym,
            'shortcut',shortcut,'shortcuts',shortcut2)
        
    return val</t>
<t tx="ekr.20060106104442.500">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName)
</t>
<t tx="ekr.20060106104442.501">def generalModeHandler (self,event,name=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c ; f = c.frame
    modeName = name or k.inputModeName
    commandName = 'enter-' + modeName
    state = k.getState(modeName)
    keysym = event and event.keysym or ''
    # g.trace(modeName,'state',state)
    
    d = g.app.config.modeCommandsDict.get(commandName)
    if not d:
        g.trace("can't happen")
    elif state == 0:
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(name,1,handler=k.generalModeHandler)
        k.setLabelBlue(name,protect=True)
        k.modeCompletionList = d.keys()
    else:
        for key in d.keys():
            bunchList = d.get(key)
            for bunch in bunchList:
                if k.matchKeys(event,bunch.val):
                    func = c.commandsDict.get(key)
                    # g.trace('calling',func)
                    if key != 'mode-help':
                        # This must be done first because commands can change windows.
                        k.clearState()
                        k.resetLabel()
                        k.endCommand(event,k.stroke)
                        k.inputModeName = None
                        c.frame.log.deleteTab('Mode')
                        c.frame.widgetWantsFocus(k.modeWidget)
                    func(event)
                    return 'break'
        k.modeHelpHelper(d)
        f.minibufferWantsFocus()
        
    return 'break'</t>
<t tx="ekr.20060106104442.502">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self

    if k.inputModeName:
        commandName = 'enter-' + k.inputModeName
        d = g.app.config.modeCommandsDict.get(commandName)
        k.modeHelpHelper(d)
    else:
        g.es('Not in any mode')





</t>
<t tx="ekr.20060106104442.503">def modeHelpHelper (self,d):
    
    k = self ; c = k.c
    
    c.frame.log.clearTab('Mode')
    
    for key in d.keys():
        bunchList = d.get(key)
        bunch = bunchList and bunchList[0]
        shortcut = bunch.val
        if shortcut not in (None,'None'):
            if shortcut.startswith('Key-'):
                shortcut = shortcut[4:]
                if len(shortcut) == 1:
                    ch = shortcut[0]
                    if ch in string.ascii_uppercase:
                        shortcut = 'Shift-%s' % ch.lower()
            g.es('%s\t%s' % (shortcut,key),tabName='Mode')</t>
<t tx="ekr.20060106104442.504">def setIgnoreMode (self,event):
    
    self.unboundKeyAction = 'ignore'

def setInsertMode (self,event):
    
    self.unboundKeyAction = 'insert'
    
def setOverwriteMode (self,event):
    
    self.unboundKeyAction = 'replace'</t>
<t tx="ekr.20060120105136"></t>
<t tx="ekr.20060120105136.1"></t>
<t tx="ekr.20060120105136.2">A 'backward' delete at the start of a headline deletes the first character.
delete-char does not work in headlines.</t>
<t tx="ekr.20060120105136.3">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return
    
    name = g.app.gui.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(i,j)

    if name.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=changed)
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20060120105136.4">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20060120105136.5">def deleteNextChar (self,event):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed)</t>
<t tx="ekr.20060120105136.6"></t>
<t tx="ekr.20060120105136.7">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)</t>
<t tx="ekr.20060120105136.8">def beginCommandHelper (self,ch,undoType,w):

    p = self.c.currentPosition()
    name = g.app.gui.widget_name(w)
    
    # Bug fix 1/6/06 (after a5 released): don't do this in headlines!
    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
        
    return w</t>
<t tx="ekr.20060120105136.9">def endCommand(self,label=None,changed=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b:
        name = b.name
        if name.startswith('body'):
            if changed:
                c.frame.body.onBodyChanged(undoType=b.undoType,
                    oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        elif name.startswith('head'):
            g.trace('Should not happen: endCommand does not support undo in headlines')
        else: pass
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    if label:
        k.setLabelGrey(label)
    else:
        k.resetLabel()</t>
<t tx="ekr.20060120105136.10"></t>
<t tx="ekr.20060120105136.11">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060120105136.12">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060120105136.13"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20060120105136.14"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060120105136.15"># Every call was a potential bug.</t>
<t tx="ekr.20060120105136.16"></t>
<t tx="ekr.20060120105136.17">def createFrame (self):

    gui = g.app.gui ; top = self.top

    &lt;&lt; create the organizer frames &gt;&gt;
    &lt;&lt; create the browser rows &gt;&gt;
    &lt;&lt; create the extension row &gt;&gt;
    &lt;&lt; create the whitespace options frame &gt;&gt;
    &lt;&lt; create the print options frame &gt;&gt;
    &lt;&lt; create the compare buttons &gt;&gt;

    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()
    top.protocol("WM_DELETE_WINDOW", self.onClose)</t>
<t tx="ekr.20060120105136.18">outer = Tk.Frame(self.frame, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)</t>
<t tx="ekr.20060120105136.19">for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    lab = Tk.Label(row,anchor="e",text=text,width=13)
    lab.pack(side="left",padx=4)
    
    e = Tk.Entry(row)
    e.pack(side="left",padx=2)
    self.browseEntries.append(e)
    
    b = Tk.Button(row,text="browse...",command=command)
    b.pack(side="left",padx=6)

    b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    b.pack(side="left")</t>
<t tx="ekr.20060120105136.20">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
    text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
    text="Append output to output file")
b.pack(side="left",padx=4)</t>
<t tx="ekr.20060120105136.21">w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")
    
for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w")
    
spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="ekr.20060120105136.22">w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w",padx=padx)
    self.printButtons.append(b)
    
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="ekr.20060120105136.23">for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):
    
    b = Tk.Button(lower,text=text,command=command,width=18)
    b.pack(side="left",padx=6)</t>
<t tx="ekr.20060120105136.24"></t>
<t tx="ekr.20060120105136.25">def callers (n=5,excludeCaller=True):
    
    '''Return a list containing the callers of the function that called g.callerList.
    
    By default, the function that called g.callerList is not on the list,
    which is what is wanted when using g.trace.'''
    
    result = []
    while n &gt; 0:
        s = g.callerName(n)
        if s == 'callers':
            if excludeCaller and result:
                del result [-1]
            break
        elif s:
            result.append(s)
        n -= 1
        
    return ','.join(result)
</t>
<t tx="ekr.20060120105136.26">def createTopologyList (c,root=None,useHeadlines=False):
    
    """Creates a list describing a node and all its descendents"""

    if not root: root = c.rootPosition()
    v = root
    if useHeadlines:
        aList = [(v.numberOfChildren(),v.headString()),]
    else:
        aList = [v.numberOfChildren()]
    child = v.firstChild()
    while child:
        aList.append(g.createTopologyList(c,child,useHeadlines))
        child = child.next()
    return aList</t>
<t tx="ekr.20060120105136.27">def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False</t>
<t tx="ekr.20060120105136.28">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }</t>
<t tx="ekr.20060120105136.29">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")</t>
<t tx="ekr.20060120105136.30"># 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20060120105136.31">if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
</t>
<t tx="ekr.20060120105136.32">if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
</t>
<t tx="ekr.20060120105136.33">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w &gt; 0:
        page_width = w</t>
<t tx="ekr.20060120105136.34">if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        </t>
<t tx="ekr.20060120105136.35">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)</t>
<t tx="ekr.20060120105136.36">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w</t>
<t tx="ekr.20060120105136.37">if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False</t>
<t tx="ekr.20060120105136.38">def initScriptFind(c,findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
        
    __pychecker__ = '--no-argsused' # firstNode is not used.
    
    import leoTest
    import leoGlobals as g

    # Find the scripts.
    p = c.currentPosition()
    u = leoTest.testUtils(c)
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    c.frame.findPanel.init(c)
    c.showFindPanel()</t>
<t tx="ekr.20060120105136.39">def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):
    
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(c,headline):
    
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20060120105136.40"></t>
<t tx="ekr.20060120105136.41">def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    
    g.app.unitTesting = True
    try:
        g.app.unitTestDict["fail"] = False
    
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()
        
        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
    
        for p in theIter:
            if isTestNode(p):
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p):
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
    
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
        c.setChanged(changed) # Restore changed state.
        # Restore the selected node unless overridden.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.selectPosition(p1)
    finally:
        g.app.unitTesting = False
        </t>
<t tx="ekr.20060120105136.42">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20060120105136.43">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20060120105136.44">def fail (self,msg=None):

    """Mark a unit test as having failed."""
    
    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20060120105136.45">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)</t>
<t tx="ekr.20060120105136.46">def tearDown (self):

    pass

    # To do: restore the outline.</t>
<t tx="ekr.20060120105136.47">def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # Execute the script. Let unit test handle any errors!
    
    if define_g:
        # Execute the test in an environment containing c, g &amp; p.
        exec script + '\n' in {'c':c,'g':g,'p':p}
    else:
        # Execute the test in a totally pristine environment.
        exec script + '\n' in {}</t>
<t tx="ekr.20060120105136.48">def shortDescription (self):

    return self.p.headString() + '\n'</t>
<t tx="ekr.20060120105136.49">@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""
    
    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None</t>
<t tx="ekr.20060120105136.50">def makeTestCase (c,p):
    
    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None</t>
<t tx="ekr.20060120105136.51"># A utility for use by script buttons.

def runTimerOnNode (c,p,count):

    s = p.bodyString().rstrip() + '\n'
    
    # A kludge so we the statement below can get c and p.
    g.app.unitTestDict = {'c':c,'p':p}
    
    # This looks like the best we can do.
    setup = 'import leoGlobals as g; c = g.app.unitTestDict.get("c"); p = g.app.unitTestDict.get("p")'

    t = timeit.Timer(s,setup)

    try:
        if count is None:
            count = 1000000
        result = t.timeit(count)
        print "count: %d time/count: %f %s" % (count,result/count,p.headString())
    except:
        t.print_exc()</t>
<t tx="ekr.20060120105136.52">def numberOfClonesInOutline (self):

    """Returns the number of cloned nodes in an outline"""

    c = self.c ; n = 0
    for p in c.allNodes_iter():
        if p.isCloned():
            n += 1
    return n</t>
<t tx="ekr.20060120105136.53">def numberOfNodesInOutline (self):

    """Returns the total number of nodes in an outline"""

    return len([p for p in self.c.allNodes_iter()])</t>
<t tx="ekr.20060120105136.54">def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    try:
        g.app.unitTesting = True
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            g.app.closeLeoWindow(frame.c.frame)
        c.frame.top.update()
        g.app.unitTesting = True

    if not ok: raise</t>
<t tx="ekr.20060120105136.55">def makeEditBodySuite(c):

    """Create an Edit Body test for every descendant of testParentHeadline.."""

    p = c.currentPosition()
    u = testUtils(c)
    assert p.exists(c)
    data_p = u.findNodeInTree(p,"editBodyTests")
    assert(data_p)
    temp_p = u.findNodeInTree(data_p,"tempNode")
    assert(temp_p)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in data_p.children_iter():
        if p.headString()=="tempNode": continue # TempNode now in data tree.
        before = u.findNodeInTree(p,"before")
        after  = u.findNodeInTree(p,"after")
        sel    = u.findNodeInTree(p,"selection")
        ins    = u.findNodeInTree(p,"insert")
        if before and after:
            test = editBodyTestCase(c,p,before,after,sel,ins,temp_p)
            suite.addTest(test)
        else:
            print 'missing "before" or "after" for', p.headString()

    return suite</t>
<t tx="ekr.20060120105136.56">def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert(parent)
    temp = u.findNodeInTree(parent,"tempNode")
    assert(temp)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children_iter(copy=True):
        if p == temp: continue
        dialog = u.findNodeInTree(p,"dialog")
        assert(dialog)
        test = importExportTestCase(c,p,dialog,temp,doImport)
        suite.addTest(test)

    return suite</t>
<t tx="ekr.20060120105136.57">def runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=False):
        
    __pychecker__ = '--no-shadowbuiltin' # input is a builtin.

    # The contents of the "-input" and "-input-after" nodes define the changes.

    p = c.currentPosition()
    u = testUtils(c)
    input           = u.findNodeInTree(p,"-input")              # i file: before the change.
    input_ins       = u.findNodeInTree(p,"-input-after")        # j file: after the change.
    output_sent     = u.findNodeInTree(p,"-output-sent")        # fat file -&gt; i file.
    out_after_sent  = u.findNodeInTree(p,"-output-after-sent")  # Should match result.
    result          = u.findNodeInTree(p,"-result")
    ilines          = u.findNodeInTree(p,"-i_lines")
    jlines          = u.findNodeInTree(p,"-j_lines")

    # Create the output nodes containing sentinels from the original input.
    u.writeNodesToNode(c,input,output_sent,sentinels=True)
    u.writeNodesToNode(c,input_ins,out_after_sent,sentinels=True)

    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension("foo.py")

    fat_lines = g.splitLines(output_sent.bodyString())
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    if input_ins.hasChildren():
        # Get the lines by stripping sentinels from -output-after-sent node.
        lines = g.splitLines(out_after_sent.bodyString()) 
        j_lines = mu.removeSentinelsFromLines(lines,delims)
    else:
        j_lines = g.splitLines(input_ins.bodyString()) 

    # For viewing...
    ilines.scriptSetBodyString(''.join(i_lines))
    jlines.scriptSetBodyString(''.join(j_lines))
    if ilines.bodyString() != input.bodyString():
        if not ignoreSentinelsInCompare:
            print "i_lines != input !"

    # Put the resulting lines (with sentinels) into the -result node.
    lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
    result.scriptSetBodyString(''.join(lines))

    if ignoreSentinelsInCompare:
        sList = []
        for s in (result.bodyString(),out_after_sent.bodyString()):
            lines = g.splitLines(s)
            lines = mu.removeSentinelsFromLines(lines,delims)
            sList.append(''.join(lines))
        return sList[0] == sList[1]
    else:
        return u.compareIgnoringNodeNames(
            result.bodyString(),
            out_after_sent.bodyString(),
            delims,verbose=True)</t>
<t tx="ekr.20060120105136.58"></t>
<t tx="ekr.20060120105136.59">def __init__ (self,c,v,stack,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    self.c = c
    self.v = v
    # assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.
    g.app.positions += 1
    
    # if g.app.tracePositions and trace:
        # g.trace("%-25s %-25s %s" % (
            # g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.</t>
<t tx="ekr.20060120105136.60"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    # if g.app.tracePositions:
        # g.trace("%-25s %-25s %s" % (
            # g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.c,self.v,self.stack,trace=False)</t>
<t tx="ekr.20060120105136.61"># It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s):

    """Bump the error count in the tangle command."""
    
    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors +=1
    g.es(s)</t>
<t tx="ekr.20060120105136.62"></t>
<t tx="ekr.20060120105136.63">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3465251
By: e

(fixed) after a save, undo last typing event
doesn't mark leo changed.
you can go up and down the undo redo list
and still the leo is not marked changed.
the changes in the body do stick.
didn't try other undo like insert node.

**Important**: the follows was likely due to improper calls to g.top()

(can't duplicate) I had a weird undo that I wasn't able to repeat
after a reboot, when I had 2 leos open and
and the undo after a save in one would display
the last undo in a node body from the other leo.
</t>
<t tx="ekr.20060120105136.64"></t>
<t tx="ekr.20060120105136.65">def new (self):

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(c,v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    finally:
        c.endUpdate()
        frame.body.setFocus()
    return c # For unit test.</t>
<t tx="ekr.20060120105136.66">def open(self):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060120105136.67">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20060120105136.68">def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20060120105136.69">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20060120105136.70">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20060120105136.71">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20060120105136.72">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20060120105136.73">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20060120105136.74">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20060120105136.75">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20060120105136.76">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20060120105136.77">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20060120105136.78">def close(self):
    
    """Handle the File-Close command."""

    g.app.closeLeoWindow(self.frame)</t>
<t tx="ekr.20060120105136.79">def save(self):

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060120105136.80">def saveAs(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060120105136.81">def saveTo(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)</t>
<t tx="ekr.20060120105136.82">def revert(self):
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20060120105136.83">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            frame.bodyWantsFocus()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20060120105136.84">def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self
    c.setLog()
    p = c.currentPosition()
    #g.trace(command.__name__,label)
    
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            if event is None:
                val = command() # Call legacy command
                if c and c.exists: # Be careful: the command could destroy c.
                    c.keyHandler.funcReturn = val
            else:
                command(event) # Call minibuffer command.
        except:
            g.es("exception executing command")
            print "exception executing command"
            g.es_exception(c=c)
            if c and c.exists and hasattr(c,'frame'):
                c.redraw_now()

    # Be careful there: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20060120105136.85">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3495741
By: stano_paska

Hi.

In plugin word_export encoding is defined:

encoding = dict.get("encoding",None)
if encoding == None:
    encoding = c.config.default_derived_file_encoding

I have default_derived_file_encoding set to UTF-8 but when exporting to word
some national characters are not encoded correctly (Slovak).

I think it is better get encoding for word from somewhere else.

In Slovak environment word uses cp1250.

When I used:

import sys
encoding = sys.getdefaultencoding() # 'cp1250'

everything goes fine.</t>
<t tx="ekr.20060120105136.86">This could have been the source of weird find behavior.</t>
<t tx="ekr.20060120105136.87">The fix was to have x.getSelectedText return '' instead of None.</t>
<t tx="ekr.20060120105136.88">
AttributeError Exception in Tk callback
  Function: &lt;function allKeysCallback at 0x03463730&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x046801C0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 647, in allKeysCallback
    return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 763, in masterCommand
    k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 799, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 530, in stateHandler
    self.doTabCompletion()
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 457, in doTabCompletion
    if s.startswith(self.prefix) and self.tabList:
AttributeError: 'NoneType' object has no attribute 'startswith'

================================================
  Event contents:
    char:
    delta: 9
    height: ??
    keycode: 9
    keysym: Tab
    keysym_num: 65289
    num: ??
    serial: 197812
    state: 8
    time: 7154627
    type: 2
    widget: .62497976.62497136.17871136.17871376.body-pane
    width: ??
    x: 307
    x_root: 688
    y: 58
    y_root: 624</t>
<t tx="ekr.20060120105136.89"></t>
<t tx="ekr.20060120105136.90">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3510983
By: vpe

I realized it's not necessary to do int-float-int conversion to calculate width.
The result will be the same. So it's really simple:

width = font.measure(p.headString())/font.measure('0')+1

If font is not fixed-width, trailing space in headlines will vary between 0
pixels and width of char '0'.</t>
<t tx="ekr.20060120105136.91">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.expanded_click_area = c.config.getBool("expanded_click_area")
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
        # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.trace = False
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.useBindtags = True
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are unchanging positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {} # Keys are vnodes, values are Tk.Text widgets
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = {} # Keys are vnodes, values are Tk.Text widgets
    self.freeUserIcons = []</t>
<t tx="ekr.20060120105136.92">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20060120105136.93"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20060120105136.94"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20060120105136.95">def headWidth(self,p=None,s=''):

    """Returns the proper width of the entry widget for the headline."""
    
    if p: s = p.headString()

    return self.font.measure(s)/self.font.measure('0')+1

    
def widthInPixels(self,s):

    s = g.toEncodedString(s,g.app.tkEncoding)
    
    return self.font.measure(s)</t>
<t tx="ekr.20060120105136.96"></t>
<t tx="ekr.20060120105136.97">def goToNextDirtyHeadline (self):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isDirty():
        p.moveToThreadNext()

    if not p:
        # Wrap around.
        p = c.rootPosition()
        while p and not p.isDirty():
            p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20060120105136.98">def goToNextMarkedHeadline(self):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isMarked():
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20060120105136.99"></t>
<t tx="ekr.20060120105136.100">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3514627
By: nobody

&lt;quote&gt;I suspect what you want is to elimate all the !text specifications in
the @shortcuts nodes. (just the !text part, not the whole binding!)&lt;/quote&gt;

Not neccessarialy, I just want to hinder that the body pane looses the focus
as soon as you press Ctrl-S for safe, or if you press ALT-DnArrow to skip to
the next node in the tree pane.The focus should stay in the body pane without
the need to explicitly give it back to it by mouse-click or Ctrl-T, but maybe
in the case of Ctrl-s that is a bug ?
Why should the body pane loose the focus by pressing Ctrl-S ?</t>
<t tx="ekr.20060120105136.101">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    w = g.app.gui.get_focus(c.frame)
    c.afterUpdateWidgetStack.append(w)
    # g.trace(g.app.gui.widget_name(w),g.callers(5))
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True,restoreFocus=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)
    w = c.afterUpdateWidgetStack.pop()
    if c.exists and not c.afterUpdateWidgetStack and restoreFocus:
        # We are at the top-level endUpdate.
        c.frame.widgetWantsFocus(w)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20060120105136.102"></t>
<t tx="ekr.20060120105136.103"></t>
<t tx="ekr.20060120105136.104">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3514755

Leo Log Window...
Leo 4.4 alpha 5, build  1.358 , January 5, 2006
Python 2.3.4, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 1

When I hit Ctrl-H to edit a headline, the entire headline is selected. Fine.
However, when I use an arrow key to move the cursor, the headline is _still_
selected. This is NOT Windows-standard action. What's happened?</t>
<t tx="ekr.20060120105136.105">def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
  
    # Move to the spot.
    w.mark_set('insert',spot)
    spot = w.index('insert')

    # Handle the selection.
    self.extendHelper(w,extend,ins1,spot)
    w.see(spot)</t>
<t tx="ekr.20060120105136.106"># The report was mistaken.</t>
<t tx="ekr.20060120105136.107">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3514816

the cut&amp;paste doesn't mark leo dirty.
a cut then change of focus, does
an undo cleans up the mark again?</t>
<t tx="ekr.20060120105136.108"></t>
<t tx="ekr.20060120105136.109">def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20060120105136.110">def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20060120105136.111">def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060120105136.112">@tabwidth 4

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=3515341
By: nobody

from latest cvs. post g.top disable.

inconsistent use of tabs and spaces
leo\src\leoUndo.py: 
leo\src\leoCommands.py:
leo\src\leoTkinterTree.py: 
@tabwidth 4
	
Library creating: default
problem starting Library: default
not sure where this is comming from.
I though Library did nothing untill first used.
the 2nd run of Leo, the db is already created
so no error reported. 
ok if have an existing db in the default place.

leo\plugins\rClick.py", line 244, in rClicker
    commandList=[
UnboundLocalError: local variable 'rc_selectAllCallback' referenced before
assignment

a lambda would work here.
or the callback has to be moved
outside the if startswith body

leo\src\leoTkinterGui.py", line 677, in getTextSelection
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine
instead!!
AttributeError: Entry instance has no attribute 'tag_ranges'
when paste into Entry widget of search box or button.
paste only understands Text widget?
and then only from Edit-Paste
keyboard paste is ok.

in dyna_menu
TypeError: cmd_flip_Leo_debug() takes no arguments (1 given)
thanks for adding the callback in plugin_menu, 
but now any plugin that has cmd_* functions 
needs a c or dummy parameter in all of them.

'help' in 139i should be copied from 
my website version 139j from last year.
this one fails on modules if you have epydoc,
that should fix the only crasher 
in the dyna version included with Leo.

pylint call might need to have the import
lines tweaked, depending on which version.
they stupidly changed logilab directorys
from version 6 to 7 and then again 7+.
Im not going to try and guess which if
any version of pylint someone has installed.
if you want it, then you can edit it in.

otherwise everything so far seems to work.
with other noted anomalies omited for brevity.
movement keys not  unselecting text the main one.

alpha testers, remember if there is a
traceback error in a plugin, although
Leo recovers often other plugins will
stop working 100% correctly in every case.
exit Leo and python and restart 
maybe with the offending plugin disabled,
to be sure other problems are real problems.

docutils 0.4 was released today.
has a new html slideshow writer.

e</t>
<t tx="ekr.20060120105136.113"></t>
<t tx="ekr.20060120105136.114">def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.endEditing()
        c.editPosition(p)
    finally:
        c.endUpdate(restoreFocus=False)

    return p # for mod_labels plugin.</t>
<t tx="ekr.20060120105136.115"></t>
<t tx="ekr.20060120105136.116">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3514294
By: sergio_101

i just started using Leo toinght, but i am having problems with the enter key..

unless i hit ctl-enter, i cannot get a lf/cr.. it seems almost like the enter
key is not active at all unless i hit ctl..</t>
<t tx="ekr.20060120105136.117"></t>
<t tx="ekr.20060120105136.118">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3509141
By: rich_ries

CLEO still does not remove markings. I set Priority -&gt; High, then tried Priority
-&gt; Clear. Arrow is still showing. Tried Clear All. Arrow is still showing.

FastGotoNode not working w/ ^SPC

Group Operations NEEDS the old KEY-BASED version -- try tagging a dozen nodes,
making a Mark, and cloning them using a mouse!!

Need How-to for Labels:
..Label to subnode
..label to subnodes
..labels to subnodes

may be clear to the programmer, but not to anyone else.
</t>
<t tx="ekr.20060120105136.119">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3515025
By: nobody

From: Rich

&gt;&gt;  Rich, are you still having any problems with plugins? (except for problems
with the initial dynamic enabling of plugins).
 
I have a nimber of plugins turned on. Here are my findings:

I've had troubles with the following:

-  cleo.pyc
....Markers are not cleared. 
....Pressing Priority --&gt; clear gives:
---------------------------------------------------
........Error: 1
........AttributeError Exception in Tk callback
........  Function: &lt;function &lt;lambda&gt; at 0x0173BAB0&gt; (type: &lt;type 'function'&gt;)
........  Args: ()
........Traceback (innermost last):
........  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py",
line 1747, in __call__
............return apply(self.func, args)
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 700,
in &lt;lambda&gt;
............command=lambda:self.priority_clear(p.v),underline=0)
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 742,
in priority_clear
............self.changed_redraw()
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 325,
in changed_redraw
............c.setChanged(True)
........  File "c:\softwa~1\leo\leo4~1.4\src\leoCommands.py", line 5966, in
setChanged
............if not c.frame: return
........AttributeError: Commands instance has no attribute 'frame'
---------------------------------------------------
(FWIW, I like the error window that pops up.)

...."Clear All" does NOT clear ALL(nodes) but restores the node colors to their
default values

....CLEO does not pick up Leo's colors. I use Antique White for the backgrounds,
but until I changed CLEO's "White" to "Antique White" it was a nuisance. Newbies
wouldn't want to / shouldn't need to go in and change the source code.


-  fastGotoNode.pyc
....Ctrl-Spc does not work to bring up the menu

~  groupOperations.pyc
....(Image) is not a very helpful name -- To me, 'image' has to do with graphics.
"GrpOps" would be better.

....I found using the old-time key combinations a LOT easier than mousing
around:
........Shift+Alt+M........Mark
........Shift+Alt+V........moVe (Remember Turbo Pascal?)
........Shift+Alt+C........Copy
........Shift+Alt+`........clone
........Shift+Alt+T........Tag
........Shift+Alt+R........Remove tag

....... and I'd rather have a multitude of operations (as above) than a multitude
of markings (mark for Move|Copy|Clone).

The following work as expected:
+  add_directives.pyc
+  color_markup.pyc
+  hoist.pyc
+  nav_buttons.pyc
+  open_with.pyc - even with my editor!
+  rClick.pyc
+  startfile.pyc
+  UniversalScrolling.pyc

Untried-until-I-get-a-chance:
?  ConceptualSort.pyc
?  labels.pyc
?  Scripts
?  timestamp.pyc
?  UNL.pyc

HTH,
--Rich
</t>
<t tx="ekr.20060120105136.120">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3517080</t>
<t tx="ekr.20060120105136.121"></t>
<t tx="ekr.20060120105136.122">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3518722
By: nobody

I'm using Leo 4.3.1, build  1.266 , June 20, 2005.

To generate HTML file I entered the outline header "@file bbb.xml" under which
I put the following body text:

//////////////// beginning of excerpt
@first &lt;?xml version="1.0" encoding="windows-1250" ?&gt;
@language html
@
comment line
@c
@others
//////////////// end of excerpt

This works OK.
But, if I put a space after the sole @ above "comment line",  save and close
the .leo file and then open it, Leo protests in log pane on the right:

//////////////// beginning of excerpt
----- error reading @file: bbb.xml
Missing open block comment
//////////////// end of excerpt

maks.romih@snt.si</t>
<t tx="ekr.20060120105136.123">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return
        
    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []</t>
<t tx="ekr.20060120105136.124"></t>
<t tx="ekr.20060120105136.125">This corrects a problem that shows up as 'Invalid cross-device link' messages on Linux.

http://sourceforge.net/forum/message.php?msg_id=3519803</t>
<t tx="ekr.20060120105136.126">&lt;&lt; about os.rename &gt;&gt;

def utils_rename (src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''

    head, tail = g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head)

    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
    try:
        # New in Leo 4.4b1: try using shutil first.
        try:
            import shutil # shutil is new in Python 2.3
            shutil.move(src,dst)
        except ImportError:
            if sys.platform == "win32":
                os.rename(src,dst)
            else:
                try:
                    # Alas, distutils.file_util may not exist.
                    from distutils.file_util import move_file
                    move_file(src,dst)
                except ImportError:
                    # Desperation: may give: 'Invalid cross-device link'
                    os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True
    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False</t>
<t tx="ekr.20060120105136.127">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.</t>
<t tx="ekr.20060120105136.128">def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)</t>
<t tx="ekr.20060120105136.129"># These should be considered bug fixes.</t>
<t tx="ekr.20060120105136.130">@nocolor

1. copyBindingsToWidget now binds keys in priority order. This also simplifies
and clarifies the code.

2. Removed k.onTextWidgetKey.  Added a callback that invokes k.masterCommand.</t>
<t tx="ekr.20060120105136.131"></t>
<t tx="ekr.20060120105136.132">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    k.func = func
    k.funcReturn = None # For unit testing.
    if commandName is None:
        commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None or ch != '' # or stroke != '&lt;Key&gt;'
    
    if trace and interesting:
        g.trace(
            'c',c,
            'stroke:',stroke,'ch:',repr(ch),'keysym:',repr(keysym),
            'widget:',w and g.app.gui.widget_name(w),'func',func,
            g.callers())

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('leoCallback') or commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060120105136.133"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060120105136.134">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060120105136.135">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060120105136.136">def handleDefaultChar(self,event):
    
    c = self.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)

    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = self.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060120105136.137">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060120105136.138">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20060120105136.139">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20060120105136.140"></t>
<t tx="ekr.20060120105136.141">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20060120105136.142">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20060120105136.143">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunchList = k.bindingsDict.get(shortcut,[])
    k.computeKeysym_numDicts(shortcut)
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyHelper(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        k.bindingsDict [shortcut] = bunchList
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20060120105136.144">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060120105136.145">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,k.prettyPrintKey(shortcut),commandName)</t>
<t tx="ekr.20060120105136.146">def bindKeyHelper(self,pane,shortcut,callback,commandName):

    k = self ; c = k.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    menu = c.frame.menu
    minibuffer = c.miniBufferWidget
    tree = c.frame.tree.canvas
    
    d = {
        'all':  [body,log,tree], # Probably not wise: menu
        'body': [body],
        'log':  [log],
        'menu': [menu],         # Not used, and probably dubious.
        'mini': [minibuffer],   # Needed so ctrl-g will work in the minibuffer!
        'text': [body,log],
        'tree': [tree],
    }
    
    # if pane: g.trace('%4s %20s %s' % (pane, shortcut,commandName))
    
    widgets = d.get((pane or '').lower(),[])
    
    # Binding to 'menu' causes problems with multiple pastes in the Find Tab.
    # There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
    if shortcut == '&lt;Key&gt;':
        # Important.  We must make this binding if the minibuffer can ever get focus.
        if self.useTextWidget:
            widgets.append(minibuffer)
        for w in widgets:
            w.bind(shortcut,callback,'+')
    elif k.isPlainKey(shortcut):
        # Put the binding in a plain-key bindtag specific to this commander.
        tag = k.plainKeyTag()
        # g.trace('bindtags',tag,shortcut)
        body.bind_class(tag,shortcut,callback)
    else:
        for w in widgets:
            # if shortcut == '&lt;Return&gt;': g.trace(g.app.gui.widget_name(w),shortcut,callback)
            w.bind(shortcut,callback)
        # Get rid of the default binding in the menu. (E.g., Alt-f)
        menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20060120105136.147">def plainKeyTag (self):
    
    return '%s-%s' % ('plain-key',self.c.fileName())</t>
<t tx="ekr.20060120105136.148">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20060120105136.149">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,k=k,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        def menuFuncCallback (event,command=command,commandName=commandName):
            return command(event)

        def keyCallback2 (event,k=k,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke,commandName=commandName)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20060120105136.150">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20060120105136.151">def computeKeysym_numDicts (self,shortcut):
    
    k = self
    
    if shortcut == '&lt;Key&gt;': return
    
    n = k.keysym_numberInverseDict.get(shortcut)
    if n is not None:
        # print 'keysym_num for %s = %d' % (shortcut,n)
        return
        
    def callback (event,shortcut=shortcut):
        n = event.keysym_num
        # Trace causes problems.
        print '%5d = %s' % (n,shortcut)
        k.keysym_numberDict [n] = shortcut
        k.keysym_numberInverseDict [shortcut] = n
        
    if 0:  # This causes all sorts of problems.
        t = Tk.Text(k.c.frame.outerFrame)
        t = k.c.frame.body.bodyCtrl
        t.bind(shortcut,callback)
        t.event_generate(shortcut)
        # t.update()
        # t.unbind(shortcut)</t>
<t tx="ekr.20060120105136.152">def copyBindingsToWidget (self,paneOrPanes,w):
    
    '''Copy all bindings for the given panes to widget w.
    
    paneOrPanes may be  pane name (a string) or a list of pane names in priority order.'''
    
    # g.trace(paneOrPanes,g.app.gui.widget_name(w))

    k = self ; d = k.bindingsDict
    bindings = {}
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes
    # g.trace(panes)

    for shortcut in keys:
        shortcutsBunchList = []
        for pane in panes:
            old_panes = bindings.get(shortcut,[])
            assert(type(old_panes)==type([]))
            if old_panes and pane in old_panes:
                # This should have been caught earlier, but another check doesn't hurt.
                g.trace('*** redefining %s in %s' % (shortcut,pane))
            else:
                bunchList = d.get(shortcut,[])
                for bunch in bunchList:
                    if bunch.pane == pane:
                        shortcutsBunchList.append(bunch)
                        old_panes.append(pane)
                        bindings [shortcut] = old_panes
        # Create bindings for the shortcut in all panes.
        if shortcutsBunchList:
            self.copyBindingsHelper(shortcutsBunchList,shortcut,w)        
                                
    # Bind all other keys to k.masterCommand.
    def generalTextKeyCallback (event,k=self):
        k.masterCommand(event,func=None,stroke='&lt;Key&gt;',commandName=None)

    w.bind('&lt;Key&gt;',generalTextKeyCallback)</t>
<t tx="ekr.20060120105136.153">def copyBindingsHelper(self,bunchList,shortcut,w):

    k = self ; c = k.c

    textBunch = treeBunch = None
    for bunch in bunchList:
        if bunch.pane == 'tree' and treeBunch is None:
            treeBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif bunch.pane != 'tree' and textBunch is None:
            textBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif c.config.getBool('trace_bindings'):
            g.trace('ignoring %s in %s' % (shortcut,bunch.pane))
            
    if textBunch and treeBunch:
        def textAndTreeKeyCallback(event,c=c,
            textFunc=textBunch.func,treeFunc=treeBunch.func):
            w = c.currentPosition().edit_widget()
            if w and w.cget('state') == 'disabled':
                treeFunc(event)
            else:
                textFunc(event)
            return 'break'

        w.bind(shortcut,textAndTreeKeyCallback)
        
    elif textBunch or treeBunch:

        def textOrTreeKeyCallback(event,func=bunch.func):
            func(event)
            return 'break'

        w.bind(shortcut,textOrTreeKeyCallback)</t>
<t tx="ekr.20060120105136.154">def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('&lt;'):   shortcut = shortcut[1:]
    if shortcut.endswith('&gt;'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]
    return len(shortcut) == 1</t>
<t tx="ekr.20060120105136.155">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    # k.makeHardBindings()
    k.makeSpecialBindings()
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    # k.add_ekr_altx_commands()
    k.checkBindings()
    
    if 0:
    
        # Print the keysym_num dicts.
        d = k.keysym_numberInverseDict
        keys = d.keys() ; keys.sort()
        for key in key():
            n = d.get(key)
            # print 'keysym_num for %s = %d' % (key,n)</t>
<t tx="ekr.20060120105136.156">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060120105136.157">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
        
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }</t>
<t tx="ekr.20060120105136.158">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        #('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        # ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        # ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        # ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        # ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        # ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        # g.trace(commandName,bunchList)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20060120105136.159">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(commandName,shortcut,stroke)
    
    if pane == 'mini' and func != k.keyboardQuit:
        if 0:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)
    
            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)
    
            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)
    
            k.bindKey(pane,shortcut,keyCallback,commandName)
    
    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20060120105136.160">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20060120105136.161">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['log','text','all'],w)</t>
<t tx="ekr.20060120105136.162"></t>
<t tx="ekr.20060120105136.163">@nocolor

Hitting Backspace immediately put the focus in the log. Another backspace put
the focus in the body pane.

The problem was in log.clearTab.  It must do call t.update().</t>
<t tx="ekr.20060120105136.164">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    if t:
        t.delete('1.0','end')
        # Necessary to allow focus to move *out* of t.
        t.update()</t>
<t tx="ekr.20060120105136.165"></t>
<t tx="ekr.20060120105136.166"></t>
<t tx="ekr.20060120105136.167"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['text','tree','all'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20060120105136.168"></t>
<t tx="ekr.20060120105136.169">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    keys = k.bindingsDict.keys() ; keys.sort()

    c.frame.log.clearTab('Command')
    for key in keys:
        bunchList = k.bindingsDict.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
            if k.unboundKeyAction == 'ignore' or not k.isPlainKey(key):
                s = k.prettyPrintKey(key) + pane
                g.es('%-30s\t%s' % (s,b.commandName),
                    tabName='Command')</t>
<t tx="ekr.20060120105136.170">def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c
    
    c.frame.log.clearTab('Command')
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    for commandName in commandNames:
        shortcutList = inverseBindingDict.get(commandName,[''])
        for shortcut in shortcutList:
            g.es('%-30s\t%s' % (commandName,k.prettyPrintKey(shortcut)),
                tabName='Command')</t>
<t tx="ekr.20060120105136.171">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(shortcut)),color='blue')
    else:
        if verbose:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20060120105136.172">def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    k = self ; c = k.c
    
    if not key: return ''
    if len(key) == 1: return key
    if key.startswith('&lt;'):
        key = key[1:]
    if key.endswith('&gt;'):
        key = key[:-1]
    if not key: return ''
    ch = key[-1]
    if not ch: return ''
    
    if len(ch) &gt; 1:
        ch,junk = c.frame.menu.canonicalizeShortcut(ch)

    if ch in string.ascii_uppercase:
        return '%sShift-%s&gt;' % (key[:-2],ch.lower())
    else:
        return key</t>
<t tx="ekr.20060120105136.173"></t>
<t tx="ekr.20060120105136.174">def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            # g.trace(f,name)
            return self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2</t>
<t tx="ekr.20060120105136.175">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'cascade-windows':              f.cascade,
    'clear-recent-files':           c.clearRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'close-find-dialog':            c.dismissFindPanel, # Deprecated.
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'find-dialog-change':           c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':       c.replaceAll,           # Deprecated.
    'find-dialog-find-next':        c.findNext,             # Deprecated.
    'find-dialog-find-previous':    c.findPrevious,         # Deprecated.
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible':            c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-bracket':                c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-with':                    c.openWith,
    'outline-to-CWEB':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'replace':                      c.replace,
    'replace-then-find':            c.replaceThenFind,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-to':                 c.saveTo,
    'select-all':                   f.body.selectAllText,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.viewAllCharacters,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}</t>
<t tx="ekr.20060120105136.176">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060120105136.177">@nocolor
@

ivars:

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are *lists* of g.bunch(func,name,warningGiven)

g.app.keysym_numberDict:
    Keys are keysym_num's.  Values are strokes.

g.app.keysym_numberInverseDict
    Keys are strokes, values are keysym_num's.

not an ivar (computed by computeInverseBindingDict):

inverseBindingDict
    keys are emacs command names, values are *lists* of shortcuts.</t>
<t tx="ekr.20060120105136.178">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.keysym_numberDict = {}
    # Keys are keysym_num's.  Values are strokes.
self.keysym_numberInverseDict = {}
    # Keys are strokes, values are keysym_num's.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()
</t>
<t tx="ekr.20060120105136.179">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20060120105136.180"></t>
<t tx="ekr.20060120105136.181"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):
    
    k = self ; c = k.c ; s = k.getLabel() 
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        for commandName in k.mb_tabList:
            shortcutList = inverseBindingDict.get(commandName,[''])
            for shortcut in shortcutList:
                g.es('%s %s' % (commandName,k.prettyPrintKey(shortcut)),tabName='Completion')

    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060120105136.182">def computeInverseBindingDict (self):

    k = self ; d = {}
    
    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict.keys():
        bunchList = k.bindingsDict.get(shortcut,[])
        for b in bunchList:
            shortcutList = d.get(b.commandName,[])
            bunchList = k.bindingsDict.get(shortcut,[g.Bunch(pane='all')])
            for b in bunchList:
                # g.trace(shortcut,repr(b.pane))
                pane = g.choose(b.pane=='all','','[%s]' % (b.pane))
                s = '%s %s' % (k.prettyPrintKey(shortcut),pane)
                if s not in shortcutList:
                    shortcutList.append(s)
            d [b.commandName] = shortcutList

    return d</t>
<t tx="ekr.20060120105136.183">@ To do:
    
- inverseCommandsDict should be a list too.
- getShortcutForCommandName should return a list.</t>
<t tx="ekr.20060120105136.184">def _executeMacro (self,macro,w):

    k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('&lt;Key&gt;',keycode=z[0],keysym=z[1])
        else:
            meth = z [0].lstrip('&lt;').rstrip('&gt;')
            bunchList = k.bindingsDict.get(meth,[])  ### Probably should not strip &lt; and &gt;
            if bunchList:
                b = bunchList[0]
                ev = Tk.Event()
                ev.widget = w
                ev.keycode = z [1]
                ev.keysym = z [2]
                ev.char = z [3]
                k.masterCommand(ev,b.f,'&lt;%s&gt;' % meth)</t>
<t tx="ekr.20060120105136.185">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = stroke.lstrip('&lt;').rstrip('&gt;')
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)</t>
<t tx="ekr.20060120105136.186">def getShortcutForCommandName (self,commandName):
    
    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == commandName:
                    return key
    return ''
    
def getShortcutForCommand (self,command):
    
    k = self ; c = k.c
    
    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == command.__name__:
                    return key
    return ''</t>
<t tx="ekr.20060120105136.187">@nocolor

The fix is easy: extensionHelper resets movePoint any time there is no selection.

@color
</t>
<t tx="ekr.20060120105136.188">def extendHelper (self,w,extend,ins1,spot):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'&lt;',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        self.moveSpot = spot
        self.moveCol = int(spot.split('.')[1])
        g.app.gui.setTextSelection(w,spot,spot,insert=None)</t>
<t tx="ekr.20060120105136.189"></t>
<t tx="ekr.20060120105136.190">def traceBinding (self,bunch,shortcut,w):

    k = self ; c = k.c

    if not c.config.getBool('trace_bindings'): return
    
    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return
    
    pane_filter = c.config.getString('trace_bindings_pane_filter')
    
    if not pane_filter or pane_filter.lower() == bunch.pane:
         g.trace(bunch.pane,k.prettyPrintKey(shortcut),bunch.commandName,w._name)</t>
<t tx="ekr.20060120105136.191"></t>
<t tx="ekr.20060120105136.192">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-all', self.changeAllCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)</t>
<t tx="ekr.20060120105136.193">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget(['text','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
           </t>
<t tx="ekr.20060120105136.194">def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget(['text','all'],t) # Text *must* be in the list.
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("&lt;Control-t&gt;",self.onControlT)

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p=p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t</t>
<t tx="ekr.20060120105136.195">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
    t.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
    t.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("&lt;Button-4&gt;", PropagateButton4)
    t.bind("&lt;Button-5&gt;", PropagateButton5)
    t.bind("&lt;MouseWheel&gt;", PropagateMouseWheel)

</t>
<t tx="ekr.20060120105136.196">@nocolor

The fix was simply to call endUpdate() rather than endUpdate(changed) in onHeadChanged.
This should be safe: The change-all command could always enclose the code in begin/endUpdate.</t>
<t tx="ekr.20060120105136.197"></t>
<t tx="ekr.20060120105136.198"></t>
<t tx="ekr.20060120105136.199">def defineMenuCallback(self,command,name,minibufferCommand):
    
    if minibufferCommand:
        
        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')
        
        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label,event)
    
        return minibufferMenuCallback
        
    else:
    
        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label)
    
        return legacyMenuCallback</t>
<t tx="ekr.20060120105136.200"></t>
<t tx="ekr.20060120105136.201"></t>
<t tx="ekr.20060120105136.202"></t>
<t tx="ekr.20060120105136.203">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = False
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20060120105136.204">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20060120105136.205">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For saving and restoring focus.
self.afterUpdateWidgetStack = []

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20060120105136.206">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20060120105136.207">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20060120105136.208">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)</t>
<t tx="ekr.20060120105136.209">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20060120105136.210">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20060120105136.211">def destroyWindow (self,frame):
    
    # g.trace(frame in g.app.windowList,frame)
        
    g.app.destroyOpenWithFilesForFrame(frame)

    if frame in g.app.windowList:
        g.app.windowList.remove(frame)
        # g.trace(g.app.windowList)

    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()</t>
<t tx="ekr.20060120105136.212">def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    print 'skipping tag: c does not exists or does not have a frame.'
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result</t>
<t tx="ekr.20060120105136.213">@nocolor


- 
</t>
<t tx="ekr.20060120105136.214">The following would be major changes, with little benefit.

- Make leoGlobals a subclass of the commander.
    - There are many calls to to g.es in leoGlobals.py.

- Eliminate g.app.log.
    - It is dangerous, but g.es requires it.

- Eliminate g.scanErrors.
    - A laudable goal, but it's real messy.</t>
<t tx="ekr.20060120105136.215"># This includes k.masterCommand and all event handlers.
</t>
<t tx="ekr.20060120105136.216">def setLog (self,log):

    """set the frame to which log messages will go"""
    
    # print "setLog:",tag,"locked:",self.logIsLocked,log
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True
    
def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False</t>
<t tx="ekr.20060120105136.217">def setLog (self):
    
    c = self

    if c.exists:
        try:
            # c.frame or c.frame.log may not exist.
            g.app.setLog(c.frame.log)
        except AttributeError:
            pass</t>
<t tx="ekr.20060120105136.218"></t>
<t tx="ekr.20060120105136.219"></t>
<t tx="ekr.20060120105136.220">def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True</t>
<t tx="ekr.20060120105136.221">def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t</t>
<t tx="ekr.20060120105136.222">def edit_widget (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
    
edit_text = edit_widget # For compatibility.</t>
<t tx="ekr.20060120105136.223">def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    # 7/28/04: Not doing this translation was the real bug.
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId: return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None</t>
<t tx="ekr.20060120105136.224"># Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c
    
    if p and c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.visibleText.get(p.v,[])
        for p2,t2,id2 in pairs:
            assert t2.leo_window_id == id2
            assert t2.leo_position == p2
            if p.equal(p2):
                # g.trace('found',t2)
                return t2
        
    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20060120105136.225">def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
        
    
</t>
<t tx="ekr.20060120105136.226"></t>
<t tx="ekr.20060120105136.227">def onClickBoxClick (self,event):
    
    c = self.c
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
            if p.isExpanded(): p.contract()
            else:              p.expand()
            self.active = True
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060120105136.228"></t>
<t tx="ekr.20060120105136.229">def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.</t>
<t tx="ekr.20060120105136.230">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20060120105136.231"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)</t>
<t tx="ekr.20060120105136.232"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    c.setLog()
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"</t>
<t tx="ekr.20060120105136.233">def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20060120105136.234"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.</t>
<t tx="ekr.20060120105136.235">def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20060120105136.236">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20060120105136.237"></t>
<t tx="ekr.20060120105136.238">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20060120105136.239">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20060120105136.240">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20060120105136.241">def OnActivateHeadline (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(p.headString())

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20060120105136.242">if p == c.currentPosition():
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus()
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        c.frame.bodyWantsFocus()

self.active = True</t>
<t tx="ekr.20060120105136.243">def onTreeClick (self,event=None):
    
    c = self.c
    
    c.setLog()
    self.frame.treeWantsFocus()

    return 'break'</t>
<t tx="ekr.20060120105136.244"></t>
<t tx="ekr.20060120105136.245">def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20060120105136.246"># This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20060120105136.247">def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    # g.trace(p.headString())
    
    c.setLog()
    
    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headclick")

    return "continue"</t>
<t tx="ekr.20060120105136.248">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20060120105136.249">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        c.beginUpdate()
        try:
            tree.endEditLabel()
            tree.dimEditLabel()
        finally:
            c.endUpdate(False)</t>
<t tx="ekr.20060120105136.250">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20060120105136.251">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()</t>
<t tx="ekr.20060120105136.252">def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)</t>
<t tx="ekr.20060120105136.253">table = (
    ("&amp;Read @file Nodes",c.readAtFileNodes),
    ("&amp;Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&amp;Tangle",c.tangle),
    ("&amp;Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &amp;Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&amp;Paste Node",c.pasteOutline),
    ("&amp;Delete Node",c.deleteOutline),
    ("-",None),
    ("&amp;Insert Node",c.insertHeadline),
    ("&amp;Clone Node",c.clone),
    ("Sort C&amp;hildren",c.sortChildren),
    ("&amp;Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)</t>
<t tx="ekr.20060120105136.254">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20060120105136.255">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20060120105136.256">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.frame.widgetWantsFocus(menu)</t>
<t tx="ekr.20060120105136.257"># Leo now calls doCommand on all commands, so the 'command' hooks always get done.
# In addition, the normal processing in doCommand catches errors, etc.</t>
<t tx="ekr.20060120105136.258"></t>
<t tx="ekr.20060120105136.259">See this node in leoDocs.leo.

Users Guide--&gt;FAQ--&gt;@rst html\FAQ.html--&gt;Learning to use Leo--&gt;When is deleting a node dangerous?</t>
<t tx="ekr.20060120105136.260"></t>
<t tx="ekr.20060120105136.261">@nocolor</t>
<t tx="ekr.20060120105136.262">I use SciTE, but these keystrokes are quite common.
http://www.scintilla.org/SciTE.html

These now exist in 'EKR bindings: a mix...'

back-word                               ! text = Ctrl-LtArrow
back-word-extend-selection              ! text = Ctrl-Shift-LtArrow
beginning-of-line                       ! text = Home
beginning-of-line-extend-selection      ! text = Shift-Home
end-of-line                             ! text = End
end-of-line-extend-selection            ! text = Shift-End
forward-word                            ! text = Ctrl-RtArrow
forward-word-extend-selection           ! text = Ctrl-Shift-RtArrow
scroll-down                             ! text = PageDn
scroll-up                               ! text = PageUp

I added these, but the commands don't exist yet:

beginning-of-text                       ! text = Ctrl-Home
beginning-of-text-extend-selection      ! text = Ctrl-Shift-Home
end-of-text                             ! text = Ctrl-End
end-of-text-extend-selection            ! text = Ctrl-Shift-End
scroll-down-extend-selection            ! text = Shift-PageDn
scroll-up-extend-selection              ! text = Shift-PageUp

Manfred
marl@pragmatis.de
www.pragmatis.de</t>
<t tx="ekr.20060120105136.263">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3518387

Here are the changes I made to get back to my old Leo:

back-word                               = Ctrl-LtArrow
back-word-extend-selection              = Shift-Ctrl-LtArrow
beginning-of-buffer                     = Ctrl-Home
beginning-of-buffer-extend-selection    = Shift-Ctrl-Home
beginning-of-line                       = Home
beginning-of-line-extend-selection      = Shift-Home
delete-char                             = Delete
end-of-buffer                           = Ctrl-End
end-of-buffer-extend-selection          = Shift-Ctrl-End
end-of-line                             = End
end-of-line-extend-selection            = Shift-End
forward-word                            = Ctrl-RtArrow
forward-word-extend-selection           = Shift-Ctrl-RtArrow
scroll-down                             = PageDn
scroll-up                               = PageUp
</t>
<t tx="ekr.20060120105136.264"></t>
<t tx="ekr.20060120105136.265"></t>
<t tx="ekr.20060120105136.266">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3518792

EKR: The change in focus happened in c.endEditing in at.writeFromString.

I added a new restoreFocus keyword arg to c.endEditing.</t>
<t tx="ekr.20060120105136.267"># Ends the editing in the outline.

def endEditing(self,restoreFocus=False):
    
    c = self ; tree = c.frame.tree
    
    if restoreFocus:
        w = g.app.gui.get_focus(c.frame)
        tree.endEditLabel()
        c.frame.widgetWantsFocus(w)
    else:
        tree.endEditLabel()</t>
<t tx="ekr.20060120105136.268"># This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing(restoreFocus=True) # Capture the current headline, but don't change the focus!

    at.initWriteIvars(root,"&lt;string-file&gt;",
        nosentinels=False,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=False,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput</t>
<t tx="ekr.20060120105136.269"></t>
<t tx="ekr.20060120105136.270">@nocolor

Later

open-outline-by-name

https://sourceforge.net/forum/message.php?msg_id=3519444

write-rst
execute-unit-tests</t>
<t tx="ekr.20060120105136.271">def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20060120105136.272">def scrollDown (self,event):
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    self.scrollHelper(event,'up',extend=True)</t>
<t tx="ekr.20060120105136.273">def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)

    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    row, col = ins1.split('.') ; row = int(row) ; col = int(col)

    # Compute the spot.
    chng = self.measure(w) ; delta = chng [0]
    row1 = g.choose(direction=='down',row+delta,row-delta)
    spot = w.index('%d.%d' % (row1,col))
    w.mark_set('insert',spot)

    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot)
    w.see('insert')</t>
<t tx="ekr.20060120105136.274"></t>
<t tx="ekr.20060120105136.275">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3515616

Could we have a visible-line-up and visible-line-down command? (I.e. to move
the cursor up or down by a visible rather than a logical line).  With these
commands, the arrows plugin could be permanently retired!

What I did:

- next-line and prev-line now work as requested.  This obsoletes the arrow plugin.
    - Removed the redundant tree.OnUpKey and tree.OnDownKey
    - Retired the arrows plugin.

- Created the extendHelper method.
    This creates and maintains the moveSpot, moveCol an moveSpotNode ivars,
    and is responsible for extending the selection range.</t>
<t tx="ekr.20060120105136.276">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20060120105136.277">def moveUpDown (self,direction):
    c = self.c ; body = c.frame.bodyCtrl
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = g.scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y &gt;= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width/2: x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    g.trace("entry:  %s.%s" % (lines,char),'result',result,'insert',body.index('insert'))
    return "break" # Inhibit further bindings.</t>
<t tx="ekr.20060120105136.278"></t>
<t tx="ekr.20060120105136.279"></t>
<t tx="ekr.20060120105136.280">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y &gt;= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col &gt;= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot)</t>
<t tx="ekr.20060120105136.281">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.frame.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20060120105136.282">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060120105136.283">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060120105136.284">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    ins = w.index('insert')
    # sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20060120105136.285">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060120105136.286">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20060120105136.287">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20060120105136.288">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060120105136.289">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20060120105136.290">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20060120105136.291">def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveUpOrDownHelper(event,'down',extend=False)
    # self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveUpOrDownHelper(event,'down',extend=True)
    #self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveUpOrDownHelper(event,'up',extend=False)
    #self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveUpOrDownHelper(event,'up',extend=True)
    #self.moveToHelper(event,'insert - 1line',extend=True)</t>
<t tx="ekr.20060120105136.292">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20060120105136.293">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20060120105136.294">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20060120105136.295">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20060120105136.296">The fix was to add the 'text' specifier to the call to copyBindingsToWidget in tree.setTabBindings.</t>
<t tx="ekr.20060120105136.297"></t>
<t tx="ekr.20060120105136.298"></t>
<t tx="ekr.20060120105136.299">Specify what mode to enter after each command:

- command-name -&gt; mode-name = binding

will specify what mode to enter after each command.
At present, all commands exit to the top-level mode.

- Add @string active-keyset setting?</t>
<t tx="ekr.20060120105136.300"></t>
<t tx="ekr.20060120105136.301">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict
    
    # g.trace(modeDict.keys())

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060120105136.302">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Change the pane of all entries to 'mode-name'.
    # This will disable warnings about duplicate bindings.
    for key in d2.keys():
        bunchList = d2.get(key,[])
        for bunch in bunchList:
            bunch.pane = name
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060120105136.303"></t>
<t tx="ekr.20060120105136.304">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
</t>
<t tx="ekr.20060120105136.305">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c

    if k.inputModeName:
        commandName = 'enter-' + k.inputModeName
        d = g.app.config.modeCommandsDict.get(commandName)
        k.modeHelpHelper(d)
    else:
        k.printBindings(event)

    return 'break'




</t>
<t tx="ekr.20060120105136.306">def modeHelpHelper (self,d):
    
    k = self ; c = k.c
    
    c.frame.log.clearTab('Mode')
    lines = []
    for key in d.keys():
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                lines.append('%-30s\t%s' % (key,k.prettyPrintKey(shortcut)))
    lines.sort()
    for line in lines:
        g.es(line,tabName='Mode')</t>
<t tx="ekr.20060120105136.307">def generalModeHandler (self,event,
    bunch=None,commandName=None,func=None,modeName=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    # modeName = modeName or k.inputModeName or ''
    state = k.getState(modeName)
   
    if state == 0:
        # g.trace(modeName,state)
        k.modeWidget = event and event.widget
        if c.config.getBool('showHelpWhenEnteringModes'):
            d = g.app.config.modeCommandsDict.get('enter-'+modeName)
            k.modeHelpHelper(d)
        self.initMode(event,modeName)
        k.setState(modeName,1,handler=k.generalModeHandler)
    elif not func:
        g.trace('No func: improper key binding')
    else:
        # g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            nextMode = bunch.nextMode
            self.endMode(event)
            func(event)
            if nextMode == 'none':
                # Do *not* clear k.inputModeName here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.initMode(event,modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'
</t>
<t tx="ekr.20060120105136.308">def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)</t>
<t tx="ekr.20060120105136.309">def createModeBindings (self,modeName,tagName,d):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if func:
            bunchList = d.get(commandName,[])
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut and shortcut not in ('None','none',None):
                    stroke, junk = c.frame.menu.canonicalizeShortcut(shortcut)
                    # g.trace(stroke,shortcut)
                    &lt;&lt; define modeCallback &gt;&gt;
        else:
            g.trace('No such command: %s' % commandName)

    &lt;&lt; define modeHelpCallback &gt;&gt;</t>
<t tx="ekr.20060120105136.310"># g.trace('Mode %s: binding %s to %s' % (modeName,stroke,commandName))

def modeCallback (event,k=k,
    bunch=bunch,commandName=commandName,func=func,modeName=modeName,stroke=stroke):
        
    __pychecker__ = '--no-argsused' # stroke
    
    # g.trace(stroke)
    return k.generalModeHandler(event,bunch,commandName,func,modeName)

# k.bindKey('all',stroke,modeCallback,commandName)

t.bind_class(tagName,stroke,modeCallback)
</t>
<t tx="ekr.20060120105136.311">def modeHelpCallback (event,k=k,d=d):
    
    if event and event.char != '': # and not special:
        return k.modeHelpHelper(d)
    else:
        return 'break'

# k.bindKey('all',stroke,modeHelpCallback,commandName)

t.bind_class(tagName,'&lt;Key&gt;',modeHelpCallback)</t>
<t tx="ekr.20060120105136.312">def initMode (self,event,modeName):

    k = self ; c = k.c
    k.inputModeName = modeName
    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
        
    t = c.frame.body.bodyCtrl
    k.savedBindtags = t.bindtags()
    tagName = '%s-%s' % (modeName,c.fileName())
    t.bindtags(tuple([tagName]))
    # g.trace(modeName,tagName,t.bindtags())
        
    # Note: we much create separate bindings for each commander.
    modeBindings = k.bindtagsDict.get(tagName)
    if not modeBindings:
        # g.trace('created mode bindings: %s' % (tagName))
        k.createModeBindings(modeName,tagName,d)
        k.bindtagsDict[tagName] = True

    k.setLabelBlue(modeName+': ',protect=True)
    c.frame.minibufferWantsFocus()</t>
<t tx="ekr.20060120105136.313">def endMode(self,event):
    
    k = self ; c = k.c

    # Restore the bind tags.
    t = c.frame.body.bodyCtrl
    t.bindtags(k.savedBindtags)

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    # k.setLabelGrey('top-level mode')
    c.frame.widgetWantsFocus(k.modeWidget)</t>
<t tx="ekr.20060120105136.314"></t>
<t tx="ekr.20060120105136.315">def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return

    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    k.inputModeName = None
        
    k.clearState()
    k.resetLabel()
    
    k.setDefaultUnboundKeyAction()
    c.endEditing()
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20060120105136.316">def setIgnoreMode (self,event):

    self.setMode('ignore')

def setInsertMode (self,event):

    self.setMode('insert')

def setOverwriteMode (self,event):

    self.setMode('overwrite')

def setMode (self,mode):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    tag = k.plainKeyTag()
    try: # Will fail for nullBody.
        w = g.app.gui.get_focus(c.frame)
        tags = t.bindtags()
        tags = list(tags)
        # g.trace('1',mode,'plain-keys:',tag in tags)
    except AttributeError:
        tags = []
        w = None
        
    if tags:
        if mode == 'ignore':
            if tag not in tags:
                tags.insert(0,tag)
                t.bindtags(tuple(tags))
        else:
            if tag in tags:
                tags.remove(tag)
                t.bindtags(tuple(tags))
    # g.trace('2',mode,'plain-keys:',tag in tags)

    self.unboundKeyAction = mode
    frame = self.c.frame
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        frame.putStatusLine('input mode: ',color='blue')
        frame.putStatusLine(mode)
    # These commands never change focus.
    w and c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060120105136.317">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setMode(self.unboundKeyAction)</t>
<t tx="ekr.20060206111431"></t>
<t tx="ekr.20060206111431.1"></t>
<t tx="ekr.20060206111431.2">@nocolor

Must check for c.exists in c.executeScript after executing the script.</t>
<t tx="ekr.20060206111431.3">@nocolor

- keyboard-quit now ends editing.

- print-bindings shows plain keys only in 'ignore' mode.

- Removed k.add_ekr_altx_commands and k.makeHardBindings.

- Added binding to vim plain shortcuts: mode-help = h

- Print the initial mode when first creating a window.
  The change had to be made in g.openWithFileName because of the UNL plugin.

- Improved print-bindings &amp; mode help.

- endMode retains the widget on entry, so e.g., inserting a new node retaings the headline editing state.

@color
</t>
<t tx="ekr.20060206111431.4">@nocolor

- Added initialClickExpandsOrContractsNode settings.  Clicking an node expands or contracts the node if this setting is True.  EKR much prefers False. 

- Selecting a headline should not select text in it.

@color
</t>
<t tx="ekr.20060206111431.5"></t>
<t tx="ekr.20060206111431.6">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20060206111431.7">def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20060206111431.8">def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20060206111431.9">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060206111431.10">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color") or 'white'
    selbg = c.config.getColor("headline_text_editing_selection_background_color") or 'black'
    
    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060206111431.11">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20060206111431.12">def onClickBoxClick (self,event):
    
    c = self.c ; p1 = c.currentPosition()
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing()
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.13">@nocolor

What I did:
    
- endMode must not change focus.

- modeHelp calls c.endEditing(retainFocus=True)

@color</t>
<t tx="ekr.20060206111431.14">def printBindings (self,event,brief=False):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)

    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if not brief or k.isPlainKey(key):
                pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
                s1 = pane
                s2 = k.prettyPrintKey(key)
                s3 = b.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
    # This isn't perfect in variable-width fonts.
    for s1,s2,s3 in data:
        g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
                   
    state = k.unboundKeyAction 
    k.showStateAndMode()</t>
<t tx="ekr.20060206111431.15">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None
    
    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060206111431.16"># Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060206111431.17">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060206111431.18">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060206111431.19">def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060206111431.20"></t>
<t tx="ekr.20060206111431.21">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20060206111431.22">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20060206111431.23"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20060206111431.24"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20060206111431.25"></t>
<t tx="ekr.20060206111431.26">def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)</t>
<t tx="ekr.20060206111431.27">def createModeBindings (self,modeName,d):
    
    k = self ; c = k.c

    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if not func:
            g.trace('No such command: %s' % commandName) ; continue
        bunchList = d.get(commandName,[])
        for bunch in bunchList:
            stroke = bunch.val
            # Important: bunch.val is a stroke returned from k.strokeFromSetting.
            # Do not call k.strokeFromSetting again here!
            if stroke and stroke not in ('None','none',None):
                if 0:
                    g.trace(
                        modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        bunch.nextMode)
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.Bunch(
                    commandName=commandName,
                    func=func,
                    nextMode=bunch.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2</t>
<t tx="ekr.20060206111431.28">def endMode(self,event):
    
    k = self ; c = k.c ; w = c.get_focus()

    c.frame.log.deleteTab('Mode')

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()

    # k.setLabelGrey('top-level mode')
    
    # Do *not* change the focus: the command may have changed it.
    c.widgetWantsFocus(w)</t>
<t tx="ekr.20060206111431.29">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
</t>
<t tx="ekr.20060206111431.30">def exitNamedMode (self,event):
    
    k = self

    if k.inState():
        k.endMode(event)
    
    k.showStateAndMode()
</t>
<t tx="ekr.20060206111431.31">def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c ;  w = c.get_focus()
    state = k.getState(modeName)
    trace = c.config.getBool('trace_modes')
    
    if trace: g.trace(modeName,state)
   
    if state == 0:
        self.initMode(event,modeName)
        k.inputModeName = modeName
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.hideTab('Mode')
        if k.useTextWidget:
            c.minibufferWantsFocus()
        else:
            c.widgetWantsFocus(w)
    elif not func:
        g.trace('No func: improper key binding')
        return 'break'
    else:
        if trace: g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            # nextMode = bunch.nextMode
            self.endMode(event)
            if c.config.getBool('trace_doCommand'):
                g.trace(func.__name__)
            func(event)
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.reinitMode(modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'</t>
<t tx="ekr.20060206111431.32">def initMode (self,event,modeName):

    k = self ; c = k.c

    if not modeName:
        g.trace('oops: no modeName')
        return

    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
    else:
        k.modeBindingsDict = d
        
    k.inputModeName = modeName
    k.modeWidget = c.get_focus()
    
    if k.masterBindingsDict.get(modeName) is None:
        k.createModeBindings(modeName,d)
   
    k.setLabelBlue(modeName+': ',protect=True)
    k.showStateAndMode()
    if k.useTextWidget:
        c.minibufferWantsFocus()
    else:
        pass # Do *not* change the focus here!</t>
<t tx="ekr.20060206111431.33">def reinitMode (self,modeName):
    
    k = self ; c = k.c

    d = k.modeBindingsDict
    
    k.inputModeName = modeName
    k.createModeBindings(modeName,d)
    
    # Do not set the status line here.
    k.setLabelBlue(modeName+': ',protect=True)

    if k.useTextWidget:
        c.minibufferWantsFocus()
    else:
        pass # Do *not* change the focus here!</t>
<t tx="ekr.20060206111431.34">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c

    c.endEditing()
    
    g.trace(k.inputModeName)
    
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
        
    if k.useTextWidget:
        c.minibufferWantsFocus()

    return 'break'</t>
<t tx="ekr.20060206111431.35">def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key ; s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
                
    data.sort()
    
    # g.es('%s\n\n' % (k.inputModeName),tabName=tabName)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s %s' % (n,s1,s2),tabName=tabName)</t>
<t tx="ekr.20060206111431.36">def setIgnoreState (self,event):

    self.setInputState('ignore',showState=True)

def setInsertState (self,event):

    self.setInputState('insert',showState=True)

def setOverwriteState (self,event):

    self.setInputState('overwrite',showState=True)

</t>
<t tx="ekr.20060206111431.37">def setInputState (self,state,showState=False):

    k = self ; c = k.c ; w = c.get_focus()

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()
   
    # These commands never change focus.
    w and c.widgetWantsFocus(w)</t>
<t tx="ekr.20060206111431.38">def showStateAndMode(self):
    
    k = self ; frame = k.c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
</t>
<t tx="ekr.20060206111431.39"></t>
<t tx="ekr.20060206111431.40"></t>
<t tx="ekr.20060206111431.41">def universalArgument (self,event):
    
    '''Begin a numeric argument for the following command.'''
    
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)
    
def digitArgument (self,event):

    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)</t>
<t tx="ekr.20060206111431.42">def hideMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.hideMinibuffer()
    
    g.es('Minibuffer hidden',color='red')

    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('%s is bound to: %s' % (commandName,shortcut))
    
    
def showMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.showMinibuffer()
    
def toggleMinibuffer (self,event):
    
    k = self ; c = k.c
    
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)</t>
<t tx="ekr.20060206111431.43">def negativeArgument (self,event):

    k = self ; state = k.getState('neg-arg')

    if state == 0:
        k.setLabelBlue('Negative Argument: ',protect=True)
        k.setState('neg-arg',1,k.negativeArgument)
    else:
        k.clearState()
        k.resetLabel()
        func = k.negArgFunctions.get(k.stroke)
        if func:
            func(event)

    return 'break'</t>
<t tx="ekr.20060206111431.44">def numberCommand (self,event,stroke,number):

    k = self ; k.stroke = stroke ; w = event.widget

    k.universalDispatcher(event)
    w.event_generate('&lt;Key&gt;',keysym=number)

    return 'break'

def numberCommand0 (self,event): return self.numberCommand (event,None,0)
def numberCommand1 (self,event): return self.numberCommand (event,None,1)
def numberCommand2 (self,event): return self.numberCommand (event,None,2)
def numberCommand3 (self,event): return self.numberCommand (event,None,3)
def numberCommand4 (self,event): return self.numberCommand (event,None,4)
def numberCommand5 (self,event): return self.numberCommand (event,None,5)
def numberCommand6 (self,event): return self.numberCommand (event,None,6)
def numberCommand7 (self,event): return self.numberCommand (event,None,7)
def numberCommand8 (self,event): return self.numberCommand (event,None,8)
def numberCommand9 (self,event): return self.numberCommand (event,None,9)</t>
<t tx="ekr.20060206111431.45">def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'
    
    c.frame.log.clearTab(tabName)
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    data = [] ; n1 = 4 ; n2 = 20
    for commandName in commandNames:
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            s1 = pane
            s2 = k.prettyPrintKey(key)
            s3 = commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)
                
    # This isn't perfect in variable-width fonts.
    for s1,s2,s3 in data:
        g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
</t>
<t tx="ekr.20060206111431.46">def repeatComplexCommand (self,event):

    k = self

    if k.mb_history:
        k.setState('last-full-command',1,handler=k.doLastAltX)
        k.setLabelBlue("Redo: %s" % k.mb_history[0])
    return 'break'
    
def doLastAltX (self,event):
    
    k = self ; c = k.c

    if event.keysym == 'Return' and k.mb_history:
        last = k.mb_history [0]
        c.commandsDict [last](event)
        return 'break'
    else:
        return k.keyboardQuit(event)</t>
<t tx="ekr.20060206111431.47">
</t>
<t tx="ekr.20060206111431.48">Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 250, in doCommand
    val = command() # Call legacy command

  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 1777, in cutText
    oldText = w.get('1.0','end')

AttributeError: Canvas instance has no attribute 'get'</t>
<t tx="ekr.20060206111431.49"></t>
<t tx="ekr.20060206111431.50">def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20060206111431.51">def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20060206111431.52">def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    # g.trace(name)
    
    singleLine = name.startswith('head') or name.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif singleLine:
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        if name.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            w.configure(width=f.tree.headWidth(s=s))
    else:
        pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060206111431.53"></t>
<t tx="ekr.20060206111431.54"># Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):
    
    f = self ; c = f.c
    
    if c.inCommand:
        g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)</t>
<t tx="ekr.20060206111431.55">def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
        
    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        w.c.setLog()
        w.c.bodyWantsFocus()
    else:
        g.app.finishQuit()

    return True # The window has been closed.</t>
<t tx="ekr.20060206111431.56">command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and (
        c.config.getBool('trace_doCommand') or
        c.config.getBool('trace_gc') and (self.command_count % 10) == 0
    ):
        commandName = command and command.__name__
        if (self.command_count % 10) == 0:
            w = c.get_focus() ; wname = c.widget_name(w)
            g.printGcSummary('doCommand: %s %s' % (commandName,wname),trace=True)
        else:
            g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            c.inCommand = False
            if c and c.exists: # Be careful: the command could destroy c.
                c.k.funcReturn = val
        except:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es("exception executing command")
                print "exception executing command"
                g.es_exception(c=c)
                if c and c.exists and hasattr(c,'frame'):
                    c.redraw_now()
                    
        if c and c.exists and c.requestCloseWindow:
            g.trace('Closing window after command')
            c.requestCloseWindow = False
            g.app.closeLeoWindow(c.frame)

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20060206111431.57"></t>
<t tx="ekr.20060206111431.58"></t>
<t tx="ekr.20060206111431.59">def prettyPrintKey (self,stroke):
    
    s = stroke.strip().lstrip('&lt;').rstrip('&gt;')
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '&lt;%s&gt;' % s</t>
<t tx="ekr.20060206111431.60"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):
    
    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        data = [] ; n1 = 20; n2 = 4
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1 = commandName
                s2 = pane
                s3 = k.prettyPrintKey(key)
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)

    c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.61">def computeInverseBindingDict (self):

    k = self ; d = {}
    
    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict.keys():
        bunchList = k.bindingsDict.get(shortcut,[])
        for b in bunchList:
            shortcutList = d.get(b.commandName,[])
            bunchList = k.bindingsDict.get(shortcut,[g.Bunch(pane='all')])
            for b in bunchList:
                #pane = g.choose(b.pane=='all','','%s:' % (b.pane))
                pane = '%s:' % (b.pane)
                data = (pane,shortcut)
                if data not in shortcutList:
                    shortcutList.append(data)
        
            d [b.commandName] = shortcutList

    return d</t>
<t tx="ekr.20060206111431.62"></t>
<t tx="ekr.20060206111431.63"></t>
<t tx="ekr.20060206111431.64">master_key_count = 0

def masterKeyHandler (self,event):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event)
    c.frame.updateStatusLine()
    return val</t>
<t tx="ekr.20060206111431.65">def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler')
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('tree','head'), ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060206111431.66">def masterClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)
        
    # Oh joy: no more need for an idle-time or timed call.
    c.frame.updateStatusLine()
        
    if k.inState('full-command') and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        g.es_print('Ignoring click outside active minibuffer',color='blue')
        c.minibufferWantsFocus()
        return 'break'

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        return None
        
masterClick3Handler         = masterClickHandler
masterDoubleClick3Handler   = masterClickHandler</t>
<t tx="ekr.20060206111431.67">def masterDoubleClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        i = w.index("@%d,%d" % (event.x,event.y))
        g.app.gui.setTextSelection(w,i+' wordstart',i+' wordend')
        return 'break'</t>
<t tx="ekr.20060206111431.68">def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    
    if 1:
        if not g.app.unitTesting:
            g.trace(c.widget_name(w))
    
    return k.masterCommand(event,func,stroke,commandName)</t>
<t tx="ekr.20060206111431.69">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
   
    c.beginUpdate()
    try:
        tree.endEditLabel()
        tree.dimEditLabel()
    finally:
        c.endUpdate(False)</t>
<t tx="ekr.20060206111431.70">def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.setLog()
        w = c.get_focus()
        if w != c.frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        c.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'</t>
<t tx="ekr.20060206111431.71">def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
    
    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")</t>
<t tx="ekr.20060206111431.72">def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            if event: # Prevent wandering insertion point.
                index = "@%d,%d" % (event.x, event.y) # Find where we clicked.
                w = self.bodyCtrl
                start = w.index(index + " wordstart")
                end   = w.index(index + " wordend")
                self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.</t>
<t tx="ekr.20060206111431.73">Call w.see('insert'), not w.see('insert-5L')</t>
<t tx="ekr.20060206111431.74"></t>
<t tx="ekr.20060206111431.75"></t>
<t tx="ekr.20060206111431.76">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20060206111431.77">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20060206111431.78">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.keysym_numberDict = {}
    # Keys are keysym_num's.  Values are strokes.
self.keysym_numberInverseDict = {}
    # Keys are strokes, values are keysym_num's.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20060206111431.79">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)


# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For getArg...


# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}</t>
<t tx="ekr.20060206111431.80"></t>
<t tx="ekr.20060206111431.81">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = c.get_focus()
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060206111431.82">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.keyboardQuit(event)
        k.setLabel('Command does not exist: %s' % commandName)
        c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.83">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20060206111431.84">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060206111431.85">def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = nextMode = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
    
    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'-&gt;'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]
        if not nextMode.strip(): nextMode = 'none'
    else: nextMode = 'none'
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)</t>
<t tx="ekr.20060206111431.86"></t>
<t tx="ekr.20060206111431.87">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = shortcut.strip().lstrip('&lt;').rstrip('&gt;')
        # if shortcut.startswith('&lt;Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility</t>
<t tx="ekr.20060206111431.88">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            shortcut,
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060206111431.89">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)</t>
<t tx="ekr.20060206111431.90">def bindKeyToDict (self,pane,stroke,func,commandName):
    
    k = self
    d =  k.masterBindingsDict.get(pane,{})
    
    stroke = stroke.lstrip('&lt;').rstrip('&gt;')
    
    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__)) # ,len(d.keys()))

    if d.get(stroke):
        g.es('ignoring duplicate definition of %s to %s in %s' % (
            stroke,commandName,pane), color='blue')
    else:
        d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
        k.masterBindingsDict [pane] = d</t>
<t tx="ekr.20060206111431.91">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c
    
    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)
    
    return k.bindKey('all',shortcut,openWithCallback,'open-with')</t>
<t tx="ekr.20060206111431.92">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20060206111431.93">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.checkBindings()</t>
<t tx="ekr.20060206111431.94">def initSpecialIvars (self):
    
    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c ; trace = c.config.getBool('trace_bindings')
    
    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found:
            g.trace('no setting for %s' % commandName)</t>
<t tx="ekr.20060206111431.95">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)</t>
<t tx="ekr.20060206111431.96"></t>
<t tx="ekr.20060206111431.97">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20060206111431.98">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20060206111431.99">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20060206111431.100"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20060206111431.101">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20060206111431.102">The outline jumps around too much when expanding/contracting nodes
</t>
<t tx="ekr.20060206111431.103"></t>
<t tx="ekr.20060206111431.104">def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag,scroll=False):
    
    self.updateCount -= 1
    if self.updateCount &lt;= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount &lt; 0:
            g.trace("Can't happen: negative updateCount")</t>
<t tx="ekr.20060206111431.105"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    self.redrawCount += 1
    
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.redrawCount % 5) == 0:
            g.printGcSummary(trace=True)

    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        g.print_stats()
        g.clear_stats()

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20060206111431.106">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20060206111431.107">def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount</t>
<t tx="ekr.20060206111431.108"></t>
<t tx="ekr.20060206111431.109">def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId</t>
<t tx="ekr.20060206111431.110">def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20060206111431.111">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060206111431.112">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20060206111431.113">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20060206111431.114">def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
</t>
<t tx="ekr.20060206111431.115">def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if 0:
        if self.trace and self.verbose:
            print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20060206111431.116">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20060206111431.117">def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        &lt;&lt; highlight text widget on enter events &gt;&gt;
   
    self.configureTextState(p)

    return self.line_height</t>
<t tx="ekr.20060206111431.118"># t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20060206111431.119">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20060206111431.120">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20060206111431.121">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20060206111431.122">pass</t>
<t tx="ekr.20060206111431.123">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p
    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20060206111431.124">pass</t>
<t tx="ekr.20060206111431.125">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        self.redrawCount += 1
        print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %-3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta),g.callers())
        
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
        
    if self.stats: self.showStats()
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20060206111431.126">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20060206111431.127"></t>
<t tx="ekr.20060206111431.128">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20060206111431.129">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20060206111431.130">def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.</t>
<t tx="ekr.20060206111431.131">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20060206111431.132">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20060206111431.133">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20060206111431.134">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20060206111431.135"># This is required now that scrolling is disabled by default.</t>
<t tx="ekr.20060206111431.136">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    gui.setInsertPoint(t,insert)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos)
    if self.reverse:
        gui.setInsertPoint(t,pos)
    gui.makeIndexVisible(t,insert)
    c.widgetWantsFocus(t)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20060206111431.137"># Added max_undo_stack_size setting.</t>
<t tx="ekr.20060206111431.138">class baseUndoer:
    """The base class of the undoer class."""
    @others
    
class undoer (baseUndoer):
    """A class that implements unlimited undo and redo."""
    pass</t>
<t tx="ekr.20060206111431.139">def __init__ (self,c):
    
    u = self ; u.c = c

    u.debug = False # True: enable debugging code in new undo scheme.
    u.debug_print = False # True: enable print statements in debug code.

    u.granularity = c.config.getString('undo_granularity')
    if u.granularity: u.granularity = u.granularity.lower()
    if u.granularity not in ('node','line','word','char'):
        u.granularity = 'line'
    # g.trace('undoer',u.granularity)
    
    u.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if u.debug is on).
    u.new_mem = 0
    u.old_mem = 0

    # State ivars...
    u.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    u.redoMenuLabel = "Can't Redo"
    u.undoMenuLabel = "Can't Undo"
    u.realRedoMenuLabel = "Can't Redo"
    u.realUndoMenuLabel = "Can't Undo"
    u.undoing = False # True if executing an Undo command.
    u.redoing = False # True if executing a Redo command.
    
    # New in 4.2...
    u.optionalIvars = []
</t>
<t tx="ekr.20060206111431.140">def clearIvars (self):
    
    u = self
    
    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)</t>
<t tx="ekr.20060206111431.141"></t>
<t tx="ekr.20060206111431.142">def cutStack (self):
    
    u = self ; n = u.max_undo_stack_size

    if n &gt; 0 and u.bead &gt;= n and not g.app.unitTesting:
        
        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i &gt;= 0:
            bunch = u.beads[i]
            if bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))</t>
<t tx="ekr.20060206111431.143">def getBead (self,n):
    
    '''Set undoer ivars from the bunch at the top of the undo stack.'''
    
    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)
    
    return bunch</t>
<t tx="ekr.20060206111431.144">def peekBead (self,n):
    
    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch</t>
<t tx="ekr.20060206111431.145">def pushBead (self,bunch):
    
    u = self
    
    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead &gt;= 0 and u.bead &lt; len(u.beads) and u.beads[u.bead]

    if bunch2 and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

        # Recalculate the menu labels.
        u.setUndoTypes()
</t>
<t tx="ekr.20060206111431.146">def setIvarsFromBunch (self,bunch):
    
    u = self

    u.clearIvars()

    if 0: # Debugging.
        print '-' * 40
        keys = bunch.keys()
        keys.sort()
        for key in keys:
            g.trace(key,bunch.get(key))
        print '-' * 20

    for key in bunch.keys():
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)</t>
<t tx="ekr.20060206111431.147">def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    ws = string.whitespace

    if 1: # This seems like the best way.
        # Start a word if new_ch begins whitespace + word
        return old_ch not in ws and new_ch in ws

    if 0: # Problems with punctuation within words.
        return old_ch in ws and new_ch not in ws

    if 0: # Problems with punctuation within words.
        word_chars = string.letters + string.digits + '_'
        return new_ch in word_chars and not old_ch in word_chars
        
    else: return False # Keeps Pychecker happy.</t>
<t tx="ekr.20060206111431.148">def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name</t>
<t tx="ekr.20060206111431.149"># These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    # g.trace(theType,g.callers(7))
    u = self ; frame = u.c.frame
    
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    
    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel

def setUndoType (self,theType):
    # g.trace(theType,g.callers(7))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel</t>
<t tx="ekr.20060206111431.150">def setUndoTypes (self):
    
    u = self
    
    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")
    
    u.cutStack()</t>
<t tx="ekr.20060206111431.151">def restoreTree (self,treeInfo):
    
    """Use the tree info to restore all vnode and tnode data,
    including all links."""
    
    u = self
    
    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)</t>
<t tx="ekr.20060206111431.152">def restoreVnodeUndoInfo (self,bunch):
    
    """Restore all ivars saved in the bunch."""
    
    v = bunch.v

    v.statusBits = bunch.statusBits
    v._parent    = bunch.parent
    v._next      = bunch.next
    v._back      = bunch.back
    
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA</t>
<t tx="ekr.20060206111431.153">def restoreTnodeUndoInfo (self,bunch):
    
    t = bunch.t

    t.headString  = bunch.headString
    t.bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits
    t._firstChild = bunch.firstChild
    
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA</t>
<t tx="ekr.20060206111431.154">def saveTree (self,p,treeInfo=None):
    
    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    &lt;&lt; about u.saveTree &gt;&gt;
    
    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
</t>
<t tx="ekr.20060206111431.155">@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.</t>
<t tx="ekr.20060206111431.156">def createVnodeUndoInfo (self,v):
    
    """Create a bunch containing all info needed to recreate a vnode for undo."""
    
    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parent     = v._parent,
        next       = v._next,
        back       = v._back,
        # The tnode never changes so there is no need to save it here.
    )
    
    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch</t>
<t tx="ekr.20060206111431.157">def createTnodeUndoInfo (self,t):
    
    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t.headString,
        bodyString = t.bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
        firstChild = t._firstChild,
    )
    
    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch</t>
<t tx="ekr.20060206111431.158">def trace (self):
    
    ivars = ('kind','undoType')
    
    for ivar in ivars:
        print ivar, getattr(self,ivar)
    </t>
<t tx="ekr.20060206111431.159">def updateMarks (self,oldOrNew):
    
    '''Update dirty and marked bits.'''
    
    u = self
    
    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    dirty   = g.choose(isOld,u.oldDirty,  u.newDirty)
    marked  = g.choose(isOld,u.oldMarked, u.newMarked)
    changed = g.choose(isOld,u.oldChanged,u.newChanged)

    if dirty:   u.p.setDirty(setDescendentsDirty=False)
    else:       u.p.clearDirty()
        
    if marked:  u.p.setMarked()
    else:       u.p.clearMarked()

    u.c.setChanged(changed)
</t>
<t tx="ekr.20060206111431.160"></t>
<t tx="ekr.20060206111431.161"></t>
<t tx="ekr.20060206111431.162">def afterChangeGroup (self,p,command,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''
    
    u = self ; body = u.c.frame.body
    if u.redoing or u.undoing: return
    
    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types &amp; helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = command
    
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newP = p.copy()
    bunch.newSel = body.getTextSelection()
    
    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag
    
    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
    
    # g.trace(u.undoMenuLabel,u.redoMenuLabel)</t>
<t tx="ekr.20060206111431.163">def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''
    
    u = self ; body = u.c.frame.body
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents
    
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.bodyString()
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.headString()
    bunch.newMarked = p.isMarked()
    bunch.newSel = body.getTextSelection()
    
    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.164">def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''
    
    u = self ; body = u.c.frame.body
    if u.redoing or u.undoing: return
    
    # Set the types &amp; helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = body.getTextSelection()
    bunch.newText = body.getAllText()
    bunch.newTree = u.saveTree(p)
    
    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.165">def afterClearRecentFiles (self,bunch):
    
    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]
    
    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles
    
    u.pushBead(bunch)

    return bunch</t>
<t tx="ekr.20060206111431.166">def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self
    if u.redoing or u.undoing: return
    
    # Set types &amp; helpers
    bunch.kind = 'clone'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = p.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.167">def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
    # Set types &amp; helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.168">def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self
    if u.redoing or u.undoing: return
    
    # Set types &amp; helpers
    bunch.kind = 'delete'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = p.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.169">def afterHoist (self,p,command):
    
    u = self
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
    # Set types &amp; helpers
    bunch.kind = 'hoist'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.170">def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set types &amp; helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())
    
    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()
    
    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            t = bunch2.t
            afterTree.append(
                g.Bunch(t=t,head=t.headString[:],body=t.bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.171">def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    
    '''Create an undo node for mark and unmark commands.'''
    
    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.
    
    u = self
    if u.redoing or u.undoing: return

    # Set the type &amp; helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    
    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.172">def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self
    if u.redoing or u.undoing: return
    
    # Set the types &amp; helpers.
    bunch.kind = 'move'
    bunch.undoType = command
    
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove
    
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = p.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newBack   = p.back()
    bunch.newN = p.childIndex()
    bunch.newParent = p.parent()
    
    u.pushBead(bunch)</t>
<t tx="ekr.20060206111431.173"></t>
<t tx="ekr.20060206111431.174">def beforeChangeGroup (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)
    
    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command
    
    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]</t>
<t tx="ekr.20060206111431.175">def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):
    
    '''Return data that gets passed to afterChangeNode'''
    
    u = self
    
    bunch = u.createCommonBunch(p)
    
    bunch.oldBody = oldBody or p.bodyString()
    bunch.oldHead = oldHead or p.headString()

    return bunch</t>
<t tx="ekr.20060206111431.176">def beforeChangeTree (self,p):
    
    # g.trace(p.headString())
    
    u = self ; body = u.c.frame.body

    bunch = u.createCommonBunch(p)

    bunch.oldSel = body.getTextSelection()
    bunch.oldText = body.getAllText()
    bunch.oldTree = u.saveTree(p)
    
    return bunch</t>
<t tx="ekr.20060206111431.177">def beforeClearRecentFiles (self):
    
    u = self ; p = u.c.currentPosition()
    
    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch</t>
<t tx="ekr.20060206111431.178">def beforeCloneNode (self,p):
    
    u = self

    bunch = u.createCommonBunch(p)

    return bunch</t>
<t tx="ekr.20060206111431.179">def beforeDeleteNode (self,p):
    
    u = self

    bunch = u.createCommonBunch(p)
    
    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()
    
    return bunch</t>
<t tx="ekr.20060206111431.180">def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):
    
    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone
    
    if pasteAsClone:
        # Save the list of bunches created by fc.createVnode.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch</t>
<t tx="ekr.20060206111431.181">def beforeMark (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command
    
    return bunch</t>
<t tx="ekr.20060206111431.182">def beforeMoveNode (self,p):
    
    u = self
    
    bunch = u.createCommonBunch(p)
    
    bunch.oldBack = p.back()
    bunch.oldN = p.childIndex()
    bunch.oldParent = p.parent()

    return bunch</t>
<t tx="ekr.20060206111431.183">def createCommonBunch (self,p):
    
    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''
    
    u = self ; c = u.c ; body = c.frame.body
    
    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = body.getTextSelection(),
        p = p.copy(),
    )</t>
<t tx="ekr.20060206111431.184"># Translation does not affect these routines.

def canRedo (self):

    u = self
    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self
    return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="ekr.20060206111431.185">def clearUndoState (self):

    """Clears then entire Undo state.
    
    All non-undoable commands should call this method."""
    
    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()</t>
<t tx="ekr.20060206111431.186">def enableMenuItems (self):

    u = self ; frame = u.c.frame
    
    menu = frame.menu.getMenu("Edit")
    frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
    frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="ekr.20060206111431.187">if 0:
    def getMark (self):
    
        __pychecker__ = '--no-classattr' # self.bead does, in fact, exist.
        
        return self.bead
        
    def rollbackToMark (self,n):
        
        u = self
    
        u.bead = n
        u.beads = u.beads[:n+1]
        u.setUndoTypes()
        
    rollBackToMark = rollbackToMark</t>
<t tx="ekr.20060206111431.188">@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    &lt;&lt; return if there is nothing to do &gt;&gt;
    # g.trace(undo_type,g.callers(7))
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    return bunch</t>
<t tx="ekr.20060206111431.189">if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None</t>
<t tx="ekr.20060206111431.190"># Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()</t>
<t tx="ekr.20060206111431.191">@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"</t>
<t tx="ekr.20060206111431.192">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines</t>
<t tx="ekr.20060206111431.193">#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
</t>
<t tx="ekr.20060206111431.194">@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview

</t>
<t tx="ekr.20060206111431.195">@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True</t>
<t tx="ekr.20060206111431.196">old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 &gt;= len(old_s) or new_col-1 &gt;= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)</t>
<t tx="ekr.20060206111431.197">def redo (self,event=None):

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead')
        return
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
        if u.redoHelper:
            u.redoHelper()
        else:
            g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
        c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
        # So we always request a redraw.
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocus()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()</t>
<t tx="ekr.20060206111431.198">def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20060206111431.199">def redoCloneNode (self):
    
    u = self ; c = u.c
    
    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    c.selectPosition(u.newP)</t>
<t tx="ekr.20060206111431.200">def redoDeleteNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)</t>
<t tx="ekr.20060206111431.201">def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # assert(u.newP.exists(c))
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)
            
    c.selectPosition(u.newP)</t>
<t tx="ekr.20060206111431.202">def redoHoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.hoist()
    
def redoDehoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.dehoist()</t>
<t tx="ekr.20060206111431.203">def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()
    
    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                z.redoHelper() ; count += 1
            else:
                g.trace('oops: no redo helper for %s' % u.undoType)

    u.groupCount -= 1
    
    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)
        
    c.selectPosition(p)
    newSel and c.frame.body.setTextSelection(newSel)</t>
<t tx="ekr.20060206111431.204">def redoNodeContents (self):
    
    u = self
    
    u.p.setTnodeText(u.newBody)
    u.p.initHeadString(u.newHead)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setTextSelection(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()</t>
<t tx="ekr.20060206111431.205">def redoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    c.selectPosition(u.p)</t>
<t tx="ekr.20060206111431.206">def redoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)
        
    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
        
    c.selectPosition(u.p)</t>
<t tx="ekr.20060206111431.207">def redoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setTextSelection(u.newSel)</t>
<t tx="ekr.20060206111431.208">def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
    
    if u.newSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)</t>
<t tx="ekr.20060206111431.209">def undo (self,event=None):

    """Undo the operation described by the undo parmaters."""
    
    u = self ; c = u.c
    # g.trace(g.callers(7))

    c.endEditing() # Capture the headline *before* checking for undo.
    
    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead')
        return # Sets ivars.
    if not c.currentPosition():
        g.trace('no current position')
        return
        
    # g.trace(u.undoType)

    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
        if u.undoHelper:
            u.undoHelper()
        else:
            g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
        c.selectPosition(c.currentPosition())
    finally:
        # New in 4.4a3: Almost any change could change an icon,
        # So we always request a redraw.
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocus()

    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()</t>
<t tx="ekr.20060206111431.210">def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20060206111431.211">def undoCloneNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    c.selectPosition(u.p)</t>
<t tx="ekr.20060206111431.212">def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    
    c.selectPosition(u.p)</t>
<t tx="ekr.20060206111431.213">def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.undoHelper:
                z.undoHelper() ; count += 1
            else:
                g.trace('oops: no undo helper for %s' % u.undoType)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)</t>
<t tx="ekr.20060206111431.214">def undoHoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
    
def undoDehoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()</t>
<t tx="ekr.20060206111431.215">def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                u.p.setBodyStringOrPane(bunch.body)
                u.p.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            
    c.selectPosition(u.p)</t>
<t tx="ekr.20060206111431.216">def undoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)</t>
<t tx="ekr.20060206111431.217">def undoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)</t>
<t tx="ekr.20060206111431.218">def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self
    
    u.p.setTnodeText(u.oldBody)
    u.p.initHeadString(u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setTextSelection(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()</t>
<t tx="ekr.20060206111431.219">def undoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setTextSelection(u.oldSel)</t>
<t tx="ekr.20060206111431.220">def undoRedoTree (self,p,new_data,old_data):
    
    '''Replace p and its subtree using old_data during undo.'''
    
    # Same as undoReplace except uses g.Bunch.

    u = self
    
    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    p.setBodyStringOrPane(p.bodyString())
    
    return p # Nothing really changes.</t>
<t tx="ekr.20060206111431.221">def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    if u.oldSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)</t>
<t tx="ekr.20060206111431.222"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c ; body = c.frame.body
    &lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
    &lt;&lt; Compute the result using p's body text &gt;&gt;
    p.setTnodeText(result)
    &lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
    if textResult == result:
        c.frame.body.recolor(p,incremental=False)
    else: # Rewrite the pane and do a full recolor.
        if 0:
            &lt;&lt; print mismatch trace &gt;&gt;
        p.setBodyStringOrPane(result)
</t>
<t tx="ekr.20060206111431.223"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading &gt; 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len &gt; 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading &gt; 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines &gt; oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines &gt; newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))</t>
<t tx="ekr.20060206111431.224"># Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result</t>
<t tx="ekr.20060206111431.225">textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) &gt; 0 and textResult[:-1] == result:
        textResult = result</t>
<t tx="ekr.20060206111431.226">print "undo mismatch"
print "expected:",result
print "actual  :",textResult</t>
<t tx="ekr.20060206111431.227">def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.endEditing()
        c.editPosition(p)
    finally:
        c.endUpdate(scroll=True)

    return p # for mod_labels plugin.</t>
<t tx="ekr.20060206111431.228"></t>
<t tx="ekr.20060206111431.229">def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.'''
    
    k = self.k ; d2 = {}
    
    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        d2 [name] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2</t>
<t tx="ekr.20060206111431.230">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'cascade-windows':              f.cascade,
    'clear-recent-files':           c.clearRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'close-find-dialog':            c.dismissFindPanel, # Deprecated.
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'find-dialog-change':           c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':       c.replaceAll,           # Deprecated.
    'find-dialog-find-next':        c.findNext,             # Deprecated.
    'find-dialog-find-previous':    c.findPrevious,         # Deprecated.
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible':            c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-bracket':                c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-with':                    c.openWith,
    'outline-to-CWEB':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'find-tab-replace':             c.replace,
    'find-tab-replace-then-find':   c.replaceThenFind,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-to':                 c.saveTo,
    'select-all':                   f.body.selectAllText,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.viewAllCharacters,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}</t>
<t tx="ekr.20060206111431.231"></t>
<t tx="ekr.20060206111431.232"></t>
<t tx="ekr.20060206111431.233"></t>
<t tx="ekr.20060206111431.234">def new (self,event=None):

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(c,v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    finally:
        c.endUpdate()
        frame.body.setFocus()
    return c # For unit test.</t>
<t tx="ekr.20060206111431.235">def open (self,event=None):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.236">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20060206111431.237">def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20060206111431.238">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20060206111431.239">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20060206111431.240">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20060206111431.241">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20060206111431.242">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20060206111431.243">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20060206111431.244">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20060206111431.245">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20060206111431.246">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20060206111431.247">def close (self,event=None):
    
    """Handle the File-Close command."""

    g.app.closeLeoWindow(self.frame)</t>
<t tx="ekr.20060206111431.248">def save (self,event=None):

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060206111431.249">def saveAs (self,event=None):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060206111431.250">def saveTo (self,event=None):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)</t>
<t tx="ekr.20060206111431.251">def revert (self,event=None):
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20060206111431.252"></t>
<t tx="ekr.20060206111431.253">def clearRecentFiles (self,event=None):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer
    
    bunch = u.beforeClearRecentFiles()
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())
    
    g.app.config.appendToRecentFiles(c.recentFiles)
    
    u.afterClearRecentFiles(bunch)</t>
<t tx="ekr.20060206111431.254">def openRecentFile(self,name=None):
    
    if not name: return

    c = self ; v = c.currentVnode()
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
    
    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame) # 12/12/03
            c = frame.c # Switch to the new commander so the "recentfiles2" hook doesn't crash.
            c.setLog() # Sets the log stream for g.es()

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
</t>
<t tx="ekr.20060206111431.255">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20060206111431.256">def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()</t>
<t tx="ekr.20060206111431.257"></t>
<t tx="ekr.20060206111431.258">def readOutlineOnly (self,event=None):

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        c,frame = g.app.newLeoCommanderAndFrame(fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:" + fileName)</t>
<t tx="ekr.20060206111431.259">def readAtFileNodes (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()

    c.beginUpdate()
    try:
        undoData = u.beforeChangeTree(p)
        c.fileCommands.readAtFileNodes()
        u.afterChangeTree(p,'Read @file Nodes',undoData)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.260"></t>
<t tx="ekr.20060206111431.261">def importDerivedFile (self,event=None):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(p,names)</t>
<t tx="ekr.20060206111431.262"></t>
<t tx="ekr.20060206111431.263">def tangleAll (self,event=None):
    
    c = self
    c.tangleCommands.tangleAll()
</t>
<t tx="ekr.20060206111431.264">def tangleMarked (self,event=None):

    c = self
    c.tangleCommands.tangleMarked()
</t>
<t tx="ekr.20060206111431.265">def tangle (self,event=None):

    c = self
    c.tangleCommands.tangle()</t>
<t tx="ekr.20060206111431.266"></t>
<t tx="ekr.20060206111431.267">def untangleAll (self,event=None):

    c = self
    c.tangleCommands.untangleAll()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20060206111431.268">def untangleMarked (self,event=None):

    c = self
    c.tangleCommands.untangleMarked()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20060206111431.269">def untangle (self,event=None):

    c = self
    c.tangleCommands.untangle()
    c.undoer.clearUndoState()
</t>
<t tx="ekr.20060206111431.270"></t>
<t tx="ekr.20060206111431.271">def exportHeadlines (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.exportHeadlines(fileName)

</t>
<t tx="ekr.20060206111431.272">def flattenOutline (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.flattenOutline(fileName)

</t>
<t tx="ekr.20060206111431.273">def importAtRoot (self,event=None):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@root")
</t>
<t tx="ekr.20060206111431.274">def importAtFile (self,event=None):
    
    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand(names,"@file")</t>
<t tx="ekr.20060206111431.275">def importCWEBFiles (self,event=None):
    
    c = self
    
    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"cweb")
</t>
<t tx="ekr.20060206111431.276">def importFlattenedOutline (self,event=None):
    
    c = self
    
    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFlattenedOutline(names)
</t>
<t tx="ekr.20060206111431.277">def importNowebFiles (self,event=None):
    
    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"noweb")
</t>
<t tx="ekr.20060206111431.278">def outlineToCWEB (self,event=None):
    
    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.outlineToWeb(fileName,"cweb")

</t>
<t tx="ekr.20060206111431.279">def outlineToNoweb (self,event=None):
    
    c = self
    
    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName

</t>
<t tx="ekr.20060206111431.280">def removeSentinels (self,event=None):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)</t>
<t tx="ekr.20060206111431.281">def weave (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.weave(fileName)
</t>
<t tx="ekr.20060206111431.282"></t>
<t tx="ekr.20060206111431.283"></t>
<t tx="ekr.20060206111431.284">def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    &lt;&lt; redirect output &gt;&gt;
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    g.es("end of script",color="purple")
            except Exception:
                &lt;&lt; handle an exception in the script &gt;&gt;
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        &lt;&lt; unredirect output &gt;&gt;</t>
<t tx="ekr.20060206111431.285">if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr</t>
<t tx="ekr.20060206111431.286">g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "&lt;string&gt;":
    c.goToScriptLineNumber(p,script,n)

&lt;&lt; dump the lines near the error &gt;&gt;</t>
<t tx="ekr.20060206111431.287">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i &lt; j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1</t>
<t tx="ekr.20060206111431.288">if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()</t>
<t tx="ekr.20060206111431.289">def goToLineNumber (self,event=None,root=None,lines=None,n=None,scriptFind=False):
    
    __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        &lt;&lt; set root &gt;&gt;
    if lines is None:
        &lt;&lt; read the file into lines &gt;&gt;
    if n is None:
        &lt;&lt; get n, the line number, from a dialog &gt;&gt;
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n &gt;= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        &lt;&lt; count outline lines, setting p,n2,found &gt;&gt;
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        &lt;&lt; set p to the node given by vnodeName, etc. &gt;&gt;
    &lt;&lt; select p and make it visible &gt;&gt;
    &lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="ekr.20060206111431.290"># First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,</t>
<t tx="ekr.20060206111431.291"># 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return</t>
<t tx="ekr.20060206111431.292">n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return</t>
<t tx="ekr.20060206111431.293">p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) &gt; 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines &gt;= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)</t>
<t tx="ekr.20060206111431.294">if scriptFind:
    &lt;&lt; just scan for the node name &gt;&gt;
elif gnx:
    &lt;&lt; 4.2: get node from gnx &gt;&gt;
elif childIndex == -1:
    &lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;
else:
    &lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</t>
<t tx="ekr.20060206111431.295"># This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break</t>
<t tx="ekr.20060206111431.296">found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20060206111431.297"># This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    g.es_print(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    &lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;
    tnodeIndex = max(0,tnodeIndex)
    &lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False &gt;&gt;
            
if not ok:
    # Fall back to the old logic.
    &lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</t>
<t tx="ekr.20060206111431.298">tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned &gt;= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1</t>
<t tx="ekr.20060206111431.299">@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex &lt; len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False</t>
<t tx="ekr.20060206111431.300">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    g.es_print(s, color="red")
    return</t>
<t tx="ekr.20060206111431.301">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex &lt;= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20060206111431.302">c.beginUpdate()
try:
    c.frame.tree.expandAllAncestors(p)
    c.selectVnode(p)
finally:
    c.endUpdate()</t>
<t tx="ekr.20060206111431.303">if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.bodyWantsFocus()
c.frame.body.makeInsertPointVisible()</t>
<t tx="ekr.20060206111431.304">@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    &lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    &lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    &lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
</t>
<t tx="ekr.20060206111431.305"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine &lt; len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
</t>
<t tx="ekr.20060206111431.306">offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        &lt;&lt; handle delim while scanning backward &gt;&gt;
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1</t>
<t tx="ekr.20060206111431.307">if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"&lt;&lt;") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.</t>
<t tx="ekr.20060206111431.308">if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i &gt; -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")</t>
<t tx="ekr.20060206111431.309">def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 &lt;= n &lt; len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n</t>
<t tx="ekr.20060206111431.310">def gotoLineNumberOpen(self, *args, **kw):
    """
    Hook for mod_shadow plugin.
    """
    theFile = open(*args, **kw)
    lines = theFile.readlines()
    theFile.close()
    return lines</t>
<t tx="ekr.20060206111431.311">def applyLineNumberMappingIfAny(self, n):
    """
    Hook for mod_shadow plugin.
    """
    return n</t>
<t tx="ekr.20060206111431.312">def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)</t>
<t tx="ekr.20060206111431.313">def fontPanel (self,event=None):
    
    c = self ; frame = c.frame

    if not frame.fontPanel:
        frame.fontPanel = g.app.gui.createFontPanel(c)
        
    frame.fontPanel.bringToFront()</t>
<t tx="ekr.20060206111431.314">def colorPanel (self,event=None):
    
    c = self ; frame = c.frame

    if not frame.colorPanel:
        frame.colorPanel = g.app.gui.createColorPanel(c)
        
    frame.colorPanel.bringToFront()</t>
<t tx="ekr.20060206111431.315">def viewAllCharacters (self,event=None):

    c = self ; frame = c.frame
    p = c.currentPosition()
    colorizer = frame.body.getColorizer()

    colorizer.showInvisibles = g.choose(colorizer.showInvisibles,0,1)

    # It is much easier to change the menu name here than in the menu updater.
    menu = frame.menu.getMenu("Edit")
    if colorizer.showInvisibles:
        frame.menu.setMenuLabel(menu,"Show Invisibles","Hide Invisibles")
    else:
        frame.menu.setMenuLabel(menu,"Hide Invisibles","Show Invisibles")

    c.frame.body.recolor_now(p)</t>
<t tx="ekr.20060206111431.316">def preferences (self,event=None):
    
    '''Handle the preferences command.'''
    
    c = self
    c.openLeoSettings()</t>
<t tx="ekr.20060206111431.317"></t>
<t tx="ekr.20060206111431.318">def convertAllBlanks (self,event=None):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count &gt; 0)</t>
<t tx="ekr.20060206111431.319">def convertAllTabs (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count &gt; 0)</t>
<t tx="ekr.20060206111431.320">def convertBlanks (self,event=None):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList</t>
<t tx="ekr.20060206111431.321">def convertTabs (self,event=None):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False,None

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList</t>
<t tx="ekr.20060206111431.322">def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p</t>
<t tx="ekr.20060206111431.323">def dedentBody (self,event=None):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060206111431.324">def extract (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.325">def extractSection (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.326">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return</t>
<t tx="ekr.20060206111431.327">def extractSectionNames(self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()</t>
<t tx="ekr.20060206111431.328">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)
        
if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]</t>
<t tx="ekr.20060206111431.329">def findBoundParagraph (self,event=None):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        &lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;

    # Scan backwards.
    i = len(head_lines)
    while i &gt; 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i &lt; len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#   para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool</t>
<t tx="ekr.20060206111431.330">if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)</t>
<t tx="ekr.20060206111431.331">def findMatchingBracket (self,event=None):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"&lt;=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)</t>
<t tx="ekr.20060206111431.332"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,"&gt;=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level &lt;= 0:
                return index
        if not forward and body.compareIndices(index,"&lt;=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched</t>
<t tx="ekr.20060206111431.333">def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview</t>
<t tx="ekr.20060206111431.334">def indentBody (self,event=None):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; undoType = 'Indent Region' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060206111431.335">def insertBodyTime (self,event=None):
    
    c = self ; undoType = 'Insert Body Time'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)</t>
<t tx="ekr.20060206111431.336">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getString("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt     = c.config.getString("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20060206111431.337"></t>
<t tx="ekr.20060206111431.338">def addComments (self,event=None):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060206111431.339">def deleteComments (self,event=None):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20060206111431.340">def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;</t>
<t tx="ekr.20060206111431.341">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL</t>
<t tx="ekr.20060206111431.342">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20060206111431.343"># Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
</t>
<t tx="ekr.20060206111431.344">sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()</t>
<t tx="ekr.20060206111431.345">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList</t>
<t tx="ekr.20060206111431.346"></t>
<t tx="ekr.20060206111431.347">def editHeadline (self,event=None):
    
    c = self ; k = c.k ; tree = c.frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return
        
    if k:
        k.setDefaultUnboundKeyAction()
        k.showStateAndMode()

    tree.editLabel(c.currentPosition())</t>
<t tx="ekr.20060206111431.348">def toggleAngleBrackets (self,event=None):
    
    c = self ; v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return
        
    c.endEditing()

    s = v.headString().strip()
    if (s[0:2] == "&lt;&lt;"
        or s[-2:] == "&gt;&gt;"): # Must be on separate line.
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    
    c.frame.tree.editLabel(v)
    w = v.edit_widget()
    if w:
        w.delete("1.0","end")
        w.insert("1.0",s)
        c.frame.tree.onHeadChanged(v,'Toggle Angle Brackets')</t>
<t tx="ekr.20060206111431.349"></t>
<t tx="ekr.20060206111431.350">def dismissFindPanel (self,event=None):
    
    c = self
    
    if c.frame.findPanel:
        c.frame.findPanel.dismiss()</t>
<t tx="ekr.20060206111431.351">def showFindPanel (self,event=None):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.bringToFront()</t>
<t tx="ekr.20060206111431.352">def findNext (self,event=None):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findNextCommand(c)
</t>
<t tx="ekr.20060206111431.353">def findPrevious (self,event=None):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findPreviousCommand(c)
</t>
<t tx="ekr.20060206111431.354">def replace (self,event=None):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeCommand(c)
</t>
<t tx="ekr.20060206111431.355">def replaceThenFind (self,event=None):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeThenFindCommand(c)
</t>
<t tx="ekr.20060206111431.356">def replaceAll (self,event=None):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeAllCommand(c)
</t>
<t tx="ekr.20060206111431.357">def notValidInBatchMode(self, commandName):
    
    g.es("%s command is not valid in batch mode" % commandName)
</t>
<t tx="ekr.20060206111431.358"></t>
<t tx="ekr.20060206111431.359"></t>
<t tx="ekr.20060206111431.360"></t>
<t tx="ekr.20060206111431.361">def cutOutline (self,event=None):

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()</t>
<t tx="ekr.20060206111431.362">def copyOutline (self,event=None):

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)</t>
<t tx="ekr.20060206111431.363"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return
    
    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
        undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate(scroll=True)
        c.recolor()</t>
<t tx="ekr.20060206111431.364">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())</t>
<t tx="ekr.20060206111431.365"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)</t>
<t tx="ekr.20060206111431.366">def pasteOutlineRetainingClones (self,event=None):
    
    c = self

    return c.pasteOutline(reassignIndices=False)</t>
<t tx="ekr.20060206111431.367">def dehoist (self,event=None):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        c.beginUpdate()
        try:
            if bunch.expanded: p.expand()
            else:              p.contract()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')

def hoist (self,event=None):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        c.beginUpdate()
        try:
            p.expand()
        finally:
            c.endUpdate()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')</t>
<t tx="ekr.20060206111431.368"></t>
<t tx="ekr.20060206111431.369">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
    
    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if warningFlag:
                g.alert(message)
            return False
    return True</t>
<t tx="ekr.20060206111431.370">def deleteOutline (self,event=None,op_name="Delete Node"):
    
    """Deletes the current position.
    
    Does nothing if the outline would become empty."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
       undoData = u.beforeDeleteNode(p)
       dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
       p.doDelete()
       c.selectPosition(newNode)
       c.setChanged(True)
       u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()</t>
<t tx="ekr.20060206111431.371">def clone (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone(p)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels plugin.</t>
<t tx="ekr.20060206111431.372"># Makes sure all nodes are valid.

def validateOutline (self,event=None):

    c = self
    
    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True</t>
<t tx="ekr.20060206111431.373">def sortChildren (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Sort Children'
    p = c.currentPosition()
    if not p or not p.hasChildren(): return

    c.beginUpdate()
    try: # In update
        c.endEditing()
        u.beforeChangeGroup(p,undoType)
        c.sortChildrenHelper(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(p,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.374">def sortChildrenHelper (self,p):
    
    c = self ; u = c.undoer

    # Create a list of tuples sorted on headlines.
    pairs = [(child.headString().lower(),child.copy()) for child in p.children_iter()]
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        undoData = u.beforeMoveNode(child)
        child.moveToNthChildOf(p,index)
        u.afterMoveNode(child,'Sort',undoData)
        index += 1</t>
<t tx="ekr.20060206111431.375">def sortSiblings (self,event=None):
    
    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    p = c.currentPosition()
    if not p: return

    parent = p.parent()
    if not parent:
        c.sortTopLevel()
    else:
        c.beginUpdate()
        try: # In update...
            c.endEditing()
            u.beforeChangeGroup(p,undoType)
            c.sortChildrenHelper(parent)
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            c.setChanged(True)
            u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.376">def sortTopLevel (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    root = c.rootPosition()
    if not root: return

    # Create a list of tuples sorted by headlines.
    pairs = [(p.headString().lower(),p.copy())
        for p in root.self_and_siblings_iter()]
    pairs.sort()
 
    c.beginUpdate()
    try: # In update...
        dirtyVnodeList = []
        u.beforeChangeGroup(root,undoType)
        if 1: # In group...
            h,p = pairs[0]
            if p != root:
                undoData = u.beforeMoveNode(p)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                p.moveToRoot(oldRoot=root)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMoveNode(p,'Sort',undoData)
            for h,next in pairs[1:]:
                undoData = u.beforeMoveNode(next)
                next.moveAfter(p)
                u.afterMoveNode(next,'Sort',undoData)
                p = next
        u.afterChangeGroup(root,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.377"></t>
<t tx="ekr.20060206111431.378">def checkOutline (self,event=None,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    &lt;&lt; assert equivalence of lastVisible methods &gt;&gt;
    for p in c.allNodes_iter():
        try:
            count += 1
            &lt;&lt; remove unused tnodeList &gt;&gt;
            if full: # Unit tests usually set this false.
                &lt;&lt; do full tests &gt;&gt;
        except AssertionError,message:
            errors += 1
            &lt;&lt; give test failed message &gt;&gt;
    if verbose or not unittest:
        &lt;&lt; print summary message &gt;&gt;
    return errors</t>
<t tx="ekr.20060206111431.379">if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False</t>
<t tx="ekr.20060206111431.380"># Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; g.es_print(s,color="blue")
    delattr(v.t,"tnodeList")</t>
<t tx="ekr.20060206111431.381">if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others</t>
<t tx="ekr.20060206111431.382">threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"</t>
<t tx="ekr.20060206111431.383">back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"</t>
<t tx="ekr.20060206111431.384">if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"</t>
<t tx="ekr.20060206111431.385">if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
</t>
<t tx="ekr.20060206111431.386">if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"</t>
<t tx="ekr.20060206111431.387">if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"</t>
<t tx="ekr.20060206111431.388">vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) &gt; 1, "len(vnodeList) &gt; 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"</t>
<t tx="ekr.20060206111431.389"># Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_widget()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"</t>
<t tx="ekr.20060206111431.390">s = "test failed: %s %s" % (message,repr(p))
print s ; g.es_print(s,color="red")</t>
<t tx="ekr.20060206111431.391">if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    g.es_print(s,color="red")
elif verbose:
    g.es(s,color="green")</t>
<t tx="ekr.20060206111431.392"></t>
<t tx="ekr.20060206111431.393">def checkAllPythonCode(self,event=None,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result</t>
<t tx="ekr.20060206111431.394">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()</t>
<t tx="ekr.20060206111431.395">def checkPythonCode (self,event=None,unittest=False,ignoreAtIgnore=True,suppressErrors=False):
    
    c = self ; count = 0 ; result = "ok"
    
    if not unittest:
        g.es("checking Python code   ")
    
    for p in c.currentPosition().self_and_subtree_iter():
        
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (parser.ParserError,SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    g.es("surprise in checkPythonNode")
                    g.es_exception()
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")
        
    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result</t>
<t tx="ekr.20060206111431.396">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()</t>
<t tx="ekr.20060206111431.397">def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self
    
    h = p.headString()
    # We must call getScript so that we can ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
        if unittest: raise
        else:
            g.es_exception(full=False,color="black")
            p.setMarked()

    c.tabNannyNode(p,h,body,unittest,suppressErrors)</t>
<t tx="ekr.20060206111431.398"># This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return
        
    except parser.ParserError, msg:
        if not suppressErrors:
            g.es("ParserError in %s" % headline,color="blue")
            g.es(str(msg))
        
    except tokenize.TokenError, msg:
        if not suppressErrors:
            g.es("TokenError in %s" % headline,color="blue")
            g.es(str(msg))

    except tabnanny.NannyNag, nag:
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])
        
    except:
        g.trace("unexpected exception")
        g.es_exception()

    if unittest: raise
    else: p.setMarked()</t>
<t tx="ekr.20060206111431.399">def dumpOutline (self,event=None):
    
    """ Dump all nodes in the outline."""
    
    c = self

    for p in c.allNodes_iter():
        p.dump()</t>
<t tx="ekr.20060206111431.400"></t>
<t tx="ekr.20060206111431.401">def prettyPrintAllPythonCode (self,event=None,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()</t>
<t tx="ekr.20060206111431.402">def prettyPrintPythonCode (self,event=None,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()</t>
<t tx="ekr.20060206111431.403">def prettyPrintPythonNode (self,p=None,dump=False):

    c = self
    
    if not p:
        p = c.currentPosition()
    
    pp = c.prettyPrinter(c)

    # Unlike scanDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()</t>
<t tx="ekr.20060206111431.404">class prettyPrinter:
    
    @others</t>
<t tx="ekr.20060206111431.405">def __init__ (self,c):
    
    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    &lt;&lt; define dispatch dict &gt;&gt;</t>
<t tx="ekr.20060206111431.406">self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}</t>
<t tx="ekr.20060206111431.407">def clear (self):
    self.lines = []</t>
<t tx="ekr.20060206111431.408">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20060206111431.409">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20060206111431.410">def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)</t>
<t tx="ekr.20060206111431.411">def get (self):
    
    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()
    
    return self.lines</t>
<t tx="ekr.20060206111431.412">def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)</t>
<t tx="ekr.20060206111431.413">def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20060206111431.414">def putArray (self):
    
    """Add the next text by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0</t>
<t tx="ekr.20060206111431.415">def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name</t>
<t tx="ekr.20060206111431.416">def doEndMarker (self):
    
    self.putArray()</t>
<t tx="ekr.20060206111431.417">def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)</t>
<t tx="ekr.20060206111431.418">def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
</t>
<t tx="ekr.20060206111431.419">def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.
    
    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
    
    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')
            
    # Suppress start-of-line logic.
    self.line = self.erow</t>
<t tx="ekr.20060206111431.420">def doName(self):
    
    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=&lt;&gt;*-+&amp;|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val</t>
<t tx="ekr.20060206111431.421">def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()</t>
<t tx="ekr.20060206111431.422">def doNumber (self):

    self.array.append(self.val)
</t>
<t tx="ekr.20060206111431.423">def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel &lt;= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','&lt;=','&gt;=','&lt;','&gt;','&lt;&gt;','*','**','+','&amp;','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '&gt;&gt;':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '&lt;&lt;':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and prev[-1] not in string.digits + string.letters:
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)</t>
<t tx="ekr.20060206111431.424">def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)</t>
<t tx="ekr.20060206111431.425">def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)</t>
<t tx="ekr.20060206111431.426">def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))</t>
<t tx="ekr.20060206111431.427">def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)</t>
<t tx="ekr.20060206111431.428">def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    </t>
<t tx="ekr.20060206111431.429"></t>
<t tx="ekr.20060206111431.430"></t>
<t tx="ekr.20060206111431.431">def contractAllHeadlines (self,event=None):

    c = self
    
    c.beginUpdate()
    try: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    finally:
        c.endUpdate()

    c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="ekr.20060206111431.432">def contractNode (self,event=None):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.contract()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20060206111431.433">def contractNodeOrGoToParent (self,event=None):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
 
    if p.hasChildren() and p.isExpanded():
        c.contractNode()
    elif p.hasParent():
        c.goToParent()</t>
<t tx="ekr.20060206111431.434">def contractParent (self,event=None):
    
    c = self ; v = c.currentVnode()
    parent = v.parent()
    if not parent: return
    
    c.beginUpdate()
    try:
        c.selectVnode(parent)
        parent.contract()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.435">def expandAllHeadlines (self,event=None):

    c = self ; v = root = c.rootVnode()
    c.beginUpdate()
    try:
        while v:
            c.expandSubtree(v)
            v = v.next()
        c.selectVnode(root)
    finally:
        c.endUpdate()
    c.expansionLevel = 0 # Reset expansion level.</t>
<t tx="ekr.20060206111431.436">def expandAllSubheads (self,event=None):

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    try:
        c.expandSubtree(v)
        while child:
            c.expandSubtree(child)
            child = child.next()
        c.selectVnode(v)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.437">def expandLevel1 (self,event=None): self.expandToLevel(1)
def expandLevel2 (self,event=None): self.expandToLevel(2)
def expandLevel3 (self,event=None): self.expandToLevel(3)
def expandLevel4 (self,event=None): self.expandToLevel(4)
def expandLevel5 (self,event=None): self.expandToLevel(5)
def expandLevel6 (self,event=None): self.expandToLevel(6)
def expandLevel7 (self,event=None): self.expandToLevel(7)
def expandLevel8 (self,event=None): self.expandToLevel(8)
def expandLevel9 (self,event=None): self.expandToLevel(9)
</t>
<t tx="ekr.20060206111431.438">def expandNextLevel (self,event=None):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="ekr.20060206111431.439">def expandNode (self,event=None):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.expand()
    finally:
        c.endUpdate()

</t>
<t tx="ekr.20060206111431.440">def expandNodeAndGoToFirstChild (self,event=None):
    
    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        return

    if not p.isExpanded():
        c.expandNode()
        
    c.beginUpdate()
    try:
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        
def expandNodeOrGoToFirstChild (self,event=None):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren(): return

    if not p.isExpanded():
        c.expandNode()
    else:
        c.beginUpdate()
        try:
            c.selectVnode(p.firstChild())
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.441">def expandPrevLevel (self,event=None):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="ekr.20060206111431.442"></t>
<t tx="ekr.20060206111431.443">def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()</t>
<t tx="ekr.20060206111431.444">def expandSubtree (self,v):

    c = self
    last = v.lastNode()

    c.beginUpdate()
    try:
        while v and v != last:
            v.expand()
            v = v.threadNext()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.445">def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    try:
        current = c.currentPosition()
        n = current.level()
        for p in current.self_and_subtree_iter():
            if p.level() - n + 1 &lt; level:
                p.expand()
            else:
                p.contract()
        c.expansionLevel = level
        c.expansionNode = c.currentPosition()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.446"></t>
<t tx="ekr.20060206111431.447">def goNextVisitedNode (self,event=None):
    
    c = self

    while c.beadPointer + 1 &lt; len(c.beadList):
        c.beadPointer += 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            return</t>
<t tx="ekr.20060206111431.448">def goPrevVisitedNode (self,event=None):
    
    c = self

    while c.beadPointer &gt; 0:
        c.beadPointer -= 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            return
</t>
<t tx="ekr.20060206111431.449">def goToFirstNode (self,event=None):
    
    c = self
    p = c.rootPosition()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.450">def goToFirstSibling (self,event=None):
    
    c = self ; p = c.currentPosition()
    
    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.451">def goToLastNode (self,event=None):
    
    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext(): # Bug fix: 10/12/05: was p.hasNext.
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()

</t>
<t tx="ekr.20060206111431.452">def goToLastSibling (self,event=None):
    
    c = self ; p = c.currentPosition()
    
    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.453">def goToLastVisibleNode (self,event=None):
    
    c = self ; p = c.rootPosition()
    
    while p.hasNext():
        p.moveToNext()
        
    while p and p.isExpanded():
        p.moveToLastChild()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.454">def goToNextClone (self,event=None):

    c = self ; current = c.currentVnode()
    if not current: return
    if not current.isCloned(): return

    v = current.threadNext()
    while v and v.t != current.t:
        v = v.threadNext()
        
    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and v != current and v.t != current.t:
            v = v.threadNext()

    if v:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectVnode(v)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.455">def goToNextDirtyHeadline (self,event=None):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isDirty():
        p.moveToThreadNext()

    if not p:
        # Wrap around.
        p = c.rootPosition()
        while p and not p.isDirty():
            p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20060206111431.456">def goToNextMarkedHeadline (self,event=None):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isMarked():
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20060206111431.457">def goToNextSibling (self,event=None):
    
    c = self
    v = c.currentVnode()
    if not v: return
    next = v.next()
    if next:
        c.beginUpdate()
        try:
            c.selectVnode(next)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.458">def goToParent (self,event=None):
    
    c = self
    v = c.currentVnode()
    if not v: return
    p = v.parent()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.459">def goToPrevSibling (self,event=None):
    
    c = self
    v = c.currentVnode()
    if not v: return
    back = v.back()
    if back:
        c.beginUpdate()
        try:
            c.selectVnode(back)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.460">def selectThreadNext (self,event=None):

    c = self ; current = c.currentPosition()
    if not current: return

    p = current.threadNext()
    if p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
        finally:
            c.endUpdate()
        c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.461">def selectThreadBack (self,event=None):

    c = self ; current = c.currentVnode()
    if not current: return
    
    v = current.threadBack()
    if v:
        c.beginUpdate()
        try:
            c.selectVnode(v)
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20060206111431.462"># This has an up arrow for a control key.

def selectVisBack (self,event=None):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.visBack()
    if v:
        c.beginUpdate()
        try:
            c.selectVnode(v)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.463">def selectVisNext (self,event=None):

    c = self ; current = c.currentVnode()
    if not current: return
    
    v = current.visNext()
    if v:
        c.beginUpdate()
        try:
            c.selectVnode(v)
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20060206111431.464"></t>
<t tx="ekr.20060206111431.465">def markChangedHeadlines (self,event=None): 

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()
    
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.466">def markChangedRoots (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                s = p.bodyString()
                flag, i = g.is_special(s,0,"@root")
                if flag:
                    bunch = u.beforeMark(p,undoType)
                    p.setMarked()
                    c.setChanged(True)
                    u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.467">def markAllAtFileNodesDirty (self,event=None):

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    try: # In update...
        while p:
            if p.isAtFileNode()and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.468">def markAtFileNodesDirty (self,event=None):

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    c.beginUpdate()
    try: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.469">def markClones (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()</t>
<t tx="ekr.20060206111431.470">def markHeadline (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            p.clearMarked()
        else:
            p.setMarked()
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20060206111431.471">def markSubheads (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()</t>
<t tx="ekr.20060206111431.472">def unmarkAll (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.clearMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()</t>
<t tx="ekr.20060206111431.473"></t>
<t tx="ekr.20060206111431.474">def demote (self,event=None):

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext(): return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(current)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.</t>
<t tx="ekr.20060206111431.475">@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next: return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        &lt;&lt; Move p down &amp; set moved if successful &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
            c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20060206111431.476">if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)</t>
<t tx="ekr.20060206111431.477">def moveOutlineLeft (self,event=None):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasParent(): return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20060206111431.478">def moveOutlineRight (self,event=None):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasBack: return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True): return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20060206111431.479">def moveOutlineUp (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        &lt;&lt; Move p up &gt;&gt;
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20060206111431.480">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)</t>
<t tx="ekr.20060206111431.481">def promote (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren(): return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20060206111431.482"></t>
<t tx="ekr.20060206111431.483">def openCompareWindow (self,event=None):
    
    c = self ; frame = c.frame
    
    if not frame.comparePanel:
        frame.comparePanel = g.app.gui.createComparePanel(c)

    frame.comparePanel.bringToFront()</t>
<t tx="ekr.20060206111431.484">def openPythonWindow (self,event=None):

    if sys.platform == "linux2":
        &lt;&lt; open idle in Linux &gt;&gt;
    else:
        &lt;&lt; open idle in Windows &gt;&gt;
</t>
<t tx="ekr.20060206111431.485"># 09-SEP-2002 DHEIN: Open Python window under linux

try:
    pathToLeo = g.os_path_join(g.app.loadDir,"leo.py")
    sys.argv = [pathToLeo]
    from idlelib import idle
    if g.app.idle_imported:
        reload(idle)
    g.app.idle_imported = True
except:
    try:
        g.es("idlelib could not be imported.")
        g.es("Probably IDLE is not installed.")
        g.es("Run Tools/idle/setup.py to build idlelib.")
        g.es("Can not import idle")
        g.es_exception() # This can fail!!
    except: pass
</t>
<t tx="ekr.20060206111431.486"># Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo"] # ,"-t","Leo"]

ok = False
if g.CheckVersion(sys.version,"2.3"):
    &lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;
else:
    &lt;&lt; Try to open idle in Python 2.2 systems &gt;&gt;

if not ok:
    g.es("Can not import idle")
    if idle_dir and idle_dir not in sys.path:
        g.es("Please add '%s' to sys.path" % idle_dir)</t>
<t tx="ekr.20060206111431.487">try:
    idle_dir = None
    
    import idlelib.PyShell

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    idlelib.PyShell.main()
    ok = True

except:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20060206111431.488">try:
    executable_dir = g.os_path_dirname(sys.executable)
    idle_dir = g.os_path_join(executable_dir,"Tools","idle")

    # 1/29/04: sys.path doesn't handle unicode in 2.2.
    idle_dir = str(idle_dir) # May throw an exception.

    # 1/29/04: must add idle_dir to sys.path even when using importFromPath.
    if idle_dir not in sys.path:
        sys.path.insert(0,idle_dir)

    if 1:
        import PyShell
    else: # Works, but is not better than import.
        PyShell = g.importFromPath("PyShell",idle_dir)

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    if 1: # Mostly works, but causes problems when opening other .leo files.
        PyShell.main()
    else: # Doesn't work: destroys all of Leo when Idle closes.
        self.leoPyShellMain()
    ok = True
except ImportError:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20060206111431.489">@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work well.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
    
    import PyShell
    root = g.app.root
    PyShell.fixwordbreaks(root)
    flist = PyShell.PyShellFileList(root)
    shell = PyShell.PyShell(flist)
    flist.pyshell = shell
    shell.begin()</t>
<t tx="ekr.20060206111431.490"></t>
<t tx="ekr.20060206111431.491">def about (self,event=None):
    
    c = self
    
    # Don't use triple-quoted strings or continued strings here.
    # Doing so would add unwanted leading tabs.
    version = c.getSignOnLine() + "\n\n"
    theCopyright = (
        "Copyright 1999-2006 by Edward K. Ream\n" +
        "All Rights Reserved\n" +
        "Leo is distributed under the Python License")
    url = "http://webpages.charter.net/edreamleo/front.html"
    email = "edreamleo@charter.net"

    g.app.gui.runAboutLeoDialog(c,version,theCopyright,url,email)</t>
<t tx="ekr.20060206111431.492">def openLeoSettings (self,event=None):

    c = self
    name = 'leoSettings.leo'
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))</t>
<t tx="ekr.20060206111431.493">def leoDocumentation (self,event=None):
    
    c = self ; name = "LeoDocs.leo"

    fileName = g.os_path_join(g.app.loadDir,"..","doc",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)
</t>
<t tx="ekr.20060206111431.494">def leoHome (self,event=None):
    
    import webbrowser

    url = "http://webpages.charter.net/edreamleo/front.html"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found: " + url)</t>
<t tx="ekr.20060206111431.495">def openLeoPlugins (self,event=None):
    
    c = self ; name = "leoPlugins.leo"
    fileName = g.os_path_join(g.app.loadDir,"..","plugins",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)</t>
<t tx="ekr.20060206111431.496">def leoTutorial (self,event=None):
    
    import webbrowser

    if 1: # new url
        url = "http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"
    else:
        url = "http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found: " + url)</t>
<t tx="ekr.20060206111431.497"></t>
<t tx="ekr.20060206111431.498"></t>
<t tx="ekr.20060206111431.499">def abortEditLabelCommand (self,event=None):
    
    frame = self ; c = frame.c ; tree = frame.tree
    p = c.currentPosition() ; w = p.edit_widget()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return
        
    # g.trace(p == tree.editPosition(),repr(tree.revertHeadline))
        
    if w and p == tree.editPosition():
        # Revert the headline text.
        w.delete("1.0","end")
        w.insert("end",tree.revertHeadline)
        p.initHeadString(tree.revertHeadline)
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20060206111431.500">def endEditLabelCommand (self,event=None):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.501">def insertHeadlineTime (self,event=None):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = p.edit_widget()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')</t>
<t tx="ekr.20060206111431.502"></t>
<t tx="ekr.20060206111431.503">def toggleActivePane (self,event=None):
    
    frame = self ; c = frame.c

    # Toggle the focus immediately.
    if c.get_focus() == frame.bodyCtrl:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.504">def cascade (self,event=None):

    x,y,delta = 10,10,10
    for frame in g.app.windowList:
        top = frame.top

        # Compute w,h
        top.update_idletasks() # Required to get proper info.
        geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        dim,junkx,junky = string.split(geom,'+')
        w,h = string.split(dim,'x')
        w,h = int(w),int(h)

        # Set new x,y and old w,h
        frame.setTopGeometry(w,h,x,y,adjustSize=False)

        # Compute the new offsets.
        x += 30 ; y += 30
        if x &gt; 200:
            x = 10 + delta ; y = 40 + delta
            delta += 10
</t>
<t tx="ekr.20060206111431.505">def equalSizedPanes (self,event=None):

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="ekr.20060206111431.506">def hideLogWindow (self,event=None):
    
    frame = self
    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="ekr.20060206111431.507">def minimizeAll (self,event=None):

    
    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
        self.minimize(frame.findPanel)
    
def minimize(self,frame):

    if frame and frame.top.state() == "normal":
        frame.top.iconify()</t>
<t tx="ekr.20060206111431.508"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def toggleSplitDirection (self,event=None):
    
    # Switch directions.
    c = self.c
    self.splitVerticalFlag = not self.splitVerticalFlag
    orientation = g.choose(self.splitVerticalFlag,"vertical","horizontal")
    c.config.set("initial_splitter_orientation","string",orientation)
    
    if use_Pmw and Pmw:
        self.togglePmwSplitDirection(self.splitVerticalFlag)
    else:
        self.toggleTkSplitDirection(self.splitVerticalFlag)</t>
<t tx="ekr.20060206111431.509">@ Alas, there seems to be is no way to
a) change the orientation of a Pmw.PanedWidget, or
b) change the parent of a widget.
Therefore, we must recreate all widgets to toggle the orientation!
@c

def togglePmwSplitDirection (self,verticalFlag):
    
    __pychecker__ = '--no-argsused' # verticalFlag not used.
    
    frame = self ; c = self.c ; p = c.currentPosition()
    
    for name in ('splitter1','splitter2'):
        splitter = self.component(name).getObject()
        splitter.pack_forget()

    # Remember the contents of the log, including most tags.
    d = self.log.saveAllState()

    # Recreate everything: similar to code in finishCreate.
    self.createLeoSplitters(self.outerFrame)
    frame.canvas = self.createCanvas(self.split2Pane1) # Also packs canvas
    frame.tree  = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
    frame.log   = leoTkinterLog(frame,self.split2Pane2)
    frame.body  = leoTkinterBody(frame,self.split1Pane2)
    
    # A kludge: reset this "official" ivar.
    frame.bodyCtrl = frame.body.bodyCtrl

    # Configure: similar to code in finishCreate.
    frame.setTabWidth(c.tab_width)
    frame.tree.setColorFromConfig()
    self.reconfigurePanes()
    self.body.setFontFromConfig()
    self.body.setColorFromConfig()

    # Restore everything.
    c.setLog()
    frame.log.restoreAllState(d)
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060206111431.510">def toggleTkSplitDirection (self,verticalFlag):

    # Abbreviations.
    frame = self
    bar1 = self.bar1 ; bar2 = self.bar2
    split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # Reconfigure the bars.
    bar1.place_forget()
    bar2.place_forget()
    self.configureBar(bar1,verticalFlag)
    self.configureBar(bar2,not verticalFlag)
    # Make the initial placements again.
    self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # Adjust the log and body panes to give more room around the bars.
    self.reconfigurePanes()
    # Redraw with an appropriate ratio.
    vflag,ratio,secondary_ratio = frame.initialRatios()
    self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="ekr.20060206111431.511">def resizeToScreen (self,event=None):
    
    top = self.top
    
    w = top.winfo_screenwidth()
    h = top.winfo_screenheight()

    if sys.platform == 'darwin':
        # Must leave room to get at very small resizing area.
        geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)
    else:
        # Fill almost the entire screen.
        # Works on Windows. YMMV for other platforms.
        geom = "%dx%d%+d%+d" % (w-8,h-46,0,0)
   
    top.geometry(geom)</t>
<t tx="ekr.20060206111431.512"></t>
<t tx="ekr.20060206111431.513">def leoHelp (self,event=None):
    
    frame = self ; c = frame.c
    
    theFile = g.os_path_join(g.app.loadDir,"..","doc","sbooks.chm")

    if g.os_path_exists(theFile):
        os.startfile(theFile)
    else:
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,theFile,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                g.es("exception dowloading sbooks.chm")
                g.es_exception()</t>
<t tx="ekr.20060206111431.514">def showProgressBar (self,count,size,total):

    # g.trace("count,size,total:",count,size,total)
    if self.scale == None:
        &lt;&lt; create the scale widget &gt;&gt;
    self.scale.set(count*size)
    self.scale.update_idletasks()</t>
<t tx="ekr.20060206111431.515">top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="ekr.20060206111431.516"></t>
<t tx="ekr.20060206111431.517">def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.dialogs = 0 # Count of open dialogs.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False
    self.trace_gc_verbose = False
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    &lt;&lt; Define global constants &gt;&gt;
    &lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="ekr.20060206111431.518">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
</t>
<t tx="ekr.20060206111431.519"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }</t>
<t tx="ekr.20060206111431.520">def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    &lt;&lt; start psycho &gt;&gt;
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc = c.config.getBool('trace_gc')
    g.app.trace_gc_verbose = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()</t>
<t tx="ekr.20060206111431.521"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)</t>
<t tx="ekr.20060206111431.522">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()</t>
<t tx="ekr.20060206111431.523">if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()</t>
<t tx="ekr.20060206111431.524">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20060206111431.525">def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName</t>
<t tx="ekr.20060206111431.526">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame</t>
<t tx="ekr.20060206111431.527">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20060206111431.528">def getBatchScript ():
    
    import leoGlobals as g
    windowFlag = False
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script, windowFlag</t>
<t tx="ekr.20060206111431.529">def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")</t>
<t tx="ekr.20060206111431.530"># debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
</t>
<t tx="ekr.20060206111431.531">def enable_gc_debug(event=None):
    
    if gc:
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            gc.DEBUG_LEAK | # Same as all below.
            gc.DEBUG_COLLECTABLE |
            gc.DEBUG_UNCOLLECTABLE |
            gc.DEBUG_INSTANCES |
            gc.DEBUG_OBJECTS |
            gc.DEBUG_SAVEALL
        )
        g.app.trace_gc_inited = True
    else:
        es('Can not import gc module',color='blue')</t>
<t tx="ekr.20060206111431.532">def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
</t>
<t tx="ekr.20060206111431.533"></t>
<t tx="ekr.20060206111431.534">def collectGarbage():
    
    if not g.app.trace_gc: return
    
    if not g.app.trace_gc_inited:
        g.enable_gc_debug()
    
    if not g.app.trace_gc_inited:
        g.app.trace_gc = False
    
    try: gc.collect()
    except: pass
</t>
<t tx="ekr.20060206111431.535">def printGcSummary (message='',trace=False):
    
    if not message:
        message = g.callerName(n=2)

    # g.collectGarbage()
    enable_gc_debug

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = 'garbage: %d, objects: %d, %s' % (n,n2,message)
        if trace:
            print s
        else:
            g.es_print(s)
    except:
        traceback.print_exc()</t>
<t tx="ekr.20060206111431.536">def printGcAll (message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()
    
    d = {} ; objects = gc.get_objects()
    g.es_print('-' * 30)
    g.es_print('%d objects' % len(objects),message)

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            g.es_print('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            g.es_print('%40s %7d' % (t,d.get(t)))
</t>
<t tx="ekr.20060206111431.537">def printGcObjects(message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()

    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        lastObjectCount = n2

        g.es_print('-' * 30)
        g.es_print("garbage: %d, objects: %d, delta: %d %s" % (n,n2,delta,message))
        
        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

    except:
        traceback.print_exc()</t>
<t tx="ekr.20060206111431.538">import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            g.es_print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.es_print("args", args)
            if varargs: g.es_print("varargs",varargs)
            if varkw: g.es_print("varkw",varkw)
            if defaults:
                g.es_print("defaults...")
                for s in defaults: g.es_print(s)

lastFunctionsDict = funcDict
funcDict = {}</t>
<t tx="ekr.20060206111431.539">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    t = type(obj)
    if t == 'instance':
        try: t = obj.__class__
        except: pass
    typesDict[t] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.es_print("%+6d =%7d %s" % (delta2,n2,key))
    
lastTypesDict = typesDict
typesDict = {}</t>
<t tx="ekr.20060206111431.540"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()

    global lastObjectsDict
    objects = gc.get_objects()
    
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            seqs += 1
        else:
            g.es_print(o)
        i += 1
    g.es_print('-' * 40)
    g.es_print('dicts: %d, sequences: %d' % (dicts,seqs))
    g.es_print("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))</t>
<t tx="ekr.20060206111431.541"></t>
<t tx="ekr.20060206111431.542">def printGc(message=None):
    
    if not g.app.trace_gc: return None
    
    if not message:
        message = g.callerName(n=2)
        
    printGcObjects(message)
    printGcRefs(message)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(message)
        
    
</t>
<t tx="ekr.20060206111431.543">def printGcRefs (message=''):

    refs = gc.get_referrers(app.windowList[0])
    g.es_print('-' * 30,message)

    if g.app.trace_gc_verbose:
        g.es_print("refs of", app.windowList[0])
        for ref in refs:
            g.es_print(type(ref))
    else:
        g.es_print("%d referers" % len(refs))</t>
<t tx="ekr.20060206111431.544"></t>
<t tx="ekr.20060206111431.545"></t>
<t tx="ekr.20060206111431.546"></t>
<t tx="ekr.20060206111431.547">@nocolor

- Replaced k.tkBindingFromSetting by k.shortcutFromSetting.
- Replaced k.canonicalizeShortcut by k.shortcutFromSetting.
- Replaced k.bindShortcut with bindKey.
- k.makeBindingsFromCommandsDict does not call k.bindKey for mode bindings.</t>
<t tx="ekr.20060206111431.548"></t>
<t tx="ekr.20060206111431.549">@nocolor

This is logically and practically dubious.
True, a screen redraw shouldn't mess with the focus,
but there are the following problems:

1. c.endUpdate can happen anytime, and it could interfere with other efforts to set focus.
2. g.app.get_focus might get the 'wrong' or a 'bad' focus.</t>
<t tx="ekr.20060206111431.550">Trying to avoid this *does not work*</t>
<t tx="ekr.20060206111431.551"># Right now it 'restores' the focus to the tree if it was in the tre previously.
</t>
<t tx="ekr.20060206111431.552"></t>
<t tx="ekr.20060206111431.553"></t>
<t tx="ekr.20060206111431.554"># insert, clone, copy node, etc.</t>
<t tx="ekr.20060206111431.555"></t>
<t tx="ekr.20060206111431.556">And any other bindings.

Remove hard binding for Ctrl-T in log pane.</t>
<t tx="ekr.20060206111431.557">class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others</t>
<t tx="ekr.20060206111431.558"></t>
<t tx="ekr.20060206111431.559">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
</t>
<t tx="ekr.20060206111431.560">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        g.trace()
        self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl</t>
<t tx="ekr.20060206111431.561">def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log</t>
<t tx="ekr.20060206111431.562">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu</t>
<t tx="ekr.20060206111431.563"></t>
<t tx="ekr.20060206111431.564">def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)</t>
<t tx="ekr.20060206111431.565">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font</t>
<t tx="ekr.20060206111431.566">def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)</t>
<t tx="ekr.20060206111431.567">def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d</t>
<t tx="ekr.20060206111431.568">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20060206111431.569">def SetWidgetFontFromConfig (self,logCtrl=None):

    c = self.c

    if not logCtrl: logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant", "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)

    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass

    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
        
setFontFromConfig = SetWidgetFontFromConfig # Renaming supresses a pychecker warning.</t>
<t tx="ekr.20060206111431.570"></t>
<t tx="ekr.20060206111431.571">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        self.c.setLog()
        self.frame.tree.OnDeactivate()
        self.c.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20060206111431.572">def hasFocus (self):
    
    return self.c.get_focus() == self.logCtrl</t>
<t tx="ekr.20060206111431.573">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()</t>
<t tx="ekr.20060206111431.574">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...</t>
<t tx="ekr.20060206111431.575"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    c = self.c
    
    # print 'tkLog.put',self.c.shortFileName(),tabName,g.callers()

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
        self.logCtrl.update_idletasks()
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;</t>
<t tx="ekr.20060206111431.576"># New in 4.4b1: Restore the focus to a standard place.
focus_widget = c.get_focus()
name = c.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = c.frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
c.widgetWantsFocus(focus_widget)
</t>
<t tx="ekr.20060206111431.577">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="ekr.20060206111431.578">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20060206111431.579"></t>
<t tx="ekr.20060206111431.580">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t and t.delete('1.0','end')</t>
<t tx="ekr.20060206111431.581">def createTab (self,tabName):
    
    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    &lt;&lt; Create the tab's text widget &gt;&gt;

    if tabName != 'Log':
        # c.k doesn't exist when the log pane is created.
        # k.makeAllBindings will call setTabBindings('Log')
        self.setTabBindings(tabName)</t>
<t tx="ekr.20060206111431.582">t = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: t.configure(bg=bg)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=t)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = t

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags</t>
<t tx="ekr.20060206111431.583">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.584">def hideTab (self,tabName):
    
    __pychecker__ = '--no-argsused' # tabName
    
    self.selectTab('Log')</t>
<t tx="ekr.20060206111431.585">def getSelectedTab (self):
    
    return self.tabName</t>
<t tx="ekr.20060206111431.586">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.587">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20060206111431.588">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    return tabFrame</t>
<t tx="ekr.20060206111431.589">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    text = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        text.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        g.trace()
        self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        g.trace()
        self.onClick(event,tabName)
    
    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20060206111431.590"></t>
<t tx="ekr.20060206111431.591">def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)</t>
<t tx="ekr.20060206111431.592">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)</t>
<t tx="ekr.20060206111431.593">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)</t>
<t tx="ekr.20060206111431.594">def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20060206111431.595"></t>
<t tx="ekr.20060206111431.596">@nocolor

A *major* improvement to the tree allocation code:

1.  Use p.key() to as keys to tree.visibleText.
 This greatly speeds up tree.findEditWidget

2. Eliminated the brain-dead requirement that previously-allocated widgets must match the position.
   - The allocation code just gets *any* previously allocated widget.
     This eliminates an n**2 search!
   - The ancient problem was that theId refers to the *window* not its Text widget:
     the *window* must be moved to the right spot.

3. recycleWidgets is simpler and a bit faster.

4. destroyWidgets now works: (the bug was not clearing tree.ids).</t>
<t tx="ekr.20060206111431.597">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.</t>
<t tx="ekr.20060206111431.598"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20060206111431.599"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20060206111431.600"># c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        ### c.beadList = c.beadList [-100:]
        # g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20060206111431.601"># The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# New in Leo 4.4: Limit the size of this list.
#### c.visitedList = c.visitedList[:100]

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!</t>
<t tx="ekr.20060206111431.602">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()</t>
<t tx="ekr.20060206111431.603">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    self.new_alloc = True
    
    # Configuration and debugging settings.
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.expanded_click_area = c.config.getBool("expanded_click_area")
    self.stats = c.config.getBool('show_tree_stats')
    self.trace = c.config.getBool('trace_tree')

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    if self.new_alloc:
        self.freeText = [] # A list of free Tk.Text widgets
    else:
        self.freeText = {} # Keys are vnodes, values are Tk.Text widgets
    self.freeUserIcons = []</t>
<t tx="ekr.20060206111431.604">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20060206111431.605"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20060206111431.606"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20060206111431.607">def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c

    if p and c:
        if self.new_alloc:
            aTuple = self.visibleText.get(p.key())
            if aTuple:
                t,theId = aTuple
                # if self.trace: g.trace('%4d' % (theId),self.textAddr(t),p.headString())
                return t
            else:
                # g.trace('oops: not found',p)
                return None
        else:
            # VERY SLOW.
            # Search the widget list for widget t with t.leo_position == p.
            # New in 4.2: the dictionary is a list of pairs(p,v)
            pairs = self.visibleText.get(p.v,[])
            for p2,t2,id2 in pairs:
                assert t2.leo_window_id == id2
                assert t2.leo_position == p2
                if p.equal(p2):
                    # g.trace('found',t2)
                    return t2
        
    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20060206111431.608">def setText (self,theId,t,s):
    
    """All changes to text widgets should come here."""

    if self.trace: g.trace('%4d' % (theId), self.textAddr(t),s)
            
    state = t.cget("state")
    if state != "normal":
        t.configure(state="normal")
    t.delete("1.0","end")
    t.insert("end",s)
    if state != "normal":
        t.configure(state=state)</t>
<t tx="ekr.20060206111431.609"></t>
<t tx="ekr.20060206111431.610">def newBox (self,p,x,y,image):
    
    canvas = self.canvas ; tag = "plusBox"

    if self.freeBoxes:
        theId = self.freeBoxes.pop(0)
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        
    if 0:
        if self.trace and self.verbose:
            g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),align=-20)

    assert(theId not in self.visibleBoxes)
    self.visibleBoxes.append(theId)

    # assert(not self.ids.get(theId))
    # assert(p)
    self.ids[theId] = p

    return theId</t>
<t tx="ekr.20060206111431.611">def newClickBox (self,p,x1,y1,x2,y2):
    
    canvas = self.canvas ; defaultColor = "" ; tag="clickBox" 

    if self.freeClickBoxes:
        theId = self.freeClickBoxes.pop(0)
        canvas.coords(theId,x1,y1,x2,y2)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        
    if 0:
        if self.trace:
            g.trace("%3d %3d %3d %3d %3d" % (theId,x1,y1,x2,y2),p.headString(),align=-20)

    assert(theId not in self.visibleClickBoxes)
    self.visibleClickBoxes.append(theId)
    
    # assert(p)
    # assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    return theId</t>
<t tx="ekr.20060206111431.612">def newIcon (self,p,x,y,image):
    
    canvas = self.canvas ; tag = "iconBox"

    if self.freeIcons:
        theId = self.freeIcons.pop(0)
        canvas.itemconfigure(theId,image=image)
        canvas.coords(theId,x,y)
    else:
        theId = canvas.create_image(x,y,image=image,anchor="nw",tag=tag)
        # assert(not self.ids.get(theId))

    # assert(theId not in self.visibleIcons)
    self.visibleIcons.append(theId)
    
    # assert(p)
    # assert(not self.iconIds.get(theId))
    # assert(not self.ids.get(theId))
    data = p,self.generation
    self.iconIds[theId] = data # Remember which vnode belongs to the icon.
    self.ids[theId] = p

    return theId</t>
<t tx="ekr.20060206111431.613">def newLine (self,p,x1,y1,x2,y2):
    
    canvas = self.canvas
    
    if self.freeLines:
        theId = self.freeLines.pop(0)
        canvas.coords(theId,x1,y1,x2,y2)
    else:
        theId = canvas.create_line(x1,y1,x2,y2,tag="lines",fill="gray50") # stipple="gray25")
        # assert(not self.ids.get(theId))

    # assert(not self.ids.get(theId))
    self.ids[theId] = p
    self.visibleLines.append(theId)

    return theId</t>
<t tx="ekr.20060206111431.614">def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k

    if self.new_alloc:
        found = len(self.freeText) &gt; 0
        if found:
            t,theId = self.freeText.pop()
            if self.trace: g.trace('%4d' % (theId),self.textAddr(t),'recycled')
            canvas.coords(theId,x,y) # Make the window visible again.
                # theId is the id of the *window* not the text.
    else:
        d = self.freeText
        key = p.v ; pList = d.get(key,[])
    
        # Return only Tk.Text widgets with an exact match with p.
        found = False
        for i in xrange(len(pList)):
            p2,t,theId = pList[i]
            if p2 == p:
                del pList[i]
                theId = t.leo_window_id
                assert(theId)
                ### assert(t.leo_position == p2)
                canvas.coords(theId,x,y)
                t.configure(font=self.font) # 12/17/04
                found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        t.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
        if self.trace: g.trace('%4d' % (theId),self.textAddr(t),'** new')
            
    # Common configuration.
    # assert(not self.ids.get(theId))
    self.ids[theId] = p # Add the id of the *window*
    self.setText(theId,t,p.headString())
    t.configure(width=self.headWidth(p=p))
    t.leo_position = p # This p never changes.
        # *Required*: onHeadlineClick uses w.leo_position to get p

    if self.new_alloc:
        # Keys are p.key().  Entries are (t,theId)
        self.visibleText [p.key()] = t,theId
    else:
        t.leo_generation = self.generation
        assert(theId == t.leo_window_id)
        # Keys are p.v.  Values are pairs (p,t,theId)
        key = p.v
        pList = self.visibleText.get(key,[])
        pList.append((p,t,theId),)
        self.visibleText[key] = pList
    return t</t>
<t tx="ekr.20060206111431.615">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

instance_tag = t.bindtags()[0]
t.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
t.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
t.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)</t>
<t tx="ekr.20060206111431.616">def recycleWidgets (self):
    
    canvas = self.canvas
    
    for theId in self.visibleBoxes:
        # assert(theId not in self.freeBoxes)
        self.freeBoxes.append(theId)
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []
    
    for theId in self.visibleClickBoxes:
        # assert(theId not in self.freeClickBoxes)
        self.freeClickBoxes.append(theId)
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []
    
    for theId in self.visibleIcons:
        # assert(theId not in self.freeIcons)
        self.freeIcons.append(theId)
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []
        
    for theId in self.visibleLines:
        # assert(theId not in self.freeLines)
        self.freeLines.append(theId)
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []
    
    if self.new_alloc:
        aList = self.visibleText.values()
        for t,theId in aList:
            # assert theId == t.leo_window_id
            canvas.coords(theId,-100,-100)
            t.leo_position = None # Allow the position to be freed.
        self.freeText.extend(aList)
        self.visibleText = {}
    else:
        for key in self.visibleText.keys():
            visList = self.visibleText.get(key,[])
            freeList = self.freeText.get(key,[])
            for data in visList:
                p,t,theId = data
                # assert theId == t.leo_window_id
                canvas.coords(theId,-100,-100)
                freeList.append(data)
            self.freeText[key] = freeList
        self.visibleText = {}
        
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []</t>
<t tx="ekr.20060206111431.617">def destroyWidgets (self):

    self.ids = {}

    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleUserIcons = []

    self.visibleText = {}
    
    self.freeText = []
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    
    self.canvas.delete("all")</t>
<t tx="ekr.20060206111431.618">def showStats (self):

    z = []
    for kind,a,b in (
        ('boxes',self.visibleBoxes,self.freeBoxes),
        ('clickBoxes',self.visibleClickBoxes,self.freeClickBoxes),
        ('icons',self.visibleIcons,self.freeIcons),
        ('lines',self.visibleLines,self.freeLines),
        ('tesxt',self.visibleText.values(),self.freeText),
    ):
        z.append('%10s used: %4d free: %4d' % (kind,len(a),len(b)))
        
    g.es_print('\n' + '\n'.join(z))</t>
<t tx="ekr.20060206111431.619">@nocolor

- Mode help should show commands first, not bindings.
- Fixed-space font looks much better in log.
- All log panes now use proper font setting.
- Eliminated clone-find-all, selection-only, show-context checkboxes in the Find tab.
- Eliminated toggle-find-clone-find-all-option command</t>
<t tx="ekr.20060206111431.620">@nocolor

- Fixed bug in strokeFromEvent.

- Replaced some calls to g.app.gui.get_focus: This is unreliable.  More should be removed.

- Fixed masterMenuHandler.

- Removed master click handlers: not needed.
    - Added FocusIn, FocusOut bindings. (Moved code from masterClickHandler).

- Made many changes so that modes work again with k.masterKeyHandler.

- Minibuffer finds now work.
    - New search-again command: it reverts to find-with-present-options if there is no search pattern.
    - Added support for minibufferSearchesShowFindTab option.

- Revised @find mode.  It is now usable and is bound to Ctrl-F.

- Made toggle-find-regex-options work.</t>
<t tx="ekr.20060206111431.621">@nocolor

- Special keys now work in all modes uniformly.

The Aha was to honor 'mini' bindings first in k.masterKeyHandler.

- Added gc traces every 100 keystrokes, every command, every 10 redraws.

- There is no doubt about it: the focus is being ripped into the headline sometimes.

*** This is *totally weird*: tkFrame.set_focus was setting c to a tkFrame(!!)
    - How did the call to c.config ever work???????????????????

- Changed calling sequence of g.app.gui.get_focus so it takes a commander, not a frame.
    - This makes gui.get_focus use the same calling sequence as g.set_focus.

- Added traces that report weird focus issues.

- k.setLabel now restores the focus.

- Changed find keystrokes:
    - Bound Ctrl-F to search-with-present-options.
    - Eliminate Find mode: I never used it.
    - Bound Shift-Ctrl-F to find-options mode.

- Added c.gui ivar and c.set_focus and c.get_focus methods.  Useful abbreviations.

- Fixed bug in createModeBindings: it must not call k.strokeFromSetting again.

- Revised replace-string command so it sets up arguments for Tab find.
    - This is different from the normal Emacs replace-string command, but it works well in Leo.

- Added smaller Find/Change text in Find Tab when show_only_find_tab_options is True.
  It is often helpful to see this state.

- Enable minibufferSearchesShowFindTab.  This turns out to be quite useful and natural.

- Replaced frame.xWantsFocus with c.xWantsFocus.

- Restored masterClickHandlers.  FocusOut can not do the job.

* Giant breakthrough:  The problem with focus 'sticking' in the Pmw.Notebook was due to a call to bringToFront.  Apparently, the side effect was to assign a focus to the widget that had it previously.  This makes sense, and can not be considered a Tk bug.

- With this breakthrough, I have been able to remove almost all calls to w.update in Leo.

* Also, I can not dispense with the calls to w.after that were used to draw the status line.  The master key and click handlers now call the update method directly.  This may ease a major stress on Tk.</t>
<t tx="ekr.20060206111431.622">- Ran Leo with Python23 to test memory allocation.

- Call update_idletasks when writing to the log.</t>
<t tx="ekr.20060214141244"></t>
<t tx="ekr.20060214141244.1"></t>
<t tx="ekr.20060214141244.2"># The callback must return what k.masterKeyHandler returns (i.e., 'break')</t>
<t tx="ekr.20060214141244.3">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    self.findButtonCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)</t>
<t tx="ekr.20060214141244.4">def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    # g.trace(wname,s,i,j)
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText</t>
<t tx="ekr.20060214141244.5"># Paste-text crashed when pasting into minibuffer
</t>
<t tx="ekr.20060214141244.6">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3549737
By: nobody

\src\leoEditCommands.py:340: 
Warning: 'yield' will become a reserved keyword 

for python2.2 leoEditCommands.py needs
from __future__ import generators

Also changed the following plugins:

at_produce.py
fastGotoNode.py
rst3.py
zodb.py</t>
<t tx="ekr.20060214141244.7"># http://sourceforge.net/forum/message.php?msg_id=3571104</t>
<t tx="ekr.20060214141244.8"># The keys to k.bindingsDict must be consistent with what this method returns.
# See 'about internal bindings' for details.
 
def strokeFromEvent (self,event):
    
    c = self.c ; k = c.k
    if event is None: return ''
    state = event.state or 0
    keysym = event.keysym or ''
    ch = event.char
    result = []
    shift = (state &amp; 1) == 1 # Not used for alpha chars.
    caps  = (state &amp; 2) == 2 # Not used at all.
    ctrl  = (state &amp; 4) == 4
    # Linux uses, 8 and 0x80, XP uses 0x20000.
    alt   = (state &amp; 0x20000) == 0x20000 or (state &amp; 8) == 8 or (state &amp; 0x80) == 0x80
    plain = len(keysym) == 1 # E.g., for ctrl-v the keysym is 'v' but ch is empty.
    
    # g.trace('ch',repr(ch),'keysym',repr(keysym),'state: %x' % state)
    
    # The big aha: we can ignore the shift state.
    if plain:
        if shift and ch.isalpha() and ch.islower():
            g.trace('oops: inconsistent shift state. shift: %s, ch: %s' % (shift,ch))
        ch = keysym
        shift = False
    else:
        ch2 = k.tkBindNamesInverseDict.get(keysym)
        if ch2:
            ch = ch2
            if len(ch) == 1: shift = False
        else:
            # Just use the unknown keysym.
            g.trace('*'*30,'unknown keysym',repr(keysym))
    
    if alt: result.append('Alt+')
    if ctrl: result.append('Ctrl+')
    if shift: result.append('Shift+')
    result.append(ch)
    result = ''.join(result)
    # g.trace('state',state,'keysym',keysym,'result',repr(result))
    return result</t>
<t tx="ekr.20060214141244.9"></t>
<t tx="ekr.20060214141244.10">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3549737

The fix was to call getBool rather than getString.</t>
<t tx="ekr.20060214141244.11">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20060214141244.12"></t>
<t tx="ekr.20060214141244.13">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3237845

On startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.</t>
<t tx="ekr.20060214141244.14">def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir
    
    verbose = not g.app.unitTesting
    &lt;&lt; return if we can set leoID from sys.leoID &gt;&gt;
    &lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;
    &lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;
    &lt;&lt; put up a dialog requiring a valid id &gt;&gt;
    &lt;&lt; attempt to create leoID.txt &gt;&gt;</t>
<t tx="ekr.20060214141244.15"># This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr &amp; getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es_print("leoID = " + g.app.leoID, color='red')
    return
else:
    g.app.leoID = None</t>
<t tx="ekr.20060214141244.16">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) &gt; 0:
                g.app.leoID = s
                if verbose:
                    g.es_print("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es_print("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es_print('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()</t>
<t tx="ekr.20060214141244.17">try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId
        return
        
except Exception:
    pass</t>
<t tx="ekr.20060214141244.18"># New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# g.trace(g.app.leoID)
g.es_print("leoID = %s" % (repr(g.app.leoID)),color="blue")</t>
<t tx="ekr.20060214141244.19">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                g.es_print(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')</t>
<t tx="ekr.20060214141244.20">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3534349
By: edcdave

Saving the Leo file is not sufficient - I have to exit the document and open
it again before the rst destination directory is set correctly.

The fix was to set c.frame.openDirectory in save and 

@color
</t>
<t tx="ekr.20060214141244.21"></t>
<t tx="ekr.20060214141244.22">def new (self,event=None):

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(c,v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    finally:
        c.endUpdate()
        frame.body.setFocus()
    return c # For unit test.</t>
<t tx="ekr.20060214141244.23">def open (self,event=None):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.app.globalOpenDir = frame.openDirectory
            # g.es('current directory: %s' %  g.app.globalOpenDir)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.bodyWantsFocus()</t>
<t tx="ekr.20060214141244.24">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20060214141244.25">def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20060214141244.26">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20060214141244.27">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20060214141244.28">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20060214141244.29">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20060214141244.30">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20060214141244.31">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20060214141244.32">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20060214141244.33">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20060214141244.34">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20060214141244.35">def close (self,event=None):
    
    """Handle the File-Close command."""

    g.app.closeLeoWindow(self.frame)</t>
<t tx="ekr.20060214141244.36">def save (self,event=None):

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060214141244.37">def saveAs (self,event=None):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20060214141244.38">def saveTo (self,event=None):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)</t>
<t tx="ekr.20060214141244.39">def revert (self,event=None):
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20060214141244.40">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20060214141244.41"></t>
<t tx="ekr.20060214141244.42">@nocolor

The problem: event.widget is the minibuffer.  It must be the body text.

- k.fullCommand saves the initial event and passes it on to callAltXFunction.

- There was a bug in c.masterFocusHandler.  The correct test for 'no change' is:

    if c.hasFocusWidget and c.requestedFocusWidget == c.hasFocusWidget:

** Important: the 'extra' calls to set_focus are correct. The minibuffer messes
with the tab pane, and so we *must* be careful to yank the focus back to the
body.</t>
<t tx="ekr.20060214141244.43">def sortLines (self,event,which=None):

    c = self.c ; k = c.k ; w = event.widget
    g.trace(c.widget_name(w))
    if not self._chckSel(event): return
    self.beginCommand()
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=False)</t>
<t tx="ekr.20060214141244.44"></t>
<t tx="ekr.20060214141244.45">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)</t>
<t tx="ekr.20060214141244.46">def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)
    
    # Don't do this in headlines!
    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
        
    return w</t>
<t tx="ekr.20060214141244.47">def endCommand(self,label=None,changed=True,setLabel=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b:
        name = b.name
        if name.startswith('body'):
            if changed:
                c.frame.body.onBodyChanged(undoType=b.undoType,
                    oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        elif name.startswith('head'):
            g.trace('Should not happen: endCommand does not support undo in headlines')
        else: pass
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()</t>
<t tx="ekr.20060214141244.48">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060214141244.49">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()</t>
<t tx="ekr.20060214141244.50">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if trace: g.trace(
        'requested',c.widget_name(c.requestedFocusWidget),
        'present',c.widget_name(c.hasFocusWidget),
        g.callers())
    
    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        # if trace: g.trace('no change.',c.widget_name(w))
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        # g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler</t>
<t tx="ekr.20060214141244.51"></t>
<t tx="ekr.20060214141244.52">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20060214141244.53">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20060214141244.54">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20060214141244.55">def invalidateFocus (self):
    
    '''Indicate that the focus is in an invalid location, or is unknown.'''
    
    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    # g.trace(g.callers())
    
</t>
<t tx="ekr.20060214141244.56">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20060214141244.57">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20060214141244.58">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20060214141244.59">def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.</t>
<t tx="ekr.20060214141244.60">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers(8))</t>
<t tx="ekr.20060214141244.61">def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)</t>
<t tx="ekr.20060214141244.62">def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)</t>
<t tx="ekr.20060214141244.63">def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
</t>
<t tx="ekr.20060214141244.64">There was a problem during unit tests.  It may have other implications.</t>
<t tx="ekr.20060214141244.65">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3538274

It's not clear that there were serious problems with the plugin, but I improved the code and error messages.  All features work for me.

Several plugins use the icon-double-click hook.  The reported problems could have been due to plugin conflicts.
</t>
<t tx="ekr.20060214141244.66">http://sourceforge.net/forum/message.php?msg_id=3517080

Patch for CLeo to allow check-marks:
-----------------------------------------------------
Line 412 in def draw_arrow:
replace 
............canvas.create_line(v.iconx-10,v.icony+7,v.iconx+5,v.icony+7,fill
= 'Gray50',width=1)

with
............#@........&lt;&lt; Blank Check &gt;&gt;
............#@+node:rjries.20060113114142:&lt;&lt; Blank Check &gt;&gt;
............#@&lt;&lt; Point Setter &gt;&gt;
............#@+node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
............# Define the 3 points of a check mark to allow quick adjustment
............XpointA = v.iconx  -15+3
............YpointA = v.icony  +8-2
............XpointB = v.iconx  -7
............YpointB = v.icony  +13
............XpointC = v.iconx  +5
............YpointC = v.icony  -2
............#@nonl
............#@-node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
............#@nl
............# "white-out" the check mark
............canvas.create_line(XpointA, YpointA, XpointB, YpointB,
fill=colour,width=2)
............canvas.create_line(XpointB, YpointB, XpointC, YpointC,
fill=colour,width=2)
............#@nonl
............#@-node:rjries.20060113114142:&lt;&lt; Blank Check &gt;&gt;
............#@nl
............# restore line 
............canvas.create_line(v.iconx-12,v.icony+7,v.iconx+6,v.icony+7,fill
= 'Gray50',width=1)

-----------------------------------------------------
Line 421-422 in def draw_tick (**not draw_arrow):
replace 
........canvas.create_line(v.iconx+13-5,v.icony+8,v.iconx+13,v.icony+13,fill=colour,width=2)
........canvas.create_line(v.iconx+13,v.icony+13,v.iconx+13+12,v.icony-2,fill=colour,width=2)

with

........#@....&lt;&lt; Point Setter &gt;&gt;
........#@+node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
........# Define the 3 points of a check mark to allow quick adjustment
........XpointA = v.iconx  -15+3
........YpointA = v.icony  +8-2
........XpointB = v.iconx  -7
........YpointB = v.icony  +13
........XpointC = v.iconx  +5
........YpointC = v.icony  -2
........#@nonl
........#@-node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
........#@nl
........# draw the check-mark
........canvas.create_line(XpointA, YpointA, XpointB, YpointB,
fill=colour,width=2)
........canvas.create_line(XpointB, YpointB, XpointC, YpointC,
fill=colour,width=2)

-----------------------------------------------------
Line 598 in def priority_menu
replace
............# (self.donePriority,'Done'),
with
............(self.donePriority,'Done'),
</t>
<t tx="ekr.20060214141244.67"></t>
<t tx="ekr.20060214141244.68">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3571431
By: ktenney

To reiterate a request:

When doing File-&gt;Open the default directory should the directory which
was navigated to for previous 'Open'

What I did:

- Defined g.app.globalOpenDir # The directory last used to open a file.</t>
<t tx="ekr.20060214141244.69"># We no longer specify default extensions so that we can open and save files without extensions.</t>
<t tx="ekr.20060214141244.70">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    
    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)</t>
<t tx="ekr.20060214141244.71">def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir=g.app.globalOpenDir or g.os_path_abspath(os.getcwd()),

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)</t>
<t tx="ekr.20060214141244.72"></t>
<t tx="ekr.20060214141244.73">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    # Configuration and debugging settings.
    self.expanded_click_area    = c.config.getBool('expanded_click_area')
    self.gc_before_redraw       = c.config.getBool('gc_before_redraw')
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')

    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')
    self.trace_select           = c.config.getBool('trace_select')
    self.trace_stats            = c.config.getBool('show_tree_stats')
 
    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []</t>
<t tx="ekr.20060214141244.74">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20060214141244.75"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20060214141244.76"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20060214141244.77">def disableGcTrace (self,event=None):
    
    g.app.trace_gc = False
    
def enableGcTrace (self,event=None):
    
    g.app.trace_gc = True
    g.app.trace_gc_inited = False
    g.enable_gc_debug()</t>
<t tx="ekr.20060214141244.78"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            g.trace(self.redrawCount,g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20060214141244.79">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20060214141244.80"># debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
</t>
<t tx="ekr.20060214141244.81">def enable_gc_debug(event=None):
    
    if g.app.trace_gc_inited:
        return
    
    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
            g.es('enabled verbose gc stats',color='blue')
        else:
            gc.set_debug(gc.DEBUG_STATS)
            g.es('enabled brief gc stats',color='blue')
    else:
        g.es('Can not import gc module',color='blue')</t>
<t tx="ekr.20060214141244.82">def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
</t>
<t tx="ekr.20060214141244.83"></t>
<t tx="ekr.20060214141244.84">def collectGarbage():

    try:
        if not g.app.trace_gc_inited and g.app.trace_gc_verbose:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            g.es_print('Collecting garbage')

        gc.collect()
    except:
        pass
        
    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True</t>
<t tx="ekr.20060214141244.85">def printGcSummary (message='',trace=False):
    
    if not message:
        message = g.callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = 'garbage: %d, objects: %d, %s' % (n,n2,message)
        if trace:
            print s
        else:
            g.es_print(s)
    except:
        traceback.print_exc()</t>
<t tx="ekr.20060214141244.86">def printGcAll (message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    d = {} ; objects = gc.get_objects()
    g.es_print('-' * 30)
    g.es_print('%d objects' % len(objects),message)

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            g.es_print('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            g.es_print('%40s %7d' % (t,d.get(t)))
</t>
<t tx="ekr.20060214141244.87">def printGcObjects(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        lastObjectCount = n2

        g.es_print('-' * 30)
        g.es_print("garbage: %d, objects: %d, delta: %d %s" % (n,n2,delta,message))
        
        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

    except:
        traceback.print_exc()</t>
<t tx="ekr.20060214141244.88">import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            g.es_print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.es_print("args", args)
            if varargs: g.es_print("varargs",varargs)
            if varkw: g.es_print("varkw",varkw)
            if defaults:
                g.es_print("defaults...")
                for s in defaults: g.es_print(s)

lastFunctionsDict = funcDict
funcDict = {}</t>
<t tx="ekr.20060214141244.89">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    t = type(obj)
    if t == 'instance':
        try: t = obj.__class__
        except: pass
    typesDict[t] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.es_print("%+6d =%7d %s" % (delta2,n2,key))
    
lastTypesDict = typesDict
typesDict = {}</t>
<t tx="ekr.20060214141244.90"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectsDict
    objects = gc.get_objects()
    
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            seqs += 1
        else:
            g.es_print(o)
        i += 1
    g.es_print('-' * 40)
    g.es_print('dicts: %d, sequences: %d' % (dicts,seqs))
    g.es_print("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))</t>
<t tx="ekr.20060214141244.91"></t>
<t tx="ekr.20060214141244.92">def printGc(message=None):
    
    if not g.app.trace_gc: return None
    
    if not message:
        message = g.callerName(n=2)
        
    printGcObjects(message)
    printGcRefs(message)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(message)
        
    
</t>
<t tx="ekr.20060214141244.93">def printGcRefs (message=''):

    refs = gc.get_referrers(app.windowList[0])
    g.es_print('-' * 30,message)

    if g.app.trace_gc_verbose:
        g.es_print("refs of", app.windowList[0])
        for ref in refs:
            g.es_print(type(ref))
    else:
        g.es_print("%d referers" % len(refs))</t>
<t tx="ekr.20060214141244.94"></t>
<t tx="ekr.20060214141244.95">def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060214141244.96"></t>
<t tx="ekr.20060214141244.97">def importDerivedFile (self,event=None):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(parent=p,paths=names)</t>
<t tx="ekr.20060214141244.98">def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.
    
    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20060214141244.99">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20060214141244.100">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20060214141244.101"></t>
<t tx="ekr.20060214141244.102"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')
    
    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
        undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate(scroll=True)
        c.recolor()</t>
<t tx="ekr.20060214141244.103">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())</t>
<t tx="ekr.20060214141244.104"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)</t>
<t tx="ekr.20060214141244.105">@nocolor

Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 1959, in cutText
    w.configure(width=f.tree.headWidth(s=s))
UnboundLocalError: local variable 's' referenced before assignment
</t>
<t tx="ekr.20060226131237"></t>
<t tx="ekr.20060226131237.1">extract                             = Shift-Ctrl-D
extract-names                       = Shift-Ctrl-N
extract-section                     = Shift-Ctrl-S  # Shift-Ctrl-E: end-of-line-extend-selection

write-at-file-nodes                 = Shift-Ctrl-W # Was enter-file-mode.
write-dirty-at-file-nodes           = Shift+Ctrl+Q

# Removed definitions of find and file modes.  I never used them.</t>
<t tx="ekr.20060226131237.2"></t>
<t tx="ekr.20060226131237.3">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3545403
By: e

more str() to remove...

with some non ascii headline,
a traceback after an executeScript
calls goto linenumber

 \leo-4-4-\src\leoCommands.py, line 1822, in goToScriptLineNumber
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
 \leo-4-4-\src\leoCommands.py", line 1466, in goToLineNumber
    if p.matchHeadline(vnodeName):
 \leo-4-4-\src\leoNodes.py, line 1631, in matchHeadline
    def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
 \leo-4-4-\src\leoNodes.py, line 665, in matchHeadline
    return s == h[0:len(s)]
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc2 in position 1: ordinal
not in range(128)

aÂ² + bÂ² = cÂ²
</t>
<t tx="ekr.20060226131237.4">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""
    
    v = self
    
    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')
    
    return h.startswith(pattern)</t>
<t tx="ekr.20060226131237.5"></t>
<t tx="ekr.20060226131237.6">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3577681
By: caugm

I added this line on leoTkinterMenu.py and now the activate-x-menu commands
works on Linux, at least for me ;-)

--- src/leoTkinterMenu.py       2006-02-15 12:06:28.000000000 -0200
+++ src2/leoTkinterMenu.py      2006-02-15 12:06:24.000000000 -0200
@@ -41,6 +41,7 @@
             if x is None:
                  x = 0 ; g.trace('oops, no menu offset: %s' % menuName)
             menu.post(topx+d.get(menuName,0),topy)
+            menu.focus()
         else:
             g.trace('oops, no menu: %s' % menuName)
     #@nonl


</t>
<t tx="ekr.20060226131237.7">def activateMenu (self,menuName):
    
    c = self.c ;  top = c.frame.top
    topx,topy = top.winfo_rootx(),top.winfo_rooty()
    menu = c.frame.menu.getMenu(menuName)

    if menu:
        d = self.computeMenuPositions()
        x = d.get(menuName)
        if x is None:
             x = 0 ; g.trace('oops, no menu offset: %s' % menuName)
        
        menu.tk_popup(topx+d.get(menuName,0),topy) # Fix by caugm.  Thanks!
    else:
        g.trace('oops, no menu: %s' % menuName)</t>
<t tx="ekr.20060226131237.8"></t>
<t tx="ekr.20060226131237.9">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3573470

Still to do:

? What are the state masks for Num_Lock on Linux and darwin?

What I did:

- Added support for trace_key_event setting.
- Added support for ignore_caps_lock setting.
- Added Caps_Lock and Num_Lock to k.tkNamesList and in the list of
  special keys in k.masterCommand and k.masterKeyHandlerHelper.
- Added support for k.ignore_unbound_non_ascii_keys logic in masterKeyHandlerHelper.
- Disabled unknown keysym trace in k.strokeFromEvent.
- Enabled the international keyboard on XP as an aid to testing.
- Added support for swap_mac_keys setting in k.shortcutFromSetting.
- Added support for non-ascii characters in the minibuffer.</t>
<t tx="ekr.20060226131237.10"></t>
<t tx="ekr.20060226131237.11">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter')
    self.enable_calltips                = c.config.getBool('enable_calltips')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;
    
    self.autoCompleter = autoCompleterClass(self)</t>
<t tx="ekr.20060226131237.12">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20060226131237.13">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20060226131237.14">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}</t>
<t tx="ekr.20060226131237.15">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20060226131237.16">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())</t>
<t tx="ekr.20060226131237.17">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20060226131237.18">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20060226131237.19">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20060226131237.20">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20060226131237.21"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20060226131237.22"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="ekr.20060226131237.23">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20060226131237.24">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('&lt;').rstrip('&gt;')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)</t>
<t tx="ekr.20060226131237.25">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20060226131237.26"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20060226131237.27">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060226131237.28">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''</t>
<t tx="ekr.20060226131237.29"></t>
<t tx="ekr.20060226131237.30">def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''
    
    shortcut = shortcut or ''
    shortcut1 = shortcut[:]

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('&lt;'):   shortcut = shortcut[1:]
    if shortcut.endswith('&gt;'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]

    return len(shortcut) == 1</t>
<t tx="ekr.20060226131237.31">def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip()
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting</t>
<t tx="ekr.20060226131237.32">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0</t>
<t tx="ekr.20060226131237.33">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False</t>
<t tx="ekr.20060226131237.34"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')</t>
<t tx="ekr.20060226131237.35">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)</t>
<t tx="ekr.20060226131237.36">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True,last),
)
    
shortcut = ''.join([val for flag,val in table if flag])</t>
<t tx="ekr.20060226131237.37"># The keys to k.bindingsDict must be consistent with what this method returns.
# See 'about internal bindings' for details.
 
def strokeFromEvent (self,event):
    
    k = self
    if event is None: return ''
    trace = k.trace_key_event and not g.app.unitTesting
    state = event.state or 0
    keysym = event.keysym or ''
    ch = event.char
    result = []
    shift = (state &amp; 1) == 1 # Not used for alpha chars.
    caps  = (state &amp; 2) == 2
    ctrl  = (state &amp; 4) == 4
    # Linux uses, 8 and 0x80, XP uses 0x20000.
    if sys.platform=='darwin':
        alt = (state&amp;0x10) == 0x10
        #num = False
    elif sys.platform.startswith('win'):
        alt = (state &amp; 0x20000) == 0x20000
        #num = (state &amp; 8) == 8
    else:
        #num = False # ???
        alt = (state &amp; 8) == 8 or (state &amp; 0x80) == 0x80
    plain = len(keysym) == 1 # E.g., for ctrl-v the keysym is 'v' but ch is empty.
    
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym),'state: %x' % state)
    
    # Undo the effect of the caps-lock key.
    if caps:
        if alt or ctrl or k.ignore_caps_lock:
            if shift:
                ch = ch.upper() ; keysym = keysym.upper()
                event.char=event.char.upper()
                event.keysym=event.keysym.upper()
            else:
                ch = ch.lower() ; keysym = keysym.lower()
                event.char=event.char.lower()
                event.keysym=event.keysym.lower()
    
    # The big aha: we can ignore the shift state.
    if plain:
        if shift and ch.isalpha() and ch.islower():
            g.trace('oops: inconsistent shift state. shift: %s, ch: %s' % (shift,ch))
        ch = keysym
        shift = False
    else:
        ch2 = k.tkBindNamesInverseDict.get(keysym)
        if ch2:
            ch = ch2
            if len(ch) == 1: shift = False
        else:
            # Just use the unknown keysym.
            pass # There are lots of keysyms that Leo may not know about.
            # g.trace('*'*30,'unknown keysym',repr(keysym))
    
    if alt: result.append('Alt+')
    if ctrl: result.append('Ctrl+')
    if shift: result.append('Shift+')
    result.append(ch)
    result = ''.join(result)
    # g.trace('state',state,'keysym',keysym,'result',repr(result))
    return result</t>
<t tx="ekr.20060226131237.38">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = stroke.lstrip('&lt;').rstrip('&gt;')
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    return '&lt;%s&gt;' % stroke</t>
<t tx="ekr.20060226131237.39">def prettyPrintKey (self,stroke):
    
    s = stroke and stroke.strip().lstrip('&lt;').rstrip('&gt;')
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '&lt;%s&gt;' % s</t>
<t tx="ekr.20060226131237.40">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    special = keysym in (
        'Caps_Lock','Num_Lock','Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None

    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and g.safeStringCompare(stroke,k.abortAllModesKey): # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060226131237.41"># Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060226131237.42">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060226131237.43">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060226131237.44">def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060226131237.45">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val</t>
<t tx="ekr.20060226131237.46">def masterKeyHandlerHelper (self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in (
        'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
        'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if trace and (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)

    if 0:
        if stroke is None:
            if trace: g.trace('no stroke: using strokeFromEvent')
            stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings, but *not* in auto-complete state.
        if not state.startswith('auto-'):
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state in ('full-command','auto-complete'):
            # Do the default state action.
            if trace: g.trace('calling state function')
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-standard-keys':
                return 'break'
            g.trace('do-standard-keys',w_name,stroke)
        # Third, pass keys to the general mode handler.
        else:
            d =  k.masterBindingsDict.get(state)
            if d:
                # A typical state
                b = d.get(stroke)
                # g.trace(d.keys())
                if b:
                    if trace: g.trace('calling generalModeHandler')
                    k.generalModeHandler (event,
                        commandName=b.commandName,func=b.func,
                        modeName=state,nextMode=b.nextMode)
                    return 'break'
                else:
                    if trace: g.trace('calling modeHelp')
                    k.modeHelp(event)
                    return 'break'
            else:
                g.trace('No state dictionary for %s' % state)
                return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
        # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060226131237.47">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'</t>
<t tx="ekr.20060226131237.48">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()</t>
<t tx="ekr.20060226131237.49">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    
    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            i = w.index('insert')
            w.insert(i,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
</t>
<t tx="ekr.20060226131237.50">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20060226131237.51">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20060226131237.52">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20060226131237.53"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20060226131237.54">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20060226131237.55">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20060226131237.56">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()</t>
<t tx="ekr.20060226131237.57"></t>
<t tx="ekr.20060226131237.58">@nocolor

- Created k.completeAllBindings, called last in k.makeAllBindings. This binds
all keystrokes in k.bindingsDict to k.masterKeyHandler with an optional stroke
argument. This allows k.masterKeyhandler to dispense with the problematic call
to k.strokeFromEvent. This is all that is really required. 

- Added code to menu.createMenuEntries that clears the accelerator on MacOS for
any key that isn't a control, alt or command key. This solves the recurring
problems with the Return key. The only effect is that the menu won't mention a
binding that is actually in effect, but apparently that cannot be helped.

- Added g.safeCompareStrings, which may, or may not, fix the crasher when
comparing k.abortAllModesKey to the incoming keystroke in k.masterKeyHandler.
It's a bit tricky to test.

- The ignore_caps_lock is no longer functional. Sigh. This depends on knowing
the Caps_Lock bit in key events. I may put this back later, but I can't delay a6
even a minute for this.</t>
<t tx="ekr.20060226131237.59"></t>
<t tx="ekr.20060226131237.60">@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.

trace = self.trace_minibuffer and not g.app.unitTesting</t>
<t tx="ekr.20060226131237.61">def minibufferWantsFocus(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocus(c.miniBufferWidget)
    else:
        c.bodyWantsFocus()

def minibufferWantsFocusNow(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocusNow(c.miniBufferWidget)
    else:
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20060226131237.62">def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    trace = self.trace_minibuffer and not g.app.unitTesting
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        while s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        
    else:
        s = k.svar and k.svar.get()
        
    trace and g.trace(repr(s))

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

</t>
<t tx="ekr.20060226131237.63">def protectLabel (self):
    
    k = self ; w = self.widget
    if not w: return

    if self.useTextWidget:
        w.update_idletasks()
        k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()</t>
<t tx="ekr.20060226131237.64">def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''</t>
<t tx="ekr.20060226131237.65">def setLabel (self,s,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace(repr(s),g.callers())

    if self.useTextWidget:
        w.delete('1.0','end')
        w.insert('1.0',s)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s</t>
<t tx="ekr.20060226131237.66">def extendLabel(self,s,select=False,protect=False):
    
    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting
    
    trace and g.trace(repr(s))
    if not s: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j,insert=j)
        if protect:
            k.protectLabel()
</t>
<t tx="ekr.20060226131237.67">def setLabelBlue (self,label=None,protect=False):
    
    k = self ; w = k.widget
    if not w: return
    
    w.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)</t>
<t tx="ekr.20060226131237.68">def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return
    
    w.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey</t>
<t tx="ekr.20060226131237.69">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    
    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            i = w.index('insert')
            w.insert(i,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
</t>
<t tx="ekr.20060226131237.70">def getEditableTextRange (self):
    
    k = self ; w = self.widget ; n = 0
    # trace = self.trace_minibuffer and not g.app.unitTesting
    
    s = w.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1] ; n += 1
        
    i = w.index('1.%d' % len(k.mb_prefix))
    j = w.index('end -%dc' % n)
    
    # if trace: g.trace(i,j)
    return i,j
</t>
<t tx="ekr.20060226131237.71"></t>
<t tx="ekr.20060226131237.72">@killcolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=3578917
By: davidmcnab

&gt; Then type control-a and alt-a, Shift-a, CapsLock-A and CapsLock-Shift-A and
tell me what the trace reports.

Ctrl-A:

ch '\x01' keysym 'a' state: 4
masterKeyHandlerHelper: 'Ctrl+a' state None
masterKeyHandlerHelper: text found Ctrl+a = beginning-of-line

Alt-A:

strokeFromEvent: ch 'a' keysym 'a' state: 8
masterKeyHandlerHelper: 'Alt+a' state None
masterKeyHandlerHelper: all found Alt+a = sort-siblings

Shift-A:

trokeFromEvent: ch 'A' keysym 'A' state: 1
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-A:

trokeFromEvent: ch '' keysym 'Caps_Lock' state: 0
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'A' keysym 'A' state: 2
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-Shift-A:

strokeFromEvent: ch '' keysym 'Caps_Lock' state: 0
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'a' keysym 'A' state: 3
strokeFromEvent: oops: inconsistent shift state. shift: True, ch: a
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

&gt; Ditto for all the above with numlock down. 

Numlock down:

trokeFromEvent: ch '' keysym 'Num_Lock' state: 0
strokeFromEvent: ****************************** unknown keysym 'Num_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func

Ctrl-A:

strokeFromEvent: ch '\x01' keysym 'a' state: 14
masterKeyHandlerHelper: 'Ctrl+a' state None
masterKeyHandlerHelper: text found Ctrl+a = beginning-of-line

Alt-A:

strokeFromEvent: ch 'a' keysym 'a' state: 18
masterKeyHandlerHelper: 'Alt+a' state None
masterKeyHandlerHelper: all found Alt+a = sort-siblings

Shift-A:

strokeFromEvent: ch 'A' keysym 'A' state: 11
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-A:

strokeFromEvent: ch '' keysym 'Caps_Lock' state: 10
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'A' keysym 'A' state: 12
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-Shift-A:

strokeFromEvent: ch '' keysym 'Caps_Lock' state: 10
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'a' keysym 'A' state: 13
strokeFromEvent: oops: inconsistent shift state. shift: True, ch: a
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

And finally:

a:

strokeFromEvent: ch 'a' keysym 'a' state: 0
masterKeyHandlerHelper: 'a' state None
masterKeyHandlerHelper: 'a' no func

u (typed by itself):

strokeFromEvent: ch 'u' keysym 'u' state: 0
masterKeyHandlerHelper: 'u' state None
masterKeyHandlerHelper: 'u' no func

ui (typed quickly):

trokeFromEvent: ch 'u' keysym 'u' state: 0
masterKeyHandlerHelper: 'u' state None
masterKeyHandlerHelper: 'u' no func
strokeFromEvent: ch 'i' keysym 'i' state: 80
masterKeyHandlerHelper: 'Alt+i' state None
masterKeyHandlerHelper: ignoring unbound special key

Hope this helps
David

</t>
<t tx="ekr.20060226131237.73">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3579430
By: dcbbcd

I hope you can still read this after SourceForge
messed up my indentation.

Cursor in the body pane

1. Pressing the modifier keys without any other key

   1.1 Left Alt
       Pressing left Alt without any other key gives no report
   
   1.2 Right Alt
       Pressing right Alt without any other key reports:
   
       strokeFromEvent: ch '' keysym 'ISO_Level3_Shift' state: 0
       masterKeyHandlerHelper: '' state None
       masterKeyHandlerHelper: '' no func
   
   1.3. Shift, Ctrl and Caps Lock
        Pressing any of the Shift, Ctrl and Caps Lock keys without 
        any other key gives no report
   
2. Pressing the modifier keys with the letter a

   2.1 Left Alt
   
       strokeFromEvent: ch 'a' keysym 'a' state: 8
       masterKeyHandlerHelper: 'Alt+a' state None
       masterKeyHandlerHelper: all found Alt+a = sort-siblings
       
   2.2 Right Alt
   
       This is very interesting! The following exception occurs, but the
       correct character is inserted in the body pane.
   
       Error: 1
       UnicodeDecodeError Exception in Tk callback
         Function: &lt;bound method keyHandlerClass.masterKeyHandler
of &lt;leoKeys.keyHandlerClass instance at 0xb77e278c&gt;&gt; (type: &lt;type
'instancemethod'&gt;)
         Args: (&lt;Tkinter.Event instance at 0xb78afa0c&gt;,)
         Event type: KeyPress (type num: 2)
       Traceback (innermost last):
         File "/home/dennis/Desktop/leo-4-4-x1/extensions/Pmw/Pmw_1_2/lib/PmwBas
e.py", line 1752, in __call__
           return apply(self.func, args)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1396, in
masterKeyHandler
           val = self.masterKeyHandlerHelper(event)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1423, in
masterKeyHandlerHelper
           if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
4: ordinal not in range(128)

       ================================================
         Event contents:
           char: Ã¦
           delta: 38
           height: ??
           keycode: 38
           keysym: ??
           keysym_num: 0
           num: ??
           send_event: False
           serial: 38133
           state: 128
           time: 2652121
           type: 2
           widget: .-1214814356.-1214814004.-1214354900.-1214354996.body-pane
           width: ??
           x: 128
           x_root: 833
           y: 92
           y_root: 410

   2.3 Shift
   
       strokeFromEvent: ch 'A' keysym 'A' state: 1
       masterKeyHandlerHelper: 'A' state None
       masterKeyHandlerHelper: 'A' no func
       
   2.4 Ctrl
   
       strokeFromEvent: ch '\x01' keysym 'a' state: 4
       masterKeyHandlerHelper: 'Ctrl+a' state None
       masterKeyHandlerHelper: text found Ctrl+a = beginning-of-line
       
   2.5 Caps Lock
       
       If Caps Lock is turned on pressing "a" results in 
       
       strokeFromEvent: ch 'A' keysym 'A' state: 2
       masterKeyHandlerHelper: 'a' state None
       masterKeyHandlerHelper: 'a' no func
       
       and the lowercase "a" is inserted!!!
       
3. Various combinations

   3.1 Shift-(Left)Ctrl a
   
       strokeFromEvent: ch '\x01' keysym 'A' state: 5
       masterKeyHandlerHelper: 'Ctrl+A' state None
       masterKeyHandlerHelper: text found Ctrl+A =
beginning-of-line-extend-selection
       
   3.2 Shift-(Right)Ctrl a    
   
       This relates to "2.2 Right Alt". The exception occurs, but the correct
       character is inserted.
   
       Error: 4
       UnicodeDecodeError Exception in Tk callback
         Function: &lt;bound method keyHandlerClass.masterKeyHandler
of &lt;leoKeys.keyHandlerClass instance at 0xb77e278c&gt;&gt; (type: &lt;type
'instancemethod'&gt;)
         Args: (&lt;Tkinter.Event instance at 0xb77893cc&gt;,)
         Event type: KeyPress (type num: 2)
       Traceback (innermost last):
         File "/home/dennis/Desktop/leo-4-4-x1/extensions/Pmw/Pmw_1_2/lib/PmwBas
e.py", line 1752, in __call__
           return apply(self.func, args)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1396, in
masterKeyHandler
           val = self.masterKeyHandlerHelper(event)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1423, in
masterKeyHandlerHelper
           if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
10: ordinal not in range(128)
       
       ================================================
         Event contents:
           char: Ã?
           delta: 38
           height: ??
           keycode: 38
           keysym: ??
           keysym_num: 0
           num: ??
           send_event: False
           serial: 76290
           state: 129
           time: 3254177
           type: 2
           widget: .-1214814356.-1214814004.-1214354900.-1214354996.body-pane
           width: ??
           x: 170
           x_root: 875
           y: 118
           y_root: 436

   3.3 (Left)Alt-Shift a
   
       strokeFromEvent: ch 'A' keysym 'A' state: 9
       masterKeyHandlerHelper: 'Alt+A' state None
       masterKeyHandlerHelper: text found Alt+A = select-all
       
       If I start this combination with pressing Shift first and then Alt
       and the the letter "a" the following is reported before the above:
       
       strokeFromEvent: ch '' keysym 'Meta_L' state: 1
       masterKeyHandlerHelper: 'Shift+' state None
       masterKeyHandlerHelper: 'Shift+' no func
       
   3.4 Shift-(Right)Alt
   
       strokeFromEvent: ch '' keysym 'ISO_Level3_Shift' state: 1
       masterKeyHandlerHelper: 'Shift+' state None
       masterKeyHandlerHelper: 'Shift+' no func
       
   3.5 (Right)Alt-Shift
   
       strokeFromEvent: ch '' keysym '??' state: 80
       masterKeyHandlerHelper: 'Alt+' state None
       masterKeyHandlerHelper: 'Alt+' no func
</t>
<t tx="ekr.20060226131237.74">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3576790
By: yarkot

On WinXT PC -

If NUM-LOCK key is enabled, main keyboard mappings all "scrogged";  need to
unlock NUM-LOCK for keys to work.
</t>
<t tx="ekr.20060226131237.75"></t>
<t tx="ekr.20060226131237.76">def setMinibufferBindings (self):
    
    '''Create bindings for the minibuffer..'''
    
    f = self ; c = f.c ; k = c.k ; t = f.miniBufferWidget
    
    if not c.useTextMinibuffer: return
    
    for kind,callback in (
        ('&lt;Key&gt;',           k.masterKeyHandler),
        ('&lt;Button-1&gt;',      k.masterClickHandler),
        ('&lt;Button-3&gt;',      k.masterClick3Handler),
        ('&lt;Double-1&gt;',      k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',      k.masterDoubleClick3Handler),
    ):
        t.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            t.bind("&lt;Button-2&gt;",frame.OnPaste)</t>
<t tx="ekr.20060226131237.77">def createBindings (self):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k ; t = self.bodyCtrl
    
    t.bind('&lt;Key&gt;', k.masterKeyHandler)

    for kind,func,handler in (
        ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
        ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        t.bind(kind,bodyClickCallback)
            
    if sys.platform.startswith('win'):
        # Support Linux middle-button paste easter egg.
        t.bind("&lt;Button-2&gt;",frame.OnPaste)</t>
<t tx="ekr.20060226131237.78">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)
    
    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)
    
    k.completeAllBindingsForWidget(w)</t>
<t tx="ekr.20060226131237.79">def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    &lt;&lt; make bindings for a common binding widget &gt;&gt;

    self.canvas.bind('&lt;Key&gt;',k.masterKeyHandler)
    self.canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    &lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</t>
<t tx="ekr.20060226131237.80">self.bindingWidget = t = Tk.Text(self.canvas,name='bindingWidget')

t.bind('&lt;Key&gt;',k.masterKeyHandler)

table = (
    ('&lt;Button-1&gt;',       k.masterClickHandler,          tree.onHeadlineClick),
    ('&lt;Button-3&gt;',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('&lt;Double-Button-1&gt;',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('&lt;Double-Button-3&gt;',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    t.bind(a,treeBindingCallback)
    
self.textBindings = t.bindtags()</t>
<t tx="ekr.20060226131237.81">where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '&lt;Button-1&gt;',self.onClickBoxClick),
    ('iconBox','&lt;Button-1&gt;',self.onIconBoxClick),
    ('iconBox','&lt;Double-1&gt;',self.onIconBoxDoubleClick),
    ('iconBox','&lt;Button-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;Double-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;B1-Motion&gt;',self.onDrag),
    ('iconBox','&lt;Any-ButtonRelease-1&gt;',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)</t>
<t tx="ekr.20060226131237.82">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)
        
    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'
        
    if 0: # No longer needed.
        def findTabClickCallback(event,self=self):
            c = self.c ; k = c.k ; w = event.widget
            k.keyboardQuit(event)
            w and c.widgetWantsFocusNow(w)
            return k.masterClickHandler(event)

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    findButtonBindingCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)</t>
<t tx="ekr.20060226131237.83">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20060226131237.84">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)</t>
<t tx="ekr.20060226131237.85">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')</t>
<t tx="ekr.20060226131237.86"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="ekr.20060226131237.87">def createBindings (self):
    
    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
           </t>
<t tx="ekr.20060226131237.88"></t>
<t tx="ekr.20060226131237.89">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = shortcut.strip().lstrip('&lt;').rstrip('&gt;')
        # if shortcut.startswith('&lt;Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility</t>
<t tx="ekr.20060226131237.90">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060226131237.91">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)</t>
<t tx="ekr.20060226131237.92">def bindKeyToDict (self,pane,stroke,func,commandName):
    
    k = self
    d =  k.masterBindingsDict.get(pane,{})
    
    stroke = stroke.lstrip('&lt;').rstrip('&gt;')
    
    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__)) # ,len(d.keys()))

    if d.get(stroke):
        g.es('ignoring duplicate definition of %s to %s in %s' % (
            stroke,commandName,pane), color='blue')
    else:
        d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
        k.masterBindingsDict [pane] = d</t>
<t tx="ekr.20060226131237.93">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c
    
    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)
    
    return k.bindKey('all',shortcut,openWithCallback,'open-with')</t>
<t tx="ekr.20060226131237.94">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20060226131237.95">def completeAllBindings (self):
    
    '''New in 4.4b3: make an actual binding in *all* the standard places.
    
    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    
    k = self ; c = k.c ; f = c.frame
    bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
    canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
    bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
    if not bodyCtrl or not canvas: return
    
    for w in (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget):
        self.completeAllBindingsForWidget(w)
        
        
        # for stroke in  k.bindingsDict.keys():
        # 
            # def bindKeyCallback (event,k=k,stroke=stroke):
                # return k.masterKeyHandler(event,stroke=stroke)
            # bindStroke = k.tkbindingFromStroke(stroke)
            # try:
                # # g.trace(bindStroke,c.widget_name(w))
                # w.bind(bindStroke,bindKeyCallback)
            # except Exception:
                # g.es_print('exception binding %s to %s' % (
                    # bindStroke,c.widget_name(w)),color='blue')</t>
<t tx="ekr.20060226131237.96">def completeAllBindingsForWidget (self,w):
    
    k = self ; c = k.c
    
    for stroke in  k.bindingsDict.keys():
    
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
        bindStroke = k.tkbindingFromStroke(stroke)

        try:
            # g.trace(bindStroke,c.widget_name(w))
            w.bind(bindStroke,bindKeyCallback)
        except Exception:
            g.es_print('exception binding %s to %s' % (
                bindStroke,c.widget_name(w)),color='blue')</t>
<t tx="ekr.20060226131237.97">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()</t>
<t tx="ekr.20060226131237.98">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))</t>
<t tx="ekr.20060226131237.99">def initSpecialIvars (self):
    
    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c ; trace = c.config.getBool('trace_bindings')
    
    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found:
            g.trace('no setting for %s' % commandName)</t>
<t tx="ekr.20060226131237.100">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)</t>
<t tx="ekr.20060226131237.101"></t>
<t tx="ekr.20060226131237.102">def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''
    
    shortcut = shortcut or ''
    shortcut1 = shortcut[:]

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('&lt;'):   shortcut = shortcut[1:]
    if shortcut.endswith('&gt;'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]

    return len(shortcut) == 1</t>
<t tx="ekr.20060226131237.103">def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip()
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting</t>
<t tx="ekr.20060226131237.104">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0</t>
<t tx="ekr.20060226131237.105">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False</t>
<t tx="ekr.20060226131237.106"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')</t>
<t tx="ekr.20060226131237.107">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)</t>
<t tx="ekr.20060226131237.108">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True,last),
)
    
shortcut = ''.join([val for flag,val in table if flag])</t>
<t tx="ekr.20060226131237.109"># The keys to k.bindingsDict must be consistent with what this method returns.
# See 'about internal bindings' for details.
 
def strokeFromEvent (self,event):
    
    k = self
    if event is None: return ''
    trace = k.trace_key_event and not g.app.unitTesting
    state = event.state or 0
    keysym = event.keysym or ''
    ch = event.char
    result = []
    shift = (state &amp; 1) == 1 # Not used for alpha chars.
    caps  = (state &amp; 2) == 2
    ctrl  = (state &amp; 4) == 4
    # Linux uses, 8 and 0x80, XP uses 0x20000.
    if sys.platform=='darwin':
        alt = (state&amp;0x10) == 0x10
        #num = False
    elif sys.platform.startswith('win'):
        alt = (state &amp; 0x20000) == 0x20000
        #num = (state &amp; 8) == 8
    else:
        #num = False # ???
        alt = (state &amp; 8) == 8 or (state &amp; 0x80) == 0x80
    plain = len(keysym) == 1 # E.g., for ctrl-v the keysym is 'v' but ch is empty.
    
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym),'state: %x' % state)
    
    # Undo the effect of the caps-lock key.
    if caps:
        if alt or ctrl or k.ignore_caps_lock:
            if shift:
                ch = ch.upper() ; keysym = keysym.upper()
                event.char=event.char.upper()
                event.keysym=event.keysym.upper()
            else:
                ch = ch.lower() ; keysym = keysym.lower()
                event.char=event.char.lower()
                event.keysym=event.keysym.lower()
    
    # The big aha: we can ignore the shift state.
    if plain:
        if shift and ch.isalpha() and ch.islower():
            g.trace('oops: inconsistent shift state. shift: %s, ch: %s' % (shift,ch))
        ch = keysym
        shift = False
    else:
        ch2 = k.tkBindNamesInverseDict.get(keysym)
        if ch2:
            ch = ch2
            if len(ch) == 1: shift = False
        else:
            # Just use the unknown keysym.
            pass # There are lots of keysyms that Leo may not know about.
            # g.trace('*'*30,'unknown keysym',repr(keysym))
    
    if alt: result.append('Alt+')
    if ctrl: result.append('Ctrl+')
    if shift: result.append('Shift+')
    result.append(ch)
    result = ''.join(result)
    # g.trace('state',state,'keysym',keysym,'result',repr(result))
    return result</t>
<t tx="ekr.20060226131237.110">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = stroke.lstrip('&lt;').rstrip('&gt;')
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    return '&lt;%s&gt;' % stroke</t>
<t tx="ekr.20060226131237.111">def prettyPrintKey (self,stroke):
    
    s = stroke and stroke.strip().lstrip('&lt;').rstrip('&gt;')
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '&lt;%s&gt;' % s</t>
<t tx="ekr.20060226131237.112">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20060226131237.113">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'</t>
<t tx="ekr.20060226131237.114">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()</t>
<t tx="ekr.20060226131237.115">def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    # g.trace(c.widget_name(w))
    
    if stroke: # New in 4.4a6:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)</t>
<t tx="ekr.20060226131237.116">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val</t>
<t tx="ekr.20060226131237.117">def masterKeyHandlerHelper (self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in (
        'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
        'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if trace and (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)

    if 0:
        if stroke is None:
            if trace: g.trace('no stroke: using strokeFromEvent')
            stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings, but *not* in auto-complete state.
        if not state.startswith('auto-'):
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state in ('full-command','auto-complete'):
            # Do the default state action.
            if trace: g.trace('calling state function')
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-standard-keys':
                return 'break'
            g.trace('do-standard-keys',w_name,stroke)
        # Third, pass keys to the general mode handler.
        else:
            d =  k.masterBindingsDict.get(state)
            if d:
                # A typical state
                b = d.get(stroke)
                # g.trace(d.keys())
                if b:
                    if trace: g.trace('calling generalModeHandler')
                    k.generalModeHandler (event,
                        commandName=b.commandName,func=b.func,
                        modeName=state,nextMode=b.nextMode)
                    return 'break'
                else:
                    if trace: g.trace('calling modeHelp')
                    k.modeHelp(event)
                    return 'break'
            else:
                g.trace('No state dictionary for %s' % state)
                return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
        # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060226131237.118">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('&lt;').rstrip('&gt;')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)</t>
<t tx="ekr.20060226131237.119">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20060226131237.120"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20060226131237.121">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20060226131237.122">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''</t>
<t tx="ekr.20060226131237.123"> if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
4: ordinal not in range(128)
</t>
<t tx="ekr.20060226131237.124">if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
4: ordinal not in range(128)
</t>
<t tx="ekr.20060226131237.125">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    special = keysym in (
        'Caps_Lock','Num_Lock','Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None

    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and g.safeStringCompare(stroke,k.abortAllModesKey): # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20060226131237.126"># Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20060226131237.127">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20060226131237.128">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20060226131237.129">def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20060226131237.130">def safeStringCompare (s1,s2):

    s1 = g.toUnicode(s1,'utf-8')
    s2 = g.toUnicode(s2,'utf-8')
    return s1 == s2
    
def test_g_safeStringCompare ():
    
    assert g.safeStringCompare('a','á') is False
    assert g.safeStringCompare('','á') is False
    assert g.safeStringCompare('',u'á') is False
    assert g.safeStringCompare('a','a') is True
    assert g.safeStringCompare('á','á') is True
    assert g.safeStringCompare(u'á',u'á') is True</t>
<t tx="ekr.20060226131237.131"></t>
<t tx="ekr.20060226131237.132">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3577022

You can click nodes and get the UNL to display, but when arrowing around the
tree, UNL area flashes the unl and then clears it immediately.</t>
<t tx="ekr.20060226131237.133">class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others</t>
<t tx="ekr.20060226131237.134">def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("&lt;Button-1&gt;", self.onActivate)</t>
<t tx="ekr.20060226131237.135">def clear (self):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(g.callers())
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")</t>
<t tx="ekr.20060226131237.136">def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.widgetWantsFocus(t)
    self.enabled = True
        
def isEnabled(self):
    return self.enabled</t>
<t tx="ekr.20060226131237.137">def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""</t>
<t tx="ekr.20060226131237.138">def getFrame (self):
    
    return self.statusFrame</t>
<t tx="ekr.20060226131237.139">def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)</t>
<t tx="ekr.20060226131237.140">def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)
        
show = pack</t>
<t tx="ekr.20060226131237.141">def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(s,g.callers())
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()</t>
<t tx="ekr.20060226131237.142">def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack</t>
<t tx="ekr.20060226131237.143">def update (self):
    
    c = self.c ; w = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = w.index("insert")
    row,col = g.app.gui.getindex(w,index)

    if col &gt; 0:
        s = w.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if 1: # row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        # Important: this does not change the focus because labels never get focus.
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col</t>
<t tx="ekr.20060226131237.144">def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    if k:
        k.setDefaultUnboundKeyAction()
        # k.showStateAndMode() # Destroys UNL info.
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)</t>
<t tx="ekr.20060227101317">@nocolor

Turned off plugins.
Turned off idle-time hook.
Turned off colorizer.

** Leak 1:  c.beadList and c.visitedList

** Leak 2:  There is one object leaked for every headline visited.
    This may be p.edit_widget()
    
** The entire headline widget logic is bizarre.
    - Create p.id() -&gt; concatenation of vnodes.
    - Create tree.widgetForPositionDict.
        - keys are p.id's, values are widgets.
    - Change p.edit_widget() to tree.edit_widget(p)

** It looks like the find command is a major leak.</t>
<t tx="ekr.20060329122352"></t>
<t tx="ekr.20060329122352.1"></t>
<t tx="ekr.20060329122352.2"># http://sourceforge.net/forum/message.php?msg_id=3583335
</t>
<t tx="ekr.20060329122352.3"></t>
<t tx="ekr.20060329122352.4">def completeAllBindings (self):
    
    '''New in 4.4b3: make an actual binding in *all* the standard places.
    
    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    
    k = self ; c = k.c ; f = c.frame
    bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
    canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
    bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
    if not bodyCtrl or not canvas: return
    
    for w in (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget):
    
        self.completeAllBindingsForWidget(w)
</t>
<t tx="ekr.20060329122352.5">def completeAllBindingsForWidget (self,w):
    
    k = self
    
    for stroke in k.bindingsDict.keys():
        
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
            
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)</t>
<t tx="ekr.20060329122352.6">def completeOneBindingForWidget (self,w,stroke,callback):

    k = self ; c = k.c

    try:
        bindStroke = k.tkbindingFromStroke(stroke)
        # g.trace(bindStroke,c.widget_name(w))
        w.bind(bindStroke,callback)

    except Exception:
        g.es_print('exception binding %s to %s' % (
            bindStroke, c.widget_name(w)), color = 'blue')</t>
<t tx="ekr.20060329122352.7">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = stroke.lstrip('&lt;').rstrip('&gt;')
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    return '&lt;%s&gt;' % stroke</t>
<t tx="ekr.20060329122352.8">def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip()
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting</t>
<t tx="ekr.20060329122352.9">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0</t>
<t tx="ekr.20060329122352.10">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False</t>
<t tx="ekr.20060329122352.11"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')</t>
<t tx="ekr.20060329122352.12">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)</t>
<t tx="ekr.20060329122352.13">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)
    
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])</t>
<t tx="ekr.20060329122352.14">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3586962
By: bwmulder

the open-find-dialog is broken. 
 
Error: 4 
TypeError Exception in Tk callback 
Function: &lt;function findButtonCallback at 0x04E219F0&gt; (type: &lt;type 'function'&gt;) 
Args: () 
Traceback (innermost last): 
File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__ 
return apply(self.func, args) 
TypeError: findButtonCallback() takes at least 1 argument (0 given) 
</t>
<t tx="ekr.20060329122352.15"></t>
<t tx="ekr.20060329122352.16"># This was causing problems.  It may be an easy fix, but I kinda doubt it.</t>
<t tx="ekr.20060329122352.17">
</t>
<t tx="ekr.20060329122352.18">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3597694
By: tfer

Template Plug-in (maybe others tooo) co,plain when activated:
exception executing command
Traceback (most recent call last):
  File "leoCommands.py", line 265, in doCommand
    val = command(event)
  File "c:\Leo_Cvs\Leo\plugins\plugins_menu.py", line 350, in about
    PluginAbout(self.name, self.version, self.doc)
  File "c:\Leo_Cvs\Leo\plugins\plugins_menu.py", line 576, in __init__
    g.app.dialogs += 1
AttributeError: LeoApp instance has no attribute 'dialogs'</t>
<t tx="ekr.20060329122352.19"># To do: use the protected range to see whether can cut back.</t>
<t tx="ekr.20060329122352.20"></t>
<t tx="ekr.20060329122352.21">class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others</t>
<t tx="ekr.20060329122352.22">def __init__(self,c,finder):

    self.c = c
    self.k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []</t>
<t tx="ekr.20060329122352.23"></t>
<t tx="ekr.20060329122352.24">def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)</t>
<t tx="ekr.20060329122352.25">def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060329122352.26">def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        verbose and g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None</t>
<t tx="ekr.20060329122352.27">def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))</t>
<t tx="ekr.20060329122352.28">def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060329122352.29">def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060329122352.30">def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060329122352.31">def addChangeStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.change_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()
    
    s = t.get('1.0','end')

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20060329122352.32">def addFindStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20060329122352.33">def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)</t>
<t tx="ekr.20060329122352.34">def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        </t>
<t tx="ekr.20060329122352.35">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)</t>
<t tx="ekr.20060329122352.36">def generalChangeHelper (self,find_pattern,change_pattern):
    
    # g.trace(repr(change_pattern))
    
    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()</t>
<t tx="ekr.20060329122352.37">def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    c = self.c
    
    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()</t>
<t tx="ekr.20060329122352.38">def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()</t>
<t tx="ekr.20060329122352.39">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20060329122352.40">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search Backward:',self.reSearchBackward)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(event,tag,'Regexp Search:',self.reSearchForward)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060329122352.41">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search Backward: ',self.searchBackward)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(event,tag,'Search: ',self.searchForward)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060329122352.42">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(event,tag,'Search: ',self.searchWithPresentOptions)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060329122352.43">def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()</t>
<t tx="ekr.20060329122352.44">def stateZeroHelper (self,event,tag,prefix,handler):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)
    
    k.getArg(event,tag,1,handler,
        tabList=self.findTextList,completion=True,prefix=prefix)</t>
<t tx="ekr.20060329122352.45">def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)
        
def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)</t>
<t tx="ekr.20060329122352.46">def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060329122352.47">class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others</t>
<t tx="ekr.20060329122352.48"></t>
<t tx="ekr.20060329122352.49">def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20060329122352.50">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20060329122352.51">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)
        
    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'
        
    if 0: # No longer needed.
        def findTabClickCallback(event,self=self):
            c = self.c ; k = c.k ; w = event.widget
            k.keyboardQuit(event)
            w and c.widgetWantsFocusNow(w)
            return k.masterClickHandler(event)

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    findButtonBindingCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)</t>
<t tx="ekr.20060329122352.52">def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    
    if  self.optionsOnly:
        buttons = []
    else:
        &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)</t>
<t tx="ekr.20060329122352.53">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)</t>
<t tx="ekr.20060329122352.54">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20060329122352.55">def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20060329122352.56">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole &amp;Word", self.dict["whole_word"]),
    ("&amp;Ignore Case",self.dict["ignore_case"]),
    ("Wrap &amp;Around",self.dict["wrap"]),
    ("&amp;Reverse",    self.dict["reverse"]),
    ('Rege&amp;xp',     self.dict['pattern_match']),
    ("Mark &amp;Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&amp;Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
]

checkLists[1] = [
    ("Search &amp;Headline", self.dict["search_headline"]),
    ("Search &amp;Body",     self.dict["search_body"]),
    ("Mark &amp;Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20060329122352.57"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20060329122352.58">def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20060329122352.59">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20060329122352.60">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")</t>
<t tx="ekr.20060329122352.61">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20060329122352.62"></t>
<t tx="ekr.20060329122352.63">def findButtonCallback(self,event=None):
    
    self.findButton()
    return 'break'</t>
<t tx="ekr.20060329122352.64">def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()</t>
<t tx="ekr.20060329122352.65"></t>
<t tx="ekr.20060329122352.66">def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()</t>
<t tx="ekr.20060329122352.67">def findAgainCommand (self):
    
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s.endswith('\n'): s = s[:-1]
    
    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
</t>
<t tx="ekr.20060329122352.68">def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20060329122352.69">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20060329122352.70">def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()</t>
<t tx="ekr.20060329122352.71">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.widgetWantsFocus(t)</t>
<t tx="ekr.20060329122352.72">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"</t>
<t tx="ekr.20060329122352.73">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20060329122352.74">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20060329122352.75">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20060329122352.76">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20060329122352.77">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)</t>
<t tx="ekr.20060329122352.78"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20060329122352.79">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20060329122352.80">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None</t>
<t tx="ekr.20060329122352.81">def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-tab-find-all':                    self.findAll,
        
        # Thin wrappers on Find tab
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }</t>
<t tx="ekr.20060329122352.82"></t>
<t tx="ekr.20060329122352.83">def openFindTab (self,event=None,show=True):

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)</t>
<t tx="ekr.20060329122352.84"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20060329122352.85">def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler</t>
<t tx="ekr.20060329122352.86">def setFindScopeEveryWhere     (self, event): return self.setFindScope('entire-outline')
def setFindScopeNodeOnly       (self, event): return self.setFindScope('node-only')
def setFindScopeSuboutlineOnly (self, event): return self.setFindScope('suboutline-only')

def setFindScope (self, where): self.getHandler().setFindScope(where)

def showFindOptions      (self,event): self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event): return self.toggleOption('ignore_case')
def toggleMarkChangesOption    (self, event): return self.toggleOption('mark_changes')
def toggleMarkFindsOption      (self, event): return self.toggleOption('mark_finds')
def toggleRegexOption          (self, event): return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event): return self.toggleOption('reverse')
def toggleSearchBodyOption     (self, event): return self.toggleOption('search_body')
def toggleSearchHeadlineOption (self, event): return self.toggleOption('search_headline')
def toggleWholeWordOption      (self, event): return self.toggleOption('whole_word')
def toggleWrapSearchOption     (self, event): return self.toggleOption('wrap')

def toggleOption (self, ivar): self.getHandler().toggleOption(ivar)</t>
<t tx="ekr.20060329122352.87">def cloneFindAll       (self,event): self.getHandler().cloneFindAll(event)
def findAll            (self,event): self.getHandler().findAll(event)

def replaceString      (self,event): self.getHandler().replaceString(event)
def reSearchBackward   (self,event): self.getHandler().reSearchBackward(event)
def reSearchForward    (self,event): self.getHandler().reSearchForward(event)
def searchBackward     (self,event): self.getHandler().searchBackward(event)
def searchForward      (self,event): self.getHandler().searchForward(event)
def wordSearchBackward (self,event): self.getHandler().wordSearchBackward(event)
def wordSearchForward  (self,event): self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    self.getHandler().searchWithPresentOptions(event)</t>
<t tx="ekr.20060329122352.88">def findAgain (self,event):
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)</t>
<t tx="ekr.20060329122352.89">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20060329122352.90">def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocus()</t>
<t tx="ekr.20060329122352.91"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
        return

    if ch == '\b':
        g.trace('backspace not handled yet')
        return
    
    if ch:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        i = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if i:
            self.searchString = s
        else:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20060329122352.92">def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20060329122352.93">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    
    self.searchString = pattern
    self.incremental = True
    self.forward = forward
    self.regexp = regexp
   
    try:
        i = None
        if forward:
            i = w.search(pattern,"insert + 1c",stopindex='end',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the top of the buffer.
                    i = w.search(pattern,'1.0',stopindex='insert',regexp=regexp)
        else:
            i = w.search(pattern,'insert',backwards=True,stopindex='1.0',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the bottom of the buffer.
                    i = w.search(pattern,'end',backwards=True,stopindex='insert',regexp=regexp)
    except: pass
        
    # Don't call endSearch here.  We'll do that when the user hits return.
    if i and not i.isspace():
        w.mark_set('insert',i)
        w.see('insert')</t>
<t tx="ekr.20060329122352.94">def endSearch (self,i,j):

    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20060329122352.95">@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.

trace = self.trace_minibuffer and not g.app.unitTesting</t>
<t tx="ekr.20060329122352.96">def minibufferWantsFocus(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocus(c.miniBufferWidget)
    else:
        c.bodyWantsFocus()

def minibufferWantsFocusNow(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocusNow(c.miniBufferWidget)
    else:
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20060329122352.97">def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    trace = self.trace_minibuffer and not g.app.unitTesting
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        while s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        
    else:
        s = k.svar and k.svar.get()
        
    trace and g.trace(repr(s))

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

</t>
<t tx="ekr.20060329122352.98">def protectLabel (self):
    
    k = self ; w = self.widget
    if not w: return

    if self.useTextWidget:
        w.update_idletasks()
        k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()</t>
<t tx="ekr.20060329122352.99">def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''</t>
<t tx="ekr.20060329122352.100">def setLabel (self,s,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace(repr(s),g.callers())

    if self.useTextWidget:
        w.delete('1.0','end')
        w.insert('1.0',s)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s</t>
<t tx="ekr.20060329122352.101">def extendLabel(self,s,select=False,protect=False):
    
    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting
    
    trace and g.trace(repr(s))
    if not s: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j,insert=j)
        if protect:
            k.protectLabel()
</t>
<t tx="ekr.20060329122352.102">def setLabelBlue (self,label=None,protect=False):
    
    k = self ; w = k.widget
    if not w: return
    
    w.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)</t>
<t tx="ekr.20060329122352.103">def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return
    
    w.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey</t>
<t tx="ekr.20060329122352.104">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    
    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            i = w.index('insert')
            w.insert(i,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
</t>
<t tx="ekr.20060329122352.105">def getEditableTextRange (self):
    
    k = self ; w = self.widget ; n = 0
    # trace = self.trace_minibuffer and not g.app.unitTesting
    
    s = w.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1] ; n += 1
        
    i = w.index('1.%d' % len(k.mb_prefix))
    j = w.index('end -%dc' % n)
    
    # if trace: g.trace(i,j)
    return i,j
</t>
<t tx="ekr.20060329122352.106">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'</t>
<t tx="ekr.20060329122352.107">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()</t>
<t tx="ekr.20060329122352.108"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        data = [] ; n1 = 20; n2 = 4
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1 = commandName
                s2 = pane
                s3 = k.prettyPrintKey(key)
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)

    c.bodyWantsFocus()</t>
<t tx="ekr.20060329122352.109"># Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True):
    
    '''Handle tab completion when the user hits a tab.'''
    
    k = self ; c = k.c ; s = k.getLabel().strip()
    
    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        # g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex &gt;= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            k.computeCompletionList(defaultTabList,backspace=False)

    c.minibufferWantsFocusNow()</t>
<t tx="ekr.20060329122352.110"># Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList,completion=True):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c
    
    if 0:
        g.trace('completion',completion,
            len(k.mb_tabListPrefix) &gt; len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))
    
    if completion:
        if len(k.mb_tabListPrefix) &gt; len(k.mb_prefix):
            k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
            k.setLabel(k.mb_tabListPrefix)
            k.computeCompletionList(defaultCompletionList,backspace=True)
        # else:
            # k.keyboardQuit(event=None)
    else:
        s = k.getLabel(ignorePrompt=False)
        # g.trace(repr(s),repr(k.mb_prefix))
        if s and len(s) &gt; len(k.mb_prefix):
            k.setLabel(s[:-1])</t>
<t tx="ekr.20060329122352.111">@ To do:
    
- scan text for foreign languages.
@c

</t>
<t tx="ekr.20060329122352.112">@nocolor

- Fixed bug in setObjectAndMembersList so initial leadin is computed correctly.
- k.doBackSpace and autocompleter.doBackspace call keyboardQuit if there are no more completions.
- Disabled calltips in headlines.
- Calltips no longer add ')' in any circumstance.
- Calltips for builtins like reduce, getattr, etc.
- Better tab name when completing 'self'.
- Allow 'self' as an anchor.
- leading . shows all classes.  (must set self.object for this to be useful.
- Handle backspace across '.'
- . prints dict.keys and contents of lists.
- ! now toggles between brief and full listings.
- Make sure typing completion sticks.
- Start at the anchor (back chaining).
- Print number of matches for ... entries
- Print types in Autocomplete tab.
- Support ''.whatever()
- x? gives docstring.
- Dot chaining: remember previous object.
- Add f, frame, log, body to dicts.
- Define objectDict on first use so all objects are completely created.
- .! opens a list of Python modules.
- Recompute list if another . seen.
- Try python modules if leadinWord not found.
- Only enable for known languages. (Right now: python)
- Create database using inspect.
- Create enable-auto-completer-command and disable-auto-completer-command commands.
- Escape should retain present insert point and selection.
- Use space accept char, return as escape.</t>
<t tx="ekr.20060329122352.113">class autoCompleterClass:
    
    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.
    
    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others</t>
<t tx="ekr.20060329122352.114">def __init__ (self,k):
    
    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.object = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.

</t>
<t tx="ekr.20060329122352.115">def defineClassesDict (self):
    
    self.allClassesDict = {}
    
    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('&lt;class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z
        
    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
</t>
<t tx="ekr.20060329122352.116">def defineObjectDict (self):
    
    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'),    # An actual string object.
        (['c','old_c','new_c'], 'object',c),            # 'leoCommands','Commands'),
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), # 'leoTkinterFrame','leoTkinterFrame'),
        (['g'],                 'object',g),       # 'leoGlobals',None),
        (['p','p1','p2'],       'object',p),       # 'leoNodes','position'),         
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string),     # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),   # 'leoNodes','tnode'),  
        (['v','v1','v2'],       'object',p.v),     # 'leoNodes','vnode'),
        (['w','widget'],        'Tkinter','Text'),
    ]
    
    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)
    
    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        if not obj:
            g.trace('bad object',obj)
            continue
        for z in idList:
            self.objectDict[z]=obj
            # g.trace(obj)</t>
<t tx="ekr.20060329122352.117"></t>
<t tx="ekr.20060329122352.118">def autoComplete (self,event=None,force=False):
    
    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k
    w = event and event.widget or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)
    
    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'</t>
<t tx="ekr.20060329122352.119">def autoCompleteForce (self,event=None):
    
    return self.autoComplete(event,force=True)</t>
<t tx="ekr.20060329122352.120">def disableAutocompleter (self,event=None):
    self.k.enable_autocompleter = False
    
def disableCalltips (self,event=None):
    self.k.enable_calltips = False
    
def enableAutocompleter (self,event=None):
    self.k.enable_autocompleter = True
    
def enableCalltips (self,event=None):
    self.k.enable_calltips = True</t>
<t tx="ekr.20060329122352.121">def showCalltips (self,event=None,force=False):
    
    c = self.c ; k = c.k
    
    w = event and event.widget or c.get_focus()
    
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = g.app.gui.getTextSelection(w)
        self.selectedText = g.app.gui.getSelectedText(w)
        # self.getLeadinWord(w)
        self.leadinWord = self.findCalltipWord(w)
        self.object = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)
        
    return 'break'</t>
<t tx="ekr.20060329122352.122">def showCalltipsForce (self,event=None):
    
    return self.showCalltips(event,force=True)</t>
<t tx="ekr.20060329122352.123">def autoCompleterStateHandler (self,event):
    
    c = self.c ; k = self.k
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = event and event.keysym
    ch = event and event.char or ''
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in ('space','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == 'period':
        self.chain()
    elif keysym == 'question':
        self.info()
    elif keysym == 'exclam':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'</t>
<t tx="ekr.20060329122352.124"></t>
<t tx="ekr.20060329122352.125">def abort (self):
    
    k = self.k
    k.keyboardQuit(event=None)
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.
    
    c = self.c ; w = self.widget
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = g.app.gui.getTextSelection(w)
    if restore:
        w.delete(i,j)
        w.insert(i,self.selectedText)
    g.app.gui.setTextSelection(w,j,j,insert=j)
    
    self.clear()
    self.object = None</t>
<t tx="ekr.20060329122352.126">def appendTabName (self,word):
    
    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')
    
def clearTabName (self):
    
    self.setTabName('AutoComplete ')
    
def popTabName (self):
    
    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])
    
# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)</t>
<t tx="ekr.20060329122352.127">def appendToKnownObjects (self,obj):
    
    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)</t>
<t tx="ekr.20060329122352.128">def calltip (self,obj=None):
    
    c = self.c ; w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        &lt;&lt; try to set s from a Python global function &gt;&gt;

    if not s:
        &lt;&lt; get s using inspect &gt;&gt;
        
    &lt;&lt; remove 'self' from s, but not from args &gt;&gt;
    if isStringMethod:
        &lt;&lt; remove 's' from s *and* args &gt;&gt;

    s = s.rstrip(')') # Convenient.
    &lt;&lt; insert the text and set j1 and j2 &gt;&gt;

    # End autocompletion mode, restoring the selection.
    self.finish()
    c.widgetWantsFocusNow(w)
    g.app.gui.setSelectionRange(w,j1,j2,insert=j2)
    &lt;&lt; put the status line &gt;&gt;
</t>
<t tx="ekr.20060329122352.129"># The first line of the docstring is good enough.
f = __builtins__.get(self.leadinWord)
doc = f and f.__doc__
if doc:
    s = g.splitLines(doc)
    s = args = s and s[0] or ''
    i = s.find('(')
    if i &gt; -1: s = s[i:]
    s = s and s.strip() or ''</t>
<t tx="ekr.20060329122352.130">isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod:
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)</t>
<t tx="ekr.20060329122352.131">if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()</t>
<t tx="ekr.20060329122352.132">if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]</t>
<t tx="ekr.20060329122352.133">if g.app.gui.hasSelection(w):
    i,j = g.app.gui.getSelectionRange(w)
else:
    i = j = g.app.gui.getInsertPoint(w)
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')

if 1:
    j1 = w.index('%s + 1c' % j)
    j2 = w.index('%s + %sc' % (j,len(s)))
else:
    j1 = j2 = w.index('%s + 2c' % j)</t>
<t tx="ekr.20060329122352.134">c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))</t>
<t tx="ekr.20060329122352.135">def chain (self):
    
    c = self.c ; w = self.widget
    word = g.app.gui.getSelectedText(w)
    old_obj = self.object

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.object = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.object = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = g.app.gui.getInsertPoint(w)
        g.app.gui.setTextSelection(w,i,i,insert=i)
        # g.trace('chaining to',word,self.object)
        # Similar to start logic.
        self.prefix = ''
        self.selection = g.app.gui.getTextSelection(w)
        self.selectedText = g.app.gui.getSelectedText(w)
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
</t>
<t tx="ekr.20060329122352.136">def computeCompletionList (self,verbose=False):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) &lt; 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList
       
    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        g.es('%s' % (name),tabName=self.tabName)</t>
<t tx="ekr.20060329122352.137">def doBackSpace (self):

    '''Cut back to previous prefix.'''
    
    # g.trace(self.prefix,self.object,self.prevObjects)
    
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.object:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.object
        # g.trace(self.object,obj)
        w = self.widget
        i,j = g.app.gui.getTextSelection(w)
        ch = w.get(i+'-1c')
        # g.trace(ch)
        if ch == '.':
            self.object = obj
            w.delete(i+'-1c')
            i = w.index(i+'-1c wordstart')
            j = w.index(i+' wordend')
            word = w.get(i,j)
            g.app.gui.setSelectionRange(w,i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()</t>
<t tx="ekr.20060329122352.138">def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)</t>
<t tx="ekr.20060329122352.139">def extendSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
    else:
        i = j = g.app.gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    g.app.gui.setSelectionRange(w,i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')</t>
<t tx="ekr.20060329122352.140">def findAnchor (self,w):
    
    i = g.app.gui.getInsertPoint(w)
    
    while w.get(i + '-1c') == '.' and w.compare(i,'&gt;','1.0'):
        i = w.index(i + '-2c wordstart')

    j = w.index(i+' wordend')
    word = w.get(i,j)
    
    if word == '.': word = None
    
    # g.trace(i,j,repr(word),w.get(j))
    return j,word</t>
<t tx="ekr.20060329122352.141">def findCalltipWord (self,w):
    
    i = g.app.gui.getInsertPoint(w)
    
    if w.compare(i,'&gt;','1.0'):
        return w.get(i+'-1c wordstart',i+'-1c wordstart wordend')
    else:
        return ''</t>
<t tx="ekr.20060329122352.142">def finish (self):
    
    c = self.c ; k = self.k
    
    k.keyboardQuit(event=None)
    
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
        
    c.frame.body.onBodyChanged('Typing')
    self.clear()
    self.object = None</t>
<t tx="ekr.20060329122352.143"># The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):
    
    '''Simulate getattr function, regardless of langauge.'''
    
    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):
    
    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList</t>
<t tx="ekr.20060329122352.144">def getLeadinWord (self,w):
    
    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = g.app.gui.getInsertPoint(w)
    start = w.index(start+'-1c')
    i,word = self.findAnchor(w)
    if word.isdigit(): return False
    self.setObjectAndMembersList(word)
    
    # g.trace(word,self.object,len(self.membersList))

    if not word:
        return False
    elif not self.object:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while w.compare(i,'&lt;',start):
            if w.get(i) != '.':
                g.trace('oops: %s' % (repr(w.get(i))))
                return False
            i = w.index(i+'+1c')
            j = w.index(i+' wordend')
            word = w.get(i,j)
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.object:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
    </t>
<t tx="ekr.20060329122352.145">def getMembersList (self,obj):
    
    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []</t>
<t tx="ekr.20060329122352.146">def info (self):
    
    c = self.c ; doc = None ; obj = self.object ; w = self.widget

    word = g.app.gui.getSelectedText(w)
    
    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word): return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es(doc,tabName='Info')</t>
<t tx="ekr.20060329122352.147">def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget

    if ch in (string.letters + string.digits + '_' ):
        # Look ahead to see if the character completes any item.
        s = g.app.gui.getSelectedText(w) + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = g.app.gui.getSelectedText(w)
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = g.app.gui.getSelectedText(w)
        if keysym == 'parenleft':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()</t>
<t tx="ekr.20060329122352.148">def push (self,obj):
    
    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())
        
def pop (self):
    
    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj
    
def clear (self):
    
    self.prevObjects = []
    # g.trace(g.callers())
    
def stackNames (self):
    
    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList</t>
<t tx="ekr.20060329122352.149">def setObjectAndMembersList (self,word):
    
    c = self.c
    
    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.object = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.object)
        self.object = 'aString'
        self.membersList = self.getMembersList(self.object)
    elif self.object:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.object,len(self.membersList))</t>
<t tx="ekr.20060329122352.150">def getObjectFromAttribute (self,word):
    
    obj = self.object

    if obj and self.hasAttr(obj,word):
        self.push(self.object)
        self.object = self.getAttr(obj,word)
        self.appendToKnownObjects(self.object)
        self.membersList = self.getMembersList(self.object)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.object = None</t>
<t tx="ekr.20060329122352.151">def completeSelf (self):
    
    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.object = None
        self.clear()
        self.membersList = []</t>
<t tx="ekr.20060329122352.152">def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.object = None
        self.clear()
        self.membersList = []</t>
<t tx="ekr.20060329122352.153">def setSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = g.app.gui.getInsertPoint(w)
        
    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    g.app.gui.setSelectionRange(w,i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')</t>
<t tx="ekr.20060329122352.154">def start (self,event=None,w=None):
    
    if w: self.widget = w
    else: w = self.widget
    
    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = g.app.gui.getTextSelection(w)
    self.selectedText = g.app.gui.getSelectedText(w)
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = g.app.gui.getInsertPoint(w)
            if w.get(i+'-1c') == '.':
                w.delete(i+'-1c')
                
        self.autoCompleterStateHandler(event)
    else:
        self.abort()</t>
<t tx="ekr.20060329122352.155"># Not used at present, but soon.</t>
<t tx="ekr.20060329122352.156"># Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):
    
    g.trace(g.callers())
    
    self.scan(thread=True)</t>
<t tx="ekr.20060329122352.157">def scan (self,event=None,verbose=True,thread=True):
    
    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return
    
    # g.trace('autocompleter')
    
    if 0: ## thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)
    
        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)</t>
<t tx="ekr.20060329122352.158">def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
    
    if 0: # not used
        self.r  = string.punctuation.replace('(','').replace('.','') # punctuation except ( and .
        self.pt = string.digits + string.letters + self.r
        ripout = string.punctuation + string.whitespace + '\n'
        self.ripout = ripout.replace('_','') # punctuation except underscore.</t>
<t tx="ekr.20060329122352.159">def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''
    
    if verbose: g.es_print('Scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.rootPosition().allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        keys = self.watchwords.keys() ; keys.sort()
        for key in keys:
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        keys = self.calltips.keys() ; keys.sort()
        for key in keys:
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))
        
    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')</t>
<t tx="ekr.20060329122352.160">def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')
    
    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, b = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList
    
    self.calltips [language] = d</t>
<t tx="ekr.20060329122352.161">def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')
    
    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i &lt; n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z</t>
<t tx="ekr.20060329122352.162">def makeAutocompletionList (self,a,b,glist):
    
    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''
    
    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i &gt;= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a
            
        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)
            
        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b </t>
<t tx="ekr.20060329122352.163">def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i &gt;= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s</t>
<t tx="ekr.20060329122352.164">def getCleanString (self,s):
    
    '''Return the prefix of s containing only chars in okchars.'''
    
    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s</t>
<t tx="ekr.20060329122352.165"></t>
<t tx="ekr.20060329122352.166">def createProxyObjectFromClass (self,className,theClass):
    
    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in xrange(n)]
        
    def dummyCtor (self):
        pass
        
    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')
        
    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj</t>
<t tx="ekr.20060329122352.167">def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec s

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in computeProxyObject')
            g.es_exception()
        return None</t>
<t tx="ekr.20060329122352.168">class forgivingParserClass:
    
    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''
    
    @others</t>
<t tx="ekr.20060329122352.169">def __init__ (self,c):
    
    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.</t>
<t tx="ekr.20060329122352.170">def parse (self,p):
    
    '''The top-level parser method.
    
    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''
    
    c = self.c
    
    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody
    
    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody
    
    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody
        return s</t>
<t tx="ekr.20060329122352.171">def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('Syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('Syntax error: deleting %s' % p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''</t>
<t tx="ekr.20060329122352.172">def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n &gt;= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None</t>
<t tx="ekr.20060329122352.173">def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)</t>
<t tx="ekr.20060329122352.174">class classScannerClass:
    
    '''A class to find class definitions in a node or its parents.'''
    
    @others</t>
<t tx="ekr.20060329122352.175">def __init__ (self,c):
    
    self.c = c
    
    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False</t>
<t tx="ekr.20060329122352.176">def scan (self):
    
    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None
        
    return className,obj,p,s</t>
<t tx="ekr.20060329122352.177">def findParentClass (self,root):
    
    autoCompleter = self.c.k.autoCompleter
    
    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p
    
    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p
    
    return None,None,None</t>
<t tx="ekr.20060329122352.178">def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None</t>
<t tx="ekr.20060329122352.179">def endsDoc (self,s):
    
    return s.startswith('@c')</t>
<t tx="ekr.20060329122352.180">def startsClass (self,s):
    
    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None</t>
<t tx="ekr.20060329122352.181">def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False</t>
<t tx="ekr.20060329122352.182">def aproposAutocompletion (self,event=None):
    
    c = self.c ; s = '''
This documentation describes both autocompletion and calltips.

Typing a period when @language python is in effect starts autocompletion. Typing
'(' during autocompletion shows the calltip. Typing Return or Control-g
(keyboard-quit) exits autocompletion or calltips.

Autocompletion
    
Autocompletion shows what may follow a period in code. For example, after typing
g. Leo will show a list of all the global functions in leoGlobals.py.
Autocompletion works much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in the body
pane.

A leading period brings up 'Autocomplete Modules'. (The period goes away.) You
can also get any module by typing its name. If more than 25 items would appear
in the Autocompleter tab, Leo shows only the valid starting characters. At this
point, typing an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated modes.

If x is a list 'x.!' shows all its elements, and if x is a Python dictionary,
'x.!' shows x.keys(). For example, 'sys.modules.!' Again, further exclamation
marks toggles between full and abbreviated modes.

During autocompletion, typing a question mark shows the docstring for the
object. For example: 'g.app?' shows the docstring for g.app. This doesn't work
(yet) directly for Python globals, but '__builtin__.f?' does. Example:
'__builtin__.pow?' shows the docstring for pow.

Autocompletion works in the Find tab; you can use &lt;Tab&gt; to cycle through the
choices. The 'Completion' tab appears while you are doing this; the Find tab
reappears once the completion is finished.

Calltips

Calltips appear after you type an open parenthesis in code. Calltips shows the
expected arguments to a function or method. Calltips work for any Python
function or method, including Python's global function. Examples:

a)  'g.toUnicode('  gives 'g.toUnicode(s, encoding, reportErrors=False'
b) 'c.widgetWantsFocusNow' gives 'c.widgetWantsFocusNow(w'
c) 'reduce(' gives 'reduce(function, sequence[, initial]) -&gt; value'

The calltips appear directly in the text and the argument list is highlighted so
you can just type to replace it. The calltips appear also in the status line for
reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the
enable_autocompleter and enable_calltips settings in leoSettings.leo. You may
enable or disable these features at any time with these commands:
enable-auto-completer-command, enable-calltips-command,
disable-auto-completer-command and disable-calltips-command.
'''

    if not g.app.unitTesting:
        # Remove indentation from indentation of this function.
        s = g.adjustTripleString(s,c.tab_width)
        g.es_print(s)</t>
<t tx="ekr.20060329122352.183">def test_aproposAutocompletion (self):

    c.helpCommands.aproposAutocompletion()</t>
<t tx="ekr.20060329122352.184"></t>
<t tx="ekr.20060329122352.185">Index: plugins/rst3.py
===================================================================
RCS file: /cvsroot//leo/leo/plugins/rst3.py,v
retrieving revision 1.42
diff -r1.42 rst3.py
1158c1158
&lt;         source = self.outputFile.getvalue()
---
&gt;         self.source = self.outputFile.getvalue()
1167c1167
&lt;             f.write(source)
---
&gt;             f.write(self.source)
1172c1172
&lt;             output = self.writeToDocutils(source)
---
&gt;             output = self.writeToDocutils(self.source)</t>
</tnodes>
</leo_file>
