#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20070703172548:Leo 4.4.4 projects
#@+node:ekr.20070703182412:Bugs
#@+node:ekr.20070725155607:removed leoKeywords from colorizer
# This was a fairly big bit of cruft.
#@nonl
#@-node:ekr.20070725155607:removed leoKeywords from colorizer
#@+node:ekr.20070724072345:Fixed UNL bug1
@nocolor

Email from Terry Brown

A softish bug, but the use of findNodeInTree() in the UNL code can 
take you to the wrong place if more than one node in the tree has 
the same headString.  Patch below - can still go wrong if more than 
one sibling has the same name, but the UNL system doesn't have a 
solution for that.

An observation - the UNL jumping code will drop you as far down the 
path as it gets, i.e. you're moved to the last node that was one the 
path, even if the path ends before the last part of the UNL is 
reached.  This is ok, i.e. "this is as far as I could follow the 
UNL", the alternative would be to not move at all if the whole UNL 
can't be followed.

Cheers -Terry

anon_cvs> cvs diff leo/plugins/UNL.py
Index: leo/plugins/UNL.py
===================================================================
RCS file: /cvs/leo/plugins/UNL.py,v
retrieving revision 1.14
diff -r1.14 UNL.py
183c183,186
<                             p = g.findNodeInTree(c2,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break
206c209,212
<                             p = g.findNodeInTree(c,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break


@color
#@nonl
#@+node:ekr.20040321065415:g.findNode... &,findTopLevelNode
def findNodeInChildren(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.children_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):

    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findTopLevelNode(c,headline):

    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20040321065415:g.findNode... &,findTopLevelNode
#@-node:ekr.20070724072345:Fixed UNL bug1
#@-node:ekr.20070703182412:Bugs
#@+node:ekr.20070703182412.1:Features
#@+node:ekr.20070703172130:Added support for @mark-for-unit-tests node
# The run-unit-tests command now includes **all** @mark-for-unit-test trees.
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@nonl
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
    c2.beginUpdate()
    try:
        self.copyRoot.expand()
        for p,limit,lookForMark,lookForNodes in (
            (p1,limit1,lookForMark1,lookForNodes1),
            (p2,limit2,lookForMark2,lookForNodes2),
        ):
            while p and p != limit:
                h = p.headString()
                if p.v.t in self.seen:
                    p.moveToNodeAfterTree()
                elif lookForMark and h.startswith(markTag):
                    self.addMarkTree(p)
                    p.moveToNodeAfterTree()
                elif lookForNodes and self.isUnitTestNode(p):
                    self.addNode(p)
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@nonl
#@+node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.currentPosition()
    if p.headString().startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@nonl
#@-node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
#@+node:ekr.20070705080413:addMarkTree
def addMarkTree (self,p):

    # g.trace(len(self.seen),p.headString())

    self.seen.append(p.v.t)

    for p in p.subtree_iter():
        if self.isUnitTestNode(p) and not p.v.t in self.seen:
            self.addNode(p)
#@-node:ekr.20070705080413:addMarkTree
#@+node:ekr.20070705065154.1:addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-test tree as the last child of self.copyRoot.
    '''

    # g.trace(len(self.seen),p.headString())

    p2 = p.copyTreeAfter()
    p2.unlink()
    p2.moveToLastChildOf(self.copyRoot)

    self.seen.append(p.v.t)
#@-node:ekr.20070705065154.1:addNode
#@+node:ekr.20070705075604.3:isUnitTestNode
def isUnitTestNode (self,p):

    h = p.headString()
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@-node:ekr.20070705075604.3:isUnitTestNode
#@-node:ekr.20070627135336.9:createOutline & helpers
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    args = [sys.executable, path, '--silent']

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = c.currentPosition()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.allNodes_iter():
        if p.headString().startswith('@mark-for-unit-test'):
            return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20070703172130:Added support for @mark-for-unit-tests node
#@+node:ekr.20070725165751:Created threading_colorizer
@nocolor

> Can anyone point me to a discussion of what is, and is not, guanteed about how
Python schedules threads? In particular, I want the colorizing thread to
relinquish control to the gui thread quite often (for good response), but I
don't want the relinquishing itself to slow down the colorizer much. It seems a
hard problem.

From what I understand, there are perhaps only a few "guarantees" with Python
threads. One guarantee is that when Python source is executing, threads will
swap after sys.getcheckinterval() bytecodes have been processed for that thread.
You can set the delay with sys.setcheckinterval(count). It seems to be 100
bytecodes in Python 2.3-2.5, but I could have sworn it was 1000. In any case,
setting the check interval higher will result in higher speed, but lower
responsiveness.

When making certain C-level calls, Python will also allow the "active" Python
thread to switch. Which really means that the only way you can use those all of
those 4-core processors with Python in a single process is to do all of your
work in C code with carefully crafted GIL acquire and release calls.

If your code is crafted in such a way that there are "convenient" places to
yield control, you can use a technique known as 'cooperative multithreading with
generators'. It gives you the total speed, more or less, of a single thread, but
*you* choose where the context switches occur, for the cost of a bit of extra
complication.
#@nonl
#@-node:ekr.20070725165751:Created threading_colorizer
#@+node:ekr.20070729093951:Added support for @auto
#@+node:ekr.20070611173545.1:Design
@nocolor

I have just started the process of 'priming the pump' for work on @auto.

Here are the key factors that drive the design:

0. [Terminology] Alice uses Leo and doesn't mind having sentinels in derived files. Bob doesn't use Leo, and *does not want sentinels* (at least until Bob gets turned on to Leo), and Mike is Alice's and Bob's manager.  Mike probably doesn't care about sentinels, but would side with Bob if Bob objected to using sentinels.

1. [No sentinels] There was a *lot* of discussion about this.  The initial implementation of @auto will use *absolutely no* sentinels. This might be relaxed later, but the *essential* idea is that @auto is a feature primarily for newbies who DO NOT WANT sentinels in their files.  As Kent has clearly pointed out, within @auto trees, Alice can live without clones, section references and @others, etc.

2. [Perfect import] I designed an algorithm that guarantees that files imported with @auto can be rewritten from the @auto tree with *no* changes to the original file.  This is the 'round-tripping' requirement.

See: Huge aha: design of the parser (perfect import)
http://sourceforge.net/forum/message.php?msg_id=4224283

3. [Resolve cvs conflicts] Leo can let the user resolve cvs conflicts.

See: Huge aha: resolving conflicts
http://sourceforge.net/forum/message.php?msg_id=4224589

The following are references to extended discussions in Leo's forums:

1. From the Open Forum, March, 2007:

auto: a new vision
http://sourceforge.net/forum/forum.php?thread_id=1700873&forum_id=10226

Huge aha: parsing replaces sentinels
http://sourceforge.net/forum/forum.php?thread_id=1699679&forum_id=10226

@auto nodes
http://sourceforge.net/forum/forum.php?thread_id=1699599&forum_id=10226

2. The original motivation was in the 'Discurssion of wxPython issues' thread in
the Developers Forum in March 2007:
http://sourceforge.net/forum/forum.php?thread_id=1695549&forum_id=10228

And especially:
http://sourceforge.net/forum/message.php?msg_id=4217121
#@nonl
#@+node:ekr.20070703172130.1:Aha: perfect import *can* correct whitespace
@nocolor

Aha: the perfect import code *can* correct whitespace (tab, underindented lines)
problems that exists in the original files. When such errors are found, Leo will
issue the message:

    'whitepace error: remove the @ignore statement to correct these problems.'

This is the best possible solution:

- It alerts the user that there are problems with the original file.
- It does *not* change them unless the user takes specific action.
- It *does* correct the problems if desired.
#@-node:ekr.20070703172130.1:Aha: perfect import *can* correct whitespace
#@+node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@-node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@+node:ekr.20040721094203:Probably not: Make sure Leo uses "verbatim" whitespace
http://sourceforge.net/forum/message.php?msg_id=3578166

I think these issues are not really relevant.
#@nonl
#@+node:ekr.20060808103849:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinery if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20060808103849:Report
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):

    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@-node:ekr.20041005105605.210:putIndent
#@-node:ekr.20040721094203:Probably not: Make sure Leo uses "verbatim" whitespace
#@-node:ekr.20070611173545.1:Design
#@-node:ekr.20070729093951:Added support for @auto
#@-node:ekr.20070703182412.1:Features
#@-node:ekr.20070703172548:Leo 4.4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
