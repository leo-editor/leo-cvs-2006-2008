#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20070703172548:Leo 4.4.4 projects
#@+node:ekr.20070703182412:Bugs
#@+node:ekr.20070725155607:removed leoKeywords from colorizer
# This was a fairly big bit of cruft.
#@nonl
#@-node:ekr.20070725155607:removed leoKeywords from colorizer
#@+node:ekr.20070724072345:Fixed UNL bug1
@nocolor

Email from Terry Brown

A softish bug, but the use of findNodeInTree() in the UNL code can 
take you to the wrong place if more than one node in the tree has 
the same headString.  Patch below - can still go wrong if more than 
one sibling has the same name, but the UNL system doesn't have a 
solution for that.

An observation - the UNL jumping code will drop you as far down the 
path as it gets, i.e. you're moved to the last node that was one the 
path, even if the path ends before the last part of the UNL is 
reached.  This is ok, i.e. "this is as far as I could follow the 
UNL", the alternative would be to not move at all if the whole UNL 
can't be followed.

Cheers -Terry

anon_cvs> cvs diff leo/plugins/UNL.py
Index: leo/plugins/UNL.py
===================================================================
RCS file: /cvs/leo/plugins/UNL.py,v
retrieving revision 1.14
diff -r1.14 UNL.py
183c183,186
<                             p = g.findNodeInTree(c2,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break
206c209,212
<                             p = g.findNodeInTree(c,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break


@color
#@nonl
#@+node:ekr.20040321065415:g.findNode... &,findTopLevelNode
def findNodeInChildren(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.children_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):

    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findTopLevelNode(c,headline):

    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20040321065415:g.findNode... &,findTopLevelNode
#@-node:ekr.20070724072345:Fixed UNL bug1
#@+node:ekr.20070803081457:Fixed how @auto handles paths
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4444579
By: terry_n_brown

Sure it's what I'd expect, but I don't think it's what it does?

in the directory 'misc_py', where del.leo and addWhitelist.py live:

  python /path/to/leo/src/leo.py del.leo

works, and indeed addWhitelist.py is now correctly imported
in the node '@auto addWhitelist.py' (very cool :-)

but if I cd .. and

  python /path/to/leo/src/leo.py misc_py/del.leo

I get

reading: /media/hda7/misc_py/del.leo
can not open addWhitelist.py

and an empty node '@auto addWhitelist.py'

Makes me think it's trying to load addWhitelist.py relative to the dir from
which leo was run, not the dir of the .leo file.

@color
#@nonl
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@-node:ekr.20070803081457:Fixed how @auto handles paths
#@+node:ekr.20070803112638:Fixed another path bug
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4445685
By: ktenney

/dir/sub/main
contains interfaces.py and configure.zcml

the @path directive works for interfaces.py

z3
@path /dir/sub/main
..@auto interfaces.py

but I find I need a node named
@auto /dir/sub/main/configure.zcml
to get that file

@color
#@nonl
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20070713075352:Default scanner
def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    if atAuto:
        for p in p.self_and_subtree_iter():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
#@-node:ekr.20070713075352:Default scanner
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@-node:ekr.20070803112638:Fixed another path bug
#@+node:ekr.20070804070844:fixed c parser so it handles non-ascii declaratsions
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4446937
By: btheado

> Two hacks (now on cvs) were surprisingly effective..

Thanks for the fixes.  I just tried some more code (Tcl C source again--I just
happen to have it handy on my hard drive).  It looks like the import parser
skips over ANSI style function definitions (didn't know anyone still used those).
Here are some examples files:

http://tcl.cvs.sourceforge.net/tcl/tcl/generic/tclScan.c?revision=1.12.2.2&view=
markup&pathrev=core-8-4-14

and

http://tcl.cvs.sourceforge.net/tcl/tcl/generic/tclObj.c?revision=1.42.2.14&view=
markup&pathrev=core-8-4-14

I checked the old importer and it handles the ANSI style just fine.

Brian
#@nonl
#@-node:ekr.20070804070844:fixed c parser so it handles non-ascii declaratsions
#@+node:ekr.20070808090641:Fixed colorizing bug and moved calls to w.toGuiIndex out of some loops
# The code that was removing tags was not working properly.
#@nonl
#@-node:ekr.20070808090641:Fixed colorizing bug and moved calls to w.toGuiIndex out of some loops
#@+node:ekr.20070803081137.1:Fixed unicode bug in http plugin
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4437415

Unicode characters were not handled properly.
#@-node:ekr.20070803081137.1:Fixed unicode bug in http plugin
#@+node:ekr.20070814083649:Fixed new @path problem
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4462693

@color
#@nonl
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if c:
        if not c.config.create_nonexistent_directories:
            return None
    elif not app.config.create_nonexistent_directories:
        return None

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es("created directory: "+path)
            except:
                g.es("exception creating directory: "+path)
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):

    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0 and not at.thinFile:
        << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            c.setBodyString(p,s) # Sets c and p dirty.

        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():

    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):

    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@-node:ekr.20070814083649:Fixed new @path problem
#@+node:ekr.20070814143748.1:Fixed @auto path bug
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4464980
By: terry_n_brown

When I delete the @ignore in my evil example above, when I try and write the
@auto I get the traceback below.  Perhaps just a msg. saying "Unwritable @auto
node, try re-importing, or save and load" or something?

exception writing derived files
Traceback (most recent call last):
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoF
ileCommands.py", line 3060, in write_Leo_file
    c.atFileCommands.writeAll()
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoA
tFile.py", line 2919, in writeAll
    at.writeOneAtAutoNode(p,toString=toString)
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoA
tFile.py", line 3005, in writeOneAtAutoNode
    fileName = g.os_path_join(at.default_directory,fileName)
AttributeError: atFile instance has no attribute 'default_directory'

@color
#@nonl
#@+node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20070806140208:writeAtAutoNodesHelper
def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
#@-node:ekr.20070806140208:writeAtAutoNodesHelper
#@+node:ekr.20070806141607:writeOneAtAutoNode & helper
def writeOneAtAutoNode(self,p,toString):

    '''Write p, and @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)

    if not c.atAutoDict.get(fileName) and g.os_path_exists(fileName):
        # Read the file if it would not wipe out significant info.
        # Otherwise, do nothing (the @auto tree will be written to the outline).
        if at.isSignificantAtAutoTree(p):
            g.es('not written: @auto %s\nmay conflict with existing derived file.' % (
                fileName),color='red')
            return False
        else:
            g.es_print('reading new @auto %s' % (fileName),color='blue')
            at.readOneAtAutoNode(fileName,p)
            return True

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()

    return ok
#@+node:ekr.20070909103844:isSignificantAtAutoTree
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    at = self ; s = p.bodyString()

    return (
        p.hasChildren() or
        len(s) > 100 or
        len(g.splitLines(s)) > 10
    )
#@-node:ekr.20070909103844:isSignificantAtAutoTree
#@-node:ekr.20070806141607:writeOneAtAutoNode & helper
#@-node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
#@-node:ekr.20070814143748.1:Fixed @auto path bug
#@+node:ekr.20070815100946:Improved messages on @import failure
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4465132
By: terry_n_brown

So I changed all my indentation to multiples of four, having decided I like
the extra line space this buys over aligning with the opening (.

leo said this when it read the file:

@auto did not import the file perfectly

but never mentioned @ignore or anything.  I made a trivial change and saved
and diff could find no difference except my trivial change... which seems perfect
to me...?

@color
#@nonl
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    c = self.c ; at = c.atFileCommands

    if s1 and s2:
        if s1 == s2: return True

    at.write(self.root,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=True,
        write_strips_blank_lines=False,
    )

    s1,s2 = self.file_s, at.stringOutput
    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')

    s1 = 'line1\nline2\n'
    s2 = 'line1\nline2a\n'
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@-node:ekr.20070815100946:Improved messages on @import failure
#@+node:ekr.20070824094935:Fixed problem with space in path names in runLeoDynamicTest
# https://sourceforge.net/forum/message.php?msg_id=4459798
#@nonl
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    if ' ' in path and sys.platform.startswith('win'): 
        path = '"' + path + '"' 

    args = [sys.executable, path, '--silent']  

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@-node:ekr.20070824094935:Fixed problem with space in path names in runLeoDynamicTest
#@+node:ekr.20070910102447:Fixed bad drag & drop bug
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4509897
By: plumloco

If you drag a parent node onto one of its children then leo crashes.

@color
#@nonl
#@+node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        << set vdrag, childFlag >>
        if self.allow_clone_drags:
            if not self.look_for_control_drag_on_mouse_down:
                self.controlDrag = c.frame.controlKeyIsDown

        redrawFlag = vdrag and vdrag.v.t != p.v.t
        if redrawFlag: # Disallow drag to joined node.
            << drag p to vdrag >>
        elif self.trace and self.verbose:
            g.trace("Cancel drag")

        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate(redrawFlag)
        c.recolor_now() # Dragging can affect coloring.
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):

    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.2353:c.dragAfter
def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,after): return
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2353:c.dragAfter
#@+node:ekr.20031218072017.2947:c.dragToNthChildOf
def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,parent): return
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2947:c.dragToNthChildOf
#@+node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()

    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone & dependents, does not set undo.
        if (
            not c.checkDrag(p,parent) or
            not c.checkMoveWithParentWithWarning(clone,parent,True)
        ):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
#@+node:ekr.20031218072017.2948:c.dragCloneAfter
def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkDrag(p,after) and c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2948:c.dragCloneAfter
#@-node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning & c.checkDrag
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Can not drag a node into its descendant tree."

    g.trace('root',root.headString())

    for z in root.subtree_iter():
        if z == parent:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
#@+node:ekr.20070910105044:checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
#@-node:ekr.20070910105044:checkMoveWithParentWithWarning
#@+node:ekr.20070910105044.1:checkDrag
def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    message = "Can not drag a node into its descendant tree."

    # g.trace('root',root.headString(),'target',target.headString())

    for z in root.subtree_iter():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                g.alert(message)
            return False
    return True
#@nonl
#@-node:ekr.20070910105044.1:checkDrag
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning & c.checkDrag
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        moved = False
        << Move p up >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)

    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        # g.trace('move to root')
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@-node:ekr.20070910102447:Fixed bad drag & drop bug
#@+node:ekr.20070912052929:Fixed bug 'node note selected' bug
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4514130
By: plumloco

Some commands (such as expand-all) leave no nodes selected. The result of this
is that if you click on the body pane without first having selected a node,
an error dialog pops up.


AttributeError Exception in Tk callback
  Function: <function bodyClickCallback at 0x01981A70> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x02505580>,)
  Event type: ButtonPress (type num: 4)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 80, in bodyClickCallback
    return handler(event,func)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 3187, in masterClickHandler
    c.frame.body.onClick(event) # New in Leo 4.4.2.
  File "C:\prog\tigris-cvs\leo\src\leoFrame.py", line 1297, in onClick
    c.editCommands.setMoveCol(w,i)
  File "C:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 3539, in setMoveCol
    self.moveSpotNode = p.v.t
AttributeError: 'NoneType' object has no attribute 't'

================================================
  Event contents:
    char: ??
    delta: 0
    height: ??
    keycode: ??
    keysym: ??
    keysym_num: ??
    num: 1
    send_event: False
    serial: 1525
    state: 0
    time: 4692125
    type: 4
    widget: .26496576.26526264.26526584.26526664.26719976.26720296.body-pane
    width: ??
    x: 438
    x_root: 744
    y: 87
    y_root: 651



@color
#@nonl
#@+node:ekr.20031218072017.2903:expandAllHeadlines
def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self

    c.beginUpdate()
    try:
        p = c.rootPosition()
        while p:
            c.expandSubtree(p)
            p.moveToNext()
        c.selectVnode(c.rootPosition())
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
#@-node:ekr.20031218072017.2903:expandAllHeadlines
#@+node:ekr.20060209095101:setMoveCol & test
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@+node:ekr.20070627082044.276:@test setMoveCol
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        ec = c.editCommands

        for spot,result in (('1.0',0),(5,5)):
            ec.setMoveCol(w,spot)
            assert ec.moveSpot == result
            assert ec.moveCol == result
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.276:@test setMoveCol
#@-node:ekr.20060209095101:setMoveCol & test
#@+node:ekr.20061109095450.8:onClick
def onClick (self,event):

    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)

    if not c.currentPosition(): return

    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
#@+node:ekr.20070627082044.857:@test onClick
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        y = 10
        for x in xrange(0,100,10):
            event = g.Bunch(c=c,x=x,y=y,widget=w)
            c.frame.body.onClick(event)
    finally:
        c.endUpdate(False)
#@nonl
#@-node:ekr.20070627082044.857:@test onClick
#@-node:ekr.20061109095450.8:onClick
#@-node:ekr.20070912052929:Fixed bug 'node note selected' bug
#@-node:ekr.20070703182412:Bugs
#@+node:ekr.20070703182412.1:Features
#@+node:ekr.20070703172130:Added support for @mark-for-unit-tests node
# The run-unit-tests command now includes **all** @mark-for-unit-test trees.
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@nonl
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
    c2.beginUpdate()
    try:
        self.copyRoot.expand()
        for p,limit,lookForMark,lookForNodes in (
            (p1,limit1,lookForMark1,lookForNodes1),
            (p2,limit2,lookForMark2,lookForNodes2),
        ):
            while p and p != limit:
                h = p.headString()
                if p.v.t in self.seen:
                    p.moveToNodeAfterTree()
                elif lookForMark and h.startswith(markTag):
                    self.addMarkTree(p)
                    p.moveToNodeAfterTree()
                elif lookForNodes and self.isUnitTestNode(p):
                    self.addNode(p)
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@nonl
#@+node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.currentPosition()
    if p.headString().startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@nonl
#@-node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
#@+node:ekr.20070705080413:addMarkTree
def addMarkTree (self,p):

    # g.trace(len(self.seen),p.headString())

    self.seen.append(p.v.t)

    for p in p.subtree_iter():
        if self.isUnitTestNode(p) and not p.v.t in self.seen:
            self.addNode(p)
#@-node:ekr.20070705080413:addMarkTree
#@+node:ekr.20070705065154.1:addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-test tree as the last child of self.copyRoot.
    '''

    # g.trace(len(self.seen),p.headString())

    p2 = p.copyTreeAfter()
    p2.unlink()
    p2.moveToLastChildOf(self.copyRoot)

    self.seen.append(p.v.t)
#@-node:ekr.20070705065154.1:addNode
#@+node:ekr.20070705075604.3:isUnitTestNode
def isUnitTestNode (self,p):

    h = p.headString()
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@-node:ekr.20070705075604.3:isUnitTestNode
#@-node:ekr.20070627135336.9:createOutline & helpers
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    if ' ' in path and sys.platform.startswith('win'): 
        path = '"' + path + '"' 

    args = [sys.executable, path, '--silent']  

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = c.currentPosition()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.allNodes_iter():
        if p.headString().startswith('@mark-for-unit-test'):
            return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20070703172130:Added support for @mark-for-unit-tests node
#@+node:ekr.20070725165751:Created threading_colorizer
@nocolor

> Can anyone point me to a discussion of what is, and is not, guanteed about how
Python schedules threads? In particular, I want the colorizing thread to
relinquish control to the gui thread quite often (for good response), but I
don't want the relinquishing itself to slow down the colorizer much. It seems a
hard problem.

From what I understand, there are perhaps only a few "guarantees" with Python
threads. One guarantee is that when Python source is executing, threads will
swap after sys.getcheckinterval() bytecodes have been processed for that thread.
You can set the delay with sys.setcheckinterval(count). It seems to be 100
bytecodes in Python 2.3-2.5, but I could have sworn it was 1000. In any case,
setting the check interval higher will result in higher speed, but lower
responsiveness.

When making certain C-level calls, Python will also allow the "active" Python
thread to switch. Which really means that the only way you can use those all of
those 4-core processors with Python in a single process is to do all of your
work in C code with carefully crafted GIL acquire and release calls.

If your code is crafted in such a way that there are "convenient" places to
yield control, you can use a technique known as 'cooperative multithreading with
generators'. It gives you the total speed, more or less, of a single thread, but
*you* choose where the context switches occur, for the cost of a bit of extra
complication.
#@nonl
#@-node:ekr.20070725165751:Created threading_colorizer
#@+node:ekr.20070731070208:Added @auto

#@+node:ekr.20070806105721:read/write-at-auto-nodes commands
#@+node:ekr.20070806144024.1:Reading...
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = parent
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in parent.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        parent.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    Issue errors for strict languages; warnings for non-strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    # For strict languages, check that leading whitespace is a multiple of the tab_width.
    if self.strict:
        for line in lines:
            if line.strip(): # only check non-blank lines.
                lws = line[0:g.skip_ws(line,0)]
                w = g.computeWidth(lws,tab_width)
                if (w % abs(tab_width)) != 0:
                ### if 0 < w < abs(tab_width):
                    self.error(
                        'leading whitespace not consistent with @tabwidth %d\nline: %s' % (
                            tab_width,repr(line)))
                    break

    if self.strict and changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    c.beginUpdate()
    try:
        undoData = u.beforeChangeTree(p)
        c.importCommands.readAtAutoNodes()
        u.afterChangeTree(p,'Read @auto Nodes',undoData)
    finally:
        c.endUpdate()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.currentPosition() ; after = p.nodeAfterTree()

    c.beginUpdate()
    try:
        found = False
        while p and p != after:
            if p.isAtAutoNode():
                if p.isAtIgnoreNode():
                    g.es_print('ignoring %s' % (p.headString()),color='blue')
                    p.moveToThreadNext()
                else:
                    self.readOneAtAutoNode(p)
                    found = True
                    p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        g.es(g.choose(found,'finished','no @auto nodes in the selected tree'),color='blue')
    finally:
        c.endUpdate()

#@+node:ekr.20070807084545:readOneAtAutoNode
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@-node:ekr.20070806144024.1:Reading...
#@+node:ekr.20070806144024.2:Writing...
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self ; c = at.c
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName)

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
#@+node:ekr.20041005105605.143:openFileForWritingHelper
def openFileForWritingHelper (self,fileName):

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
#@-node:ekr.20041005105605.143:openFileForWritingHelper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString)
        writtenFiles.append(p.v.t)
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False,write_strips_blank_lines=None):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString,
        write_strips_blank_lines=write_strips_blank_lines)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@+node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20070806140208:writeAtAutoNodesHelper
def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
#@-node:ekr.20070806140208:writeAtAutoNodesHelper
#@+node:ekr.20070806141607:writeOneAtAutoNode & helper
def writeOneAtAutoNode(self,p,toString):

    '''Write p, and @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)

    if not c.atAutoDict.get(fileName) and g.os_path_exists(fileName):
        # Read the file if it would not wipe out significant info.
        # Otherwise, do nothing (the @auto tree will be written to the outline).
        if at.isSignificantAtAutoTree(p):
            g.es('not written: @auto %s\nmay conflict with existing derived file.' % (
                fileName),color='red')
            return False
        else:
            g.es_print('reading new @auto %s' % (fileName),color='blue')
            at.readOneAtAutoNode(fileName,p)
            return True

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()

    return ok
#@+node:ekr.20070909103844:isSignificantAtAutoTree
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    at = self ; s = p.bodyString()

    return (
        p.hasChildren() or
        len(s) > 100 or
        len(g.splitLines(s)) > 10
    )
#@-node:ekr.20070909103844:isSignificantAtAutoTree
#@-node:ekr.20070806141607:writeOneAtAutoNode & helper
#@-node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
#@-node:ekr.20070806144024.2:Writing...
#@-node:ekr.20070806105721:read/write-at-auto-nodes commands
#@+node:ekr.20070713082220:scannerUnitTest
def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.headString()
    oldChanged = c.changed
    c.beginUpdate()
    try:
        d = g.app.unitTestDict
        expectedErrors = d.get('expectedErrors')
        expectedErrorMessage = d.get('expectedErrorMessage')
        expectedMismatchLine = d.get('expectedMismatchLine')
        g.app.unitTestDict = {
            'expectedErrors':expectedErrors,
            'expectedErrorMessage':expectedErrorMessage,
            'expectedMismatchLine':expectedMismatchLine,
        }
        if not fileName: fileName = p.headString()
        if not s: s = self.removeSentinelsCommand([fileName],toString=True)
        title = g.choose(h.startswith('@test'),h[5:],h)
        self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
        d = g.app.unitTestDict
        ok = ((d.get('result') and expectedErrors in (None,0)) or
            (
                # checkTrialWrite returns *True* if the following match.
                # d.get('result') == False and
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
                (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
            ))
        if not ok:
            g.trace('result',d.get('result'),
                'actualErrors',d.get('actualErrors'),
                'expectedErrors',d.get('expectedErrors'),
                'actualMismatchLine',d.get('actualMismatchLine'),
                'expectedMismatchLine', d.get('expectedMismatchLine'),
                '\nactualErrorMessage  ',d.get('actualErrorMessage'),
                '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
            )
        if not showTree and ok:
            while p.hasChildren():
                p.firstChild().doDelete()
            c.setChanged(oldChanged)
    finally:
        c.endUpdate()

    if g.app.unitTesting:
        assert ok

    return ok
#@-node:ekr.20070713082220:scannerUnitTest
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigID = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks:
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    c = self.c ; at = c.atFileCommands

    if s1 and s2:
        if s1 == s2: return True

    at.write(self.root,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=True,
        write_strips_blank_lines=False,
    )

    s1,s2 = self.file_s, at.stringOutput
    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')

    s1 = 'line1\nline2\n'
    s2 = 'line1\nline2a\n'
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys):
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # All blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if i+1 != expectedMismatch or not g.app.unitTesting:
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line: ', repr(line1))
            g.es_print('generated line:', repr(line2))
        d ['actualMismatchLine'] = i+1
        g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]
    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys):
        g.es_print(color='blue',newline=False,*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')
    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 30:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@-node:ekr.20070911110507:reportMismatch
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and children of c for each def in the class.'''

    prefix = self.createClassNodePrefix()
    if not self.sigID:
        g.trace('Can not happen: no sigID')
        sigID = 'Unknown class name'
    class_name = self.sigID
    headline = 'class ' + class_name
    body = s[start:sigEnd]
    body = self.undentBody(body)
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        extend = self.undentBody(extend)
        extend = self.indentBody(extend)
        body = body + extend

    class_node = self.createHeadline(parent,prefix + body,headline)
    savedMethodName = self.methodName
    self.methodName = headline
    self.putClassHelper(s,i,codeEnd,class_name,class_node)
    self.methodName = savedMethodName
#@+node:ekr.20070703122141.106:appendRefToClassNode
def appendRefToClassNode (self,class_name,class_node):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Put any leading decls in the class node.
    trace = False
    start = i
    i = self.skipDecls(s,i,end)
    decls = s[start:i]
    if decls:
        # We must regularize the indentation to match the @others
        decls = self.undentBody(decls)
        decls = self.indentBody(decls)
        if self.trace: g.trace('decls\n%s' % decls)
        # g.trace(class_name,'decls',repr(decls))
        self.appendTextToClassNode(class_node,decls)
    start = i ; putRef = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,self.outerBlockDelim1):
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,class_node)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            self.putFunction(s,self.sigStart,self.codeEnd,start,class_node)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    if putRef:
        self.appendRefToClassNode(class_name,class_node)

    if start < end:
        trailing = s[start:end]
        if trace or self.trace: g.trace('trailing\n%s' % trailing)
        self.appendTextToClassNode(class_node,trailing)
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    if self.sigID:
        headline = self.sigID
    else:
        g.trace('Can not happen: no sigID')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if self.trace:
        g.trace('body\n%s' % repr(body))
        g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigID,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    #g.trace('before',repr(s))

    # Copy an @code line as is.
    i = 0
    if g.match(s,i,'@code'):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]

    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i,ignoreComments=ignoreComments)
    if undent == 0:
        return s
    else:
        result = ''.join([
            g.removeLeadingWhitespace(line,undent,self.tab_width)
                for line in g.splitLines(s)])
        #g.trace('after',repr(result))
        return result
#@-node:ekr.20070703122141.88:undentBody
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 1: # For debugging unit tests.
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20070706101600:scan
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''
    self.putRootText(parent)
    i = start = self.skipDecls(s,0,len(s))
    decls = s[:i]
    if decls: self.createDeclsNode(parent,decls)
    while i < len(s):
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,self.outerBlockDelim1):
            # k = i
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # g.trace('\n',s[k:i])
        elif self.startsClass(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@-node:ekr.20070706101600:scan
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline:
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end):

    '''Skip everything until the start of the next class or function.'''

    trace = False
    start = i ; prefix = None
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            if prefix is None: prefix = i
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif g.match(s,i,self.outerBlockDelim1):
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    # Ignore empty decls.
    if prefix is not None: i = prefix
    if s[start:i].strip():
        if trace or self.trace: g.trace('\n'+s[start:i])
        return i
    else:
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    if s[j:i].strip():
        self.error(
            '%s %s does not start a line. Leo must insert a newline\n%s' % (
                tag,self.sigID,g.get_line(s,j)))
        return i
    else:
        return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigID,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''

    trace = False
    self.codeEnd = self.sigEnd = self.sigID = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigID = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False
    if tags:
        if theId not in tags:
            return False
        if trace: g.trace('tags',tags,'theId',theId)
        if quick: return True

    if trace: g.trace('kind',kind,'id',theId,g.callers())

    # Get the class/function id.
    i, ids = self.skipSigStart(s,j,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace: g.trace('no sigId',g.get_line(s,i))
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigID = sigId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if s[self.sigStart:k].strip():
        self.error('%s definition does not start a line\n%s' % (
            kind,g.get_line(s,k)))

    if trace or self.trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False
    ids = []
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, []
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId: ids.append(theId)
            else: break

    return i, ids
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = parent
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in parent.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        parent.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    Issue errors for strict languages; warnings for non-strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    # For strict languages, check that leading whitespace is a multiple of the tab_width.
    if self.strict:
        for line in lines:
            if line.strip(): # only check non-blank lines.
                lws = line[0:g.skip_ws(line,0)]
                w = g.computeWidth(lws,tab_width)
                if (w % abs(tab_width)) != 0:
                ### if 0 < w < abs(tab_width):
                    self.error(
                        'leading whitespace not consistent with @tabwidth %d\nline: %s' % (
                            tab_width,repr(line)))
                    break

    if self.strict and changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:ekr.20070808115837.2:Regularize whitespace
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self,event=None):

    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = parent
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in parent.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        parent.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    Issue errors for strict languages; warnings for non-strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    # For strict languages, check that leading whitespace is a multiple of the tab_width.
    if self.strict:
        for line in lines:
            if line.strip(): # only check non-blank lines.
                lws = line[0:g.skip_ws(line,0)]
                w = g.computeWidth(lws,tab_width)
                if (w % abs(tab_width)) != 0:
                ### if 0 < w < abs(tab_width):
                    self.error(
                        'leading whitespace not consistent with @tabwidth %d\nline: %s' % (
                            tab_width,repr(line)))
                    break

    if self.strict and changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks:
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    Issue errors for strict languages; warnings for non-strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    # For strict languages, check that leading whitespace is a multiple of the tab_width.
    if self.strict:
        for line in lines:
            if line.strip(): # only check non-blank lines.
                lws = line[0:g.skip_ws(line,0)]
                w = g.computeWidth(lws,tab_width)
                if (w % abs(tab_width)) != 0:
                ### if 0 < w < abs(tab_width):
                    self.error(
                        'leading whitespace not consistent with @tabwidth %d\nline: %s' % (
                            tab_width,repr(line)))
                    break

    if self.strict and changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070808115837.2:Regularize whitespace
#@-node:ekr.20070731070208:Added @auto
#@-node:ekr.20070703182412.1:Features
#@-node:ekr.20070703172548:Leo 4.4.4 projects
#@+node:ekr.20070809131638:Pychecker report
# Invalid warnings...
# leoGlobals.py:136: No module attribute (leo_config_directory) found
# leoGlobals.py:4015: Statement appears to have no effect
# leoGlobals.py:4015: No module attribute (CODESET) found
# leoGlobals.py:4693: No module attribute (mtime) found

# Fixed...
# leoAtFile.py:2999: Parameter (force) not used
# c:\prog\tigris-cvs\leo\src\leoAtFile.py:26: Imported module (leoColor) not used
# leoImport.py:14: Imported module (parser) not used
# leoImport.py:15: Imported module (re) not used
# leoImport.py:17: Imported module (tabnanny) not used
# leoImport.py:18: Imported module (tokenize) not used
# leoImport.py:787: Parameter (toString) not used
# leoImport.py:2913: Parameter (atAuto) not used
# leoImport.py:2886: Parameter (ext) not used
# leoImport.py:2886: Parameter (fileName) not used
# leoImport.py:2889: Parameter (ext) not used
# leoImport.py:2892: Parameter (ext) not used
# leoImport.py:2895: Parameter (ext) not used
# leoImport.py:2898: Parameter (ext) not used
# leoImport.py:2901: Parameter (ext) not used
# leoImport.py:2904: Parameter (ext) not used
# leoImport.py:2907: Parameter (ext) not used
# leoImport.py:2910: Parameter (ext) not used


#@-node:ekr.20070809131638:Pychecker report
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
