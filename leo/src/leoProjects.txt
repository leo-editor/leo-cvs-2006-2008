#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20070809131638:Pychecker report
# Invalid warnings...
# leoGlobals.py:136: No module attribute (leo_config_directory) found
# leoGlobals.py:4015: Statement appears to have no effect
# leoGlobals.py:4015: No module attribute (CODESET) found
# leoGlobals.py:4693: No module attribute (mtime) found

#@-node:ekr.20070809131638:Pychecker report
#@+node:ekr.20070930102228:( jyLeo )
#@+node:ekr.20071008000135:Debugging in jython
#@+node:ekr.20031218072017.2317:trace
# Convert all args to strings.

def trace (*args,**keys):

    #callers = keys.get("callers",False)
    newline = keys.get("newline",True)
    align =   keys.get("align",0)

    s = ""
    for arg in args:
        if type(arg) == type(u""):
            pass
            # try:    arg = str(arg) 
            # except: arg = repr(arg)
        elif type(arg) != type(""):
            arg = repr(arg)
        if len(s) > 0:
            s = s + " " + arg
        else:
            s = arg
    message = s

    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except: name = ''
    if name == "?":
        name = "<unknown>"

    # if callers:
        # traceback.print_stack()

    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else:         name = pad + name

    message = g.toEncodedString(message,'ascii') # Bug fix: 10/10/07.

    if newline:
        print name + ": " + message
    else:
        print name + ": " + message,
#@-node:ekr.20031218072017.2317:trace
#@+node:ekr.20051023083258:callers & _callerName
def callers (n=8,excludeCaller=True,files=False):

    '''Return a list containing the callers of the function that called g.callerList.

    If the excludeCaller keyword is True (the default), g.callers is not on the list.

    If the files keyword argument is True, filenames are included in the list.
    '''

    # sys._getframe throws ValueError in both cpython and jython if there are less than i entries.
    # The jython stack often has less than 8 entries,
    # so we must be careful to call g._callerName with smaller values of i first.
    result = []
    i = g.choose(excludeCaller,3,2)
    while 1:
        s = g._callerName(i,files=files)
        if s:
            result.append(s)
        if not s or len(result) >= n: break
        i += 1

    result.reverse()
    sep = g.choose(files,'\n',',')
    return sep.join(result)
#@+node:ekr.20031218072017.3107:_callerName
def _callerName (n=1,files=False):

    try: # get the function name from the call stack.
        f1 = sys._getframe(n) # The stack frame, n levels up.
        code1 = f1.f_code # The code object
        if files:
            return '%s:%s' % (g.shortFilename(code1.co_filename),code1.co_name)
        else:
            return code1.co_name # The code name
    except ValueError:
        return '' # The stack is not deep enough.
    except:
        g.es_exception()
        return '' # "<no caller name>"
#@-node:ekr.20031218072017.3107:_callerName
#@-node:ekr.20051023083258:callers & _callerName
#@+node:ekr.20071001091231.25:__init__ (swingFrame)
def __init__(self,title,gui):

    g.trace('swingFrame',g.callers(20))

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.use_chapters = False ###

    self.title = title

    leoSwingFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBarClass = self.swingIconBarClass
    self.statusLineClass = self.swingStatusLineClass
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.

    << set the leoSwingFrame ivars >>
#@+node:ekr.20071001091231.26:<< set the leoSwingFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
# self.treeBar = None # Replaced by injected frame.canvas.leo_treeBar.

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@-node:ekr.20071001091231.26:<< set the leoSwingFrame ivars >>
#@-node:ekr.20071001091231.25:__init__ (swingFrame)
#@-node:ekr.20071008000135:Debugging in jython
#@+node:ekr.20070930184746:from original swingGui plugin
@first # -*- coding: utf-8 -*-

"""A plugin to use swing as Leo's gui."""

@language python
@tabwidth -4

__version__ = '0.01' # EKR Initial code based on LeoJy2 version 1-11-06.

try:
    << imports >>
    import_ok = True
except Exception:
    g.es('Can not init swingGui plugin')
    g.es_exception()
    import_ok = False

True, False = 1,0

@others
#@+node:ekr.20070930184746.1:<< imports >>
import leoGlobals as g

import leoFrame
import leoGui
import leoMenu
import leoPlugins

import java.io as io
import org.leo.shell.IsolatedJythonClassLoader as ijcl ###

ld = io.File(g.app.loadDir)
ijcl.addToSearchPath(ld)
ijcl.beginLoading()

import base64
import copy
import string
import sys

import java

import java.awt as awt
import java.awt.datatransfer as datatransfer
import java.awt.event as aevent

import javax.imageio as imageio

import java.io as io

import java.lang
import java.lang.Exception
import java.lang.System as jsys

import javax.swing as swing
import javax.swing.border as sborder
import javax.swing.event as sevent
import javax.swing.plaf.synth as synth
import javax.swing.text as stext  
import javax.swing.tree as stree
import javax.swing.undo as undo

import java.text as text

import java.util as util #
import java.util.concurrent as concurrent
import java.util.concurrent.atomic as atomic
import java.util.concurrent.locks as locks
import java.util.regex as jregex

# import pdb
from utilities.DefCallable import DefCallable
from utilities.TabManager import TabManager
from utilities.WeakMethod import WeakMethod

if 0: # Not ready yet: these should be in this file.
    import leoEditorKit2
    import EditorBackground
    import SwingMacs
    #import string
    #import leoPlugins
    #import base64
    import leoIconTreeRenderer
    import leoHeadlineTreeCellEditor
    import jarray
    import LeoUtilities
    #import copy
    import leoLanguageManager
    import PositionSpecification

if 0:
    @others
    pass
#@nonl
#@+node:ekr.20070930184746.2:imports from leoSwingFrame
#import leoSwingMenu
#import leoSwingGui
###import leoSwingUndo
# import leoFrame

# import leoGlobals as g   

#from utilities.DefCallable import DefCallable
#from utilities.TabManager import TabManager
#from utilities.WeakMethod import WeakMethod
#import weakref

#import java
#import java.awt as awt
# import java.awt.datatransfer as datatransfer
#import java.awt.event as aevent
# import java.io as io
# import java.lang
#import java.lang.Exception
#import java.util as util #
#import java.util.concurrent as concurrent
#import java.util.concurrent.atomic as atomic
#import java.util.concurrent.locks as locks
#import java.util.regex as jregex

#import javax.imageio as imageio

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent
#import javax.swing.plaf.synth as synth
#import javax.swing.text as stext  
#import javax.swing.tree as stree
#import javax.swing.undo as undo

import leoEditorKit2
import EditorBackground
import SwingMacs
#import string
#import leoPlugins
#import base64
import leoIconTreeRenderer
import leoHeadlineTreeCellEditor
import jarray
import LeoUtilities
#import copy
import leoLanguageManager
import PositionSpecification
#@nonl
#@-node:ekr.20070930184746.2:imports from leoSwingFrame
#@+node:ekr.20070930184746.3:imports from leoSwingGui (all comments)
#import leoGlobals as g
#import leoFrame # for null gui.        
#import leoGui

#from utilities.DefCallable import DefCallable

#import java

#import java.awt as awt
#import java.awt.datatransfer as dtfr 
#import java.awt.event as aevent

#import java.io

#import java.lang.System as jsys

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent

#import java.text as text
#@-node:ekr.20070930184746.3:imports from leoSwingGui (all comments)
#@+node:ekr.20070930184746.4:imports from leoSwingFrame
#import leoSwingMenu
#import leoSwingGui
###import leoSwingUndo
# import leoFrame

# import leoGlobals as g   

#from utilities.DefCallable import DefCallable
#from utilities.TabManager import TabManager
#from utilities.WeakMethod import WeakMethod
#import weakref

#import java

#import java.awt as awt
#import java.awt.datatransfer as datatransfer
#import java.awt.event as aevent

#import java.io as io

#import java.lang
#import java.lang.Exception

#import java.util as util #
#import java.util.concurrent as concurrent
#import java.util.concurrent.atomic as atomic
#import java.util.concurrent.locks as locks
#import java.util.regex as jregex

#import javax.imageio as imageio

#import javax.swing as swing
#import javax.swing.border as sborder
#import javax.swing.event as sevent
#import javax.swing.plaf.synth as synth
#import javax.swing.text as stext  
#import javax.swing.tree as stree
#import javax.swing.undo as undo

import leoEditorKit2
import EditorBackground
import SwingMacs
#import string
#import leoPlugins
#import base64
import leoIconTreeRenderer
import leoHeadlineTreeCellEditor
import jarray
import LeoUtilities
import copy
import leoLanguageManager
import PositionSpecification
#@nonl
#@-node:ekr.20070930184746.4:imports from leoSwingFrame
#@+node:ekr.20070930184746.5:imports from leoSwingMenu (all comments)
#import leoGlobals as g

#import java.io as io
#import org.leo.shell.IsolatedJythonClassLoader as ijcl

#ld = io.File( g.app.loadDir )
#ijcl.addToSearchPath( ld )
#ijcl.beginLoading()

#import string
#import sys
#import leoMenu

#import java

#import java.awt as awt
#import java.awt.event as aevent
#import java.lang

#import javax.swing as swing  
#import javax.swing.border as sborder 
#import javax.swing.event as sevent
#import javax.swing.tree as stree  

# import pdb
# from utilities.DefCallable import DefCallable
#@nonl
#@-node:ekr.20070930184746.5:imports from leoSwingMenu (all comments)
#@-node:ekr.20070930184746.1:<< imports >>
#@+node:ekr.20070930184746.7: init
def init ():

    global import_ok
    if not import_ok: return False

    if g.app.gui:
        g.es('Can not install swingGui plugin: %s gui already active' % (g.app.gui.guiName()),color='red')
        return False

    splash = LeoSplash()
    java.awt.EventQueue.invokeAndWait(splash)

    gct = GCEveryOneMinute()
    gct.start()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)

    return True
#@nonl
#@-node:ekr.20070930184746.7: init
#@+node:ekr.20070930184746.9:class leoSwingBody
class leoSwingBody (sevent.DocumentListener,aevent.KeyAdapter,sevent.UndoableEditListener):

    """The base class for the body pane in Leo windows."""

    @others
#@nonl
#@+node:ekr.20070930184746.10:leoSwingBody.__init__
def __init__ (self,frame,parentFrame):

    self.editors = []
    self.ignore_insert = 0
    self.frame = frame
    self.c = c = frame.c
    self.forceFullRecolorFlag = False
    frame.body = self
    # May be overridden i
    #leoFrame.leoBody.__init__( self, frame, parentFrame )
    self.parentFrame = parentFrame
    self._current_editor = None
    self._undo_manager = None
    self.jdp = jdp = swing.JDesktopPane()
    self.jdp.addMouseListener( self.SimplifiedUtilityRightClick( self ) )
    #class AddEditor( event.MouseAdapter ):
    #    def __init__( self ):
    #        event.MouseAdapter.__init__( self )
    #    
    #    def mouse


    #self.mAdapter = leoSwingBody.UtilityRightClick( frame.c ) 
    #self.jdp.addMouseListener( self.mAdapter )
    self.editor = leoSwingBody.Editor( jdp, frame.c, self )
    #self.tabed_pane = swing.JTabbedPane()
    self.tab_manager = TabManager()
    self.tab_manager.add( "Editors", jdp )
    g.doHook( "body_pane_added", c = self.c, tabmanager = self.tab_manager )
    parentFrame.bottomComponent = self.tab_manager.base
    self.editor.frame.setMaximum( True )
    self.oldText = ""
    self.oldSel = ""
    self.oldYview = None
    self.ch = None

    #self.frame = frame
    #self.c = c = frame.c
    #self.forceFullRecolorFlag = False
    #frame.body = self

    # May be overridden in subclasses...
    #self.bodyCtrl = self

    # Must be overridden in subclasses...
    #self.colorizer = None
#@-node:ekr.20070930184746.10:leoSwingBody.__init__
#@+node:ekr.20070930184746.11:oops
def oops (self):

    g.trace("leoBody oops:", g.callerName(2), "should be overridden in subclass")
#@nonl
#@-node:ekr.20070930184746.11:oops
#@+node:ekr.20070930184746.12:leoBody.setFontFromConfig
def setFontFromConfig (self):

    self.oops()
#@nonl
#@-node:ekr.20070930184746.12:leoBody.setFontFromConfig
#@+node:ekr.20070930184746.13:DocumentListener
@
These methods, implementing DocumentListener, keeps the document and position data in sync.
And also adds to the undoer.
@c

def insertUpdate( self, event):

    #doc = event.getDocument()
    #txt = doc.getText( event.getOffset(), event.getLength() )       
    self._syncText( event )

def removeUpdate( self, event):
    self._syncText( event, which = 0 )

def changedUpdate( self, event ):
    pass #this does Attribute changes

def _syncText( self, event, which = 1 ):

    if self.ignore_insert: return
    c = self.c 
    doc = event.getDocument()
    #From here to
    oldText = self.oldText
    oldSel = self.oldSel 
    oldYview = self.oldYview 
    ch = self.ch
    #Here, these are set in the KeyAdapter node

    newSel = c.frame.body.getTextSelection()
    #length = doc.getLength()
    #newText = doc.getText( 0 , length )
    p = c.currentPosition().copy()

    undoType='Typing'
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        event.consume()
        return

    pos = c.currentPosition()
    #pos.setTnodeText( newText )
    t = pos.v.t
    offset = event.getOffset()
    length = event.getLength()
    if which:
        txt = doc.getText( offset, length )
        t._bodyString.insert( offset, txt )
        dec_edit = leoSwingUndo.UndoableDocumentEvent( c , event, txt )
        #c.undoer.addUndo( dec_edit )
        if self.editor._node_undoer:
            self.editor._node_undoer.addUndo( dec_edit )
        else:
            c.undoer.addUndo( dec_edit )
            dec_edit.p = pos.copy()
    else:
        #offset = offset - length
        txt = t.bodyString[ offset: offset + length ]
        t._bodyString.delete( offset, offset + length )
        dec_edit = leoSwingUndo.UndoableDocumentEvent( c, event, txt )
        #c.undoer.addUndo( dec_edit )
        #c.frame.body.editor._node_undoer.addUndo( dec_edit )
        if self.editor._node_undoer:
            self.editor._node_undoer.addUndo( dec_edit )
        else:
            c.undoer.addUndo( dec_edit )
            dec_edit.p = pos.copy()

    if not pos.isDirty():
        pos.setDirty()
        c.setChanged( True )  

    #for z in self.editor.synchers:
    #    z.sync()

    #c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)   
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType) 
#@-node:ekr.20070930184746.13:DocumentListener
#@+node:ekr.20070930184746.14:Must be overriden in subclasses
def createBindings (self,frame):
    self.oops()

def createControl (self,frame,parentFrame):
    self.oops()

def initialRatios (self):
    self.oops()

def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    pass

def setBodyFontFromConfig (self):
    self.oops()

#@+node:ekr.20070930184746.15:Bounding box (Tk spelling)
def bbox(self,index):

    self.oops()
#@nonl
#@-node:ekr.20070930184746.15:Bounding box (Tk spelling)
#@+node:ekr.20070930184746.16:Color tags (Tk spelling)
def tag_add (self,tagName,index1,index2):

    self.oops()

def tag_bind (self,tagName,event,callback):

    self.oops()

def tag_configure (self,colorName,**keys):

    self.oops()

def tag_delete(self,tagName):

    self.oops()

def tag_remove (self,tagName,index1,index2):
    self.oops()
#@nonl
#@-node:ekr.20070930184746.16:Color tags (Tk spelling)
#@+node:ekr.20070930184746.17:Configuration (Tk spelling)
def cget(self,*args,**keys):

    self.oops()

def configure (self,*args,**keys):

    self.oops()
#@nonl
#@-node:ekr.20070930184746.17:Configuration (Tk spelling)
#@+node:ekr.20070930184746.18:Focus
def hasFocus (self):

    return self.editor.editor.hasFocus()

def setFocus (self):

    df = DefCallable( self.editor.editor.requestFocusInWindow )
    ft = java.util.concurrent.FutureTask( df )
    java.awt.EventQueue.invokeLater( ft )

def focus_get( self ):

    return self
#@nonl
#@-node:ekr.20070930184746.18:Focus
#@+node:ekr.20070930184746.19:Height & width
def getBodyPaneHeight (self):

    return self.editor.editor.getSize().height

def getBodyPaneWidth (self):

    return self.editor.editor.getSize().width 
#@nonl
#@-node:ekr.20070930184746.19:Height & width
#@+node:ekr.20070930184746.20:Idle time...
def scheduleIdleTimeRoutine (self,function,*args,**keys):

    self.oops()
#@nonl
#@-node:ekr.20070930184746.20:Idle time...
#@+node:ekr.20070930184746.21:Indices
def adjustIndex (self,index,offset):

    return index + offset

def compareIndices(self,i,rel,j):

    if j == 'end' or j == '1.0':
        if j == 'end':
            j = self.editor.editor.getDocument().getLength()
        elif j == '1.0':
            j = 0

    if rel == '<=':
        return i <= j

def convertRowColumnToIndex (self,row,column):

    self.oops()

def convertIndexToRowColumn (self,index):

    self.oops()

def getImageIndex (self,image):

    self.oops()
#@nonl
#@-node:ekr.20070930184746.21:Indices
#@+node:ekr.20070930184746.22:Insert point
def getBeforeInsertionPoint (self):

    editor = self.editor.editor
    pos = editor.getCaretPosition()
    if pos == 0:
        return 0
    else:
        return pos - 1

def getInsertionPoint (self):

    return self.editor.editor.getCaretPosition()

def getCharAtInsertPoint (self):

    editor = self.editor.editor
    pos = editor.getCaretPosition()
    doc = editor.getDocument()
    dlen = doc.getLength()
    if dlen == pos:
        return " "
    else:
        return doc.getText( pos, 1 )

def getCharBeforeInsertPoint (self):
    editor = self.editor.editor
    pos = editor.getCaretPosition()
    doc = editor.getDocument()
    dlen = doc.getLength()
    if pos == 0:
        return " "
    else:
        return doc.getText( pos - 1, 1 )

def makeInsertPointVisible (self):
    pass #this doesn't seem to be a relevant method at this point

def setInsertionPoint (self,index):

    self.editor.editor.setCaretPosition( index )

def setInsertionPointToEnd (self):

    editor = self.editor.editor
    doc = editor.getDocument()
    editor.setCaretPosition( doc.getLength() )

def setInsertPointToStartOfLine (self,lineNumber): # zero-based line number

    txt = self.editor.editor.getText()
    lines = txt.splitlines( True )
    n = 0
    for z in xrange( lineNumber ):
        n += len( lines[ z ] )

    self.editor.editor.setCaretPosition( n )
#@-node:ekr.20070930184746.22:Insert point
#@+node:ekr.20070930184746.23:Menus
def bind (self,*args,**keys):

    #self.oops()
    pass
#@-node:ekr.20070930184746.23:Menus
#@+node:ekr.20070930184746.24:Selection
def deleteTextSelection (self):

    editor = self.editor.editor
    editor.replaceSelection( "" )

def getSelectedText (self):

    editor = self.editor.editor
    return editor.getSelectedText()

def getTextSelection (self):

    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    return start, end

def hasTextSelection (self):

    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start != end: return True
    else: return False

def selectAllText (self):

    editor = self.editor.editor
    doc = editor.getDocument()
    editor.setSelectionStart( 0 )
    editor.setSelectionEnd( doc.getLength() )

def setTextSelection (self,i,j=None):

    if i is None:
        i, j = 0, 0
    elif i != None and j != None:
        pass
    else:
        i,j = i
    editor = self.editor.editor
    g.app.gui.setTextSelection( editor, i, j )
#@nonl
#@-node:ekr.20070930184746.24:Selection
#@+node:ekr.20070930184746.25:Text
#@+node:ekr.20070930184746.26:delete...
#@+node:ekr.20071001070907:deleteAllText
def deleteAllText (self):
    editor = self.editor.editor
    doc = editor.getDocument()
    doc.replace(0,doc.getLength(),"",None)

#@-node:ekr.20071001070907:deleteAllText
#@+node:ekr.20071001070907.1:deleteCharacter
def deleteCharacter (self,index):
    editor = self.editor.editor
    doc = editor.getDocument()
    doc.replace(index,1,"",None)

#@-node:ekr.20071001070907.1:deleteCharacter
#@+node:ekr.20071001070907.2:deleteLastChar
def deleteLastChar (self):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    sdoc.replace(sdoc.getLength()-1,1,"",None)

#@-node:ekr.20071001070907.2:deleteLastChar
#@+node:ekr.20071001070907.3:deleteLine
def deleteLine (self,lineNumber): # zero based line number.
    editor = self.editor.editor
    txt = editor.getText()
    lines = txt.splitlines(True)
    start = lines [: lineNumber]
    end = lines [lineNumber + 1:]
    start.extend(end)
    ntxt = ''.join(start)
    sdoc = editor.getStyledDocument()
    sdoc.replace(0,sdoc.getLength(),"",None)
    sdoc.insertString(0,ntxt,None)

#@-node:ekr.20071001070907.3:deleteLine
#@+node:ekr.20071001070907.4:deleteLines
def deleteLines (self,line1,numberOfLines): # zero based line numbers.
    editor = self.editor.editor
    txt = editor.getText()
    txtlines = txt.splitlines(True)
    start = txtlines [: line1]
    middle = ['\n',]
    end = txtlines [line1 + numberOfLines:]
    start.extend(middle)
    start.extend(end)
    ntxt = ''.join(start)
    sdoc = editor.getStyledDocument()
    try:
        sdoc.replace(0,sdoc.getLength(),ntxt,None)
    except java.lang.Exception, x:
        x.printStackTrace()

#@-node:ekr.20071001070907.4:deleteLines
#@+node:ekr.20071001070907.5:deleteRange
def deleteRange (self,index1,index2):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    sdoc.remove(index1,index2-index1)
#@nonl
#@-node:ekr.20071001070907.5:deleteRange
#@-node:ekr.20070930184746.26:delete...
#@+node:ekr.20070930184746.27:get...
#@+node:ekr.20071001071107:getAllText
def getAllText (self):
    editor = self.editor.editor
    doc = editor.getDocument()
    return doc.getText()

#@-node:ekr.20071001071107:getAllText
#@+node:ekr.20071001071107.1:getCharAtIndex
def getCharAtIndex (self,index):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    return sdoc.getText(index,1)

#@-node:ekr.20071001071107.1:getCharAtIndex
#@+node:ekr.20071001071107.2:getInsertLines
def getInsertLines (self):
    self.oops()
    return None, None, None

#@-node:ekr.20071001071107.2:getInsertLines
#@+node:ekr.20071001071107.3:getSelectionAreas
def getSelectionAreas (self):
    self.oops()
    return None, None, None

#@-node:ekr.20071001071107.3:getSelectionAreas
#@+node:ekr.20071001071107.4:getSelectionLines
def getSelectionLines (self):
    editor = self.editor.editor
    start = editor.getSelectionStart()
    end = editor.getSelectionEnd()
    if start == end:
        start = stext.Utilities.getRowStart(editor,start)
        end = stext.Utilities.getRowEnd(editor,start)
        if start == -1: start = 0
        if end == -1: end = 0

    before = editor.getText(0,start)
    sel = editor.getText(start,end-start)
    after = editor.getText(end,len(editor.getText())-end)
    return before, sel, after

#@-node:ekr.20071001071107.4:getSelectionLines
#@+node:ekr.20071001071107.5:getTextRange
def getTextRange (self,index1,index2):
    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    return sdoc.getText(index1,index2-index1)

#@-node:ekr.20071001071107.5:getTextRange
#@-node:ekr.20070930184746.27:get...
#@+node:ekr.20070930184746.28:Insert...
#@+node:ekr.20071001071107.6:insertAtInsertPoint
def insertAtInsertPoint (self,s):

    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    pos = editor.getCaretPosition()
    sdoc.insertString(pos,s,None)
    editor.setCaretPosition(pos+len(s))

#@-node:ekr.20071001071107.6:insertAtInsertPoint
#@+node:ekr.20071001071107.7:insertAtEnd
def insertAtEnd (self,s):

    editor = self.editor.editor
    sdoc = editor.getStyledDocument()
    length = sdoc.getLength()
    sdoc.insertString(length-1,s,None)
    editor.setCaretPosition(length-1+len(s))

#@-node:ekr.20071001071107.7:insertAtEnd
#@+node:ekr.20071001071107.8:insertAtStartOfLine
def insertAtStartOfLine (self,lineNumber,s):

    editor = self.editor.editor
    txt = editor.getText()
    txtlines = txt.splitlines(True)
    lines = txtlines [: lineNumber]
    where = ''.join(lines)
    spot = len(where)
    sdoc = editor.getStyledDocument()
    sdoc.insertString(spot,s,None)
    editor.setCaretPosition(spot+len(s))
#@nonl
#@-node:ekr.20071001071107.8:insertAtStartOfLine
#@-node:ekr.20070930184746.28:Insert...
#@+node:ekr.20070930184746.29:setSelectionAreas
def setSelectionAreas (self,before,sel,after):

    editor = self.editor.editor
    doc = editor.getDocument()
    doc.remove(0,doc.getLength())
    if before:
        doc.insertString(0,before,None)
    sel_start = doc.getLength()

    if sel:
        doc.insertString(doc.getLength(),sel,None)
    sel_end = doc.getLength()

    if after:
        if after [ -1] == '\n':
            after = after [: -1]
        doc.insertString(doc.getLength(),after,None)

    g.app.gui.setTextSelection(self.editor.editor,sel_start,sel_end)

    return sel_start, sel_end
#@-node:ekr.20070930184746.29:setSelectionAreas
#@-node:ekr.20070930184746.25:Text
#@+node:ekr.20070930184746.30:Visibility & scrolling
def makeIndexVisible (self,index):
    pass

def setFirstVisibleIndex (self,index):
    pass

def getYScrollPosition (self):

    editor = self.editor.editor
    try:
        cpos = editor.getCaretPosition()
        rec = editor.modelToView( cpos )
        return rec.y 
    except:
        return 0

def setYScrollPosition (self,scrollPosition):
    #self.oops()
    #print "Y Scroll is %s" % scrollPosition
    pass   

def scrollUp (self):
    self.oops()

def scrollDown (self):
    self.oops()
#@nonl
#@-node:ekr.20070930184746.30:Visibility & scrolling
#@-node:ekr.20070930184746.14:Must be overriden in subclasses
#@+node:ekr.20070930184746.31:Coloring
# It's weird to have the tree class be responsible for coloring the body pane!

def getColorizer(self):

    return self.colorizer

def recolor_now(self,p,incremental=False):

    self.editor.editor.repaint()
    #self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):

    pass 
    #self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=False):

    pass
    #if 0: # Do immediately
    #    self.colorizer.colorize(p.copy(),incremental)
    #else: # Do at idle time
    #    self.colorizer.schedule(p.copy(),incremental)

def updateSyntaxColorer(self,p):
    pass
    #return self.colorizer.updateSyntaxColorer(p.copy())
#@nonl
#@-node:ekr.20070930184746.31:Coloring
#@+node:ekr.20070930184746.32:class Editor
class Editor( aevent.FocusListener ):

    ipath = g.os_path_join( g.app.loadDir ,"..","Icons","Leoapp2.GIF")
    icon = swing.ImageIcon( "../Icons/Leoapp2.GIF" )
    icon = swing.ImageIcon( ipath ) 
    #ifile = java.io.File( ipath )
    #iimage = imageio.ImageIO.read( ifile ) 

    @others





#@+node:ekr.20070930184746.33:class insTx
class InsertTextIntoBody(swing.AbstractAction):

    def __init__ (self,c,txt):
        swing.AbstractAction.__init__(self,txt)
        self.txt = txt
        self.c = c

    def actionPerformed (self,event):

        editor = self.c.frame.body.editor.editor
        pos = editor.getCaretPosition()
        #editor.insert( self.txt, pos )
        doc = editor.getDocument()
        doc.insertString(pos,self.txt,None)



class SetHeadline(InsertTextIntoBody):

    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        newHeadString = "%s %s" % (self.txt,hS)
        cp.setHeadString(newHeadString)


class SetHeadlineToSelection(InsertTextIntoBody):
    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        txt = self.c.frame.body.editor.editor.getSelectedText()
        if txt:
            cp = self.c.currentPosition()
            cp.setHeadString(txt)



class rmvSymbol(swing.AbstractAction):
    def __init__ (self,c,symbol):
        swing.AbstractAction.__init__(self,"remove %s" % symbol)
        self.c = c
        self.symbol = symbol

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        if hS.startswith(self.symbol):
            hS = hS.split()
            hS = hS [1:]
            hS = " ".join(hS)
            cp.setHeadString(hS)



class inSRMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        cp = self.c.currentPosition()
        InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
        for z in cp.children_iter():
            hS = z.headString()
            hS = hS.strip()
            if hS.startswith("<%s" % '<') and hS.endswith(">%s" % ">"):
                menu.add(InsertTextIntoBody(self.c,hS))

#@-node:ekr.20070930184746.33:class insTx
#@+node:ekr.20070930184746.34:colorizer callback
class ColorKeywordsProvider(leoEditorKit2.ColorDeterminer,sevent.DocumentListener):

    @others
#@+node:ekr.20071001071356:__init__
def __init__ (self,c):

    lb = leoLanguageManager.LanguageManager.getLanguageBundle(c)
    for z in dir(lb):
        if not callable(getattr(lb,z)):
            setattr(self,z,getattr(lb,z))

    self.c = c
    self.last_p = None
    self.last_language = None
    self.editor = None
    self.error_map = util.HashMap()
    fg, bg, cl = self.getLineNumberColors()
    self.line_fg = fg ; self.line_bg = bg ; self.line_cl = cl
    self.queue = concurrent.LinkedBlockingQueue()
    self.c.invisibleWatchers.append(self)
    return


#@-node:ekr.20071001071356:__init__
#@+node:ekr.20071001071356.1:changedUpdate
def changedUpdate (self,event):
    pass #this does Attribute changes


#@-node:ekr.20071001071356.1:changedUpdate
#@+node:ekr.20071001071356.2:checkForLanguageChange
def checkForLanguageChange (self,event):

    language = LeoUtilities.scanForLanguageOnLine(self.editor)
    if language:
        #if not hasattr( self, "%s_keywords" % language ):
        if self.last_language != language:
            #self.editor.repaint()
            self.last_language = language
            jlc = self.c.frame.body.editor.jlc
            jlc.fullrecolorize()



#@-node:ekr.20071001071356.2:checkForLanguageChange
#@+node:ekr.20071001071356.3:drawrectangle
def drawrectangle (self):
    return self._drawrectangle

#@-node:ekr.20071001071356.3:drawrectangle
#@+node:ekr.20071001071356.4:getColoredTokens
def getColoredTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language

    leoLanguageManager.LanguageManager.setLanguageInEffect(self.c,language)

    if language == None:
        language = "python"
    if hasattr(self,"%s_keywords" % language):
        return getattr(self,"%s_keywords" % language)
    else:
        hm = leoLanguageManager.LanguageManager.loadLanguage(self.c,language)
        setattr(self,"%s_keywords" % language,hm)
        return hm


#@-node:ekr.20071001071356.4:getColoredTokens
#@+node:ekr.20071001071356.5:getCommentColor
def getCommentColor (self):
    return self._commentColor

#@-node:ekr.20071001071356.5:getCommentColor
#@+node:ekr.20071001071356.6:getCommentTokens
def getCommentTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language
    if self.comment_cache.has_key(language):
        return self.comment_cache [language]
    else:
        rv = g.set_delims_from_language(language)
        rv = jarray.array(rv,java.lang.String)
        self.comment_cache [language] = rv
        return rv
    #delim1,delim2, delim3 = g.set_delims_from_language( language )
    #return [ delim1, delim2, delim3 ]

#@-node:ekr.20071001071356.6:getCommentTokens
#@+node:ekr.20071001071356.7:getCurrentLineNumberForeground
def getCurrentLineNumberForeground (self):
    return self.line_cl

#@-node:ekr.20071001071356.7:getCurrentLineNumberForeground
#@+node:ekr.20071001071356.8:getDocColor
def getDocColor (self):
    return self._docColor

#@-node:ekr.20071001071356.8:getDocColor
#@+node:ekr.20071001071356.9:getFoldedBackgroundColor
def getFoldedBackgroundColor (self):
    return self._fbColor

#@-node:ekr.20071001071356.9:getFoldedBackgroundColor
#@+node:ekr.20071001071356.10:getFoldedForegroundColor
def getFoldedForegroundColor (self):
    return self._ffColor



#@-node:ekr.20071001071356.10:getFoldedForegroundColor
#@+node:ekr.20071001071356.11:getFootNodeBackgroundColor
def getFootNodeBackgroundColor (self):
    return self._fnbgColor

#@-node:ekr.20071001071356.11:getFootNodeBackgroundColor
#@+node:ekr.20071001071356.12:getFootNodeForegroundColor
def getFootNodeForegroundColor (self):
    return self._fnfgColor


#@-node:ekr.20071001071356.12:getFootNodeForegroundColor
#@+node:ekr.20071001071356.13:getFootNodes
def getFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            sb = java.lang.StringBuilder()
            for z in fn:
                sb.append(z[0]).append(" : ").append(z[1])
                if not z [1].endswith("\n"): sb.append("\n")
            return sb.toString()
    return ""


#@-node:ekr.20071001071356.13:getFootNodes
#@+node:ekr.20071001071356.14:getInvisiblesBlock
def getInvisiblesBlock (self):
    return self._invisibleBlock

#@-node:ekr.20071001071356.14:getInvisiblesBlock
#@+node:ekr.20071001071356.15:getInvisiblesDot
def getInvisiblesDot (self):
    return self._invisibleDot

#@-node:ekr.20071001071356.15:getInvisiblesDot
#@+node:ekr.20071001071356.16:getLineNumberBackground
def getLineNumberBackground (self):
    return self.line_bg

#public boolean useLineNumbers();
#public Color getLineNumberForeground();
#public Color getCurrentLineNumberForeground();
#public Color getLineNumberBackground();
#@-node:ekr.20071001071356.16:getLineNumberBackground
#@+node:ekr.20070930184746.35:getLineNumberColors
def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl



#@-node:ekr.20070930184746.35:getLineNumberColors
#@+node:ekr.20071001071356.17:getLineNumberForeground
def getLineNumberForeground (self):
    return self.line_fg

#@-node:ekr.20071001071356.17:getLineNumberForeground
#@+node:ekr.20071001071356.18:getNumericColor
def getNumericColor (self):
    return self._numericcolor

#@-node:ekr.20071001071356.18:getNumericColor
#@+node:ekr.20071001071356.19:getOperators
def getOperators (self):
    return util.HashMap()


#@-node:ekr.20071001071356.19:getOperators
#@+node:ekr.20071001071356.20:getPunctuationColor
def getPunctuationColor (self):
    return self._punctuationColor

#@-node:ekr.20071001071356.20:getPunctuationColor
#@+node:ekr.20071001071356.21:getRectangleColor
def getRectangleColor (self):
    return self._rectanglecolor

#@-node:ekr.20071001071356.21:getRectangleColor
#@+node:ekr.20071001071356.22:getSectionReferenceColor
def getSectionReferenceColor (self):
    return self._sectionNameColor

#@-node:ekr.20071001071356.22:getSectionReferenceColor
#@+node:ekr.20071001071356.23:getStringColor
def getStringColor (self):
    return self._stringColor

#@-node:ekr.20071001071356.23:getStringColor
#@+node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
def getUndefinedSectionReferenceColor (self):
    return self._undefinedSectionNameColor

#@-node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
#@+node:ekr.20071001071356.25:hasFootNodes
def hasFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            if fn: return True
    return False

#@-node:ekr.20071001071356.25:hasFootNodes
#@+node:ekr.20071001071356.26:insertUpdate
def insertUpdate (self,event):
    self.checkForLanguageChange(event)

#@-node:ekr.20071001071356.26:insertUpdate
#@+node:ekr.20071001071356.27:notify
def notify (self):
    self.c.frame.body.editor.ekit.showInvisibles(self.c.showInvisibles)

#@-node:ekr.20071001071356.27:notify
#@+node:ekr.20071001071356.28:removeUpdate
def removeUpdate (self,event):
    self.checkForLanguageChange(event)


#@-node:ekr.20071001071356.28:removeUpdate
#@+node:ekr.20071001071356.29:setEditor
def setEditor (self,editor):
    self.editor = editor
    doc = editor.getDocument()
    doc.addDocumentListener(self)


#@-node:ekr.20071001071356.29:setEditor
#@+node:ekr.20071001071356.30:showInvisibles
def showInvisibles (self):
    return self.c.showInvisibles

#@-node:ekr.20071001071356.30:showInvisibles
#@+node:ekr.20071001071356.31:underline
def underline (self):
    return self._underline

#@-node:ekr.20071001071356.31:underline
#@+node:ekr.20071001071356.32:useLineNumbers
def useLineNumbers (self):
    return g.app.config.getBool(self.c,"use_line_numbering")

#@-node:ekr.20071001071356.32:useLineNumbers
#@+node:ekr.20071001071356.33:whichInvisible
def whichInvisible (self):
    return self._which_invisible

#@-node:ekr.20071001071356.33:whichInvisible
#@-node:ekr.20070930184746.34:colorizer callback
#@+node:ekr.20070930184746.36:RecentVisitsMenuListener
class RecentVisitsMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c,recent):
        self.menu = menu
        self.c = c
        self.recent = recent

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        goNode = leoSwingBody.Editor.goNode
        for z in self.recent:
            if z:
                menu.add(goNode(z,self.c))
#@-node:ekr.20070930184746.36:RecentVisitsMenuListener
#@+node:ekr.20070930184746.37:Note on Editor design
@
The key to making:
    1. Autocompleter
    2. Line numbers
    3. Any any future floaters
work is in the use of the JLayeredPane.  The JLayeredPane is made for floating widgets on top of one another.


This allows the autocompleter to appear on top of the JTextPane when needed.  It also allows
the easy placement of the Line number label to the left.

The line number label was tried as a JTextPane to start with, this gave us numbers parralel to the editor.
But this seemed to introduce a scroll bug that became apparent when the editor had a large volume of lines in it.  My
assumption is that this was because of some event the Caret for the line number editor was executing when its contents
changed.  By moving to a Label that is drawn on my a method in the LeoView class this problem no longer presented itself,
mainly because a JLabel doesnt have a Cursor.  If that was the source of the problem.

The viewport is secretly tied to the JTextPane by a specialised jython JLayeredPane that returns the preferred size of the
JTextPane instead of itself.  This causes the JScrollPane to actually scroll with the editor.

To calculate the coordinates of a floater you need to do the minimum:
1. Translate the viewports visible rectangle into the JLayeredPanes coord system.
    2. Translate the JTextPane into the JLayeredPanes coord system.
    3. Do calculations based off of those two pieces of information.


@c
#@-node:ekr.20070930184746.37:Note on Editor design
#@+node:ekr.20070930184746.38:__init__ (Editor)
def __init__( self, parent, c , body, x = 0, y = 0):

    self.c = c
    self.body = body
    wr = java.lang.ref.WeakReference( self )
    self.body.editors.append( wr )
    self.synchers = []
    self._parent = parent 
    self.frame = swing.JInternalFrame( "", 1, 1, 1, 1, 
                                      size = ( 400, 400 ) )
    self.frame.setFocusTraversalPolicy( c.frame.ftp )
    self._attached = True

    cpane = self.frame.getContentPane()
    self.tab_manager = TabManager()
    self.tab_manager.tabsToBottom()
    self.visible_informer = VisibleInformer( self.tab_manager.jtp )
    cpane.add( self.tab_manager.base, java.awt.BorderLayout.CENTER )
    self.editorlomanager = self.leoLayoutManager()
    self.epane = swing.JPanel()
    self.epane.setLayout( self.editorlomanager )
    self.frame.setFrameIcon( leoSwingBody.Editor.icon )

    self.initializeEditor()        
    self.initializeFont()
    << add EditorKit>>

    #self.editor.addFocusListener( self.tFocusListener())
    self.editor.addMouseListener( leoSwingBody.UtilityRightClick( c , detach_retach = True, editor = self ) )
    self.addMinibuffer()
    self.swingmacs = SwingMacs.SwingMacs( self.editor, self.minibuffer, self.minilabel, c )
    c.frame.isMenuInitialized( self.createCommanderCommander )

    #self.swingmacs.addCommands( commandercommander, commandercommander.getCommands() )
    self.addCompleters()
    self.addMenus()    

    self.brackethighlighter = self.BracketHighlighter( self.editor, c ) # initializeCaret needs this to work
    self.initializeCaret()


    self.editor.setName( "Editor" )

    self.editor.getDocument().addDocumentListener( body )
    self.editor.addKeyListener( body )
    << add autocompleter >>
    << add scrollpane >>


    self.configureMedia()
    self.editor.addFocusListener( self )
    self.frame.setLocation( x, y )
    parent.add( self.frame, swing.JLayeredPane.DEFAULT_LAYER )
    self.initializeEditorColors()
    self.frame.visible = 1
    self.lastPosition = None
    self.chapter = None
    wm1 = WeakMethod( self, "chapterChanged" )
    wm2 = WeakMethod( self, "headlineChanged" )
    leoPlugins.registerHandler( "chapter-changed", wm1 )
    leoPlugins.registerHandler( "chapter-removed", wm1 )
    leoPlugins.registerHandler( "headline-editing-finished", wm2 )

    bd = self.ekit.getBorder()
    vpb = self.view.getViewportBorder()
    if vpb:
        bd = sborder.CompoundBorder( bd, vpb )
    self.view.setViewportBorder( bd )
    self.sync()
    self.chapter = c.chapters.current_chapter
    g.doHook( "editor-created", editor = self )







#@+node:ekr.20070930184746.39:<< add EditorKit >>
self.cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider( self.c )
self.cdeterminer = weakref.proxy( cdeterminer )
#use_line_numbers = g.app.config.getBool( c, "use_line_numbering" )  
use_line_numbers = 0 
if use_line_numbers:
    pass
    #self.initializeLineNumbering()
else:
    self.numbers = None

#self.ekit = leoEditorKit( cdeterminer, self.numbers )
import leoEditorKit2
self.ekit = leoEditorKit2( self.editor, cdeterminer, leoSwingBody.Editor.icon )
self.editor.setEditorKit( self.ekit )
#self.editor.setDocument( ekit.createDefaultDocument() )
cdeterminer.setEditor( self.editor )
import JyLeoColorizer
self.jlc = JyLeoColorizer.JyLeoColorizer( self.editor, cdeterminer )
self.foldprotection = self.FoldProtector( self.editor, self.ekit )
self.editor.getDocument().setDocumentFilter( self.foldprotection )
#self.editor.getDocument().addUndoableEditListener( self.body )

#@-node:ekr.20070930184746.39:<< add EditorKit >>
#@+node:ekr.20070930184746.40:<< add autocompleter >>
self.autocompleter = self.autolistener( self )
self.editor.getDocument().addDocumentListener( self.autocompleter )
self.editor.addKeyListener( self.autocompleter )
g.app.config.manager.addNotificationDef( "use_autocompleter", self.useAutocompleter )
self.useAutocompleter()



#@-node:ekr.20070930184746.40:<< add autocompleter >>
#@+node:ekr.20070930184746.41:<< add scrollpane >>
spc = swing.ScrollPaneConstants
#self.view = swing.JScrollPane( layeredpane )
self.view = swing.JScrollPane( self.editor )
self.editorlomanager.jscrollpane = self.view
self.editor.addFocusListener( leoJSPFocusListener( self.view, self.c  ) )
self.view.setHorizontalScrollBarPolicy( swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER )
self._vport = vport = self.view.getViewport()
vport.addComponentListener( self.resizer2( self.editorlomanager ) )
vport.setScrollMode( vport.BLIT_SCROLL_MODE ) #fastest, removes alot of the flicker I saw
mwl = self.view.getMouseWheelListeners()[ 0 ]
self.editor.addMouseWheelListener( mwl )
self.frame.addMouseWheelListener( mwl )
self.epane.add( self.view )
#jtp.add( "Editor", self.epane )
self.tab_manager.add( "Editor", self.epane )
self.visible_informer.addCallback( self.epane, self.nowShowing )
#jtp.add( "Editor", self.view )
#cpane.add( self.view )
#@nonl
#@-node:ekr.20070930184746.41:<< add scrollpane >>
#@-node:ekr.20070930184746.38:__init__ (Editor)
#@+node:ekr.20070930184746.42:helper methods and classes
@others
#@nonl
#@+node:ekr.20070930184746.43:constuctor methods
# Just some methods the constructor calls to build the gui components.
#@+node:ekr.20070930184746.44:addMenus
def addMenus (self):

    self.menu = swing.JMenuBar()
    self.frame.setJMenuBar(self.menu)
    self.gotoMenu = gm = swing.JMenu("Goto")
    recmen = swing.JMenu("Recent")
    self.recent = []
    recmen.addMenuListener(leoSwingBody.Editor.RecentVisitsMenuListener(recmen,self.c,self.recent))
    gm.add(recmen)
    self.menu.add(gm)
    self.configureGotoMenu(gm)

    self.bodyMenu = body = swing.JMenu("Body")
    self.menu.add(body)
    directives = swing.JMenu("Directives")
    self.directiveMenu(directives)
    #self.menu.add( directives )
    body.add(directives)
    self.addLanguageMenu(body)
    headline = swing.JMenu("Headline")
    self.headlineMenu(headline)
    self.menu.add(headline)
    isSR = swing.JMenu("Insert<%s%s>" % ('<','>'))
    self.insertSR(isSR)
    body.add(isSR)


    insPath = swing.JMenuItem("Insert @path With File Dialog")
    self.addInsertPath(insPath)
    body.add(insPath)

    #self.addFootNodeMenu( body )

    config = g.app.config
    wrap = config.getBool(self.c,"body_pane_wraps")
    self.ekit.setLineWrap(wrap)
    wrapmenuitem = swing.JCheckBoxMenuItem("Wrap Lines")
    wrapmenuitem.setState(wrap)
    def wrapcommand (event):
        source = event.getSource()
        wrap = source.getState()
        self.ekit.setLineWrap(wrap)
        if wrap:
            self.view.setHorizontalScrollBarPolicy(swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER)
        else: self.view.setHorizontalScrollBarPolicy(swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED)

    wrapmenuitem.actionPerformed = wrapcommand
    body.add(wrapmenuitem)
    if config.getBool(self.c,"use_text_undo"):
        umenu = swing.JMenuItem("")
        rmenu = swing.JMenuItem("")
        gtnu = swing.JMenuItem("Goto Next Undo Spot")
        gtnr = swing.JMenuItem("Goto Next Redo Spot")
        vunstack = swing.JMenuItem("Visualise Undo Stack")
        clear_undo = swing.JMenuItem("Clear Undo")
        self._node_undoer = leoSwingUndo.NodeUndoer(self.c,umenu,rmenu,gtnu,gtnr,vunstack,clear_undo,self.editor)
        #print self._node_undoer
        body.addSeparator()
        body.add(umenu)
        body.add(rmenu)
        body.addSeparator()
        body.add(gtnu)
        body.add(gtnr)
        body.addSeparator()
        body.add(vunstack)
        body.add(clear_undo)
    else:
        self._node_undoer = None

    self.viewMenu = vmenu = swing.JMenu("Views")
    self.menu.add(vmenu)
    jmi = swing.JCheckBoxMenuItem("CompositeView")
    vmenu.add(jmi)
    jmi.actionPerformed = self.addCompositeView


    self.helpmenu = swing.JMenu("Help")
    self.menu.add(self.helpmenu)
    self.helpmenu.add(self.smacs_help(self.c,self.swingmacs,"Keystrokes"))
    self.helpmenu.add(self.smacs_help(self.c,self.swingmacs,"Commands"))
    self.helpmenu.add(self.autocompleter_help())
    if hasattr(self.body,'ebm'):
        ccomp = self.body.ebm.getControlPanelComponent()
        self.menu.add(ccomp)


#@-node:ekr.20070930184746.44:addMenus
#@+node:ekr.20070930184746.45:addMinibuffer
def addMinibuffer (self):

    self.minilabel = swing.JLabel()
    self.minibuffer = minibuffer = swing.JTextField(15)
    frame = swing.JPanel()
    frame.setLayout(swing.BoxLayout(frame,swing.BoxLayout.X_AXIS))
    frame.add(self.minilabel)
    frame.add(minibuffer)
    frame.setName("Minibufferbackground")
    self.epane.add(frame) # awt.BorderLayout.SOUTH )
    self.editorlomanager.minibuffer = frame
    #cpane = self.frame.getContentPane()
    #cpane.add( frame, awt.BorderLayout.SOUTH )
#@-node:ekr.20070930184746.45:addMinibuffer
#@+node:ekr.20070930184746.46:addCompleters
def addCompleters (self):

    config = g.app.config
    if config.getBool(self.c,"complete-<"):
        self.swingmacs.addCompleter("<",">")
    if config.getBool(self.c,"complete-("):
        self.swingmacs.addCompleter("(",")")
    if config.getBool(self.c,"complete-["):
        self.swingmacs.addCompleter("[","]")
    if config.getBool(self.c,"complete-{"):
        self.swingmacs.addCompleter("{","}")
    if config.getBool(self.c,"complete-'"):
        self.swingmacs.addCompleter("'","'")
    if config.getBool(self.c,'complete-"'):
        self.swingmacs.addCompleter('"','"')
    if config.getBool(self.c,"add_tab_for-:"):
        self.swingmacs.addTabForColon(True)




#@-node:ekr.20070930184746.46:addCompleters
#@+node:ekr.20070930184746.47:initializeEditor
def initializeEditor (self):


    self.editor = self.leoJTextPane(self.c)
    self.editor.setLineColor()
    self.body._current_editor = self.editor
    manager = g.app.config.manager
    wm1 = WeakMethod(self.editor,"setLineColor")
    manager.addNotificationDef("highlight_current_line",wm1)
    manager.addNotificationDef("current_line_highlight_color",wm1)
#@-node:ekr.20070930184746.47:initializeEditor
#@+node:ekr.20070930184746.48:initializeEditorColors
def initializeEditorColors (self):

    self.setEditorColors()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setEditorColors")
    manager.addNotificationDef('body_text_foreground_color',wm1)
    manager.addNotificationDef('body_text_background_color',wm1)
    manager.addNotificationDef('body_selection_color',wm1)
    manager.addNotificationDef('body_text_selected_color',wm1)


#@-node:ekr.20070930184746.48:initializeEditorColors
#@+node:ekr.20070930184746.49:initializeFont
def initializeFont (self):

    self.setFont()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setFont")
    manager.addNotificationDef("body_text_font_family",wm1)
    manager.addNotificationDef("body_text_font_size",wm1)
    manager.addNotificationDef("body_text_font_weight",wm1)

#@-node:ekr.20070930184746.49:initializeFont
#@+node:ekr.20070930184746.50:initializeCaret
def initializeCaret (self):

    self.setCaret()
    wm1 = WeakMethod(self,"setCaret")
    g.app.config.manager.addNotificationDef("which_caret",wm1)

#@-node:ekr.20070930184746.50:initializeCaret
#@+node:ekr.20070930184746.51:initializeLineNumbering
def initializeLineNumbering (self):

    fg, bg, cl = self.getLineNumberColors()
    #self.numbers = leoEditorKit.LeoNumberLabel( bg, fg, cl )
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setLineNumberColors")
    manager.addNotificationDef("line_number_background",wm1)
    manager.addNotificationDef("line_number_foreground",wm1)
    manager.addNotificationDef("line_number_current",wm1)

#@-node:ekr.20070930184746.51:initializeLineNumbering
#@+node:ekr.20070930184746.52:createCommanderCommander
def createCommanderCommander (self,menu):

    commandercommander = self.CommanderCommander(self.c,self.swingmacs,menu)
    self.swingmacs.addCommands(commandercommander,commandercommander.getAltXCommands())
#@nonl
#@-node:ekr.20070930184746.52:createCommanderCommander
#@-node:ekr.20070930184746.43:constuctor methods
#@+node:ekr.20070930184746.53:config methods
@others
#@+node:ekr.20070930184746.54:configureMedia
def configureMedia (self):

    c = self.c
    use_background = g.app.config.getBool(c,"use_media_background")
    if use_background:
        try:
            background_which = g.app.config.getString(c,"media_background_type")
            if background_which == 'image':
                self.setBackgroundImage()
            elif background_which == 'movie':
                movie = g.app.config.getString(c,"movie_location@as-filedialog")
                if movie:
                    self.background = swing.JPanel()
                    self.background.setOpaque(False)
                    import EditorBackgroundMovie
                    ebm = EditorBackgroundMovie(movie,self.background)
                    if ebm.loadOk():
                        self.epane.add(self.background)
                        self.editorlomanager.media = self.background
                        #self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
                        #self._vport.addChangeListener( self._resizer )
                        self.editor.setOpaque(False)
                        vport = self.view.getViewport()
                        vport.setOpaque(False)
                        self.view.setOpaque(False)
                        self.ebm = ebm
                        #print self.epm
                        ebm.addControllerToMenu(self.menu)
                    else: self.background = None
        finally:
            if not hasattr(self,'background'):
                self.background = None
    else:
        self.background = None
#@-node:ekr.20070930184746.54:configureMedia
#@+node:ekr.20070930184746.55:setBackgroundImage
def setBackgroundImage (self,notification=None,handback=None):

    c = self.c
    alpha = g.app.config.getFloat(c,"background_alpha")
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString(c,"image_location@as-filedialog")
    if image_path:
        imfile = java.io.File(image_path)
        if imfile.exists():
            bimage = imageio.ImageIO.read(imfile)
            if not hasattr(self,'background'):
                self.background = EditorBackground(bimage,bimage.getWidth(),bimage.getHeight(),alpha)
                self.epane.add(self.background)

            #    self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
            #    self._vport.addChangeListener( self._resizer )
            self.editor.setOpaque(False)
            vport = self.view.getViewport()
            vport.setOpaque(False)
            self.view.setOpaque(False)
            #self.epane.setBackedWidget( self.view.getViewport() )
            #self.epane.setImage( bimage )
            #self.epane.setAlpha( alpha )
            self.editorlomanager.media = self.background
            g.app.config.manager.addNotificationDef("background_alpha",self.setBackgroundImage)
            g.app.config.manager.addNotificationDef("image_location@as-filedialog",self.setBackgroundImage)

            #else:
            #    #self.background.setBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #    #self.background.repaint()


#@-node:ekr.20070930184746.55:setBackgroundImage
#@+node:ekr.20070930184746.56:useAutocompleter
def useAutocompleter (self,notification=None,handback=None):

    use = g.app.config.getBool(self.c,"use_autocompleter")
    if use:
        self.autocompleter.on = 1
    else:
        self.autocompleter.on = 0
        self.autocompleter.hideAutoBox()
#@nonl
#@-node:ekr.20070930184746.56:useAutocompleter
#@+node:ekr.20070930184746.57:setCaret
def setCaret (self,notification=None,handback=None):
    c = self.c
    if g.app.config.getString(c,"which_caret"):
        caret = g.app.config.getString(c,"which_caret")
        carets = {'Box': (self.SeeThroughBoxCaret,'box_color'),
                  'Underliner': (self.UnderlinerCaret,'underliner_color'),
                  'GhostlyLeo': (self.GhostlyLeoCaret,None),
                  'ImageCaret': (self.ImageCaret,None),
                  '<none>': (stext.DefaultCaret,None)}

        if caret == 'ImageCaret':
            try:
                path_to_image = g.app.config.getString(c,"path_to_caret_image@as-filedialog")
                ifile = java.io.File(path_to_image)
                cimage = imageio.ImageIO.read(ifile)
                #cicon = swing.ImageIcon( path_to_image )
                self.editor.setCaret(carets[caret](cimage))
            except java.lang.Exception, x:
                x.printStackTrace()
                g.es("Could not load image for caret")
        else:
            caret, color = carets [caret]
            args = None
            if color:
                color = g.app.config.getColor(c,color)
                color = getColorInstance(color)
                args = (color)
                self.editor.setCaret(caret(color))
            else:
                self.editor.setCaret(caret())
    self.editor.getCaret().addChangeListener(self.brackethighlighter)
#@-node:ekr.20070930184746.57:setCaret
#@+node:ekr.20070930184746.58:setFont
def setFont (self,notification=None,handback=None):

    config = g.app.config
    c = self.c
    family = config.get(c,"body_text_font_family","family")
    size = config.get(c,"body_text_font_size","size")
    weight = config.get(c,"body_text_font_weight","weight")
    slant = None
    font = config.getFontFromParams(c,"body_text_font_family","body_text_font_size",None,"body_text_font_weight")
    if font:
        self.editor.setFont(font)
#@nonl
#@-node:ekr.20070930184746.58:setFont
#@+node:ekr.20070930184746.59:setEditorColors
def setEditorColors (self,notification=None,handback=None):

    c = self.c

    fg = g.app.config.getColor(c,'body_text_foreground_color')
    bg = g.app.config.getColor(c,'body_text_background_color')
    sc = g.app.config.getColor(c,'body_selection_color')
    stc = g.app.config.getColor(c,'body_text_selected_color')

    fg = getColorInstance(fg,awt.Color.GRAY)
    bg = getColorInstance(bg,awt.Color.WHITE)
    sc = getColorInstance(sc,awt.Color.GREEN)
    stc = getColorInstance(stc,awt.Color.WHITE)

    self.editor.setForeground(fg)
    self.editor.setBackground(bg)
    self.editor.setSelectionColor(sc)
    self.editor.setSelectedTextColor(stc)


#@-node:ekr.20070930184746.59:setEditorColors
#@+node:ekr.20070930184746.60:setLineNumberColors
def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl

def setLineNumberColors (self,notification=None,background=None):

    fg, bg, cl = self.getLineNumberColors()
    if self.numbers:
        self.numbers.setBackground(bg)
        self.numbers.setForeground(fg)
        self.numbers.setCurrent(cl)

#@-node:ekr.20070930184746.60:setLineNumberColors
#@-node:ekr.20070930184746.53:config methods
#@+node:ekr.20070930184746.61:methods
#@+node:ekr.20070930184746.62:sync
def sync (self,pos=None):

    try:
        if pos == None:
            pos = self.c.currentPosition()

        if pos in self.recent:
            self.recent.remove(pos)
        else:
            if len(self.recent) == 10:
                self.recent.pop()
        self.recent.insert(0,pos)

        if self.lastPosition:
            self.foldprotection.cacheFolds(self.lastPosition.v.t)
        self.lastPosition = pos.copy()
        hs = pos.headString()
        bs = pos.bodyString()
        #self.editor.setText( bs )
        doc = self.editor.getDocument()
        doc.setPosition(pos)
        #doc.sync( bs )
        body = self.c.frame.body
        try:
            body.ignore_insert = 1
            self.jlc.ignoreEvents()
            self.foldprotection.clearFolds()
            self.foldprotection.defoldViews()
            doc.remove(0,doc.getLength())
            doc.insertString(0,bs,None)
            self.frame.setTitle(hs)
            self.jlc.recolorizenow()
            self.foldprotection.restoreFolds(pos.v.t)
            if hasattr(self,'_node_undoer'):
                self._node_undoer.setNode(pos)
        finally:
            self.jlc.watchEvents()
            body.ignore_insert = 0
    except Exception, x:
        pass
        #x.printStackTrace()

#@-node:ekr.20070930184746.62:sync
#@+node:ekr.20070930184746.63:nowShowing
def nowShowing (self):

    self.body._current_editor = self.editor
    self.sync()
#@-node:ekr.20070930184746.63:nowShowing
#@+node:ekr.20070930184746.64:menu methods
@others
#@nonl
#@+node:ekr.20070930184746.65:configureGotoMenu
def configureGotoMenu (self,menu):
    oltraveler = leoSwingBody.Editor.outlinetraveler(menu,self.c)
    menu.addMenuListener(oltraveler)
#@nonl
#@-node:ekr.20070930184746.65:configureGotoMenu
#@+node:ekr.20070930184746.66:directiveMenu
def directiveMenu (self,menu):

    import leoColor
    directives = []
    for z in leoColor.leoKeywords:
        directives.append(z)
    directives.sort()
    InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
    for z in directives:
        menu.add(InsertTextIntoBody(self.c,z))

#@-node:ekr.20070930184746.66:directiveMenu
#@+node:ekr.20070930184746.67:headlineMenu
def headlineMenu (self,menu):

    import leoNodes
    tnode = leoNodes.tnode()
    v = leoNodes.vnode(self.c,tnode)
    def getValue (names,self=v):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list(names)
    names.sort()
    SetHeadline = leoSwingBody.Editor.SetHeadline
    self.addSR(menu)
    for z in names:
        menu.add(SetHeadline(self.c,z))

    rmvSymbol = leoSwingBody.Editor.rmvSymbol
    rS = rmvSymbol(self.c,'@')
    menu.add(rS)
    SetHeadlineToSelection = leoSwingBody.Editor.SetHeadlineToSelection
    sTaction = SetHeadlineToSelection(self.c,"Set Headline to Selection")
    menu.add(sTaction)

#@-node:ekr.20070930184746.67:headlineMenu
#@+node:ekr.20070930184746.68:insertSR
def insertSR (self,menu):

    inSRMenuListener = leoSwingBody.Editor.inSRMenuListener
    menu.addMenuListener(inSRMenuListener(menu,self.c))
#@nonl
#@-node:ekr.20070930184746.68:insertSR
#@+node:ekr.20070930184746.69:addSR
def addSR (self,menu):

    class aa(swing.AbstractAction):

        def __init__ (self,c):
            swing.AbstractAction.__init__(self,'toggle <%s%s>' % ('<','>'))
            self.c = c

        def actionPerformed (self,event):
            cp = self.c.currentPosition()
            hs = cp.headString()
            hs = hs.strip()
            if hs.startswith('<%s' % '<') and hs.endswith('>%s' % '>'):
                hs = hs [2:]
                hs = hs [: -2]
            else:
                hs = '<%s%s%s>' % ('<',hs,'>')

            self.c.beginUpdate()
            cp.setHeadString(hs)
            self.c.endUpdate()

    menu.add(aa(self.c))
#@nonl
#@-node:ekr.20070930184746.69:addSR
#@+node:ekr.20070930184746.70:addLanguageMenu
def addLanguageMenu (self,pmenu):
    pass
@
    lmenu = swing.JMenu("language")
    kI = self.keywordInserter(lmenu,self.c)
    lmenu.addMenuListener(kI)
    pmenu.add(lmenu)
    lS = self.languageSetter(kI)
    pmenu.addMenuListener(lS)

#@-node:ekr.20070930184746.70:addLanguageMenu
#@+node:ekr.20070930184746.71:addInsertPath
def addInsertPath (self,menu):

    def __insertHeadline (event):

        jfc = swing.JFileChooser()
        jfc.setFileSelectionMode(jfc.DIRECTORIES_ONLY)
        jfc.setDialogTitle("Select Directory for %s%s" % ("@","path"))
        jfc.setApproveButtonText("Select")
        result = jfc.showOpenDialog(self.c.frame.top)
        if result == jfc.APPROVE_OPTION:
            sfile = jfc.getSelectedFile()
            self.c.frame.body.insertAtInsertPoint("%s %s" % ("@path",sfile.getAbsolutePath()))


    menu.actionPerformed = __insertHeadline


#@-node:ekr.20070930184746.71:addInsertPath
#@+node:ekr.20070930184746.72:addCompositeView
def addCompositeView (self,event):

    if not hasattr(self,'lcv'):
        import leoCompositeView
        jpanel = swing.JPanel(awt.BorderLayout())
        #self.jtab.addTab( "CompositeView", jpanel )
        #self.jtab.setSelectedComponent( jpanel )
        self.tab_manager.add("CompositeView",jpanel)
        self.lcv = lcv = leoCompositeView.CompositeView(self.c,jpanel)
        self.visible_informer.addCallback(jpanel,lambda: lcv.sync(force=1))
        self.body._current_editor = self.lcv.jtp
    else:
        parent = self.lcv.parent
        #if self.jtab.indexOfComponent( parent ) == -1:
        if not self.tab_manager.holdsComponent(parent):

            self.tab_manager.add("CompositeView",parent)
            #self.jtab.addTab( "CompositeView", parent )
            #self.jtab.setSelectedComponent( parent )
        else:
            #self.jtab.remove( parent )
            self.tab_manager.remove(parent)
#@-node:ekr.20070930184746.72:addCompositeView
#@+node:ekr.20070930184746.73:addFlashCardView
def addFlashCardView (self,event):

    import leoFlashCardView
    if not hasattr(self,'fcv'):
        jpanel = swing.JPanel(awt.BorderLayout())
        self.jtab.addTab("FlashCardView",jpanel)
        self.jtab.setSelectedComponent(jpanel)
        self.fcv = fcv = leoFlashCardView.FlashCardView(self.c,jpanel)
        self.visible_informer.addCallback(jpanel,lambda: fcv.sync(force=1))
    else:
        parent = self.fcv.parent
        if self.jtab.indexOfComponent(parent) == -1:
            self.jtab.addTab("FlashCardView",parent)
            self.jtab.setSelectedComponent(parent)
        else:
            self.jtab.remove(parent)
#@-node:ekr.20070930184746.73:addFlashCardView
#@+node:ekr.20070930184746.74:addFootNodeMenu
def addFootNodeMenu (self,menu):

    menu.addSeparator()
    addfn = swing.JMenuItem("Add FootNode")
    menu.add(addfn)
    rmvfn = swing.JMenu("Remove FootNode")
    menu.add(rmvfn)
    fnoderemover = self.footnoderemover(rmvfn,self.c)
    rmvfn.addMenuListener(fnoderemover)

    def addFootNode (event,c):

        pos = c.currentPosition()
        t = pos.v.t
        if not hasattr(t,"unknownAttributes"):
            uas = t.unknownAttributes = {}
            fn = []
            uas ["footnodes"] = fn
        else:
            uas = t.unknownAttributes
            if uas.has_key("footnodes"):
                fn = uas ["footnodes"]
            else:
                fn = []
                uas ["footnodes"] = fn

        jd = swing.JDialog()
        jd.title = "Add a FootNode"
        cpane = jd.getContentPane()
        cpane.setLayout(awt.BorderLayout())
        jtf = swing.JTextField()
        tborder1 = sborder.TitledBorder("Title")
        jtf.setBorder(tborder1)
        cpane.add(jtf,awt.BorderLayout.NORTH)
        jta = swing.JTextArea()
        jsp = swing.JScrollPane(jta)
        tborder2 = sborder.TitledBorder("FootNode")
        jsp.setBorder(tborder2)
        cpane.add(jsp)
        jp = swing.JPanel()
        b1 = swing.JButton("Cancel")
        b1.actionPerformed = lambda event, jd = jd: jd.dispose()
        jp.add(b1)
        b2 = swing.JButton("Ok")
        def ok (event,fn,jtf,jta,jd,c=c):
            headline = jtf.getText()
            body = jta.getText()
            fn.append((headline,body))
            c.frame.body.editor.ekit.relayout()
            jd.dispose()
        b2.actionPerformed = lambda event, fn = fn, jtf = jtf, jta = jta, jd = jd, c = c: ok(event,fn,jtf,jta,jd,c)
        jp.add(b2)
        cpane.add(jp,awt.BorderLayout.SOUTH)
        jd.size = (250,250)
        jd.preferredSize = (250,250)
        #jd.pack()
        g.app.gui.center_dialog(jd)
        jd.show()
    addfn.actionPerformed = lambda event, c = self.c: addFootNode(event,c)






#@-node:ekr.20070930184746.74:addFootNodeMenu
#@-node:ekr.20070930184746.64:menu methods
#@+node:ekr.20070930184746.75:implementation of FocusListener interface
def focusGained (self,fe):

    lasteditor = self.body.editor
    self.body.editor = self
    if self.lastPosition:
        if lasteditor != self:
            if self.chapter.isValid():
                cc = self.c.chapters.getChapter()
                if self.chapter != cc:
                    self.c.chapters.selectChapter(self.chapter)

                try:
                    self.c.beginUpdate() #This part if not done right can cause weird tree sync issues
                    lp = self.lastPosition
                    self.lastPosition = None
                    self.c.frame.tree.select(lp)
                finally:
                    self.c.endUpdate()
            else:
                self.sync()

    if hasattr(self,'_node_undoer'):
        self._node_undoer.setMenu()

def focusLost (self,fe):

    self.chapter = self.c.chapters.getChapter()
    if hasattr(self,'_node_undoer'):
        if self.lastPosition:
            self._node_undoer.checkSumNode(self.lastPosition.v.t)
#@-node:ekr.20070930184746.75:implementation of FocusListener interface
#@+node:ekr.20070930184746.76:detach and retach
def detach (self,event=None):

    self._parent2 = jf = swing.JFrame()
    bounds = self.frame.getBounds()
    self._parent.remove(self.frame)
    jf.getContentPane().add(self.frame)
    jf.setBounds(bounds)
    km = self.editor.getKeymap()
    k_and_a = self.c.frame.menu.keystrokes_and_actions
    for z in k_and_a.keys():
        action = k_and_a [z]
        km.addActionForKeyStroke(z,action)
    self._attached = False
    jf.visible = 1
    self._parent.validate()
    self._parent.repaint()


def retach (self,event=None):

    parent = self._parent2
    self._parent2 = None
    parent.remove(self.frame)
    self._parent.add(self.frame)
    parent.dispose()
    parent.visible = 0
    self._attached = True
    self._parent.validate()
    self._parent.repaint()
    self.frame.validate()
    self.frame.repaint()



#@-node:ekr.20070930184746.76:detach and retach
#@+node:ekr.20070930184746.77:turnSelectionIntoNode
def turnSelectionIntoNode (self):

    editor = self.editor
    txt = editor.getSelectedText()
    if txt == None: return
    spot = txt.find('\n')
    headline = txt [: spot]
    editor.replaceSelection("")
    c = self.c
    c.beginUpdate()
    cp = c.currentPosition()
    np = cp.insertAsLastChild()
    np.setHeadString(headline)
    np.setBodyStringOrPane(txt)
    c.endUpdate()
#@nonl
#@-node:ekr.20070930184746.77:turnSelectionIntoNode
#@+node:ekr.20070930184746.78:insertTextIntoBody
def insertTextIntoBody (self,txt):

    cpos = self.editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart(self.editor,cpos)
    doc = self.editor.getStyledDocument()
    txt2 = doc.getText(start,cpos-start)
    start_text = []
    for z in txt2:
        if z.isspace():
            start_text.append(z)
        else:
            start_text.append(' ')

    indent = ''.join(start_text)

    lines = txt.split('\n')
    if len(lines) > 1:
        for z in xrange(len(lines)-1):
            line = lines [z + 1]
            nwline = "%s%s" % (indent,line)
            lines [z + 1] = nwline
    itext = '\n'.join(lines)
    doc.insertString(cpos,itext,None)





#@-node:ekr.20070930184746.78:insertTextIntoBody
#@+node:ekr.20070930184746.79:splitNode
def splitNode (self):

    c = self.c
    editor = self.editor
    cpos = editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart(editor,cpos)
    doc = editor.getDocument()
    nn_txt = doc.getText(start,doc.getLength()-start)
    doc.remove(start,doc.getLength()-start)
    c.beginUpdate()
    cp = c.currentPosition()
    nn = cp.insertAfter()
    nn.setBodyStringOrPane(nn_txt)
    c.selectPosition(nn)
    c.endUpdate()

    dc = DefCallable(lambda: c.frame.tree.editLabel(nn))
    ft = java.util.concurrent.FutureTask(dc)
    java.awt.EventQueue.invokeLater(ft)
#@-node:ekr.20070930184746.79:splitNode
#@+node:ekr.20070930184746.80:sectionReferenceToWidget
def sectionReferenceToWidget (self):

    c = self.c
    cp = c.currentPosition()
    bs = cp.bodyString()
    pattern = java.util.regex.Pattern.compile("<"+"<"+"[^<>]*>"+">")

    children = {}
    for z in cp.children_iter(copy=True):
        children [z.headString()] = z


    matcher = pattern.matcher(java.lang.String(bs))
    results = []
    while matcher.find():
        result = matcher.toMatchResult()
        results.append(result)

    doc = self.editor.getDocument()
    for z in results:
        begin = z.start()
        end = z.end()
        sr = bs [begin: end]
@
        if sr in children:
            jtp = swing.JTextArea()
            child = children [sr]
            jtp.setText(child.bodyString())
            jb = swing.JButton("Mooo")
            mas = swing.text.SimpleAttributeSet()
            swing.text.StyleConstants.setComponent(mas,jb)
            swing.text.StyleConstants.setForeground(mas,java.awt.Color.RED)
            doc.setCharacterAttributes(begin,end-begin,mas,1)
            doc.insertString(0,"\n",mas)
@c




#@-node:ekr.20070930184746.80:sectionReferenceToWidget
#@+node:ekr.20070930184746.81:chapterChanged
def chapterChanged (self,tag,*args,**kwords):

    try:
        chapter = args [0] ['chapter']
        if tag == "chapter-changed":
            if self.c.frame.body.editor is self:
                cp = chapter.getCurrentPosition() ; rp = chapter.getRootPosition()
                if cp or rp:
                    self.sync()
        elif tag == "chapter-removed":
            if self.c.frame.body.editor is self:
                self.sync()
    except java.lang.Exception, x:
        pass
#@-node:ekr.20070930184746.81:chapterChanged
#@+node:ekr.20070930184746.82:headlineChanged
def headlineChanged (self,tag,*args,**kwords):

    p = args [0] ['p']
    if self.lastPosition == p:
        self.frame.setTitle(p.headString())

#@-node:ekr.20070930184746.82:headlineChanged
#@+node:ekr.20070930184746.83:splitting the editor
@others
#@+node:ekr.20070930184746.84:splitVertically
def splitVertically (self,event):

    widget = self.editor
    parent = widget.getParent()

#@-node:ekr.20070930184746.84:splitVertically
#@+node:ekr.20070930184746.85:createEditor
def createEditor (self):

    editor = self.leoJTextPane(self.c)
    editor.setLineColor()
    manager = g.app.config.manager
    manager.addNotificationDef("highlight_current_line",editor.setLineColor)
    manager.addNotificationDef("current_line_highlight_color",editor.setLineColor)
    cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider(self.c)

    use_line_numbers = g.app.config.getBool(c,"use_line_numbering")
    if use_line_numbers:
        #self.initializeLineNumbering()
        fg, bg, cl = self.getLineNumberColors()
        numbers = leoEditorKit.LeoNumberLabel(bg,fg,cl)
        #manager = g.app.config.manager
        #manager.addNotificationDef( "line_number_background", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_foreground", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_current", self.setLineNumberColors )
    else:
        numbers = None

    ekit = leoEditorKit(cdeterminer,numbers)
    editor.setEditorKit(ekit)
    cdeterminer.setEditor(editor)
    editor.getDocument().addUndoableEditListener(self.body)
    editor.addMouseListener(leoSwingBody.UtilityRightClick(c,detach_retach=True,editor=self))

    return editor
#@nonl
#@-node:ekr.20070930184746.85:createEditor
#@-node:ekr.20070930184746.83:splitting the editor
#@-node:ekr.20070930184746.61:methods
#@+node:ekr.20070930184746.86:helper classes
@
In general these are subclasses of java gui listeners.

In CPython and Tk you would be using callbacks most of the time, a def or a lambda.
#@+node:ekr.20070930184746.36:RecentVisitsMenuListener
class RecentVisitsMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c,recent):
        self.menu = menu
        self.c = c
        self.recent = recent

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        goNode = leoSwingBody.Editor.goNode
        for z in self.recent:
            if z:
                menu.add(goNode(z,self.c))
#@-node:ekr.20070930184746.36:RecentVisitsMenuListener
#@+node:ekr.20070930184746.34:colorizer callback
class ColorKeywordsProvider(leoEditorKit2.ColorDeterminer,sevent.DocumentListener):

    @others
#@+node:ekr.20071001071356:__init__
def __init__ (self,c):

    lb = leoLanguageManager.LanguageManager.getLanguageBundle(c)
    for z in dir(lb):
        if not callable(getattr(lb,z)):
            setattr(self,z,getattr(lb,z))

    self.c = c
    self.last_p = None
    self.last_language = None
    self.editor = None
    self.error_map = util.HashMap()
    fg, bg, cl = self.getLineNumberColors()
    self.line_fg = fg ; self.line_bg = bg ; self.line_cl = cl
    self.queue = concurrent.LinkedBlockingQueue()
    self.c.invisibleWatchers.append(self)
    return


#@-node:ekr.20071001071356:__init__
#@+node:ekr.20071001071356.1:changedUpdate
def changedUpdate (self,event):
    pass #this does Attribute changes


#@-node:ekr.20071001071356.1:changedUpdate
#@+node:ekr.20071001071356.2:checkForLanguageChange
def checkForLanguageChange (self,event):

    language = LeoUtilities.scanForLanguageOnLine(self.editor)
    if language:
        #if not hasattr( self, "%s_keywords" % language ):
        if self.last_language != language:
            #self.editor.repaint()
            self.last_language = language
            jlc = self.c.frame.body.editor.jlc
            jlc.fullrecolorize()



#@-node:ekr.20071001071356.2:checkForLanguageChange
#@+node:ekr.20071001071356.3:drawrectangle
def drawrectangle (self):
    return self._drawrectangle

#@-node:ekr.20071001071356.3:drawrectangle
#@+node:ekr.20071001071356.4:getColoredTokens
def getColoredTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language

    leoLanguageManager.LanguageManager.setLanguageInEffect(self.c,language)

    if language == None:
        language = "python"
    if hasattr(self,"%s_keywords" % language):
        return getattr(self,"%s_keywords" % language)
    else:
        hm = leoLanguageManager.LanguageManager.loadLanguage(self.c,language)
        setattr(self,"%s_keywords" % language,hm)
        return hm


#@-node:ekr.20071001071356.4:getColoredTokens
#@+node:ekr.20071001071356.5:getCommentColor
def getCommentColor (self):
    return self._commentColor

#@-node:ekr.20071001071356.5:getCommentColor
#@+node:ekr.20071001071356.6:getCommentTokens
def getCommentTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language
    if self.comment_cache.has_key(language):
        return self.comment_cache [language]
    else:
        rv = g.set_delims_from_language(language)
        rv = jarray.array(rv,java.lang.String)
        self.comment_cache [language] = rv
        return rv
    #delim1,delim2, delim3 = g.set_delims_from_language( language )
    #return [ delim1, delim2, delim3 ]

#@-node:ekr.20071001071356.6:getCommentTokens
#@+node:ekr.20071001071356.7:getCurrentLineNumberForeground
def getCurrentLineNumberForeground (self):
    return self.line_cl

#@-node:ekr.20071001071356.7:getCurrentLineNumberForeground
#@+node:ekr.20071001071356.8:getDocColor
def getDocColor (self):
    return self._docColor

#@-node:ekr.20071001071356.8:getDocColor
#@+node:ekr.20071001071356.9:getFoldedBackgroundColor
def getFoldedBackgroundColor (self):
    return self._fbColor

#@-node:ekr.20071001071356.9:getFoldedBackgroundColor
#@+node:ekr.20071001071356.10:getFoldedForegroundColor
def getFoldedForegroundColor (self):
    return self._ffColor



#@-node:ekr.20071001071356.10:getFoldedForegroundColor
#@+node:ekr.20071001071356.11:getFootNodeBackgroundColor
def getFootNodeBackgroundColor (self):
    return self._fnbgColor

#@-node:ekr.20071001071356.11:getFootNodeBackgroundColor
#@+node:ekr.20071001071356.12:getFootNodeForegroundColor
def getFootNodeForegroundColor (self):
    return self._fnfgColor


#@-node:ekr.20071001071356.12:getFootNodeForegroundColor
#@+node:ekr.20071001071356.13:getFootNodes
def getFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            sb = java.lang.StringBuilder()
            for z in fn:
                sb.append(z[0]).append(" : ").append(z[1])
                if not z [1].endswith("\n"): sb.append("\n")
            return sb.toString()
    return ""


#@-node:ekr.20071001071356.13:getFootNodes
#@+node:ekr.20071001071356.14:getInvisiblesBlock
def getInvisiblesBlock (self):
    return self._invisibleBlock

#@-node:ekr.20071001071356.14:getInvisiblesBlock
#@+node:ekr.20071001071356.15:getInvisiblesDot
def getInvisiblesDot (self):
    return self._invisibleDot

#@-node:ekr.20071001071356.15:getInvisiblesDot
#@+node:ekr.20071001071356.16:getLineNumberBackground
def getLineNumberBackground (self):
    return self.line_bg

#public boolean useLineNumbers();
#public Color getLineNumberForeground();
#public Color getCurrentLineNumberForeground();
#public Color getLineNumberBackground();
#@-node:ekr.20071001071356.16:getLineNumberBackground
#@+node:ekr.20070930184746.35:getLineNumberColors
def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl



#@-node:ekr.20070930184746.35:getLineNumberColors
#@+node:ekr.20071001071356.17:getLineNumberForeground
def getLineNumberForeground (self):
    return self.line_fg

#@-node:ekr.20071001071356.17:getLineNumberForeground
#@+node:ekr.20071001071356.18:getNumericColor
def getNumericColor (self):
    return self._numericcolor

#@-node:ekr.20071001071356.18:getNumericColor
#@+node:ekr.20071001071356.19:getOperators
def getOperators (self):
    return util.HashMap()


#@-node:ekr.20071001071356.19:getOperators
#@+node:ekr.20071001071356.20:getPunctuationColor
def getPunctuationColor (self):
    return self._punctuationColor

#@-node:ekr.20071001071356.20:getPunctuationColor
#@+node:ekr.20071001071356.21:getRectangleColor
def getRectangleColor (self):
    return self._rectanglecolor

#@-node:ekr.20071001071356.21:getRectangleColor
#@+node:ekr.20071001071356.22:getSectionReferenceColor
def getSectionReferenceColor (self):
    return self._sectionNameColor

#@-node:ekr.20071001071356.22:getSectionReferenceColor
#@+node:ekr.20071001071356.23:getStringColor
def getStringColor (self):
    return self._stringColor

#@-node:ekr.20071001071356.23:getStringColor
#@+node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
def getUndefinedSectionReferenceColor (self):
    return self._undefinedSectionNameColor

#@-node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
#@+node:ekr.20071001071356.25:hasFootNodes
def hasFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            if fn: return True
    return False

#@-node:ekr.20071001071356.25:hasFootNodes
#@+node:ekr.20071001071356.26:insertUpdate
def insertUpdate (self,event):
    self.checkForLanguageChange(event)

#@-node:ekr.20071001071356.26:insertUpdate
#@+node:ekr.20071001071356.27:notify
def notify (self):
    self.c.frame.body.editor.ekit.showInvisibles(self.c.showInvisibles)

#@-node:ekr.20071001071356.27:notify
#@+node:ekr.20071001071356.28:removeUpdate
def removeUpdate (self,event):
    self.checkForLanguageChange(event)


#@-node:ekr.20071001071356.28:removeUpdate
#@+node:ekr.20071001071356.29:setEditor
def setEditor (self,editor):
    self.editor = editor
    doc = editor.getDocument()
    doc.addDocumentListener(self)


#@-node:ekr.20071001071356.29:setEditor
#@+node:ekr.20071001071356.30:showInvisibles
def showInvisibles (self):
    return self.c.showInvisibles

#@-node:ekr.20071001071356.30:showInvisibles
#@+node:ekr.20071001071356.31:underline
def underline (self):
    return self._underline

#@-node:ekr.20071001071356.31:underline
#@+node:ekr.20071001071356.32:useLineNumbers
def useLineNumbers (self):
    return g.app.config.getBool(self.c,"use_line_numbering")

#@-node:ekr.20071001071356.32:useLineNumbers
#@+node:ekr.20071001071356.33:whichInvisible
def whichInvisible (self):
    return self._which_invisible

#@-node:ekr.20071001071356.33:whichInvisible
#@-node:ekr.20070930184746.34:colorizer callback
#@+node:ekr.20070930184746.33:class insTx
class InsertTextIntoBody(swing.AbstractAction):

    def __init__ (self,c,txt):
        swing.AbstractAction.__init__(self,txt)
        self.txt = txt
        self.c = c

    def actionPerformed (self,event):

        editor = self.c.frame.body.editor.editor
        pos = editor.getCaretPosition()
        #editor.insert( self.txt, pos )
        doc = editor.getDocument()
        doc.insertString(pos,self.txt,None)



class SetHeadline(InsertTextIntoBody):

    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        newHeadString = "%s %s" % (self.txt,hS)
        cp.setHeadString(newHeadString)


class SetHeadlineToSelection(InsertTextIntoBody):
    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        txt = self.c.frame.body.editor.editor.getSelectedText()
        if txt:
            cp = self.c.currentPosition()
            cp.setHeadString(txt)



class rmvSymbol(swing.AbstractAction):
    def __init__ (self,c,symbol):
        swing.AbstractAction.__init__(self,"remove %s" % symbol)
        self.c = c
        self.symbol = symbol

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        if hS.startswith(self.symbol):
            hS = hS.split()
            hS = hS [1:]
            hS = " ".join(hS)
            cp.setHeadString(hS)



class inSRMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        cp = self.c.currentPosition()
        InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
        for z in cp.children_iter():
            hS = z.headString()
            hS = hS.strip()
            if hS.startswith("<%s" % '<') and hS.endswith(">%s" % ">"):
                menu.add(InsertTextIntoBody(self.c,hS))

#@-node:ekr.20070930184746.33:class insTx
#@+node:ekr.20070930184746.87:resizer --keeps components sized right
@
class resizer(aevent.ComponentAdapter,sevent.ChangeListener):
    '''This class keeps the Editor size in sync with the JLayeredPane.
       It also sets where the line numbers go and where, if present,
       a background image goes.'''
    def __init__ (self,editor,side='Left'):
        self.editor = editor
        self.viewPort = self.editor.view.getViewport()
        self.vsbar = self.editor.view.getVerticalScrollBar()
        self.side = side
    def componentResized (self,event):
        source = event.getSource()
        size = source.getSize()
        editor = self.editor.editor
        esize = editor.getSize()
        editor = self.editor.editor
        visRect = self.viewPort.getViewRect() #was once getVisibleRect, bad choice...
        if self.editor.numbers:
            numbers = self.editor.numbers
            lnsize = numbers.getSize()
            if lnsize.width == 0: lnsize.width = 30
            nswidth = size.width- lnsize.width
            nvwidth = visRect.width- lnsize.width
            if esize.height != size.height or esize.width not in (nvwidth,nswidth):
                if visRect.width > 0:
                    size.width = nvwidth
                else:
                    size.width = nswidth
                editor.setSize(size)
                if self.side == 'Left':
                    editor.setLocation(lnsize.width,0)
                else:
                    editor.setLocation(0,0)
                    numbers.setLocation(size.width,0)
            numsize = numbers.getSize()
            nlocation = numbers.getLocation()
            esize = editor.getSize()
            edheight = esize.height
            edwidth = esize.width
            lnsize.height = edheight
            if numsize.height < lnsize.height:
                numbers.setSize(lnsize)
                if self.side == 'Left':
                    numbers.setLocation(0,0)
                else:
                    numbers.setLocation(edwidth,0)
        else:
            self.editor.editor.setSize(size)
            self.editor.editor.setLocation(0,0)
        if self.editor.background:
            self.stateChanged(None)


    def stateChanged (self,event):
        editor = self.editor.editor
        background = self.editor.background
        #visRect = editor.getVisibleRect()
        visRect = self.viewPort.getViewRect()
        x = editor.getX()
        minus = x
        if x == 0 and self.editor.numbers != None:
            minus = self.editor.numbers.getSize().width
        background.setSize(visRect.width-minus,visRect.height)
        background.setLocation(x,visRect.y)
        self.editor.layeredpane.moveToBack(background)
#@nonl
#@-node:ekr.20070930184746.87:resizer --keeps components sized right
#@+node:ekr.20070930184746.88:resizer2
class resizer2(aevent.ComponentAdapter):

    def __init__ (self,layoutmanager):
        aevent.ComponentAdapter.__init__(self)
        self.layoutmanager = layoutmanager

    def componentResized (self,event):
        self.layoutmanager.layoutMedia()
#@nonl
#@-node:ekr.20070930184746.88:resizer2
#@+node:ekr.20070930184746.89:gonode -- actionPerformed takes user to node
class goNode(swing.AbstractAction):
    def __init__ (self,pos,c):
        swing.AbstractAction.__init__(self,pos.headString())
        self.pos = pos.copy()
        self.c = c

    def actionPerformed (self,event):

        self.c.frame.tree.select(self.pos)
#@nonl
#@-node:ekr.20070930184746.89:gonode -- actionPerformed takes user to node
#@+node:ekr.20070930184746.90:outlinetraveler --allows the user to traverse the tree quickly
class outlinetraveler(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        count = self.menu.getMenuComponentCount()
        for z in xrange(1,count):
            self.menu.remove(1)

        cp = self.c.currentPosition()
        self._addMenu("Parents",self.menu,cp.parents_iter(),cp)
        self._addMenu("Siblings",self.menu,cp.siblings_iter(),cp)
        self._addMenu("Children",self.menu,cp.children_iter(),cp)

    def _addMenu (self,name,menu,iterator,cp):

        goNode = leoSwingBody.Editor.goNode
        gmenu = swing.JMenu(name)
        shouldAdd = True
        for z in iterator:
            if shouldAdd:
                if not cp == z:
                    shouldAdd = False
                    menu.add(gmenu)
            if not cp == z:
                gmenu.add(goNode(z,self.c))
            else:
                gmenu.addSeparator()

#@-node:ekr.20070930184746.90:outlinetraveler --allows the user to traverse the tree quickly
#@+node:ekr.20070930184746.91:footnoderemover
class footnoderemover(sevent.MenuListener):

    def __init__ (self,menu,c):
            self.menu = menu
            self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        self.menu.removeAll()
        #count = self.menu.getMenuComponentCount()
        #for z in xrange( 1 , count ):
        #    self.menu.remove( 1 )

        pos = self.c.currentPosition()
        t = pos.v.t
        if hasattr(t,"unknownAttributes"):
            uas = t.unknownAttributes
            if uas.has_key("footnodes"):
                footnodes = uas ["footnodes"]
                def rmv (item,footnodes=footnodes,c=self.c):
                    footnodes.remove(item)
                    c.frame.body.editor.ekit.relayout()

                for x in xrange(len(footnodes)):
                    fnood = footnodes [x]
                    jmi = swing.JMenuItem(fnood[0])
                    jmi.actionPerformed = lambda event, item = fnood: rmv(item)
                    self.menu.add(jmi)

#@-node:ekr.20070930184746.91:footnoderemover
#@+node:ekr.20070930184746.92:keywordInserter -- allows the user to insert language keywords
@
class keywordInserter(sevent.MenuListener):
    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c
        self.lastlanguage = None
    def setLanguageName (self):
        cp = self.c.currentPosition()
        self.language = language = g.scanForAtLanguage(self.c,cp)
        self.menu.setText(language)
    def menuCanceled (self,event):
        pass
    def menuDeselected (self,event):
        pass
    def menuSelected (self,event):
        #cp = self.c.currentPosition()
        #language = g.scanForAtLanguage( self.c, cp )
        language = self.language
        if language == self.lastlanguage: return
        self.lastlanguage = language
        print dir(leoLanguageManager.LanguageManager)
        if language == None:
            m = leoLanguageManager.LanguageManager.python_tokens
        else:
            m = getattr(leoLanguageManager.LanguageManager,"%s_tokens" % language)

        m.sort()
        self.menu.removeAll()
        for z in m:
            self._addInserter(z)
    def _addInserter (self,name):
        self.menu.add(leoSwingBody.Editor.InsertTextIntoBody(self.c,name))

class languageSetter(sevent.MenuListener):
    def __init__ (self,kWI):
        self._kWI = kWI
    def menuCanceled (self,event):
        pass
    def menuDeselected (self,event):
        pass
    def menuSelected (self,event):
        self._kWI.setLanguageName()
#@-node:ekr.20070930184746.92:keywordInserter -- allows the user to insert language keywords
#@+node:ekr.20070930184746.93:swingmacs help
class smacs_help(swing.AbstractAction):

    class clz(swing.AbstractAction):
        def __init__ (self,tl):
            swing.AbstractAction.__init__(self,"Close")
            self.tl = tl


        def actionPerformed (self,event):
            self.tl.visible = 0
            self.tl.dispose()

    def __init__ (self,c,emacs,which):

        if which == 'Keystrokes':
            swing.AbstractAction.__init__(self,"Emacs Keystrokes")
        else:
            swing.AbstractAction.__init__(self,"Emacs Commands")

        self.emacs = weakref.proxy(emacs)
        self.which = which
        fg = g.app.config.getColor(c,'body_text_foreground_color')
        bg = g.app.config.getColor(c,'body_text_background_color')
        sc = g.app.config.getColor(c,'body_selection_color')
        stc = g.app.config.getColor(c,'body_text_selected_color')

        self.fg = getColorInstance(fg,awt.Color.GRAY)
        self.bg = getColorInstance(bg,awt.Color.WHITE)
        self.sc = getColorInstance(sc,awt.Color.GREEN)
        self.stc = getColorInstance(stc,awt.Color.WHITE)

    def actionPerformed (self,event):

        tl = swing.JFrame(title=self.which)
        ta = swing.JTextArea()
        ta.setForeground(self.fg)
        ta.setBackground(self.bg)
        ta.setSelectionColor(self.sc)
        ta.setSelectedTextColor(self.stc)
        ta.setEditable(False)
        ta.setLineWrap(True)
        sp = swing.JScrollPane(ta)
        tl.getContentPane().add(sp)
        if self.which == 'Keystrokes':
            ta.setText(self.emacs.getHelp())
        else:

            ta.setText(self.emacs.ax.getCommandHelp())
        gui = g.app.gui


        cbutt = swing.JButton(self.clz(tl))
        tl.getContentPane().add(cbutt,awt.BorderLayout.SOUTH)
        tkit = awt.Toolkit.getDefaultToolkit()
        size = tkit.getScreenSize()
        tl.setSize(size.width/2,size.height/2)
        tl.setPreferredSize(tl.getSize())
        x, y = g.app.gui._calculateCenteredPosition(tl)
        tl.setLocation(x,y)
        ta.setCaretPosition(0)
        tl.visible = 1


#@-node:ekr.20070930184746.93:swingmacs help
#@+node:ekr.20070930184746.94:autocompleter help
class autocompleter_help(swing.AbstractAction):

    def __init__ (self):
        swing.AbstractAction.__init__(self,"How to use the Autocompleter")

    def getText (self):

        htext = '''
        The Autcompleter appears upon typing of the '.' character.  Upon
        typing this character an in memory database is searched for the matching prefix.
        For example:
            object.toString  appears in a node.
            Typing 'object.' will bring the autocompleter box up with 'toString' as an option.

            Keystrokes that manipulate the autobox:
            Ctrl - this inserts the currently selected word
            Alt-Up, Alt-Down - these move the selection up and down.
            Esc - desummons the autobox

        The autobox will select the best prefix you have typed so far.  To extend the last example:
        typing 'to' will select 'toString'.  It will not enter the text until the user types 'Ctrl'
        or selects an item with the mouse.'''

        return htext

    def actionPerformed (self,event):
        tl = swing.JFrame(title='Autocompleter Help')
        ta = swing.JTextArea()
        ta.setEditable(False)
        sp = swing.JScrollPane(ta)
        tl.getContentPane().add(sp)
        #ta.setText( self.emacs.getHelp() )
        ta.setText(self.getText())
        gui = g.app.gui
        tl.setSize(600,400)
        spot = gui._calculateCenteredPosition(tl)
        tl.setLocation(spot[0],spot[1])
        class clz(swing.AbstractAction):
            def __init__ (self):
                swing.AbstractAction.__init__(self,"Close")
            def actionPerformed (self,event):
                tl.visible = 0
                tl.dispose()
        cbutt = swing.JButton(clz())
        tl.getContentPane().add(cbutt,awt.BorderLayout.SOUTH)
        tl.visible = 1
#@nonl
#@-node:ekr.20070930184746.94:autocompleter help
#@+node:ekr.20070930184746.95:class FoldProtector
class FoldProtector(stext.DocumentFilter):

    cachedfolds = {}

    def __init__ (self,editor,ekit):
        stext.DocumentFilter.__init__(self)
        self.folds = []
        self.ekit = ekit
        self.editor = editor
        self.doc = editor.getDocument()
        self.editor.addMouseListener(self.Defolder(self))

    def cacheFolds (self,t):
        if self.folds:
            for z in self.folds:
                z.persist(self.doc)
            self.cachedfolds [t] = self.folds

    def defoldViews (self):
        self.ekit.defoldViews()

    def restoreFolds (self,t):
        if self.cachedfolds.has_key(t):
            self.folds = self.cachedfolds [t]
            doc = self.editor.getDocument()
            for x in xrange(len(self.folds)):
                z = self.folds [x]
                if z.restore(doc):
                    self.foldWithoutAdding(z.pos1,z.pos2)
                else:
                    self.folds.remove(z)
                    g.es("Removing Fold(%s,%s), no longer valid" % (z.pos1,z.pos2),color="red")
        else:
            self.folds = []

    def foldSelection (self):

        start = self.editor.getSelectionStart()
        end = self.editor.getSelectionEnd()
        if start == end: return
        if start > end:
            s1 = start
            start = end
            end = s1
        cp = self.editor.getCaretPosition()
        self.editor.setCaretPosition(cp)
        self.editor.moveCaretPosition(cp)
        paragraph1 = stext.Utilities.getParagraphElement(self.editor,start)
        paragraph2 = stext.Utilities.getParagraphElement(self.editor,end)
        self.fold(paragraph1.getStartOffset(),paragraph2.getEndOffset()-1)


    def fold (self,start,end):

        fold = self.addFold(start,end,self.editor)
        self.ekit.fold(fold.pos1,fold.pos2)
        start = fold.pos1.getOffset() ; end = fold.pos2.getOffset()
        for z in copy.copy(self.folds):
            if z == fold: continue
            test1 = z.pos1.getOffset()
            test2 = z.pos2.getOffset()
            if start <= test1 and end > test1:
                self.folds.remove(z) #the folds are now the same


    def foldWithoutAdding (self,pos1,pos2):
        self.ekit.fold(pos1,pos2)

    def areLinesInFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 <= start and end2 >= end: return True
        return False

    def doLinesIntersectFold (self,start,end):

        doc = self.doc
        s = doc.getParagraphElement(start)
        e = doc.getParagraphElement(end)
        for z in self.folds:
            p1 = doc.getParagraphElement(z.pos1.getOffset())
            p2 = doc.getParagraphElement(z.pos2.getOffset())
            while p1 != p2:
                if p1 == e or p1 == s: return True
                p1 = doc.getParagraphElement(p1.getEndOffset())
            else:
                if p1 == e or p1 == s: return True
        return False

    def areLinesSurroundingFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start <= start2 and end >= end2: return True
        return False

    def getFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 <= start and end2 >= end: return z
        return None

    def isFolded (self,x,y):
        return self.ekit.isFolded(x,y)

    def isXInIconArea (self,x):

        i = self.ekit.getFoldIconX()
        if i >= x: return True
        return False

    def removeFold (self,fold):
        self.unfold(fold.pos1,fold.pos2)
        self.folds.remove(fold)

    def unfold (self,pos1,pos2):
        self.ekit.unfold(pos1,pos2)

    def unfoldSpot (self,x,y):

        i = self.editor.viewToModel(awt.Point(x,y))
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if i >= z.pos1.getOffset() and i <= z.pos2.getOffset():
                self.unfold(z.pos1,z.pos2)
                self.folds.remove(z)
                break

    def addFold (self,start,end,editor):

        doc = editor.getDocument()
        pos1 = doc.createPosition(start)
        pos2 = doc.createPosition(end)
        fold = self.Fold(pos1,pos2)
        self.folds.append(fold)
        return fold

    def clearFolds (self):
        self.folds = []


    @others





#@+node:ekr.20070930184746.96:DocumentFilter interface
def insertString (self,fb,offset,data,attr):

    if self.folds:
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if not z.isInsertLegal(offset,fb.getDocument()):
                return

    fb.insertString(offset,data,attr)

def remove (self,fb,offset,length):

    if self.folds:
        for z in self.folds:
            if not z.isRemoveLegal(offset,length,fb.getDocument()):
                return
    fb.remove(offset,length)

def replace (self,fb,offset,length,text,attrs):

    if self.folds:
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if not z.isRemoveLegal(offset,length,fb.getDocument()):
                return
    fb.replace(offset,length,text,attrs)
#@nonl
#@-node:ekr.20070930184746.96:DocumentFilter interface
#@+node:ekr.20070930184746.97:moveSelectionUp
def moveSelectionUp (self):

    start = self.editor.getSelectionStart()
    end = self.editor.getSelectionEnd()
    if (self.areLinesSurroundingFold(start,end) or self.doLinesIntersectFold(start,end)): return
    if start > end:
        s1 = start
        start = end
        end = start
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement(start)
    p2 = doc.getParagraphElement(end)
    above = doc.getParagraphElement(p1.getStartOffset()-1)
    << move partial selection >>

    if (self.areLinesInFold(above.getStartOffset(),above.getEndOffset()-1)):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold(above.getStartOffset(),above.getEndOffset()-1)
        self.removeFold(fold)
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText(start,end-start)
        txt2 = doc.getText(fstart,fend-fstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(fstart,end-fstart)
        nwtxt = "%s\n%s" % (txt,txt2)
        doc.insertString(fstart,nwtxt,None)
        self.fold(fstart+len(txt)+1,end)
        para = doc.getParagraphElement(fstart)
        para2 = doc.getParagraphElement(fstart+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)

    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText(start,end-start)
        sstart = above.getStartOffset()
        txt2 = doc.getText(sstart,above.getEndOffset()-sstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(sstart,end-sstart)
        txt3 = "%s\n%s" % (txt,txt2)
        doc.insertString(sstart,txt3,None)
        para = doc.getParagraphElement(sstart)
        para2 = doc.getParagraphElement(sstart+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)


#@+node:ekr.20070930184746.98:<<move partial selection>>
if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText(start,end-start)
    if not txt.endswith("\n"): txt = txt + "\n"
    self.editor.replaceSelection("")
    pstart = p1.getStartOffset()
    doc.insertString(p1.getStartOffset(),txt,None)
    para = doc.getParagraphElement(pstart)
    para2 = doc.getParagraphElement(pstart+len(txt)-1)
    if cpstart:
        self.editor.setCaretPosition(para2.getEndOffset()-1)
        self.editor.moveCaretPosition(para.getStartOffset())
    else:
        self.editor.setCaretPosition(para.getStartOffset())
        self.editor.moveCaretPosition(para2.getEndOffset()-1)
    return
#@nonl
#@-node:ekr.20070930184746.98:<<move partial selection>>
#@-node:ekr.20070930184746.97:moveSelectionUp
#@+node:ekr.20070930184746.99:moveSelectionDown
def moveSelectionDown (self):

    start = self.editor.getSelectionStart()
    end = self.editor.getSelectionEnd()
    if (self.areLinesSurroundingFold(start,end) or self.doLinesIntersectFold(start,end)): return
    if start > end:
        s1 = start
        start = end
        end = start
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement(start)
    p2 = doc.getParagraphElement(end)
    below = doc.getParagraphElement(p2.getEndOffset())
    << move partial selection >>
    if (self.areLinesInFold(below.getStartOffset(),below.getEndOffset())):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold(below.getStartOffset(),below.getEndOffset())
        self.removeFold(fold)
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText(start,end-start)
        txt2 = doc.getText(fstart,fend-fstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(start,(fold.pos2.getOffset()-start))
        nwtxt = "%s\n%s" % (txt2,txt)
        doc.insertString(start,nwtxt,None)
        self.fold(start,start+len(txt2))
        para = doc.getParagraphElement(start+len(txt2)+1)
        para2 = doc.getParagraphElement(start+len(txt2)+1+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)
    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText(start,end-start)
        sstart = below.getStartOffset()
        txt2 = doc.getText(sstart,below.getEndOffset()-sstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(start,(below.getEndOffset()-start)-1)
        txt3 = "%s\n%s" % (txt2,txt)
        doc.insertString(start,txt3,None)
        para = doc.getParagraphElement(start+len(txt2)+1)
        para2 = doc.getParagraphElement(start+len(txt2)+1+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)
#@nonl
#@+node:ekr.20070930184746.100:<<move partial selection>>
if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText(start,end-start)
    if not txt.endswith("\n"): txt = txt + "\n"
    self.editor.replaceSelection("")
    pend = p2.getEndOffset()
    doc.insertString(p2.getEndOffset(),txt,None)
    para = doc.getParagraphElement(pend+1)
    para2 = doc.getParagraphElement(pend+len(txt)-1)
    if cpstart:
        self.editor.setCaretPosition(para2.getEndOffset()-1)
        self.editor.moveCaretPosition(para.getStartOffset())
    else:
        self.editor.setCaretPosition(para.getStartOffset())
        self.editor.moveCaretPosition(para2.getEndOffset()-1)

    return
#@nonl
#@-node:ekr.20070930184746.100:<<move partial selection>>
#@-node:ekr.20070930184746.99:moveSelectionDown
#@+node:ekr.20070930184746.101:class Fold
class Fold:
    def __init__ (self,pos1,pos2):
        self.pos1 = pos1
        self.pos2 = pos2
        self.text = None

    def persist (self,doc):
        self.pos1 = self.pos1.getOffset()
        self.pos2 = self.pos2.getOffset()
        self.text = doc.getText(self.pos1,self.pos2-self.pos1)

    def restore (self,doc):
        p1, p2 = self.pos1, self.pos2
        if doc.getLength() < p2:
            return False
        self.pos1 = doc.createPosition(self.pos1)
        self.pos2 = doc.createPosition(self.pos2)
        pelement1 = doc.getParagraphElement(p1)
        pelement2 = doc.getParagraphElement(p2)
        if pelement1.getStartOffset() != p1 or pelement2.getEndOffset() -1 != p2:
            return False
        testtext = doc.getText(p1,p2-p1)
        text = self.text ; self.text = None
        return text == testtext

    def isInsertLegal (self,offset,doc):

        e = doc.getParagraphElement(offset)
        p1 = doc.getParagraphElement(self.pos1.getOffset())
        p2 = doc.getParagraphElement(self.pos2.getOffset())
        if p1 == e or p2 == e: return False
        while p1 != p2:
            if p1 == e: return False
            p1 = doc.getParagraphElement(p1.getEndOffset())
        else:
            if p1 == e: return False
        return True

    def isRemoveLegal (self,offset,length,doc):

        p1 = doc.getParagraphElement(self.pos1.getOffset())
        p2 = doc.getParagraphElement(self.pos2.getOffset())
        start = doc.getParagraphElement(offset)
        end = doc.getParagraphElement(offset+length)
        if start == p1 or start == p2: return False
        if end == p1 or end == p2: return False
        while start != end:
            if start == p1 or start == p2: return False
            start = doc.getParagraphElement(start.getEndOffset())
        else:
            if start == p1 or start == p2: return False

        return True
#@-node:ekr.20070930184746.101:class Fold
#@+node:ekr.20070930184746.102:class Defolder
class Defolder(aevent.MouseAdapter):
    def __init__ (self,fp):
        aevent.MouseAdapter.__init__(self)
        self.fp = fp

    def mouseClicked (self,event):

        x = event.getX()
        y = event.getY()
        if event.getButton() == event.BUTTON1:
            if self.fp.isFolded(x,y) and self.fp.isXInIconArea(x):
                self.fp.unfoldSpot(x,y)
#@nonl
#@-node:ekr.20070930184746.102:class Defolder
#@-node:ekr.20070930184746.95:class FoldProtector
#@+node:ekr.20070930184746.103:CommanderCommander
class CommanderCommander:

    def __init__ (self,c,emacs,menu):

        self.c = c
        self.emacs = weakref.proxy(emacs)
        f = c.frame
        self.nodes = {}
        self.mode = 0
        self.tab_completer = None
        self.last_command = None
        self.name = "CommanderCommander"
        self.setupCommands(menu)
        self.addHelp()


    def getAltXCommands (self):
        return self.commands.keys()

    def __call__ (self,event,command):

        if self.mode == 1:
            if command == 'Enter':
                self.gotoNode2(event)
                self.last_command = None
                #self.emacs.keyboardQuit( event )
                return True
            elif command == 'Tab' and self.tab_completer:

                txt = self.emacs.minibuffer.getText()
                if self.last_command == None or not txt.startswith(self.last_command):
                    txt = self.emacs.minibuffer.getText()
                    fnd = self.tab_completer.lookFor(txt)
                    if fnd:
                        self.last_command = txt
                        self.emacs.minibuffer.setText(self.tab_completer.getNext())
                else:
                    self.emacs.minibuffer.setText(self.tab_completer.getNext())
                return True
            else:
                self.emacs.eventToMinibuffer(event)
                return True

        quit = self.commands [command] ()
        if quit == None:
            self.emacs.keyboardQuit(event)
        return True

    def getName (self):
        return self.name

    @others

#@+node:ekr.20070930184746.104:setupCommands
def setupCommands (self,menu):

    c = self.c
    f = c.frame
    self.commands = menu.names_and_commands
    self.commands ["goto node"] = self.gotoNode1



def addHelp (self):

    addhelp = ['Menu Commands:',
                 '-----------------',
    		         'You can execute any Menu command by entering its text',
                 'in the minibuffer.  For example:',
                 'Alt-x',
                 'Open Python Window',
                 '',
                 'will open a Python Window.  See Menus for complete list.',
                 '',
                 '',
                 'Additional Commands:',
                 '---------------------',
                 'These are Leo based commands.',
                 '',
                 'goto node --- will ask the user for which node to goto',
                 'and will take the user to it.'] #we don't do triple strings because it doesn't format right because of Leo output
    addhelp = "\n".join(addhelp)
    self.emacs.addCommandHelp(addhelp)
#@nonl
#@-node:ekr.20070930184746.104:setupCommands
#@+node:ekr.20070930184746.105:gotoNode1
def gotoNode1 (self):

    self.nodes = {}
    cp = self.c.currentPosition()
    for z in cp.allNodes_iter(copy=True):
        hs = z.headString()
        if self.nodes.has_key(hs):
            self.nodes [hs].append(z)
        else:
            self.nodes [hs] = [z,]
    self.tab_completer = self.emacs.TabCompleter(self.nodes.keys())

    self.emacs.setCommandText("Goto Which Node:")
    self.emacs.minibuffer.setText("")
    self.emacs._stateManager.setState(self)
    self.mode = 1
    return True
#@nonl
#@-node:ekr.20070930184746.105:gotoNode1
#@+node:ekr.20070930184746.106:gotoNode2
def gotoNode2 (self,event):

    self.mode = 0
    self.tab_completer = None
    node = self.emacs.minibuffer.getText()
    self.emacs.keyboardQuit(event)
    if self.nodes.has_key(node):
        c = self.c
        c.beginUpdate()
        nlist = self.nodes [node]
        if len(nlist) > 1:
            jf = swing.JDialog()
            jf.setLayout(awt.BorderLayout())
            jf.setModal(True)
            jf.title = "Choose a Node"
            table = swing.JTable()
            table.setSelectionMode(swing.ListSelectionModel.SINGLE_SELECTION)
            table.setAutoResizeMode(table.AUTO_RESIZE_OFF)
            class kl(aevent.KeyAdapter):
                def keyPressed (self,event):
                    if event.getKeyCode() == event.VK_ENTER:
                        jf.dispose()

            table.addKeyListener(kl())
            jsp = swing.JScrollPane(table)
            jf.add(jsp,awt.BorderLayout.CENTER)
            dtm = table.getModel()
            dtm.addColumn("Node")
            dtm.addColumn("Level")
            dtm.addColumn("Parents")
            longest_parents = "Parents"
            for z in nlist:
                row = []
                row.append(z.headString())
                row.append(z.level())
                ps = ""
                p = z.getParent()
                while p:
                    ps = "%s -->%s" % (p.headString(),ps)
                    p = p.getParent()
                row.append(ps)
                if len(ps) > len(longest_parents): longest_parents = ps
                dtm.addRow(row)

            table.setColumnSelectionAllowed(False)
            table.setRowSelectionInterval(0,0)
            cm = table.getColumn("Node")
            fm = table.getFontMetrics(table.getFont())
            w = fm.stringWidth(z.headString())
            cm.setPreferredWidth(w)

            cm = table.getColumn("Level")
            w = fm.stringWidth("Level")
            cm.setPreferredWidth(w)

            cm = table.getColumn("Parents")
            w = fm.stringWidth(longest_parents)
            cm.setPreferredWidth(w)


            height = table.getRowHeight()
            size = jsp.getPreferredSize()
            size.height = height * 6
            jsp.setPreferredSize(size)
            cb = swing.JButton("Select")
            cb.actionPerformed = lambda event: jf.dispose()
            p = swing.JPanel()
            p.add(cb)
            jf.add(p,awt.BorderLayout.SOUTH)
            jf.pack()
            g.app.gui.center_dialog(jf)
            jf.show()
            sr = table.getSelectedRow()
            if sr != -1:
                c.selectPosition(nlist[sr])


        else:
            c.selectPosition(nlist[0])
        c.endUpdate()
    else:
        self.emacs.setCommandText("%s does not exits" % node)
    self.nodes = {}
#@nonl
#@-node:ekr.20070930184746.106:gotoNode2
#@-node:ekr.20070930184746.103:CommanderCommander
#@+node:ekr.20070930184746.107:BracketHighlighter
class BracketHighlighter(sevent.ChangeListener,sevent.DocumentListener):

    @others



#@+node:ekr.20070930184746.108:__init__
def __init__ (self,editor,c): #, color ):

    self._jtc = editor
    self.c = c
    self._jtc.getDocument().addDocumentListener(self)
    self.highlight_painter = None #stext.DefaultHighlighter.DefaultHighlightPainter( color )
    self.highlighting = False
    self.tag = None
    self.iFind = False
    self.matchers = {'{': ('{','}'),
                          '}': ('{','}'),
                          '(': ('(',')'),
                          ')': ('(',')'),
                          '[': ('[',']'),
                          ']': ('[',']'),
                          '<': ('<','>'),
                          '>': ('<','>'),
                          }

    self._nomatch = (None,None)
    self.match_bracket = 0
    self.setBracketMatch()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setBracketMatch")
    manager.addNotificationDef("highlight_brackets",wm1)
    manager.addNotificationDef("highlight_brackets_color",wm1)


#@-node:ekr.20070930184746.108:__init__
#@+node:ekr.20070930184746.109:DocumentListener interface
def changedUpdate (self,event):
    pass

def insertUpdate (self,event):

    doc = event.getDocument()
    len = event.getLength()
    where = event.getOffset()
    self.findBracket(where,doc,doc.getLength())
    self.iFind = True

def removeUpdate (self,event):
    pass
#@nonl
#@-node:ekr.20070930184746.109:DocumentListener interface
#@+node:ekr.20070930184746.110:ChangeListener interface
def stateChanged (self,event):

    jtc = self._jtc
    dot = jtc.getCaretPosition()
    doc = jtc.getDocument()
    dlen = doc.getLength()
    self.findBracket(dot,doc,dlen)
#@nonl
#@-node:ekr.20070930184746.110:ChangeListener interface
#@+node:ekr.20070930184746.111:findBracket
def findBracket (self,dot,doc,dlen):

    if not self.match_bracket: return
    jtc = self._jtc
    highlighter = jtc.getHighlighter()
    if self.iFind:
        self.iFind = False
        return
    if self.highlighting:
        highlighter.removeHighlight(self.tag)
        self.highlighting = False

    if dot >= dlen:
        return
    else:
        c = doc.getText(dot,1)
        first, last = self.matchers.get(c,self._nomatch)
        if not first: return
        if c == first:
            txt = jtc.getText()
            i = self.forwardFind(txt[dot:],first,last) #we must include the first bracket for the find functions
            if i != -1:
                self.tag = highlighter.addHighlight(dot+i,dot+i+1,self.highlight_painter)
                self.highlighting = True
        elif c == last:

            txt = jtc.getText(0,dot+1) #we must include the first bracket for the find functions
            i = self.backwardFind(txt,first,last)
            if i != -1:
                self.tag = highlighter.addHighlight(i,i+1,self.highlight_painter)
                self.highlighting = True
#@-node:ekr.20070930184746.111:findBracket
#@+node:ekr.20070930184746.112:forwardFind
def forwardFind (self,txt,first,last):

    fbc = 0
    for z in xrange(len(txt)):
        c = txt [z]
        if c == first:
            fbc += 1
            continue
        elif c == last:
            if fbc:
                fbc -= 1
            if not fbc:
                return z

    return-1
#@nonl
#@-node:ekr.20070930184746.112:forwardFind
#@+node:ekr.20070930184746.113:backwardFind
def backwardFind (self,txt,first,last):

    fbc = 0
    tlen = len(txt)
    tnum = tlen-1
    for z in xrange(tlen):
        c = txt [tnum]
        if c == last:
            fbc += 1
        elif c == first:
            if fbc:
                fbc -= 1
            if not fbc:
                return tnum
        tnum -= 1
    return-1
#@nonl
#@-node:ekr.20070930184746.113:backwardFind
#@+node:ekr.20070930184746.114:setBracketMatch
def setBracketMatch (self,notification=None,handback=None):

    c = self.c
    if g.app.config.getBool(c,"highlight_brackets"):
        col = g.app.config.getColor(c,"highlight_brackets_color")
        color = getColorInstance(col,awt.Color.GREEN)
        self.highlight_painter = stext.DefaultHighlighter.DefaultHighlightPainter(color)
        self.match_bracket = 1
    else:
        self.match_bracket = 0
#@-node:ekr.20070930184746.114:setBracketMatch
#@-node:ekr.20070930184746.107:BracketHighlighter
#@-node:ekr.20070930184746.86:helper classes
#@+node:ekr.20070930184746.115:component classes
#@+node:ekr.20070930184746.116:autolistener --does autocompleter work
class autolistener(sevent.DocumentListener,aevent.KeyAdapter):

    watchwords = {}

    def __init__ (self,editor):
        self.watchwords = leoSwingBody.Editor.autolistener.watchwords
        self.watchitems = ('.',')')
        self.txt_template = '%s%s%s'
        okchars = {}
        for z in string.ascii_letters:
            okchars [z] = z
        okchars ['_'] = '_'
        self.okchars = okchars
        self.editor = editor
        self.jeditor = editor.editor
        self.popup = None
        #self.layeredpane = editor.layeredpane
        self.haveseen = {}
        #self.autobox = None
        self.constructAutobox()
        self.on = 0
        wm1 = WeakMethod(self,"initialScan")
        leoPlugins.registerHandler(('start2','open2'),wm1)


    @others

#@+node:ekr.20070930184746.117:helper classes
#@+node:ekr.20070930184746.118:hider and boxListener
class inserter(aevent.MouseAdapter):

    def __init__ (self,autolistener):
        self.autolistener = autolistener

    def mouseReleased (self,event):
        self.autolistener.insertFromAutoBox()


class hider(aevent.MouseWheelListener):

    def __init__ (self,autolistener):
        self.autolistener = autolistener

    def mouseWheelMoved (self,event):
        if self.autolistener.autobase.isShowing():
            self.autolistener.hideAutoBox()


#@-node:ekr.20070930184746.118:hider and boxListener
#@-node:ekr.20070930184746.117:helper classes
#@+node:ekr.20070930184746.119:constructAutobox
def constructAutobox (self):

    #import AutoPanel
    jp = swing.JPanel()
    #jp = AutoPanel()
    gbl = awt.GridBagLayout()
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    jp.setLayout(gbl)
    jlist = swing.JList(swing.DefaultListModel())
    jlist.setName("Autolist")
    jlist.setFont(self.editor.editor.getFont())
    self.jsp = jsp = swing.JScrollPane(jlist)
    gbl.setConstraints(jsp,gbc)
    jp.add(jsp)
    self.autobox = jlist
    self.autobase = jp
    self.autobox.addMouseListener(self.inserter(self))
    self.jeditor.addMouseWheelListener(self.hider(self))

#@-node:ekr.20070930184746.119:constructAutobox
#@+node:ekr.20070930184746.120:processKeyStroke/keyPressed
def keyPressed (self,event): #aka key process keyStroke
    '''c in this def is not a commander but a Tk Canvas.  This def determine what action to take dependent upon
       the state of the canvas and what information is in the Event'''
    #if not c.on:return None #nothing on, might as well return

    if not self.on: return
    if not self.autobase.isShowing(): return #isVisible just determines if the thing should be visible, not if it is.  isShowing does.


    modifiers = event.getModifiers()
    mtxt = event.getKeyModifiersText(modifiers)
    ktxt = event.getKeyText(event.getKeyCode())
    keysym = '%s %s' % (mtxt,ktxt)
    keysym = keysym.strip()
    if keysym == "shift":
        return

    elif keysym == "Backspace":
        pos = self.jeditor.getCaretPosition()
        doc = self.jeditor.getDocument()
        if pos != 0:
            c = doc.getText(pos-1,1)
            if c == '.':
                return self.hideAutoBox()


    elif self.testForUnbind(keysym): #all of the commented out code is being tested in the new testForUnbind def or moved above.
        #unbind( context )
        self.hideAutoBox()
        return None
    #elif event.keysym in("Shift_L","Shift_R"):
    #    #so the user can use capital letters.
    #    return None 
    #elif not c.which and event.char in ripout:
    #    unbind( c )
    #elif context.which==1:
    #    #no need to add text if its calltip time.
    #    return None 
    #ind = body.index('insert-1c wordstart')
    #pat = body.get(ind,'insert')+event.char 
    #pat = pat.lstrip('.')
    doc = self.jeditor.getDocument()
    pos = self.jeditor.getCaretPosition()
    try:
        txt = doc.getText(0,pos)
    except:
        return
    txt_lines = txt.splitlines()

    if len(txt_lines) > 1:
        txt_line = txt_lines [ -1]
    else:
        txt_line = txt_lines [0]
    pat = txt_line.split('.')
    if len(pat) > 1:
        pat = pat [ -1]
    else:
        pat = pat [0]

    #print keysym
    if keysym == 'Ctrl Ctrl':
       return self.processAutoBox(event,pat)

    if keysym in ("Alt Up","Alt Down"):
        event.consume()
        return self.moveUpDown(keysym)

    kchar = event.getKeyChar()
    if kchar == event.CHAR_UNDEFINED: return
    else:
        pat = pat + kchar
    autobox = self.autobox
    lm = autobox.getModel()
    ww = []
    index = None
    for z in xrange(lm.getSize()):
        item = lm.getElementAt(z)
        if item.startswith(pat):
                index = z
                break
        #ww.append( lm.getElementAt( z ) )

    #autobox = context.autobox
    #ww = list( autobox.get( 0, 'end' ) )
    #lis = self.reducer(ww,pat)
    #if len(lis)==0:return None #in this section we are selecting which item to select based on what the user has typed.
    #i = ww.index(lis[0])

    #lm.clear()
    #autobox.setListData( lis )
    if index != None:
        autobox.clearSelection()
        autobox.setSelectedIndex(index)
        autobox.ensureIndexIsVisible(index)

    #autobox.select_clear( 0, 'end' ) #This section sets the current selection to match what the user has typed
    #autobox.select_set( i )
    #autobox.see( i )
    #return 'break'

#@-node:ekr.20070930184746.120:processKeyStroke/keyPressed
#@+node:ekr.20070930184746.121:processAutoBox
def processAutoBox (self,event,pat):
    '''This method processes the selection from the autobox.'''
    #if event.keysym in("Alt_L","Alt_R"):
    #    return None 

    #a = context.autobox.getvalue()
    a = self.autobox.getSelectedValue()
    #if len(a)==0:return None 
    if not a: self.hideAutoBox()
    try:
        #a = a[0]
        #ind = body.index('insert-1c wordstart')
        #pat = body.get(ind,'insert')
        #pat = pat.lstrip('.')

        if a.startswith(pat): a = a [len(pat):]
        doc = self.jeditor.getDocument()
        doc.insertString(self.jeditor.getCaretPosition(),a,None)
        self.hideAutoBox()
        #self.editor.insert 
        #body.insert('insert',a)
        #body.event_generate("<Key>")
        #body.update_idletasks()
    except java.lang.Exception, x:
        x.printStackTrace()
        #self.editor.hideAutoBox()
        #unbind( context )
#@-node:ekr.20070930184746.121:processAutoBox
#@+node:ekr.20070930184746.122:moveUpDown
def moveUpDown (self,code):

    autobox = self.autobox
    i = autobox.getSelectedIndex()
    if code == 'Alt Up':
        i2 = i-1
    else:
        i2 = i + 1

    lm = autobox.getModel()
    if i2 < 0 or i2 + 1 > lm.getSize():
        return
    else:
        autobox.setSelectedIndex(i2)
        autobox.ensureIndexIsVisible(i2)
#@nonl
#@-node:ekr.20070930184746.122:moveUpDown
#@+node:ekr.20070930184746.123:testForUnbind
def testForUnbind (self,keysym):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if keysym in ('parenright','parenleft','Escape','Space','Enter','Tab','Up','Down') or keysym.isspace():
        return True
    #elif not context.which and event.char in ripout:
    #    return True
    return False
#@-node:ekr.20070930184746.123:testForUnbind
#@+node:ekr.20070930184746.124:DocumentListener implementation
@others
#@nonl
#@+node:ekr.20070930184746.125:changedUpdate
def changedUpdate (self,event):
    pass

#@-node:ekr.20070930184746.125:changedUpdate
#@+node:ekr.20070930184746.126:insertUpdate
def insertUpdate (self,event):

    if not self.on: return
    doc = event.getDocument()
    change = doc.getText(event.getOffset(),event.getLength())
    if change == '.':
        self.watcher(event)



#@-node:ekr.20070930184746.126:insertUpdate
#@+node:ekr.20070930184746.127:removeUpdate
def removeUpdate (self,event):
    '''originally I wanted to do a remove of the autobox on a backspace of '.' but this couldnt be detected adequately
    and had to be put in the Key handling code of the autocompleter.'''
    pass

#@-node:ekr.20070930184746.127:removeUpdate
#@-node:ekr.20070930184746.124:DocumentListener implementation
#@+node:ekr.20070930184746.128:watcher
watchitems = ('.',')')
txt_template = '%s%s%s'
def watcher (self,event):
    '''A function that tracks what chars are typed in the Text Editor.  Certain chars activate the text scanning
       code.'''
    #global lang 
    doc = event.getDocument()
    txt = doc.getText(event.getOffset(),event.getLength())
    if txt.isspace() or txt in self.watchitems:
        #bCtrl = event.widget
        #This if statement ensures that attributes set in another node
        #are put in the database.  Of course the user has to type a whitespace
        # to make sure it happens.  We try to be selective so that we dont burn
        # through the scanText def for every whitespace char entered.  This will
        # help when the nodes become big.
        #if event.char.isspace():
        #    if bCtrl.get( 'insert -1c' ).isspace(): return #We dont want to do anything if the previous char was a whitespace
        #    if bCtrl.get( 'insert -1c wordstart -1c') != '.': return

        #c = bCtrl.commander
        #lang = c.frame.body.getColorizer().language 
        #txt = txt_template %( bCtrl.get( "1.0", 'insert' ), 
        #                     event.char, 
        #                     bCtrl.get( 'insert', "end" ) ) #We have to add the newest char, its not in the bCtrl yet
        txt = doc.getText(0,doc.getLength())
        self.scanText(txt)
        self.determineToShow(event)

#@-node:ekr.20070930184746.128:watcher
#@+node:ekr.20070930184746.129:scanText
def scanText (self,txt):
    '''This function guides what gets scanned.'''

    #if useauto:
    self.scanForAutoCompleter(txt)
    #if usecall:
    #    scanForCallTip(txt)
#@-node:ekr.20070930184746.129:scanText
#@+node:ekr.20070930184746.130:scanForAutoCompleter
def scanForAutoCompleter (self,txt):
    '''This function scans text for the autocompleter database.'''
    t1 = txt.split('.')
    g = []
    reduce(lambda a,b: self.makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            if self.watchwords.has_key(a):
                self.watchwords [a] [b] = None
            else:
                self.watchwords [a] = {b: None}
                #watchwords[a] = sets.Set([b])
                #watchwords[ a ] = util.Hash
            #watchwords[ a ].add( b ) # we are using the experimental DictSet class here, usage removed the above statements
            #notice we have cut it down to one line of code here!
#@nonl
#@-node:ekr.20070930184746.130:scanForAutoCompleter
#@+node:ekr.20070930184746.131:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):
    '''A helper function for autocompletion'''
    a1 = self._reverseFindWhitespace(a)
    if a1:
        b2 = self._getCleanString(b)
        if b2 != '':
            glist.append((a1,b2))
    return b
#@-node:ekr.20070930184746.131:makeAutocompletionList
#@+node:ekr.20070930184746.132:_getCleanString
def _getCleanString (self,s):
    '''a helper for autocompletion scanning'''
    if s.isalpha(): return s

    #for n, l in enumerate(s):
    for n in xrange(len(s)):
        l = s [n]
        if l in self.okchars: pass
        else: return s [: n]
    return s
#@-node:ekr.20070930184746.132:_getCleanString
#@+node:ekr.20070930184746.133:_reverseFindWhitespace
def _reverseFindWhitespace (self,s):
    '''A helper for autocompletion scan'''
    #for n, l in enumerate(s):
    for n in xrange(len(s)):
        l = s [n]
        n = (n+1) * -1
        if s [n].isspace() or s [n] == '.': return s [n + 1:]
    return s
#@-node:ekr.20070930184746.133:_reverseFindWhitespace
#@+node:ekr.20070930184746.134:reducer
def reducer (self,lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return [x for x in lis if x.startswith(pat)]
#@-node:ekr.20070930184746.134:reducer
#@+node:ekr.20070930184746.135:determineToShow
def determineToShow (self,event):

    doc = event.getDocument()
    txt = doc.getText(0,event.getOffset())
    txt_list = txt.splitlines()
    if not txt_list: return
    txt_line = txt_list [ -1]
    txt_splitdots = txt_line.split('.') [ -1]
    txt_final = txt_splitdots.split()
    if txt_final:
        txt_final = txt_final [ -1]
    if txt_final and self.watchwords.has_key(txt_final):
        completers = self.watchwords [txt_final].keys()
        completers.sort()
        self.getAutoBox(completers)

#@-node:ekr.20070930184746.135:determineToShow
#@+node:ekr.20070930184746.136:startup time scanning
@others
#@nonl
#@+node:ekr.20070930184746.137:initialScan
def initialScan (self,tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c") or keywords.get("new_c")
    haveseen = self.haveseen
    if haveseen.has_key(c):
        return

    haveseen [c] = None

    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    #pth = os.path.split(g.app.loadDir)  
    #aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    #if not os.path.exists(aini):
    #    createConfigFile( aini )
    #try:
    #    if not hasReadConfig():
    #        if os.path.exists(aini):
    #            readConfigFile(aini) 
    #
    #        bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
    #        readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    #finally:
    #    setReadConfig()

    # Use a thread to do the initial scan so as not to interfere with the user.
    #_self = self
    #class scanner( java.lang.Thread ):          
    #def run( self ):
    #    _self.readOutline( c )
    #    #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
    #    #readOutline( c )

    dc = DefCallable(lambda: self.readOutline(c))
    g.app.gui.addStartupTask(dc)



#@-node:ekr.20070930184746.137:initialScan
#@+node:ekr.20070930184746.138:readOutline
def readOutline (self,c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    #global lang
    #if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
    #    import chapters 
    #    it = chapters.walkChapters()
    #     for x in it:
    #        lang = None 
    #        setLanguage(x)
    #        scanText(x.bodyString())
    #else:
    for z in c.rootPosition().allNodes_iter(copy=True):
        #self.scanText( z.bodyString() )
        rvalues = LeoUtilities.scanForAutoCompleter(z.v.t._bodyString)
        if rvalues:
            for z in rvalues:
                a, b = z
                if self.watchwords.has_key(a):
                    self.watchwords [a] [b] = None
                else:
                    self.watchwords [a] = {b: None}



    g.es("Autocompleter ready")
#@-node:ekr.20070930184746.138:readOutline
#@-node:ekr.20070930184746.136:startup time scanning
#@+node:ekr.20070930184746.139:get, hide and insert AutoBox
@others
#@nonl
#@+node:ekr.20070930184746.140:getAutoBox
def getAutoBox (self,completers):

    jlist = self.autobox
    jp = self.autobase
    if len(completers) < 5:
        jlist.setVisibleRowCount(len(completers))
    else:
        jlist.setVisibleRowCount(5)

    model = jlist.getModel()
    model.removeAllElements() #by working with the model we dont burn a new object each time.
    for z in completers:
        model.addElement(z)
    jlist.setSelectedIndex(0)
    jlist.ensureIndexIsVisible(0)
    jlist.setValueIsAdjusting(True)


    cur = self.jeditor.getCaretPosition()
    pos = self.jeditor.modelToView(cur)
    size = self.editor.view.getViewport().getViewRect()
    pos = swing.SwingUtilities.convertRectangle(self.jeditor,pos,self.editor.epane)
    size.x = 0 ; size.y = 0 ;


    jlist.setSize(jlist.getPreferredSize()) #the discrepency between the two was causing weird drawing bugs.  This appears to have rectified it.
    #Its very important that the setSize call happens before the self.jsp.getPreferredSize call, or it may not calculate right.
    jsps = self.jsp.getPreferredSize()
    jp.setSize(jsps)
    rx = ry = 0
    if pos.x > (size.x+size.height) / 2:
        rx = pos.x- jsps.width
    else: rx = pos.x

    if pos.y > (size.y+size.height) / 2:
        ry = pos.y- jsps.height
    else: ry = pos.y + pos.height

    point = awt.Point(rx,ry)
    swing.SwingUtilities.convertPointToScreen(point,self.editor.view.getViewport())
    popupfactory = swing.PopupFactory().getSharedInstance()
    self.popup = popup = popupfactory.getPopup(self.editor.editor,jp,point.x,point.y)
    popup.show()






#@-node:ekr.20070930184746.140:getAutoBox
#@+node:ekr.20070930184746.141:hideAutoBox
def hideAutoBox (self):

    if self.popup:
        self.popup.hide() ; self.popup = None


#@-node:ekr.20070930184746.141:hideAutoBox
#@+node:ekr.20070930184746.142:insertFromAutobox
def insertFromAutoBox (self):

    autobox = self.autobox
    value = autobox.getSelectedValue()
    pos = self.jeditor.getCaretPosition()
    self.jeditor.getDocument().insertString(pos,value,None)
    self.hideAutoBox()
#@nonl
#@-node:ekr.20070930184746.142:insertFromAutobox
#@-node:ekr.20070930184746.139:get, hide and insert AutoBox
#@-node:ekr.20070930184746.116:autolistener --does autocompleter work
#@+node:ekr.20070930184746.143:Carets
#@+node:ekr.20070930184746.144:UnderlinerCaret
class UnderlinerCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self,color):
        stext.DefaultCaret.__init__(self)
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #self._bg = awt.Color.RED
        self._bg = color
        #self._bg = awt.Color( c.getRed(), c.getGreen(), c.getBlue(), 50 ); 
        self.setBlinkRate(0) #no blinking please


    def paint (self,g):

        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)

        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self.calculateCharacterWidth(g) + 1 #Its important to be a little wider
            self.height = view.height + 1 #And a little taller than the box, or redraws will leave traces


        if self.isVisible():
            g.setColor(self._bg)
            #g.fillRect( self.x, self.y, self.width - 1, view.height )
            g.drawLine(self.x,self.y+self.height-1,self.x+self.width-1,self.y+self.height-1)
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def calculateCharacterWidth (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        fm = g.getFontMetrics()

        pos = com.getCaretPosition()
        len = com.getDocument().getLength()
        if pos >= len:
            c = ' '
        else:
            c = com.getText(pos,1)
        if java.lang.Character.isWhitespace(c): c = ' '

        return swing.SwingUtilities.computeStringWidth(fm,c)





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth(graphics) + 1
        graphics.dispose()
        self.height = view.height + 1 ;
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))
#@nonl
#@-node:ekr.20070930184746.144:UnderlinerCaret
#@+node:ekr.20070930184746.145:SeeThroughBoxCaret
class SeeThroughBoxCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self,color):
        stext.DefaultCaret.__init__(self)
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #c = awt.Color.RED
        self._bg = awt.Color(color.getRed(),color.getGreen(),color.getBlue(),50) ;
        self.setBlinkRate(0) #no blinking please


    def paint (self,g):

        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self.calculateCharacterWidth(g) + 1 #Its important to be a little wider
            self.height = view.height + 1 #And a little taller than the box, or redraws will leave traces


        if self.isVisible():
            g.setColor(self._bg)
            g.fillRect(self.x,self.y,self.width-1,view.height)

        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def calculateCharacterWidth (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        if not g: return 0
        com = self.super__getComponent()
        doc = com.getDocument()
        pos = com.getCaretPosition()
        len = doc.getLength()
        if pos >= len:
            c = ' '
        else:
            c = com.getText(pos,1)

        e = doc.getCharacterElement(pos)
        atts = e.getAttributes()
        f = doc.getFont(atts)
        if f:
            g.setFont(f)
        fm = g.getFontMetrics()

        if java.lang.Character.isWhitespace(c): c = ' '

        return swing.SwingUtilities.computeStringWidth(fm,c)





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth(graphics) + 1
        if graphics:
            graphics.dispose()
        self.height = view.height + 1 ;
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

#@-node:ekr.20070930184746.145:SeeThroughBoxCaret
#@+node:ekr.20070930184746.146:GhostlyLeoCaret
import java.awt.image as aim
class GhostlyLeoCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self):
        stext.DefaultCaret.__init__(self)

        self.setBlinkRate(0) #no blinking please
        self._image = leoSwingBody.Editor.icon.getImage()
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1
        self._ac = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,.2)
        self._bgc = None


    def paint (self,g):

        com = self.super__getComponent()
        if self._bgc == None:
            self._bgc == g.getColor()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)

        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self._im_width
            self.height = self._im_height


        if self.isVisible():

            if not self.isWhiteSpace(g):
                g.setComposite(self._ac)
            g.drawImage(self._image,self.x,self.y,self._bgc,None)
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def isWhiteSpace (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        v1 = com.viewToModel(awt.Point(self.x,self.y))
        v2 = com.viewToModel(awt.Point(self.x+self.width,self.y))
        vlen = v2- v1
        len = com.getDocument().getLength()
        if v1 >= len:
            c = ' '
        else:
            c = com.getText(v1,vlen)
        if c.isspace() or c == '': c = ' '
        return c == ' '





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        self.height = self._im_height
        self.width = self._im_width
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))
#@-node:ekr.20070930184746.146:GhostlyLeoCaret
#@+node:ekr.20070930184746.147:ImageCaret
class ImageCaret(GhostlyLeoCaret):

    def __init__ (self,image):
        leoSwingBody.Editor.GhostlyLeoCaret.__init__(self)
        self._image = image
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1


#@-node:ekr.20070930184746.147:ImageCaret
#@-node:ekr.20070930184746.143:Carets
#@+node:ekr.20070930184746.148:leoJTextPane
class leoJTextPane(swing.JTextPane):

    def __init__ (self,c):
        swing.JTextPane.__init__(self)
        self.c = c
        self.last_rec = None
        self._bg = None

    def setLineColor (self,notification=None,handback=None):

        c = self.c
        if g.app.config.getBool(c,"highlight_current_line"):
            hc = g.app.config.getColor(c,"current_line_highlight_color")
            color = getColorInstance(hc,awt.Color.ORANGE)
            self._bg = awt.Color(color.getRed(),color.getGreen(),color.getBlue(),50)
        else:
            self._bg = None
            self._last_rec = None
        self.repaint()

@
    def paintComponent (self,graphics):
        if 0:
            paint = graphics.getPaint()
            color = self.getBackground()
            c1 = awt.Color.RED
            c2 = awt.Color.GREEN
            vrect = self.getVisibleRect()
            gp = awt.GradientPaint(vrect.x,vrect.y,c1,vrect.x+vrect.width,vrect.y+vrect.height,c2)
            graphics.setPaint(gp)
            graphics.fillRect(vrect.x,vrect.y,vrect.width,vrect.height)
            graphics.setPaint(paint)
@c

    def paintComponent (self,graphics):

        self.super__paintComponent(graphics)
        if self._bg:
            cpos = self.getCaretPosition() #from here
            try:
                rec = self.modelToView(cpos)
            except java.lang.Exception, x:
                x.printStackTrace()
                return
            sz = self.getVisibleRect()
            rec = awt.Rectangle(sz.x,rec.y,sz.width,rec.height) #to here: these calculate the colored background.
            if self.last_rec and not self.last_rec.equals(rec): #its not the same spot we must repaint!
                if self.last_rec.width < rec.width:
                    self.last_rec.width = rec.width
                self.repaint(self.last_rec)


            c = graphics.getClip()
            rintersect = rec.intersects(c)
            if not rec.equals(self.last_rec) or rintersect:
                if self.last_rec:
                    if rec.y != self.last_rec.y or rec.height != self.last_rec.height:
                        rintersect = 0
                if rintersect:
                    graphics.setColor(self._bg) #if we intersect we only repaint a small portion. This reduces flicker.
                    graphics.fill(rec)
                else:
                    g2 = self.getGraphics()
                    g2.setColor(self._bg) #if we dont we repaint all of it.
                    g2.fill(rec)
                    g2.dispose()


            self.last_rec = rec


#@-node:ekr.20070930184746.148:leoJTextPane
#@+node:ekr.20070930184746.149:leoImageJPanel
class leoImageJPanel(swing.JPanel):

    def __init__ (self,layoutmanager):
        swing.JPanel.__init__(self,layoutmanager)
        self.image = None
        self.backedWidget = None
        self.last_image = None
        self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,1.0)
        self.lastDimensions = awt.Rectangle(0,0,0,0)

    def setBackedWidget (self,widget):
        self.backedWidget = widget

    def setImage (self,image):
        self.image = image

    def setAlpha (self,alpha):
        self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,alpha)

    def paintComponent (self,graphics):

        self.super__paintComponent(graphics)
        if self.backedWidget and self.image:
            vrec = self.backedWidget.getVisibleRect()
            rec2 = swing.SwingUtilities.convertRectangle(self.backedWidget,vrec,self)
            if not self.lastDimensions.equals(vrec):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance(rec2.width,rec2.height,awt.Image.SCALE_REPLICATE)
            composite = graphics.getComposite()
            graphics.setComposite(self.alpha)
            graphics.drawImage(self.last_image,rec2.x,rec2.y,awt.Color.WHITE,None)
            graphics.setComposite(composite)
#@-node:ekr.20070930184746.149:leoImageJPanel
#@+node:ekr.20070930184746.150:leoLayoutManager
class leoLayoutManager(awt.LayoutManager):


    def __init__ (self):
        self.jscrollpane = None
        self.minibuffer = None
        self.media = None



    def addLayoutComponent (self,name,component):
        pass


    def layoutContainer (self,container):

        size = container.getSize()
        if self.minibuffer:
            mbpsize = self.minibuffer.getPreferredSize()
        else:
            mbpsize = awt.Rectangle(0,0,0,0)

        if self.jscrollpane:
            self.jscrollpane.setBounds(0,0,size.width,size.height-mbpsize.height)
            if self.minibuffer:
                self.minibuffer.setBounds(0,size.height-mbpsize.height,size.width,mbpsize.height)

        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds(vr)

    def layoutMedia (self):
        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds(vr)

    def minimumLayoutSize (self,container):
        return container.getMinimumSize()


    def preferredLayoutSize (self,container):
        return container.getPreferredSize()


    def removeLayoutComponent (self,container):
        pass
#@-node:ekr.20070930184746.150:leoLayoutManager
#@-node:ekr.20070930184746.115:component classes
#@-node:ekr.20070930184746.42:helper methods and classes
#@-node:ekr.20070930184746.32:class Editor
#@+node:ekr.20070930184746.151:MouseAdapter
class UtilityRightClick( aevent.MouseAdapter ):


    def __init__( self, c, detach_retach = False, editor = None ):
        aevent.MouseAdapter.__init__( self )
        self.c = c
        self.editor = weakref.proxy( editor )
        self._detach_retach = detach_retach


    @others


#@+node:ekr.20070930184746.152:mousePressed
def mousePressed( self, mE ):

    if mE.getClickCount() == 1:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()

            popup = swing.JPopupMenu()

            UtilityAction = leoSwingBody.UtilityAction
            AddEditor = leoSwingBody.AddEditor
            InsertNode = leoSwingBody.InsertNode            
            frame = self.c.frame
            for z in ( ( "Cut", self.editor.editor.cut ), ( "Copy", self.editor.editor.copy ), 
                        ( "Paste", self.editor.editor.paste ), # frame.OnPaste ), 
                        ( "Delete", self.c.delete  ),
                        ):
                popup.add( UtilityAction( z[ 0 ], z[ 1 ] ) )

            popup.addSeparator()
            popup.add( UtilityAction( "Turn Selection Into Node", self.editor.turnSelectionIntoNode ))
            inmenu = swing.JMenu( "Insert Node Into Body" )
            inmenu.addMenuListener( InsertNode( inmenu, self.c, UtilityAction ) )
            popup.add( inmenu )

            popup.add( UtilityAction( "Split Node", frame.body.editor.splitNode ) )

            if( mE.getComponent() == self.editor ):
                popup.add( UtilityAction( "Select All", self.editor.selectAll ) )

            popup.addSeparator()  
            body = frame.body
            popup.add( AddEditor( body , x, y ) )
            popup.addSeparator()               
            if self._detach_retach:
                if self.editor._attached:
                    s = "Detach Editor"
                    act = self.editor.detach
                else:
                    s = "Retach Editor"
                    act = self.editor.retach 
                ji = swing.JMenuItem( s )
                ji.actionPerformed =  act
                popup.add( ji )

            folded = self.editor.foldprotection.isFolded( x, y )
            if self.editor.editor.getSelectionStart() != self.editor.editor.getSelectionEnd() or folded:
                popup.addSeparator()
                if not folded:
                    jmi = swing.JMenuItem( "Fold Selection" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection: fp.foldSelection()
                else:
                    jmi = swing.JMenuItem( "Unfold Fold" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection, x = x, y= y: fp.unfoldSpot( x, y )

                popup.add( jmi )

            source = mE.getSource()    
            popup.show( source, x, y )
#@nonl
#@-node:ekr.20070930184746.152:mousePressed
#@-node:ekr.20070930184746.151:MouseAdapter
#@+node:ekr.20070930184746.153:tabs
def addTab( self, name, widget ):

    self.tab_manager.add( name, widget )



def removeTab( self, widget ):

    self.tab_manager.remove( widget )

#@-node:ekr.20070930184746.153:tabs
#@+node:ekr.20070930184746.154:nextEditor previousEditor
def nextEditor (self,reverse=False):

    editor = self.editor
    next = False
    editors = list(self.editors)
    if reverse:
        editors.reverse()
    for z in editors:
        z = z.get()
        if next:
            tl = z.editor.getTopLevelAncestor()
            tl.toFront()
            z.editor.requestFocus()
            return
        if z == editor: next = True
    if next:
        for z in editors:
            z = z.get()
            if z:
                tl = z.editor.getTopLevelAncestor()
                tl.toFront()
                z.editor.requestFocus()
                return

def previousEditor (self):
    self.nextEditor(reverse=True)
#@-node:ekr.20070930184746.154:nextEditor previousEditor
#@+node:ekr.20070930184746.155:classes: Editor and a multitude of helpers
@others
#@nonl
#@+node:ekr.20070930184746.32:class Editor
class Editor( aevent.FocusListener ):

    ipath = g.os_path_join( g.app.loadDir ,"..","Icons","Leoapp2.GIF")
    icon = swing.ImageIcon( "../Icons/Leoapp2.GIF" )
    icon = swing.ImageIcon( ipath ) 
    #ifile = java.io.File( ipath )
    #iimage = imageio.ImageIO.read( ifile ) 

    @others





#@+node:ekr.20070930184746.33:class insTx
class InsertTextIntoBody(swing.AbstractAction):

    def __init__ (self,c,txt):
        swing.AbstractAction.__init__(self,txt)
        self.txt = txt
        self.c = c

    def actionPerformed (self,event):

        editor = self.c.frame.body.editor.editor
        pos = editor.getCaretPosition()
        #editor.insert( self.txt, pos )
        doc = editor.getDocument()
        doc.insertString(pos,self.txt,None)



class SetHeadline(InsertTextIntoBody):

    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        newHeadString = "%s %s" % (self.txt,hS)
        cp.setHeadString(newHeadString)


class SetHeadlineToSelection(InsertTextIntoBody):
    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        txt = self.c.frame.body.editor.editor.getSelectedText()
        if txt:
            cp = self.c.currentPosition()
            cp.setHeadString(txt)



class rmvSymbol(swing.AbstractAction):
    def __init__ (self,c,symbol):
        swing.AbstractAction.__init__(self,"remove %s" % symbol)
        self.c = c
        self.symbol = symbol

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        if hS.startswith(self.symbol):
            hS = hS.split()
            hS = hS [1:]
            hS = " ".join(hS)
            cp.setHeadString(hS)



class inSRMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        cp = self.c.currentPosition()
        InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
        for z in cp.children_iter():
            hS = z.headString()
            hS = hS.strip()
            if hS.startswith("<%s" % '<') and hS.endswith(">%s" % ">"):
                menu.add(InsertTextIntoBody(self.c,hS))

#@-node:ekr.20070930184746.33:class insTx
#@+node:ekr.20070930184746.34:colorizer callback
class ColorKeywordsProvider(leoEditorKit2.ColorDeterminer,sevent.DocumentListener):

    @others
#@+node:ekr.20071001071356:__init__
def __init__ (self,c):

    lb = leoLanguageManager.LanguageManager.getLanguageBundle(c)
    for z in dir(lb):
        if not callable(getattr(lb,z)):
            setattr(self,z,getattr(lb,z))

    self.c = c
    self.last_p = None
    self.last_language = None
    self.editor = None
    self.error_map = util.HashMap()
    fg, bg, cl = self.getLineNumberColors()
    self.line_fg = fg ; self.line_bg = bg ; self.line_cl = cl
    self.queue = concurrent.LinkedBlockingQueue()
    self.c.invisibleWatchers.append(self)
    return


#@-node:ekr.20071001071356:__init__
#@+node:ekr.20071001071356.1:changedUpdate
def changedUpdate (self,event):
    pass #this does Attribute changes


#@-node:ekr.20071001071356.1:changedUpdate
#@+node:ekr.20071001071356.2:checkForLanguageChange
def checkForLanguageChange (self,event):

    language = LeoUtilities.scanForLanguageOnLine(self.editor)
    if language:
        #if not hasattr( self, "%s_keywords" % language ):
        if self.last_language != language:
            #self.editor.repaint()
            self.last_language = language
            jlc = self.c.frame.body.editor.jlc
            jlc.fullrecolorize()



#@-node:ekr.20071001071356.2:checkForLanguageChange
#@+node:ekr.20071001071356.3:drawrectangle
def drawrectangle (self):
    return self._drawrectangle

#@-node:ekr.20071001071356.3:drawrectangle
#@+node:ekr.20071001071356.4:getColoredTokens
def getColoredTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language

    leoLanguageManager.LanguageManager.setLanguageInEffect(self.c,language)

    if language == None:
        language = "python"
    if hasattr(self,"%s_keywords" % language):
        return getattr(self,"%s_keywords" % language)
    else:
        hm = leoLanguageManager.LanguageManager.loadLanguage(self.c,language)
        setattr(self,"%s_keywords" % language,hm)
        return hm


#@-node:ekr.20071001071356.4:getColoredTokens
#@+node:ekr.20071001071356.5:getCommentColor
def getCommentColor (self):
    return self._commentColor

#@-node:ekr.20071001071356.5:getCommentColor
#@+node:ekr.20071001071356.6:getCommentTokens
def getCommentTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language
    if self.comment_cache.has_key(language):
        return self.comment_cache [language]
    else:
        rv = g.set_delims_from_language(language)
        rv = jarray.array(rv,java.lang.String)
        self.comment_cache [language] = rv
        return rv
    #delim1,delim2, delim3 = g.set_delims_from_language( language )
    #return [ delim1, delim2, delim3 ]

#@-node:ekr.20071001071356.6:getCommentTokens
#@+node:ekr.20071001071356.7:getCurrentLineNumberForeground
def getCurrentLineNumberForeground (self):
    return self.line_cl

#@-node:ekr.20071001071356.7:getCurrentLineNumberForeground
#@+node:ekr.20071001071356.8:getDocColor
def getDocColor (self):
    return self._docColor

#@-node:ekr.20071001071356.8:getDocColor
#@+node:ekr.20071001071356.9:getFoldedBackgroundColor
def getFoldedBackgroundColor (self):
    return self._fbColor

#@-node:ekr.20071001071356.9:getFoldedBackgroundColor
#@+node:ekr.20071001071356.10:getFoldedForegroundColor
def getFoldedForegroundColor (self):
    return self._ffColor



#@-node:ekr.20071001071356.10:getFoldedForegroundColor
#@+node:ekr.20071001071356.11:getFootNodeBackgroundColor
def getFootNodeBackgroundColor (self):
    return self._fnbgColor

#@-node:ekr.20071001071356.11:getFootNodeBackgroundColor
#@+node:ekr.20071001071356.12:getFootNodeForegroundColor
def getFootNodeForegroundColor (self):
    return self._fnfgColor


#@-node:ekr.20071001071356.12:getFootNodeForegroundColor
#@+node:ekr.20071001071356.13:getFootNodes
def getFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            sb = java.lang.StringBuilder()
            for z in fn:
                sb.append(z[0]).append(" : ").append(z[1])
                if not z [1].endswith("\n"): sb.append("\n")
            return sb.toString()
    return ""


#@-node:ekr.20071001071356.13:getFootNodes
#@+node:ekr.20071001071356.14:getInvisiblesBlock
def getInvisiblesBlock (self):
    return self._invisibleBlock

#@-node:ekr.20071001071356.14:getInvisiblesBlock
#@+node:ekr.20071001071356.15:getInvisiblesDot
def getInvisiblesDot (self):
    return self._invisibleDot

#@-node:ekr.20071001071356.15:getInvisiblesDot
#@+node:ekr.20071001071356.16:getLineNumberBackground
def getLineNumberBackground (self):
    return self.line_bg

#public boolean useLineNumbers();
#public Color getLineNumberForeground();
#public Color getCurrentLineNumberForeground();
#public Color getLineNumberBackground();
#@-node:ekr.20071001071356.16:getLineNumberBackground
#@+node:ekr.20070930184746.35:getLineNumberColors
def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl



#@-node:ekr.20070930184746.35:getLineNumberColors
#@+node:ekr.20071001071356.17:getLineNumberForeground
def getLineNumberForeground (self):
    return self.line_fg

#@-node:ekr.20071001071356.17:getLineNumberForeground
#@+node:ekr.20071001071356.18:getNumericColor
def getNumericColor (self):
    return self._numericcolor

#@-node:ekr.20071001071356.18:getNumericColor
#@+node:ekr.20071001071356.19:getOperators
def getOperators (self):
    return util.HashMap()


#@-node:ekr.20071001071356.19:getOperators
#@+node:ekr.20071001071356.20:getPunctuationColor
def getPunctuationColor (self):
    return self._punctuationColor

#@-node:ekr.20071001071356.20:getPunctuationColor
#@+node:ekr.20071001071356.21:getRectangleColor
def getRectangleColor (self):
    return self._rectanglecolor

#@-node:ekr.20071001071356.21:getRectangleColor
#@+node:ekr.20071001071356.22:getSectionReferenceColor
def getSectionReferenceColor (self):
    return self._sectionNameColor

#@-node:ekr.20071001071356.22:getSectionReferenceColor
#@+node:ekr.20071001071356.23:getStringColor
def getStringColor (self):
    return self._stringColor

#@-node:ekr.20071001071356.23:getStringColor
#@+node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
def getUndefinedSectionReferenceColor (self):
    return self._undefinedSectionNameColor

#@-node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
#@+node:ekr.20071001071356.25:hasFootNodes
def hasFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            if fn: return True
    return False

#@-node:ekr.20071001071356.25:hasFootNodes
#@+node:ekr.20071001071356.26:insertUpdate
def insertUpdate (self,event):
    self.checkForLanguageChange(event)

#@-node:ekr.20071001071356.26:insertUpdate
#@+node:ekr.20071001071356.27:notify
def notify (self):
    self.c.frame.body.editor.ekit.showInvisibles(self.c.showInvisibles)

#@-node:ekr.20071001071356.27:notify
#@+node:ekr.20071001071356.28:removeUpdate
def removeUpdate (self,event):
    self.checkForLanguageChange(event)


#@-node:ekr.20071001071356.28:removeUpdate
#@+node:ekr.20071001071356.29:setEditor
def setEditor (self,editor):
    self.editor = editor
    doc = editor.getDocument()
    doc.addDocumentListener(self)


#@-node:ekr.20071001071356.29:setEditor
#@+node:ekr.20071001071356.30:showInvisibles
def showInvisibles (self):
    return self.c.showInvisibles

#@-node:ekr.20071001071356.30:showInvisibles
#@+node:ekr.20071001071356.31:underline
def underline (self):
    return self._underline

#@-node:ekr.20071001071356.31:underline
#@+node:ekr.20071001071356.32:useLineNumbers
def useLineNumbers (self):
    return g.app.config.getBool(self.c,"use_line_numbering")

#@-node:ekr.20071001071356.32:useLineNumbers
#@+node:ekr.20071001071356.33:whichInvisible
def whichInvisible (self):
    return self._which_invisible

#@-node:ekr.20071001071356.33:whichInvisible
#@-node:ekr.20070930184746.34:colorizer callback
#@+node:ekr.20070930184746.36:RecentVisitsMenuListener
class RecentVisitsMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c,recent):
        self.menu = menu
        self.c = c
        self.recent = recent

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        goNode = leoSwingBody.Editor.goNode
        for z in self.recent:
            if z:
                menu.add(goNode(z,self.c))
#@-node:ekr.20070930184746.36:RecentVisitsMenuListener
#@+node:ekr.20070930184746.37:Note on Editor design
@
The key to making:
    1. Autocompleter
    2. Line numbers
    3. Any any future floaters
work is in the use of the JLayeredPane.  The JLayeredPane is made for floating widgets on top of one another.


This allows the autocompleter to appear on top of the JTextPane when needed.  It also allows
the easy placement of the Line number label to the left.

The line number label was tried as a JTextPane to start with, this gave us numbers parralel to the editor.
But this seemed to introduce a scroll bug that became apparent when the editor had a large volume of lines in it.  My
assumption is that this was because of some event the Caret for the line number editor was executing when its contents
changed.  By moving to a Label that is drawn on my a method in the LeoView class this problem no longer presented itself,
mainly because a JLabel doesnt have a Cursor.  If that was the source of the problem.

The viewport is secretly tied to the JTextPane by a specialised jython JLayeredPane that returns the preferred size of the
JTextPane instead of itself.  This causes the JScrollPane to actually scroll with the editor.

To calculate the coordinates of a floater you need to do the minimum:
1. Translate the viewports visible rectangle into the JLayeredPanes coord system.
    2. Translate the JTextPane into the JLayeredPanes coord system.
    3. Do calculations based off of those two pieces of information.


@c
#@-node:ekr.20070930184746.37:Note on Editor design
#@+node:ekr.20070930184746.38:__init__ (Editor)
def __init__( self, parent, c , body, x = 0, y = 0):

    self.c = c
    self.body = body
    wr = java.lang.ref.WeakReference( self )
    self.body.editors.append( wr )
    self.synchers = []
    self._parent = parent 
    self.frame = swing.JInternalFrame( "", 1, 1, 1, 1, 
                                      size = ( 400, 400 ) )
    self.frame.setFocusTraversalPolicy( c.frame.ftp )
    self._attached = True

    cpane = self.frame.getContentPane()
    self.tab_manager = TabManager()
    self.tab_manager.tabsToBottom()
    self.visible_informer = VisibleInformer( self.tab_manager.jtp )
    cpane.add( self.tab_manager.base, java.awt.BorderLayout.CENTER )
    self.editorlomanager = self.leoLayoutManager()
    self.epane = swing.JPanel()
    self.epane.setLayout( self.editorlomanager )
    self.frame.setFrameIcon( leoSwingBody.Editor.icon )

    self.initializeEditor()        
    self.initializeFont()
    << add EditorKit>>

    #self.editor.addFocusListener( self.tFocusListener())
    self.editor.addMouseListener( leoSwingBody.UtilityRightClick( c , detach_retach = True, editor = self ) )
    self.addMinibuffer()
    self.swingmacs = SwingMacs.SwingMacs( self.editor, self.minibuffer, self.minilabel, c )
    c.frame.isMenuInitialized( self.createCommanderCommander )

    #self.swingmacs.addCommands( commandercommander, commandercommander.getCommands() )
    self.addCompleters()
    self.addMenus()    

    self.brackethighlighter = self.BracketHighlighter( self.editor, c ) # initializeCaret needs this to work
    self.initializeCaret()


    self.editor.setName( "Editor" )

    self.editor.getDocument().addDocumentListener( body )
    self.editor.addKeyListener( body )
    << add autocompleter >>
    << add scrollpane >>


    self.configureMedia()
    self.editor.addFocusListener( self )
    self.frame.setLocation( x, y )
    parent.add( self.frame, swing.JLayeredPane.DEFAULT_LAYER )
    self.initializeEditorColors()
    self.frame.visible = 1
    self.lastPosition = None
    self.chapter = None
    wm1 = WeakMethod( self, "chapterChanged" )
    wm2 = WeakMethod( self, "headlineChanged" )
    leoPlugins.registerHandler( "chapter-changed", wm1 )
    leoPlugins.registerHandler( "chapter-removed", wm1 )
    leoPlugins.registerHandler( "headline-editing-finished", wm2 )

    bd = self.ekit.getBorder()
    vpb = self.view.getViewportBorder()
    if vpb:
        bd = sborder.CompoundBorder( bd, vpb )
    self.view.setViewportBorder( bd )
    self.sync()
    self.chapter = c.chapters.current_chapter
    g.doHook( "editor-created", editor = self )







#@+node:ekr.20070930184746.39:<< add EditorKit >>
self.cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider( self.c )
self.cdeterminer = weakref.proxy( cdeterminer )
#use_line_numbers = g.app.config.getBool( c, "use_line_numbering" )  
use_line_numbers = 0 
if use_line_numbers:
    pass
    #self.initializeLineNumbering()
else:
    self.numbers = None

#self.ekit = leoEditorKit( cdeterminer, self.numbers )
import leoEditorKit2
self.ekit = leoEditorKit2( self.editor, cdeterminer, leoSwingBody.Editor.icon )
self.editor.setEditorKit( self.ekit )
#self.editor.setDocument( ekit.createDefaultDocument() )
cdeterminer.setEditor( self.editor )
import JyLeoColorizer
self.jlc = JyLeoColorizer.JyLeoColorizer( self.editor, cdeterminer )
self.foldprotection = self.FoldProtector( self.editor, self.ekit )
self.editor.getDocument().setDocumentFilter( self.foldprotection )
#self.editor.getDocument().addUndoableEditListener( self.body )

#@-node:ekr.20070930184746.39:<< add EditorKit >>
#@+node:ekr.20070930184746.40:<< add autocompleter >>
self.autocompleter = self.autolistener( self )
self.editor.getDocument().addDocumentListener( self.autocompleter )
self.editor.addKeyListener( self.autocompleter )
g.app.config.manager.addNotificationDef( "use_autocompleter", self.useAutocompleter )
self.useAutocompleter()



#@-node:ekr.20070930184746.40:<< add autocompleter >>
#@+node:ekr.20070930184746.41:<< add scrollpane >>
spc = swing.ScrollPaneConstants
#self.view = swing.JScrollPane( layeredpane )
self.view = swing.JScrollPane( self.editor )
self.editorlomanager.jscrollpane = self.view
self.editor.addFocusListener( leoJSPFocusListener( self.view, self.c  ) )
self.view.setHorizontalScrollBarPolicy( swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER )
self._vport = vport = self.view.getViewport()
vport.addComponentListener( self.resizer2( self.editorlomanager ) )
vport.setScrollMode( vport.BLIT_SCROLL_MODE ) #fastest, removes alot of the flicker I saw
mwl = self.view.getMouseWheelListeners()[ 0 ]
self.editor.addMouseWheelListener( mwl )
self.frame.addMouseWheelListener( mwl )
self.epane.add( self.view )
#jtp.add( "Editor", self.epane )
self.tab_manager.add( "Editor", self.epane )
self.visible_informer.addCallback( self.epane, self.nowShowing )
#jtp.add( "Editor", self.view )
#cpane.add( self.view )
#@nonl
#@-node:ekr.20070930184746.41:<< add scrollpane >>
#@-node:ekr.20070930184746.38:__init__ (Editor)
#@+node:ekr.20070930184746.42:helper methods and classes
@others
#@nonl
#@+node:ekr.20070930184746.43:constuctor methods
# Just some methods the constructor calls to build the gui components.
#@+node:ekr.20070930184746.44:addMenus
def addMenus (self):

    self.menu = swing.JMenuBar()
    self.frame.setJMenuBar(self.menu)
    self.gotoMenu = gm = swing.JMenu("Goto")
    recmen = swing.JMenu("Recent")
    self.recent = []
    recmen.addMenuListener(leoSwingBody.Editor.RecentVisitsMenuListener(recmen,self.c,self.recent))
    gm.add(recmen)
    self.menu.add(gm)
    self.configureGotoMenu(gm)

    self.bodyMenu = body = swing.JMenu("Body")
    self.menu.add(body)
    directives = swing.JMenu("Directives")
    self.directiveMenu(directives)
    #self.menu.add( directives )
    body.add(directives)
    self.addLanguageMenu(body)
    headline = swing.JMenu("Headline")
    self.headlineMenu(headline)
    self.menu.add(headline)
    isSR = swing.JMenu("Insert<%s%s>" % ('<','>'))
    self.insertSR(isSR)
    body.add(isSR)


    insPath = swing.JMenuItem("Insert @path With File Dialog")
    self.addInsertPath(insPath)
    body.add(insPath)

    #self.addFootNodeMenu( body )

    config = g.app.config
    wrap = config.getBool(self.c,"body_pane_wraps")
    self.ekit.setLineWrap(wrap)
    wrapmenuitem = swing.JCheckBoxMenuItem("Wrap Lines")
    wrapmenuitem.setState(wrap)
    def wrapcommand (event):
        source = event.getSource()
        wrap = source.getState()
        self.ekit.setLineWrap(wrap)
        if wrap:
            self.view.setHorizontalScrollBarPolicy(swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER)
        else: self.view.setHorizontalScrollBarPolicy(swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED)

    wrapmenuitem.actionPerformed = wrapcommand
    body.add(wrapmenuitem)
    if config.getBool(self.c,"use_text_undo"):
        umenu = swing.JMenuItem("")
        rmenu = swing.JMenuItem("")
        gtnu = swing.JMenuItem("Goto Next Undo Spot")
        gtnr = swing.JMenuItem("Goto Next Redo Spot")
        vunstack = swing.JMenuItem("Visualise Undo Stack")
        clear_undo = swing.JMenuItem("Clear Undo")
        self._node_undoer = leoSwingUndo.NodeUndoer(self.c,umenu,rmenu,gtnu,gtnr,vunstack,clear_undo,self.editor)
        #print self._node_undoer
        body.addSeparator()
        body.add(umenu)
        body.add(rmenu)
        body.addSeparator()
        body.add(gtnu)
        body.add(gtnr)
        body.addSeparator()
        body.add(vunstack)
        body.add(clear_undo)
    else:
        self._node_undoer = None

    self.viewMenu = vmenu = swing.JMenu("Views")
    self.menu.add(vmenu)
    jmi = swing.JCheckBoxMenuItem("CompositeView")
    vmenu.add(jmi)
    jmi.actionPerformed = self.addCompositeView


    self.helpmenu = swing.JMenu("Help")
    self.menu.add(self.helpmenu)
    self.helpmenu.add(self.smacs_help(self.c,self.swingmacs,"Keystrokes"))
    self.helpmenu.add(self.smacs_help(self.c,self.swingmacs,"Commands"))
    self.helpmenu.add(self.autocompleter_help())
    if hasattr(self.body,'ebm'):
        ccomp = self.body.ebm.getControlPanelComponent()
        self.menu.add(ccomp)


#@-node:ekr.20070930184746.44:addMenus
#@+node:ekr.20070930184746.45:addMinibuffer
def addMinibuffer (self):

    self.minilabel = swing.JLabel()
    self.minibuffer = minibuffer = swing.JTextField(15)
    frame = swing.JPanel()
    frame.setLayout(swing.BoxLayout(frame,swing.BoxLayout.X_AXIS))
    frame.add(self.minilabel)
    frame.add(minibuffer)
    frame.setName("Minibufferbackground")
    self.epane.add(frame) # awt.BorderLayout.SOUTH )
    self.editorlomanager.minibuffer = frame
    #cpane = self.frame.getContentPane()
    #cpane.add( frame, awt.BorderLayout.SOUTH )
#@-node:ekr.20070930184746.45:addMinibuffer
#@+node:ekr.20070930184746.46:addCompleters
def addCompleters (self):

    config = g.app.config
    if config.getBool(self.c,"complete-<"):
        self.swingmacs.addCompleter("<",">")
    if config.getBool(self.c,"complete-("):
        self.swingmacs.addCompleter("(",")")
    if config.getBool(self.c,"complete-["):
        self.swingmacs.addCompleter("[","]")
    if config.getBool(self.c,"complete-{"):
        self.swingmacs.addCompleter("{","}")
    if config.getBool(self.c,"complete-'"):
        self.swingmacs.addCompleter("'","'")
    if config.getBool(self.c,'complete-"'):
        self.swingmacs.addCompleter('"','"')
    if config.getBool(self.c,"add_tab_for-:"):
        self.swingmacs.addTabForColon(True)




#@-node:ekr.20070930184746.46:addCompleters
#@+node:ekr.20070930184746.47:initializeEditor
def initializeEditor (self):


    self.editor = self.leoJTextPane(self.c)
    self.editor.setLineColor()
    self.body._current_editor = self.editor
    manager = g.app.config.manager
    wm1 = WeakMethod(self.editor,"setLineColor")
    manager.addNotificationDef("highlight_current_line",wm1)
    manager.addNotificationDef("current_line_highlight_color",wm1)
#@-node:ekr.20070930184746.47:initializeEditor
#@+node:ekr.20070930184746.48:initializeEditorColors
def initializeEditorColors (self):

    self.setEditorColors()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setEditorColors")
    manager.addNotificationDef('body_text_foreground_color',wm1)
    manager.addNotificationDef('body_text_background_color',wm1)
    manager.addNotificationDef('body_selection_color',wm1)
    manager.addNotificationDef('body_text_selected_color',wm1)


#@-node:ekr.20070930184746.48:initializeEditorColors
#@+node:ekr.20070930184746.49:initializeFont
def initializeFont (self):

    self.setFont()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setFont")
    manager.addNotificationDef("body_text_font_family",wm1)
    manager.addNotificationDef("body_text_font_size",wm1)
    manager.addNotificationDef("body_text_font_weight",wm1)

#@-node:ekr.20070930184746.49:initializeFont
#@+node:ekr.20070930184746.50:initializeCaret
def initializeCaret (self):

    self.setCaret()
    wm1 = WeakMethod(self,"setCaret")
    g.app.config.manager.addNotificationDef("which_caret",wm1)

#@-node:ekr.20070930184746.50:initializeCaret
#@+node:ekr.20070930184746.51:initializeLineNumbering
def initializeLineNumbering (self):

    fg, bg, cl = self.getLineNumberColors()
    #self.numbers = leoEditorKit.LeoNumberLabel( bg, fg, cl )
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setLineNumberColors")
    manager.addNotificationDef("line_number_background",wm1)
    manager.addNotificationDef("line_number_foreground",wm1)
    manager.addNotificationDef("line_number_current",wm1)

#@-node:ekr.20070930184746.51:initializeLineNumbering
#@+node:ekr.20070930184746.52:createCommanderCommander
def createCommanderCommander (self,menu):

    commandercommander = self.CommanderCommander(self.c,self.swingmacs,menu)
    self.swingmacs.addCommands(commandercommander,commandercommander.getAltXCommands())
#@nonl
#@-node:ekr.20070930184746.52:createCommanderCommander
#@-node:ekr.20070930184746.43:constuctor methods
#@+node:ekr.20070930184746.53:config methods
@others
#@+node:ekr.20070930184746.54:configureMedia
def configureMedia (self):

    c = self.c
    use_background = g.app.config.getBool(c,"use_media_background")
    if use_background:
        try:
            background_which = g.app.config.getString(c,"media_background_type")
            if background_which == 'image':
                self.setBackgroundImage()
            elif background_which == 'movie':
                movie = g.app.config.getString(c,"movie_location@as-filedialog")
                if movie:
                    self.background = swing.JPanel()
                    self.background.setOpaque(False)
                    import EditorBackgroundMovie
                    ebm = EditorBackgroundMovie(movie,self.background)
                    if ebm.loadOk():
                        self.epane.add(self.background)
                        self.editorlomanager.media = self.background
                        #self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
                        #self._vport.addChangeListener( self._resizer )
                        self.editor.setOpaque(False)
                        vport = self.view.getViewport()
                        vport.setOpaque(False)
                        self.view.setOpaque(False)
                        self.ebm = ebm
                        #print self.epm
                        ebm.addControllerToMenu(self.menu)
                    else: self.background = None
        finally:
            if not hasattr(self,'background'):
                self.background = None
    else:
        self.background = None
#@-node:ekr.20070930184746.54:configureMedia
#@+node:ekr.20070930184746.55:setBackgroundImage
def setBackgroundImage (self,notification=None,handback=None):

    c = self.c
    alpha = g.app.config.getFloat(c,"background_alpha")
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString(c,"image_location@as-filedialog")
    if image_path:
        imfile = java.io.File(image_path)
        if imfile.exists():
            bimage = imageio.ImageIO.read(imfile)
            if not hasattr(self,'background'):
                self.background = EditorBackground(bimage,bimage.getWidth(),bimage.getHeight(),alpha)
                self.epane.add(self.background)

            #    self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
            #    self._vport.addChangeListener( self._resizer )
            self.editor.setOpaque(False)
            vport = self.view.getViewport()
            vport.setOpaque(False)
            self.view.setOpaque(False)
            #self.epane.setBackedWidget( self.view.getViewport() )
            #self.epane.setImage( bimage )
            #self.epane.setAlpha( alpha )
            self.editorlomanager.media = self.background
            g.app.config.manager.addNotificationDef("background_alpha",self.setBackgroundImage)
            g.app.config.manager.addNotificationDef("image_location@as-filedialog",self.setBackgroundImage)

            #else:
            #    #self.background.setBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #    #self.background.repaint()


#@-node:ekr.20070930184746.55:setBackgroundImage
#@+node:ekr.20070930184746.56:useAutocompleter
def useAutocompleter (self,notification=None,handback=None):

    use = g.app.config.getBool(self.c,"use_autocompleter")
    if use:
        self.autocompleter.on = 1
    else:
        self.autocompleter.on = 0
        self.autocompleter.hideAutoBox()
#@nonl
#@-node:ekr.20070930184746.56:useAutocompleter
#@+node:ekr.20070930184746.57:setCaret
def setCaret (self,notification=None,handback=None):
    c = self.c
    if g.app.config.getString(c,"which_caret"):
        caret = g.app.config.getString(c,"which_caret")
        carets = {'Box': (self.SeeThroughBoxCaret,'box_color'),
                  'Underliner': (self.UnderlinerCaret,'underliner_color'),
                  'GhostlyLeo': (self.GhostlyLeoCaret,None),
                  'ImageCaret': (self.ImageCaret,None),
                  '<none>': (stext.DefaultCaret,None)}

        if caret == 'ImageCaret':
            try:
                path_to_image = g.app.config.getString(c,"path_to_caret_image@as-filedialog")
                ifile = java.io.File(path_to_image)
                cimage = imageio.ImageIO.read(ifile)
                #cicon = swing.ImageIcon( path_to_image )
                self.editor.setCaret(carets[caret](cimage))
            except java.lang.Exception, x:
                x.printStackTrace()
                g.es("Could not load image for caret")
        else:
            caret, color = carets [caret]
            args = None
            if color:
                color = g.app.config.getColor(c,color)
                color = getColorInstance(color)
                args = (color)
                self.editor.setCaret(caret(color))
            else:
                self.editor.setCaret(caret())
    self.editor.getCaret().addChangeListener(self.brackethighlighter)
#@-node:ekr.20070930184746.57:setCaret
#@+node:ekr.20070930184746.58:setFont
def setFont (self,notification=None,handback=None):

    config = g.app.config
    c = self.c
    family = config.get(c,"body_text_font_family","family")
    size = config.get(c,"body_text_font_size","size")
    weight = config.get(c,"body_text_font_weight","weight")
    slant = None
    font = config.getFontFromParams(c,"body_text_font_family","body_text_font_size",None,"body_text_font_weight")
    if font:
        self.editor.setFont(font)
#@nonl
#@-node:ekr.20070930184746.58:setFont
#@+node:ekr.20070930184746.59:setEditorColors
def setEditorColors (self,notification=None,handback=None):

    c = self.c

    fg = g.app.config.getColor(c,'body_text_foreground_color')
    bg = g.app.config.getColor(c,'body_text_background_color')
    sc = g.app.config.getColor(c,'body_selection_color')
    stc = g.app.config.getColor(c,'body_text_selected_color')

    fg = getColorInstance(fg,awt.Color.GRAY)
    bg = getColorInstance(bg,awt.Color.WHITE)
    sc = getColorInstance(sc,awt.Color.GREEN)
    stc = getColorInstance(stc,awt.Color.WHITE)

    self.editor.setForeground(fg)
    self.editor.setBackground(bg)
    self.editor.setSelectionColor(sc)
    self.editor.setSelectedTextColor(stc)


#@-node:ekr.20070930184746.59:setEditorColors
#@+node:ekr.20070930184746.60:setLineNumberColors
def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl

def setLineNumberColors (self,notification=None,background=None):

    fg, bg, cl = self.getLineNumberColors()
    if self.numbers:
        self.numbers.setBackground(bg)
        self.numbers.setForeground(fg)
        self.numbers.setCurrent(cl)

#@-node:ekr.20070930184746.60:setLineNumberColors
#@-node:ekr.20070930184746.53:config methods
#@+node:ekr.20070930184746.61:methods
#@+node:ekr.20070930184746.62:sync
def sync (self,pos=None):

    try:
        if pos == None:
            pos = self.c.currentPosition()

        if pos in self.recent:
            self.recent.remove(pos)
        else:
            if len(self.recent) == 10:
                self.recent.pop()
        self.recent.insert(0,pos)

        if self.lastPosition:
            self.foldprotection.cacheFolds(self.lastPosition.v.t)
        self.lastPosition = pos.copy()
        hs = pos.headString()
        bs = pos.bodyString()
        #self.editor.setText( bs )
        doc = self.editor.getDocument()
        doc.setPosition(pos)
        #doc.sync( bs )
        body = self.c.frame.body
        try:
            body.ignore_insert = 1
            self.jlc.ignoreEvents()
            self.foldprotection.clearFolds()
            self.foldprotection.defoldViews()
            doc.remove(0,doc.getLength())
            doc.insertString(0,bs,None)
            self.frame.setTitle(hs)
            self.jlc.recolorizenow()
            self.foldprotection.restoreFolds(pos.v.t)
            if hasattr(self,'_node_undoer'):
                self._node_undoer.setNode(pos)
        finally:
            self.jlc.watchEvents()
            body.ignore_insert = 0
    except Exception, x:
        pass
        #x.printStackTrace()

#@-node:ekr.20070930184746.62:sync
#@+node:ekr.20070930184746.63:nowShowing
def nowShowing (self):

    self.body._current_editor = self.editor
    self.sync()
#@-node:ekr.20070930184746.63:nowShowing
#@+node:ekr.20070930184746.64:menu methods
@others
#@nonl
#@+node:ekr.20070930184746.65:configureGotoMenu
def configureGotoMenu (self,menu):
    oltraveler = leoSwingBody.Editor.outlinetraveler(menu,self.c)
    menu.addMenuListener(oltraveler)
#@nonl
#@-node:ekr.20070930184746.65:configureGotoMenu
#@+node:ekr.20070930184746.66:directiveMenu
def directiveMenu (self,menu):

    import leoColor
    directives = []
    for z in leoColor.leoKeywords:
        directives.append(z)
    directives.sort()
    InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
    for z in directives:
        menu.add(InsertTextIntoBody(self.c,z))

#@-node:ekr.20070930184746.66:directiveMenu
#@+node:ekr.20070930184746.67:headlineMenu
def headlineMenu (self,menu):

    import leoNodes
    tnode = leoNodes.tnode()
    v = leoNodes.vnode(self.c,tnode)
    def getValue (names,self=v):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list(names)
    names.sort()
    SetHeadline = leoSwingBody.Editor.SetHeadline
    self.addSR(menu)
    for z in names:
        menu.add(SetHeadline(self.c,z))

    rmvSymbol = leoSwingBody.Editor.rmvSymbol
    rS = rmvSymbol(self.c,'@')
    menu.add(rS)
    SetHeadlineToSelection = leoSwingBody.Editor.SetHeadlineToSelection
    sTaction = SetHeadlineToSelection(self.c,"Set Headline to Selection")
    menu.add(sTaction)

#@-node:ekr.20070930184746.67:headlineMenu
#@+node:ekr.20070930184746.68:insertSR
def insertSR (self,menu):

    inSRMenuListener = leoSwingBody.Editor.inSRMenuListener
    menu.addMenuListener(inSRMenuListener(menu,self.c))
#@nonl
#@-node:ekr.20070930184746.68:insertSR
#@+node:ekr.20070930184746.69:addSR
def addSR (self,menu):

    class aa(swing.AbstractAction):

        def __init__ (self,c):
            swing.AbstractAction.__init__(self,'toggle <%s%s>' % ('<','>'))
            self.c = c

        def actionPerformed (self,event):
            cp = self.c.currentPosition()
            hs = cp.headString()
            hs = hs.strip()
            if hs.startswith('<%s' % '<') and hs.endswith('>%s' % '>'):
                hs = hs [2:]
                hs = hs [: -2]
            else:
                hs = '<%s%s%s>' % ('<',hs,'>')

            self.c.beginUpdate()
            cp.setHeadString(hs)
            self.c.endUpdate()

    menu.add(aa(self.c))
#@nonl
#@-node:ekr.20070930184746.69:addSR
#@+node:ekr.20070930184746.70:addLanguageMenu
def addLanguageMenu (self,pmenu):
    pass
@
    lmenu = swing.JMenu("language")
    kI = self.keywordInserter(lmenu,self.c)
    lmenu.addMenuListener(kI)
    pmenu.add(lmenu)
    lS = self.languageSetter(kI)
    pmenu.addMenuListener(lS)

#@-node:ekr.20070930184746.70:addLanguageMenu
#@+node:ekr.20070930184746.71:addInsertPath
def addInsertPath (self,menu):

    def __insertHeadline (event):

        jfc = swing.JFileChooser()
        jfc.setFileSelectionMode(jfc.DIRECTORIES_ONLY)
        jfc.setDialogTitle("Select Directory for %s%s" % ("@","path"))
        jfc.setApproveButtonText("Select")
        result = jfc.showOpenDialog(self.c.frame.top)
        if result == jfc.APPROVE_OPTION:
            sfile = jfc.getSelectedFile()
            self.c.frame.body.insertAtInsertPoint("%s %s" % ("@path",sfile.getAbsolutePath()))


    menu.actionPerformed = __insertHeadline


#@-node:ekr.20070930184746.71:addInsertPath
#@+node:ekr.20070930184746.72:addCompositeView
def addCompositeView (self,event):

    if not hasattr(self,'lcv'):
        import leoCompositeView
        jpanel = swing.JPanel(awt.BorderLayout())
        #self.jtab.addTab( "CompositeView", jpanel )
        #self.jtab.setSelectedComponent( jpanel )
        self.tab_manager.add("CompositeView",jpanel)
        self.lcv = lcv = leoCompositeView.CompositeView(self.c,jpanel)
        self.visible_informer.addCallback(jpanel,lambda: lcv.sync(force=1))
        self.body._current_editor = self.lcv.jtp
    else:
        parent = self.lcv.parent
        #if self.jtab.indexOfComponent( parent ) == -1:
        if not self.tab_manager.holdsComponent(parent):

            self.tab_manager.add("CompositeView",parent)
            #self.jtab.addTab( "CompositeView", parent )
            #self.jtab.setSelectedComponent( parent )
        else:
            #self.jtab.remove( parent )
            self.tab_manager.remove(parent)
#@-node:ekr.20070930184746.72:addCompositeView
#@+node:ekr.20070930184746.73:addFlashCardView
def addFlashCardView (self,event):

    import leoFlashCardView
    if not hasattr(self,'fcv'):
        jpanel = swing.JPanel(awt.BorderLayout())
        self.jtab.addTab("FlashCardView",jpanel)
        self.jtab.setSelectedComponent(jpanel)
        self.fcv = fcv = leoFlashCardView.FlashCardView(self.c,jpanel)
        self.visible_informer.addCallback(jpanel,lambda: fcv.sync(force=1))
    else:
        parent = self.fcv.parent
        if self.jtab.indexOfComponent(parent) == -1:
            self.jtab.addTab("FlashCardView",parent)
            self.jtab.setSelectedComponent(parent)
        else:
            self.jtab.remove(parent)
#@-node:ekr.20070930184746.73:addFlashCardView
#@+node:ekr.20070930184746.74:addFootNodeMenu
def addFootNodeMenu (self,menu):

    menu.addSeparator()
    addfn = swing.JMenuItem("Add FootNode")
    menu.add(addfn)
    rmvfn = swing.JMenu("Remove FootNode")
    menu.add(rmvfn)
    fnoderemover = self.footnoderemover(rmvfn,self.c)
    rmvfn.addMenuListener(fnoderemover)

    def addFootNode (event,c):

        pos = c.currentPosition()
        t = pos.v.t
        if not hasattr(t,"unknownAttributes"):
            uas = t.unknownAttributes = {}
            fn = []
            uas ["footnodes"] = fn
        else:
            uas = t.unknownAttributes
            if uas.has_key("footnodes"):
                fn = uas ["footnodes"]
            else:
                fn = []
                uas ["footnodes"] = fn

        jd = swing.JDialog()
        jd.title = "Add a FootNode"
        cpane = jd.getContentPane()
        cpane.setLayout(awt.BorderLayout())
        jtf = swing.JTextField()
        tborder1 = sborder.TitledBorder("Title")
        jtf.setBorder(tborder1)
        cpane.add(jtf,awt.BorderLayout.NORTH)
        jta = swing.JTextArea()
        jsp = swing.JScrollPane(jta)
        tborder2 = sborder.TitledBorder("FootNode")
        jsp.setBorder(tborder2)
        cpane.add(jsp)
        jp = swing.JPanel()
        b1 = swing.JButton("Cancel")
        b1.actionPerformed = lambda event, jd = jd: jd.dispose()
        jp.add(b1)
        b2 = swing.JButton("Ok")
        def ok (event,fn,jtf,jta,jd,c=c):
            headline = jtf.getText()
            body = jta.getText()
            fn.append((headline,body))
            c.frame.body.editor.ekit.relayout()
            jd.dispose()
        b2.actionPerformed = lambda event, fn = fn, jtf = jtf, jta = jta, jd = jd, c = c: ok(event,fn,jtf,jta,jd,c)
        jp.add(b2)
        cpane.add(jp,awt.BorderLayout.SOUTH)
        jd.size = (250,250)
        jd.preferredSize = (250,250)
        #jd.pack()
        g.app.gui.center_dialog(jd)
        jd.show()
    addfn.actionPerformed = lambda event, c = self.c: addFootNode(event,c)






#@-node:ekr.20070930184746.74:addFootNodeMenu
#@-node:ekr.20070930184746.64:menu methods
#@+node:ekr.20070930184746.75:implementation of FocusListener interface
def focusGained (self,fe):

    lasteditor = self.body.editor
    self.body.editor = self
    if self.lastPosition:
        if lasteditor != self:
            if self.chapter.isValid():
                cc = self.c.chapters.getChapter()
                if self.chapter != cc:
                    self.c.chapters.selectChapter(self.chapter)

                try:
                    self.c.beginUpdate() #This part if not done right can cause weird tree sync issues
                    lp = self.lastPosition
                    self.lastPosition = None
                    self.c.frame.tree.select(lp)
                finally:
                    self.c.endUpdate()
            else:
                self.sync()

    if hasattr(self,'_node_undoer'):
        self._node_undoer.setMenu()

def focusLost (self,fe):

    self.chapter = self.c.chapters.getChapter()
    if hasattr(self,'_node_undoer'):
        if self.lastPosition:
            self._node_undoer.checkSumNode(self.lastPosition.v.t)
#@-node:ekr.20070930184746.75:implementation of FocusListener interface
#@+node:ekr.20070930184746.76:detach and retach
def detach (self,event=None):

    self._parent2 = jf = swing.JFrame()
    bounds = self.frame.getBounds()
    self._parent.remove(self.frame)
    jf.getContentPane().add(self.frame)
    jf.setBounds(bounds)
    km = self.editor.getKeymap()
    k_and_a = self.c.frame.menu.keystrokes_and_actions
    for z in k_and_a.keys():
        action = k_and_a [z]
        km.addActionForKeyStroke(z,action)
    self._attached = False
    jf.visible = 1
    self._parent.validate()
    self._parent.repaint()


def retach (self,event=None):

    parent = self._parent2
    self._parent2 = None
    parent.remove(self.frame)
    self._parent.add(self.frame)
    parent.dispose()
    parent.visible = 0
    self._attached = True
    self._parent.validate()
    self._parent.repaint()
    self.frame.validate()
    self.frame.repaint()



#@-node:ekr.20070930184746.76:detach and retach
#@+node:ekr.20070930184746.77:turnSelectionIntoNode
def turnSelectionIntoNode (self):

    editor = self.editor
    txt = editor.getSelectedText()
    if txt == None: return
    spot = txt.find('\n')
    headline = txt [: spot]
    editor.replaceSelection("")
    c = self.c
    c.beginUpdate()
    cp = c.currentPosition()
    np = cp.insertAsLastChild()
    np.setHeadString(headline)
    np.setBodyStringOrPane(txt)
    c.endUpdate()
#@nonl
#@-node:ekr.20070930184746.77:turnSelectionIntoNode
#@+node:ekr.20070930184746.78:insertTextIntoBody
def insertTextIntoBody (self,txt):

    cpos = self.editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart(self.editor,cpos)
    doc = self.editor.getStyledDocument()
    txt2 = doc.getText(start,cpos-start)
    start_text = []
    for z in txt2:
        if z.isspace():
            start_text.append(z)
        else:
            start_text.append(' ')

    indent = ''.join(start_text)

    lines = txt.split('\n')
    if len(lines) > 1:
        for z in xrange(len(lines)-1):
            line = lines [z + 1]
            nwline = "%s%s" % (indent,line)
            lines [z + 1] = nwline
    itext = '\n'.join(lines)
    doc.insertString(cpos,itext,None)





#@-node:ekr.20070930184746.78:insertTextIntoBody
#@+node:ekr.20070930184746.79:splitNode
def splitNode (self):

    c = self.c
    editor = self.editor
    cpos = editor.getCaretPosition()
    start = swing.text.Utilities.getRowStart(editor,cpos)
    doc = editor.getDocument()
    nn_txt = doc.getText(start,doc.getLength()-start)
    doc.remove(start,doc.getLength()-start)
    c.beginUpdate()
    cp = c.currentPosition()
    nn = cp.insertAfter()
    nn.setBodyStringOrPane(nn_txt)
    c.selectPosition(nn)
    c.endUpdate()

    dc = DefCallable(lambda: c.frame.tree.editLabel(nn))
    ft = java.util.concurrent.FutureTask(dc)
    java.awt.EventQueue.invokeLater(ft)
#@-node:ekr.20070930184746.79:splitNode
#@+node:ekr.20070930184746.80:sectionReferenceToWidget
def sectionReferenceToWidget (self):

    c = self.c
    cp = c.currentPosition()
    bs = cp.bodyString()
    pattern = java.util.regex.Pattern.compile("<"+"<"+"[^<>]*>"+">")

    children = {}
    for z in cp.children_iter(copy=True):
        children [z.headString()] = z


    matcher = pattern.matcher(java.lang.String(bs))
    results = []
    while matcher.find():
        result = matcher.toMatchResult()
        results.append(result)

    doc = self.editor.getDocument()
    for z in results:
        begin = z.start()
        end = z.end()
        sr = bs [begin: end]
@
        if sr in children:
            jtp = swing.JTextArea()
            child = children [sr]
            jtp.setText(child.bodyString())
            jb = swing.JButton("Mooo")
            mas = swing.text.SimpleAttributeSet()
            swing.text.StyleConstants.setComponent(mas,jb)
            swing.text.StyleConstants.setForeground(mas,java.awt.Color.RED)
            doc.setCharacterAttributes(begin,end-begin,mas,1)
            doc.insertString(0,"\n",mas)
@c




#@-node:ekr.20070930184746.80:sectionReferenceToWidget
#@+node:ekr.20070930184746.81:chapterChanged
def chapterChanged (self,tag,*args,**kwords):

    try:
        chapter = args [0] ['chapter']
        if tag == "chapter-changed":
            if self.c.frame.body.editor is self:
                cp = chapter.getCurrentPosition() ; rp = chapter.getRootPosition()
                if cp or rp:
                    self.sync()
        elif tag == "chapter-removed":
            if self.c.frame.body.editor is self:
                self.sync()
    except java.lang.Exception, x:
        pass
#@-node:ekr.20070930184746.81:chapterChanged
#@+node:ekr.20070930184746.82:headlineChanged
def headlineChanged (self,tag,*args,**kwords):

    p = args [0] ['p']
    if self.lastPosition == p:
        self.frame.setTitle(p.headString())

#@-node:ekr.20070930184746.82:headlineChanged
#@+node:ekr.20070930184746.83:splitting the editor
@others
#@+node:ekr.20070930184746.84:splitVertically
def splitVertically (self,event):

    widget = self.editor
    parent = widget.getParent()

#@-node:ekr.20070930184746.84:splitVertically
#@+node:ekr.20070930184746.85:createEditor
def createEditor (self):

    editor = self.leoJTextPane(self.c)
    editor.setLineColor()
    manager = g.app.config.manager
    manager.addNotificationDef("highlight_current_line",editor.setLineColor)
    manager.addNotificationDef("current_line_highlight_color",editor.setLineColor)
    cdeterminer = cdeterminer = leoSwingBody.Editor.ColorKeywordsProvider(self.c)

    use_line_numbers = g.app.config.getBool(c,"use_line_numbering")
    if use_line_numbers:
        #self.initializeLineNumbering()
        fg, bg, cl = self.getLineNumberColors()
        numbers = leoEditorKit.LeoNumberLabel(bg,fg,cl)
        #manager = g.app.config.manager
        #manager.addNotificationDef( "line_number_background", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_foreground", self.setLineNumberColors )
        #manager.addNotificationDef( "line_number_current", self.setLineNumberColors )
    else:
        numbers = None

    ekit = leoEditorKit(cdeterminer,numbers)
    editor.setEditorKit(ekit)
    cdeterminer.setEditor(editor)
    editor.getDocument().addUndoableEditListener(self.body)
    editor.addMouseListener(leoSwingBody.UtilityRightClick(c,detach_retach=True,editor=self))

    return editor
#@nonl
#@-node:ekr.20070930184746.85:createEditor
#@-node:ekr.20070930184746.83:splitting the editor
#@-node:ekr.20070930184746.61:methods
#@+node:ekr.20070930184746.86:helper classes
@
In general these are subclasses of java gui listeners.

In CPython and Tk you would be using callbacks most of the time, a def or a lambda.
#@+node:ekr.20070930184746.36:RecentVisitsMenuListener
class RecentVisitsMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c,recent):
        self.menu = menu
        self.c = c
        self.recent = recent

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        goNode = leoSwingBody.Editor.goNode
        for z in self.recent:
            if z:
                menu.add(goNode(z,self.c))
#@-node:ekr.20070930184746.36:RecentVisitsMenuListener
#@+node:ekr.20070930184746.34:colorizer callback
class ColorKeywordsProvider(leoEditorKit2.ColorDeterminer,sevent.DocumentListener):

    @others
#@+node:ekr.20071001071356:__init__
def __init__ (self,c):

    lb = leoLanguageManager.LanguageManager.getLanguageBundle(c)
    for z in dir(lb):
        if not callable(getattr(lb,z)):
            setattr(self,z,getattr(lb,z))

    self.c = c
    self.last_p = None
    self.last_language = None
    self.editor = None
    self.error_map = util.HashMap()
    fg, bg, cl = self.getLineNumberColors()
    self.line_fg = fg ; self.line_bg = bg ; self.line_cl = cl
    self.queue = concurrent.LinkedBlockingQueue()
    self.c.invisibleWatchers.append(self)
    return


#@-node:ekr.20071001071356:__init__
#@+node:ekr.20071001071356.1:changedUpdate
def changedUpdate (self,event):
    pass #this does Attribute changes


#@-node:ekr.20071001071356.1:changedUpdate
#@+node:ekr.20071001071356.2:checkForLanguageChange
def checkForLanguageChange (self,event):

    language = LeoUtilities.scanForLanguageOnLine(self.editor)
    if language:
        #if not hasattr( self, "%s_keywords" % language ):
        if self.last_language != language:
            #self.editor.repaint()
            self.last_language = language
            jlc = self.c.frame.body.editor.jlc
            jlc.fullrecolorize()



#@-node:ekr.20071001071356.2:checkForLanguageChange
#@+node:ekr.20071001071356.3:drawrectangle
def drawrectangle (self):
    return self._drawrectangle

#@-node:ekr.20071001071356.3:drawrectangle
#@+node:ekr.20071001071356.4:getColoredTokens
def getColoredTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language

    leoLanguageManager.LanguageManager.setLanguageInEffect(self.c,language)

    if language == None:
        language = "python"
    if hasattr(self,"%s_keywords" % language):
        return getattr(self,"%s_keywords" % language)
    else:
        hm = leoLanguageManager.LanguageManager.loadLanguage(self.c,language)
        setattr(self,"%s_keywords" % language,hm)
        return hm


#@-node:ekr.20071001071356.4:getColoredTokens
#@+node:ekr.20071001071356.5:getCommentColor
def getCommentColor (self):
    return self._commentColor

#@-node:ekr.20071001071356.5:getCommentColor
#@+node:ekr.20071001071356.6:getCommentTokens
def getCommentTokens (self):

    cp = self.c.currentPosition().copy()
    if cp != self.last_p:
        #language = g.scanForAtLanguage( self.c, cp )
        language = LeoUtilities.scanForLanguage(cp)
        self.last_p = cp
        self.last_language = language
    else:
        language = self.last_language
    if self.comment_cache.has_key(language):
        return self.comment_cache [language]
    else:
        rv = g.set_delims_from_language(language)
        rv = jarray.array(rv,java.lang.String)
        self.comment_cache [language] = rv
        return rv
    #delim1,delim2, delim3 = g.set_delims_from_language( language )
    #return [ delim1, delim2, delim3 ]

#@-node:ekr.20071001071356.6:getCommentTokens
#@+node:ekr.20071001071356.7:getCurrentLineNumberForeground
def getCurrentLineNumberForeground (self):
    return self.line_cl

#@-node:ekr.20071001071356.7:getCurrentLineNumberForeground
#@+node:ekr.20071001071356.8:getDocColor
def getDocColor (self):
    return self._docColor

#@-node:ekr.20071001071356.8:getDocColor
#@+node:ekr.20071001071356.9:getFoldedBackgroundColor
def getFoldedBackgroundColor (self):
    return self._fbColor

#@-node:ekr.20071001071356.9:getFoldedBackgroundColor
#@+node:ekr.20071001071356.10:getFoldedForegroundColor
def getFoldedForegroundColor (self):
    return self._ffColor



#@-node:ekr.20071001071356.10:getFoldedForegroundColor
#@+node:ekr.20071001071356.11:getFootNodeBackgroundColor
def getFootNodeBackgroundColor (self):
    return self._fnbgColor

#@-node:ekr.20071001071356.11:getFootNodeBackgroundColor
#@+node:ekr.20071001071356.12:getFootNodeForegroundColor
def getFootNodeForegroundColor (self):
    return self._fnfgColor


#@-node:ekr.20071001071356.12:getFootNodeForegroundColor
#@+node:ekr.20071001071356.13:getFootNodes
def getFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            sb = java.lang.StringBuilder()
            for z in fn:
                sb.append(z[0]).append(" : ").append(z[1])
                if not z [1].endswith("\n"): sb.append("\n")
            return sb.toString()
    return ""


#@-node:ekr.20071001071356.13:getFootNodes
#@+node:ekr.20071001071356.14:getInvisiblesBlock
def getInvisiblesBlock (self):
    return self._invisibleBlock

#@-node:ekr.20071001071356.14:getInvisiblesBlock
#@+node:ekr.20071001071356.15:getInvisiblesDot
def getInvisiblesDot (self):
    return self._invisibleDot

#@-node:ekr.20071001071356.15:getInvisiblesDot
#@+node:ekr.20071001071356.16:getLineNumberBackground
def getLineNumberBackground (self):
    return self.line_bg

#public boolean useLineNumbers();
#public Color getLineNumberForeground();
#public Color getCurrentLineNumberForeground();
#public Color getLineNumberBackground();
#@-node:ekr.20071001071356.16:getLineNumberBackground
#@+node:ekr.20070930184746.35:getLineNumberColors
def getLineNumberColors (self):

    c = self.c

    bg = g.app.config.getColor(c,"line_number_background")
    fg = g.app.config.getColor(c,"line_number_foreground")
    cl = g.app.config.getColor(c,"line_number_current")
    try:
        bg = getColorInstance(bg)
        if bg == None: bg = awt.Color.BLACK
        fg = getColorInstance(fg)
        if fg == None: fg = awt.Color.RED
        cl = getColorInstance(cl)
        if cl == None: cl = awt.Color.YELLOW
    except:
        bg = awt.Color.BLACK
        fg = awt.Color.RED
        cl = awt.Color.YELLOW
    return fg, bg, cl



#@-node:ekr.20070930184746.35:getLineNumberColors
#@+node:ekr.20071001071356.17:getLineNumberForeground
def getLineNumberForeground (self):
    return self.line_fg

#@-node:ekr.20071001071356.17:getLineNumberForeground
#@+node:ekr.20071001071356.18:getNumericColor
def getNumericColor (self):
    return self._numericcolor

#@-node:ekr.20071001071356.18:getNumericColor
#@+node:ekr.20071001071356.19:getOperators
def getOperators (self):
    return util.HashMap()


#@-node:ekr.20071001071356.19:getOperators
#@+node:ekr.20071001071356.20:getPunctuationColor
def getPunctuationColor (self):
    return self._punctuationColor

#@-node:ekr.20071001071356.20:getPunctuationColor
#@+node:ekr.20071001071356.21:getRectangleColor
def getRectangleColor (self):
    return self._rectanglecolor

#@-node:ekr.20071001071356.21:getRectangleColor
#@+node:ekr.20071001071356.22:getSectionReferenceColor
def getSectionReferenceColor (self):
    return self._sectionNameColor

#@-node:ekr.20071001071356.22:getSectionReferenceColor
#@+node:ekr.20071001071356.23:getStringColor
def getStringColor (self):
    return self._stringColor

#@-node:ekr.20071001071356.23:getStringColor
#@+node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
def getUndefinedSectionReferenceColor (self):
    return self._undefinedSectionNameColor

#@-node:ekr.20071001071356.24:getUndefinedSectionReferenceColor
#@+node:ekr.20071001071356.25:hasFootNodes
def hasFootNodes (self):

    cp = self.c.currentPosition()
    t = cp.v.t
    if hasattr(t,"unknownAttributes"):
        uas = t.unknownAttributes
        if uas.has_key("footnodes"):
            fn = uas ["footnodes"]
            if fn: return True
    return False

#@-node:ekr.20071001071356.25:hasFootNodes
#@+node:ekr.20071001071356.26:insertUpdate
def insertUpdate (self,event):
    self.checkForLanguageChange(event)

#@-node:ekr.20071001071356.26:insertUpdate
#@+node:ekr.20071001071356.27:notify
def notify (self):
    self.c.frame.body.editor.ekit.showInvisibles(self.c.showInvisibles)

#@-node:ekr.20071001071356.27:notify
#@+node:ekr.20071001071356.28:removeUpdate
def removeUpdate (self,event):
    self.checkForLanguageChange(event)


#@-node:ekr.20071001071356.28:removeUpdate
#@+node:ekr.20071001071356.29:setEditor
def setEditor (self,editor):
    self.editor = editor
    doc = editor.getDocument()
    doc.addDocumentListener(self)


#@-node:ekr.20071001071356.29:setEditor
#@+node:ekr.20071001071356.30:showInvisibles
def showInvisibles (self):
    return self.c.showInvisibles

#@-node:ekr.20071001071356.30:showInvisibles
#@+node:ekr.20071001071356.31:underline
def underline (self):
    return self._underline

#@-node:ekr.20071001071356.31:underline
#@+node:ekr.20071001071356.32:useLineNumbers
def useLineNumbers (self):
    return g.app.config.getBool(self.c,"use_line_numbering")

#@-node:ekr.20071001071356.32:useLineNumbers
#@+node:ekr.20071001071356.33:whichInvisible
def whichInvisible (self):
    return self._which_invisible

#@-node:ekr.20071001071356.33:whichInvisible
#@-node:ekr.20070930184746.34:colorizer callback
#@+node:ekr.20070930184746.33:class insTx
class InsertTextIntoBody(swing.AbstractAction):

    def __init__ (self,c,txt):
        swing.AbstractAction.__init__(self,txt)
        self.txt = txt
        self.c = c

    def actionPerformed (self,event):

        editor = self.c.frame.body.editor.editor
        pos = editor.getCaretPosition()
        #editor.insert( self.txt, pos )
        doc = editor.getDocument()
        doc.insertString(pos,self.txt,None)



class SetHeadline(InsertTextIntoBody):

    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        newHeadString = "%s %s" % (self.txt,hS)
        cp.setHeadString(newHeadString)


class SetHeadlineToSelection(InsertTextIntoBody):
    def __init__ (self,c,txt):
        leoSwingBody.Editor.InsertTextIntoBody.__init__(self,c,txt)

    def actionPerformed (self,event):

        txt = self.c.frame.body.editor.editor.getSelectedText()
        if txt:
            cp = self.c.currentPosition()
            cp.setHeadString(txt)



class rmvSymbol(swing.AbstractAction):
    def __init__ (self,c,symbol):
        swing.AbstractAction.__init__(self,"remove %s" % symbol)
        self.c = c
        self.symbol = symbol

    def actionPerformed (self,event):

        cp = self.c.currentPosition()
        hS = cp.headString()
        if hS.startswith(self.symbol):
            hS = hS.split()
            hS = hS [1:]
            hS = " ".join(hS)
            cp.setHeadString(hS)



class inSRMenuListener(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        menu = self.menu
        menu.removeAll()
        cp = self.c.currentPosition()
        InsertTextIntoBody = leoSwingBody.Editor.InsertTextIntoBody
        for z in cp.children_iter():
            hS = z.headString()
            hS = hS.strip()
            if hS.startswith("<%s" % '<') and hS.endswith(">%s" % ">"):
                menu.add(InsertTextIntoBody(self.c,hS))

#@-node:ekr.20070930184746.33:class insTx
#@+node:ekr.20070930184746.87:resizer --keeps components sized right
@
class resizer(aevent.ComponentAdapter,sevent.ChangeListener):
    '''This class keeps the Editor size in sync with the JLayeredPane.
       It also sets where the line numbers go and where, if present,
       a background image goes.'''
    def __init__ (self,editor,side='Left'):
        self.editor = editor
        self.viewPort = self.editor.view.getViewport()
        self.vsbar = self.editor.view.getVerticalScrollBar()
        self.side = side
    def componentResized (self,event):
        source = event.getSource()
        size = source.getSize()
        editor = self.editor.editor
        esize = editor.getSize()
        editor = self.editor.editor
        visRect = self.viewPort.getViewRect() #was once getVisibleRect, bad choice...
        if self.editor.numbers:
            numbers = self.editor.numbers
            lnsize = numbers.getSize()
            if lnsize.width == 0: lnsize.width = 30
            nswidth = size.width- lnsize.width
            nvwidth = visRect.width- lnsize.width
            if esize.height != size.height or esize.width not in (nvwidth,nswidth):
                if visRect.width > 0:
                    size.width = nvwidth
                else:
                    size.width = nswidth
                editor.setSize(size)
                if self.side == 'Left':
                    editor.setLocation(lnsize.width,0)
                else:
                    editor.setLocation(0,0)
                    numbers.setLocation(size.width,0)
            numsize = numbers.getSize()
            nlocation = numbers.getLocation()
            esize = editor.getSize()
            edheight = esize.height
            edwidth = esize.width
            lnsize.height = edheight
            if numsize.height < lnsize.height:
                numbers.setSize(lnsize)
                if self.side == 'Left':
                    numbers.setLocation(0,0)
                else:
                    numbers.setLocation(edwidth,0)
        else:
            self.editor.editor.setSize(size)
            self.editor.editor.setLocation(0,0)
        if self.editor.background:
            self.stateChanged(None)


    def stateChanged (self,event):
        editor = self.editor.editor
        background = self.editor.background
        #visRect = editor.getVisibleRect()
        visRect = self.viewPort.getViewRect()
        x = editor.getX()
        minus = x
        if x == 0 and self.editor.numbers != None:
            minus = self.editor.numbers.getSize().width
        background.setSize(visRect.width-minus,visRect.height)
        background.setLocation(x,visRect.y)
        self.editor.layeredpane.moveToBack(background)
#@nonl
#@-node:ekr.20070930184746.87:resizer --keeps components sized right
#@+node:ekr.20070930184746.88:resizer2
class resizer2(aevent.ComponentAdapter):

    def __init__ (self,layoutmanager):
        aevent.ComponentAdapter.__init__(self)
        self.layoutmanager = layoutmanager

    def componentResized (self,event):
        self.layoutmanager.layoutMedia()
#@nonl
#@-node:ekr.20070930184746.88:resizer2
#@+node:ekr.20070930184746.89:gonode -- actionPerformed takes user to node
class goNode(swing.AbstractAction):
    def __init__ (self,pos,c):
        swing.AbstractAction.__init__(self,pos.headString())
        self.pos = pos.copy()
        self.c = c

    def actionPerformed (self,event):

        self.c.frame.tree.select(self.pos)
#@nonl
#@-node:ekr.20070930184746.89:gonode -- actionPerformed takes user to node
#@+node:ekr.20070930184746.90:outlinetraveler --allows the user to traverse the tree quickly
class outlinetraveler(sevent.MenuListener):

    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        count = self.menu.getMenuComponentCount()
        for z in xrange(1,count):
            self.menu.remove(1)

        cp = self.c.currentPosition()
        self._addMenu("Parents",self.menu,cp.parents_iter(),cp)
        self._addMenu("Siblings",self.menu,cp.siblings_iter(),cp)
        self._addMenu("Children",self.menu,cp.children_iter(),cp)

    def _addMenu (self,name,menu,iterator,cp):

        goNode = leoSwingBody.Editor.goNode
        gmenu = swing.JMenu(name)
        shouldAdd = True
        for z in iterator:
            if shouldAdd:
                if not cp == z:
                    shouldAdd = False
                    menu.add(gmenu)
            if not cp == z:
                gmenu.add(goNode(z,self.c))
            else:
                gmenu.addSeparator()

#@-node:ekr.20070930184746.90:outlinetraveler --allows the user to traverse the tree quickly
#@+node:ekr.20070930184746.91:footnoderemover
class footnoderemover(sevent.MenuListener):

    def __init__ (self,menu,c):
            self.menu = menu
            self.c = c

    def menuCanceled (self,event):
        pass

    def menuDeselected (self,event):
        pass

    def menuSelected (self,event):

        self.menu.removeAll()
        #count = self.menu.getMenuComponentCount()
        #for z in xrange( 1 , count ):
        #    self.menu.remove( 1 )

        pos = self.c.currentPosition()
        t = pos.v.t
        if hasattr(t,"unknownAttributes"):
            uas = t.unknownAttributes
            if uas.has_key("footnodes"):
                footnodes = uas ["footnodes"]
                def rmv (item,footnodes=footnodes,c=self.c):
                    footnodes.remove(item)
                    c.frame.body.editor.ekit.relayout()

                for x in xrange(len(footnodes)):
                    fnood = footnodes [x]
                    jmi = swing.JMenuItem(fnood[0])
                    jmi.actionPerformed = lambda event, item = fnood: rmv(item)
                    self.menu.add(jmi)

#@-node:ekr.20070930184746.91:footnoderemover
#@+node:ekr.20070930184746.92:keywordInserter -- allows the user to insert language keywords
@
class keywordInserter(sevent.MenuListener):
    def __init__ (self,menu,c):
        self.menu = menu
        self.c = c
        self.lastlanguage = None
    def setLanguageName (self):
        cp = self.c.currentPosition()
        self.language = language = g.scanForAtLanguage(self.c,cp)
        self.menu.setText(language)
    def menuCanceled (self,event):
        pass
    def menuDeselected (self,event):
        pass
    def menuSelected (self,event):
        #cp = self.c.currentPosition()
        #language = g.scanForAtLanguage( self.c, cp )
        language = self.language
        if language == self.lastlanguage: return
        self.lastlanguage = language
        print dir(leoLanguageManager.LanguageManager)
        if language == None:
            m = leoLanguageManager.LanguageManager.python_tokens
        else:
            m = getattr(leoLanguageManager.LanguageManager,"%s_tokens" % language)

        m.sort()
        self.menu.removeAll()
        for z in m:
            self._addInserter(z)
    def _addInserter (self,name):
        self.menu.add(leoSwingBody.Editor.InsertTextIntoBody(self.c,name))

class languageSetter(sevent.MenuListener):
    def __init__ (self,kWI):
        self._kWI = kWI
    def menuCanceled (self,event):
        pass
    def menuDeselected (self,event):
        pass
    def menuSelected (self,event):
        self._kWI.setLanguageName()
#@-node:ekr.20070930184746.92:keywordInserter -- allows the user to insert language keywords
#@+node:ekr.20070930184746.93:swingmacs help
class smacs_help(swing.AbstractAction):

    class clz(swing.AbstractAction):
        def __init__ (self,tl):
            swing.AbstractAction.__init__(self,"Close")
            self.tl = tl


        def actionPerformed (self,event):
            self.tl.visible = 0
            self.tl.dispose()

    def __init__ (self,c,emacs,which):

        if which == 'Keystrokes':
            swing.AbstractAction.__init__(self,"Emacs Keystrokes")
        else:
            swing.AbstractAction.__init__(self,"Emacs Commands")

        self.emacs = weakref.proxy(emacs)
        self.which = which
        fg = g.app.config.getColor(c,'body_text_foreground_color')
        bg = g.app.config.getColor(c,'body_text_background_color')
        sc = g.app.config.getColor(c,'body_selection_color')
        stc = g.app.config.getColor(c,'body_text_selected_color')

        self.fg = getColorInstance(fg,awt.Color.GRAY)
        self.bg = getColorInstance(bg,awt.Color.WHITE)
        self.sc = getColorInstance(sc,awt.Color.GREEN)
        self.stc = getColorInstance(stc,awt.Color.WHITE)

    def actionPerformed (self,event):

        tl = swing.JFrame(title=self.which)
        ta = swing.JTextArea()
        ta.setForeground(self.fg)
        ta.setBackground(self.bg)
        ta.setSelectionColor(self.sc)
        ta.setSelectedTextColor(self.stc)
        ta.setEditable(False)
        ta.setLineWrap(True)
        sp = swing.JScrollPane(ta)
        tl.getContentPane().add(sp)
        if self.which == 'Keystrokes':
            ta.setText(self.emacs.getHelp())
        else:

            ta.setText(self.emacs.ax.getCommandHelp())
        gui = g.app.gui


        cbutt = swing.JButton(self.clz(tl))
        tl.getContentPane().add(cbutt,awt.BorderLayout.SOUTH)
        tkit = awt.Toolkit.getDefaultToolkit()
        size = tkit.getScreenSize()
        tl.setSize(size.width/2,size.height/2)
        tl.setPreferredSize(tl.getSize())
        x, y = g.app.gui._calculateCenteredPosition(tl)
        tl.setLocation(x,y)
        ta.setCaretPosition(0)
        tl.visible = 1


#@-node:ekr.20070930184746.93:swingmacs help
#@+node:ekr.20070930184746.94:autocompleter help
class autocompleter_help(swing.AbstractAction):

    def __init__ (self):
        swing.AbstractAction.__init__(self,"How to use the Autocompleter")

    def getText (self):

        htext = '''
        The Autcompleter appears upon typing of the '.' character.  Upon
        typing this character an in memory database is searched for the matching prefix.
        For example:
            object.toString  appears in a node.
            Typing 'object.' will bring the autocompleter box up with 'toString' as an option.

            Keystrokes that manipulate the autobox:
            Ctrl - this inserts the currently selected word
            Alt-Up, Alt-Down - these move the selection up and down.
            Esc - desummons the autobox

        The autobox will select the best prefix you have typed so far.  To extend the last example:
        typing 'to' will select 'toString'.  It will not enter the text until the user types 'Ctrl'
        or selects an item with the mouse.'''

        return htext

    def actionPerformed (self,event):
        tl = swing.JFrame(title='Autocompleter Help')
        ta = swing.JTextArea()
        ta.setEditable(False)
        sp = swing.JScrollPane(ta)
        tl.getContentPane().add(sp)
        #ta.setText( self.emacs.getHelp() )
        ta.setText(self.getText())
        gui = g.app.gui
        tl.setSize(600,400)
        spot = gui._calculateCenteredPosition(tl)
        tl.setLocation(spot[0],spot[1])
        class clz(swing.AbstractAction):
            def __init__ (self):
                swing.AbstractAction.__init__(self,"Close")
            def actionPerformed (self,event):
                tl.visible = 0
                tl.dispose()
        cbutt = swing.JButton(clz())
        tl.getContentPane().add(cbutt,awt.BorderLayout.SOUTH)
        tl.visible = 1
#@nonl
#@-node:ekr.20070930184746.94:autocompleter help
#@+node:ekr.20070930184746.95:class FoldProtector
class FoldProtector(stext.DocumentFilter):

    cachedfolds = {}

    def __init__ (self,editor,ekit):
        stext.DocumentFilter.__init__(self)
        self.folds = []
        self.ekit = ekit
        self.editor = editor
        self.doc = editor.getDocument()
        self.editor.addMouseListener(self.Defolder(self))

    def cacheFolds (self,t):
        if self.folds:
            for z in self.folds:
                z.persist(self.doc)
            self.cachedfolds [t] = self.folds

    def defoldViews (self):
        self.ekit.defoldViews()

    def restoreFolds (self,t):
        if self.cachedfolds.has_key(t):
            self.folds = self.cachedfolds [t]
            doc = self.editor.getDocument()
            for x in xrange(len(self.folds)):
                z = self.folds [x]
                if z.restore(doc):
                    self.foldWithoutAdding(z.pos1,z.pos2)
                else:
                    self.folds.remove(z)
                    g.es("Removing Fold(%s,%s), no longer valid" % (z.pos1,z.pos2),color="red")
        else:
            self.folds = []

    def foldSelection (self):

        start = self.editor.getSelectionStart()
        end = self.editor.getSelectionEnd()
        if start == end: return
        if start > end:
            s1 = start
            start = end
            end = s1
        cp = self.editor.getCaretPosition()
        self.editor.setCaretPosition(cp)
        self.editor.moveCaretPosition(cp)
        paragraph1 = stext.Utilities.getParagraphElement(self.editor,start)
        paragraph2 = stext.Utilities.getParagraphElement(self.editor,end)
        self.fold(paragraph1.getStartOffset(),paragraph2.getEndOffset()-1)


    def fold (self,start,end):

        fold = self.addFold(start,end,self.editor)
        self.ekit.fold(fold.pos1,fold.pos2)
        start = fold.pos1.getOffset() ; end = fold.pos2.getOffset()
        for z in copy.copy(self.folds):
            if z == fold: continue
            test1 = z.pos1.getOffset()
            test2 = z.pos2.getOffset()
            if start <= test1 and end > test1:
                self.folds.remove(z) #the folds are now the same


    def foldWithoutAdding (self,pos1,pos2):
        self.ekit.fold(pos1,pos2)

    def areLinesInFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 <= start and end2 >= end: return True
        return False

    def doLinesIntersectFold (self,start,end):

        doc = self.doc
        s = doc.getParagraphElement(start)
        e = doc.getParagraphElement(end)
        for z in self.folds:
            p1 = doc.getParagraphElement(z.pos1.getOffset())
            p2 = doc.getParagraphElement(z.pos2.getOffset())
            while p1 != p2:
                if p1 == e or p1 == s: return True
                p1 = doc.getParagraphElement(p1.getEndOffset())
            else:
                if p1 == e or p1 == s: return True
        return False

    def areLinesSurroundingFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start <= start2 and end >= end2: return True
        return False

    def getFold (self,start,end):
        for z in self.folds:
            start2 = z.pos1.getOffset()
            end2 = z.pos2.getOffset()
            if start2 <= start and end2 >= end: return z
        return None

    def isFolded (self,x,y):
        return self.ekit.isFolded(x,y)

    def isXInIconArea (self,x):

        i = self.ekit.getFoldIconX()
        if i >= x: return True
        return False

    def removeFold (self,fold):
        self.unfold(fold.pos1,fold.pos2)
        self.folds.remove(fold)

    def unfold (self,pos1,pos2):
        self.ekit.unfold(pos1,pos2)

    def unfoldSpot (self,x,y):

        i = self.editor.viewToModel(awt.Point(x,y))
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if i >= z.pos1.getOffset() and i <= z.pos2.getOffset():
                self.unfold(z.pos1,z.pos2)
                self.folds.remove(z)
                break

    def addFold (self,start,end,editor):

        doc = editor.getDocument()
        pos1 = doc.createPosition(start)
        pos2 = doc.createPosition(end)
        fold = self.Fold(pos1,pos2)
        self.folds.append(fold)
        return fold

    def clearFolds (self):
        self.folds = []


    @others





#@+node:ekr.20070930184746.96:DocumentFilter interface
def insertString (self,fb,offset,data,attr):

    if self.folds:
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if not z.isInsertLegal(offset,fb.getDocument()):
                return

    fb.insertString(offset,data,attr)

def remove (self,fb,offset,length):

    if self.folds:
        for z in self.folds:
            if not z.isRemoveLegal(offset,length,fb.getDocument()):
                return
    fb.remove(offset,length)

def replace (self,fb,offset,length,text,attrs):

    if self.folds:
        for x in xrange(len(self.folds)):
            z = self.folds [x]
            if not z.isRemoveLegal(offset,length,fb.getDocument()):
                return
    fb.replace(offset,length,text,attrs)
#@nonl
#@-node:ekr.20070930184746.96:DocumentFilter interface
#@+node:ekr.20070930184746.97:moveSelectionUp
def moveSelectionUp (self):

    start = self.editor.getSelectionStart()
    end = self.editor.getSelectionEnd()
    if (self.areLinesSurroundingFold(start,end) or self.doLinesIntersectFold(start,end)): return
    if start > end:
        s1 = start
        start = end
        end = start
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement(start)
    p2 = doc.getParagraphElement(end)
    above = doc.getParagraphElement(p1.getStartOffset()-1)
    << move partial selection >>

    if (self.areLinesInFold(above.getStartOffset(),above.getEndOffset()-1)):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold(above.getStartOffset(),above.getEndOffset()-1)
        self.removeFold(fold)
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText(start,end-start)
        txt2 = doc.getText(fstart,fend-fstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(fstart,end-fstart)
        nwtxt = "%s\n%s" % (txt,txt2)
        doc.insertString(fstart,nwtxt,None)
        self.fold(fstart+len(txt)+1,end)
        para = doc.getParagraphElement(fstart)
        para2 = doc.getParagraphElement(fstart+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)

    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText(start,end-start)
        sstart = above.getStartOffset()
        txt2 = doc.getText(sstart,above.getEndOffset()-sstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(sstart,end-sstart)
        txt3 = "%s\n%s" % (txt,txt2)
        doc.insertString(sstart,txt3,None)
        para = doc.getParagraphElement(sstart)
        para2 = doc.getParagraphElement(sstart+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)


#@+node:ekr.20070930184746.98:<<move partial selection>>
if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText(start,end-start)
    if not txt.endswith("\n"): txt = txt + "\n"
    self.editor.replaceSelection("")
    pstart = p1.getStartOffset()
    doc.insertString(p1.getStartOffset(),txt,None)
    para = doc.getParagraphElement(pstart)
    para2 = doc.getParagraphElement(pstart+len(txt)-1)
    if cpstart:
        self.editor.setCaretPosition(para2.getEndOffset()-1)
        self.editor.moveCaretPosition(para.getStartOffset())
    else:
        self.editor.setCaretPosition(para.getStartOffset())
        self.editor.moveCaretPosition(para2.getEndOffset()-1)
    return
#@nonl
#@-node:ekr.20070930184746.98:<<move partial selection>>
#@-node:ekr.20070930184746.97:moveSelectionUp
#@+node:ekr.20070930184746.99:moveSelectionDown
def moveSelectionDown (self):

    start = self.editor.getSelectionStart()
    end = self.editor.getSelectionEnd()
    if (self.areLinesSurroundingFold(start,end) or self.doLinesIntersectFold(start,end)): return
    if start > end:
        s1 = start
        start = end
        end = start
    doc = self.editor.getDocument()
    p1 = doc.getParagraphElement(start)
    p2 = doc.getParagraphElement(end)
    below = doc.getParagraphElement(p2.getEndOffset())
    << move partial selection >>
    if (self.areLinesInFold(below.getStartOffset(),below.getEndOffset())):
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        fold = self.getFold(below.getStartOffset(),below.getEndOffset())
        self.removeFold(fold)
        fstart = fold.pos1.getOffset()
        fend = fold.pos2.getOffset()
        txt = doc.getText(start,end-start)
        txt2 = doc.getText(fstart,fend-fstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(start,(fold.pos2.getOffset()-start))
        nwtxt = "%s\n%s" % (txt2,txt)
        doc.insertString(start,nwtxt,None)
        self.fold(start,start+len(txt2))
        para = doc.getParagraphElement(start+len(txt2)+1)
        para2 = doc.getParagraphElement(start+len(txt2)+1+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)
    else:
        cp = self.editor.getCaretPosition()
        cpstart = True
        if cp == end:
            cpstart = False
        txt = doc.getText(start,end-start)
        sstart = below.getStartOffset()
        txt2 = doc.getText(sstart,below.getEndOffset()-sstart)
        if txt2.endswith("\n"): txt2 = txt2 [: -1]
        doc.remove(start,(below.getEndOffset()-start)-1)
        txt3 = "%s\n%s" % (txt2,txt)
        doc.insertString(start,txt3,None)
        para = doc.getParagraphElement(start+len(txt2)+1)
        para2 = doc.getParagraphElement(start+len(txt2)+1+len(txt))
        if cpstart:
            self.editor.setCaretPosition(para2.getEndOffset()-1)
            self.editor.moveCaretPosition(para.getStartOffset())
        else:
            self.editor.setCaretPosition(para.getStartOffset())
            self.editor.moveCaretPosition(para2.getEndOffset()-1)
#@nonl
#@+node:ekr.20070930184746.100:<<move partial selection>>
if p1.getStartOffset() != start or p2.getEndOffset() -1 != end:
    cp = self.editor.getCaretPosition()
    cpstart = True
    if cp == end:
        cpstart = False
    txt = doc.getText(start,end-start)
    if not txt.endswith("\n"): txt = txt + "\n"
    self.editor.replaceSelection("")
    pend = p2.getEndOffset()
    doc.insertString(p2.getEndOffset(),txt,None)
    para = doc.getParagraphElement(pend+1)
    para2 = doc.getParagraphElement(pend+len(txt)-1)
    if cpstart:
        self.editor.setCaretPosition(para2.getEndOffset()-1)
        self.editor.moveCaretPosition(para.getStartOffset())
    else:
        self.editor.setCaretPosition(para.getStartOffset())
        self.editor.moveCaretPosition(para2.getEndOffset()-1)

    return
#@nonl
#@-node:ekr.20070930184746.100:<<move partial selection>>
#@-node:ekr.20070930184746.99:moveSelectionDown
#@+node:ekr.20070930184746.101:class Fold
class Fold:
    def __init__ (self,pos1,pos2):
        self.pos1 = pos1
        self.pos2 = pos2
        self.text = None

    def persist (self,doc):
        self.pos1 = self.pos1.getOffset()
        self.pos2 = self.pos2.getOffset()
        self.text = doc.getText(self.pos1,self.pos2-self.pos1)

    def restore (self,doc):
        p1, p2 = self.pos1, self.pos2
        if doc.getLength() < p2:
            return False
        self.pos1 = doc.createPosition(self.pos1)
        self.pos2 = doc.createPosition(self.pos2)
        pelement1 = doc.getParagraphElement(p1)
        pelement2 = doc.getParagraphElement(p2)
        if pelement1.getStartOffset() != p1 or pelement2.getEndOffset() -1 != p2:
            return False
        testtext = doc.getText(p1,p2-p1)
        text = self.text ; self.text = None
        return text == testtext

    def isInsertLegal (self,offset,doc):

        e = doc.getParagraphElement(offset)
        p1 = doc.getParagraphElement(self.pos1.getOffset())
        p2 = doc.getParagraphElement(self.pos2.getOffset())
        if p1 == e or p2 == e: return False
        while p1 != p2:
            if p1 == e: return False
            p1 = doc.getParagraphElement(p1.getEndOffset())
        else:
            if p1 == e: return False
        return True

    def isRemoveLegal (self,offset,length,doc):

        p1 = doc.getParagraphElement(self.pos1.getOffset())
        p2 = doc.getParagraphElement(self.pos2.getOffset())
        start = doc.getParagraphElement(offset)
        end = doc.getParagraphElement(offset+length)
        if start == p1 or start == p2: return False
        if end == p1 or end == p2: return False
        while start != end:
            if start == p1 or start == p2: return False
            start = doc.getParagraphElement(start.getEndOffset())
        else:
            if start == p1 or start == p2: return False

        return True
#@-node:ekr.20070930184746.101:class Fold
#@+node:ekr.20070930184746.102:class Defolder
class Defolder(aevent.MouseAdapter):
    def __init__ (self,fp):
        aevent.MouseAdapter.__init__(self)
        self.fp = fp

    def mouseClicked (self,event):

        x = event.getX()
        y = event.getY()
        if event.getButton() == event.BUTTON1:
            if self.fp.isFolded(x,y) and self.fp.isXInIconArea(x):
                self.fp.unfoldSpot(x,y)
#@nonl
#@-node:ekr.20070930184746.102:class Defolder
#@-node:ekr.20070930184746.95:class FoldProtector
#@+node:ekr.20070930184746.103:CommanderCommander
class CommanderCommander:

    def __init__ (self,c,emacs,menu):

        self.c = c
        self.emacs = weakref.proxy(emacs)
        f = c.frame
        self.nodes = {}
        self.mode = 0
        self.tab_completer = None
        self.last_command = None
        self.name = "CommanderCommander"
        self.setupCommands(menu)
        self.addHelp()


    def getAltXCommands (self):
        return self.commands.keys()

    def __call__ (self,event,command):

        if self.mode == 1:
            if command == 'Enter':
                self.gotoNode2(event)
                self.last_command = None
                #self.emacs.keyboardQuit( event )
                return True
            elif command == 'Tab' and self.tab_completer:

                txt = self.emacs.minibuffer.getText()
                if self.last_command == None or not txt.startswith(self.last_command):
                    txt = self.emacs.minibuffer.getText()
                    fnd = self.tab_completer.lookFor(txt)
                    if fnd:
                        self.last_command = txt
                        self.emacs.minibuffer.setText(self.tab_completer.getNext())
                else:
                    self.emacs.minibuffer.setText(self.tab_completer.getNext())
                return True
            else:
                self.emacs.eventToMinibuffer(event)
                return True

        quit = self.commands [command] ()
        if quit == None:
            self.emacs.keyboardQuit(event)
        return True

    def getName (self):
        return self.name

    @others

#@+node:ekr.20070930184746.104:setupCommands
def setupCommands (self,menu):

    c = self.c
    f = c.frame
    self.commands = menu.names_and_commands
    self.commands ["goto node"] = self.gotoNode1



def addHelp (self):

    addhelp = ['Menu Commands:',
                 '-----------------',
    		         'You can execute any Menu command by entering its text',
                 'in the minibuffer.  For example:',
                 'Alt-x',
                 'Open Python Window',
                 '',
                 'will open a Python Window.  See Menus for complete list.',
                 '',
                 '',
                 'Additional Commands:',
                 '---------------------',
                 'These are Leo based commands.',
                 '',
                 'goto node --- will ask the user for which node to goto',
                 'and will take the user to it.'] #we don't do triple strings because it doesn't format right because of Leo output
    addhelp = "\n".join(addhelp)
    self.emacs.addCommandHelp(addhelp)
#@nonl
#@-node:ekr.20070930184746.104:setupCommands
#@+node:ekr.20070930184746.105:gotoNode1
def gotoNode1 (self):

    self.nodes = {}
    cp = self.c.currentPosition()
    for z in cp.allNodes_iter(copy=True):
        hs = z.headString()
        if self.nodes.has_key(hs):
            self.nodes [hs].append(z)
        else:
            self.nodes [hs] = [z,]
    self.tab_completer = self.emacs.TabCompleter(self.nodes.keys())

    self.emacs.setCommandText("Goto Which Node:")
    self.emacs.minibuffer.setText("")
    self.emacs._stateManager.setState(self)
    self.mode = 1
    return True
#@nonl
#@-node:ekr.20070930184746.105:gotoNode1
#@+node:ekr.20070930184746.106:gotoNode2
def gotoNode2 (self,event):

    self.mode = 0
    self.tab_completer = None
    node = self.emacs.minibuffer.getText()
    self.emacs.keyboardQuit(event)
    if self.nodes.has_key(node):
        c = self.c
        c.beginUpdate()
        nlist = self.nodes [node]
        if len(nlist) > 1:
            jf = swing.JDialog()
            jf.setLayout(awt.BorderLayout())
            jf.setModal(True)
            jf.title = "Choose a Node"
            table = swing.JTable()
            table.setSelectionMode(swing.ListSelectionModel.SINGLE_SELECTION)
            table.setAutoResizeMode(table.AUTO_RESIZE_OFF)
            class kl(aevent.KeyAdapter):
                def keyPressed (self,event):
                    if event.getKeyCode() == event.VK_ENTER:
                        jf.dispose()

            table.addKeyListener(kl())
            jsp = swing.JScrollPane(table)
            jf.add(jsp,awt.BorderLayout.CENTER)
            dtm = table.getModel()
            dtm.addColumn("Node")
            dtm.addColumn("Level")
            dtm.addColumn("Parents")
            longest_parents = "Parents"
            for z in nlist:
                row = []
                row.append(z.headString())
                row.append(z.level())
                ps = ""
                p = z.getParent()
                while p:
                    ps = "%s -->%s" % (p.headString(),ps)
                    p = p.getParent()
                row.append(ps)
                if len(ps) > len(longest_parents): longest_parents = ps
                dtm.addRow(row)

            table.setColumnSelectionAllowed(False)
            table.setRowSelectionInterval(0,0)
            cm = table.getColumn("Node")
            fm = table.getFontMetrics(table.getFont())
            w = fm.stringWidth(z.headString())
            cm.setPreferredWidth(w)

            cm = table.getColumn("Level")
            w = fm.stringWidth("Level")
            cm.setPreferredWidth(w)

            cm = table.getColumn("Parents")
            w = fm.stringWidth(longest_parents)
            cm.setPreferredWidth(w)


            height = table.getRowHeight()
            size = jsp.getPreferredSize()
            size.height = height * 6
            jsp.setPreferredSize(size)
            cb = swing.JButton("Select")
            cb.actionPerformed = lambda event: jf.dispose()
            p = swing.JPanel()
            p.add(cb)
            jf.add(p,awt.BorderLayout.SOUTH)
            jf.pack()
            g.app.gui.center_dialog(jf)
            jf.show()
            sr = table.getSelectedRow()
            if sr != -1:
                c.selectPosition(nlist[sr])


        else:
            c.selectPosition(nlist[0])
        c.endUpdate()
    else:
        self.emacs.setCommandText("%s does not exits" % node)
    self.nodes = {}
#@nonl
#@-node:ekr.20070930184746.106:gotoNode2
#@-node:ekr.20070930184746.103:CommanderCommander
#@+node:ekr.20070930184746.107:BracketHighlighter
class BracketHighlighter(sevent.ChangeListener,sevent.DocumentListener):

    @others



#@+node:ekr.20070930184746.108:__init__
def __init__ (self,editor,c): #, color ):

    self._jtc = editor
    self.c = c
    self._jtc.getDocument().addDocumentListener(self)
    self.highlight_painter = None #stext.DefaultHighlighter.DefaultHighlightPainter( color )
    self.highlighting = False
    self.tag = None
    self.iFind = False
    self.matchers = {'{': ('{','}'),
                          '}': ('{','}'),
                          '(': ('(',')'),
                          ')': ('(',')'),
                          '[': ('[',']'),
                          ']': ('[',']'),
                          '<': ('<','>'),
                          '>': ('<','>'),
                          }

    self._nomatch = (None,None)
    self.match_bracket = 0
    self.setBracketMatch()
    manager = g.app.config.manager
    wm1 = WeakMethod(self,"setBracketMatch")
    manager.addNotificationDef("highlight_brackets",wm1)
    manager.addNotificationDef("highlight_brackets_color",wm1)


#@-node:ekr.20070930184746.108:__init__
#@+node:ekr.20070930184746.109:DocumentListener interface
def changedUpdate (self,event):
    pass

def insertUpdate (self,event):

    doc = event.getDocument()
    len = event.getLength()
    where = event.getOffset()
    self.findBracket(where,doc,doc.getLength())
    self.iFind = True

def removeUpdate (self,event):
    pass
#@nonl
#@-node:ekr.20070930184746.109:DocumentListener interface
#@+node:ekr.20070930184746.110:ChangeListener interface
def stateChanged (self,event):

    jtc = self._jtc
    dot = jtc.getCaretPosition()
    doc = jtc.getDocument()
    dlen = doc.getLength()
    self.findBracket(dot,doc,dlen)
#@nonl
#@-node:ekr.20070930184746.110:ChangeListener interface
#@+node:ekr.20070930184746.111:findBracket
def findBracket (self,dot,doc,dlen):

    if not self.match_bracket: return
    jtc = self._jtc
    highlighter = jtc.getHighlighter()
    if self.iFind:
        self.iFind = False
        return
    if self.highlighting:
        highlighter.removeHighlight(self.tag)
        self.highlighting = False

    if dot >= dlen:
        return
    else:
        c = doc.getText(dot,1)
        first, last = self.matchers.get(c,self._nomatch)
        if not first: return
        if c == first:
            txt = jtc.getText()
            i = self.forwardFind(txt[dot:],first,last) #we must include the first bracket for the find functions
            if i != -1:
                self.tag = highlighter.addHighlight(dot+i,dot+i+1,self.highlight_painter)
                self.highlighting = True
        elif c == last:

            txt = jtc.getText(0,dot+1) #we must include the first bracket for the find functions
            i = self.backwardFind(txt,first,last)
            if i != -1:
                self.tag = highlighter.addHighlight(i,i+1,self.highlight_painter)
                self.highlighting = True
#@-node:ekr.20070930184746.111:findBracket
#@+node:ekr.20070930184746.112:forwardFind
def forwardFind (self,txt,first,last):

    fbc = 0
    for z in xrange(len(txt)):
        c = txt [z]
        if c == first:
            fbc += 1
            continue
        elif c == last:
            if fbc:
                fbc -= 1
            if not fbc:
                return z

    return-1
#@nonl
#@-node:ekr.20070930184746.112:forwardFind
#@+node:ekr.20070930184746.113:backwardFind
def backwardFind (self,txt,first,last):

    fbc = 0
    tlen = len(txt)
    tnum = tlen-1
    for z in xrange(tlen):
        c = txt [tnum]
        if c == last:
            fbc += 1
        elif c == first:
            if fbc:
                fbc -= 1
            if not fbc:
                return tnum
        tnum -= 1
    return-1
#@nonl
#@-node:ekr.20070930184746.113:backwardFind
#@+node:ekr.20070930184746.114:setBracketMatch
def setBracketMatch (self,notification=None,handback=None):

    c = self.c
    if g.app.config.getBool(c,"highlight_brackets"):
        col = g.app.config.getColor(c,"highlight_brackets_color")
        color = getColorInstance(col,awt.Color.GREEN)
        self.highlight_painter = stext.DefaultHighlighter.DefaultHighlightPainter(color)
        self.match_bracket = 1
    else:
        self.match_bracket = 0
#@-node:ekr.20070930184746.114:setBracketMatch
#@-node:ekr.20070930184746.107:BracketHighlighter
#@-node:ekr.20070930184746.86:helper classes
#@+node:ekr.20070930184746.115:component classes
#@+node:ekr.20070930184746.116:autolistener --does autocompleter work
class autolistener(sevent.DocumentListener,aevent.KeyAdapter):

    watchwords = {}

    def __init__ (self,editor):
        self.watchwords = leoSwingBody.Editor.autolistener.watchwords
        self.watchitems = ('.',')')
        self.txt_template = '%s%s%s'
        okchars = {}
        for z in string.ascii_letters:
            okchars [z] = z
        okchars ['_'] = '_'
        self.okchars = okchars
        self.editor = editor
        self.jeditor = editor.editor
        self.popup = None
        #self.layeredpane = editor.layeredpane
        self.haveseen = {}
        #self.autobox = None
        self.constructAutobox()
        self.on = 0
        wm1 = WeakMethod(self,"initialScan")
        leoPlugins.registerHandler(('start2','open2'),wm1)


    @others

#@+node:ekr.20070930184746.117:helper classes
#@+node:ekr.20070930184746.118:hider and boxListener
class inserter(aevent.MouseAdapter):

    def __init__ (self,autolistener):
        self.autolistener = autolistener

    def mouseReleased (self,event):
        self.autolistener.insertFromAutoBox()


class hider(aevent.MouseWheelListener):

    def __init__ (self,autolistener):
        self.autolistener = autolistener

    def mouseWheelMoved (self,event):
        if self.autolistener.autobase.isShowing():
            self.autolistener.hideAutoBox()


#@-node:ekr.20070930184746.118:hider and boxListener
#@-node:ekr.20070930184746.117:helper classes
#@+node:ekr.20070930184746.119:constructAutobox
def constructAutobox (self):

    #import AutoPanel
    jp = swing.JPanel()
    #jp = AutoPanel()
    gbl = awt.GridBagLayout()
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    jp.setLayout(gbl)
    jlist = swing.JList(swing.DefaultListModel())
    jlist.setName("Autolist")
    jlist.setFont(self.editor.editor.getFont())
    self.jsp = jsp = swing.JScrollPane(jlist)
    gbl.setConstraints(jsp,gbc)
    jp.add(jsp)
    self.autobox = jlist
    self.autobase = jp
    self.autobox.addMouseListener(self.inserter(self))
    self.jeditor.addMouseWheelListener(self.hider(self))

#@-node:ekr.20070930184746.119:constructAutobox
#@+node:ekr.20070930184746.120:processKeyStroke/keyPressed
def keyPressed (self,event): #aka key process keyStroke
    '''c in this def is not a commander but a Tk Canvas.  This def determine what action to take dependent upon
       the state of the canvas and what information is in the Event'''
    #if not c.on:return None #nothing on, might as well return

    if not self.on: return
    if not self.autobase.isShowing(): return #isVisible just determines if the thing should be visible, not if it is.  isShowing does.


    modifiers = event.getModifiers()
    mtxt = event.getKeyModifiersText(modifiers)
    ktxt = event.getKeyText(event.getKeyCode())
    keysym = '%s %s' % (mtxt,ktxt)
    keysym = keysym.strip()
    if keysym == "shift":
        return

    elif keysym == "Backspace":
        pos = self.jeditor.getCaretPosition()
        doc = self.jeditor.getDocument()
        if pos != 0:
            c = doc.getText(pos-1,1)
            if c == '.':
                return self.hideAutoBox()


    elif self.testForUnbind(keysym): #all of the commented out code is being tested in the new testForUnbind def or moved above.
        #unbind( context )
        self.hideAutoBox()
        return None
    #elif event.keysym in("Shift_L","Shift_R"):
    #    #so the user can use capital letters.
    #    return None 
    #elif not c.which and event.char in ripout:
    #    unbind( c )
    #elif context.which==1:
    #    #no need to add text if its calltip time.
    #    return None 
    #ind = body.index('insert-1c wordstart')
    #pat = body.get(ind,'insert')+event.char 
    #pat = pat.lstrip('.')
    doc = self.jeditor.getDocument()
    pos = self.jeditor.getCaretPosition()
    try:
        txt = doc.getText(0,pos)
    except:
        return
    txt_lines = txt.splitlines()

    if len(txt_lines) > 1:
        txt_line = txt_lines [ -1]
    else:
        txt_line = txt_lines [0]
    pat = txt_line.split('.')
    if len(pat) > 1:
        pat = pat [ -1]
    else:
        pat = pat [0]

    #print keysym
    if keysym == 'Ctrl Ctrl':
       return self.processAutoBox(event,pat)

    if keysym in ("Alt Up","Alt Down"):
        event.consume()
        return self.moveUpDown(keysym)

    kchar = event.getKeyChar()
    if kchar == event.CHAR_UNDEFINED: return
    else:
        pat = pat + kchar
    autobox = self.autobox
    lm = autobox.getModel()
    ww = []
    index = None
    for z in xrange(lm.getSize()):
        item = lm.getElementAt(z)
        if item.startswith(pat):
                index = z
                break
        #ww.append( lm.getElementAt( z ) )

    #autobox = context.autobox
    #ww = list( autobox.get( 0, 'end' ) )
    #lis = self.reducer(ww,pat)
    #if len(lis)==0:return None #in this section we are selecting which item to select based on what the user has typed.
    #i = ww.index(lis[0])

    #lm.clear()
    #autobox.setListData( lis )
    if index != None:
        autobox.clearSelection()
        autobox.setSelectedIndex(index)
        autobox.ensureIndexIsVisible(index)

    #autobox.select_clear( 0, 'end' ) #This section sets the current selection to match what the user has typed
    #autobox.select_set( i )
    #autobox.see( i )
    #return 'break'

#@-node:ekr.20070930184746.120:processKeyStroke/keyPressed
#@+node:ekr.20070930184746.121:processAutoBox
def processAutoBox (self,event,pat):
    '''This method processes the selection from the autobox.'''
    #if event.keysym in("Alt_L","Alt_R"):
    #    return None 

    #a = context.autobox.getvalue()
    a = self.autobox.getSelectedValue()
    #if len(a)==0:return None 
    if not a: self.hideAutoBox()
    try:
        #a = a[0]
        #ind = body.index('insert-1c wordstart')
        #pat = body.get(ind,'insert')
        #pat = pat.lstrip('.')

        if a.startswith(pat): a = a [len(pat):]
        doc = self.jeditor.getDocument()
        doc.insertString(self.jeditor.getCaretPosition(),a,None)
        self.hideAutoBox()
        #self.editor.insert 
        #body.insert('insert',a)
        #body.event_generate("<Key>")
        #body.update_idletasks()
    except java.lang.Exception, x:
        x.printStackTrace()
        #self.editor.hideAutoBox()
        #unbind( context )
#@-node:ekr.20070930184746.121:processAutoBox
#@+node:ekr.20070930184746.122:moveUpDown
def moveUpDown (self,code):

    autobox = self.autobox
    i = autobox.getSelectedIndex()
    if code == 'Alt Up':
        i2 = i-1
    else:
        i2 = i + 1

    lm = autobox.getModel()
    if i2 < 0 or i2 + 1 > lm.getSize():
        return
    else:
        autobox.setSelectedIndex(i2)
        autobox.ensureIndexIsVisible(i2)
#@nonl
#@-node:ekr.20070930184746.122:moveUpDown
#@+node:ekr.20070930184746.123:testForUnbind
def testForUnbind (self,keysym):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if keysym in ('parenright','parenleft','Escape','Space','Enter','Tab','Up','Down') or keysym.isspace():
        return True
    #elif not context.which and event.char in ripout:
    #    return True
    return False
#@-node:ekr.20070930184746.123:testForUnbind
#@+node:ekr.20070930184746.124:DocumentListener implementation
@others
#@nonl
#@+node:ekr.20070930184746.125:changedUpdate
def changedUpdate (self,event):
    pass

#@-node:ekr.20070930184746.125:changedUpdate
#@+node:ekr.20070930184746.126:insertUpdate
def insertUpdate (self,event):

    if not self.on: return
    doc = event.getDocument()
    change = doc.getText(event.getOffset(),event.getLength())
    if change == '.':
        self.watcher(event)



#@-node:ekr.20070930184746.126:insertUpdate
#@+node:ekr.20070930184746.127:removeUpdate
def removeUpdate (self,event):
    '''originally I wanted to do a remove of the autobox on a backspace of '.' but this couldnt be detected adequately
    and had to be put in the Key handling code of the autocompleter.'''
    pass

#@-node:ekr.20070930184746.127:removeUpdate
#@-node:ekr.20070930184746.124:DocumentListener implementation
#@+node:ekr.20070930184746.128:watcher
watchitems = ('.',')')
txt_template = '%s%s%s'
def watcher (self,event):
    '''A function that tracks what chars are typed in the Text Editor.  Certain chars activate the text scanning
       code.'''
    #global lang 
    doc = event.getDocument()
    txt = doc.getText(event.getOffset(),event.getLength())
    if txt.isspace() or txt in self.watchitems:
        #bCtrl = event.widget
        #This if statement ensures that attributes set in another node
        #are put in the database.  Of course the user has to type a whitespace
        # to make sure it happens.  We try to be selective so that we dont burn
        # through the scanText def for every whitespace char entered.  This will
        # help when the nodes become big.
        #if event.char.isspace():
        #    if bCtrl.get( 'insert -1c' ).isspace(): return #We dont want to do anything if the previous char was a whitespace
        #    if bCtrl.get( 'insert -1c wordstart -1c') != '.': return

        #c = bCtrl.commander
        #lang = c.frame.body.getColorizer().language 
        #txt = txt_template %( bCtrl.get( "1.0", 'insert' ), 
        #                     event.char, 
        #                     bCtrl.get( 'insert', "end" ) ) #We have to add the newest char, its not in the bCtrl yet
        txt = doc.getText(0,doc.getLength())
        self.scanText(txt)
        self.determineToShow(event)

#@-node:ekr.20070930184746.128:watcher
#@+node:ekr.20070930184746.129:scanText
def scanText (self,txt):
    '''This function guides what gets scanned.'''

    #if useauto:
    self.scanForAutoCompleter(txt)
    #if usecall:
    #    scanForCallTip(txt)
#@-node:ekr.20070930184746.129:scanText
#@+node:ekr.20070930184746.130:scanForAutoCompleter
def scanForAutoCompleter (self,txt):
    '''This function scans text for the autocompleter database.'''
    t1 = txt.split('.')
    g = []
    reduce(lambda a,b: self.makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            if self.watchwords.has_key(a):
                self.watchwords [a] [b] = None
            else:
                self.watchwords [a] = {b: None}
                #watchwords[a] = sets.Set([b])
                #watchwords[ a ] = util.Hash
            #watchwords[ a ].add( b ) # we are using the experimental DictSet class here, usage removed the above statements
            #notice we have cut it down to one line of code here!
#@nonl
#@-node:ekr.20070930184746.130:scanForAutoCompleter
#@+node:ekr.20070930184746.131:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):
    '''A helper function for autocompletion'''
    a1 = self._reverseFindWhitespace(a)
    if a1:
        b2 = self._getCleanString(b)
        if b2 != '':
            glist.append((a1,b2))
    return b
#@-node:ekr.20070930184746.131:makeAutocompletionList
#@+node:ekr.20070930184746.132:_getCleanString
def _getCleanString (self,s):
    '''a helper for autocompletion scanning'''
    if s.isalpha(): return s

    #for n, l in enumerate(s):
    for n in xrange(len(s)):
        l = s [n]
        if l in self.okchars: pass
        else: return s [: n]
    return s
#@-node:ekr.20070930184746.132:_getCleanString
#@+node:ekr.20070930184746.133:_reverseFindWhitespace
def _reverseFindWhitespace (self,s):
    '''A helper for autocompletion scan'''
    #for n, l in enumerate(s):
    for n in xrange(len(s)):
        l = s [n]
        n = (n+1) * -1
        if s [n].isspace() or s [n] == '.': return s [n + 1:]
    return s
#@-node:ekr.20070930184746.133:_reverseFindWhitespace
#@+node:ekr.20070930184746.134:reducer
def reducer (self,lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return [x for x in lis if x.startswith(pat)]
#@-node:ekr.20070930184746.134:reducer
#@+node:ekr.20070930184746.135:determineToShow
def determineToShow (self,event):

    doc = event.getDocument()
    txt = doc.getText(0,event.getOffset())
    txt_list = txt.splitlines()
    if not txt_list: return
    txt_line = txt_list [ -1]
    txt_splitdots = txt_line.split('.') [ -1]
    txt_final = txt_splitdots.split()
    if txt_final:
        txt_final = txt_final [ -1]
    if txt_final and self.watchwords.has_key(txt_final):
        completers = self.watchwords [txt_final].keys()
        completers.sort()
        self.getAutoBox(completers)

#@-node:ekr.20070930184746.135:determineToShow
#@+node:ekr.20070930184746.136:startup time scanning
@others
#@nonl
#@+node:ekr.20070930184746.137:initialScan
def initialScan (self,tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c") or keywords.get("new_c")
    haveseen = self.haveseen
    if haveseen.has_key(c):
        return

    haveseen [c] = None

    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    #pth = os.path.split(g.app.loadDir)  
    #aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    #if not os.path.exists(aini):
    #    createConfigFile( aini )
    #try:
    #    if not hasReadConfig():
    #        if os.path.exists(aini):
    #            readConfigFile(aini) 
    #
    #        bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
    #        readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    #finally:
    #    setReadConfig()

    # Use a thread to do the initial scan so as not to interfere with the user.
    #_self = self
    #class scanner( java.lang.Thread ):          
    #def run( self ):
    #    _self.readOutline( c )
    #    #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
    #    #readOutline( c )

    dc = DefCallable(lambda: self.readOutline(c))
    g.app.gui.addStartupTask(dc)



#@-node:ekr.20070930184746.137:initialScan
#@+node:ekr.20070930184746.138:readOutline
def readOutline (self,c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    #global lang
    #if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
    #    import chapters 
    #    it = chapters.walkChapters()
    #     for x in it:
    #        lang = None 
    #        setLanguage(x)
    #        scanText(x.bodyString())
    #else:
    for z in c.rootPosition().allNodes_iter(copy=True):
        #self.scanText( z.bodyString() )
        rvalues = LeoUtilities.scanForAutoCompleter(z.v.t._bodyString)
        if rvalues:
            for z in rvalues:
                a, b = z
                if self.watchwords.has_key(a):
                    self.watchwords [a] [b] = None
                else:
                    self.watchwords [a] = {b: None}



    g.es("Autocompleter ready")
#@-node:ekr.20070930184746.138:readOutline
#@-node:ekr.20070930184746.136:startup time scanning
#@+node:ekr.20070930184746.139:get, hide and insert AutoBox
@others
#@nonl
#@+node:ekr.20070930184746.140:getAutoBox
def getAutoBox (self,completers):

    jlist = self.autobox
    jp = self.autobase
    if len(completers) < 5:
        jlist.setVisibleRowCount(len(completers))
    else:
        jlist.setVisibleRowCount(5)

    model = jlist.getModel()
    model.removeAllElements() #by working with the model we dont burn a new object each time.
    for z in completers:
        model.addElement(z)
    jlist.setSelectedIndex(0)
    jlist.ensureIndexIsVisible(0)
    jlist.setValueIsAdjusting(True)


    cur = self.jeditor.getCaretPosition()
    pos = self.jeditor.modelToView(cur)
    size = self.editor.view.getViewport().getViewRect()
    pos = swing.SwingUtilities.convertRectangle(self.jeditor,pos,self.editor.epane)
    size.x = 0 ; size.y = 0 ;


    jlist.setSize(jlist.getPreferredSize()) #the discrepency between the two was causing weird drawing bugs.  This appears to have rectified it.
    #Its very important that the setSize call happens before the self.jsp.getPreferredSize call, or it may not calculate right.
    jsps = self.jsp.getPreferredSize()
    jp.setSize(jsps)
    rx = ry = 0
    if pos.x > (size.x+size.height) / 2:
        rx = pos.x- jsps.width
    else: rx = pos.x

    if pos.y > (size.y+size.height) / 2:
        ry = pos.y- jsps.height
    else: ry = pos.y + pos.height

    point = awt.Point(rx,ry)
    swing.SwingUtilities.convertPointToScreen(point,self.editor.view.getViewport())
    popupfactory = swing.PopupFactory().getSharedInstance()
    self.popup = popup = popupfactory.getPopup(self.editor.editor,jp,point.x,point.y)
    popup.show()






#@-node:ekr.20070930184746.140:getAutoBox
#@+node:ekr.20070930184746.141:hideAutoBox
def hideAutoBox (self):

    if self.popup:
        self.popup.hide() ; self.popup = None


#@-node:ekr.20070930184746.141:hideAutoBox
#@+node:ekr.20070930184746.142:insertFromAutobox
def insertFromAutoBox (self):

    autobox = self.autobox
    value = autobox.getSelectedValue()
    pos = self.jeditor.getCaretPosition()
    self.jeditor.getDocument().insertString(pos,value,None)
    self.hideAutoBox()
#@nonl
#@-node:ekr.20070930184746.142:insertFromAutobox
#@-node:ekr.20070930184746.139:get, hide and insert AutoBox
#@-node:ekr.20070930184746.116:autolistener --does autocompleter work
#@+node:ekr.20070930184746.143:Carets
#@+node:ekr.20070930184746.144:UnderlinerCaret
class UnderlinerCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self,color):
        stext.DefaultCaret.__init__(self)
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #self._bg = awt.Color.RED
        self._bg = color
        #self._bg = awt.Color( c.getRed(), c.getGreen(), c.getBlue(), 50 ); 
        self.setBlinkRate(0) #no blinking please


    def paint (self,g):

        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)

        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self.calculateCharacterWidth(g) + 1 #Its important to be a little wider
            self.height = view.height + 1 #And a little taller than the box, or redraws will leave traces


        if self.isVisible():
            g.setColor(self._bg)
            #g.fillRect( self.x, self.y, self.width - 1, view.height )
            g.drawLine(self.x,self.y+self.height-1,self.x+self.width-1,self.y+self.height-1)
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def calculateCharacterWidth (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        fm = g.getFontMetrics()

        pos = com.getCaretPosition()
        len = com.getDocument().getLength()
        if pos >= len:
            c = ' '
        else:
            c = com.getText(pos,1)
        if java.lang.Character.isWhitespace(c): c = ' '

        return swing.SwingUtilities.computeStringWidth(fm,c)





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth(graphics) + 1
        graphics.dispose()
        self.height = view.height + 1 ;
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))
#@nonl
#@-node:ekr.20070930184746.144:UnderlinerCaret
#@+node:ekr.20070930184746.145:SeeThroughBoxCaret
class SeeThroughBoxCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self,color):
        stext.DefaultCaret.__init__(self)
        #ti = java.lang.Integer.decode( "#FFFFC6" );
        #c = awt.Color( ti );
        #c = awt.Color.RED
        self._bg = awt.Color(color.getRed(),color.getGreen(),color.getBlue(),50) ;
        self.setBlinkRate(0) #no blinking please


    def paint (self,g):

        com = self.super__getComponent()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self.calculateCharacterWidth(g) + 1 #Its important to be a little wider
            self.height = view.height + 1 #And a little taller than the box, or redraws will leave traces


        if self.isVisible():
            g.setColor(self._bg)
            g.fillRect(self.x,self.y,self.width-1,view.height)

        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def calculateCharacterWidth (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        if not g: return 0
        com = self.super__getComponent()
        doc = com.getDocument()
        pos = com.getCaretPosition()
        len = doc.getLength()
        if pos >= len:
            c = ' '
        else:
            c = com.getText(pos,1)

        e = doc.getCharacterElement(pos)
        atts = e.getAttributes()
        f = doc.getFont(atts)
        if f:
            g.setFont(f)
        fm = g.getFontMetrics()

        if java.lang.Character.isWhitespace(c): c = ' '

        return swing.SwingUtilities.computeStringWidth(fm,c)





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        com = self.super__getComponent()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)
        graphics = com.getGraphics()
        self.width = self.calculateCharacterWidth(graphics) + 1
        if graphics:
            graphics.dispose()
        self.height = view.height + 1 ;
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

#@-node:ekr.20070930184746.145:SeeThroughBoxCaret
#@+node:ekr.20070930184746.146:GhostlyLeoCaret
import java.awt.image as aim
class GhostlyLeoCaret(stext.DefaultCaret):
    '''This Caret creates a see through colored box over the current character.'''
    def __init__ (self):
        stext.DefaultCaret.__init__(self)

        self.setBlinkRate(0) #no blinking please
        self._image = leoSwingBody.Editor.icon.getImage()
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1
        self._ac = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,.2)
        self._bgc = None


    def paint (self,g):

        com = self.super__getComponent()
        if self._bgc == None:
            self._bgc == g.getColor()
        dot = self.getDot()
        pos = com.getCaretPosition()
        view = com.modelToView(pos)

        if (self.x!=view.x or self.y!=view.y):
            self.super__repaint()
            self.x = view.x
            self.y = view.y
            self.width = self._im_width
            self.height = self._im_height


        if self.isVisible():

            if not self.isWhiteSpace(g):
                g.setComposite(self._ac)
            g.drawImage(self._image,self.x,self.y,self._bgc,None)
        self.setMagicCaretPosition(awt.Point(self.x,self.y))

    def isWhiteSpace (self,g):
        '''This method allows the see-through box to have the same width as the character'''

        com = self.super__getComponent()
        v1 = com.viewToModel(awt.Point(self.x,self.y))
        v2 = com.viewToModel(awt.Point(self.x+self.width,self.y))
        vlen = v2- v1
        len = com.getDocument().getLength()
        if v1 >= len:
            c = ' '
        else:
            c = com.getText(v1,vlen)
        if c.isspace() or c == '': c = ' '
        return c == ' '





    def damage (self,r):

        if r == None: return

        self.x = r.x
        self.y = r.y
        self.height = self._im_height
        self.width = self._im_width
        self.super__repaint()
        self.setMagicCaretPosition(awt.Point(self.x,self.y))
#@-node:ekr.20070930184746.146:GhostlyLeoCaret
#@+node:ekr.20070930184746.147:ImageCaret
class ImageCaret(GhostlyLeoCaret):

    def __init__ (self,image):
        leoSwingBody.Editor.GhostlyLeoCaret.__init__(self)
        self._image = image
        self._im_height = self._image.getHeight() + 1
        self._im_width = self._image.getWidth() + 1


#@-node:ekr.20070930184746.147:ImageCaret
#@-node:ekr.20070930184746.143:Carets
#@+node:ekr.20070930184746.148:leoJTextPane
class leoJTextPane(swing.JTextPane):

    def __init__ (self,c):
        swing.JTextPane.__init__(self)
        self.c = c
        self.last_rec = None
        self._bg = None

    def setLineColor (self,notification=None,handback=None):

        c = self.c
        if g.app.config.getBool(c,"highlight_current_line"):
            hc = g.app.config.getColor(c,"current_line_highlight_color")
            color = getColorInstance(hc,awt.Color.ORANGE)
            self._bg = awt.Color(color.getRed(),color.getGreen(),color.getBlue(),50)
        else:
            self._bg = None
            self._last_rec = None
        self.repaint()

@
    def paintComponent (self,graphics):
        if 0:
            paint = graphics.getPaint()
            color = self.getBackground()
            c1 = awt.Color.RED
            c2 = awt.Color.GREEN
            vrect = self.getVisibleRect()
            gp = awt.GradientPaint(vrect.x,vrect.y,c1,vrect.x+vrect.width,vrect.y+vrect.height,c2)
            graphics.setPaint(gp)
            graphics.fillRect(vrect.x,vrect.y,vrect.width,vrect.height)
            graphics.setPaint(paint)
@c

    def paintComponent (self,graphics):

        self.super__paintComponent(graphics)
        if self._bg:
            cpos = self.getCaretPosition() #from here
            try:
                rec = self.modelToView(cpos)
            except java.lang.Exception, x:
                x.printStackTrace()
                return
            sz = self.getVisibleRect()
            rec = awt.Rectangle(sz.x,rec.y,sz.width,rec.height) #to here: these calculate the colored background.
            if self.last_rec and not self.last_rec.equals(rec): #its not the same spot we must repaint!
                if self.last_rec.width < rec.width:
                    self.last_rec.width = rec.width
                self.repaint(self.last_rec)


            c = graphics.getClip()
            rintersect = rec.intersects(c)
            if not rec.equals(self.last_rec) or rintersect:
                if self.last_rec:
                    if rec.y != self.last_rec.y or rec.height != self.last_rec.height:
                        rintersect = 0
                if rintersect:
                    graphics.setColor(self._bg) #if we intersect we only repaint a small portion. This reduces flicker.
                    graphics.fill(rec)
                else:
                    g2 = self.getGraphics()
                    g2.setColor(self._bg) #if we dont we repaint all of it.
                    g2.fill(rec)
                    g2.dispose()


            self.last_rec = rec


#@-node:ekr.20070930184746.148:leoJTextPane
#@+node:ekr.20070930184746.149:leoImageJPanel
class leoImageJPanel(swing.JPanel):

    def __init__ (self,layoutmanager):
        swing.JPanel.__init__(self,layoutmanager)
        self.image = None
        self.backedWidget = None
        self.last_image = None
        self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,1.0)
        self.lastDimensions = awt.Rectangle(0,0,0,0)

    def setBackedWidget (self,widget):
        self.backedWidget = widget

    def setImage (self,image):
        self.image = image

    def setAlpha (self,alpha):
        self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,alpha)

    def paintComponent (self,graphics):

        self.super__paintComponent(graphics)
        if self.backedWidget and self.image:
            vrec = self.backedWidget.getVisibleRect()
            rec2 = swing.SwingUtilities.convertRectangle(self.backedWidget,vrec,self)
            if not self.lastDimensions.equals(vrec):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance(rec2.width,rec2.height,awt.Image.SCALE_REPLICATE)
            composite = graphics.getComposite()
            graphics.setComposite(self.alpha)
            graphics.drawImage(self.last_image,rec2.x,rec2.y,awt.Color.WHITE,None)
            graphics.setComposite(composite)
#@-node:ekr.20070930184746.149:leoImageJPanel
#@+node:ekr.20070930184746.150:leoLayoutManager
class leoLayoutManager(awt.LayoutManager):


    def __init__ (self):
        self.jscrollpane = None
        self.minibuffer = None
        self.media = None



    def addLayoutComponent (self,name,component):
        pass


    def layoutContainer (self,container):

        size = container.getSize()
        if self.minibuffer:
            mbpsize = self.minibuffer.getPreferredSize()
        else:
            mbpsize = awt.Rectangle(0,0,0,0)

        if self.jscrollpane:
            self.jscrollpane.setBounds(0,0,size.width,size.height-mbpsize.height)
            if self.minibuffer:
                self.minibuffer.setBounds(0,size.height-mbpsize.height,size.width,mbpsize.height)

        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds(vr)

    def layoutMedia (self):
        if self.media and self.jscrollpane:
            vp = self.jscrollpane.getViewport()
            vr = vp.getBounds()
            self.media.setBounds(vr)

    def minimumLayoutSize (self,container):
        return container.getMinimumSize()


    def preferredLayoutSize (self,container):
        return container.getPreferredSize()


    def removeLayoutComponent (self,container):
        pass
#@-node:ekr.20070930184746.150:leoLayoutManager
#@-node:ekr.20070930184746.115:component classes
#@-node:ekr.20070930184746.42:helper methods and classes
#@-node:ekr.20070930184746.32:class Editor
#@+node:ekr.20070930184746.151:MouseAdapter
class UtilityRightClick( aevent.MouseAdapter ):


    def __init__( self, c, detach_retach = False, editor = None ):
        aevent.MouseAdapter.__init__( self )
        self.c = c
        self.editor = weakref.proxy( editor )
        self._detach_retach = detach_retach


    @others


#@+node:ekr.20070930184746.152:mousePressed
def mousePressed( self, mE ):

    if mE.getClickCount() == 1:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()

            popup = swing.JPopupMenu()

            UtilityAction = leoSwingBody.UtilityAction
            AddEditor = leoSwingBody.AddEditor
            InsertNode = leoSwingBody.InsertNode            
            frame = self.c.frame
            for z in ( ( "Cut", self.editor.editor.cut ), ( "Copy", self.editor.editor.copy ), 
                        ( "Paste", self.editor.editor.paste ), # frame.OnPaste ), 
                        ( "Delete", self.c.delete  ),
                        ):
                popup.add( UtilityAction( z[ 0 ], z[ 1 ] ) )

            popup.addSeparator()
            popup.add( UtilityAction( "Turn Selection Into Node", self.editor.turnSelectionIntoNode ))
            inmenu = swing.JMenu( "Insert Node Into Body" )
            inmenu.addMenuListener( InsertNode( inmenu, self.c, UtilityAction ) )
            popup.add( inmenu )

            popup.add( UtilityAction( "Split Node", frame.body.editor.splitNode ) )

            if( mE.getComponent() == self.editor ):
                popup.add( UtilityAction( "Select All", self.editor.selectAll ) )

            popup.addSeparator()  
            body = frame.body
            popup.add( AddEditor( body , x, y ) )
            popup.addSeparator()               
            if self._detach_retach:
                if self.editor._attached:
                    s = "Detach Editor"
                    act = self.editor.detach
                else:
                    s = "Retach Editor"
                    act = self.editor.retach 
                ji = swing.JMenuItem( s )
                ji.actionPerformed =  act
                popup.add( ji )

            folded = self.editor.foldprotection.isFolded( x, y )
            if self.editor.editor.getSelectionStart() != self.editor.editor.getSelectionEnd() or folded:
                popup.addSeparator()
                if not folded:
                    jmi = swing.JMenuItem( "Fold Selection" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection: fp.foldSelection()
                else:
                    jmi = swing.JMenuItem( "Unfold Fold" )
                    jmi.actionPerformed = lambda event, fp = self.editor.foldprotection, x = x, y= y: fp.unfoldSpot( x, y )

                popup.add( jmi )

            source = mE.getSource()    
            popup.show( source, x, y )
#@nonl
#@-node:ekr.20070930184746.152:mousePressed
#@-node:ekr.20070930184746.151:MouseAdapter
#@+node:ekr.20070930184746.156:SimplifiedUtilityRightClick -- for adding an Editor
class SimplifiedUtilityRightClick( aevent.MouseAdapter ):


    def __init__( self, body ):
        aevent.MouseAdapter.__init__( self )
        self.body = body



    @others


#@+node:ekr.20070930184746.157:mousePressed
def mousePressed( self, mE ):

    if mE.getClickCount() == 1:
        if mE.getButton() == mE.BUTTON3:
            x = mE.getX()
            y = mE.getY()

            popup = swing.JPopupMenu()
            AddEditor = leoSwingBody.AddEditor
            popup.add( AddEditor( self.body , x, y ) )                
            source = mE.getSource()                
            popup.show( source, x, y )
#@nonl
#@-node:ekr.20070930184746.157:mousePressed
#@-node:ekr.20070930184746.156:SimplifiedUtilityRightClick -- for adding an Editor
#@+node:ekr.20070930184746.158:class AddEditor
class AddEditor( swing.AbstractAction ):

    def __init__( self, body, x,y ):
        swing.AbstractAction.__init__( self, "Add Editor" )
        self.body = body
        self.x = x
        self.y = y

    def actionPerformed( self, event ):
        leoSwingBody.Editor( self.body.jdp , self.body.c, self.body , x = self.x, y = self.y )
#@nonl
#@-node:ekr.20070930184746.158:class AddEditor
#@+node:ekr.20070930184746.159:class UtilityAction
class UtilityAction( swing.AbstractAction ):
    def __init__( self, name, command ):
        swing.AbstractAction.__init__( self, name )
        self.command = command

    def actionPerformed( self, event ):
        self.command()
#@nonl
#@-node:ekr.20070930184746.159:class UtilityAction
#@+node:ekr.20070930184746.160:class InsertNode
class InsertNode( sevent.MenuListener ):

    def __init__( self, menu, c, utilityaction ):
        self.menu = menu
        self.c = c
        self.UtilityAction = utilityaction
        #self.insert = insert

    def menuCanceled( self, event ):
        pass

    def menuDeselected( self, event ):
        pass

    def menuSelected( self, event ):

        menu = self.menu       
        menu.removeAll()
        cp = self.c.currentPosition()
        for z in cp.children_iter( copy = True ):
            action = lambda node = z: self.insertNode( node )
            ua = self.UtilityAction( z.headString(), action )
            menu.add( ua )

    def insertNode( self, node ):

        c = self.c
        at = c.atFileCommands
        at.write(node.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput
        c.frame.body.editor.insertTextIntoBody( data )
        c.beginUpdate()
        cpos = c.currentPosition()
        node.doDelete( cpos )
        c.endUpdate()




#@-node:ekr.20070930184746.160:class InsertNode
#@-node:ekr.20070930184746.155:classes: Editor and a multitude of helpers
#@+node:ekr.20070930184746.161:UndoableEditListener
def undoableEditHappened( self, event ):

    if self.ignore_insert: return
    c = self.c
    cp = c.currentPosition().copy()
    edit = event.getEdit()
    #dec_edit = leoSwingUndo.UndoableEditDecorator( c, cp, edit )
    #c.undoer.addUndo( dec_edit )

    #undoType = "undo_edit_class"
    #c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
#@-node:ekr.20070930184746.161:UndoableEditListener
#@+node:ekr.20070930184746.162:KeyAdapter -- for preparing undoer
def keyPressed( self, event ):

    editor = self.editor.editor
    self.oldText = editor.getText()
    self.oldSel = editor.getSelectedText()
    self.ch = event.getKeyChar()
    cpos = editor.getCaretPosition()
    rec = editor.modelToView( cpos )
    self.oldYview = rec.y 
#@-node:ekr.20070930184746.162:KeyAdapter -- for preparing undoer
#@+node:ekr.20070930184746.163:getAllText --had to be added
def getAllText( self ):

    return self.editor.editor.getText()
#@nonl
#@-node:ekr.20070930184746.163:getAllText --had to be added
#@-node:ekr.20070930184746.9:class leoSwingBody
#@+node:ekr.20070930184746.164:class leoSwingFrame
class leoSwingFrame(leoFrame.leoFrame):

    """The base class for all Leo windows."""

    instances = 0

    @others
#@nonl
#@+node:ekr.20070930184746.165:  leoSwingFrame.__init__
def __init__ (self,gui):

    leoFrame.leoFrame.__init__(self,gui)
    self.gui = gui
    #import RepaintManager2
    #rpm2 = RepaintManager2()
    #swing.RepaintManager.setCurrentManager( rpm2 )
    # Objects attached to this frame.
    self.menu = None
    self.keys = None
    self.colorPanel = None
    self.fontPanel = None
    self.prefsPanel = None
    self.comparePanel = None
    self.title = ""
    self._menu_init_callbacks = []
    self.receiver = None
    self.canresize = True

    #import Chapters
    #self.chapters = Chapters.Chapters( self.c )
    #if g.app.config.getBool( self.c, "lock_open_files" ):
    #    receiver = self.Receiver( self, self.c )
    #    thread = java.lang.Thread( receiver )
    #    thread.setDaemon( True )
    #    thread.start()

    #self.c = None # Must be created by subclasses.
    #self.title = None # Must be created by subclasses.

    # Objects attached to this frame.
    #self.menu = None
    #self.keys = None
    #self.colorPanel = None 
    #self.fontPanel = None 
    #self.prefsPanel = None
    #self.comparePanel = None

    # Gui-independent data
    #self.es_newlines = 0 # newline count for this log stream
    #self.openDirectory = ""
    #self.saved=False # True if ever saved
    #self.splitVerticalFlag,self.ratio, self.secondary_ratio = self.initialRatios()
    #self.startupWindow=False # True if initially opened window
    #self.stylesheet = None # The contents of <?xml-stylesheet...?> line.

    # Colors of log pane.
    #self.statusColorTags = [] # list of color names used as tags in status window.

    # Previous row and column shown in the status area.
    #self.lastStatusRow = self.lastStatusCol = 0
    #self.tab_width = 0 # The tab width in effect in this pane.
#@nonl
#@-node:ekr.20070930184746.165:  leoSwingFrame.__init__
#@+node:ekr.20070930184746.174:finishCreate
def finishCreate (self,c):

    self.c = c
    self.setSkin()
    #swing.plaf.metal.MetalLookAndFeel.setCurrentTheme( self.LeoMetalTheme( self.c ) )
    wm1 = WeakMethod(self,"setSkin")
    g.app.config.manager.addNotificationDef("type_of_skin",wm1)
    self.top = swing.JFrame() #Must add close question
    self.gp2 = self.GlassPane2()
    self.top.setGlassPane(self.gp2)
    self.top.addWindowListener(self.WindowClosingWatcher(self))

    self.ftp = self.leoFocusTraversalPolicy(c)
    self.top.setFocusTraversalPolicy(self.ftp)
    #if g.app.config.getBool( self.c, "lock_open_files" ) and self.c.mFileName != "":
    #    self.startReceiver()

    g.app.gui.addLAFListener(self.top)
    #self.setSkin()
    #g.app.config.manager.addNotificationDef( "type_of_skin", self.setSkin )


    ic = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF")
    ifile = io.File(ic)
    if ifile.exists():
        try:
            icimage = imageio.ImageIO.read(ifile)
            self.top.setIconImage(icimage)
        except java.lang.Exception, x:
            pass
    self.top.setDefaultCloseOperation(swing.JFrame.DO_NOTHING_ON_CLOSE)
    self.setTitle(c.mFileName)
    pf = self.top.getContentPane()

    self.jcp = self.top.getContentPane()
    self.toolbar = swing.JPanel(java.awt.BorderLayout()) #swing.JToolBar()
    #self.toolbar.setFloatable( False )
    nodebar = swing.JToolBar()
    self.NodeBar(c,nodebar)
    nodebar.setFloatable(True)
    self.toolbar.add(nodebar,java.awt.BorderLayout.NORTH)
    self.toolbar2 = swing.JToolBar()
    #g.doHook( "toolbar2-in-place", c = self.c , toolbar = self.toolbar2 )
    self.toolbar.add(self.toolbar2,java.awt.BorderLayout.SOUTH)

    self.jsp1 = swing.JSplitPane()
    self.jsp1.continuousLayout = True

    #pf.add( self.jif3 )
    self.jsp2 = swing.JSplitPane(swing.JSplitPane.VERTICAL_SPLIT,True)
    self.jsp2.topComponent = self.jsp1
    #self.jtab = swing.JTabbedPane()
    #self.tree_tabs = TabManager()
    #self.jsp1.leftComponent = self.tree_tabs.base #self.jtab
    self.jcp.add(self.jsp2,awt.BorderLayout.CENTER)
    self.top.add(self.toolbar,awt.BorderLayout.NORTH)
    #self.jif.getContentPane().add( self.jtab )
    #import Chapters
    #self.chapters = Chapters.Chapters( self.c )
    self.jsp1.leftComponent = self.c.chapters.getWidget()
    #self.tree = leoSwingTree(frame=self)
    self.tree = self.c.chapters.addChapter("New Chapter",p=c.rootPosition())
    #self.jsp1.leftComponent = self.tree.getWidget()
    self.menu = leoSwingMenu.leoSwingMenu(frame=self)
    #self.menu.createMenuBar( self )
    self.body = leoSwingBody(frame=self,parentFrame=self.jsp2)
    self.log = leoSwingLog(frame=self,parentFrame=self.jsp1)
    import leoSwingFind
    self.findPanel = leoSwingFind.leoSwingFind(c)
    g.app.log = self.log
    self.bodyCtrl = self.body.editor.editor

    tk = self.top.getToolkit()
    size = tk.getScreenSize()
    self.top.bounds = (0,0,size.width,size.height)
    #self.jsp1.setDividerLocation( .75 )
    #self.jsp2.setDividerLocation( .5 )
    self.jsp1.setOneTouchExpandable(True)
    self.jsp2.setOneTouchExpandable(True)
    << create the first tree node >>
    #self.menu = leoSwingMenu.leoSwingMenu(frame=self)
    self.menu.createMenuBar(self)
    #self.top.visible = True
    #self.jsp1.setDividerLocation( .75 )
    #self.jsp2.setDividerLocation( .5 )

    g.app.windowList.append(self)
    c.initVersion()
    c.signOnWithVersion()
    self.menuInitialized()
    placement = g.app.config.getString(c,'tree_editor_placement')
    if placement == "Top/Bottom":
        pass
    else:
        self.toggleSplitDirection()
#@nonl
#@+node:ekr.20070930184746.175:<< create the first tree node >>
import leoNodes
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

c.beginUpdate()
try:
    p.moveToRoot()
    c.selectPosition(p)
    c.editPosition(p)
finally:
    c.endUpdate(False)


#@-node:ekr.20070930184746.175:<< create the first tree node >>
#@-node:ekr.20070930184746.174:finishCreate
#@+node:ekr.20070930184746.166: Must be defined in subclasses
#@+node:ekr.20070930184746.167: gui-dependent commands
def abortEditLabelCommand (self):

    self.c.frame.tree.jtree.cancelEditing()

def endEditLabelCommand (self):
    self.c.frame.tree.endEditLabel()

def insertHeadlineTime (self):
    time = self.c.getTime(body=False)
    cp = self.c.currentPosition()
    hs = cp.headString()
    nhs = '%s %s' % (time,hs)
    cp.setHeadString(nhs)

# In the Window menu...
def cascade (self): self.oops()

def equalSizedPanes (self):
    self.jsp2.setDividerLocation(.5)

def hideLogWindow (self): self.oops()

def minimizeAll (self):

    self.top.setState(self.top.ICONIFIED)

def resizeToScreen (self):

    tk = self.top.getToolkit()
    ss = tk.getScreenSize()
    self.top.setBounds(0,0,ss.width,ss.height)

def toggleActivePane (self): self.oops()

def toggleSplitDirection (self):

    self._toggle(self.jsp1)
    self._toggle(self.jsp2)
    self.jsp2.setDividerLocation(.50)
    self.jsp1.setDividerLocation(.75)

def _toggle (self,jsp):

    orient = jsp.getOrientation()
    if orient == jsp.HORIZONTAL_SPLIT:
        jsp.setOrientation(jsp.VERTICAL_SPLIT)
    else:
        jsp.setOrientation(jsp.HORIZONTAL_SPLIT)

# In help menu...
def leoHelp (self): self.oops()

#@+node:ekr.20071001080039:cut/copy/paste
# In the Edit menu...
def OnCopy (self,event=None): self.OnCopyFromMenu()
def OnCut (self,event=None): self.OnCutFromMenu()
def OnPaste (self,event=None): self.OnPasteFromMenu()

def OnCutFromMenu (self):
    self.OnCopyFromMenu()
    self.body.editor.editor.replaceSelection("")

def OnCopyFromMenu (self):

    gui = g.app.gui
    editor = self.body.editor.editor
    txt = editor.getSelectedText()
    gui.replaceClipboardWith(txt)

def OnPasteFromMenu (self):

    txt = g.app.gui.getTextFromClipboard()
    editor = self.body.editor.editor
    document = self.body.editor.editor.getStyledDocument()
    if txt:
        pos = editor.getCaretPosition()
        document.insertString(pos,txt,None)
#@-node:ekr.20071001080039:cut/copy/paste
#@-node:ekr.20070930184746.167: gui-dependent commands
#@+node:ekr.20070930184746.168:bringToFront, deiconify, lift & update
def bringToFront (self):

    self.top.toFront()

def deiconify (self):

    self.top.setVisible(True)

def lift (self):

    self.top.toFront()

def update (self):

    self.top.repaint()

#@-node:ekr.20070930184746.168:bringToFront, deiconify, lift & update
#@+node:ekr.20070930184746.169:config stuff...
#@+node:ekr.20070930184746.170:resizePanesToRatio
def resizePanesToRatio (self,ratio,secondary_ratio):

    def resize ():
        self.jsp1.setDividerLocation(ratio)
        self.jsp2.setDividerLocation(secondary_ratio)

    dc = DefCallable(resize)
    java.awt.EventQueue.invokeLater(java.util.concurrent.FutureTask(dc))
#@-node:ekr.20070930184746.170:resizePanesToRatio
#@+node:ekr.20070930184746.171:setInitialWindowGeometry
def setInitialWindowGeometry (self):
    """Set the position and size of the frame to config params."""
    #config = g.app.config
    c = self.c
    h = c.config.getInt("initial_window_height")
    w = c.config.getInt("initial_window_width")
    x = c.config.getInt("initial_window_left")
    y = c.config.getInt("initial_window_top")

    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)

    #was:
    #h = config.getIntWindowPref("initial_window_height")
    #w = config.getIntWindowPref("initial_window_width")
    #x = config.getIntWindowPref("initial_window_left")
    #y = config.getIntWindowPref("initial_window_top")
    #if h and w and x and y:
    #    self.setTopGeometry(w,h,x,y)
#@nonl
#@-node:ekr.20070930184746.171:setInitialWindowGeometry
#@+node:ekr.20070930184746.172:setTopGeometry
def setTopGeometry (self,w,h,x,y,adjustSize=True):

    if self.canresize:
        self.top.setBounds(x,y,w,h)

def disableResizing (self):

    self.canresize = False

def enableResizing (self):

    self.canresize = True
#@nonl
#@-node:ekr.20070930184746.172:setTopGeometry
#@+node:ekr.20070930184746.173:get_window_info
def get_window_info (self):

    bounds = self.top.getBounds()
    return (bounds.width,bounds.height,bounds.x,bounds.y)
#@-node:ekr.20070930184746.173:get_window_info
#@-node:ekr.20070930184746.169:config stuff...
#@-node:ekr.20070930184746.166: Must be defined in subclasses
#@+node:ekr.20071001080420:Unchanged from base class
#@+node:ekr.20070930184746.176:setTabWidth
def setTabWidth (self,w):

    # Subclasses may override this to affect drawing.
    self.tab_width = w
#@nonl
#@-node:ekr.20070930184746.176:setTabWidth
#@+node:ekr.20070930184746.177:getTitle & setTitle
def getTitle (self):
    return self.title

def setTitle (self,title):
    self.top.title = title
#@nonl
#@-node:ekr.20070930184746.177:getTitle & setTitle
#@+node:ekr.20070930184746.178:initialRatios
def initialRatios (self):

    config = g.app.config

    s = config.getWindowPref("initial_splitter_orientation")
    verticalFlag = s == None or (s!="h" and s!="horizontal")

    if verticalFlag:
        r = config.getFloatWindowPref("initial_vertical_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.5
        r2 = config.getFloatWindowPref("initial_vertical_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = config.getFloatWindowPref("initial_horizontal_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.3
        r2 = config.getFloatWindowPref("initial_horizontal_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8

    # print r,r2
    return verticalFlag, r, r2
#@nonl
#@-node:ekr.20070930184746.178:initialRatios
#@+node:ekr.20070930184746.179:longFileName & shortFileName
def longFileName (self):

    return self.c.mFileName

def shortFileName (self):

    return g.shortFileName(self.c.mFileName)
#@nonl
#@-node:ekr.20070930184746.179:longFileName & shortFileName
#@+node:ekr.20070930184746.180:oops
def oops (self):

    print "leoFrame oops:", g.callerName(2), "should be overridden in subclass"
#@-node:ekr.20070930184746.180:oops
#@+node:ekr.20070930184746.181:promptForSave
def promptForSave (self):

    """Prompt the user to save changes.

    Return True if the user vetos the quit or save operation."""

    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    type = g.choose(g.app.quitting,"quitting?","closing?")
    answer = g.app.gui.runAskYesNoCancelDialog(
        "Confirm",
        'Save changes to %s before %s' % (name,type))
    # print answer	
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            << Put up a file save dialog to set mFileName >>
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.
#@nonl
#@+node:ekr.20070930184746.182:<< Put up a file save dialog to set mFileName >>
# Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title = "Save",
    filetypes = [("Leo files","*.leo")],
    defaultextension = ".leo")
#@nonl
#@-node:ekr.20070930184746.182:<< Put up a file save dialog to set mFileName >>
#@-node:ekr.20070930184746.181:promptForSave
#@+node:ekr.20070930184746.183:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20070930184746.184:<< set w and break on @tabwidth >>
if dict.has_key("tabwidth"):

    val = g.scanAtTabwidthDirective(s,dict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20070930184746.184:<< set w and break on @tabwidth >>
#@-node:ekr.20070930184746.183:scanForTabWidth
#@-node:ekr.20071001080420:Unchanged from base class
#@+node:ekr.20071001080420.1:New methods
#@+node:ekr.20070930184746.185:destroySelf --had to be added
def destroySelf (self):

    self.top.setVisible(False)
    self.top.dispose()
    self.top = None

#@-node:ekr.20070930184746.185:destroySelf --had to be added
#@+node:ekr.20070930184746.186:clearStatusLine -- had to be added
def clearStatusLine (self):
    pass

def putStatusLine (self,s,**kwords):
    pass
#@nonl
#@-node:ekr.20070930184746.186:clearStatusLine -- had to be added
#@+node:ekr.20070930184746.187:finishCreateForSettings
def finishCreateForSettings (self,c,controller):

    self.c = c
    self.top = swing.JFrame()
    self.ftp = self.leoFocusTraversalPolicy(c)
    self.top.setFocusTraversalPolicy(self.ftp)
    self.top.setTitle("Leo Settings")

    ic = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF")
    ifile = java.io.File(ic)
    if ifile.exists():
        iimage = imageio.ImageIO.read(ifile)
        self.top.setIconImage(iimage)
    self.top.setDefaultCloseOperation(swing.JFrame.EXIT_ON_CLOSE)
    self.setTitle(c.mFileName)
    pf = self.top.getContentPane()
    gbl = awt.GridBagLayout()
    pf.setLayout(gbl)
    gbc = awt.GridBagConstraints()
    gbc.weightx = 1
    gbc.weighty = 1
    gbc.fill = 1


    self.jcp = self.top.getContentPane()
    self.jsp1 = swing.JSplitPane(swing.JSplitPane.VERTICAL_SPLIT)
    gbl.setConstraints(self.jsp1,gbc)
    self.jsp1.continuousLayout = True
    pf.add(self.jsp1)
    self.jtab = self.c.chapters.getWidget()
    c.chapters.disablePopup()
    self.jsp1.leftComponent = self.jtab
    self.jsp1.rightComponent = swing.JPanel()
    self.tree = c.chapters.addChapterForSettingsTree("Settings",p=c.rootPosition(),controller=controller)
    self.tree.jtree.setEditable(False)
    class fkBody:

        class ed:
            def __init__ (self):
                self.editor = swing.JTextPane()

            def sync (self,*args):
                pass

        def __init__ (self):
            self.editor = self.ed()

        def setFocus (self):
            pass

        def setSelectionAreas (self,*args):
            pass

        def setTextSelection (self,*args):
            pass

        def recolor (self,*args):
            pass

        def setColorFromConfig (self,*args):
            pass

    self.body = fkBody()
    self.jsp1.setOneTouchExpandable(True)
    << create the first tree node >>
    self.jsp1.setDividerLocation(.5)
    g.app.windowList.append(self)
    c.initVersion()
    c.signOnWithVersion()
    self.tree.jtree.setDragEnabled(False)


#@+node:ekr.20070930184746.188:<< create the first tree node >>
import leoNodes
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")
c.beginUpdate()
p.moveToRoot()
#c.beginUpdate()
#c.selectVnode(p)
c.selectPosition(p)
#c.redraw()
#c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)


#@-node:ekr.20070930184746.188:<< create the first tree node >>
#@-node:ekr.20070930184746.187:finishCreateForSettings
#@+node:ekr.20070930184746.190:setSkin
def setSkin (self,notification=None,handback=None):

    c = self.c
    toskin = g.app.config.getString(c,'type_of_skin')
    if toskin == 'native':

        nlafname = swing.UIManager.getSystemLookAndFeelClassName()
        if nlafname:
            import java.lang.Class
            nlaf = java.lang.Class.forName(nlafname).newInstance()
            swing.UIManager.setLookAndFeel(nlaf)
    elif toskin == 'synth':
        try:
            slaf = synth.SynthLookAndFeel()
            sname = g.app.config.getString(c,'custom_skin')
            ldir1 = io.File(g.app.loadDir)
            ldir2 = ldir1.getParent()
            ldir3 = io.File(ldir2,"skins")
            ldir4 = io.File(ldir2,"skinimages")
            synthfile = io.File(ldir3,sname)
            fis = io.FileInputStream(synthfile)
            import JyLeoResourceClassLoader as jlrc
            cloader = jlrc(ldir4,ldir1)
            clazz = cloader.getFakeClass()
            slaf.load(fis,clazz)
            swing.UIManager.setLookAndFeel(slaf)
        except java.lang.Exception, x:
            x.printStackTrace()
            g.es("Could not load custom skin")
    else:
        swing.UIManager.setLookAndFeel("javax.swing.plaf.metal.MetalLookAndFeel")




#@-node:ekr.20070930184746.190:setSkin
#@+node:ekr.20070930184746.191:addIconButton -- had to be added
def addIconButton (self,*args,**kwords):

    toolbar = self.toolbar2
    text = kwords ['text']
    button = swing.JButton(text)
    toolbar.add(button)
    return button
#@-node:ekr.20070930184746.191:addIconButton -- had to be added
#@+node:ekr.20070930184746.192:toggleActivePane
def toggleActivePane (self):

    kfm = awt.KeyboardFocusManager.getCurrentKeyboardFocusManager()
    kfm.focusNextComponent()



#@-node:ekr.20070930184746.192:toggleActivePane
#@+node:ekr.20070930184746.193:isMenuInitialized
def isMenuInitialized (self,callback):

    if self.menu != None:
        callback(self.menu)
    else:
        self._menu_init_callbacks.append(callback)


def menuInitialized (self):

    for z in self._menu_init_callbacks:
        z(self.menu)

    self._menu_init_callbacks = []
#@nonl
#@-node:ekr.20070930184746.193:isMenuInitialized
#@+node:ekr.20070930184746.194:startReceiver
def startReceiver (self):

    import java
    self.receiver = receiver = self.Receiver(self,self.c)
    thread = java.lang.Thread(receiver)
    thread.setDaemon(True)
    thread.start()

def hasReceiver (self):

    if self.receiver:
        return True
    else:
        return False
#@nonl
#@-node:ekr.20070930184746.194:startReceiver
#@-node:ekr.20071001080420.1:New methods
#@+node:ekr.20070930184746.195:helper classes
@others
#@+node:ekr.20070930184746.196:class leoFocusTraversalPolicy
class leoFocusTraversalPolicy(awt.FocusTraversalPolicy):
    """This class implements the Traversale Policy for a Leo instance,
    Ctrl-T moves from widget to widget.  The Policy moves the Widgets like so:
    Editor --> Tree --> Log --> (Back to Editor)"""

    def __init__ (self,c):
        awt.FocusTraversalPolicy.__init__(self)
        self.c = c

    @others

#@+node:ekr.20070930184746.197:getComponentAfter
def getComponentAfter (self,aContainer,aComponent):

    try:
        c = self.c
        if str(c.frame.tree.__class__) == "leoConfig.settingsTree":
            return c.frame.tree.jtree

        editor = c.frame.body.editor.editor
        logCtrl = c.frame.log.getCurrentTab()
        tree = c.frame.tree.jtree
        tree_editor = c.frame.tree.tcEdi.editor._jta

        if aComponent == editor:
            return tree
        elif aComponent == tree:

            return logCtrl

        elif aComponent == tree_editor:
            return logCtrl

        else:
            return editor
    except java.lang.Exception, x:
        x.printStackTrace()
        return editor

#@-node:ekr.20070930184746.197:getComponentAfter
#@+node:ekr.20070930184746.198:getComponentBefore
def getComponentBefore (self,aContainer,aComponent):

    logCtrl = self.c.frame.log.getCurrentTab()
    editor = self.c.frame.body.editor.editor
    tree = self.c.frame.tree.jtree
    tree_editor = self.c.frame.tree.tcEdi.editor._jta

    if aComponent == editor:
        return logCtrl
    elif aComponent == tree:
        return editor

    elif aComponent == tree_editor:
        return editor
    else:
        return tree

#@-node:ekr.20070930184746.198:getComponentBefore
#@+node:ekr.20070930184746.199:getDefaultComponent
def getDefaultComponent (self,container):

    return self.c.frame.body.editor.editor

#@-node:ekr.20070930184746.199:getDefaultComponent
#@+node:ekr.20070930184746.200:getFirstComponent
def getFirstComponent (self,aContainer):

    return self.c.frame.body.editor.editor
#@nonl
#@-node:ekr.20070930184746.200:getFirstComponent
#@+node:ekr.20070930184746.201:getInitialComponent
def getInitialComponent (self,window):

    return self.c.frame.body.editor.editor



#@-node:ekr.20070930184746.201:getInitialComponent
#@+node:ekr.20070930184746.202:getLastComponent
def getLastComponent (self,aContainer):

    return self.c.frame.log.getCurrentTab()

#@-node:ekr.20070930184746.202:getLastComponent
#@-node:ekr.20070930184746.196:class leoFocusTraversalPolicy
#@+node:ekr.20070930184746.203:class Receiver
class Receiver(java.lang.Runnable):
    '''A Class that receives UDP packets, and will bring the frame
       parameter to the front if the packet contains the open file name
       of the Commander instance passed in'''

    def __init__ (self,frame,c):
        self.frame = frame
        self.c = c



#@+node:ekr.20071001072935:run
def run (self):

    s = java.lang.String(self.c.mFileName)
    random = java.util.Random(s.hashCode())
    i = 0
    while i <= 2000:
        i = random.nextInt(65535+1)

    ia = java.net.InetAddress.getByName("127.0.0.1")
    mcs = java.net.DatagramSocket(i,ia)

    import jarray
    s = java.lang.String(self.c.mFileName)
    bytes = s.getBytes()

    while 1:
        try:
            array = jarray.zeros(len(bytes),'b')
            dgp = java.net.DatagramPacket(array,len(bytes))
            dgp.setPort(i)
            dgp.setAddress(ia)
            mcs.receive(dgp)
            nexts = java.lang.String(dgp.getData())

            if nexts.equals(s):
                self.frame.top.setVisible(True)
                self.frame.top.setState(self.frame.top.NORMAL)
                self.frame.top.toFront()
                self.frame.body.editor.editor.requestFocusInWindow()
        except java.lang.Exception, x:
            x.printStackTrace()
#@-node:ekr.20071001072935:run
#@-node:ekr.20070930184746.203:class Receiver
#@+node:ekr.20070930184746.204:class GlassPane2
class GlassPane2(swing.JPanel):

    @others
#@nonl
#@+node:ekr.20071001072935.1:__init__
def __init__ (self):

    swing.JPanel.__init__(self)

    self.setOpaque(False)
    self.alpha = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,float(0.5))
    self.image = None
    self.setLayout(None)


#@-node:ekr.20071001072935.1:__init__
#@+node:ekr.20071001072935.2:setImage
def setImage (self,image):

    self.image = image
    self.setVisible(g.choose(image,True,False))
#@-node:ekr.20071001072935.2:setImage
#@+node:ekr.20071001072935.3:phaseIn
def phaseIn (self,widget):

    psize = widget.getPreferredSize()
    self.add(widget)
    bi = awt.image.BufferedImage(psize.width,psize.height,awt.image.BufferedImage.TYPE_INT_RGB)
    g = bi.createGraphics()
    widget.paint(g)
    self.remove(widget)
    g.dispose()
    self.setVisible(True)
    self.Phaser(widget,bi,self)
#@-node:ekr.20071001072935.3:phaseIn
#@+node:ekr.20071001073047:class Phaser
class Phaser(aevent.ActionListener):

    def __init__ (self,widget,image,parent):
        self.widget = widget
        self.parent = parent
        self.image = image
        self.increments = 20
        self.waitperiod = 1000 / self.increments
        self.timer = swing.Timer(self.waitperiod,self)
        self.timer.start()

    def actionPerformed (self,event):

        alpha = 1.0 / self.increments
        g = self.parent.getGraphics()
        spot = self.widget.getLocation()
        ac = awt.AlphaComposite.getInstance(awt.AlphaComposite.SRC_OVER,alpha)
        g.setComposite(ac)
        g.drawImage(self.image,spot.x,spot.y,None)
        g.dispose()
        self.increments -= 1
        if self.increments == 0:
            self.timer.stop()
            self.parent.add(self.widget)
            self.parent.revalidate()
#@nonl
#@-node:ekr.20071001073047:class Phaser
#@+node:ekr.20071001072935.4:paintComponent2
def paintComponent2 (self,g):

    if not self.image: return

    composite = g.getComposite()
    mpi = awt.MouseInfo.getPointerInfo()
    location = mpi.getLocation()
    swing.SwingUtilities.convertPointFromScreen(location,self)
    g.setComposite(self.alpha)
    g.drawImage(self.image,location.x,location.y,None)
    g.setComposite(composite)
#@nonl
#@-node:ekr.20071001072935.4:paintComponent2
#@-node:ekr.20070930184746.204:class GlassPane2
#@+node:ekr.20070930184746.205:class NodeBar
import java.awt.datatransfer as dtfr

class NodeBar(dtfr.FlavorListener,java.lang.Runnable):
    '''This class creates a toolbar that offers the user the ability to manipulate nodes
        with a button press.'''

    @others

#@+node:ekr.20070930184746.207: __init__
def __init__ (self,c,toolbar):

    self.c = c
    bcommands = (
        (c.moveOutlineUp,"nodeup.gif",'Move Node Up',c.canMoveOutlineUp),
        (c.moveOutlineDown,"nodedown.gif",'Move Node Down',c.canMoveOutlineDown),
        (c.moveOutlineLeft,"nodeleft.gif",'Move Node Left',c.canMoveOutlineLeft),
        (c.moveOutlineRight,"noderight.gif",'Move Node Right',c.canMoveOutlineRight),
        (c.clone,"clone.gif",'Clone Node',c.canClone),
        (c.copyOutline,"copy.gif",'Copy Node',0),
        (c.cutOutline,"cut.gif",'Cut Node',c.canCutOutline),
        (c.deleteOutline,"delete.gif",'Delete Node',c.canDeleteHeadline),
        (c.pasteOutline,"paste.gif",'Paste Node',c.canPasteOutline),
        (c.pasteOutlineRetainingClones,"pasteclone.gif",'Paste Retaining Clones',c.canPasteOutline),
        (c.insertHeadline,"insert.gif",'Insert Node',0),
        (c.demote,"demote.gif",'Demote',c.canDemote),
        (c.promote,"promote.gif",'Promote',c.canPromote),
        (c.hoist,"hoist.gif",'Hoist',c.canHoist),
        (c.dehoist,"dehoist.gif",'De-Hoist',c.canDehoist),
        (c.sortChildren,"sortchildren.gif",'Sort Children',c.canSortChildren),
        (c.sortSiblings,"sortsiblings.gif",'Sort Siblings',c.canSortSiblings),
        (c.goToPrevSibling,"moveup.gif",'Goto Previous Sibling',self.canGotoPreviousSibling),
        (c.goToNextSibling,"movedown.gif",'Goto Next Sibling',self.canGotoNextSibling),
        (c.goToParent,"moveleft.gif",'Goto Parent',self.canGotoParent),
        (self.goToChild,"moveright.gif",'Goto Child',self.canGotoChild),
    )

    self.buttons_enabled = {}
    for z in bcommands:
        button = self.createButton(z[1])
        button.setToolTipText(z[2])
        button.actionPerformed = self.getCallback(z[0])
        if z [3]: self.buttons_enabled [button] = z [3]
        toolbar.add(button)

    wm1 = WeakMethod(self,"endUpdate")
    leoPlugins.registerHandler("select1",wm1)
    leoPlugins.registerHandler("chapter-changed",wm1)
    leoPlugins.registerHandler("chapter-removed",wm1)
    leoPlugins.registerHandler("hoist-executed",wm1)
    leoPlugins.registerHandler("dehoist-executed",wm1)
    #--> disable for now, this seems to flaky behavorialy, but the idea is good
    #tk = java.awt.Toolkit.getDefaultToolkit()
    #clipboard = tk.getSystemClipboard()
    #clipboard.addFlavorListener( self )
    self.runs = 0

def getCallback (self,command):

    def callback (self,event=None,c=self.c):
        command()


    return callback

#@-node:ekr.20070930184746.207: __init__
#@+node:ekr.20070930184746.210:createButton
def createButton (self,name):

    #bytes = java.lang.String( base64.decodestring( data ) ).getBytes()

    path = g.os_path_join(g.app.loadDir,"..","Icons/nodebar",name)
    ii = swing.ImageIcon(path)
    jb = swing.JButton(ii)
    #size = awt.Dimension( ii.getIconWidth(), ii.getIconHeight() )
    return jb

#@-node:ekr.20070930184746.210:createButton
#@+node:ekr.20070930184746.212:endUpdate
def endUpdate (self,tag,*args,**kwords):

    c = args [0] ['c']
    #print tag
    if c == self.c:
        swing.SwingUtilities.invokeLater(self)
    else:
        print "C %s not == to %s" % (c,self.c)



#@-node:ekr.20070930184746.212:endUpdate
#@+node:ekr.20070930184746.208:flavorsChanged
def flavorsChanged (self,event):

    #print event
    #print event.getSource()
    cb = event.getSource()
    #print cb.getName()
    #import java.awt.datatransfer as dtfr
    #print cb.getData( dtfr.DataFlavor.stringFlavor )
    #print cb.getAvailableDataFlavors()
    self.endUpdate("flavor-change",{'c': self.c})
#@nonl
#@-node:ekr.20070930184746.208:flavorsChanged
#@+node:ekr.20070930184746.209:goto enablers
def canGotoParent (self):

    cp = self.c.currentPosition()
    if not cp: return False
    parent = cp.getParent()
    if parent:
        return True
    return False


def canGotoChild (self):

    cp = self.c.currentPosition()
    if not cp: return False
    nc = cp.numberOfChildren()
    if nc != 0: return True
    return False

def canGotoPreviousSibling (self):

    cp = self.c.currentPosition()
    if not cp: return False
    psibling = cp.moveToBack()
    if psibling:
        return True
    return False

def canGotoNextSibling (self):

    cp = self.c.currentPosition()
    if not cp: return False
    nsibling = cp.moveToNext()
    if nsibling:
        return True
    return False
#@nonl
#@-node:ekr.20070930184746.209:goto enablers
#@+node:ekr.20070930184746.211:gotoChild
def goToChild (self):

    c = self.c ; p = c.currentPosition()

    if p.hasChildren():
        beginUpdate()
        try:
            c.selectPosition(p.firstChild())
        finally:
            endUpdate()
#@nonl
#@-node:ekr.20070930184746.211:gotoChild
#@+node:ekr.20070930184746.206:images
@
nodeup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhqM
j6nL7QDcgVBS2u5dWqfeTWA4lqYnpeqqFgA7'''
nodedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhuM
j6nL7Q2inLTaGW49Wqa+XBD1YE8GnOrKBgUAOw=='''
nodeleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiOM
jwDIqd3Ug0dOam/MC3JdfR0jjuRHBWjKpUbmvlIsm65WAAA7'''
noderight = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiGM
A3DLltrag/FMWi+WuiK9WWD4gdGYdenklUnrwqX8tQUAOw=='''
clone = r'''R0lGODlhEAAQAIABAP8AAP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAhaM
j6nL7Q8jBDRWG8DThjvqSeJIlkgBADs='''
copy = r'''R0lGODlhEAAQAMIEAAAAAI9pLOcxcaCclf///////////////ywAAAAAEAAQAAADLEi63P5vSLiC
vYHiq6+wXSB8mQKcJ2GNLAssr0fCaOyB0IY/ekn9wKBwSEgAADs='''
cut = r'''R0lGODlhEAAQAKECAAAAAKCclf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiaUDad7yS8cnDNYi4A0t7vNaCLTXR/ZZSBFrZMLbaIWzhLczCxTAAA7'''
paste = r'''R0lGODlhEAAQAKECAAAAAB89vP///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUH3nLktHYm9HMV92FWfPugQcgjqVBnmm5dsD7gmsbwfEZFQA7'''
insert = r'''R0lGODlhEAAQAKECAAAAAB89vP///////ywAAAAAEAAQAAACKJRhqSvIDGJ8yjWa5MQ5BX4JwXdo
3RiYRyeSjRqKmGZRVv3Q4M73VAEAOw=='''
demote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiiUj2nBrNniW+G4eSmulqssgAgoduYWeZ+kANPkCsBM1/abxLih70gBADs='''
promote = r'''R0lGODlhEAAQAKECACMj3ucxcf///////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUj6kX7cvcgy1CUU1ecvJ+YUGIbKSJAAlqqGQLxPI8t29650YBADs='''
pasteclone = r'''R0lGODlhEAAQAKEDACMj3v8AAP/9/f///ywAAAAAEAAQAAACOJSPaTPgoxBzgEVDM4yZbtU91/R8
ClkJzGqp7MK21rcG9tYedSCb7sDjwRLAGs7HsPF8khjzcigAADs='''
hoist = r'''R0lGODlhEAAQAKECAAAAAENMzf/9/f/9/SwAAAAAEAAQAAACI5SPaRCtypp7S9rw4sVwzwQYW4ZY
JAWhqYqE7OG+QvzSrI0WADs='''
dehoist = r'''R0lGODlhEAAQAKECAAAAACMj3v/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiOUj6lrwOteivLQKi4LXCcOegJIBmIZLminklbLISIzQ9hbAAA7'''
question = r'''R0lGODlhEAAQAIABAB89vP///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiCM
DwnHrNrcgzFQGuGrMnGEfdtnjKRJpt2SsuxZqqgaFQA7'''
sortchildren = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SwAAAAAEAAQAAACJJSPKcGt2NwzbKpqYcg68oN9ITde
UQCkKgCeCvutsDXPk/wlBQA7'''
sortsiblings = r'''R0lGODlhEAAQAKECAAAAAB89vP/9/f/9/SH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAA
EAAAAiWUFalxbatcS7IiZh3NE2L+fOAGXpknal4JlAIAw2Br0Fksu1YBADs='''
delete = r'''R0lGODlhEAAQAMIEAAAAAB89vKCclbq3sv///////////////yH+FUNyZWF0ZWQgd2l0aCBUaGUg
R0lNUAAsAAAAABAAEAAAAzJIutwKELoGVp02Xmy5294zDSSlBAupMleAEhoYuahaOq4yCPswvYQe
LyT0eYpEW8iRAAA7'''
moveup = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh6M
j6nL7QDcgVDWcFfGUW3zfVPHPZHoUeq6Su4LwwUAOw=='''
movedown = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAh+M
j6nL7Q2inFS+EDFw2XT1eVsSHmGJdChpXesFx00BADs='''
moveleft = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
jwDIqd3egueFSe2lF2+oGV41fkwoZmNJJlxXvbDJSbKI1l4BADs='''
moveright = r'''R0lGODlhEAAQAIABAENMzf///yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAsAAAAABAAEAAAAiWM
A3DLltqaSpFBWt3BFTovWeAyIiUinSNnkaf2Zagpo2x343IBADs='''
@c



#@-node:ekr.20070930184746.206:images
#@+node:ekr.20071001073819:run
def run (self):

    try:
        #print "RUN NUMBER %s" % self.runs
        self.runs += 1
        for z in self.buttons_enabled:
            button = z
            callback = self.buttons_enabled [z]
            #print callback
            if callback():
                button.setEnabled(1)
            else:
                button.setEnabled(0)
    except:
        print "BOOM!!"
#@-node:ekr.20071001073819:run
#@-node:ekr.20070930184746.205:class NodeBar
#@+node:ekr.20070930184746.213:class WindowClosingWatcher
class WindowClosingWatcher(aevent.WindowAdapter):

    def __init__ (self,frame):
        aevent.WindowAdapter.__init__(self)
        self.frame = frame

    def windowClosing (self,event):

        g.app.closeLeoWindow(self.frame)
        if len(g.app.windowList) == 0:
            java.lang.System.exit(0)
#@-node:ekr.20070930184746.213:class WindowClosingWatcher
#@+node:ekr.20070930184746.214:class LeoMetalTheme
class LeoMetalTheme(swing.plaf.metal.DefaultMetalTheme):

    def __init__ (self,c):

        swing.plaf.metal.DefaultMetalTheme.__init__(self)
        self.c = c
        self.p1 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.p3 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.p2 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.s1 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.s2 = swing.plaf.ColorUIResource(awt.Color.YELLOW)
        self.s3 = swing.plaf.ColorUIResource(awt.Color.YELLOW)

        print self.p1, self.p2, self.p3, self.s1, self.s2, self.s3

    @others
#@+node:ekr.20071001074041.1:getName
def getName (self):
    return "LeoMetalTheme"

#@-node:ekr.20071001074041.1:getName
#@+node:ekr.20071001074041.2:getControlTextFont2
def getControlTextFont2 (self):
    pass

#@-node:ekr.20071001074041.2:getControlTextFont2
#@+node:ekr.20071001074041.3:getMenuTextFont2
def getMenuTextFont2 (self):
    pass

#@-node:ekr.20071001074041.3:getMenuTextFont2
#@+node:ekr.20071001074041.4:getPrimary1
def getPrimary1 (self):
    print 'p1'
    return self.p1

#@-node:ekr.20071001074041.4:getPrimary1
#@+node:ekr.20071001074041.5:getPrimary2
def getPrimary2 (self):
    print 'p2'
    return self.p2

#@-node:ekr.20071001074041.5:getPrimary2
#@+node:ekr.20071001074041.6:getPrimary3
def getPrimary3 (self):
    print 'p3'
    return self.p3

#@-node:ekr.20071001074041.6:getPrimary3
#@+node:ekr.20071001074041.7:getSecondary1
def getSecondary1 (self):
    print "s1"
    return self.s1

#@-node:ekr.20071001074041.7:getSecondary1
#@+node:ekr.20071001074041.8:getSecondary2
def getSecondary2 (self):
    print "s2"
    return self.s2

#@-node:ekr.20071001074041.8:getSecondary2
#@+node:ekr.20071001074041.9:getSecondary3
def getSecondary3 (self):
    print "s3"
    return self.s3

#@-node:ekr.20071001074041.9:getSecondary3
#@+node:ekr.20071001074041.10:getBlack2
def getBlack2 (self):
    print "BLACK"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

#@-node:ekr.20071001074041.10:getBlack2
#@+node:ekr.20071001074041.11:getMenuBackground
def getMenuBackground (self):
    print "GMB"
    return self.getWhite()

#@-node:ekr.20071001074041.11:getMenuBackground
#@+node:ekr.20071001074041.12:getMenuForeground
def getMenuForeground (self):
    print "MFG"
    return self.getBlack()

#@-node:ekr.20071001074041.12:getMenuForeground
#@+node:ekr.20071001074041.13:getMenuSelectedForeground
def getMenuSelectedForeground (self):
    print "MSFG!"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

#@-node:ekr.20071001074041.13:getMenuSelectedForeground
#@+node:ekr.20071001074041.14:getMenuSelectedBackground
def getMenuSelectedBackground (self):
    print "MSBG"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

#@-node:ekr.20071001074041.14:getMenuSelectedBackground
#@+node:ekr.20071001074041.15:getPrimaryControl
def getPrimaryControl (self):
    print "PCONTROL"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

#@-node:ekr.20071001074041.15:getPrimaryControl
#@+node:ekr.20071001074041.16:getControl
def getControl (self):
    print "CONTROL"
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

#@-node:ekr.20071001074041.16:getControl
#@+node:ekr.20071001074041.17:getControlHighlight
def getControlHighlight (self):
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

#@-node:ekr.20071001074041.17:getControlHighlight
#@+node:ekr.20071001074041.18:getPrimaryControlHighlight
def getPrimaryControlHighlight (self):
    return swing.plaf.ColorUIResource(awt.Color.YELLOW)

#@-node:ekr.20071001074041.18:getPrimaryControlHighlight
#@+node:ekr.20071001074041.19:getSystemTextColor
def getSystemTextColor (self):
    return swing.plaf.ColorUIResource(awt.Color.WHITE)

#@-node:ekr.20071001074041.19:getSystemTextColor
#@+node:ekr.20071001074041.20:getSubTextFont2
def getSubTextFont2 (self):
    pass

#@-node:ekr.20071001074041.20:getSubTextFont2
#@+node:ekr.20071001074041.21:getSystemTextFont2
def getSystemTextFont2 (self):
    pass

#@-node:ekr.20071001074041.21:getSystemTextFont2
#@+node:ekr.20071001074041.22:getUserTextFont2
def getUserTextFont2 (self):
    pass

#@-node:ekr.20071001074041.22:getUserTextFont2
#@+node:ekr.20071001074041.23:getWindowTitleFont2
def getWindowTitleFont2 (self):
    pass
#@-node:ekr.20071001074041.23:getWindowTitleFont2
#@-node:ekr.20070930184746.214:class LeoMetalTheme
#@-node:ekr.20070930184746.195:helper classes
#@-node:ekr.20070930184746.164:class leoSwingFrame
#@+node:ekr.20070930184746.215:class leoSwingGui
class leoSwingGui:

    @others
#@+node:ekr.20070930184746.216:app.gui Birth & death
#@+node:ekr.20070930184746.217: leoGui.__init__
def __init__ (self):

    # g.trace("leoGui",guiName)
    #leoGui.leoGui.__init__( self, "swing" )
    self.leoIcon = None
    self.mGuiName = "swing"
    self.mainLoop = None
    self.root = None
    self.utils = None
    self.isNullGui = False
    self.ex = java.util.concurrent.Executors.newSingleThreadScheduledExecutor()
    self.startup_tasks = java.util.ArrayList()
    self.laflistener = self.LAFChangeListener()
    swing.UIManager.addPropertyChangeListener( self.laflistener )
#@-node:ekr.20070930184746.217: leoGui.__init__
#@+node:ekr.20070930184746.218:newLeoCommanderAndFrame (gui-independent)
def newLeoCommanderAndFrame(self,fileName, updateRecentFiles = True):

    """Create a commander and its view frame for the Leo main window."""

    import leoCommands

    if not fileName: fileName = ""
    << compute the window title >>
@
    if not splashseen:
        #self.splash = splash = swing.JWindow()
        #splash.setBackground( awt.Color.ORANGE )
        #dimension = awt.Dimension( 500, 500 )
        #splash.setPreferredSize( dimension )
        #splash.setSize( 500, 500 )
        #ii = swing.ImageIcon( "../Icons/Leosplash.GIF" )
        #image = swing.JLabel( ii )
        #image.setBackground( awt.Color.ORANGE )
        #splash.add( image )
        #self.splashlabel = swing.JLabel( "BORKERS ar fUN" )
        #splash.add( self.splashlabel, awt.BorderLayout.SOUTH )
        w, h = self._calculateCenteredPosition( splash )
        splash.setLocation( w, h )
        splash.visible = True
@c
    # Create an unfinished frame to pass to the commanders.
    class Create( java.util.concurrent.Callable ):

        def call( self ):
            frame = g.app.gui.createLeoFrame(title)
            c = leoCommands.Commands( frame, fileName )
            frame.finishCreate( c )
            return c, frame

    creator = java.util.concurrent.FutureTask( Create() )
    java.awt.EventQueue.invokeAndWait( creator )
    c, frame = creator.get()
    self.c = c       
    # Create the commander and its subcommanders.
    #self.c = c = leoCommands.Commands(frame,fileName)

    # Finish creating the frame



    #frame.finishCreate(c)

    # Finish initing the subcommanders.
    #c.undoer.clearUndoState() # Menus must exist at this point.

    #c.updateRecentFiles(fileName) # 12/01/03
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    g.doHook("after-create-leo-frame",c=c)
    return c,frame
#@nonl
#@+node:ekr.20070930184746.219:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20070930184746.219:<< compute the window title >>
#@-node:ekr.20070930184746.218:newLeoCommanderAndFrame (gui-independent)
#@+node:ekr.20070930184746.220:stubs
#@+node:ekr.20070930184746.221:createRootWindow
def createRootWindow(self):

    """Create the hidden root window for the gui.

    Nothing needs to be done if the root window need not exist."""

    jf = swing.JFrame()
    return jf


#@-node:ekr.20070930184746.221:createRootWindow
#@+node:ekr.20070930184746.222:destroySelf
def destroySelf (self):

    #self.oops()
    pass
#@nonl
#@-node:ekr.20070930184746.222:destroySelf
#@+node:ekr.20070930184746.223:finishCreate
def finishCreate (self):

    """Do any remaining chores after the root window has been created."""
    #pass
    #self.c.frame.setTitle( self.c.mFileName )
    pass


#@-node:ekr.20070930184746.223:finishCreate
#@+node:ekr.20070930184746.224:killGui
def killGui(self,exitFlag=True):

    """Destroy the gui.

    The entire Leo application should terminate if exitFlag is True."""

    pass
#@nonl
#@-node:ekr.20070930184746.224:killGui
#@+node:ekr.20070930184746.225:recreateRootWindow
def recreateRootWindow(self):

    """Create the hidden root window of the gui
    after a previous gui has terminated with killGui(False)."""

    pass
#@nonl
#@-node:ekr.20070930184746.225:recreateRootWindow
#@+node:ekr.20070930184746.226:runMainLoop
def runMainLoop(self):
    """Run the gui's main loop."""

    def rml():
        self.c.frame.tree.doneLoading()
        self.c.frame.top.visible = True
        self.c.frame.jsp1.setDividerLocation( .75 )
        self.c.frame.jsp2.setDividerLocation( .5 )
        self.c.selectPosition( self.c.currentPosition() )
        self.c.frame.body.editor.editor.setCaretPosition( 0 ) #otherwise the caret is at the end, yuck.
        dc = DefCallable( self.ex.shutdown )
        self.startup_tasks.add( dc )
        for z in self.startup_tasks:
            self.ex.submit( z )

        def hide():
            splash.hide()
        dc = DefCallable( hide )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )

    dc = DefCallable( rml )
    ft = dc.wrappedAsFutureTask()    
    java.awt.EventQueue.invokeLater( ft )
#@-node:ekr.20070930184746.226:runMainLoop
#@-node:ekr.20070930184746.220:stubs
#@-node:ekr.20070930184746.216:app.gui Birth & death
#@+node:ekr.20070930184746.227:app.gui dialogs
def runAboutLeoDialog(self,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    dialog = self._getDialog( "About Leo" )
    cpane = dialog.getContentPane()
    data = "%s\n%s\n\n%s\n\n%s" % ( version, theCopyright, url, email )
    jtc = swing.JTextArea()
    jtc.setText( data )
    jtc.setEditable( False )
    dialog.add( jtc )
    class cl_act( swing.AbstractAction ):
        def __init__( self, dialog ):
            swing.AbstractAction.__init__( self, "Close" )
            self.dialog = dialog

        def actionPerformed( self, aE ):
            self.dialog.dispose()
    button = swing.JButton( cl_act( dialog ) )
    jbp = swing.JPanel()
    jbp.add( button )
    dialog.add( jbp, awt.BorderLayout.SOUTH )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.visible = 1

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs login name is a good choice.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.") 

    dialog = swing.JDialog()
    dialog.title = "Create a Leo ID"
    dialog.modal = 1
    cpane = dialog.getContentPane()
    jta = swing.JTextArea()
    jta.setText( message )
    jta.editable = 0
    cpane.add( jta, awt.BorderLayout.NORTH )
    jtf = swing.JTextField()
    jp = swing.JPanel()
    jp.setBorder( sborder.TitledBorder( "Your ID:" ) )
    gbl = awt.GridBagLayout()
    jp.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    gbc.weightx =1
    gbc.weighty = 1
    gbl.setConstraints( jtf, gbc )
    jp.add( jtf )
    cpane.add( jp, awt.BorderLayout.CENTER )
    class _OK( swing.AbstractAction ):
        def __init__( self ):
            swing.AbstractAction.__init__( self, "OK" )

        def actionPerformed( self, ae ):
            dialog.dispose()
    jb = swing.JButton( _OK()  )

    jb.setEnabled( False )
    jpanel2 = swing.JPanel()
    jpanel2.add(jb )
    cpane.add( jpanel2, awt.BorderLayout.SOUTH )
    class _Enabler( sevent.DocumentListener ):

        def __init__( self ):
            pass

        def changedUpdate( self, de ):
            pass

        def insertUpdate( self, de ):

            l = de.getDocument().getLength()
            if l >= 3: jb.setEnabled( True )

        def removeUpdate( self, de ):

            l = de.getDocument().getLength()
            if l <3: jb.setEnabled( False )
    jtf.getDocument().addDocumentListener( _Enabler() )       
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    splash.toBack()
    dialog.visible = 1
    g.app.leoID = jtf.getText()
    splash.toFront()

def runAskOkDialog(self,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,title,message):
    """Create and run askOkCancelNumber dialog ."""
    dialog = self._getDialog( title )
    cpane = dialog.getContentPane()
    holder = swing.JPanel()
    gbl = awt.GridBagLayout()
    holder.setLayout( gbl )
    gbc = awt.GridBagConstraints()
    gbc.fill = 1
    gbc.weightx = 1
    gbc.weighty = 1
    jtf = swing.JTextField()
    gbl.setConstraints( jtf, gbc )
    holder.add( jtf )
    tborder = sborder.TitledBorder( message )
    holder.setBorder( tborder )
    cpane.add( holder )
    class _Search( swing.AbstractAction ):
        source = None
        def __init__( self, dialog, message ):
            swing.AbstractAction.__init__( self, message )
            self.dialog= dialog
            self.message = message

        def actionPerformed( self, ae ):
            _Search.source = ae.getSource()
            self.dialog.dispose()

    jb = swing.JButton( _Search( dialog, "Ok" ) )
    jb2 = swing.JButton( _Search( dialog, "Cancel" ) )
    class _Enter( aevent.ActionListener ):
        def __init__( self, ok_but ):
            self.ok_but = ok_but

        def actionPerformed( self, aE ):
            _Search.source = self.ok_but
            dialog.dispose()

    jtf.addActionListener( _Enter( jb ) )
    class _AcceptOnlyNumbers( aevent.KeyAdapter ):

        def __init__( self  ):
            aevent.KeyAdapter.__init__( self )
            self.consume = False

        def keyPressed( self, ke ):

            kc = ke.getKeyCode()
            if kc in ( ke.VK_ENTER, ke.VK_BACK_SPACE ): return
            c = ke.getKeyChar()
            if not java.lang.Character.isDigit( c ):
                self.consume = True 
                ke.consume()

        def keyReleased( self, ke ):
            if self.consume:
                self.consume = False
                ke.consume()

        def keyTyped( self, ke ):
            if self.consume:
                ke.consume()

    jtf.addKeyListener( _AcceptOnlyNumbers() )
    bottom = swing.JPanel()
    bottom.add( jb, awt.BorderLayout.WEST )
    bottom.add( jb2, awt.BorderLayout.EAST )
    cpane.add( bottom, awt.BorderLayout.SOUTH )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.setVisible( True )
    if _Search.source is jb:
        return int( jtf.getText() )
    else:
        return -1

def runAskYesNoDialog(self,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""

    dialog = self._getDialog( title )
    class yno( swing.AbstractAction ):

        source = None
        def __init__( self, dialog, name ):
            swing.AbstractAction.__init__( self, name )
            self.dialog = dialog

        def actionPerformed( self, aE ):
            yno.source = aE.getSource()
            self.dialog.dispose()

    cpane = dialog.getContentPane()
    cpane.add( swing.JLabel( message ), awt.BorderLayout.NORTH )
    jp = swing.JPanel()
    cpane.add( jp, awt.BorderLayout.SOUTH )

    yes = swing.JButton( yno( dialog, yesMessage ) )
    no = swing.JButton( yno( dialog, noMessage ) )
    cancel = swing.JButton( yno( dialog, "Cancel" ) )
    jp.add( yes )
    jp.add( no )
    jp.add( cancel )
    dialog.pack()
    w, h = self._calculateCenteredPosition( dialog )
    dialog.setLocation( w, h )
    dialog.setAlwaysOnTop( 1 )
    dialog.setVisible( True )
    if yno.source is yes:
        return 'yes'
    elif yno.source is no:
        return 'no'
    elif yno.source is cancel:
        return "cancel"
    else:
        if defaultButton == 'Yes': return 'yes'
        else: return 'cancel'

def _getDialog( self, title ):

    jdialog = swing.JDialog( self.c.frame.top, title, True )
    jdialog.getContentPane().setName( "Leodialog" )
    return jdialog

def _getScreenPositionForDialog( self ):

    #tk = self.c.frame.top.getToolkit()
    tk = awt.Toolkit.getDefaultToolkit()
    dim = tk.getScreenSize()
    h = dim.height/2
    w = dim.width/2
    return h, w

def _calculateCenteredPosition( self, widget ):

    size = widget.getPreferredSize()
    height = size.height/2
    width = size.width/2
    h,w = self._getScreenPositionForDialog()
    height = h - height
    width = w - width
    return width, height



#@-node:ekr.20070930184746.227:app.gui dialogs
#@+node:ekr.20070930184746.228:app.gui file dialogs
class FileTypesFilter( swing.filechooser.FileFilter ):
    def __init__( self, filetypes ):
        swing.filechooser.FileFilter.__init__( self )
        self.filetypes = filetypes

    def accept( self, fvar ):
        name = fvar.getName()
        ftype = self.filetypes[ 1 ]
        ftype = ftype.strip( "*" )
        if name.endswith( ftype ): return True
        return False

    def getDescription( self ):
        return self.filetypes[ 0 ]


def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    import os
    fd = swing.JFileChooser( os.getcwd() )
    if filetypes:
        for x in fd.getChoosableFileFilters():
            fd.removeChoosableFileFilter( x )
    if filetypes:
        first = None
        for z in filetypes:
            filter = self.FileTypesFilter( z )
            if first is None: first = filter
            fd.addChoosableFileFilter( filter )
        if first:
            fd.setFileFilter( first )
    ok = fd.showOpenDialog( None )
    if ok == fd.APPROVE_OPTION:
        f = fd.getSelectedFile()
        st = f.toString()
        if multiple:
            st = ( st , )
        return st


def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""
    import os
    #self.oops()
    fd = swing.JFileChooser( os.getcwd() )
    if filetypes:
        for x in fd.getChoosableFileFilters():
            fd.removeChoosableFileFilter( x )
    if filetypes:
        first = None
        for z in filetypes:
            filter = self.FileTypesFilter( z )
            if first is None: first = filter
            fd.addChoosableFileFilter( filter )
        if first:
            fd.setFileFilter( first )
    ok = fd.showSaveDialog( None )
    if ok == fd.APPROVE_OPTION:
        f = fd.getSelectedFile()
        st = f.toString()
        if not st.endswith( defaultextension ):
            st = st + defaultextension
        return st
#@nonl
#@-node:ekr.20070930184746.228:app.gui file dialogs
#@+node:ekr.20070930184746.229:app.gui panels
def createColorPanel(self,c):
    """Create Color panel."""
    self.oops()

def createComparePanel(self,c):
    """Create Compare panel."""
    import leoSwingComparePanel
    return leoSwingComparePanel.leoSwingComparePanel( c )


def createFindPanel(self):
    """Create a hidden Find panel."""
    self.oops()

def createFontPanel(self,c):
    """Create a Font panel."""
    self.oops()

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    import leoSwingFrame
    lsf = leoSwingFrame.leoSwingFrame( self )
    return lsf

def createPrefsPanel(self,c):
    """Create a Prefs panel."""
    return swing.JFrame()
#@-node:ekr.20070930184746.229:app.gui panels
#@+node:ekr.20070930184746.230:app.gui utils
@ Subclasses are expected to subclass all of the following methods.

These are all do-nothing methods: callers are expected to check for None returns.

The type of commander passed to methods depends on the type of frame or dialog being created.  The commander may be a Commands instance or one of its subcommanders.
#@nonl
#@+node:ekr.20070930184746.231:Clipboard
class cBoardOwner( dtfr.ClipboardOwner ):


    def lostOwnership( self, clipboard, contents ):
        pass



class LeoTransferable( dtfr.Transferable ): 
    '''This class exists primarily so that the system can detect when a valid
       leoxml tree has been placed in the system clipboard.  It enables the enabling/disabling
       of "paste node"'''
    def __init__( self, data, dataflavor ):

        self.data = data
        self.dataflavors = [ dtfr.DataFlavor.stringFlavor ]
        if dataflavor:
            self.dataflavors.append( dtfr.DataFlavor( dataflavor ) )
        self.dataflavor = dataflavor

    def getTransferData( self, dflavor ):

        if dflavor.getRepresentationClass() == java.lang.String:
            return java.lang.String( self.data )
        elif dflavor.getRepresentationClass() == java.io.InputStream:
            ba = java.lang.String( self.data ).getBytes()
            return java.io.ByteArrayInputStream( ba )

    def getTransferDataFlavors( self ):
        return self.dataflavors 

    def isDataFlavorSupported( self, flavor ):

        if flavor == dtfr.DataFlavor.stringFlavor: return True
        elif str( flavor.getMimeType() ) == self.dataflavor: return True
        return False    


def replaceClipboardWith (self,s, dflavor = None):

    #tk = self.c.frame.top.getToolkit()
    tk = java.awt.Toolkit.getDefaultToolkit()
    cp = tk.getSystemClipboard()
    cBO = self.cBoardOwner()
    #ss = dtfr.StringSelection( s )
    ss = self.LeoTransferable( s, dflavor )
    cp.setContents( ss, cBO )


def getTextFromClipboard (self):

    #tk = self.c.frame.top.getToolkit()
    tk = java.awt.Toolkit.getDefaultToolkit()
    cp = tk.getSystemClipboard()
    contents = cp.getContents( self )
    dflavor = dtfr.DataFlavor.selectBestTextFlavor( contents.getTransferDataFlavors() )
    if not dflavor:
        return None
    reader = dflavor.getReaderForText( contents )
    breader = java.io.BufferedReader( reader )
    txt = []
    try:
        while 1:
            stxt = breader.readLine()
            if stxt != None:
                txt.append( stxt )
            else:
                return '\n'.join( txt )
    except:
        return '\n'.join( txt )




#@-node:ekr.20070930184746.231:Clipboard
#@+node:ekr.20070930184746.232:Dialog utils
def attachLeoIcon (self,window):
    """Attach the Leo icon to a window."""

    sicon = g.os_path_join( g.app.loadDir,"..","Icons","Leoapp.GIF")
    #ii = swing.ImageIcon( "../Icons/Leosplash.GIF" )
    ii = swing.ImageIcon( sicon )
    window.setIconImage( ii.getImage() )

def center_dialog(self,dialog):
    """Center a dialog."""
    spot = self._calculateCenteredPosition( dialog )
    dialog.setLocation( spot[ 0 ], spot[ 1 ] )

def create_labeled_frame (self,parent,caption=None,relief="groove",bd=2,padx=0,pady=0):
    """Create a labeled frame."""

    w = swing.JPanel()
    parent.add( w )
    if caption:
        border = w.getBorder()
        tborder = sborder.TitledBorder( border )
        tborder.setTitle( caption )
        w.setBorder( tborder )

    sl = swing.SpringLayout()
    w.setLayout( sl )
    f = swing.JPanel()
    w.add( f )
    sl.putConstraint( sl.NORTH, f, 5, sl.NORTH, w )
    sl.putConstraint( sl.WEST, f, 5, sl.WEST, w )
    sl.putConstraint( sl.SOUTH, w, 5, sl.SOUTH, f )
    sl.putConstraint( sl.EAST, w, 5, sl.EAST, f )

    return w, f


def get_window_info (self,window):
    """Return the window information."""
    self.oops()

#@-node:ekr.20070930184746.232:Dialog utils
#@+node:ekr.20070930184746.233:Font
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    pass
    # self.oops()
#@nonl
#@-node:ekr.20070930184746.233:Font
#@+node:ekr.20070930184746.234:Focus
def get_focus(self,frame):

    """Return the widget that has focus, or the body widget if None."""

    self.oops()

def set_focus(self,commander,widget):

    """Set the focus of the widget in the given commander if it needs to be changed."""

    widget.requestFocusInWindow()
#@nonl
#@-node:ekr.20070930184746.234:Focus
#@+node:ekr.20070930184746.235:Index
def firstIndex (self):

    self.oops()

def lastIndex (self):

    self.oops()

def moveIndexForward(self,t,index,n):

    self.oops()

def moveIndexToNextLine(self,t,index):

    self.oops()
#@nonl
#@-node:ekr.20070930184746.235:Index
#@+node:ekr.20070930184746.236:Idle time
def setIdleTimeHook (self,idleTimeHookHandler,*args,**keys):

    pass # Not an error.

def setIdleTimeHookAfterDelay (self,delay,idleTimeHookHandler,*args,**keys):

   pass # Not an error.
#@-node:ekr.20070930184746.236:Idle time
#@-node:ekr.20070930184746.230:app.gui utils
#@+node:ekr.20070930184746.237:guiName
def guiName(self):

    try:
        return self.mGuiName
    except:
        return "invalid gui name"
#@nonl
#@-node:ekr.20070930184746.237:guiName
#@+node:ekr.20070930184746.238:oops
def oops (self):

    print "leoGui oops", g.callerName(2), "should be overridden in subclass"
#@nonl
#@-node:ekr.20070930184746.238:oops
#@+node:ekr.20070930184746.239:insertPoints --had to be added
def getInsertPoint( self, t ):

    return t.getCaretPosition()


def setInsertPoint( self, t, pos ):
    #pass
    #return t.setCaretPosition( pos )
    t.setCaretPosition( pos )

def getSelectionRange( self, t ):

    s = t.getSelectedText()
    s = "%s" % s
    return s

def setTextSelection( self, t, start, end ):

    t.setSelectionStart( start )
    t.setSelectionEnd( end )

def setSelectionRange(  self, t, n1, n2 ):
    return g.app.gui.setTextSelection( t, n1, n2 )


def getTextSelection( self, t ):


    return ( t.getSelectionStart(), t.getSelectionEnd() )
#@nonl
#@-node:ekr.20070930184746.239:insertPoints --had to be added
#@+node:ekr.20070930184746.240:makeIndexVisible --had to be added
def makeIndexVisible(self,t,index):

    print t
    print index
    #return t.see(index) 
#@nonl
#@-node:ekr.20070930184746.240:makeIndexVisible --had to be added
#@+node:ekr.20070930184746.241:moveIndexForward & moveIndexToNextLine -- had to be added
def moveIndexForward(self,t,index,n):

    t = self.c.frame.body.editor.editor 
    #print index
    #print n
    #print t
    t.setCaretPosition( index[ 1 ] )
    #newpos = t.index("%s+%dc" % (index,n))
    if len( t.getText() ) <= ( index[ 1 ] ): return None
    else:
        return index[ 1 ]
    #return g.choose(t.compare(newpos,"==","end"),None,newpos)

def moveIndexToNextLine(self,t,index):
    pass
    #newpos = t.index("%s linestart + 1lines" % (index))

    #return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20070930184746.241:moveIndexForward & moveIndexToNextLine -- had to be added
#@+node:ekr.20070930184746.242:addStartupTask
def addStartupTask( self, task ):
    '''Adds a task to the collection of tasks that are
       executed upon startup'''

    self.startup_tasks.add( task )
#@-node:ekr.20070930184746.242:addStartupTask
#@+node:ekr.20070930184746.243:getFontFromParams
def getFontFromParams( self, family,size,slant,weight):

    #print family, size, slant, weight

    if size in ( 'None', None ):
        size = 12
    else:
        size = int( size )

    if weight in ( 'None', None):
        weight = awt.Font.PLAIN
    else:
        weight = weight
        weights = weight.split( "and" )
        nweight = None
        for z in weights:
            z = z.strip()
            #print z
            if not hasattr( awt.Font, z ): continue
            w2 = getattr( awt.Font, z )
            if nweight:
                nweight = nweight|w2
            else:
                nweight = w2
        weight = nweight

    if family in ( 'None', None ):
        family = 'Helvetica'
    else:
        #family = family[ 1 ]
        pass

    #print family, size, slant, weight    
    f = awt.Font( family, weight, size )
    return f    

#@-node:ekr.20070930184746.243:getFontFromParams
#@+node:ekr.20070930184746.244:Look And Feel Changes
@others
#@+node:ekr.20070930184746.245:addLAFListener
def addLAFListener( self, component ):
    self.laflistener.addComponent( component )

#@-node:ekr.20070930184746.245:addLAFListener
#@+node:ekr.20070930184746.246:class LAFChangeListener
class LAFChangeListener( java.beans.PropertyChangeListener ):

    def __init__( self ):
        self.changers = []


    def addComponent( self, component ):
        ref = java.lang.ref.WeakReference( component )
        self.changers.append( ref )

    def propertyChange( self, event ):
        if event.getPropertyName() == 'lookAndFeel':
            for z in self.changers:
                component = z.get()
                if component:
                    swing.SwingUtilities.updateComponentTreeUI( component )
#@nonl
#@-node:ekr.20070930184746.246:class LAFChangeListener
#@-node:ekr.20070930184746.244:Look And Feel Changes
#@+node:ekr.20070930184746.247:had to be added
@others
#@+node:ekr.20070930184746.248:replaceSelectionRangeWithText
def replaceSelectionRangeWithText( self, t, start, end, change ):


    if t:
        doc = t.getDocument()
        doc.replace( start, end - start, change, None )


#@-node:ekr.20070930184746.248:replaceSelectionRangeWithText
#@+node:ekr.20070930184746.249:setSelectionRangeWithLength
def setSelectionRangeWithLength( self, t, start, length ):


    if t:
        t.setSelectionStart( start )
        t.setSelectionEnd( start + length )
#@-node:ekr.20070930184746.249:setSelectionRangeWithLength
#@+node:ekr.20070930184746.250:compareIndices
def compareIndices( self, st, pos, which, pos2 ):

    if which == '>':

        return int( pos ) > int( pos2 )

    elif which == '<':

        return int( pos ) < int( pos2 )

#@-node:ekr.20070930184746.250:compareIndices
#@+node:ekr.20070930184746.251:getAllText
def getAllText( self,st ):

    print st
    doc = st.getDocument()
    return doc.getText( 0, doc.getLength() )
#@nonl
#@-node:ekr.20070930184746.251:getAllText
#@-node:ekr.20070930184746.247:had to be added
#@-node:ekr.20070930184746.215:class leoSwingGui
#@+node:ekr.20070930184746.252:class leoSwingLog
class leoSwingLog:

    @others
#@nonl
#@+node:ekr.20070930184746.253:leoLog.__init__
def __init__ (self,frame,parentFrame):

    self._font = None
    self.jta = None
    #leoFrame.leoLog.__init__( self, frame, parentFrame )
    self.frame = frame
    self.c = frame.c
    self.enabled = True
    self.newlines = 0

    # Note: self.logCtrl is None for nullLog's.
    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()

    #self.c = frame.c
    self._font = None

    manager = g.app.config.manager
    for z in ( "log_pane_background_color", "log_text_foreground_color", "log_text_background_color" ):
        manager.addNotificationDef( z, self.setColorFromConfig )
    for z in ( "log_text_font_family", "log_text_font_size" ,  "log_text_font_weight" ):
        manager.addNotificationDef( z, self.setFontFromConfig )


#@-node:ekr.20070930184746.253:leoLog.__init__
#@+node:ekr.20070930184746.254:leoLog.configure
def configure (self,*args,**keys):

    self.oops()
#@nonl
#@-node:ekr.20070930184746.254:leoLog.configure
#@+node:ekr.20070930184746.255:leoLog.configureBorder
def configureBorder(self,border):

    self.oops()
#@-node:ekr.20070930184746.255:leoLog.configureBorder
#@+node:ekr.20070930184746.256:leoLog.createControl
def createControl (self,parentFrame):

    self.tab_manager = TabManager( switch_on_add = 0 )
    self.tab_manager.tabsToBottom()
    self._jtp = jtp = self.tab_manager.base

    self.logCtrl = logCtrl = self.jta = self.LogControl()
    self.logCtrl.setFocusable( True );
    logCtrl.setName( "Log" )
    import utilities.CutCopyPaste as CCP
    CCP.CutCopyPaste( logCtrl )
    self.setColorFromConfig()

    if self._font:
        logCtrl.setFont( self._font )
    self.jsp = swing.JScrollPane( logCtrl )

    self.tab_manager.add( "Log", self.jsp )
    logCtrl.addFocusListener( leoJSPFocusListener( self.jsp, self.c ) )
    parentFrame.rightComponent = jtp
    self.setBackgroundImage()
    g.doHook( "leoswinglogcreated", c = self.c, log = self )




#@-node:ekr.20070930184746.256:leoLog.createControl
#@+node:ekr.20070930184746.257:leoLog.enable & disable
def enable (self,enabled=True):

    self.enabled = enabled

def disable (self):

    self.enabled = False
#@-node:ekr.20070930184746.257:leoLog.enable & disable
#@+node:ekr.20070930184746.258:leoLog.oops
def oops (self):

    print "leoLog oops:", g.callerName(2), "should be overridden in subclass"
#@nonl
#@-node:ekr.20070930184746.258:leoLog.oops
#@+node:ekr.20070930184746.259:leoLog.setFontFromConfig
def setFontFromConfig (self, notification = None, handback = None):

    logCtrl = self.jta ; config = g.app.config

    font = config.getFontFromParams( self.c,
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        config.defaultLogFontSize)

    if font:
        #awt_font = awt.Font.decode( font )
        self._font = font
        if logCtrl:
            logCtrl.setFont( font )





#@-node:ekr.20070930184746.259:leoLog.setFontFromConfig
#@+node:ekr.20070930184746.260:leoLog.onActivateLog
def onActivateLog (self,event=None):

    try:
        g.app.setLog(self,"OnActivateLog")
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20070930184746.260:leoLog.onActivateLog
#@+node:ekr.20070930184746.261:leoLog.put & putnl
# All output to the log stream eventually comes here.

def put (self,s,color=None):

    if self.jta:
        pos = self.jta.getCaretPosition()
        document = self.jta.getStyledDocument()
        attrset = None

        if color:
            if hasattr( awt.Color, color ):
                attrcolor = getattr( awt.Color, color )
                attrset = stext.SimpleAttributeSet()
                stext.StyleConstants.setForeground( attrset, attrcolor  )

        document.insertString( document.getLength(), s, attrset )
        npos = document.getLength() - len( s )
        self.jta.setCaretPosition( npos )
    else:
        g.app.logWaiting.append( ( s , color ) )

    if leoSwingGui.splash.isVisible():
        leoSwingGui.splash.setText( s )


def putnl (self):

    if self.jta:
        doc = self.jta.getStyledDocument()
        doc.insertString( doc.getLength(), "\n", None )
    else:
        g.app.logWaiting.append( '\n' )




#@-node:ekr.20070930184746.261:leoLog.put & putnl
#@+node:ekr.20070930184746.262:class LogControl
class LogControl( swing.JTextPane ):

    def __init__( self, *args ):
        swing.JTextPane.__init__( self, *args )
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, 1.0 )
        self.lastDimensions = awt.Rectangle( 0,0,0,0 )
        self.image = None
        self.last_image= None


    def setAlpha( self, alpha ):
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )


    def setImage( self, image ):
        self.image = image


    def paintComponent( self, graphics ):

        #self.super__paintComponent( graphics )
        if self.image:
            vrec = self.getVisibleRect()
            if not self.lastDimensions.equals( vrec ):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance( vrec.width, vrec.height, awt.Image.SCALE_REPLICATE )
            composite = graphics.getComposite()
            graphics.setComposite( self.alpha )
            graphics.drawImage( self.last_image, vrec.x, vrec.y, awt.Color.WHITE, None )
            graphics.setComposite( composite )       
        self.super__paintComponent( graphics )

#@-node:ekr.20070930184746.262:class LogControl
#@+node:ekr.20070930184746.263:setBackgroundImage
def setBackgroundImage( self, notification = None, handback = None ):

    c = self.c


    use_background = g.app.config.getBool( c, "log_use_background_image" )    
    if not use_background:
        return

    alpha = g.app.config.getFloat( c, "log_background_alpha" )
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString( c, "log_image_location@as-filedialog" )
    if image_path:
        imfile = java.io.File( image_path ) 
        if imfile.exists():
            bimage = imageio.ImageIO.read( imfile )
            #if not hasattr( self, 'background' ): 
            #self.background = EditorBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #self.layeredpane.add( self.background, self.layeredpane.DEFAULT_LAYER )
            #self.logBackPane.add( self.background )
            #self.jsp.getViewport().addChangeListener( self.resizer( self.jsp, self.logBackPane ) )
            #self._vport.addChangeListener( self._resizer )
            #self.editor.setOpaque( False )
            #self.jtree.setOpaque( False )
            #self.jpanel.setOpaque( False )
            #self.jspane.setOpaque( False )
            #self.jspane.getViewport().setOpaque( False )
            #self.logCtrl.setOpaque( False )
            #self.jsp.getViewport().setOpaque( False )
            #self.jsp.setOpaque( False )
            self.logCtrl.setOpaque( False )
            self.logCtrl.setImage( bimage )
            self.logCtrl.setAlpha( alpha )
            g.app.config.manager.addNotificationDef( "log_background_alpha", self.setBackgroundImage )
            g.app.config.manager.addNotificationDef( "log_image_location@as-filedialog", self.setBackgroundImage )

            #else:
            #    self.background.setBackground( bimage, bimage.getWidth(), bimage.getHeight(), alpha )
            #    self.background.repaint()



#@-node:ekr.20070930184746.263:setBackgroundImage
#@+node:ekr.20070930184746.264:leoLog setColorFromConfig
def setColorFromConfig( self, notification = None, handback = None ):

    logCtrl = self.jta
    if logCtrl:
        color = g.app.config.getColor( self.c , "log_pane_background_color" )
        logCtrl.setBackground( getColorInstance( color, awt.Color.WHITE ) )
        color = g.app.config.getColor( self.c, "log_text_foreground_color" )
        logCtrl.setForeground( getColorInstance( color, awt.Color.GRAY ) ) 
        color = g.app.config.getColor( self.c, "log_text_background_color" )
        logCtrl.setSelectionColor( getColorInstance( color, awt.Color.GREEN ) )

#@-node:ekr.20070930184746.264:leoLog setColorFromConfig
#@+node:ekr.20070930184746.265:addTab
def addTab( self, name, component ):

    self.tab_manager.add( name, component )


def selectTab( self, component ):
    self.tab_manager.select( component )

def removeTab( self, component ):

    self.tab_manager.remove( component )


def getCurrentTab( self ):

    ctab = self.tab_manager.getCurrentTab()
    if ctab is None:
        return self.jta
    else:
        size = ctab.getSize()
        x = size.width/2
        y = size.height/2
        component = swing.SwingUtilities.getDeepestComponentAt( ctab, x, y )
        return component
#@-node:ekr.20070930184746.265:addTab
#@-node:ekr.20070930184746.252:class leoSwingLog
#@+node:ekr.20070930184746.266:class leoSwingMenu
class leoSwingMenu( leoMenu.leoMenu ):


    @others
#@nonl
#@+node:ekr.20070930184746.267: leoSwingMenu.__init__
def __init__ (self,frame):

    ld = io.File( g.app.loadDir )
    ijcl.addToSearchPath( ld )
    ijcl.beginLoading()
    self.font = frame.top.getFont()
    self.executor = java.util.concurrent.Executors.newCachedThreadPool()
    self.queue = java.util.concurrent.LinkedBlockingQueue()
    self.menu_changer = self.MenuChanger( self.queue )
    self.names_and_commands = {}
    self.keystrokes_and_actions = {}
    leoMenu.leoMenu.__init__( self, frame )
    #self.createLeoSwingPrint()
    #self.defineLeoSwingPrintTable()
    #self.addCommanderSupplemental()








#@-node:ekr.20070930184746.267: leoSwingMenu.__init__
#@+node:ekr.20070930184746.268:class MenuChanger
class MenuChanger( java.lang.Runnable, java.util.concurrent.Callable ):

    def __init__( self, queue ):
        self.queue = queue

    def run( self ):

        ft = java.util.concurrent.FutureTask( self )
        java.awt.EventQueue.invokeLater( ft )


    def call( self ):

        menu , name , label, enabled = self.queue.take() 
        target = None
        for z in menu.getMenuComponents():
            if hasattr( z, "getText" ) and z.getText() == name:
                target = z
                break


        if target:
            target.setText( label )
            target.setEnabled( enabled )
#@-node:ekr.20070930184746.268:class MenuChanger
#@+node:ekr.20070930184746.269:print menu stuff...

#@+node:ekr.20070930184746.270:defineLeoSwingPrintTable
def defineLeoSwingPrintTable( self ):

    self.printNodeTable= (

    ( "Print Current Node" , None, lambda event: self.lsp.printNode() ),
    ( "Print Current Node as HTML", None, lambda event: self.lsp.printNode( type = "HTML" ) ),
    ( "Print Marked Nodes", None, lambda event:  self.lsp.printMarkedNodes() ),
    ( "Print Marked Nodes as HTML", None, lambda event: self.lsp.printNode( type ="HTML" ) ),

    )

    for z in self.printNodeTable:
        self.names_and_commands[ z[ 0 ] ] = z[ 2 ]
#@-node:ekr.20070930184746.270:defineLeoSwingPrintTable
#@+node:ekr.20070930184746.271:createLeoSwingPrintMenu
def createLeoSwingPrintMenu( self ):

    fmenu = self.getMenu( "File" )

    components = fmenu.getMenuComponents()

    x = 0
    for z in components:

        if hasattr( z, 'getText' ) and z.getText() == "Recent Files...":
            break
        x += 1


    spot = x + 1

    pmenu = swing.JMenu( "Printing" )

    pnodes = swing.JMenu( "Print Nodes" )
    pmenu.add( pnodes )
    for z in self.printNodeTable:
        item = swing.JMenuItem( z[ 0 ] )
        item.actionPerformed = z[ 2 ]
        pnodes.add( item )

    sep = swing.JSeparator()
    fmenu.add( sep, spot  )
    fmenu.add( pmenu, spot + 1 )

    print_tree = swing.JMenuItem( "Print Tree As Is" )
    print_tree.actionPerformed = self.lsp.printTreeAsIs
    pmenu.add( print_tree )
    self.names_and_commands[ "Print Tree As Is" ] = self.lsp.printTreeAsIs
    print_as_more = swing.JMenuItem( "Print Outline in More Format" )
    print_as_more.actionPerformed = self.lsp.printOutlineAsMore
    self.names_and_commands[ "Print Outline in More Formet" ] = self.lsp.printOutlineAsMore
    pmenu.add( print_as_more )











#@-node:ekr.20070930184746.271:createLeoSwingPrintMenu
#@+node:ekr.20070930184746.272:createLeoSwingPrint
def createLeoSwingPrint( self ):

    c = self.c
    import leoSwingPrint
    lsp = leoSwingPrint.leoSwingPrint( c )
    menu = lsp.getAsMenu()

    fmenu = self.getMenu( "File" )

    components = fmenu.getMenuComponents()

    x = 0
    for z in components:

        if hasattr( z, 'getText' ) and z.getText() == "Recent Files...":
            break
        x += 1


    spot = x + 1


    sep = swing.JSeparator()
    fmenu.add( sep, spot  )
    fmenu.add( menu, spot + 1 )


#@-node:ekr.20070930184746.272:createLeoSwingPrint
#@-node:ekr.20070930184746.269:print menu stuff...
#@+node:ekr.20070930184746.273:plugin menu stuff...
#@+node:ekr.20070930184746.274:createPluginMenu
def createPluginMenu( self ):

    top = self.getMenu( 'top' )
    oline = self.getMenu( 'Outline' )
    ind = top.getComponentIndex( oline ) + 1
    import leoSwingPluginManager
    self.plugin_menu = pmenu = leoSwingPluginManager.createPluginsMenu()
    #self.plugin_menu = pmenu = swing.JMenu( "Plugins" )
    top.add( pmenu, ind )
    #cpm = swing.JMenuItem( "Plugin Manager" )
    #cpm.actionPerformed = self.createPluginManager
    #pmenu.add( cpm )
    #pmenu.addSeparator()


    #self.names_and_commands[ "Plugin Manager" ] = self.createPluginManager


#@-node:ekr.20070930184746.274:createPluginMenu
#@+node:ekr.20070930184746.275:createPluginManager
def createPluginManager( self, event ):

    import leoSwingPluginManager as lspm
    lspm.topLevelMenu()

#@-node:ekr.20070930184746.275:createPluginManager
#@+node:ekr.20070930184746.276:getPluginMenu
def getPluginMenu( self ):

    return self.plugin_menu
#@-node:ekr.20070930184746.276:getPluginMenu
#@-node:ekr.20070930184746.273:plugin menu stuff...
#@+node:ekr.20070930184746.277:JythonShell stuff

#@+node:ekr.20070930184746.278:openJythonShell
def openJythonShell( self ):

    js = ijcl.getJythonShell()
    jd = js.getDelegate()
    config = g.app.config
    c = self.c

    import leoSwingFrame
    getColorInstance = leoSwingFrame.getColorInstance 

    colorconfig = js.getColorConfiguration()
    color = config.getColor( c, "jyshell_background" )
    colorconfig.setBackgroundColor( getColorInstance( color, awt.Color.WHITE ) )

    color = config.getColor( c, "jyshell_foreground" )
    colorconfig.setForegroundColor( getColorInstance( color, awt.Color.GRAY ) )

    color = config.getColor( c, "jyshell_keyword" )
    colorconfig.setKeywordColor( getColorInstance( color, awt.Color.GREEN ) )

    color = config.getColor( c, "jyshell_local" )
    colorconfig.setLocalColor( getColorInstance( color, awt.Color.ORANGE ) )

    color = config.getColor( c, "jyshell_ps1color" )
    colorconfig.setPromptOneColor( getColorInstance( color, awt.Color.BLUE ) )

    color = config.getColor( c, "jyshell_ps2color" )
    colorconfig.setPromptTwoColor( getColorInstance( color, awt.Color.GREEN ) )

    color = config.getColor( c, "jyshell_syntax" )
    colorconfig.setSyntaxColor( getColorInstance( color, awt.Color.RED ) )

    color = config.getColor( c, "jyshell_output" )
    colorconfig.setOutColor( getColorInstance( color, awt.Color.GRAY ) )

    color = config.getColor( c, "jyshell_error" )
    colorconfig.setErrColor( getColorInstance( color, awt.Color.RED ) )

    family = config.get( c, "jyshell_text_font_family", "family" )
    size = config.get( c, "jyshell_text_font_size", "size" )
    weight = config.get( c, "jyshell_text_font_weight", "weight" )
    slant = None
    font = config.getFontFromParams( c, "jyshell_text_font_family", "jyshell_text_font_size", None, "jyshell_text_font_weight")

    use_bgimage = g.app.config.getBool( c, "jyshell_background_image" )
    if use_bgimage:

        image_location = g.app.config.getString( c, "jyshell_image_location@as-filedialog" )
        test_if_exists = java.io.File( image_location )
        if test_if_exists.exists():
            ii = swing.ImageIcon( image_location )
            alpha = g.app.config.getFloat( c, "jyshell_background_alpha" )
            js.setBackgroundImage( ii.getImage(), float( alpha ) )

    if font:
        js.setFont( font )

    js.setVisible( True )
    widget = js.getWidget()
    log = self.c.frame.log    
    self.addMenuToJythonShell( js )
    log.addTab( "JythonShell", widget )
    log.selectTab( widget )


#@-node:ekr.20070930184746.278:openJythonShell
#@+node:ekr.20070930184746.279:addMenuToJythonShell
def addMenuToJythonShell( self, js ):

    c = self.c
    jd = js.getDelegate()
    jmenu = swing.JMenu( "Leo" )
    jd.addToMenu( jmenu )

    e = swing.JMenuItem( "Execute Node As Script" )  
    e.actionPerformed = lambda event, jd = jd: self.fireNodeAsScript( event, jd )
    jmenu.add( e )

    p = swing.JMenuItem( "Run Node in Pdb" )
    p.actionPerformed = self.getRunNodeInPdb( c, jd )
    jmenu.add( p )

    captext = "Capture Shell Input In Node"
    totext = "Turn Off Shell Input Capture"
    sc = swing.JMenuItem( captext )
    import org.leo.JTextComponentOutputStream as jtcos
    class logcontrol:
        def __init__( self, menu ):
            self.menu = menu
            self.loging = False
            self.ostream = jtcos( c.frame.body.editor.editor )

        def __call__( self, event ):  
            menu = self.menu
            loging = self.loging
            if not loging:
                js.addLogger( self.ostream )
                menu.setText( totext )
                self.loging = True
            else:
                js.removeLogger( self.ostream )
                menu.setText( captext )
                self.loging = False

    sc.actionPerformed = logcontrol( sc )           
    jmenu.add( sc )

    d = swing.JMenuItem( "Detach Shell" )
    class detacher( java.util.concurrent.Callable ):

        def __init__( self, menu ):
            self.menu = menu
            self.embeded = True
            js.setCloser( self )

        def call( self ):

            if self.embeded:
                log = c.frame.log
                widget = js.getWidget()
                log.removeTab( widget )
            else:
                widget = js.getWidget()
                parent = widget.getTopLevelAncestor()
                parent.dispose();

        def __call__( self, event ):
            d = self.menu
            text = d.getText()
            if( text == "Detach Shell" ):
                d.setText( "Retach Shell" )
                jf = swing.JFrame( "JythonShell" )
                widget = js.getWidget()
                log = c.frame.log 
                log.removeTab( widget )
                jf.add( widget )
                jf.setSize( 500, 500 )
                jf.visible = 1
                self.embeded = False
            else:
                d.setText( "Detach Shell" )
                widget = js.getWidget()
                parent = widget.getTopLevelAncestor()
                parent.dispose();
                log = c.frame.log
                log.addTab( "JythonShell", widget  )
                log.selectTab( widget ) 
                self.embeded = True

    d.actionPerformed = detacher( d )
    jmenu.add( d )    


#@-node:ekr.20070930184746.279:addMenuToJythonShell
#@+node:ekr.20070930184746.280:getInsertNodeIntoShell
def getInsertNodeIntoShell( self, c, jd ):

    jm = swing.JMenuItem( "Write Node Into Shell as Reference" )
    def writeNode( event ):

        cp = c.currentPosition()
        at = c.atFileCommands 
        c.fileCommands.assignFileIndices()
        at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput

        jtf = self._GetReferenceName( jd, data )
        jtf.rmv_spot = jd.insertWidget( jtf )
        jtf.requestFocusInWindow()



    jm.actionPerformed = writeNode
    return jm
#@-node:ekr.20070930184746.280:getInsertNodeIntoShell
#@+node:ekr.20070930184746.281:getInsertReferenceIntoLeo
def getInsertReferenceIntoLeo( self, jd ):

    jmi = swing.JMenuItem( "Insert Reference As Node" )

    def action( event ):

        jtf = self._GetReferenceAsObject( jd, self.c )
        jtf.rmv_spot = jd.insertWidget( jtf )
        jtf.requestFocusInWindow()

    jmi.actionPerformed = action
    return jmi
#@nonl
#@-node:ekr.20070930184746.281:getInsertReferenceIntoLeo
#@+node:ekr.20070930184746.282:getRunNodeInPdb
def getRunNodeInPdb( self, c, jd ):

    def runInPdb( event ):

        cp = c.currentPosition()
        name = cp.headString()
        name = name.split()[ 0 ]
        at = c.atFileCommands 
        c.fileCommands.assignFileIndices()
        at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
        data = at.stringOutput

        f = java.io.File.createTempFile( "leopdbrun", None )
        pw = java.io.PrintWriter( f )
        pw.println( "import pdb" )
        pw.println( "pdb.set_trace()" )
        for z in data.split( "\n" ):
            pw.println( z )            
        pw.close()
        f.deleteOnExit()       
        l = java.util.Vector()
        l.add( "execfile( '%s', globals(), locals())" % f.getAbsolutePath() )
        jd.processAsScript( l )


    return runInPdb      
#@-node:ekr.20070930184746.282:getRunNodeInPdb
#@+node:ekr.20070930184746.283:fireNodeAsScript
def fireNodeAsScript( self, event, jd ):

    c = self.c        
    cp = c.currentPosition()    
    at = c.atFileCommands 
    c.fileCommands.assignFileIndices()
    at.write(cp.copy(),nosentinels=True,toString=True,scriptWrite=True)
    data = at.stringOutput.split( '\n' ) 


    l = java.util.Vector()
    for z in data:
        l.add( java.lang.String( z ) )

    jd.processAsScript( l )
#@nonl
#@-node:ekr.20070930184746.283:fireNodeAsScript
#@+node:ekr.20070930184746.284:class _GetReferenceName
class _GetReferenceName( swing.JTextField, aevent.KeyListener ):


    def __init__( self, jd, data ):
        swing.JTextField.__init__( self )
        self.jd = jd
        self.data = data
        border = self.getBorder()
        tborder = sborder.TitledBorder( border )
        tborder.setTitle( "Choose Reference Name:" )
        self.setBorder( tborder )
        self.addKeyListener( self )
        self.rmv_spot = None

    def keyPressed( self, event ):

        kc = event.getKeyChar();
        if kc == '\n':
            self.execute()
        elif java.lang.Character.isWhitespace( kc ):
            event.consume

    def execute( self ):

        self.jd.setReference( self.getText(), self.data )
        if self.rmv_spot:
            self.jd.remove( self.rmv_spot)
        self.jd.requestFocusInWindow()

    def keyTyped( self, event ):

        kc = event.getKeyChar()
        if kc == '\n': return
        elif java.lang.Character.isWhitespace( kc ):
            event.consume()

    def keyReleased( self, event ):

        kc = event.getKeyChar()
        if kc == '\n': return
        elif java.lang.Character.isWhitespace( kc ):
            event.consume()


class _GetReferenceAsObject( _GetReferenceName ):

    def __init__( self, jd, c ):
        leoSwingMenu._GetReferenceName.__init__( self, jd, None )
        self.c = c
        border = self.getBorder()
        border.setTitle( "Which Reference To Insert:" )


    def execute( self ):

        ref = self.jd.getReference( self.getText() )
        if ref:
            self.c.beginUpdate()
            pos = self.c.currentPosition()
            npos = pos.insertAfter()
            npos.setHeadString( "Reference: %s" % self.getText() )
            npos.setTnodeText( str( ref ) )
            self.c.endUpdate()
        if self.rmv_spot:
            self.jd.remove( self.rmv_spot )
#@-node:ekr.20070930184746.284:class _GetReferenceName
#@-node:ekr.20070930184746.277:JythonShell stuff
#@+node:ekr.20070930184746.285:addUserGuide
def addUserGuide( self ):

    help = self.getMenu( 'Help' )
    c = self.c
    help.addSeparator()
    jmi = swing.JCheckBoxMenuItem( "View User Guide" )
    widgets = []
    def showUserGuide( event ):
        if jmi.getState() and not widgets:
            import leoSwingLeoTutorial
            lswlt = leoSwingLeoTutorial.leoSwingLeoTutorial()
            widget = lswlt.getWidget()
            widgets.append( widget )
            c.frame.body.addTab( "User Guide", widget )
        elif jmi.getState() and widgets:
            widget = widgets[ 0 ]
            c.frame.body.addTab( "User Guide", widget )
        else:
            widget = widgets[ 0 ]
            c.frame.body.removeTab( widget )


    jmi.actionPerformed = showUserGuide
    help.add( jmi )
#@-node:ekr.20070930184746.285:addUserGuide
#@+node:ekr.20070930184746.286:createRecentFilesMenuItems (leoMenu)
def createRecentFilesMenuItems (self):

    c = self.c ; frame = c.frame
    recentFilesMenu = self.getMenu("Recent Files...")

    # Delete all previous entries.
    if len( recentFilesMenu.getMenuComponents() ) != 0:
        deferable = lambda :self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
        if not swing.SwingUtilities.isEventDispatchThread():
            dc = DefCallable( deferable )
            ft = dc.wrappedAsFutureTask()
            swing.SwingUtilities.invokeAndWait( ft )
        else:
            deferable()
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table,init=True)

    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def callback (event=None,c=c,name=name): # 12/9/03
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=callback,underline=0)
        i += 1
#@nonl
#@-node:ekr.20070930184746.286:createRecentFilesMenuItems (leoMenu)
#@+node:ekr.20070930184746.287:oops
def oops (self):

    print "leoMenu oops:", g.callerName(2), "should be overridden in subclass"
#@nonl
#@-node:ekr.20070930184746.287:oops
#@+node:ekr.20070930184746.288:Must be overridden in menu subclasses
#@+node:ekr.20070930184746.289:9 Routines with Tk spellings
def add_cascade (self,parent,label,menu,underline):

    menu.setText( label )

def add_command (self,menu,**keys):

    if keys[ 'label' ] == "Open Python Window":
        keys[ 'command' ] = self.openJythonShell

    self.names_and_commands[ keys[ 'label' ] ] = keys[ 'command' ]

    action = self.MenuRunnable( keys[ 'label' ], keys[ 'command' ], self.c, self.executor )
    jmenu = swing.JMenuItem( action )
    if keys.has_key( 'accelerator' ) and keys[ 'accelerator' ]:
        accel = keys[ 'accelerator' ]
        acc_list = accel.split( '+' )
        changeTo = { 'Alt': 'alt', 'Shift':'shift', #translation table
                     'Ctrl':'ctrl', 'UpArrow':'UP', 'DnArrow':'DOWN',
                     '-':'MINUS', '+':'PLUS', '=':'EQUALS',
                     '[':'typed [', ']':'typed ]', '{':'typed {',
                     '}':'typed }', 'Esc':'ESCAPE', '.':'typed .',
                      "`":"typed `", "BkSp":"BACK_SPACE"} #SEE java.awt.event.KeyEvent for further translations
        chg_list = []
        for z in acc_list:
            if z in changeTo:
                chg_list.append( changeTo[ z ] )
            else:
                chg_list.append( z )
        accelerator = " ".join( chg_list )
        ks = swing.KeyStroke.getKeyStroke( accelerator )
        if ks:
            self.keystrokes_and_actions[ ks ] = action
            jmenu.setAccelerator( ks )
        else:
            pass
    menu.add( jmenu )
    label = keys[ 'label' ]
    return jmenu

def add_separator(self,menu):
    menu.addSeparator()

def bind (self,bind_shortcut,callback):
    #self.oops() 
    pass

def delete (self,menu,realItemName):
    self.oops()

def delete_range (self,menu,n1,n2):


    items = menu.getMenuComponents()
    n3 = n1
    components = []
    while 1:
        if n3 == n2:
            break
        item = menu.getMenuComponent( n3 )
        components.append( item )
        n3 += 1

    for z in components:
        menu.remove( z )


def destroy (self,menu):
    self.oops()

def insert_cascade (self,parent,index,label,menu,underline):
    self.oops()

def new_menu(self,parent,tearoff=0):
    jm = swing.JMenu( "1" )
    #jm = self.LeoMenu( "1" )
    parent.add( jm )
    #jm.setFont( self.font)
    return jm
#@nonl
#@-node:ekr.20070930184746.289:9 Routines with Tk spellings
#@+node:ekr.20070930184746.290:7 Routines with new spellings
def createMenuBar (self,frame):

    top = frame.top
    self.defineMenuTables()
    topMenu = swing.JMenuBar()
    top.setJMenuBar( topMenu )
    topMenu.setFont( self.font )
    # Do gui-independent stuff.
    self.setMenu("top",topMenu)
    self.createMenusFromTables()
    self.createLeoSwingPrint()
    self.createPluginMenu()
    self.addUserGuide()

def createOpenWithMenuFromTable (self,table):
    self.oops()

def defineMenuCallback(self,command,name):
    return command

def defineOpenWithMenuCallback(self,command):
    self.oops()

def disableMenu (self,menu,name):
    for z in menu.getMenuComponents():
        if hasattr( z, "getText" ) and z.getText() == name:
            z.setEnabled( False )

def enableMenu (self,menu,name,val):
    for z in menu.getMenuComponents():
        if hasattr( z, "getText" ) and z.getText() == name:
            z.setEnabled( bool( val ) )

def setMenuLabel (self,menu,name,label,underline=-1, enabled = 1):

    item = ( menu, name, label, enabled )
    self.queue.offer( item )
    self.executor.submit( self.menu_changer )
#@-node:ekr.20070930184746.290:7 Routines with new spellings
#@+node:ekr.20070930184746.291:class MenuRunnable
class MenuRunnable( swing.AbstractAction, java.lang.Runnable): 

    def __init__( self, name, command, c , executor):
        swing.AbstractAction.__init__( self, name )
        self.command = command
        self.c = c
        self.name = name
        self.executor = executor

    def run( self ):
        self.c.doCommand( self.command, self.name ) #command()

    def actionPerformed( self, aE ):

        #print self.command
        #if self.name == 'Save':
        self.executor.submit( self )

        #else:        
        #    se
#@nonl
#@-node:ekr.20070930184746.291:class MenuRunnable
#@+node:ekr.20070930184746.292:class MenuExecuteOnSelect
class MenuExecuteOnSelect( sevent.MenuListener ):

    def __init__( self, method ):
        self.method = method

    def menuSelected( self, me ):
        self.method()

    def menuCanceled( self, me ):
        pass

    def menuDeselected( self, me ):
        pass
#@nonl
#@-node:ekr.20070930184746.292:class MenuExecuteOnSelect
#@+node:ekr.20070930184746.293:class LeoMenu
class LeoMenu( swing.JMenu ):

    def __init__( self, *args ):
        swing.JMenu.__init__( self, *args )

    def add( self, *items ):
        if hasattr( items[ 0 ], "setFont" ):
            items[ 0 ].setFont( self.getFont() )
        return self.super__add( *items )

#@-node:ekr.20070930184746.293:class LeoMenu
#@-node:ekr.20070930184746.288:Must be overridden in menu subclasses
#@-node:ekr.20070930184746.266:class leoSwingMenu
#@+node:ekr.20070930184746.294:class leoSwingTree
# This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoSwingTree( sevent.TreeSelectionListener, java.lang.Runnable, aevent.FocusListener ):   

    """The base class for the outline pane in Leo windows."""

    positions = java.util.WeakHashMap() #For storing where a node has last been edited
    icons = jarray.zeros( 16, swing.ImageIcon )
    for z in xrange( 16 ):
        num = '%s' % z
        if z < 10: num = '%s%s' %( 0, num )
        ipath = g.os_path_join( g.app.loadDir,"..","Icons","box%s.GIF" % num )
        icons[ z ] = swing.ImageIcon( ipath )

    commenticon = swing.ImageIcon( g.os_path_join( g.app.loadDir, "..", "Icons", "Cloud24.gif" ) )

# for( int i = 0; i < _icons.length; i++ ){
            # String num = String.valueOf( i );
            # if( i < 10 ) num = "0" + num;
# _icons[ i ] = new ImageIcon( String.format( "../Icons/box%s.GIF" , num ) );
    # }

    @others
#@nonl
#@+node:ekr.20070930184746.295:  tree.__init__ (base class)
def __init__ (self,frame, model = None, chapter = None ):

    #leoFrame.leoTree.__init__( self, frame )
    self.frame = frame
    self.c = c = frame.c

    # "public" ivars: correspond to setters & getters.
    self._editPosition = None

    # Controlling redraws
    self.updateCount = 0 # self.redraw does nothing unless this is zero.
    self.chapter = chapter
    self.loaded = False
    self._op = None
    self.skip_reload = 0
    self.view_controls = self.ViewControls()
    self.center = center = self.view_controls.addControl( "Outline", lambda : 1, None, checkmark = 1 )



    if model:
        self.posTM = model
    else:
        self.posTM = self.posTreeModel( self.c )
    self.jtree = jtree = self.JTree2( self.posTM )
    jtree.setFocusable( True )
    jtree.setRowHeight( -1 )#ensures that the renderer component's size is used
    self.setBackgroundColor()
    #self.setFontFromConfig()
    g.app.config.manager.addNotificationDef( "outline_pane_background_color", self.setBackgroundColor )
    config = g.app.config
    color = g.app.config.getColor( self.c, "headline_text_unselected_foreground_color" )
    tfg = getColorInstance( color, awt.Color.BLACK )
    color = g.app.config.getColor( self.c, "headline_text_unselected_background_color" )
    tbg = getColorInstance( color, awt.Color.WHITE )
    do_brackets = config.getBool( self.c, "headline_do_bracket_color" )
    color = config.getColor( self.c, "headline_bracket_color" )
    bracket_color = getColorInstance( color, awt.Color.BLUE )
    do_directives = config.getBool( self.c, "headline_do_directive_color" )
    color = config.getColor( self.c, "headline_directive_color" )
    directive_color = getColorInstance( color, awt.Color.GREEN )

    import leoNodes
    tnode = leoNodes.tnode()
    v = leoNodes.vnode( self.c, tnode )
    def getValue( names, self = v ):
        return names
    olFindAtFileName = v.findAtFileName
    v.findAtFileName = getValue
    names = v.anyAtFileNodeName()
    v.findAtFileName = olFindAtFileName
    names = list( names )
    hmap = java.util.HashMap()
    for z in names: hmap.put( z, None )

    self.renderer = leoIconTreeRenderer( self.posTM._root, self.icons,
                                         tfg, tbg,
                                         do_brackets, bracket_color,
                                         do_directives, directive_color,
                                         hmap
                                         )

    self.renderer.setCommentIcon( self.commenticon )
    xxx = lambda : self.jtree.setCellRenderer( self.renderer )
    dc = DefCallable( xxx )
    ft = dc.wrappedAsFutureTask()
    swing.SwingUtilities.invokeLater( ft )
    self.setFontFromConfig()
    self.renderer.setFont( self.jtree.getFont() )

    color = g.app.config.getColor( self.c, "headline_text_editing_foreground_color" )
    tefg = getColorInstance( color, awt.Color.BLACK )
    color = g.app.config.getColor( self.c, "headline_text_editing_background_color" )
    tebg = getColorInstance( color, awt.Color.WHITE )
    self.headlineEditor = leoHeadlineTreeCellEditor( self.c, tefg, tebg, leoSwingBody.Editor.icon )
    self.headlineEditor.setFont( self.jtree.getFont() )
    self.tcEdi = tcllEditor = self.tcellEditor( jtree, self.renderer, 
                                                self.headlineEditor,
                                                self.c )
    tcllEditor.addCellEditorListener( self.cellEditorListener( self.c ) )
    jtree.setCellEditor( tcllEditor )
    jtree.setRootVisible( False )
    jtree.setShowsRootHandles( True )
    jtree.getSelectionModel().setSelectionMode( stree.DefaultTreeSelectionModel.SINGLE_TREE_SELECTION )
    jtree.setScrollsOnExpand( True )

    self.jtree = jtree
    jtree.setTransferHandler( self.TreeTransferHandler( self.c, jtree ) )
    jtree.setDragEnabled( True ) 
    jtree.addTreeSelectionListener( self )
    jtree.editable = True
    self.jspane = swing.JScrollPane()
    #self.jspane.setViewport( JViewPort2() )

    #self.jspane = self.ZoomJSP()#swing.JScrollPane()
    #self.jspane.setViewport( self.ZoomView() )
    self.jspane.setViewportView( self.jtree )
    #self.jspane.getViewport().setOpaque( False )
    #self.jspane.setBackground( self.jtree.getBackground() )
    center.add( self.jspane )
    jtree.addFocusListener( leoJSPFocusListener( self.jspane, self.c ) )
    self.main_widget = parentpanel = swing.JRootPane()# swing.JPanel( awt.BorderLayout() )
    base = self.view_controls.getBase()
    parentpanel.getContentPane().add( base )
    parentpanel.getGlassPane().setLayout( None )


@
    zoom = swing.JMenu( "Zoom" )
    def setScale( scale, jtree = jtree ): #zoomer = zoomer, jtree = jtree ):
        double = java.lang.Double( scale )
        sval = double.doubleValue()/100
        #zoomer.setScale( sval )
        jtree.setScale( sval )
    buttongroup = swing.ButtonGroup()
    for z in ( 25, 50, 75, 100, 150, 200, 300, 400 ):
        jmi = swing.JCheckBoxMenuItem( str( z ) + "%" )
        zoom.add( jmi )
        buttongroup.add( jmi )
        if z == 100: jmi.setState( True )
        jmi.actionPerformed = lambda event, scale = z: setScale( scale )
    jmb.add( zoom )
@c

    self.current = self.jspane
    cpane = frame.jsp1

    self._dragging = False
    self._editPosition = None


    self.reloading = False
    self.paths = False
    self.settingPosition = False
    self.lastHoistStackLength = 0
    self.configureMedia()
    g.doHook("swingtreecreated", tree = self, view_controls = self.view_controls, c = self.c) 




#@-node:ekr.20070930184746.295:  tree.__init__ (base class)
#@+node:ekr.20070930184746.296:class posTreeModel
class posTreeModel( stree.TreeModel, java.lang.Runnable ):

    def __init__( self, c ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c )
        self._rTreePath = stree.TreePath( self._root )       


    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):


        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            for z in self.c.rootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )

        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in self.tmlisteners:
            z.treeStructureChanged( e )



    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )

    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )

    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()

    def getChildCount( self, parent ):

        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0

    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()



    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )

    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True

    def getPathToRoot( self, node ):

        path = []
        #if not node:
        #    node = self.c.rootPosition()

        while node and node.level() != 0:
            path.append( node.copy() )
            node = node.getParent()
        else:
            path.append( node.copy() )
            path.append( self._root )

        path.reverse()
        tp = stree.TreePath( path )
        return tp

    class _rootN( stree.TreeNode ):

        def __init__( self, c ):
            self.c = c

        def getChildAt(self, childIndex):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0: #Hoist Code
                rp = self.c.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       

        def getChildCount( self ):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i

        def getParent( self ):
            return None

        def getIndex( self, node):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ][ 0 ].copy()
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1

        def getAllowsChildren( self ):
            return True

        def isLeaf( self ):
            return False

        def equal( self, x ):
            if self is x: return True
            else: return False

        def equals( self, x ):
            if self is x: return True
            else:
                return False

        def copy( self ):
            return self

        def bodyString( self ):
            return ""

        def headString( self ):
            return ""

        def children( self ):

            class _enum( util.Enumeration ):

                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None

                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False

                def nextElement( self ):

                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            return _enum( self.c.rootPosition.siblings_iter( copy = True ) )        









#@-node:ekr.20070930184746.296:class posTreeModel
#@+node:ekr.20070930184746.297:doneLoading
def doneLoading( self ):

    self.loaded = True
    c = self.c
    #awt.EventQueue.invokeLater( self.__reloader( self.posTM, self.tree_reloader ) )
    #swing.SwingUtilities.invokeLater( self.tree_reloader )
    #g.es( "Expanding tree( last startup operation )..." )
    c.frame.body.editor.sync()
    #c.frame.body.editor.cdertminer.last_p = None
    c.frame.body.jdp.repaint()


class __reloader( java.lang.Runnable ):

    def __init__( self, model , tree_reloader ):
        self.model = model
        self.tree_reloader = tree_reloader

    def run( self ):
        self.model.reload( full_reload = False );
        self.tree_reloader.run()
        #awt.EventQueue.invokeLater( self.tree_reloader ) 
#@nonl
#@-node:ekr.20070930184746.297:doneLoading
#@+node:ekr.20070930184746.298:valueChanged --tree selection Event
def valueChanged( self, event ):

    path = event.getPath()
    o = path.getLastPathComponent()
    #if not self.c.currentPosition().equal( o ):
    if not self.chapter.getCurrentPosition().equal( o ):
        self.settingPosition = True
        #cp = self.c.currentPosition()
        cp = self.chapter.getCurrentPosition()
        #if hasattr( cp ,'v' ):
        #    leoSwingTree.positions.put( cp.v, self.c.frame.body.editor.editor.getCaretPosition() )
        #self.c.setCurrentPosition( o )
        self.select( o )
        #self.frame.body.editor.sync()
        self.settingPosition = False
        #if hasattr( o, 'v' ) and leoSwingTree.positions.containsKey( o.v ):
        #    spot = leoSwingTree.positions.get( o.v )
        #    editor = self.c.frame.body.editor
        #    doc = editor.editor.getStyledDocument()
        #    if doc.getLength() < spot: return
        #    
        #    editor.editor.setCaretPosition( spot )
        #    rec = editor.editor.modelToView( spot )
        #    if rec:
        #        editor.view.getViewport().scrollRectToVisible( rec )
        #else:
        #    self.c.frame.body.editor.editor.setCaretPosition( 0 )
#@nonl
#@-node:ekr.20070930184746.298:valueChanged --tree selection Event
#@+node:ekr.20070930184746.299: Must be defined in subclasses
#@+node:ekr.20070930184746.300:Drawing
def drawIcon(self,v,x=None,y=None):
    self.oops()


def _redraw( self, event = None ):
    pass

def redraw(self,event=None): # May be bound to an event.

    if len( self.c.hoistStack ) or self.lastHoistStackLength: #This ensures the correct Hoisted part of the tree is displayed
        if self.lastHoistStackLength != len( self.c.hoistStack ):
            self.lastHoistStackLength = len( self.c.hoistStack )
            #self.posTM.reload()
            #swing.SwingUtilities.invokeLater( self.tree_reloader )

    #self.jtree.repaint()
    self.jtree.repaint( 10 )


def _redraw_now( self, scroll = False ):
    pass

def redraw_now(self, scroll = False):
    self.jtree.repaint()

def redrawAfterException (self):
    self.redraw()

def alterationInTreeNodes( self ):
    #self.jtree.getParent().revalidate()
    #self.posTM.reload( full_reload = True )
    self.beginUpdate()
    self.endUpdate()

def nodeDidChange( self, pos ):
    self.jtree.treeDidChange()





#@-node:ekr.20070930184746.300:Drawing
#@+node:ekr.20070930184746.301:Edit label
def editLabel(self,v):

  if self.loaded: #If the system isnt loaded this can result in a different root than what is in the Leo File!.
    self._EditLabelEnabler.setNodeToEdit( v )
  if self.updateCount == 0:
      self._EditLabelEnabler.addToEventQueue()



def endEditLabel(self):

    if self.jtree.isEditing():
        dc = DefCallable( self.__stopediting )
        ft = dc.wrappedAsFutureTask()
        java.awt.EventQueue.invokeLater( ft )
        #self.jtree.stopEditing()

def __stopediting( self ): 
    self.jtree.stopEditing()
    g.doHook( "headline-editing-finished", p = self.chapter.getCurrentPosition(), chapter = self.chapter )

def setNormalLabelState(self,v):
    pass
#@nonl
#@-node:ekr.20070930184746.301:Edit label
#@+node:ekr.20070930184746.302:Notifications
# These should all be internal to the tkinter.frame class.

def OnActivateHeadline(self,v):
    self.oops()

def onHeadChanged(self,v):
    self.oops()

def OnHeadlineKey(self,v,event):
    self.oops()

def idle_head_key(self,v,ch=None):
    self.oops()
#@nonl
#@-node:ekr.20070930184746.302:Notifications
#@+node:ekr.20070930184746.303:Scrolling
def scrollTo(self,v):
    self.oops()

def scrollRight( self, increment = 0 ):

    sbar = self.jspane.getHorizontalScrollBar()
    max = sbar.getMaximum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value += increment
    if value > max:
        value = max
    sbar.setValue( value )

def scrollLeft( self, increment = 0 ):
    sbar = self.jspane.getHorizontalScrollBar()
    min = sbar.getMinimum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value -= increment
    if value < min:
        value = min
    sbar.setValue( value )

def scrollUp( self, increment = 0 ):

    sbar = self.jspane.getVerticalScrollBar()
    min = sbar.getMinimum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value -= increment
    if value < min:
        value = min
    sbar.setValue( value )

def scrollDown( self, increment = 0 ):

    sbar = self.jspane.getVerticalScrollBar()
    max = sbar.getMaximum()
    value = sbar.getValue()
    if not increment:
        increment = sbar.getBlockIncrement()
    value += increment
    if value > max:
        value = max
    sbar.setValue( value )    

def idle_scrollTo(self,v):

    self.oops()



#@-node:ekr.20070930184746.303:Scrolling
#@+node:ekr.20070930184746.304:Selecting
def select(self,p,updateBeadList=True):

    c = self.c
    jtree = self.jtree
    editor = c.frame.body.editor.editor

    cpy = p.copy()
    tp = self.posTM.getPathToRoot( cpy )
    if tp.getPath():
        jtree.setSelectionPath( tp )
        jtree.scrollPathToVisible( tp )

    #old_p = c.currentPosition()
    old_p = self.chapter.getCurrentPosition()
    if hasattr( old_p ,'v' ):
        leoSwingTree.positions.put( old_p.v, editor.getCaretPosition() )

    #c.setCurrentPosition( cpy )
    self.chapter.setCurrentPosition( cpy )
    if c.frame.body.editor.lastPosition == cpy:
        g.doHook("select1",c=self.c,new_p=cpy,old_p=old_p,new_v=cpy,old_v=old_p)
        return

    c.frame.body.editor.sync( pos = cpy)

    if hasattr( cpy, 'v' ) and leoSwingTree.positions.containsKey( cpy.v ):

        spot = leoSwingTree.positions.get( cpy.v )
        doc = editor.getStyledDocument()
        if doc.getLength() < spot: return

        editor.setCaretPosition( spot )
        try:
            rec = editor.modelToView( spot )
            if rec:
                c.frame.body.editor.view.getViewport().scrollRectToVisible( rec )
        except: #the darn thing blows up here if not enough of the editor is showing...
            pass
    else:
        editor.setCaretPosition( 0 )

    g.doHook("select1",c=self.c,new_p=cpy,old_p=old_p,new_v=cpy,old_v=old_p)
#@-node:ekr.20070930184746.304:Selecting
#@+node:ekr.20070930184746.305:Tree operations
def expandAllAncestors(self,p):


    tp = self.posTM.getPathToRoot( p.copy() )
    self.jtree.expandPath( tp )
#@-node:ekr.20070930184746.305:Tree operations
#@-node:ekr.20070930184746.299: Must be defined in subclasses
#@+node:ekr.20070930184746.306:beginUpdate
def beginUpdate (self):

    self.updateCount += 1
    self.endEditLabel()
    if not self.settingPosition:
        self.paths = True
#@nonl
#@-node:ekr.20070930184746.306:beginUpdate
#@+node:ekr.20070930184746.307:endUpdate
def endUpdate (self,flag=True ):

    #print java.lang.Thread.currentThread() , self.updateCount
    #try:
    assert(self.updateCount > 0)
    self.updateCount -= 1

    # g.trace(self.updateCount)
    #if flag and self.updateCount == 0:
    #    self.redraw()
    if self.paths:
        self.reloading = True
        #posTM = self.posTM
        #c = self.c
        if not self.skip_reload and self.updateCount == 0:
            #cp = c.currentPosition().copy()
            #cp = self.chapter.getCurrentPosition().copy()
            self.posTM.dRun()
            #tp = self.posTM.getPathToRoot( cp )
            #self.tree_reloader.setCurrentPosition( tp )
            #swing.SwingUtilities.invokeLater( self.tree_reloader )               
            self._op = None
            self.paths = False
            self.reloading = False
            if hasattr( self, "_EditLabelEnabler" ):
                self._EditLabelEnabler.addToEventQueue()

#@-node:ekr.20070930184746.307:endUpdate
#@+node:ekr.20070930184746.308:Getters/Setters (tree)
def dragging(self):
    return self._dragging

def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setDragging(self,flag):
    self._dragging = flag

def setEditPosition(self,p):
    self._editPosition = p
#@nonl
#@-node:ekr.20070930184746.308:Getters/Setters (tree)
#@+node:ekr.20070930184746.309:oops
def oops(self):

    print "leoTree oops:", g.callerName(2), "should be overridden in subclass"
#@nonl
#@-node:ekr.20070930184746.309:oops
#@+node:ekr.20070930184746.310:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,v,event=None):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = v.headString().strip()
    if g.match_word(s,0,"@url"):
        if not g.doHook("@url1",c=c,v=v):
            url = s[4:].strip()
            << stop the url after any whitespace >>
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,v=v)
#@nonl
#@+node:ekr.20070930184746.311:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i > -1:
    if 0: # No need for a warning.  Assume everything else is a comment.
        g.es("ignoring characters after space in url:"+url[i:])
        g.es("use %20 instead of spaces")
    url = url[:i]
#@-node:ekr.20070930184746.311:<< stop the url after any whitespace  >>
#@+node:ekr.20070930184746.312:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return

@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"
import re
# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20070930184746.312:<< check the url; return if bad >>
#@+node:ekr.20070930184746.313:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser

        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

#@-node:ekr.20070930184746.313:<< pass the url to the web browser >>
#@-node:ekr.20070930184746.310:tree.OnIconDoubleClick (@url)
#@+node:ekr.20070930184746.314:tree.enableDrawingAfterException
def enableDrawingAfterException (self):
    pass
#@nonl
#@-node:ekr.20070930184746.314:tree.enableDrawingAfterException
#@+node:ekr.20070930184746.315:class tcellEditor
class tcellEditor( stree.DefaultTreeCellEditor ): #so the tree will start editing on 1 click!

    def __init__( self , jtree, renderer, editor, c ):
        stree.DefaultTreeCellEditor.__init__( self, jtree, renderer , editor )
        self.editor = editor
        self.editor.setFocusTraversalPolicy( c.frame.ftp )
        self.timer = None
        self.c = c
        self.tree = jtree

    def getTreeCellEditorComponent(self, tree, value, isSelected, expanded, leaf, row):
        return self.editor.getTreeCellEditorComponent( tree, value, isSelected, expanded, leaf, row )     

    def requestFocusInWindow( self ):
        self.editor.requestFocusInWindow()

    def shouldStartEditingTimer( self, event ):

        if event.getClickCount() >= 1 and self.inHitRegion( event.getX(), event.getY() ):
            #self.tree.stopEditing() 
            return True
        else:
            return False

    def canEditImmediately( self, event ):

        if event == None or event.getClickCount() == 2:
            return True
        else:
            return False

    def startEditingTimer( self ):

        #self.htext = None
        if self.timer == None:
            self.timer = swing.Timer( 10, self )
            self.timer.setRepeats( False )
        self.timer.start()

    #def cancelCellEditing( self ):
    #
    #    self.super__cancelCellEditing()
    #cp = self.c.currentPosition()
    #htext = self.tree.getCellEditor().getCellEditorValue()
    #cp.setHeadString(  )
    #self.htext = None

    #def prepareForEditing( self ):
    #    
    #    self.super__prepareForEditing()
    #cp = self.c.currentPosition()
    #self.htext = cp.headString()

#@-node:ekr.20070930184746.315:class tcellEditor
#@+node:ekr.20070930184746.316:class cellEditorListener
class cellEditorListener( sevent.CellEditorListener, java.lang.Runnable ):

    def __init__( self, c ):
        self.c = c

    def editingCanceled( self, event ): 
        #Called when the headline edit has been aborted, do nothing... results in headline reverting.
        pass
        #self.sync( event )

    def editingStopped( self, event ):
        self.sync( event )

    def run( self ):

        self.c.frame.body.editor.editor.requestFocusInWindow()


    def sync( self , event ):

        source = event.getSource()
        value = source.getCellEditorValue()
        cp = self.c.currentPosition()
        cp.setHeadString( value )
        awt.EventQueue.invokeLater( self )
#@-node:ekr.20070930184746.316:class cellEditorListener
#@+node:ekr.20070930184746.317:edit_text --had to be added
def edit_text( self, p ):

    return self.c.frame.body.editor.editor

#@-node:ekr.20070930184746.317:edit_text --had to be added
#@+node:ekr.20070930184746.318:createAuxilaryWidgets
def createAuxilaryWidgets( self ):

    parentpanel = self.main_widget
    jtree = self.jtree
    c = self.c
    jmb = swing.JMenuBar()
    self.view_controls.setMenuBar( jmb )
    parentpanel.add( jmb, java.awt.BorderLayout.NORTH )    
    pue = self.PopupEnabler( c )
    jtree.addMouseListener( pue )
    self._EditLabelEnabler = self.EditLabelEnabler( self.jtree , self.headlineEditor)
    jtree.addFocusListener( self )
#@-node:ekr.20070930184746.318:createAuxilaryWidgets
#@+node:ekr.20070930184746.319:getWidget
def getWidget( self ):

    return self.main_widget

#@-node:ekr.20070930184746.319:getWidget
#@+node:ekr.20070930184746.320:configureMedia
def configureMedia( self ):

    c = self.c 
    use_background = g.app.config.getBool( c, "tree_use_background_image" )    
    if use_background:
        self.setBackgroundImage()
#@-node:ekr.20070930184746.320:configureMedia
#@+node:ekr.20070930184746.321:setBackgroundImage
def setBackgroundImage( self, notification = None, handback = None ):

    c = self.c
    alpha = g.app.config.getFloat( c, "tree_background_alpha" )
    if alpha == None: alpha = 1.0
    image_path = g.app.config.getString( c, "tree_image_location@as-filedialog" )
    if image_path:
        imfile = java.io.File( image_path ) 
        if imfile.exists():
            bimage = imageio.ImageIO.read( imfile )
            self.jtree.setImage( bimage )
            self.jtree.setAlpha( alpha )
            self.jtree.setOpaque( False )
            g.app.config.manager.addNotificationDef( "tree_background_alpha", self.setBackgroundImage )
            g.app.config.manager.addNotificationDef( "tree_image_location@as-filedialog", self.setBackgroundImage )



#@-node:ekr.20070930184746.321:setBackgroundImage
#@+node:ekr.20070930184746.322:helper classes
@others
#@+node:ekr.20070930184746.323:class JTree2
class JTree2( swing.JTree ):

    def __init__( self, model ):
        self.posTM = model
        swing.JTree.__init__( self, model )
        self.lastDimensions = awt.Rectangle( 0, 0,0,0 )
        self.last_image = None
        self.image = None
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, 1.0 ) 
        #self.setOpaque( False )
        self.canPaint = True


    def setImage( self, image ):
        self.image = image

    def setAlpha( self, alpha ):
        self.alpha = awt.AlphaComposite.getInstance( awt.AlphaComposite.SRC_OVER, alpha )



    def paintComponent( self, graphics ):

        if self.image:
            vrec = self.getVisibleRect()
            if not self.lastDimensions.equals( vrec ):
                self.lastDimensions = vrec
                self.last_image = self.image.getScaledInstance( vrec.width, vrec.height, awt.Image.SCALE_REPLICATE )
            composite = graphics.getComposite()
            graphics.setComposite( self.alpha )

            graphics.drawImage( self.last_image, vrec.x, vrec.y, awt.Color.WHITE, None )
            graphics.setComposite( composite ) 
@
        else:
            #clip = graphics.getClip();
            #bounds = clip.getBounds()
            paint = graphics.getPaint()
            color = self.getBackground()
            c1 = color.brighter()
            c2 = color.darker()
            vrect = self.getVisibleRect()
            gp = awt.GradientPaint( vrect.x, vrect.y, c1, vrect.x + vrect.width, vrect.y + vrect.height, c2, True )
            graphics.setPaint( gp )
            graphics.fillRect( vrect.x, vrect.y, vrect.width, vrect.height )
            graphics.setPaint( paint )
@c       
        self.super__paintComponent( graphics )#comes last, or no tree!!!



    def isExpanded( self, path ):

        if path.__class__ != stree.TreePath:
            path = self.getPathForRow( path )

        lc = path.getLastPathComponent()
        if lc == self.posTM._root:
            return True
        else:
            return lc.isExpanded()

    def setExpandedState( self, path, boolean ):

        if boolean:
            lc = path.getLastPathComponent()
            try:
                self.fireTreeWillExpand( path )
            except:
                return
            lc.expand()
            self.fireTreeExpanded( path )
        else:
            lc = path.getLastPathComponent()
            try:
                self.fireTreeWillCollapse( path )
            except:
                return
            lc.contract()
            self.fireTreeCollapsed( path )


    def getExpandedDescendants( self, path ):


        lc = path.getLastPathComponent()
        paths = java.util.Vector()
        expanders = []

        if lc == self.posTM._root:
            p = self.posTM.chapter.getRootPosition()
            cp = self.posTM.chapter.getCurrentPosition()
        else:
            p = lc.copy()
        rp = self.posTM.chapter.getRootPosition()
        stop_p = p.copy()

        while p:                
            expanded = p.isExpanded()
            #if p == stop_p and p != rp: expanded = True
            #elif stop_p == rp and not self.posTM.drunning: expanded = True
            #elif self.posTM.drunning and p == rp:
            #    expanded = True

            if expanded:
                expanders.append( p.copy() )

            if expanded:
                if p.v.t._firstChild:
                    p.moveToFirstChild()
                elif p and p.v._next:
                    p.moveToNext()
                else:
                    while p:
                        p.moveToParent()
                        if p == stop_p and not p.isRoot(): 
                            p = None
                            break
                        if p and p.v._next:
                            p.moveToNext()
                            break
                        elif not p: break
            else:
                if p.v._next:
                    p.moveToNext()
                else:
                    while p:
                        p.moveToParent()
                        if p == stop_p and not p.isRoot(): 
                            p = None
                            break
                        if p and p.v._next:
                            p.moveToNext()
                            break
                        elif not p: break

        expanders.sort( self.sortNodes )
        while expanders:
            z = expanders.pop()
            path = self.posTM.getPathToRoot( z.copy(), masterlist = expanders )
            paths.add( path )
        return paths.elements()


    def sortNodes( self, node1, node2 ):

        l1 = node2.level()
        l2 = node2.level()
        if l1 > l2: return 1
        elif l1 < l2: return -1
        else: return 0


#@-node:ekr.20070930184746.323:class JTree2
#@+node:ekr.20070930184746.296:class posTreeModel
class posTreeModel( stree.TreeModel, java.lang.Runnable ):

    def __init__( self, c ):

        self.c = c
        self.tmlisteners = java.util.ArrayList();
        self._root = self._rootN( c )
        self._rTreePath = stree.TreePath( self._root )       


    def getRoot( self ):
        return self._root

    def reload( self, full_reload = False ):


        if full_reload:
            t_r = self.c.frame.tree.tree_reloader
            for z in self.c.rootPosition().allNodes_iter( copy = True ):
                if z.isExpanded():
                    t_r.expand( z )

        import jarray
        a = jarray.zeros( 1, stree.TreeNode )
        a[ 0 ] = self._root
        e = sevent.TreeModelEvent( self._root, a )
        for z in self.tmlisteners:
            z.treeStructureChanged( e )



    def addTreeModelListener( self, listener ):
        self.tmlisteners.add( listener )

    def removeTreeModelListener( self, listener ):
        self.tmlisteners.remove( listener )

    def getChild( self, parent, ind ):
        if parent is self._root:
            return parent.getChildAt( ind ).copy()
        return parent.getNthChild( ind ).copy()

    def getChildCount( self, parent ):

        if parent is self._root:
            return parent.getChildCount()
        if parent:
            return parent.numberOfChildren()
        else:
            return 0

    def getIndexOfChild( self, parent, child ):
        if parent is self._root:
            return self._root.getIndex( child )
        else:
            return child.childIndex()



    def valueForPathChanged( self, path, value ):

        pos = path.getLastPathComponent()
        pos.setHeadString( value )

    def isLeaf( self, node ):
        if node is self._root: return False
        if node:
            if node.numberOfChildren(): return False
            else: return True
        else:
            return True

    def getPathToRoot( self, node ):

        path = []
        #if not node:
        #    node = self.c.rootPosition()

        while node and node.level() != 0:
            path.append( node.copy() )
            node = node.getParent()
        else:
            path.append( node.copy() )
            path.append( self._root )

        path.reverse()
        tp = stree.TreePath( path )
        return tp

    class _rootN( stree.TreeNode ):

        def __init__( self, c ):
            self.c = c

        def getChildAt(self, childIndex):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0: #Hoist Code
                rp = self.c.hoistStack[ -1 ].p.copy()
                def getParent( root = self ): #This slight modification to a copy allows the Tree to keep its expanded state
                    return root
                rp.getParent = getParent
                return rp #End of Hoist Code
            if not rp: return None
            i = 0
            for z in rp.siblings_iter():
                if i == childIndex:
                    return z
                i = i + 1
            return None       

        def getChildCount( self ):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                return 1
            i = 0
            for z in rp.siblings_iter():
                i = i + 1
            return i

        def getParent( self ):
            return None

        def getIndex( self, node):
            rp = self.c.rootPosition()
            if len( self.c.hoistStack ) != 0:
                #rp = self.c.hoistStack[ -1 ][ 0 ].copy()
                return 0
            i = 0
            for z in rp.siblings_iter():
                if z == node: return i
                i = i + 1
            return -1

        def getAllowsChildren( self ):
            return True

        def isLeaf( self ):
            return False

        def equal( self, x ):
            if self is x: return True
            else: return False

        def equals( self, x ):
            if self is x: return True
            else:
                return False

        def copy( self ):
            return self

        def bodyString( self ):
            return ""

        def headString( self ):
            return ""

        def children( self ):

            class _enum( util.Enumeration ):

                def __init__( self, iter ):
                    self.iter = iter
                    try:
                        self.next = iter.next()
                    except:
                        self.next = None

                def hasMoreElements( self ):
                    if self.next: return True
                    else: return False

                def nextElement( self ):

                    try:
                        rt = self.next
                        self.next = iter.next()
                    finally:
                        return rt
            return _enum( self.c.rootPosition.siblings_iter( copy = True ) )        









#@-node:ekr.20070930184746.296:class posTreeModel
#@+node:ekr.20070930184746.315:class tcellEditor
class tcellEditor( stree.DefaultTreeCellEditor ): #so the tree will start editing on 1 click!

    def __init__( self , jtree, renderer, editor, c ):
        stree.DefaultTreeCellEditor.__init__( self, jtree, renderer , editor )
        self.editor = editor
        self.editor.setFocusTraversalPolicy( c.frame.ftp )
        self.timer = None
        self.c = c
        self.tree = jtree

    def getTreeCellEditorComponent(self, tree, value, isSelected, expanded, leaf, row):
        return self.editor.getTreeCellEditorComponent( tree, value, isSelected, expanded, leaf, row )     

    def requestFocusInWindow( self ):
        self.editor.requestFocusInWindow()

    def shouldStartEditingTimer( self, event ):

        if event.getClickCount() >= 1 and self.inHitRegion( event.getX(), event.getY() ):
            #self.tree.stopEditing() 
            return True
        else:
            return False

    def canEditImmediately( self, event ):

        if event == None or event.getClickCount() == 2:
            return True
        else:
            return False

    def startEditingTimer( self ):

        #self.htext = None
        if self.timer == None:
            self.timer = swing.Timer( 10, self )
            self.timer.setRepeats( False )
        self.timer.start()

    #def cancelCellEditing( self ):
    #
    #    self.super__cancelCellEditing()
    #cp = self.c.currentPosition()
    #htext = self.tree.getCellEditor().getCellEditorValue()
    #cp.setHeadString(  )
    #self.htext = None

    #def prepareForEditing( self ):
    #    
    #    self.super__prepareForEditing()
    #cp = self.c.currentPosition()
    #self.htext = cp.headString()

#@-node:ekr.20070930184746.315:class tcellEditor
#@+node:ekr.20070930184746.316:class cellEditorListener
class cellEditorListener( sevent.CellEditorListener, java.lang.Runnable ):

    def __init__( self, c ):
        self.c = c

    def editingCanceled( self, event ): 
        #Called when the headline edit has been aborted, do nothing... results in headline reverting.
        pass
        #self.sync( event )

    def editingStopped( self, event ):
        self.sync( event )

    def run( self ):

        self.c.frame.body.editor.editor.requestFocusInWindow()


    def sync( self , event ):

        source = event.getSource()
        value = source.getCellEditorValue()
        cp = self.c.currentPosition()
        cp.setHeadString( value )
        awt.EventQueue.invokeLater( self )
#@-node:ekr.20070930184746.316:class cellEditorListener
#@+node:ekr.20070930184746.324:class EditLabelEnabler
class EditLabelEnabler( java.lang.Runnable ):
    '''This class enables a label to be edited within the context of
       beginUpdate and endUpdate.  Doing the operation between these two
       calls resulted in NullPointer Exceptins to be thrown.  This does the work
       safely after those calls have been made, actually this is how it is used
       in endUpate, not with the EditLabelEnabler.  It is a policy on top of this
       classes mechanism'''

    def __init__( self, jtree, headlineEditor ):

        self._jtree = jtree
        self.headlineEditor = headlineEditor
        #We use an AtomicReference to ensure that the node is fresh.
        #We use 2 Semaphores so we can correctly time the execution of an insert
        #and the beginning of a label edit.  Without this we can move too quickly 
        #and produce  NullPointerExceptions, or something like that.
        self.edit_v = atomic.AtomicReference()
        self.semaphore = concurrent.Semaphore( 1 ) 
        self.add_to_queue = concurrent.Semaphore( 1 )


    def setNodeToEdit( self, node ):

        if node:
            self.semaphore.acquire()
            self.edit_v.set( node.copy() )
            self.semaphore.release()

    def addToEventQueue( self ):
        #java.lang.Thread.dumpStack()
        if self.edit_v.get() and self.add_to_queue.availablePermits():
            self.add_to_queue.acquire()
            awt.EventQueue.invokeLater( self )


    def run( self ):

        self.semaphore.acquire()
        posTM = self._jtree.getModel()
        ev = self.edit_v.getAndSet( None )
        self.semaphore.release()
        ptr = posTM.getPathToRoot( ev )
        #self.edit_v = None
        #self._jtree.requestFocusInWindow()
        self._jtree.startEditingAtPath( ptr )
        self.headlineEditor.requestFocusInWindow()
        self.add_to_queue.release()


#@-node:ekr.20070930184746.324:class EditLabelEnabler
#@+node:ekr.20070930184746.325:class ViewControls
class ViewControls:

    def __init__( self ):
        self.menu = swing.JMenu( "Views" )
        self.bgroup = swing.ButtonGroup()
        self.layout = java.awt.CardLayout()
        self.base = swing.JPanel( self.layout )
        self.methods = {}
        self.detacher = None
        self.menu_bar = None
        self.count = 0

    def setMenuBar( self, bar ):
        self.menu_bar = bar
        if self.count > 1:
            self.menu_bar.add( self.menu, 0 )

    def getMenu( self ):
        return self.menu

    def getBase( self ):
        return self.base

    def addControl( self, name, attachmethod, detachmethod, checkmark = 0 ):

        jmi = swing.JCheckBoxMenuItem( name )
        if checkmark:
            jmi.setSelected( 1 )
        self.methods[ name ] = ( attachmethod, detachmethod )
        jmi.actionPerformed = lambda event: self.__action(  name  )
        self.bgroup.add( jmi )
        self.menu.add( jmi )
        nwbase = swing.JPanel()
        nwbase.setLayout( awt.GridLayout( 1,1 )) 
        self.base.add( nwbase, name )
        if self.menu_bar and ( self.count > 1 and self.menu.getParent() == None ):
            self.menu_bar.add( self.menu, 0 )
        self.count += 1
        return nwbase

    def __action( self, name ):

        if self.detacher: self.detacher()
        attach, detach = self.methods[ name ]
        self.layout.show( self.base, name )
        attach()
        self.detacher = detach


#@-node:ekr.20070930184746.325:class ViewControls
#@+node:ekr.20070930184746.326:class PopupEnabler
class PopupEnabler( aevent.MouseAdapter ):

    def __init__( self, c ):
        aevent.MouseAdapter.__init__( self )
        self.node = None
        self.c = c
        #self.cursor = None
        #self.imagesetter = leoSwingTree.ImageSetter( c.frame.gp2, c )

    def mouseDragged( self, event ):
        self.c.frame.gp2.repaint()

    def mouseMoved( self, event ):
        pass

    def mousePressed( self, mevent ):

        button = mevent.getButton()
@
        if button == mevent.BUTTON1:
            tree = mevent.getSource()
            path = tree.getPathForLocation( mevent.x, mevent.y )
            if path:
                row = tree.getRowForLocation( mevent.x, mevent.y )
                self.node = path.getLastPathComponent().copy()
                bi2 = self.c.frame.tree.getRendererImageOfNode( self.node )
                self.cursor = tree.getCursor()
                ncursor = awt.Cursor.getPredefinedCursor( awt.Cursor.HAND_CURSOR )
                #tk = awt.Toolkit.getDefaultToolkit()
                #ccursor = tk.createCustomCursor( bi2, awt.Point(0,0 ), "ccursor" )
                self.imagesetter.setTargets( bi2, ncursor, path )
                swing.SwingUtilities.invokeLater( self.imagesetter )
@c
        if button == mevent.BUTTON3:
            self.showMenu( mevent )
@        
    def mouseReleased2( self, mevent ):
        tree = mevent.getSource()
        path = tree.getPathForLocation( mevent.x, mevent.y )
        updatestarted = False
        self.imagesetter.reset()
        try:
            if path and self.node:
                endpoint = path.getLastPathComponent().copy()
                if self.node.v.t != endpoint.v.t and not self.node.isAncestorOf( endpoint ):
                    try:
                        self.c.beginUpdate()
                        updatestarted = True
                    except:
                        pass
                    if endpoint.numberOfChildren():
                        self.c.dragToNthChildOf(self.node,endpoint,0)
                    else:
                        self.c.dragAfter(self.node,endpoint)
        finally:
            self.node = None
            if self.cursor:
                tree.setCursor( self.cursor )
                self.cursor = None
            if updatestarted:
                updatestarted = False
                self.c.endUpdate()
@c

    def showMenu( self, event ):

        popup = swing.JPopupMenu()
        class aa( swing.AbstractAction ):
            def __init__( self, name, command ):
                swing.AbstractAction.__init__( self, name )
                self.command = command

            def actionPerformed( self, event ):
                self.command()

        c = self.c
        commandlist = (  
                        ( "Read @file Nodes", c.readAtFileNodes, 0 ),
                        ( "Write @file Nodes", c.fileCommands.writeAtFileNodes, 0 ), 
                        (),
                        ( "Tangle", c.tangle, 0 ),
                        ( "Untangle", c.untangle, 0 ),
                        (),
                        ("Toggle Angle Brackets", c.toggleAngleBrackets, 0 ),
                        (),
                        ( "Cut Node", c.cutOutline, c.canCutOutline ),
                         (  "Copy Node", c.copyOutline, 0 ),
                         ( "Paste Node", c.pasteOutline, c.canPasteOutline ),
                         ( "Delete Node", c.deleteOutline, c.canDeleteHeadline ),
                         (),
                         ( "Insert Node", c.insertHeadline, 0 ),
                         ( "Clone Node", c.clone, 0 ),
                         ( "Sort Children", c.sortChildren, c.canSortChildren ),
                         ( "Sort Siblings", c.sortSiblings, c.canSortSiblings ),
                         (),
                         ( "Contract Parent", c.contractParent, c.canContractParent ),
                         )

        for z in commandlist:
            if len(z) == 0:
                popup.addSeparator()
            else:
                if z[ 2 ]:
                    ok = z[ 2 ]()
                else:
                    ok = True
                if ok:
                    popup.add( aa( z[ 0 ], z[ 1 ] ) )




        x = event.getX()
        y = event.getY()
        popup.show( event.getSource(), x, y )

#@-node:ekr.20070930184746.326:class PopupEnabler
#@+node:ekr.20070930184746.327:class ImageSetter
class ImageSetter( java.lang.Runnable, aevent.MouseMotionListener  ):
    def __init__( self , gp2, c, jtree):
        self.image = None
        self.gp2 = gp2
        self.c = c
        self.path = None
        jtree.addMouseMotionListener( self )

    def mouseDragged( self, event ):
        if self.image:
            self.gp2.repaint()

    def mouseMoved( self, event ):
        pass

    def setImage( self, image ):
        self.image = image


    def setPath( self, path ):
        self.path = path

    def setTargets( self, image , path ):
        self.image = image
        self.path = path

    def reset( self ):
        self.gp2.setImage( None ); self.gp2.setCursor( None )
        self.image  = self.path = None

    def run( self ):

        if self.image:# and self.cursor:
            tree = self.c.frame.tree.jtree
            epath = tree.getEditingPath()
            spath = tree.getSelectionPath()
            if not self.path.equals( epath ):
                self.gp2.setImage( self.image )
                #self.gp2.setCursor( self.cursor )
            else:
                self.reset()
#@-node:ekr.20070930184746.327:class ImageSetter
#@+node:ekr.20070930184746.328:class TreeTransferHandler
class TreeTransferHandler( swing.TransferHandler ):

    transferservice = java.util.concurrent.Executors.newSingleThreadExecutor()

    def __init__( self, c, jtree ):
        swing.TransferHandler.__init__( self )
        self.flavors = []
        DataFlavor = datatransfer.DataFlavor
        self.flavors.append( DataFlavor.javaFileListFlavor )
        self.uri = DataFlavor( "text/uri-list;class=java.lang.String" )
        self.smarker = DataFlavor( "text/internal-transfer;class=java.lang.String" )
        self.pspecflavor = DataFlavor( DataFlavor.javaJVMLocalObjectMimeType, 
                                       "class=%s" % PositionSpecification, 
                                       PositionSpecification.getClassLoader() ) #We use this one or the system can't find the PS class!
        self.flavors.append( self.uri )
        self.c = c
        self.jtree = jtree

    def createTransferable( self, jc ):
        pi = awt.MouseInfo.getPointerInfo()
        spot = pi.getLocation()
        swing.SwingUtilities.convertPointFromScreen( spot, self.jtree )
        path = self.jtree.getPathForLocation( spot.x, spot.y )
        rv = self.TreeTransferable( self.c, list( self.flavors ) )
        if path:
            p = path.getLastPathComponent().copy()
            rv.setPosition( p, self.pspecflavor )
            bi2 = self.c.frame.tree.getRendererImageOfNode( p.copy() ) 
        else:
            rv.addDataFlavor( self.smarker )
        return rv

    def getSourceActions( self, jc ):
        return self.COPY_OR_MOVE

    @others

#@+node:ekr.20070930184746.329:canImport
def canImport( self, jc, df ):

    for z in df:
        if z.equals( self.smarker ): return False

    for z in df:
        if z.isFlavorJavaFileListType(): return True
        elif z.equals( self.uri ): return True
        elif z.equals( self.pspecflavor ): return True

    return False
#@nonl
#@-node:ekr.20070930184746.329:canImport
#@+node:ekr.20070930184746.330:importData
def importData( self, jc, trans ):

    c = self.c
    try:
        if trans.isDataFlavorSupported( self.pspecflavor ):
            pi = awt.MouseInfo.getPointerInfo()
            spot = pi.getLocation()
            swing.SwingUtilities.convertPointFromScreen( spot, self.jtree )
            path = self.jtree.getPathForLocation( spot.x, spot.y )
            if path:
                node = trans.getTransferData( self.pspecflavor )
                endpoint = path.getLastPathComponent().copy()
                if node.v.t != endpoint.v.t and not node.isAncestorOf( endpoint ):
                    try:
                        c.beginUpdate()
                        if endpoint.numberOfChildren(): 
                            self.c.dragToNthChildOf( node,endpoint,0)
                        else:
                            self.c.dragAfter( node,endpoint)
                    finally:
                        c.endUpdate()
            return True
        elif trans.isDataFlavorSupported( datatransfer.DataFlavor.javaFileListFlavor ):
            files = trans.getTransferData( datatransfer.DataFlavor.javaFileListFlavor )
            ifiles = self.ImportFiles( files, self )
            self.transferservice.submit( ifiles )
            return True
        elif trans.isDataFlavorSupported( self.uri ):
            uri = trans.getTransferData( self.uri )
            iurls = self.ImportUrls( uri, self )
            self.transferservice.submit( iurls )
            return True
    finally:
        pass

    return False
#@nonl
#@-node:ekr.20070930184746.330:importData
#@+node:ekr.20070930184746.331:importFile
def importFile( self, filename ):

    c = self.c
    at = c.atFileCommands
    io = java.io
    filename = java.net.URLDecoder.decode( filename, "UTF-8" )
    if filename.endswith( ".leo" ):
        try:
            c.chapters.loadFileAsChapter( filename )
        except:
            g.es( "Error loading %s" % filename )            
    else:
        isDerived = False
        thin = False
        try:
            theFile = open(filename,'rb')
            firstLines , readNew, thin = at.scanHeader(theFile,filename)
            isDerived = ( readNew or thin )
            theFile.close()
        except IOError:
            g.es( "Could not import %s" % filename )
            return
        if isDerived:
            c.importCommands.importDerivedFiles( c.currentPosition().copy(), [ filename, ] )
        else:
            c.importCommands.importFilesCommand( [ filename, ], "@file" )
        try:
            nwname = io.File( filename ).getName()
            if nwname:
                cp = c.currentPosition()
                cp.setHeadStringOrHeadline( nwname )

        except:
            pass

#@-node:ekr.20070930184746.331:importFile
#@+node:ekr.20070930184746.332:getVisualRepresentation
def getVisualRepresentation( self, transf ):

    tree = self.c.frame.tree
    icon = tree.getRendererImageOfNode( self.c.currentPosition() )
    return icon
#@nonl
#@-node:ekr.20070930184746.332:getVisualRepresentation
#@+node:ekr.20070930184746.333:class TreeTransferable
class TreeTransferable( datatransfer.Transferable ):

    def __init__( self, c, flavors ):
        self.c = c
        self.flavors = flavors
        self.uri = datatransfer.DataFlavor( "text/uri-list;class=java.lang.String" )
        self.position = None
        self.pflavor = None
        self.writen = False
        self.nwfile = None

    def addDataFlavor( self, flavor ):
        self.flavors.append( flavor )

    def setPosition( self, position, flavor ):
        self.position = position
        self.pflavor = flavor
        self.flavors.append( flavor )

    def getTransferDataFlavors( self ):
        return self.flavors 

    def isDataFlavorSupported( self, flavor ):

        for z in self.flavors:
            if flavor.equals( z ): return True
        return False

    @others
#@+node:ekr.20070930184746.334:getTransferData
def getTransferData( self, df ):

    if df.equals( datatransfer.DataFlavor.javaFileListFlavor ):
        rv = util.ArrayList()
        if not self.writen:
            tmpfile = io.File.createTempFile( "Node", "Drop" )
            self.nwfile = self.writeNodeToFile( tmpfile )
            self.written = True

        rv.add( self.nwfile )
        return rv
    elif df.equals( self.uri ):
        if not self.writen:
            tmpfile = io.File.createTempFile( "Node", "Drop" )
            self.nwfile = self.writeNodeToFile( tmpfile )
            self.writen = True

        rv = self.nwfile.toURI().toString()
        return rv
    elif self.pflavor and df.equals( self.pflavor ):
        return self.position
    else:
        raise datatransfer.UnsupportedFlavorException( df )
#@nonl
#@-node:ekr.20070930184746.334:getTransferData
#@+node:ekr.20070930184746.335:writeNodeToFile
def writeNodeToFile( self, tmpfile ):

    c = self.c
    cp = c.currentPosition()
    at = c.atFileCommands
    c.fileCommands.assignFileIndices()
    fn = cp.v.anyAtFileNodeName()
    if fn:
        nosentinels = cp.v.atNoSentinelsFileNodeName()
        if nosentinels: nosentinels = True
        else: nosentinels = False
        thinFile = cp.v.atThinFileNodeName()
        if thinFile: thinFile = True
        else: thinFile = False
        at.write( cp.copy(), thinFile = thinFile, nosentinels = nosentinels, toString = True, scriptWrite = False )
    else:
        at.write( cp.copy(), thinFile = True, toString = True, scriptWrite = False )
    data = at.stringOutput 
    ps = None
    io = java.io
    encoding = "UTF-8"
    try:
        try:
            fos = io.FileOutputStream( tmpfile )
            ps = io.PrintWriter( io.OutputStreamWriter( fos ) ) 
            for z in data.split( "\n" ):
                ps.println( z )
            ps.close()
            ps = None
            frd = io.FileReader( tmpfile )
            encoding = frd.getEncoding()
            frd.close()
            frd = None       
        except io.IOException, io:
            io.printStackTrace()
    finally:
        if ps: ps.close()
        if frd: frd.close()
    hstring = cp.headString()
    if cp.v.anyAtFileNodeName():
        hstring = cp.v.anyAtFileNodeName()
    language = LeoUtilities.scanForLanguage( cp.copy() ) 
    if g.app.language_extension_dict.has_key( language ):
        ext = g.app.language_extension_dict[ language ]
    else:
        ext = language

    import binascii
    hstring = list( hstring )
    for i in xrange( len( hstring ) ):
        ch = hstring[ i ]
        if not ch.isalnum() and not ch.isspace() and ch not in ( "." ):
            hstring[ i ] = binascii.hexlify( ch )

    hstring = "".join( hstring )

    if not hstring.endswith( ext ):
        nwname = "%s.%s" %( hstring, ext )
    else:
        nwname = hstring
    nwname = java.net.URLEncoder.encode( nwname, encoding )
    pdirectory = tmpfile.getParent()
    try:
        if fn:
            fn2 = io.File( fn )
            nwfile = io.File( pdirectory, fn2.getName() )
        else:
            nwfile = io.File( pdirectory, nwname )
    except io.IOException, ix:
        ix.printStackTrace()
    tmpfile.renameTo( nwfile )
    nwfile.deleteOnExit()
    return nwfile
#@-node:ekr.20070930184746.335:writeNodeToFile
#@-node:ekr.20070930184746.333:class TreeTransferable
#@+node:ekr.20070930184746.336:class ImportUrls
class ImportUrls( java.lang.Runnable ):

    def __init__( self, uri, tth ):
        self.uri = uri
        self.tth = tth

    def run( self ):
        uris = self.uri.split( "\r\n" )
        for z in uris:
            try:
                if z:
                    f = java.net.URL( z ).getFile()
                    self.tth.importFile( f )
            except java.lang.Exception, x:
                x.printStackTrace()
#@-node:ekr.20070930184746.336:class ImportUrls
#@+node:ekr.20070930184746.337:class ImportFiles
class ImportFiles( java.lang.Runnable ):

    def __init__( self, files, tth ):
        self.files = files
        self.tth = tth

    def run( self ):

        for z in self.files:
            try:
                fname = z.getAbsolutePath()
                if fname:
                    self.tth.importFile( fname )
            except java.lang.Exception, x:
                x.printStackTrace()
#@-node:ekr.20070930184746.337:class ImportFiles
#@-node:ekr.20070930184746.328:class TreeTransferHandler
#@-node:ekr.20070930184746.322:helper classes
#@+node:ekr.20070930184746.338:focuslistener interface
def focusGained( self, event ):

    if self.jtree.isEditing():
        self.jtree.getCellEditor().requestFocusInWindow()

def focusLost( self, event ):
    pass
#@-node:ekr.20070930184746.338:focuslistener interface
#@+node:ekr.20070930184746.339:image creation
def getEditorImageOfNode( self, p ):

    path = self.posTM.getPathToRoot( p )
    row = self.jtree.getRowForPath( path )
    comp = self.tcEdi.getTreeCellEditorComponent( self.jtree, p, p.isCurrentPosition(), p.isExpanded(), p.numberOfChildren(), row )
    return self.__createImage( comp )    



def getRendererImageOfNode( self, p ):

    path = self.posTM.getPathToRoot( p )
    row = self.jtree.getRowForPath( path ) 
    comp = self.renderer.getTreeCellRendererComponent( self.jtree, p, p.isCurrentPosition(), 
                                                       p.isExpanded(), p.numberOfChildren(), row, True ) 
    return self.__createImage( comp )

def __createImage( self, component ):

    psize = component.getPreferredSize()
    bi = awt.image.BufferedImage( psize.width, psize.height, awt.image.BufferedImage.TYPE_INT_RGB )
    g = bi.createGraphics()

    #jw = swing.JWindow()
    #jw.toBack()
    #mpi = awt.MouseInfo.getPointerInfo()
    #location = mpi.getLocation()
    #jw.setLocation( location )
    #jw.add( component )
    #jw.setSize( psize )
    opaque = component.isOpaque()
    background = component.getBackground()
    component.setOpaque( True )
    component.setBackground( awt.Color.WHITE )
    #jw.visible = 1
    self.jtree.add( component )
    component.setSize( component.getPreferredSize() ) #this appears to work better then making a short lived window
    component.paint( g ) 
    self.jtree.remove( component )
    #jw.visible = 0
    component.setOpaque( opaque )
    component.setBackground( background )
    #jw.dispose()
    g.dispose()
    return bi          



#@-node:ekr.20070930184746.339:image creation
#@+node:ekr.20070930184746.340:tree.getFont,setFont,setFontFromConfig
def getFont (self):

    return self.font

# Called by leoFontPanel.
def setFont(self,font=None, fontName=None):

    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        #self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
    print "SETTING FONT!!!!"

    self.setLineHeight(self.font)

# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):

    c = self.c
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize, tag = "tree")


    #    font = config.getFontFromParams( self.c,
    #    "log_text_font_family", "log_text_font_size",
    #    "log_text_font_slant",  "log_text_font_weight",
    #    config.defaultLogFontSize)

    #font2 = c.config.getFontFromParams( self.c,
    #    "headline_text_font_family", "headline_text_font_size",
    #    "headline_text_font_slant",  "headline_text_font_weight",
    #    c.config.defaultTreeFontSize )#, tag = "tree")


    #self.setFont(font)
    self.jtree.setFont( font )
#@nonl
#@-node:ekr.20070930184746.340:tree.getFont,setFont,setFontFromConfig
#@+node:ekr.20070930184746.341:setBackgroundColor
def setBackgroundColor (self, notification = None, handback = None ):

    c = self.c

    color = c.config.getColor("outline_pane_background_color")
    bg = getColorInstance( color, awt.Color.WHITE )

    try:
        #self.canvas.configure(bg=bg)
        self.jtree.setBackground( bg )
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20070930184746.341:setBackgroundColor
#@-node:ekr.20070930184746.294:class leoSwingTree
#@+node:ekr.20070930184746.369:Utils
#@+node:ekr.20070930184746.370:getColorInstance
def getColorInstance( val, OnNone=None ):

    if hasattr( awt.Color, val ):
        return getattr( awt.Color, val )
    else:
        try:
            l = java.lang.Long.parseLong( val, 16 )
            l2 = java.lang.Long( l )
            color = awt.Color.decode( "%s" % l2.intValue() )
            return color

        except java.lang.Exception, x:
            #print 'WHATDA!!!!  %s' % x
            pass

    return OnNone
#@nonl
#@-node:ekr.20070930184746.370:getColorInstance
#@+node:ekr.20070930184746.371:class leoJSPFocusListener
class leoJSPFocusListener( aevent.FocusListener ):
    '''A Class that changes the border of a focused JViewPort'''

    _listeners = {}

    def __init__( self, jsp, c ):
        self.jsp = jsp
        self.c = c
        color = g.app.config.getColor( c, "component_focused_bordor_color" )
        self.fcolor = getColorInstance( color, awt.Color.RED )
        color = g.app.config.getColor( c, "component_unfocused_bordor_color" )
        self.ucolor = getColorInstance( color, awt.Color.GREEN )

        self.border = self.LineBorder2( self.ucolor )
        jsp.setViewportBorder( self.border )
        if not leoJSPFocusListener._listeners.has_key( c ):
            group =  leoJSPFocusListener._listeners[ c ] = []
        else:
            group = leoJSPFocusListener._listeners[ c ]
        group.append( self )

    def focusGained( self, event ):

        self.border.setColor( self.fcolor )
        self.jsp.repaint()
        group = leoJSPFocusListener._listeners[ self.c ] 
        for x in group:
            if x == self: continue
            else:
                x.border.setColor( self.ucolor )
                x.jsp.repaint()

    def focusLost( self, event ):
        pass 


    class LineBorder2( sborder.LineBorder ):

        def __init__( self, color ):
            sborder.LineBorder.__init__( self, color )
            self.color = color


        def setColor( self, color ):
            self.color = color


        def paintBorder( self, c, g, x,y,w,h ):

            g.setColor( self.color )
            g.drawRect( x, y, w -1, h -1 )
#@-node:ekr.20070930184746.371:class leoJSPFocusListener
#@+node:ekr.20070930184746.372:class VisibleInformer
class VisibleInformer( sevent.ChangeListener ):
    '''A class that allows a change in the tab of a tabbed pane to
       be used as a notification to registered callbacks.'''

    def __init__( self, tabbedpane ):
        self.tabbedpane = tabbedpane #should be a JTabbedPane, or at least a component that has:
                                     #getSelectedComponent and an addChangeListener method
        tabbedpane.addChangeListener( self )
        self.callbacks = {}

    def addCallback( self, component, callback ):
        self.callbacks[ component ] = callback

    def stateChanged( self, event ):

        component = self.tabbedpane.getSelectedComponent()
        if self.callbacks.has_key( component ):
            self.callbacks[ component ]()    
#@-node:ekr.20070930184746.372:class VisibleInformer
#@-node:ekr.20070930184746.369:Utils
#@+node:ekr.20070930184746.375:from leoSwingFind.py
import leoGlobals as g 
import leoFind  
import javax.swing as swing
import javax.swing.border as sborder
import javax.swing.table as stable
import javax.swing.event as sevent
import java.util.HashSet as hset
import java.awt as awt   
import java.awt.event as aevent
import java.lang


class leoSwingFind (leoFind.leoFind ):

    """A class that implements Leo's tkinter find dialog."""

    @others
#@nonl
#@+node:ekr.20070930184746.376:Birth & death
#@+node:ekr.20070930184746.377:__init__
def __init__(self,c, title="Find/Change",resizeable=False ):

    # Init the base classes...

    leoFind.leoFind.__init__(self, c)
    self.title = title
    g.app.findFrame = self
    #leoTkinterDialog.leoTkinterDialog.__init__(self,title,resizeable)

    << init the tkinter ivars >>
    self.c = c
    #self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    self.lasPos = None
    self.reverse_flag = False
    self.selection = False

#@+node:ekr.20070930184746.378:<< init the tkinter ivars >>
self.dict = {}



for key in self.intKeys:
    self.dict[key] = self.fakeIntTkVar()

for key in self.newStringKeys:
    self.dict[key] = self.fakeStringTkVar()

#self.s_text = Tk.Text() # Used by find.search()
self.s_text = "HI" #AssertionError without
#@nonl
#@-node:ekr.20070930184746.378:<< init the tkinter ivars >>
#@-node:ekr.20070930184746.377:__init__
#@+node:ekr.20070930184746.379:fake TkVars --classes that look like Tk variables
class fakeStringTkVar:

    def __init__( self ):

        self.sb = ""

    def get( self ):
        return self.sb

    def set( self, value ):  

        self.sb = value

class fakeIntTkVar:

    def __init__( self ):
        self.val = 0

    def get( self ):
        return self.val

    def set( self, value ):
        self.val = value
#@nonl
#@-node:ekr.20070930184746.379:fake TkVars --classes that look like Tk variables
#@+node:ekr.20070930184746.380:destroySelf
def destroySelf (self):

    self.top.destroy()
#@nonl
#@-node:ekr.20070930184746.380:destroySelf
#@+node:ekr.20070930184746.381:find.createFrame
def createFrame (self):

    # Create the find panel...
    #outer = Tk.Frame(self.frame,relief="groove",bd=2)
    #outer.pack(padx=2,pady=2)
    self.top = swing.JFrame()
    g.app.gui.addLAFListener( self.top )
    #self.top.setDefaultCloseOperation( swing.JFrame.EXIT_ON_CLOSE )
    self.top.title = self.title
    jtab = swing.JTabbedPane()
    self.top.add( jtab )
    cpane = swing.JPanel()
    jtab.addTab( "regular search", cpane )
    clnsearch = swing.JPanel()
    clnsearch.setName( "Leodialog" )
    jtab.addTab( "node search", clnsearch )
    #cpane = outer.getContentPane()
    cpane.setName( "Leodialog" )
    cpane.setLayout( awt.GridLayout( 3, 1 ) )


    << Create the Find and Change panes >>
    << Create four columns of radio and checkboxes >>
    << Create two rows of buttons >>

    self.createNodeSearchFrame( clnsearch )
    #self.top.setSize( 500, 500 )
    self.top.pack()
    size = self.top.getSize()
    size.width = size.width + 50
    self.top.setSize( size )
    splitpane.setDividerLocation( .5 )
    #outer.visible = True

    #for widget in (self.find_text, self.change_text):
    #    widget.bind ("<1>",  self.resetWrap)
    #    widget.bind("<Key>", self.resetWrap)
    #    widget.bind("<Control-a>",self.selectAll)
    #    #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)

    #for widget in (outer, self.find_text, self.change_text):
    #    widget.bind("<Key-Return>", self.findButton)
    #    widget.bind("<Key-Escape>", self.onCloseWindow)

    #self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)


#@+node:ekr.20070930184746.382:<< Create the Find and Change panes >>
#fc = Tk.Frame(outer, bd="1m")
#fc.pack(anchor="n", fill="x", expand=1)
findPanel = self.findPanel = swing.JTextArea()
self.CutCopyPaste( findPanel )
fspane = swing.JScrollPane( findPanel )

self.changePanel = changePanel = swing.JTextArea()
self.CutCopyPaste( changePanel )
cpane2 = swing.JScrollPane( changePanel )
splitpane = swing.JSplitPane( swing.JSplitPane.VERTICAL_SPLIT, fspane, cpane2 )
splitpane.setDividerLocation( .5 )
#outer.getContentPane().add( splitpane )
cpane.add( splitpane )
#outer.pack()


# Removed unused height/width params: using fractions causes problems in some locales!
#fpane = Tk.Frame(fc, bd=1)
#cpane = Tk.Frame(fc, bd=1)

#fpane.pack(anchor="n", expand=1, fill="x")
#cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
#flab = Tk.Label(fpane, width=8, text="Find:")
#clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
#self.find_text   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
#3self.change_text = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)

#fBar = Tk.Scrollbar(fpane,name='findBar')
#cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
#for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
#    txt['yscrollcommand'] = bar.set
#    bar['command'] = txt.yview
#    bar.pack(side="right", fill="y")

#flab.pack(side="left")
#clab.pack(side="left")
#ctxt.pack(side="right", expand=1, fill="both")
#ftxt.pack(side="right", expand=1, fill="both")
#@nonl
#@-node:ekr.20070930184746.382:<< Create the Find and Change panes >>
#@+node:ekr.20070930184746.383:<< Create four columns of radio and checkboxes >>
#columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
#columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.
columnsFrame = swing.JPanel()
columnsFrame.setLayout( swing.BoxLayout( columnsFrame, swing.BoxLayout.X_AXIS ) )
cpane.add( columnsFrame, awt.BorderLayout.SOUTH )

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []; buttonGroups = []
for i in xrange(numberOfColumns):
    #columns.append(Tk.Frame(columnsFrame,bd=1))
    jp = swing.JPanel()
    jp.setLayout( swing.BoxLayout( jp, swing.BoxLayout.Y_AXIS ) )
    columns.append( jp )
    radioLists.append([])
    checkLists.append([])
    buttonGroups.append( swing.ButtonGroup() )

for i in xrange(numberOfColumns):
    columnsFrame.add( columns[ i ] )
    #columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = [
    (self.dict["radio-find-type"],"Plain Search","plain-search"),  
    (self.dict["radio-find-type"],"Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"Script Search","script-search")]
checkLists[0] = [
    ("Script Change",self.dict["script_change"])]
checkLists[1] = [
    ("Whole Word",  self.dict["whole_word"]),
    ("Ignore Case", self.dict["ignore_case"]),
    ("Wrap Around", self.dict["wrap"]),
    ("Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only","selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search Headline Text", self.dict["search_headline"]),
    ("Search Body Text",     self.dict["search_body"]),
    ("Mark Finds",           self.dict["mark_finds"]),
    ("Mark Changes",         self.dict["mark_changes"])]


class rAction( swing.AbstractAction ):

    def __init__( self, name, var , val ):
        swing.AbstractAction.__init__( self, name )
        self.name = name
        self.var = var
        self.val = val

    def actionPerformed( self, aE ):
        self.var.set( self.val )

class jcbAction( swing.AbstractAction ):

    def __init__( self, name, var ):
        swing.AbstractAction.__init__( self, name )
        self.var = var

    def actionPerformed( self, ae ):

        val = self.var.get()
        if val:
            self.var.set( 0 )
        else:
            self.var.set( 1 )

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        aa = rAction( name, var, val )
        but = swing.JRadioButton( aa )
        columns[ i ].add( but )
        buttonGroups[ i ].add( but )
        #box = Tk.Radiobutton(columns[i],anchor="w",text=name,variable=var,value=val)
        #box.pack(fill="x")
        #box.bind("<1>", self.resetWrap)
        #if val == None: box.configure(state="disabled")
    for name, var in checkLists[i]:
        cbut = swing.JCheckBox( jcbAction( name, var ) )
        columns[ i ].add( cbut )
        #box = Tk.Checkbutton(columns[i],anchor="w",text=name,variable=var)
        #box.pack(fill="x")
        #box.bind("<1>", self.resetWrap)
        #if var is None: box.configure(state="disabled")

for z in buttonGroups:

    elements = z.getElements()
    for x in elements:
        x.setSelected( True )
        break
#@-node:ekr.20070930184746.383:<< Create four columns of radio and checkboxes >>
#@+node:ekr.20070930184746.384:<< Create two rows of buttons >>
# Create the button panes
secondGroup = swing.JPanel()
secondGroup.setLayout( awt.GridLayout( 2, 3 , 10, 10 ) )
cpane.add( secondGroup )
#buttons  = Tk.Frame(outer,bd=1)
#buttons2 = Tk.Frame(outer,bd=1)
#buttons.pack (anchor="n",expand=1,fill="x")
#buttons2.pack(anchor="n",expand=1,fill="x")
class commandAA( swing.AbstractAction ):

    def __init__( self, name, command ):
        swing.AbstractAction.__init__( self, name )
        self.command = command

    def actionPerformed( self, aE ):
        self.command()


# Create the first row of buttons
#findButton=Tk.Button(buttons,width=8,text="Find",bd=4,command=self.findButton) # The default.
#contextBox=Tk.Checkbutton(buttons,anchor="w",text="Show Context",variable=self.dict["batch"])
#findAllButton=Tk.Button(buttons,width=8,text="Find All",command=self.findAllButton)
findButton = swing.JButton( commandAA( "Find", self.findButton ) )
contextBox = swing.JCheckBox( "Show Context" )
findAllButton = swing.JButton( commandAA( "Find All", self.findAllButton ) )
secondGroup.add( findButton )
secondGroup.add( contextBox )
secondGroup.add( findAllButton )

#findButton.pack   (pady="1p",padx="25p",side="left")
#contextBox.pack   (pady="1p",           side="left",expand=1)
#findAllButton.pack(pady="1p",padx="25p",side="right",fill="x",)

# Create the second row of buttons
#changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
#changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
#changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)
changeButton = swing.JButton( commandAA( "Change", self.changeButton ) )
changeFindButton = swing.JButton( commandAA( "Change, Then Find", self.changeThenFindButton ) )
changeAllButton = swing.JButton( commandAA( "Change All", self.changeAllButton ) )
secondGroup.add( changeButton )
secondGroup.add( changeFindButton )
secondGroup.add( changeAllButton )

#changeButton.pack    (pady="1p",padx="25p",side="left")
#changeFindButton.pack(pady="1p",           side="left",expand=1)
#changeAllButton.pack (pady="1p",padx="25p",side="right")
#@nonl
#@-node:ekr.20070930184746.384:<< Create two rows of buttons >>
#@-node:ekr.20070930184746.381:find.createFrame
#@+node:ekr.20070930184746.385:createNodeSearchFrame
def createNodeSearchFrame( self, clnpanel ):

    clnpanel.setLayout( awt.BorderLayout() )
    oclnpanel = clnpanel
    clnpanel = swing.Box.createHorizontalBox()
    oclnpanel.add( clnpanel, awt.BorderLayout.CENTER )


    jta = swing.JTextArea()
    self.CutCopyPaste( jta )
    tp = swing.JPanel( awt.GridLayout( 1, 1 ))
    self.nstext = jta
    sp = swing.JScrollPane( jta )

    border = sp.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Base Text" )
    sp.setBorder( tborder )
    tp.add( sp )
    clnpanel.add( tp )


    bpanel = swing.JPanel()
    spl = swing.SpringLayout()
    bpanel.setLayout( spl )  
    executebox = swing.Box.createHorizontalBox()
    border = executebox.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Searching" )
    executebox.setBorder( tborder )
    bpanel.add( executebox )
    spl.putConstraint( spl.NORTH, executebox, 5, spl.NORTH, bpanel )
    clnsearch = swing.JButton( "Clone Search" )
    clnsearch.actionPerformed = self.nodeSearch
    executebox.add( clnsearch )
    #spl.putConstraint( spl.NORTH, clnsearch, 5, spl.NORTH, bpanel )
    cpysearch = swing.JButton( "Copy Search" )
    cpysearch.actionPerformed = lambda event: self.nodeSearch( event, type='copy' ) 
    #bpanel.add( cpysearch )
    #spl.putConstraint( spl.NORTH, cpysearch, 5, spl.SOUTH, clnsearch )
    executebox.add( cpysearch )

    self.all_searches = rb1 = swing.JCheckBox( "Match Searches" )
    mtext = """Selecting causes the search system to only recognize a node if all searches match"""
    rb1.setToolTipText( mtext ) 
    bpanel.add( rb1 )
    spl.putConstraint( spl.NORTH, rb1, 5, spl.NORTH, bpanel )
    spl.putConstraint( spl.WEST, rb1, 5, spl.EAST, executebox )


    self.all_filters = rb2 = swing.JCheckBox( "Match Filters" )
    mtext = """Selecting causes the filter system to only filter out a node if all searches match"""
    rb2.setToolTipText( mtext )
    bpanel.add( rb2 )
    spl.putConstraint( spl.NORTH, rb2, 5, spl.SOUTH, rb1 )
    spl.putConstraint( spl.WEST, rb2, 5, spl.EAST, executebox )

    spl2 = swing.SpringLayout()
    sandf = swing.JPanel( spl2 )
    sandf.setPreferredSize( awt.Dimension( 275, 85 ) )
    border = sandf.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Derive Searches and Filters" )
    sandf.setBorder( tborder )
    bpanel.add( sandf )
    spl.putConstraint( spl.NORTH, sandf, 5, spl.SOUTH, executebox )

    b1 = swing.JButton( "+ as Search" )
    b1.setActionCommand( "search" )
    b1.actionPerformed = self.addAsSearchOrExclude
    b2 = swing.JButton( "+ as Filter" )
    b2.setActionCommand( "filter" )
    b2.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b1 ); sandf.add( b2 )
    spl2.putConstraint( spl2.NORTH, b1, 5, spl2.NORTH, executebox )
    spl2.putConstraint( spl2.NORTH, b2, 5, spl2.SOUTH, b1 )
    b3 = swing.JButton( "+ as Regex-Search" )
    b3.setActionCommand( "regex-search" )
    b3.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b3 )
    spl2.putConstraint( spl2.NORTH, b3,5, spl2.NORTH, executebox )
    spl2.putConstraint( spl2.WEST, b3,5, spl2.EAST, b1 )
    #spl2.putConstraint( spl2.EAST, b3, 5, spl2.EAST, executebox )
    b4 = swing.JButton( "+ as Regex-Filter" )
    b4.setActionCommand( "regex-filter" )
    b4.actionPerformed = self.addAsSearchOrExclude
    sandf.add( b4 )
    spl2.putConstraint( spl2.NORTH, b4, 5, spl2.SOUTH, b1 )
    spl2.putConstraint( spl2.WEST, b4, 5, spl2.EAST, b2 )
    clear = swing.JButton( "Clear Text" )
    def clear_txt( event, text = jta ):

        jta.setText( "" )
    clear.actionPerformed = clear_txt
    bpanel.add( clear )
    spl.putConstraint( spl.NORTH, clear, 5, spl.SOUTH, sandf )


    clnpanel.add( bpanel )
    tp.setPreferredSize( awt.Dimension( 200, 100 ) )
    clnpanel.setPreferredSize( awt.Dimension( 200, 100 )) 

    class dtm2( stable.DefaultTableModel ):

        def __int__( self ):
            stable.DefaultTableModel.__init__( self )

        def isCellEditable( self, a, b ):
            if b == 1:
                return False
            return True

    self.dtm = dtm = dtm2()
    dtm.addColumn( "Text" )
    dtm.addColumn( "Type" )
    jp = swing.JPanel( awt.BorderLayout() )
    self.table = jt = swing.JTable( dtm )
    jt.getColumn( "Text" ).setCellEditor( self._LeoTableCellEditor() )
    jt.getColumn( "Text" ).setCellRenderer( self._LeoTableCellRenderer() )

    rmv = swing.JButton( "Remove" )
    def rmv_row( event, jt = jt, dtm = dtm ):

        row = jt.getSelectedRow()
        if row != -1:
            dtm.removeRow( row )

    rmv.actionPerformed = rmv_row
    rmva = swing.JButton( "Clear" )
    def rmv_all( event, jt = jt, dtm = dtm ):

        rc = dtm.getRowCount()
        for z in xrange( rc ):
            dtm.removeRow( 0 )       

    rmva.actionPerformed = rmv_all   
    rmvp = swing.Box.createVerticalBox()
    rmvp.add( rmv )
    rmvp.add( rmva )
    jp.add( rmvp, awt.BorderLayout.EAST )
    jtsp = swing.JScrollPane( jt )
    border = jtsp.getBorder()
    tborder = sborder.TitledBorder( border )
    tborder.setTitle( "Searchers and Filters" )
    jtsp.setBorder( tborder )
    jp.add( jtsp )

    jp.setPreferredSize( clnpanel.getPreferredSize() )
    oclnpanel.add( jp, awt.BorderLayout.SOUTH )
#@-node:ekr.20070930184746.385:createNodeSearchFrame
#@+node:ekr.20070930184746.386:addAsSearchOrExclude
def addAsSearchOrExclude( self, event ):

    source = event.getSource()
    ac = source.getActionCommand()

    doc = self.nstext.getDocument()
    txt = doc.getText( 0, doc.getLength() )

    self.dtm.addRow( ( java.lang.String( txt ), ac ) )
#@nonl
#@-node:ekr.20070930184746.386:addAsSearchOrExclude
#@+node:ekr.20070930184746.387:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        val = getattr(c, key + "_flag")
        val = g.choose(val,1,0) # 2/1/04: work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20070930184746.388:<< set find/change widgets >>
self.find_text.delete("1.0","end")
self.find_text.insert("end",c.find_text)

self.change_text.delete("1.0","end")
self.change_text.insert("end",c.change_text)
#@nonl
#@-node:ekr.20070930184746.388:<< set find/change widgets >>
#@+node:ekr.20070930184746.389:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")

found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20070930184746.389:<< set radio buttons from ivars >>
#@-node:ekr.20070930184746.387:find.init
#@+node:ekr.20070930184746.390:find.set_ivars
def update_ivars2 (self ): #was called set_ivars

    # N.B.: separate c.ivars are much more convenient than a dict.
    c = self.c
    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(c, key + "_flag", val)
        # g.trace(key,val)

    # Set ivars from radio buttons. 10/2/01: convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    c.pattern_match_flag = g.choose(find_type == "pattern-search",1,0)
    c.script_search_flag = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    c.suboutline_only_flag = g.choose(search_scope == "suboutline-only",1,0)
    c.node_only_flag       = g.choose(search_scope == "node-only",1,0)
    c.selection_only_flag  = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    #s = self.find_text.get("1.0","end - 1c") # Remove trailing newline
    #s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03
    #c.find_text = s
    s = self.findPanel.getText()
    c.find_text = s

    #s = self.change_text.get("1.0","end - 1c") # Remove trailing newline
    #s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03
    #c.change_text = s
    s = self.changePanel.getText()
    c.change_text = s
#@nonl
#@-node:ekr.20070930184746.390:find.set_ivars
#@+node:ekr.20070930184746.391:find.update_ivars
def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0) 
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    self.reverse_flag = self.dict[ 'reverse' ].get()

    #s = self.find_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = self.findPanel.getText()
    s = g.toUnicode(s,g.app.tkEncoding)
    self.find_text = s

    #s = self.change_ctrl.get("1.0","end - 1c") # Remove trailing newline
    s = self.changePanel.getText()
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20070930184746.391:find.update_ivars
#@-node:ekr.20070930184746.376:Birth & death
#@+node:ekr.20070930184746.392:onCloseWindow
def onCloseWindow(self,event=None):

    self.top.dispose()
    self.top = None
#@nonl
#@-node:ekr.20070930184746.392:onCloseWindow
#@+node:ekr.20070930184746.393:bringToFront
def bringToFront (self):

    """Bring the tkinter Find Panel to the front."""

    c = g.top() ; #t = self.find_text ; 
    gui = g.app.gui
    t = self.findPanel
    width, height = gui._calculateCenteredPosition( self.top )
    self.top.setLocation( width, height )        
    #self.top.withdraw() # Helps bring the window to the front.
    #self.top.deiconify()
    #self.top.lift()
    self.top.visible = 1

    gui.set_focus(c,t)
    gui.setTextSelection (t, 0, len( t.getText() )) # Thanks Rich.
#@-node:ekr.20070930184746.393:bringToFront
#@+node:ekr.20070930184746.394:selectAll
def selectAll (self,event=None):

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.
#@nonl
#@-node:ekr.20070930184746.394:selectAll
#@+node:ekr.20070930184746.395:Tkinter wrappers (leoTkinterFind)
def gui_search (self,t,*args,**keys):
    nocase = keys[ 'nocase' ]
    backwards = keys[ 'backwards' ]
    regexp = keys[ 'regexp' ]
    stopindex = keys[ 'stopindex' ]

    if self.pattern_match:
        import java.util.regex as reg
        flags = 0
        if not regexp:
            flags = flags|reg.Pattern.LITERAL
        if nocase:
            flags = flags|reg.Pattern.CASE_INSENSITIVE
        flags = java.lang.Integer( flags )

        pat = args[ 0 ]
        pat = reg.Pattern.compile( pat, flags.intValue() )
        match = pat.matcher( java.lang.String( t ) )
        if stopindex:
            match = match.region( 0, stopindex )

        if backwards:
            start = -1
            end = -1
            while match.find():
                start = match.start()
                end = match.end()
            return start, end
        else:
            found = match.find()
            if found:
                return ( match.start(), match.end() )
            else: return None, None
    else:
        if backwards:
            where = t.rfind( args[ 0 ] )
            if where != -1:
                return where, where + len( args[ 0 ] )
            else:
                return None, None
        else:
            match = java.lang.String( t ).indexOf( args[ 0 ] )
            if match != -1:
                return match, match + len( args[ 0 ] )
            else:
                return None, None
    #return t.search(*args,**keys)

def init_s_ctrl (self,s):
    c = self.c ; #t = self.s_text	
    return c.frame.body.editor.editor
    #t.delete("1.0","end")
    #t.insert("end",s)
    #t.mark_set("insert",g.choose(c.reverse_flag,"end","1.0"))
    #return t
#@-node:ekr.20070930184746.395:Tkinter wrappers (leoTkinterFind)
#@+node:ekr.20070930184746.396:search
def search (self):

    """Searches the present headline or body text for c.find_text and returns True if found.

    c.whole_word_flag, c.ignore_case_flag, and c.pattern_match_flag control the search."""

    __pychecker__ = '--no-implicitreturns' # Suppress bad warning.

    self.p = self.c.currentPosition()
    c = self.c ; p = self.p 
    self.v = p
    se = 0
    index = 0
    stopindex = 0
    editor = self.c.frame.body.editor.editor
    caret_pos = editor.getCaretPosition()
    doc = editor.getDocument()

    if self.selection:
        txt = editor.getSelectedText()
    else:
        if self.reverse_flag:
            txt = doc.getText( 0, caret_pos )
        else:
            txt = doc.getText( caret_pos, doc.getLength() - caret_pos )
    #xt = editor.getText( caret_pos, len( txt ) )
    find_text = self.findPanel.getText()
    pos = self.gui_search(txt ,find_text,index,
                            stopindex=stopindex,backwards=self.reverse_flag,
                            regexp=self.pattern_match,nocase=self.ignore_case)

    notin = ( None, -1 )        
    if self.node_only: 
        if pos[ 0 ] in notin and pos[ 1 ] in notin:
            return pos
        else:
            return pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos
    if self.selection:
        if pos[ 0 ] in notin and pos[ 1 ] in notin: return pos
        else:
            return pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos

    if pos[ 0 ] in notin and pos[ 1 ] in notin:
        #if self.suboutline_only:
        #    iterator = self.p.children_iter()
        #else:
        #    iterator = self.p.allNodes_iter()
        #    for z in iterator:
        #        if z == p: break

        self.v = z = self.selectNextVnode()
        while z:
            #if z == p: continue
            txt = z.bodyString()
            pos = self.gui_search(txt ,find_text,index,
                            stopindex=stopindex,backwards=self.reverse_flag,
                            regexp=self.pattern_match,nocase=self.ignore_case)
            if pos[ 0 ] not in ( None, -1 ) and pos[ 1 ] not in ( None, -1 ):
                c.beginUpdate()
                c.selectPosition( z )
                c.endUpdate()
                return pos
            else:
                self.v = z = self.selectNextVnode()     
    else:
        if self.reverse_flag:
            npos = pos[ 1 ], pos[ 0 ]
        else:
            npos = pos[ 0 ] + caret_pos, pos[ 1 ] + caret_pos
        return npos

    return None, None        

@
    if self.lasPos and self.lasPos == v:
        ed = self.c.frame.body.editor.editor
        se = ed.getCaretPosition()
        t = ed.getText()
        t = t[ se: ]
        #t = ed.getText( se, len( ed.getText() ) - se  )
    else:
        t = v.bodyString()
        self.lasPos = v.copy()
    gui = g.app.gui

    assert(c and v)
    if c.selection_only_flag: # 11/9/03
        index,stopindex = self.selStart, self.selEnd
        # g.trace(index,stopindex,v)
        if index == stopindex:
            return None, None
    else:
        #index = gui.getInsertPoint(t)
        index = v.v.t.insertSpot
        stopindex = g.choose(c.reverse_flag,gui.firstIndex(),gui.lastIndex())
    sub_iter = self.v.allNodes_iter( copy = True )
    sub_iter.first = self.v.copy()
    for z in sub_iter:
        if self.lasPos and self.lasPos == z:
            ed = self.c.frame.body.editor.editor
            se = ed.getCaretPosition()
            t = ed.getText()
            t = t[ se: ]
        else:
            se = 0
            t = z.bodyString()
        try:
            pos = self.gui_search(t,c.find_text,index,
                stopindex=stopindex,backwards=c.reverse_flag,
                regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)
        except:
            g.es_exception(full=False)
            self.errors += 1
            return None, None
        if not pos:
            continue

        t = self.c.frame.body.editor.editor
        self.c.beginUpdate()
        self.c.frame.tree.select( z )
        self.c.endUpdate()
        t.requestFocusInWindow()
        t.select( pos[ 0 ] + se  , pos[ 1 ] + se )
        return pos[ 0 ] + se, pos[ 1 ] + se

#@-node:ekr.20070930184746.396:search
#@+node:ekr.20070930184746.397:findButton --had to change
def findButton( self ):

    self.setup_button()
    self.executeSearch()
@
    pos = self.search()
    if pos[ 0 ] and pos[ 1 ]:
        editor = self.c.frame.body.editor.editor
        editor.select( pos[ 0 ], pos[ 1 ] )
        #editor.setSelectionStart( pos[ 0 ] )
        #editor.setSelectionEnd( pos[ 1 ] )
        if len(self.change_text ) != 0:
            editor.replaceSelection( self.change_text )

#@-node:ekr.20070930184746.397:findButton --had to change
#@+node:ekr.20070930184746.398:executeSearch
def executeSearch( self ):

    pos = self.search()
    if pos[ 0 ] not in ( None, -1 ) and pos[ 1 ] not in ( None, -1 ):
        editor = self.c.frame.body.editor.editor
        editor.setCaretPosition( pos[ 0 ] )
        editor.moveCaretPosition( pos[ 1 ] )

        if self.mark_finds:

            cp = self.c.currentPosition()
            cp.setMarked()
            self.c.frame.tree.redraw()

#@-node:ekr.20070930184746.398:executeSearch
#@+node:ekr.20070930184746.399:findNextCommand
def findNextCommand( self, c ):

    self.executeSearch()
#@nonl
#@-node:ekr.20070930184746.399:findNextCommand
#@+node:ekr.20070930184746.400:changeAll
def changeAll( self ):

    cp = self.c.currentPosition().copy()

    fdoc = self.findPanel.getDocument()
    cdoc = self.changePanel.getDocument()
    ftxt = self.findPanel.getText( 0, fdoc.getLength() )
    ctxt = self.changePanel.getText( 0, cdoc.getLength() )
    if self.pattern_match:
        import java.util.regex as reg
        pattern = reg.Pattern.compile( ftxt )
        matcher = pattern.matcher( java.lang.String( "" ) )
    for z in cp.allNodes_iter( copy = True ):

        changed = False
        txt = z.bodyString()
        if self.pattern_match:
            matcher.reset( java.lang.String( txt ) )
            ntxt = matcher.replaceAll( java.lang.String( ctxt ) )
        else:
            ntxt = txt.replace( ftxt, ctxt )

        if txt != ntxt: changed = True
        if changed:
            z.setBodyStringOrPane( ntxt )
            if self.mark_changes:
                z.setMarked()

    self.c.frame.tree.redraw()


#@-node:ekr.20070930184746.400:changeAll
#@+node:ekr.20070930184746.401:clone and copy searching
#@+node:ekr.20070930184746.402:nodeSearch
def nodeSearch( self, event, type = 'clone' ):

    all_searches = self.all_searches.isSelected()
    all_filters = self.all_filters.isSelected()
    dvector = self.dtm.getDataVector()
    if dvector.size() == 0: return
    search = []
    rsearch = []
    filter = []
    rfilter = []
    addto = { 'search': search, 'regex-search': rsearch,
              'filter': filter, 'regex-filter': rfilter }
    for z in dvector:
        addto[ z[ 1 ] ].append( z[ 0 ] )

    bstring = 'Used All Searches: %s   Used All Filters: %s' %( all_searches, all_filters )
    bstring = bstring + '\n\nsearches: \n%s' % '\n'.join( search )
    bstring = bstring + '\n\nregex-searches: \n%s' % '\n'.join( rsearch )
    bstring = bstring + '\n\nfilters: \n%s' % '\n'.join( filter )
    bstring = bstring + '\n\nregex-filters: \n%s' % '\n'.join( rfilter )
    bstring = bstring + '\n\n@' + 'others'

    import java.util.regex as reg        
    for z in xrange( len( rfilter ) ):
        pat = reg.Pattern.compile( rfilter[ z ] )
        matcher = pat.matcher( java.lang.String( "" )) 
        rfilter[ z ] = matcher

    for z in xrange( len( rsearch ) ):
        pat = reg.Pattern.compile( rsearch[ z ] )
        matcher = pat.matcher( java.lang.String( "" ) )
        rsearch[ z ] = matcher






    c = self.c
    cp = self.c.currentPosition()
    if not cp.isValid(): return
    c.beginUpdate()
    if type == 'clone':
        chstring = "Clone Search Results:"
    else:
        chstring = "Copy Search Results:"
    container = self.createContainerNode( chstring, bstring )
    haveseen = {}
    haveseen[ container ] = None
    for z in cp.allNodes_iter( copy = True ):
        if z in haveseen: continue
        else:
            haveseen[ z ] = None

        if z.getParent() == container: continue
        elif z == container: continue
        bstring = z.bodyString()
        hstring = z.headString()
        found = False

        searchmatches = hset()
        if not found:
            for z2 in search:
                if bstring.find( z2 ) != -1:
                    found = True
                    if not all_searches:
                        break
                elif all_searches:
                    found = False
                    searchmatches.add( False )
                    break


        if not found or ( all_searches and False not in searchmatches ):
            for z2 in rsearch:
                matcher = z2
                matcher.reset( java.lang.String( bstring ) )
                if matcher.find():
                    found = True
                    if not all_searches:
                        break
                elif all_searches:
                    found = False
                    break    

        filtermatches = hset()
        if found:
            for z2 in filter:
                if bstring.find( z2 ) != -1:
                    filtermatches.add( True )
                    if not all_filters:
                        found = False
                        break
                elif all_filters:
                    filtermatches.add( False )
                    break



        filtermatches2 = hset()       
        if found:
            for z2 in rfilter:
                matcher = z2
                matcher.reset( java.lang.String( bstring ) )
                if matcher.find():
                    filtermatches2.add( True )
                    if not all_filters:
                        found = False
                        break
                elif all_filters:
                    filtermatches2.add( False )
                    break

        if all_filters and filtermatches.size() != 0 and filtermatches2.size() != 0 and  (
         ( False not in filtermatches ) and ( False not in filtermatches2 ) ):
            found = False

        if found:
            if type == 'clone':
                cln = z.clone( z )
                cln.moveToLastChildOf( container )
            else:
                pos = container.insertAsLastChild()
                cln = z.copyTreeFromSelfTo( pos )

    c.frame.tree.tree_reloader.expand( container )
    c.selectPosition( container )  
    c.endUpdate()     
#@-node:ekr.20070930184746.402:nodeSearch
#@+node:ekr.20070930184746.403:createContainerNode
def createContainerNode( self, hs, bs ):

    c = self.c
    cp = c.currentPosition()
    np = cp.insertAfter()
    np.v.t.headString = hs
    np.v.t.bodyString = bs
    return np
#@nonl
#@-node:ekr.20070930184746.403:createContainerNode
#@-node:ekr.20070930184746.401:clone and copy searching
#@+node:ekr.20070930184746.404:class CutCopyPaste
class CutCopyPaste( aevent.MouseAdapter ):

    def __init__( self, jtcomponent ):

        self.jtcomponent = jtcomponent
        self.popup = popup = swing.JPopupMenu()
        i1 = swing.JMenuItem( "Cut" )
        i1.actionPerformed = lambda event: jtcomponent.cut()
        popup.add( i1 )
        i2 = swing.JMenuItem( "Copy" )
        i2.actionPerformed = lambda event: jtcomponent.copy()
        popup.add( i2 )
        i3 = swing.JMenuItem( "Paste" )
        i3.actionPerformed = lambda event: jtcomponent.paste()
        popup.add( i3 )
        i4 = swing.JMenuItem( "Select All" )
        i4.actionPerformed = lambda event: jtcomponent.selectAll()
        popup.add( i4 )
        jtcomponent.addMouseListener( self )

    def mousePressed( self, mevent ):

        if mevent.getButton() == mevent.BUTTON3:
            self.popup.show( self.jtcomponent, mevent.getX(), mevent.getY() )

#@-node:ekr.20070930184746.404:class CutCopyPaste
#@+node:ekr.20070930184746.405:class _LeoTableCellEditor
class _LeoTableCellEditor( swing.AbstractCellEditor, stable.TableCellEditor ):

    def __init__( self ):
        swing.AbstractCellEditor.__init__( self )  
        self._row = None      
        self._rowh = None   
        self._table = None    
        self.to_be_reset = []
        self.lsners = []

    class _deselector( sevent.PopupMenuListener ):

        def __init__( self, ced ):
            self.ced = ced

        def popupMenuCanceled( self, e):
            self.ced.fireEditingStopped()

        def popupMenuWillBecomeInvisible( self, e):
            self.ced.fireEditingStopped()

        def popupMenuWillBecomeVisible( self, e):
            pass  

    class _lcr( swing.DefaultListCellRenderer ):

        def __init__( self , data):
            swing.DefaultListCellRenderer.__init__( self )
            self.data = data

        def getListCellRendererComponent( self, list, value, index, isSelected, cellHasFocus):

            jta = swing.JTextArea()
            jta.setLineWrap( True )
            jta.setText( self.data ) 
            return jta

    def getTableCellEditorComponent( self, table, value, isSelected, row, column):


            values = value.split( '\n' )
            self._value = value
            jcb = swing.JComboBox( ( values[ 0 ], ) )
            jcb.addPopupMenuListener( self._deselector( self ) )
            jcb.setEditable( False )
            jcb.setRenderer( self._lcr( value ) )
            if len( values ) > 5:
                jcb.setMaximumRowCount( 0 )
            else:
                jcb.setMaximumRowCount( 1 )
            if isSelected:
                jcb.setForeground( table.getSelectionForeground() )
                jcb.setBackground( table.getSelectionBackground() )
            else:
                jcb.setForeground( table.getForeground() )
                jcb.setBackground( table.getBackground() )
            return jcb


    def removeCellEditorListener( self, arg ):

        self.lsners.remove( arg )

    def addCellEditorListener( self, arg ):

        self.lsners.append( arg )

    def fireEditingStopped( self ):

        ce = sevent.ChangeEvent( self )
        for z in self.lsners:
            z.editingStopped( ce )

    def isCellEditable( self, evobj ):
        return True

    def shouldSelectCell( self, evobj ):

        return True

    def getCellEditorValue( self ):
        return self._value


    def stopCellEditing( self ):

        self.fireEditingStopped()
        return True

#@-node:ekr.20070930184746.405:class _LeoTableCellEditor
#@+node:ekr.20070930184746.406:class _LeoTableCellRenderer
class _LeoTableCellRenderer( stable.DefaultTableCellRenderer ):

    def __init__( self ):
        stable.DefaultTableCellRenderer.__init__( self )

    def getTableCellRendererComponent( self, table, value, isSelected, hasFocus, row, column):

        jcb = swing.JComboBox( ( value.split( '\n' )[ 0 ], ) )
        if isSelected:
            jcb.setForeground( table.getSelectionForeground() )
            jcb.setBackground( table.getSelectionBackground() )
        else:
            jcb.setForeground( table.getForeground() )
            jcb.setBackground( table.getBackground() )

        return jcb


#@-node:ekr.20070930184746.406:class _LeoTableCellRenderer
#@-node:ekr.20070930184746.375:from leoSwingFind.py
#@+node:ekr.20070930184746.407:from leoSwingComparePanel
@language python  
@tabwidth -4
@pagewidth 80

import leoGlobals as g
import leoCompare
import javax.swing as swing
import java.awt as awt
import java.awt.event as aevent
import java
import javax.swing.border as sborder
import javax.swing.table as stable


class leoSwingComparePanel (leoCompare.leoCompare):

    """A class that creates Leo's compare panel."""

    @others
#@nonl
#@+node:ekr.20070930184746.408:Birth...
#@+node:ekr.20070930184746.409: tkinterComparePanel.__init__
def __init__ (self,c):

    # Init the base class.
    leoCompare.leoCompare.__init__ (self,c)
    #leoTkinterDialog.leoTkinterDialog.__init__(self,"Compare files and directories",resizeable=False)
    self.c = c

    << init tkinter compare ivars >>

    # These ivars are set from Entry widgets.
    self.limitCount = 0
    self.limitToExtension = None
    self._dtm = self._DTM( [  "","Mismatches", ], 0 )
    # The default file name in the "output file name" browsers.
    self.defaultOutputFileName = "CompareResults.txt"

    self.createTopFrame()
    self.createFrame()
#@+node:ekr.20070930184746.410:<< init tkinter compare ivars >>
# Ivars pointing to Tk elements.
self.browseEntries = []
self.extensionEntry = None
self.countEntry = None
self.printButtons = []

# No corresponding ivar in the leoCompare class.
self.useOutputFileVar = self.IntVar()

# These all correspond to ivars in leoCompare	
self.appendOutputVar             = self.IntVar()

self.ignoreBlankLinesVar         = self.IntVar()
self.ignoreFirstLine1Var         = self.IntVar()
self.ignoreFirstLine2Var         = self.IntVar()
self.ignoreInteriorWhitespaceVar = self.IntVar()
self.ignoreLeadingWhitespaceVar  = self.IntVar()
self.ignoreSentinelLinesVar      = self.IntVar()

self.limitToExtensionVar         = self.IntVar()
self.makeWhitespaceVisibleVar    = self.IntVar()

self.printBothMatchesVar         = self.IntVar()
self.printMatchesVar             = self.IntVar()
self.printMismatchesVar          = self.IntVar()
self.printTrailingMismatchesVar  = self.IntVar()
self.stopAfterMismatchVar        = self.IntVar()
#@nonl
#@-node:ekr.20070930184746.410:<< init tkinter compare ivars >>
#@-node:ekr.20070930184746.409: tkinterComparePanel.__init__
#@+node:ekr.20070930184746.411:fake Tk vars
class IntVar:

    def __init__( self ):

        self._val = 0

    def get( self ):
        return self._val

    def set( self, val ):
        self._val = val
#@-node:ekr.20070930184746.411:fake Tk vars
#@+node:ekr.20070930184746.412:class _DTM
class _DTM( stable.DefaultTableModel ):

    def __init__( self, *args ):
        stable.DefaultTableModel.__init__( self, *args )

    def isCellEditable( self, row, column ):
        return False

#@-node:ekr.20070930184746.412:class _DTM
#@+node:ekr.20070930184746.413:finishCreate
# Initialize ivars from config parameters.

def finishCreate (self):

    c = self.c

    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):

        name = c.config.getString(option)
        if name and len(name) > 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)

    name = c.config.getString("output_file")
    b = g.choose(name and len(name) > 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = c.config.getBool("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)

    b = c.config.getBool("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)

    b = c.config.getBool("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = c.config.getString("limit_directory_search_extension")
    b = ext and len(ext) > 0
    b = g.choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        #e.delete(0,"end")
        e.setText( ext )
        #e.insert(0,ext)

    # Print options.
    b = c.config.getBool("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)

    b = c.config.getBool("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)

    b = c.config.getBool("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)

    b = c.config.getBool("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)

    n = c.config.getInt("limit_count")
    b = n and n > 0
    b = g.choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.setText( str( n ) )
        #e.delete(0,"end")
        #e.insert(0,str(n))

    # bool options...
    for option,var,default in (
        # Whitespace options.
        ("ignore_blank_lines",self.ignoreBlankLinesVar,1),
        ("ignore_interior_whitespace",self.ignoreInteriorWhitespaceVar,0),
        ("ignore_leading_whitespace",self.ignoreLeadingWhitespaceVar,0),
        ("ignore_sentinel_lines",self.ignoreSentinelLinesVar,0),
        ("make_whitespace_visible", self.makeWhitespaceVisibleVar,0),
    ):
        b = c.config.getBool(option)
        if b is None: b = default
        var.set(b)

    if 0: # old code
        b = c.config.getBool("ignore_blank_lines")
        if b == None: b = 1 # unusual default.
        self.ignoreBlankLinesVar.set(b)

        b = c.config.getBool("ignore_interior_whitespace")
        if b == None: b = 0
        self.ignoreInteriorWhitespaceVar.set(b)

        b = c.config.getBool("ignore_leading_whitespace")
        if b == None: b = 0
        self.ignoreLeadingWhitespaceVar.set(b)

        b = c.config.getBool("ignore_sentinel_lines")
        if b == None: b = 0
        self.ignoreSentinelLinesVar.set(b)

        b = c.config.getBool("make_whitespace_visible")
        if b == None: b = 0
        self.makeWhitespaceVisibleVar.set(b)
#@nonl
#@-node:ekr.20070930184746.413:finishCreate
#@+node:ekr.20070930184746.414:createTopFrame
def createTopFrame( self ):

    self.frame = self.top = swing.JDialog()
    g.app.gui.addLAFListener( self.frame )
    self.top.title = "Compare files and directories"
#@nonl
#@-node:ekr.20070930184746.414:createTopFrame
#@+node:ekr.20070930184746.415:createFrame
def createFrame (self):

    gui = g.app.gui ; top = self.top

    << create the organizer frames >>
    << create the browser rows >>
    << create the extension row >>
    << create the whitespace options frame >>
    << create the print options frame >>
    << create the compare buttons >>


    top.pack()
    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()
#@nonl
#@+node:ekr.20070930184746.416:<< create the organizer frames >>
#outer = Tk.Frame(self.frame, bd=2,relief="groove")
#outer.pack(pady=4)

sl = swing.SpringLayout()
outer = self.top.getContentPane() #swing.JPanel()
outer.setLayout( sl )
#self.frame.add( outer )

#row1 = Tk.Frame(outer)
#row1.pack(pady=4)
row1 = swing.JPanel( awt.GridLayout( 3, 4 ) )
outer.add( row1 )
sl.putConstraint( sl.NORTH, row1, 5, sl.NORTH, outer )


row4 = swing.JPanel()
outer.add( row4 )
sl.putConstraint( sl.NORTH, row4, 5, sl.SOUTH, row1 )


sl2 = swing.SpringLayout()
options =  swing.JPanel( sl2 )#swing.Box.createHorizontalBox() #swing.JPanel( sl2 );

outer.add( options )
sl.putConstraint( sl.NORTH, options, 5, sl.SOUTH, row4 )

#ws = Tk.Frame(options)
#ws.pack(side="left",padx=4)
ws = swing.JPanel()
ws.setLayout( awt.GridLayout( 1, 1 ) )
options.add( ws )
sl2.putConstraint( sl2.NORTH, ws, 2, sl2.NORTH, options )
sl2.putConstraint( sl2.WEST, ws, 5, sl2.WEST, options )

pr = swing.JPanel()
pr.setLayout( awt.GridLayout( 1, 1 ) )
options.add( pr )
sl2.putConstraint( sl2.NORTH, pr, 2, sl2.NORTH, options )
sl2.putConstraint( sl2.WEST, pr, 10, sl2.EAST, ws )
sl2.putConstraint( sl2.SOUTH, options, 5, sl2.SOUTH, pr )
sl2.putConstraint( sl2.EAST, options, 5, sl2.EAST, pr )

lower = swing.JPanel()
outer.add( lower )
sl.putConstraint( sl.NORTH, lower, 5, sl.SOUTH, options )
sl.putConstraint( sl.EAST, lower, 0, sl.EAST, options )

sl.putConstraint( sl.SOUTH, outer, 5, sl.SOUTH, lower )
sl.putConstraint( sl.EAST, outer, 5, sl.EAST, row1 )
#@-node:ekr.20070930184746.416:<< create the organizer frames >>
#@+node:ekr.20070930184746.417:<< create the browser rows >>
for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row1,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row1,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    #lab = Tk.Label(row,anchor="e",text=text,width=13)
    #lab.pack(side="left",padx=4)
    lab = swing.JLabel( text )
    row.add( lab )

    #e = Tk.Entry(row)
    #e.pack(side="left",padx=2)
    e = swing.JTextField( 15 )
    row.add( e )
    self.browseEntries.append(e)

    #b = Tk.Button(row,text="browse...",command=command)
    #b.pack(side="left",padx=6)
    b = swing.JButton( "browse..." )
    b.actionPerformed = lambda event, command = command: command()
    row.add( b )

    #b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    #b.pack(side="left")
    b = swing.JCheckBox( text2 )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    row.add( b )
#@nonl
#@-node:ekr.20070930184746.417:<< create the browser rows >>
#@+node:ekr.20070930184746.418:<< create the extension row >>
#b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
#    text="Limit directory compares to type:")
#b.pack(side="left",padx=4)
b = swing.JCheckBox( "Limit directory compares to type:" )
b.actionPerformed = lambda event, b=b, var=self.limitToExtensionVar: var.set( b.getModel().isSelected() )
row4.add( b )


#self.extensionEntry = e = Tk.Entry(row4,width=6)
#e.pack(side="left",padx=2)
self.extensionEntry = e = swing.JTextField(5)
row4.add( e )

#b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
#    text="Append output to output file")
#b.pack(side="left",padx=4)

b = swing.JCheckBox( "Append output to outputfile" )
b.actionPerformed = lambda event, b = b, var = self.appendOutputVar: var.set( b.getModel().isSelected() )
row4.add( b )
#@-node:ekr.20070930184746.418:<< create the extension row >>
#@+node:ekr.20070930184746.419:<< create the whitespace options frame >>
w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")


f.setLayout( awt.GridLayout( 5, 1 ) )

for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):

    #b = Tk.Checkbutton(f,text=text,variable=var)
    #b.pack(side="top",anchor="w")
    b = swing.JCheckBox( text )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    f.add( b )


#@-node:ekr.20070930184746.419:<< create the whitespace options frame >>
#@+node:ekr.20070930184746.420:<< create the print options frame >>
w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")
f.setLayout( awt.GridLayout( 5, 1 ) )

#row = Tk.Frame(f)
#row.pack(expand=1,fill="x")
row = swing.JPanel()
sl3 = swing.SpringLayout()
row.setLayout( sl3 )
f.add( row )
pwidth = 0


#b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
#b.pack(side="left",anchor="w")
b = swing.JCheckBox( "Stop after" )
b.actionPerformed = lambda event, var = self.stopAfterMismatchVar, b = b: var.set( b.getModel().isSelected() )
row.add( b )
sl3.putConstraint( sl3.NORTH, b, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, b, 1, sl3.WEST, row )

#self.countEntry = e = Tk.Entry(row,width=4)
#e.pack(side="left",padx=2)
#e.insert(01,"1")
self.countEntry = e = swing.JTextField(5)
row.add( e )
sl3.putConstraint( sl3.NORTH, e, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, e, 1, sl3.EAST, b )

#lab = Tk.Label(row,text="mismatches")
#lab.pack(side="left",padx=2)
lab = swing.JLabel( "mismatches" )
row.add( lab )
sl3.putConstraint( sl3.NORTH, lab, 1, sl3.NORTH, row )
sl3.putConstraint( sl3.WEST, lab, 1, sl3.EAST, e )
sl3.putConstraint( sl3.SOUTH, row, 1, sl3.SOUTH, e )
sl3.putConstraint( sl3.EAST, row, 1, sl3.EAST, lab )




for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):

    #b = Tk.Checkbutton(f,text=text,variable=var)
    #b.pack(side="top",anchor="w",padx=padx)
    b = swing.JCheckBox( text )
    b.actionPerformed = lambda event, b=b, var=var: var.set( b.getModel().isSelected() )
    f.add( b )
    self.printButtons.append(b)



# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
#b.configure(command=self.onPrintMatchedLines)

#spacer = Tk.Frame(f)
#spacer.pack(padx="1i")
#@nonl
#@-node:ekr.20070930184746.420:<< create the print options frame >>
#@+node:ekr.20070930184746.421:<< create the compare buttons >>
for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):

    #b = Tk.Button(lower,text=text,command=command,width=18)
    #b.pack(side="left",padx=6)
    b = swing.JButton( text )
    b.actionPerformed = lambda event, command=command: command()
    lower.add( b )

#@-node:ekr.20070930184746.421:<< create the compare buttons >>
#@-node:ekr.20070930184746.415:createFrame
#@+node:ekr.20070930184746.422:setIvarsFromWidgets
def setIvarsFromWidgets (self):

    # File paths: checks for valid file name.
    e = self.browseEntries[0]
    self.fileName1 = e.getText()

    e = self.browseEntries[1]
    self.fileName2 = e.getText()

    # Ignore first line settings.
    self.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
    self.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()

    # Output file: checks for valid file name.
    if self.useOutputFileVar.get():
        e = self.browseEntries[2]
        name = e.getText()
        if name != None and len(name) == 0:
            name = None
        self.outputFileName = name
    else:
        #self._dtm.setRowCount( 0 )
        self.outputFileName = None

    # Extension settings.
    if self.limitToExtensionVar.get():
        self.limitToExtension = self.extensionEntry.getText()
        if len(self.limitToExtension) == 0:
            self.limitToExtension = None
    else:
        self.limitToExtension = None

    self.appendOutput = self.appendOutputVar.get()

    # Whitespace options.
    self.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
    self.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
    self.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
    self.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
    self.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()

    # Print options.
    self.printMatches            = self.printMatchesVar.get()
    self.printMismatches         = self.printMismatchesVar.get()
    self.printTrailingMismatches = self.printTrailingMismatchesVar.get()

    if self.printMatches:
        self.printBothMatches = self.printBothMatchesVar.get()
    else:
        self.printBothMatches = False

    if self.stopAfterMismatchVar.get():
        try:
            count = self.countEntry.get()
            self.limitCount = int(count)
        except: self.limitCount = 0
    else:
        self.limitCount = 0
#@nonl
#@-node:ekr.20070930184746.422:setIvarsFromWidgets
#@-node:ekr.20070930184746.408:Birth...
#@+node:ekr.20070930184746.423:bringToFront
def bringToFront(self):

    #self.top.deiconify()
    #self.top.lift()
    self.top.visible = 1
    self.top.toFront()

#@-node:ekr.20070930184746.423:bringToFront
#@+node:ekr.20070930184746.424:browser
def browser (self,n):

    types = [
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py"),
        ("Text files","*.txt"),
        ("All files","*") ]


    import java.io as io
    f = io.File( "tmp" )
    parent = f.getParentFile()
    f = None

    fc = swing.JFileChooser( parent )
    fc.setDialogTitle( "Choose compare file" + n )


    haveseen = {}
    for z in types:
        if z[ 0 ] in haveseen:
            haveseen[ z[ 0 ] ].extend( z[1] )
        else:
            bf = self.brwsfilter( z )
            fc.addChoosableFileFilter( bf )
            haveseen[ z[ 0 ] ] = bf

    result = fc.showOpenDialog( self.top )
    if result == fc.APPROVE_OPTION:
        fileName = fc.getSelectedFile().getAbsolutePath()
    else:
        fileName = None

    #fileName = tkFileDialog.askopenfilename(
    #    title="Choose compare file" + n,
    #    filetypes=types,
    #    defaultextension=".txt")

    if fileName and len(fileName) > 0:
        # The dialog also warns about this, so this may never happen.
        if not g.os_path_exists(fileName):
            self.show("not found: " + fileName)
            fileName = None
    else: fileName = None

    return fileName
#@nonl
#@-node:ekr.20070930184746.424:browser
#@+node:ekr.20070930184746.425:compare_directories (entry)
# We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):

    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)

    if dir1 == dir2:
        self.show("Directory names are identical.\nPlease pick distinct directories.")
        return

    try:
        list1 = os.listdir(dir1)
    except:
        self.show("invalid directory:" + dir1)
        return
    try:
        list2 = os.listdir(dir2)
    except:
        self.show("invalid directory:" + dir2)
        return

    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok:
        return

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and fail lists.
    yes = [] ; no = [] ; fail = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                _file1 = java.io.File( name1 )
                _file2 = java.io.File( name2 )
                if _file1.length() == _file2.length():
                    val = self._filecmp( name1, name2 )                    
                else:
                    val = False
                #val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                fail.append(f1)
        else:
            fail.append(f1)

    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found ------",fail)):
        self.show(kind)
        for f in files:
            self.show(f)

    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None
#@nonl
#@-node:ekr.20070930184746.425:compare_directories (entry)
#@+node:ekr.20070930184746.426:filecmp
def filecmp (self,f1,f2):

    #val = filecmp.cmp(f1,f2)
    val = self._filecmp( f1, f2 )
    if 1:
        if val: self.show("equal")
        else:   self.show("*** not equal")
    else:
        self.show("filecmp.cmp returns:")
        if val: self.show(str(val)+ " (equal)")
        else:   self.show(str(val) + " (not equal)")
    return val


def _filecmp( self, f1, f2 ):

    _file1 = java.io.File( f1 )
    _file2 = java.io.File( f2 )
    _fc1 = java.io.FileInputStream( _file1 ).getChannel()
    _fc2 = java.io.FileInputStream( _file2 ).getChannel()
    _bb1 = java.nio.ByteBuffer.allocateDirect( _fi1e1.length() )
    _bb2 = java.nio.ByteBuffer.allocateDirect( _file2.length() )
    _fc1.read( _bb1 )
    _fc2.read( _bb2 )
    _fc1.close(); _fc2.close()
    _bb1.position( 0 ); _bb2.position( 0 )
    c_result = _bb1.compareTo( _bb2 )
    if c_result == 0:
        val = True
    else:
        val = False

    return val
#@nonl
#@-node:ekr.20070930184746.426:filecmp
#@+node:ekr.20070930184746.427:class brwsfilter
import javax.swing.filechooser as ff
class brwsfilter( ff.FileFilter ):

    def __init__( self, items ):
        self.items = items
        self.filters = []
        self.extend( items[ 1 ] )

    def accept( self, fvar ):
        name = fvar.getName()
        for ending in self.filters:
            if name.endswith( ending ): return True

        return False

    def extend( self, item ):
        self.filters.append( item.strip( '*' ) )

    def getDescription( self ):
        return self.items[ 0 ]
#@nonl
#@-node:ekr.20070930184746.427:class brwsfilter
#@+node:ekr.20070930184746.428:Event handlers...
#@+node:ekr.20070930184746.429:onBrowse...
def onBrowse1 (self):

    fileName = self.browser("1")
    if fileName:
        e = self.browseEntries[0]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)
    #self.top.deiconify()

def onBrowse2 (self):

    fileName = self.browser("2")
    if fileName:
        e = self.browseEntries[1]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)
    #self.top.deiconify()

def onBrowse3 (self): # Get the name of the output file.

    #fileName = tkFileDialog.asksaveasfilename(
    #    initialfile = self.defaultOutputFileName,
    #    title="Set output file",
    #    filetypes=[("Text files", "*.txt")],
    #    defaultextension=".txt")
    import java.io as io
    f = io.File( "tmp" )
    parent = f.getParentFile()
    f = None

    fc = swing.JFileChooser( parent )
    result = fc.showSaveDialog( self.top )
    if result == fc.APPROVE_OPTION:
        fileName = fc.getSelectedFile().getAbsolutePath()
    else:
        fileName = None


    if fileName and len(fileName) > 0:
        self.defaultOutputFileName = fileName
        self.useOutputFileVar.set(1) # The user will expect this.
        e = self.browseEntries[2]
        e.setText( fileName )
        #e.delete(0,"end")
        #e.insert(0,fileName)
#@nonl
#@-node:ekr.20070930184746.429:onBrowse...
#@+node:ekr.20070930184746.430:onClose
def onClose (self):

    self.top.withdraw()
#@nonl
#@-node:ekr.20070930184746.430:onClose
#@+node:ekr.20070930184746.431:onCompare...
def onCompareDirectories (self):

    self.setIvarsFromWidgets()
    self._dtm.setRowCount( 0 )
    self.compare_directories(self.fileName1,self.fileName2)
    if self._dtm.getRowCount() > 0:
        self.showMismatchTable()

def onCompareFiles (self):

    self.setIvarsFromWidgets()
    self._dtm.setRowCount( 0 )
    self.compare_files(self.fileName1,self.fileName2)
    if self._dtm.getRowCount() > 0:
        self.showMismatchTable()
#@nonl
#@-node:ekr.20070930184746.431:onCompare...
#@+node:ekr.20070930184746.432:onPrintMatchedLines
def onPrintMatchedLines (self):

    v = self.printMatchesVar.get()
    b = self.printButtons[1]
    state = g.choose(v,"normal","disabled")
    b.configure(state=state)
#@nonl
#@-node:ekr.20070930184746.432:onPrintMatchedLines
#@-node:ekr.20070930184746.428:Event handlers...
#@+node:ekr.20070930184746.433:utils
#@+node:ekr.20070930184746.434:show
def show (self,s):

    # print s
    if self.outputFile:
        self.outputFile.write(s + '\n')
    elif self.c:
        #g.es(s)
        self._dtm.addRow( [ self._dtm.getRowCount() + 1 ,s ] )
    else:
        print s
        print
#@nonl
#@-node:ekr.20070930184746.434:show
#@+node:ekr.20070930184746.435:showMismatchTable
def showMismatchTable( self ):

    jf = swing.JFrame()

    jf.setDefaultCloseOperation( jf.DISPOSE_ON_CLOSE )
    cp = jf.getContentPane()
    cp.setLayout( awt.BorderLayout() )
    jt = swing.JTable( self._dtm )
    jt.setAutoResizeMode( jt.AUTO_RESIZE_ALL_COLUMNS )
    drend = self._dftcr()
    jt.setDefaultRenderer( java.lang.Object, drend )
    count = self._dtm.getRowCount()
    tmp_label = swing.JLabel( java.lang.String.valueOf( count ) )
    psize = tmp_label.getPreferredSize()
    column = jt.getColumn( "" )
    column.setPreferredWidth( psize.width + 10 )
    column.setMaxWidth( psize.width + 10 )
    sp = swing.JScrollPane( jt )
    sp.addComponentListener( drend )
    cp.add( sp, awt.BorderLayout.CENTER )
    jb = swing.JButton( "Close" )
    jb.actionPerformed = lambda event: jf.dispose()
    cp.add( jb, awt.BorderLayout.SOUTH )
    jf.pack()
    g.app.gui.center_dialog( jf )
    jf.visible = 1

class _dftcr( stable.DefaultTableCellRenderer, aevent.ComponentListener ):

    def __init__( self ):
        stable.DefaultTableCellRenderer.__init__( self )
        self._component = swing.JTextArea()
        self._component.setLineWrap( True )
        self._label = swing.JTextField()
        self._label.setMargin( awt.Insets( 0, 0, 0, 0 ) )


    def getTableCellRendererComponent( self, table, value,isSelected, hasFocus, row, column):

        if column == 1:
            vrect = table.getVisibleRect()
            self._component.setText( value )
            size = self._component.getSize()
            size.width = vrect.width
            self._component.setSize( size )
            if isSelected:
                self._component.setForeground( table.getSelectionForeground() )
                self._component.setBackground( table.getSelectionBackground() )
            else:
                self._component.setForeground( table.getForeground()) 
                self._component.setBackground( table.getBackground() )

            table.setRowHeight( row, self._component.getPreferredSize().height )
            return self._component
        else:

            row = java.lang.String.valueOf( row + 1 )
            self._label.setText( row )
            if isSelected:
                self._label.setForeground( table.getSelectionForeground() )
                self._label.setBackground( table.getSelectionBackground() )
            else:
                self._label.setForeground( table.getForeground()) 
                self._label.setBackground( table.getBackground() ) 
            return self._label

    def componentHidden( self, event ):
        pass

    def componentMoved( self, event ):
        pass

    def componentResized( self, event ):

        pass
        #source = event.getSource()
        #vrect = source.getVisibleRect()
        #model = source.getModel()
        #csize = self._component.getSize()
        #csize.width = vrect.width
        #print self._component.getPreferredSize()
        #print self._component.getSize()
        #for z in xrange( model.getRowCount() ):
        #    value = model.getValueAt( z, 0 )
        #    self._component.setText( value )
        #    print self._component.getPreferredSize()
        #    print self._component.getSize()
        #    source.setRowHeight( z, self._component.getPreferredSize().height )




    def componentShown( self, event ):

        event.getSource().repaint()
#@nonl
#@-node:ekr.20070930184746.435:showMismatchTable
#@-node:ekr.20070930184746.433:utils
#@-node:ekr.20070930184746.407:from leoSwingComparePanel
#@-node:ekr.20070930184746:from original swingGui plugin
#@+node:ekr.20070228074312:class baseTextWidget
# Subclassing from wx.EvtHandler allows methods of this and derived class to be event handlers.

class baseTextWidget:

    '''The base class for all wrapper classes for leo Text widgets.'''

    @others
#@+node:ekr.20070228074312.1:Birth & special methods (baseText)
def __init__ (self,c,baseClassName,name,widget):

    self.baseClassName = baseClassName
    self.c = c
    self.name = name
    self.virtualInsertPoint = None
    self.widget = widget # Not used at present.

def __repr__(self):
    return '%s: %s' % (self.baseClassName,id(self))

#@-node:ekr.20070228074312.1:Birth & special methods (baseText)
#@+node:ekr.20070228074312.2:baseTextWidget.onChar
# Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

def onChar (self, event):

    c = self.c
    keycode = event.GetKeyCode()
    event.leoWidget = self
    keysym = g.app.gui.eventKeysym(event)
    #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    if keysym:
        c.k.masterKeyHandler(event,stroke=keysym)
#@nonl
#@-node:ekr.20070228074312.2:baseTextWidget.onChar
#@+node:ekr.20070228074312.3:Do-nothing
def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
#@-node:ekr.20070228074312.3:Do-nothing
#@+node:ekr.20070228074312.4:bindings (must be overridden in subclasses)
# def _appendText(self,s):            self.oops()
# def _get(self,i,j):                 self.oops()
# def _getAllText(self):              self.oops()
# def _getFocus(self):                self.oops()
# def _getInsertPoint(self):          self.oops()
# def _getLastPosition(self):         self.oops()
# def _getSelectedText(self):         self.oops()
# def _getSelectionRange(self):       self.oops()
# def _hitTest(self,pos):             self.oops()
# def _insertText(self,i,s):          self.oops()
# def _scrollLines(self,n):           self.oops()
# def _see(self,i):                   self.oops()
# def _setAllText(self,s):            self.oops()
# def _setBackgroundColor(self,color): self.oops()
# def _setFocus(self):                self.oops()
# def _setInsertPoint(self,i):        self.oops()
# def _setSelectionRange(self,i,j):   self.oops()

# _findFocus = _getFocus
#@-node:ekr.20070228074312.4:bindings (must be overridden in subclasses)
#@+node:ekr.20070228074312.5:oops
def oops (self):

    print('wxGui baseTextWidget oops:',self,g.callers(),
        'must be overridden in subclass')
#@-node:ekr.20070228074312.5:oops
#@+node:ekr.20070228074312.6:Index conversion
#@+node:ekr.20070228074312.7:w.toGuiIndex & toPythonIndex
def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w._getLastPosition()
    else:
        # g.trace(repr(index))
        s = w._getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col)
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex
#@nonl
#@-node:ekr.20070228074312.7:w.toGuiIndex & toPythonIndex
#@+node:ekr.20070228074312.8:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return g.convertRowColToPythonIndex(s,row,col)    
#@-node:ekr.20070228074312.8:w.rowColToGuiIndex
#@-node:ekr.20070228074312.6:Index conversion
#@+node:ekr.20070228074312.9:Wrapper methods (widget-independent)
# These methods are widget-independent because they call the corresponding _xxx methods.
#@nonl
#@+node:ekr.20070228074312.10:appendText
def appendText (self,s):

    w = self
    w._appendText(s)
#@-node:ekr.20070228074312.10:appendText
#@+node:ekr.20070228074312.11:bind
def bind (self,kind,*args,**keys):

    w = self

    pass # g.trace('wxLeoText',kind,args[0].__name__)
#@nonl
#@-node:ekr.20070228074312.11:bind
#@+node:ekr.20070228074312.12:clipboard_clear & clipboard_append
def clipboard_clear (self):

    g.app.gui.replaceClipboardWith('')

def clipboard_append(self,s):

    s1 = g.app.gui.getTextFromClipboard()

    g.app.gui.replaceClipboardWith(s1 + s)
#@-node:ekr.20070228074312.12:clipboard_clear & clipboard_append
#@+node:ekr.20070228074312.13:delete
def delete(self,i,j=None):

    w = self
    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    # g.trace(i,j,len(s),repr(s[:20]))
    s = w.getAllText()
    w.setAllText(s[:i] + s[j:])
#@-node:ekr.20070228074312.13:delete
#@+node:ekr.20070228074312.14:deleteTextSelection
def deleteTextSelection (self):

    w = self
    i,j = w._getSelectionRange()
    if i == j: return

    s = w._getAllText()
    s = s[i:] + s[j:]

    # g.trace(len(s),repr(s[:20]))
    w._setAllText(s)
#@-node:ekr.20070228074312.14:deleteTextSelection
#@+node:ekr.20070228074312.15:event_generate (baseTextWidget)
def event_generate(self,stroke):

    w = self ; c = self.c ; char = stroke

    # Canonicalize the setting.
    stroke = c.k.shortcutFromSetting(stroke)

    # g.trace('baseTextWidget','char',char,'stroke',stroke)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,keysym):
            self.c = c
            self.char = char
            self.keysym = keysym
            self.leoWidget = w
            self.widget = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
#@-node:ekr.20070228074312.15:event_generate (baseTextWidget)
#@+node:ekr.20070228074312.16:flashCharacter (to do)
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    return ###

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toPythonIndex(index),w.toPythonIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count > 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()
#@nonl
#@-node:ekr.20070228074312.16:flashCharacter (to do)
#@+node:ekr.20070228074312.17:getFocus (baseText)
def getFocus (self):

    w = self
    w2 = w._getFocus()
    # g.trace('w',w,'focus',w2)
    return w2

findFocus = getFocus
#@-node:ekr.20070228074312.17:getFocus (baseText)
#@+node:ekr.20070228074312.18:get
def get(self,i,j=None):

    w = self

    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    s = w._get(i,j)
    return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20070228074312.18:get
#@+node:ekr.20070228074312.19:getAllText
def getAllText (self):

    w = self

    s = w._getAllText()
    return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20070228074312.19:getAllText
#@+node:ekr.20070228074312.20:getInsertPoint (baseText)
def getInsertPoint(self):

    w = self
    i = w._getInsertPoint()

    # g.trace(self,'baseWidget: i:',i,'virtual',w.virtualInsertPoint)

    if i is None:
        if w.virtualInsertPoint is None:
            i = 0
        else:
            i = w.virtualInsertPoint

    w.virtualInsertPoint = i

    return i
#@-node:ekr.20070228074312.20:getInsertPoint (baseText)
#@+node:ekr.20070228102413:getName & GetName
def GetName(self):
    return self.name

getName = GetName
#@nonl
#@-node:ekr.20070228102413:getName & GetName
#@+node:ekr.20070228074312.21:getSelectedText
def getSelectedText (self):

    w = self
    s = w._getSelectedText()
    return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20070228074312.21:getSelectedText
#@+node:ekr.20070228074312.22:getSelectionRange (baseText)
def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] >= 0 and sel[1] >= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i > j: sel = j,i # Bug fix: 10/5/07
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
#@-node:ekr.20070228074312.22:getSelectionRange (baseText)
#@+node:ekr.20070228074312.23:getYScrollPosition
def getYScrollPosition (self):

     w = self
     return w._getYScrollPosition()
#@-node:ekr.20070228074312.23:getYScrollPosition
#@+node:ekr.20070228074312.24:getWidth
def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return 0
#@-node:ekr.20070228074312.24:getWidth
#@+node:ekr.20070228074312.25:hasSelection
def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
#@-node:ekr.20070228074312.25:hasSelection
#@+node:ekr.20070228074312.26:insert
# The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toPythonIndex(i)
    # w._setInsertPoint(i)
    w._insertText(i,s)
#@-node:ekr.20070228074312.26:insert
#@+node:ekr.20070228074312.27:indexIsVisible
def indexIsVisible (self,i):

    return False # Code will loop if this returns True forever.
#@nonl
#@-node:ekr.20070228074312.27:indexIsVisible
#@+node:ekr.20070228074312.28:replace
def replace (self,i,j,s):

    w = self
    w.delete(i,j)
    w.insert(i,s)
#@-node:ekr.20070228074312.28:replace
#@+node:ekr.20070228074312.29:scrollLines
def scrollLines (self,n):

    w = self
    w._scrollLines(n)
#@nonl
#@-node:ekr.20070228074312.29:scrollLines
#@+node:ekr.20070228074312.30:see & seeInsertPoint
def see(self,index):

    w = self
    i = self.toPythonIndex(index)
    w._see(i)

def seeInsertPoint(self):

    w = self
    i = w._getInsertPoint()
    w._see(i)
#@-node:ekr.20070228074312.30:see & seeInsertPoint
#@+node:ekr.20070228074312.31:selectAllText
def selectAllText (self,insert=None):

    '''Select all text of the widget.'''

    w = self
    w.setSelectionRange(0,'end',insert=insert)
#@-node:ekr.20070228074312.31:selectAllText
#@+node:ekr.20070228074312.32:setAllText
def setAllText (self,s):

    w = self
    w._setAllText(s)
#@nonl
#@-node:ekr.20070228074312.32:setAllText
#@+node:ekr.20070228074312.33:setBackgroundColor & SetBackgroundColour
def setBackgroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setBackgroundColor(color)

SetBackgroundColour = setBackgroundColor
#@nonl
#@-node:ekr.20070228074312.33:setBackgroundColor & SetBackgroundColour
#@+node:ekr.20070228074312.34:setFocus (baseText)
def setFocus (self):

    w = self
    # g.trace('baseText')
    return w._setFocus()

SetFocus = setFocus
#@-node:ekr.20070228074312.34:setFocus (baseText)
#@+node:ekr.20070228074312.35:setInsertPoint (baseText)
def setInsertPoint (self,pos):

    w = self
    w.virtualInsertPoint = i = w.toPythonIndex(pos)
    # g.trace(self,i)
    w._setInsertPoint(i)
#@-node:ekr.20070228074312.35:setInsertPoint (baseText)
#@+node:ekr.20070228074312.36:setSelectionRange (baseText)
def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    # g.trace(self,'baseWidget',repr(i1),'=',repr(i),repr(j1),'=',repr(j),repr(insert1),'=',repr(insert),g.callers(4))

    if i == j:
        w._setInsertPoint(j)
    else:
        w._setSelectionRange(i,j)

    if insert is not None and insert in (i,j):
        ins = w.toPythonIndex(insert)
        if ins in (i,j):
            self.virtualInsertPoint = ins
#@-node:ekr.20070228074312.36:setSelectionRange (baseText)
#@+node:ekr.20070228074312.37:setWidth
def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    pass
#@-node:ekr.20070228074312.37:setWidth
#@+node:ekr.20070228074312.38:setYScrollPosition
def setYScrollPosition (self,i):

     w = self
     w._setYScrollPosition(i)
#@nonl
#@-node:ekr.20070228074312.38:setYScrollPosition
#@+node:ekr.20070228074312.39:tags (to-do)
#@+node:ekr.20070228074312.40:mark_set (to be removed)
def mark_set(self,markName,i):

    w = self
    i = self.toPythonIndex(i)

    ### Tk.Text.mark_set(w,markName,i)
#@-node:ekr.20070228074312.40:mark_set (to be removed)
#@+node:ekr.20070228074312.41:tag_add
# The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ###

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)
#@nonl
#@-node:ekr.20070228074312.41:tag_add
#@+node:ekr.20070228074312.42:tag_configure & helper
def tag_configure (self,colorName,**keys):
    pass

tag_config = tag_configure
#@nonl
#@+node:ekr.20070228074312.43:tkColorToWxColor
def tkColorToWxColor (self, color):

    d = {
        'black':        wx.BLACK,
        "red":          wx.RED,
        "blue":         wx.BLUE,
        "#00aa00":      wx.GREEN,
        "firebrick3":   wx.RED,
        'white':        wx.WHITE,
    }

    return d.get(color)
#@nonl
#@-node:ekr.20070228074312.43:tkColorToWxColor
#@-node:ekr.20070228074312.42:tag_configure & helper
#@+node:ekr.20070228074312.44:tag_delete (NEW)
def tag_delete (self,tagName,*args,**keys):

    pass # g.trace(tagName,args,keys)
#@nonl
#@-node:ekr.20070228074312.44:tag_delete (NEW)
#@+node:ekr.20070228074312.45:tag_names
def tag_names (self, *args):

    return []
#@-node:ekr.20070228074312.45:tag_names
#@+node:ekr.20070228074312.46:tag_ranges
def tag_ranges(self,tagName):

    return tuple() ###

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
#@-node:ekr.20070228074312.46:tag_ranges
#@+node:ekr.20070228074312.47:tag_remove
def tag_remove(self,tagName,i,j=None,*args):

    w = self
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)

    return ### Not ready yet.

    if not hasattr(w,'leo_styles'):
        w.leo_styles = {}

    style = w.leo_styles.get(tagName)

    if style is not None:
        # g.trace(i,j,tagName)
        w.textBaseClass.SetStyle(w,i,j,style)
#@nonl
#@-node:ekr.20070228074312.47:tag_remove
#@+node:ekr.20070228074312.48:yview
def yview (self,*args):

    '''w.yview('moveto',y) or w.yview()'''

    return 0,0
#@nonl
#@-node:ekr.20070228074312.48:yview
#@-node:ekr.20070228074312.39:tags (to-do)
#@+node:ekr.20070228074312.49:xyToGui/PythonIndex
def xyToPythonIndex (self,x,y):
    return 0
#@-node:ekr.20070228074312.49:xyToGui/PythonIndex
#@-node:ekr.20070228074312.9:Wrapper methods (widget-independent)
#@-node:ekr.20070228074312:class baseTextWidget
#@+node:ekr.20070930202214:What I did
#@+node:ekr.20070930150331:Changes to support jython
@nocolor

- The following modules do not exist in Jython.  The imports must be protected in try/except blocks:

    filecmp
    gettext
    tabnanny

- Python does not support generators.  Several seldom-used iterators will be written to avoid the 'yield' statement.

- Added the jyLeo keyword argument to the run function in leo.py.

- g.cantImport now does not warn when the gui is not tkinter and the moduleName is either tkinter or Pmw.
  This suppresses unnecessary import warnings from several plugins.

- Hacked the navButtons plugin to suppress a weird call to onCreate when the gui is swing.  It is a mystery why this is being called.

- changed toUnicodeFileEncoding to test for 'java' platform.
#@nonl
#@-node:ekr.20070930150331:Changes to support jython
#@+node:ekr.20070930102228.1:Rewrote iterators that use yield
# They are not valid in jython.
# At present, Leo's core does not use them.
#@nonl
#@+node:ekr.20040312090934:c.iterators
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):

    c = self
    return self.allNodes_iter_class(c,copy)

all_positions_iter = allNodes_iter
#@nonl
#@+node:ekr.20060907085906.1:__init__ & __iter__ (c.all_positions_iter)
def __init__(self,c,copy):

    # g.trace('c.allNodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20060907085906.1:__init__ & __iter__ (c.all_positions_iter)
#@+node:ekr.20060907085906.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p

    else: raise StopIteration
#@-node:ekr.20060907085906.2:next
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@+node:EKR.20040529091232.1:c.all_tnodes_iter
# def all_tnodes_iter(self):

    # c = self
    # for p in c.all_positions_iter():
        # yield p.v.t

    # # return c.rootPosition().all_tnodes_iter(all=True)

class all_tnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_tnodes_iter (self):

    c = self
    return self.all_tnodes_iter_class(c)
#@+node:ekr.20070930185552:__init__ & __iter__ (c.all_tnodes_iter)
def __init__(self,c):

    # g.trace('c.all_tnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930185552:__init__ & __iter__ (c.all_tnodes_iter)
#@+node:ekr.20070930185603:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v.t

    else: raise StopIteration
#@-node:ekr.20070930185603:next
#@-node:EKR.20040529091232.1:c.all_tnodes_iter
#@+node:EKR.20040529091232.2:c.all_unique_tnodes_iter
# def all_unique_tnodes_iter(self):

    # c = self ; marks = {}

    # for p in c.all_positions_iter():
        # if not p.v.t in marks:
            # marks[p.v.t] = p.v.t
            # yield p.v.t

class all_unique_tnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_unique_tnodes_iter (self):

    c = self
    return self.all_unique_tnodes_iter_class(c)
#@+node:ekr.20070930190218:__init__ & __iter__ (c.all_unique_tnodes_iter)
def __init__(self,c):

    # g.trace('c.all_uniquetnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.d = {}
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930190218:__init__ & __iter__ (c.all_unique_tnodes_iter)
#@+node:ekr.20070930190229:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v.t

    else: raise StopIteration
#@-node:ekr.20070930190229:next
#@-node:EKR.20040529091232.2:c.all_unique_tnodes_iter
#@+node:EKR.20040529091232.3:c.all_vnodes_iter
# def all_vnodes_iter(self):

    # c = self
    # for p in c.all_positions_iter():
        # yield p.v

class all_vnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_vnodes_iter (self):

    c = self
    return self.all_vnodes_iter_class(c)
#@+node:ekr.20070930190711:__init__ & __iter__ (c.all_vnodes_iter)
def __init__(self,c):

    # g.trace('c.all_tnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930190711:__init__ & __iter__ (c.all_vnodes_iter)
#@+node:ekr.20070930190729:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v

    else: raise StopIteration
#@-node:ekr.20070930190729:next
#@-node:EKR.20040529091232.3:c.all_vnodes_iter
#@+node:EKR.20040529091232.4:c.all_unique_vnodes_iter
# def all_unique_vnodes_iter(self):

    # c = self ; marks = {}
    # for p in c.all_positions_iter():
        # if not p.v in marks:
            # marks[p.v] = p.v
            # yield p.v

class all_unique_vnodes_iter_class:

    """Returns a list of all tnodes in the entire outline."""

    @others

def all_unique_vnodes_iter (self):

    c = self
    return self.all_unique_vnodes_iter_class(c)
#@+node:ekr.20070930190755:__init__ & __iter__ (c.all_unique_nodes_iter)
def __init__(self,c):

    # g.trace('c.all_uniquetnodes_iter.__init','p',p,'c',c)

    self.c = c
    self.d = {}
    self.first = c.rootPosition()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930190755:__init__ & __iter__ (c.all_unique_nodes_iter)
#@+node:ekr.20070930190835:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v

    else: raise StopIteration
#@-node:ekr.20070930190835:next
#@-node:EKR.20040529091232.4:c.all_unique_vnodes_iter
#@+node:ekr.20070627082044.866:@test c iters
if g.unitTesting:
    << coverage tests >>
    << duplicate tests >>

    if 0:
        print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
        print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

    if 0: # all nodes
        for v in c.all_vnodes_iter(): print v
        for t in c.all_tnodes_iter(): print t

    if 0: # unique nodes
        for v in c.all_unique_vnodes_iter(): print v
        for t in c.all_unique_tnodes_iter(): print t
#@+node:ekr.20070627082044.867:<< coverage tests >>
v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"
#@nonl
#@-node:ekr.20070627082044.867:<< coverage tests >>
#@+node:ekr.20070627082044.868:<< duplicate tests >>
nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)

nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)

# print "duplicate tests pass"
#@nonl
#@-node:ekr.20070627082044.868:<< duplicate tests >>
#@-node:ekr.20070627082044.866:@test c iters
#@-node:ekr.20040312090934:c.iterators
#@+node:ekr.20040305162628.1:p.Iterators
@ A crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@+node:EKR.20040529103843:p.tnodes_iter
# def tnodes_iter(self):

    # """Return all tnode's in a positions subtree."""

    # p = self
    # for p in p.self_and_subtree_iter():
        # yield p.v.t

class tnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def tnodes_iter (self):

    p = self
    return self.tnodes_iter_class(p)
#@+node:ekr.20070930191649.1:__init__ & __iter__ (p.tnodes_iter)
def __init__(self,p):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930191649.1:__init__ & __iter__ (p.tnodes_iter)
#@+node:ekr.20070930191649.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v.t

    else: raise StopIteration
#@-node:ekr.20070930191649.2:next
#@-node:EKR.20040529103843:p.tnodes_iter
#@+node:ekr.20070930191632:p.unique_tnodes_iter
# def unique_tnodes_iter(self):

    # """Return all unique tnode's in a positions subtree."""

    # p = self
    # marks = {}
    # for p in p.self_and_subtree_iter():
        # if p.v.t not in marks:
            # marks[p.v.t] = p.v.t
            # yield p.v.t

class unique_tnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_tnodes_iter (self):

    p = self
    return self.unique_tnodes_iter_class(p)
#@+node:ekr.20070930192032.1:__init__ & __iter__ (p.unique_tnodes_iter)
def __init__(self,p):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930192032.1:__init__ & __iter__ (p.unique_tnodes_iter)
#@+node:ekr.20070930192032.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v.t

    else: raise StopIteration
#@-node:ekr.20070930192032.2:next
#@-node:ekr.20070930191632:p.unique_tnodes_iter
#@+node:EKR.20040529103945:p.vnodes_iter
# def vnodes_iter(self):

    # """Return all vnode's in a positions subtree."""

    # p = self
    # for p in p.self_and_subtree_iter():
        # yield p.v

class vnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def vnodes_iter (self):

    p = self
    return self.vnodes_iter_class(p)


#@+node:ekr.20070930192339.1:__init__ & __iter__ (p.tnodes_iter)
def __init__(self,p):

    # g.trace('p.tnodes_iter.__init','p',p)

    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930192339.1:__init__ & __iter__ (p.tnodes_iter)
#@+node:ekr.20070930192339.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None
    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        return self.p.v

    else: raise StopIteration
#@-node:ekr.20070930192339.2:next
#@-node:EKR.20040529103945:p.vnodes_iter
#@+node:ekr.20070930191632.1:p.unique_vnodes_iter
# def unique_vnodes_iter(self):

    # """Return all unique vnode's in a positions subtree."""

    # p = self
    # marks = {}
    # for p in p.self_and_subtree_iter():
        # if p.v not in marks:
            # marks[p.v] = p.v
            # yield p.v

class unique_vnodes_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def unique_vnodes_iter (self):

    p = self
    return self.unique_vnodes_iter_class(p)
#@+node:ekr.20070930192441.1:__init__ & __iter__ (p.unique_vnodes_iter)
def __init__(self,p):

    # g.trace('p.unique_tnodes_iter.__init','p',p,)

    self.d = {}
    self.first = p.copy()
    self.p = None

def __iter__(self):

    return self
#@-node:ekr.20070930192441.1:__init__ & __iter__ (p.unique_vnodes_iter)
#@+node:ekr.20070930192441.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    while self.p:
        self.p.moveToThreadNext()
        if not self.p:
            break
        elif not self.d.get(self.p.v.t):
            self.d [self.p.v.t] = True
            return self.p.v

    else: raise StopIteration
#@-node:ekr.20070930192441.2:next
#@-node:ekr.20070930191632.1:p.unique_vnodes_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=False)

def self_and_subtree_iter (self,copy=False):

    return self.subtree_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):

    return self.children_iter_class(self,copy)
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)

def self_and_parents_iter(self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=True)
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):

    return self.siblings_iter_class(self,copy,following)

self_and_siblings_iter = siblings_iter

def following_siblings_iter (self,copy=False):

    return self.siblings_iter_class(self,copy,following=True)
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):

    # We always include p, even if following is True.

    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):

    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20070930194035:Not converted yet
#@+node:ekr.20050920084036.184:iterateKillBuffer
class killBuffer_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def iterateKillBuffer (self):

    return self.killBuffer_iter_class(self.c)
#@+node:ekr.20071003160252.1:__init__ & __iter__
def __init__(self,c):

    # g.trace('iterateKillBuffer.__init')
    self.c = c
    self.index = 0 # The index of the next item to be returned.

def __iter__(self):

    return self
#@-node:ekr.20071003160252.1:__init__ & __iter__
#@+node:ekr.20071003160252.2:next
def next(self):

    commands = self.c.killBufferCommands
    aList = commands.killBuffer

    # g.trace(g.listToString([repr(z) for z in aList]))

    if not aList:
        self.index = 0
        return None

    if commands.reset is None:
        i = self.index
    else:
        i = commands.reset
        commands.reset = None

    if i < 0 or i >= len(aList): i = 0
    # g.trace(i)
    val = aList[i]
    self.index = i + 1
    return val
#@-node:ekr.20071003160252.2:next
#@-node:ekr.20050920084036.184:iterateKillBuffer
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
# @ This is a generator (it contains a yield).
# To make this work we must define a new generator for each call to regionalExpandAbbrev.
# @c
# def searchXR (i1,i2,ins,event):
    # k = self.k
    # w = self.editWidget(event)
    # if not w: return

    # w.tag_add('sXR',i1,i2)
    # while i1:
        # tr = w.tag_ranges('sXR')
        # if not tr: break
        # i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        # if i1:
            # word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_delete('found')
            # w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_config('found',background='yellow')
            # if self.abbrevs.has_key(word):
                # k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                # yield None
                # if k.regXKey == 'y':
                    # ind = w.index('%s wordstart' % i1)
                    # w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    # w.insert(ind,self.abbrevs[word])
            # i1 = '%s wordend' % i1
    # w.setInsertPoint(ins,ins,insert=ins)
    # w.tag_delete('sXR')
    # w.tag_delete('found')
    # k.setLabelGrey('')
    # self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
#@+node:ekr.20050920085536.84:class Tracker (an iterator)
class Tracker:

    '''An iterator class to allow the user to cycle through and change a list.'''

    @others
#@+node:ekr.20050920085536.85:init
def __init__ (self):

    self.tablist = []
    self.prefix = None 
    self.ng = self._next()
#@-node:ekr.20050920085536.85:init
#@+node:ekr.20050920085536.86:setTabList
def setTabList (self,prefix,tlist):

    self.prefix = prefix 
    self.tablist = tlist
#@-node:ekr.20050920085536.86:setTabList
#@+node:ekr.20050920085536.87:_next
# def _next (self):

    # while 1:
        # tlist = self.tablist 
        # if not tlist:yield ''
        # for z in self.tablist:
            # if tlist!=self.tablist:
                # break 
            # yield z
#@-node:ekr.20050920085536.87:_next
#@+node:ekr.20050920085536.88:next
def next (self):

    return self.ng.next()
#@-node:ekr.20050920085536.88:next
#@+node:ekr.20050920085536.89:clear
def clear (self):

    self.tablist = []
    self.prefix = None
#@-node:ekr.20050920085536.89:clear
#@-node:ekr.20050920085536.84:class Tracker (an iterator)
#@-node:ekr.20070930194035:Not converted yet
#@-node:ekr.20070930102228.1:Rewrote iterators that use yield
#@+node:ekr.20031218072017.2160:toUnicodeFileEncoding
def toUnicodeFileEncoding(path,encoding):

    if path: path = path.replace('\\', os.sep)

    if not encoding:
        if sys.platform == "win32" or sys.platform.lower().startswith('java'):
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
#@-node:ekr.20031218072017.2160:toUnicodeFileEncoding
#@-node:ekr.20070930202214:What I did
#@+node:ekr.20070930204122:Notes
import swing.border as sborder
#@nonl
#@-node:ekr.20070930204122:Notes
#@+node:ekr.20070930205659:debugging
#@+node:ekr.20031218072017.3108:Dumps
#@+node:ekr.20031218072017.3109:dump
def dump(s):

    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out

def oldDump(s):

    out = ""
    for i in s:
        if i=='\n':
            out += "[" ; out += "n" ; out += "]"
        if i=='\t':
            out += "[" ; out += "t" ; out += "]"
        elif i==' ':
            out += "[" ; out += " " ; out += "]"
        else: out += i
    return out
#@-node:ekr.20031218072017.3109:dump
#@+node:ekr.20060917120951:es_dump
def es_dump (s,n = 30,title=None):

    if title:
        g.es_print(title)

    i = 0
    while i < len(s):
        g.es_print(''.join(['%2x ' % (ord(ch)) for ch in s[i:i+n]]))
        i += n
#@nonl
#@-node:ekr.20060917120951:es_dump
#@+node:ekr.20031218072017.3110:es_error
def es_error (s,color=None):

    if color is None and g.app.config: # May not exist during initialization.
        color = g.app.config.getColor(None,"log_error_color")

    g.es(s,color=color)
#@-node:ekr.20031218072017.3110:es_error
#@+node:ekr.20031218072017.3111:es_event_exception
def es_event_exception (eventName,full=False):

    g.es("exception handling ", eventName, " event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es(i)

    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()
#@-node:ekr.20031218072017.3111:es_event_exception
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):

    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)

    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            try:
                print line
            except Exception:
                print g.toEncodedString(s,'ascii')

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@+node:ekr.20050220030850:@test g.es_exception
if g.unitTesting:

    c,p = g.getTestVars() # Optional: prevents pychecker warnings.

    if c.config.redirect_execute_script_output_to_log_pane:
        pass # Test doesn't work when redirection is on.
    else:
        try:
            import sys
            # Catch the output of g.es_exception.
            # We catch the AssertionError, so nothing gets written to stderr.
            sys.stdout = fo = g.fileLikeObject()
            try: # Create an exception to catch.
                assert False, 'Assert False in test_g_es_exception'
            except AssertionError:
                g.es_exception(color='suppress')
                result = fo.get()
                s1 = 'Traceback (most recent call last):'
                s2 = 'AssertionError: Assert False in test_g_es_exception'
                assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
                assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
        finally:
            # Not needed unless we execute this script as selected text.
            sys.stdout = sys.__stdout__
#@-node:ekr.20050220030850:@test g.es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@+node:ekr.20061015090538:es_exception_type
def es_exception_type (c=None,color="red"):

    # exctype is a Exception class object; value is the error message.
    exctype, value = sys.exc_info()[:2]

    g.es_print('%s, %s' % (exctype.__name__, value),color=color)
#@-node:ekr.20061015090538:es_exception_type
#@+node:ekr.20040731204831:getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():

    typ,val,tb = sys.exc_info()

    if typ in (exceptions.SyntaxError,exceptions.IndentationError):
        # Syntax and indentation errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            # g.es_print(repr(val))
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        if data:
            # g.es_print(repr(data))
            item = data[-1]
            filename = item[0]
            n = item[1]
            return filename,n
        else:
            return None,0
#@-node:ekr.20040731204831:getLastTracebackFileAndLineNumber
#@+node:ekr.20031218072017.3113:printBindings
def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b
#@-node:ekr.20031218072017.3113:printBindings
#@+node:ekr.20031218072017.3114:printGlobals
def printGlobals(message=None):

    # Get the list of globals.
    globs = list(globals())
    globs.sort()

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    for glob in globs:
        print glob
#@-node:ekr.20031218072017.3114:printGlobals
#@+node:ekr.20070510074941:g.printEntireTree
def printEntireTree(c,tag=''):

    print 'printEntireTree','=' * 50
    print 'printEntireTree',tag,'root',c.rootPosition()
    for p in c.allNodes_iter():
        print '..'*p.level(),p.v
#@nonl
#@-node:ekr.20070510074941:g.printEntireTree
#@+node:ekr.20031218072017.3115:printLeoModules
def printLeoModules(message=None):

    # Create the list.
    mods = []
    for name in sys.modules.keys():
        if name and name[0:3] == "leo":
            mods.append(name)

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    mods.sort()
    for m in mods:
        print m,
    print
#@-node:ekr.20031218072017.3115:printLeoModules
#@-node:ekr.20031218072017.3108:Dumps
#@+node:ekr.20051023083258:callers & _callerName
def callers (n=8,excludeCaller=True,files=False):

    '''Return a list containing the callers of the function that called g.callerList.

    If the excludeCaller keyword is True (the default), g.callers is not on the list.

    If the files keyword argument is True, filenames are included in the list.
    '''

    # sys._getframe throws ValueError in both cpython and jython if there are less than i entries.
    # The jython stack often has less than 8 entries,
    # so we must be careful to call g._callerName with smaller values of i first.
    result = []
    i = g.choose(excludeCaller,3,2)
    while 1:
        s = g._callerName(i,files=files)
        if s:
            result.append(s)
        if not s or len(result) >= n: break
        i += 1

    result.reverse()
    sep = g.choose(files,'\n',',')
    return sep.join(result)
#@+node:ekr.20031218072017.3107:_callerName
def _callerName (n=1,files=False):

    try: # get the function name from the call stack.
        f1 = sys._getframe(n) # The stack frame, n levels up.
        code1 = f1.f_code # The code object
        if files:
            return '%s:%s' % (g.shortFilename(code1.co_filename),code1.co_name)
        else:
            return code1.co_name # The code name
    except ValueError:
        return '' # The stack is not deep enough.
    except:
        g.es_exception()
        return '' # "<no caller name>"
#@-node:ekr.20031218072017.3107:_callerName
#@-node:ekr.20051023083258:callers & _callerName
#@-node:ekr.20070930205659:debugging
#@+node:ekr.20070930202214.1:startup code
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
if jyLeo:

    print '*** starting jyLeo',sys.platform # will be something like java1.6.0_02

    ### This is a hack.
    ### The jyleo script in test.leo sets the cwd to g.app.loadDir
    ### Eventually, we will have to compute the equivalent here.

    path = os.path.join(os.getcwd()) ### ,'..','src')
    if path not in sys.path:
        print 'appending %s to sys.path' % path
        sys.path.append(path)
    if 0:
        print 'sys.path...'
        for s in sys.path: print s

# Import leoGlobals, but do NOT set g.
import leoGlobals
import leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20070930194949:startJyleo (leo.py)
def startJyleo (g):

    import leoSwingFrame
    import leoSwingUtils
    import java.awt as awt

    if 1:
        g.app.splash = None
    else:
        g.app.splash = splash = leoSwingFrame.leoSplash()
        awt.EventQueue.invokeAndWait(splash)

    gct = leoSwingUtils.GCEveryOneMinute()
    gct.start()

    tk = awt.Toolkit.getDefaultToolkit()
    tk.setDynamicLayout(True)
#@-node:ekr.20070930194949:startJyleo (leo.py)
#@+node:ekr.20070930184746.8:class leoSplash (java.lang.Runnable)
class leoSplash ( java.lang.Runnable ):

    @others
#@+node:ekr.20070930185331:run (leoSplash)
def run (self):

    g.trace(g.callers())

    self.splash = splash = swing.JWindow()
    splash.setAlwaysOnTop(1)
    cpane = splash.getContentPane()
    rp = splash.getRootPane()
    tb = swing.border.TitledBorder('Leo')
    tb.setTitleJustification(tb.CENTER)
    rp.setBorder(tb)
    splash.setBackground(awt.Color.ORANGE)
    dimension = awt.Dimension(400,400)
    splash.setPreferredSize(dimension)
    splash.setSize(400,400)

    sicon = g.os_path_join(g.app.loadDir,"..","Icons","Leosplash.GIF")
    ii = swing.ImageIcon(sicon)
    image = swing.JLabel(ii)
    image.setBackground(awt.Color.ORANGE)
    cpane.add(image)
    self.splashlabel = splashlabel = swing.JLabel("Leo is starting....")
    splashlabel.setBackground(awt.Color.ORANGE)
    splashlabel.setForeground(awt.Color.BLUE)
    cpane.add(splashlabel,awt.BorderLayout.SOUTH)
    w, h = self._calculateCenteredPosition(splash)
    splash.setLocation(w,h)
    splash.visible = True
#@-node:ekr.20070930185331:run (leoSplash)
#@+node:ekr.20070930185331.1:utils
def _calculateCenteredPosition( self, widget ):

    size = widget.getPreferredSize()
    height = size.height/2
    width = size.width/2
    h,w = self._getScreenPositionForDialog()
    height = h - height
    width = w - width
    return width, height

def _getScreenPositionForDialog( self ):

    tk = awt.Toolkit.getDefaultToolkit()
    dim = tk.getScreenSize()
    h = dim.height/2
    w = dim.width/2
    return h, w   

def setText( self, text ):  
    self.splashlabel.setText( text )

def hide( self ):
    self.splash.visible = 0

def toBack( self ):
    if self.splash.visible:
        self.splash.toBack()

def toFront( self ):
    if self.splash.visible:
        self.splash.setAlwaysOnTop( 1 )
        self.splash.toFront()

def isVisible( self ):
    return self.splash.visible
#@-node:ekr.20070930185331.1:utils
#@-node:ekr.20070930184746.8:class leoSplash (java.lang.Runnable)
#@-node:ekr.20070930202214.1:startup code
#@-node:ekr.20070930102228:( jyLeo )
#@+node:ekr.20070703172548:Leo 4.4.4 projects
#@+node:ekr.20070915101503:4.4.4 b2
#@+node:ekr.20070703182412:Bugs
#@+node:ekr.20070725155607:removed leoKeywords from colorizer
# This was a fairly big bit of cruft.
#@nonl
#@-node:ekr.20070725155607:removed leoKeywords from colorizer
#@+node:ekr.20070724072345:Fixed UNL bug1
@nocolor

Email from Terry Brown

A softish bug, but the use of findNodeInTree() in the UNL code can 
take you to the wrong place if more than one node in the tree has 
the same headString.  Patch below - can still go wrong if more than 
one sibling has the same name, but the UNL system doesn't have a 
solution for that.

An observation - the UNL jumping code will drop you as far down the 
path as it gets, i.e. you're moved to the last node that was one the 
path, even if the path ends before the last part of the UNL is 
reached.  This is ok, i.e. "this is as far as I could follow the 
UNL", the alternative would be to not move at all if the whole UNL 
can't be followed.

Cheers -Terry

anon_cvs> cvs diff leo/plugins/UNL.py
Index: leo/plugins/UNL.py
===================================================================
RCS file: /cvs/leo/plugins/UNL.py,v
retrieving revision 1.14
diff -r1.14 UNL.py
183c183,186
<                             p = g.findNodeInTree(c2,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break
206c209,212
<                             p = g.findNodeInTree(c,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break


@color
#@nonl
#@+node:ekr.20040321065415:g.findNode... &,findTopLevelNode
def findNodeInChildren(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.children_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):

    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findTopLevelNode(c,headline):

    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20040321065415:g.findNode... &,findTopLevelNode
#@-node:ekr.20070724072345:Fixed UNL bug1
#@+node:ekr.20070803081457:Fixed how @auto handles paths
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4444579
By: terry_n_brown

Sure it's what I'd expect, but I don't think it's what it does?

in the directory 'misc_py', where del.leo and addWhitelist.py live:

  python /path/to/leo/src/leo.py del.leo

works, and indeed addWhitelist.py is now correctly imported
in the node '@auto addWhitelist.py' (very cool :-)

but if I cd .. and

  python /path/to/leo/src/leo.py misc_py/del.leo

I get

reading: /media/hda7/misc_py/del.leo
can not open addWhitelist.py

and an empty node '@auto addWhitelist.py'

Makes me think it's trying to load addWhitelist.py relative to the dir from
which leo was run, not the dir of the .leo file.

@color
#@nonl
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@-node:ekr.20070803081457:Fixed how @auto handles paths
#@+node:ekr.20070803112638:Fixed another path bug
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4445685
By: ktenney

/dir/sub/main
contains interfaces.py and configure.zcml

the @path directive works for interfaces.py

z3
@path /dir/sub/main
..@auto interfaces.py

but I find I need a node named
@auto /dir/sub/main/configure.zcml
to get that file

@color
#@nonl
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@-node:ekr.20070803112638:Fixed another path bug
#@+node:ekr.20070804070844:fixed c parser so it handles non-ascii declaratsions
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4446937
By: btheado

> Two hacks (now on cvs) were surprisingly effective..

Thanks for the fixes.  I just tried some more code (Tcl C source again--I just
happen to have it handy on my hard drive).  It looks like the import parser
skips over ANSI style function definitions (didn't know anyone still used those).
Here are some examples files:

http://tcl.cvs.sourceforge.net/tcl/tcl/generic/tclScan.c?revision=1.12.2.2&view=
markup&pathrev=core-8-4-14

and

http://tcl.cvs.sourceforge.net/tcl/tcl/generic/tclObj.c?revision=1.42.2.14&view=
markup&pathrev=core-8-4-14

I checked the old importer and it handles the ANSI style just fine.

Brian
#@nonl
#@-node:ekr.20070804070844:fixed c parser so it handles non-ascii declaratsions
#@+node:ekr.20070808090641:Fixed colorizing bug and moved calls to w.toGuiIndex out of some loops
# The code that was removing tags was not working properly.
#@nonl
#@-node:ekr.20070808090641:Fixed colorizing bug and moved calls to w.toGuiIndex out of some loops
#@+node:ekr.20070803081137.1:Fixed unicode bug in http plugin
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4437415

Unicode characters were not handled properly.
#@-node:ekr.20070803081137.1:Fixed unicode bug in http plugin
#@+node:ekr.20070814083649:Fixed new @path problem
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4462693

@color
#@nonl
#@+node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
# This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if c:
        if not c.config.create_nonexistent_directories:
            return None
    elif not app.config.create_nonexistent_directories:
        return None

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) > 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                g.es("created directory: "+path)
            except:
                g.es("exception creating directory: "+path)
                g.es_exception()
                return None
    return dir1 # All have been created.
#@-node:ekr.20031218072017.3119:g.makeAllNonExistentDirectories
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

# g.trace('at.default_directory',at.default_directory)
# g.trace('theDir',theDir)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):

    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0 and not at.thinFile:
        << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            c.setBodyString(p,s) # Sets c and p dirty.

        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():

    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):

    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """

    __pychecker__ = '--maxlines=400'
    # g.stat()

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = s[j:i].strip()

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') or
    (path[0]=="'" and path[-1] == "'")
):
    path = path[1:-1].strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):

    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):

    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):

    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):

    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@-node:ekr.20070814083649:Fixed new @path problem
#@+node:ekr.20070814143748.1:Fixed @auto path bug
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4464980
By: terry_n_brown

When I delete the @ignore in my evil example above, when I try and write the
@auto I get the traceback below.  Perhaps just a msg. saying "Unwritable @auto
node, try re-importing, or save and load" or something?

exception writing derived files
Traceback (most recent call last):
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoF
ileCommands.py", line 3060, in write_Leo_file
    c.atFileCommands.writeAll()
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoA
tFile.py", line 2919, in writeAll
    at.writeOneAtAutoNode(p,toString=toString)
  File "/media/hda8/home/tbrown/.gnome-desktop/Package/leo/anon_cvs/leo/src/leoA
tFile.py", line 3005, in writeOneAtAutoNode
    fileName = g.os_path_join(at.default_directory,fileName)
AttributeError: atFile instance has no attribute 'default_directory'

@color
#@nonl
#@+node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20070806140208:writeAtAutoNodesHelper
def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString,force=True)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
#@-node:ekr.20070806140208:writeAtAutoNodesHelper
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@-node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
#@-node:ekr.20070814143748.1:Fixed @auto path bug
#@+node:ekr.20070815100946:Improved messages on @import failure
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4465132
By: terry_n_brown

So I changed all my indentation to multiples of four, having decided I like
the extra line space this buys over aligning with the opening (.

leo said this when it read the file:

@auto did not import the file perfectly

but never mentioned @ignore or anything.  I made a trivial change and saved
and diff could find no difference except my trivial change... which seems perfect
to me...?

@color
#@nonl
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@-node:ekr.20070815100946:Improved messages on @import failure
#@+node:ekr.20070824094935:Fixed problem with space in path names in runLeoDynamicTest
# https://sourceforge.net/forum/message.php?msg_id=4459798
#@nonl
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    if ' ' in path and sys.platform.startswith('win'): 
        path = '"' + path + '"'

    args = [sys.executable, path, '--silent']  

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@-node:ekr.20070824094935:Fixed problem with space in path names in runLeoDynamicTest
#@+node:ekr.20070910102447:Fixed bad drag & drop bug
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4509897
By: plumloco

If you drag a parent node onto one of its children then leo crashes.

@color
#@nonl
#@+node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        << set vdrag, childFlag >>
        if self.allow_clone_drags:
            if not self.look_for_control_drag_on_mouse_down:
                self.controlDrag = c.frame.controlKeyIsDown

        redrawFlag = vdrag and vdrag.v.t != p.v.t
        if redrawFlag: # Disallow drag to joined node.
            << drag p to vdrag >>
        elif self.trace and self.verbose:
            g.trace("Cancel drag")

        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate(redrawFlag)
        c.recolor_now() # Dragging can affect coloring.
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):

    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.2353:c.dragAfter
def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,after): return
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2353:c.dragAfter
#@+node:ekr.20031218072017.2947:c.dragToNthChildOf
def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkDrag(p,parent): return
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2947:c.dragToNthChildOf
#@+node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()

    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone & dependents, does not set undo.
        if (
            not c.checkDrag(p,parent) or
            not c.checkMoveWithParentWithWarning(clone,parent,True)
        ):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
#@+node:ekr.20031218072017.2948:c.dragCloneAfter
def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkDrag(p,after) and c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2948:c.dragCloneAfter
#@-node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning & c.checkDrag
#@+node:ekr.20070910105044:checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
#@-node:ekr.20070910105044:checkMoveWithParentWithWarning
#@+node:ekr.20070910105044.1:checkDrag
def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    message = "Can not drag a node into its descendant tree."

    # g.trace('root',root.headString(),'target',target.headString())

    for z in root.subtree_iter():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                g.alert(message)
            return False
    return True
#@nonl
#@-node:ekr.20070910105044.1:checkDrag
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning & c.checkDrag
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        moved = False
        << Move p up >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)

    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeFocusHelper()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        # g.trace('move to root')
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@-node:ekr.20070910102447:Fixed bad drag & drop bug
#@+node:ekr.20070912052929:Fixed bug 'node note selected' bug
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4514130
By: plumloco

Some commands (such as expand-all) leave no nodes selected. The result of this
is that if you click on the body pane without first having selected a node,
an error dialog pops up.


AttributeError Exception in Tk callback
  Function: <function bodyClickCallback at 0x01981A70> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x02505580>,)
  Event type: ButtonPress (type num: 4)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 80, in bodyClickCallback
    return handler(event,func)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 3187, in masterClickHandler
    c.frame.body.onClick(event) # New in Leo 4.4.2.
  File "C:\prog\tigris-cvs\leo\src\leoFrame.py", line 1297, in onClick
    c.editCommands.setMoveCol(w,i)
  File "C:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 3539, in setMoveCol
    self.moveSpotNode = p.v.t
AttributeError: 'NoneType' object has no attribute 't'

================================================
  Event contents:
    char: ??
    delta: 0
    height: ??
    keycode: ??
    keysym: ??
    keysym_num: ??
    num: 1
    send_event: False
    serial: 1525
    state: 0
    time: 4692125
    type: 4
    widget: .26496576.26526264.26526584.26526664.26719976.26720296.body-pane
    width: ??
    x: 438
    x_root: 744
    y: 87
    y_root: 651



@color
#@nonl
#@+node:ekr.20031218072017.2903:expandAllHeadlines
def expandAllHeadlines (self,event=None):

    '''Expand all headlines.
    Warning: this can take a long time for large outlines.'''

    c = self

    c.beginUpdate()
    try:
        p = c.rootPosition()
        while p:
            c.expandSubtree(p)
            p.moveToNext()
        c.selectVnode(c.rootPosition())
    finally:
        c.endUpdate()
        c.treeFocusHelper()

    c.expansionLevel = 0 # Reset expansion level.
#@-node:ekr.20031218072017.2903:expandAllHeadlines
#@+node:ekr.20060209095101:setMoveCol & test
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@+node:ekr.20070627082044.276:@test setMoveCol
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        ec = c.editCommands

        for spot,result in (('1.0',0),(5,5)):
            ec.setMoveCol(w,spot)
            assert ec.moveSpot == result
            assert ec.moveCol == result
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.276:@test setMoveCol
#@-node:ekr.20060209095101:setMoveCol & test
#@+node:ekr.20061109095450.8:onClick
def onClick (self,event):

    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)

    if not c.currentPosition(): return

    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
#@+node:ekr.20070627082044.857:@test onClick
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        y = 10
        for x in xrange(0,100,10):
            event = g.Bunch(c=c,x=x,y=y,widget=w)
            c.frame.body.onClick(event)
    finally:
        c.endUpdate(False)
#@nonl
#@-node:ekr.20070627082044.857:@test onClick
#@-node:ekr.20061109095450.8:onClick
#@-node:ekr.20070912052929:Fixed bug 'node note selected' bug
#@+node:ekr.20070913085051:Fixed recent crasher involving pr and es_print
#@+node:ekr.20050707064040:es_print
def es_print(s,*args,**keys):

    if keys.get('newline') in (True,None):
        print g.toEncodedString(s,'ascii')
    else:
        print g.toEncodedString(s,'ascii'),

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
#@+node:ekr.20070621092938:@@test g.es_print
if g.unitTesting:
    g.es_print('\ntest of es_print: ',color='red',newline=False)
    g.es_print('after')
    g.es_print('done')
#@-node:ekr.20070621092938:@@test g.es_print
#@-node:ekr.20050707064040:es_print
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:@test pr
if False or g.unitTesting:
    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:@test pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070913085051:Fixed recent crasher involving pr and es_print
#@+node:ekr.20070816084029:Retain dirty bit after write @auto fails
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4468174
By: rich_ries

>> I find that if I change an @auto node and the save of the @auto file fails
because it's locked by another app and I stop the other app, releasing the lock
then I save the file again::

>> The .leo file is saved, but not the @auto file.

This is not only in @auto, but in "regular" Leo, also.

@color
#@nonl
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@-node:ekr.20070816084029:Retain dirty bit after write @auto fails
#@-node:ekr.20070703182412:Bugs
#@+node:ekr.20070703182412.1:Features
#@+node:ekr.20070703172130:Added support for @mark-for-unit-tests node
# The run-unit-tests command now includes **all** @mark-for-unit-test trees.
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
    c2.beginUpdate()
    try:
        self.copyRoot.expand()
        for p,limit,lookForMark,lookForNodes in (
            (p1,limit1,lookForMark1,lookForNodes1),
            (p2,limit2,lookForMark2,lookForNodes2),
        ):
            while p and p != limit:
                h = p.headString()
                if p.v.t in self.seen:
                    p.moveToNodeAfterTree()
                elif lookForMark and h.startswith(markTag):
                    self.addMarkTree(p)
                    p.moveToNodeAfterTree()
                elif lookForNodes and self.isUnitTestNode(p):
                    self.addNode(p)
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@nonl
#@+node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.currentPosition()
    if p.headString().startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@nonl
#@-node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
#@+node:ekr.20070705080413:addMarkTree
def addMarkTree (self,p):

    # g.trace(len(self.seen),p.headString())

    self.seen.append(p.v.t)

    for p in p.subtree_iter():
        if self.isUnitTestNode(p) and not p.v.t in self.seen:
            self.addNode(p)
#@-node:ekr.20070705080413:addMarkTree
#@+node:ekr.20070705065154.1:addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-test tree as the last child of self.copyRoot.
    '''

    # g.trace(len(self.seen),p.headString())

    p2 = p.copyTreeAfter()
    p2.unlink()
    p2.moveToLastChildOf(self.copyRoot)

    self.seen.append(p.v.t)
#@-node:ekr.20070705065154.1:addNode
#@+node:ekr.20070705075604.3:isUnitTestNode
def isUnitTestNode (self,p):

    h = p.headString()
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@-node:ekr.20070705075604.3:isUnitTestNode
#@-node:ekr.20070627135336.9:createOutline & helpers
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    if ' ' in path and sys.platform.startswith('win'): 
        path = '"' + path + '"'

    args = [sys.executable, path, '--silent']  

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = c.currentPosition()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.allNodes_iter():
        if p.headString().startswith('@mark-for-unit-test'):
            return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20070703172130:Added support for @mark-for-unit-tests node
#@+node:ekr.20070725165751:Created threading_colorizer
@nocolor

> Can anyone point me to a discussion of what is, and is not, guanteed about how
Python schedules threads? In particular, I want the colorizing thread to
relinquish control to the gui thread quite often (for good response), but I
don't want the relinquishing itself to slow down the colorizer much. It seems a
hard problem.

From what I understand, there are perhaps only a few "guarantees" with Python
threads. One guarantee is that when Python source is executing, threads will
swap after sys.getcheckinterval() bytecodes have been processed for that thread.
You can set the delay with sys.setcheckinterval(count). It seems to be 100
bytecodes in Python 2.3-2.5, but I could have sworn it was 1000. In any case,
setting the check interval higher will result in higher speed, but lower
responsiveness.

When making certain C-level calls, Python will also allow the "active" Python
thread to switch. Which really means that the only way you can use those all of
those 4-core processors with Python in a single process is to do all of your
work in C code with carefully crafted GIL acquire and release calls.

If your code is crafted in such a way that there are "convenient" places to
yield control, you can use a technique known as 'cooperative multithreading with
generators'. It gives you the total speed, more or less, of a single thread, but
*you* choose where the context switches occur, for the cost of a bit of extra
complication.
#@nonl
#@-node:ekr.20070725165751:Created threading_colorizer
#@+node:ekr.20070731070208:Added @auto

#@+node:ekr.20070806105721:read/write-at-auto-nodes commands
#@+node:ekr.20070806144024.1:Reading...
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = root = parent.copy()
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@+node:ekr.20071023082323:@test run
if g.unitTesting:

    ic = c.importCommands
    ic.methodName = 'test' ; ic.fileType = '.py'

    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()
    parent = p.copy()

    s = '''\
def spam():
    pass
'''
    s = g.adjustTripleString(s,-4)

    runner.run(s,parent)
#@-node:ekr.20071023082323:@test run
#@-node:ekr.20070707072749:run (baseScannerClass)
#@+node:ekr.20070806105721.1:readAtAutoNodes (commands)
def readAtAutoNodes (self,event=None):

    '''Read all @auto nodes in the presently selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()

    c.beginUpdate()
    try:
        undoData = u.beforeChangeTree(p)
        c.importCommands.readAtAutoNodes()
        u.afterChangeTree(p,'Read @auto Nodes',undoData)
    finally:
        c.endUpdate()
#@-node:ekr.20070806105721.1:readAtAutoNodes (commands)
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.currentPosition() ; after = p.nodeAfterTree()

    c.beginUpdate()
    try:
        found = False
        while p and p != after:
            if p.isAtAutoNode():
                if p.isAtIgnoreNode():
                    g.es_print('ignoring %s' % (p.headString()),color='blue')
                    p.moveToThreadNext()
                else:
                    self.readOneAtAutoNode(p)
                    found = True
                    p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        g.es(g.choose(found,'finished','no @auto nodes in the selected tree'),color='blue')
    finally:
        c.endUpdate()

#@+node:ekr.20070807084545:readOneAtAutoNode
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@-node:ekr.20070806144024.1:Reading...
#@+node:ekr.20070806144024.2:Writing...
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self ; c = at.c
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName)

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
#@+node:ekr.20041005105605.143:openFileForWritingHelper
def openFileForWritingHelper (self,fileName):

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
#@-node:ekr.20041005105605.143:openFileForWritingHelper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t)
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False,write_strips_blank_lines=None):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString,
        write_strips_blank_lines=write_strips_blank_lines)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@-node:ekr.20041005105605.157:writeOpenFile
#@+node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20070806140208:writeAtAutoNodesHelper
def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString,force=True)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
#@-node:ekr.20070806140208:writeAtAutoNodesHelper
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@-node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
#@-node:ekr.20070806144024.2:Writing...
#@-node:ekr.20070806105721:read/write-at-auto-nodes commands
#@+node:ekr.20070713082220:scannerUnitTest
def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.headString() ; old_root = p.copy()
    oldChanged = c.changed
    c.beginUpdate()
    try:
        d = g.app.unitTestDict
        expectedErrors = d.get('expectedErrors')
        expectedErrorMessage = d.get('expectedErrorMessage')
        expectedMismatchLine = d.get('expectedMismatchLine')
        g.app.unitTestDict = {
            'expectedErrors':expectedErrors,
            'expectedErrorMessage':expectedErrorMessage,
            'expectedMismatchLine':expectedMismatchLine,
        }
        if not fileName: fileName = p.headString()
        if not s: s = self.removeSentinelsCommand([fileName],toString=True)
        title = g.choose(h.startswith('@test'),h[5:],h)
        self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
        d = g.app.unitTestDict
        ok = ((d.get('result') and expectedErrors in (None,0)) or
            (
                # checkTrialWrite returns *True* if the following match.
                # d.get('result') == False and
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
                (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
            ))
        if not ok:
            g.trace('result',d.get('result'),
                'actualErrors',d.get('actualErrors'),
                'expectedErrors',d.get('expectedErrors'),
                'actualMismatchLine',d.get('actualMismatchLine'),
                'expectedMismatchLine', d.get('expectedMismatchLine'),
                '\nactualErrorMessage  ',d.get('actualErrorMessage'),
                '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
            )
        if not showTree and ok:
            while old_root.hasChildren():
                old_root.firstChild().doDelete()
            c.setChanged(oldChanged)

    finally:
        c.selectPosition(old_root)
        c.endUpdate()

    if g.app.unitTesting:
        assert ok

    return ok
#@-node:ekr.20070713082220:scannerUnitTest
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.classIndent = 0 # The indentation of the start of the class.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]
    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:@test pr
if False or g.unitTesting:
    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:@test pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace only from the classHead and trailing parts.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        ref +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = start = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    # if kind =='class' and g.match(s,i,self.outerBlockDelim1):
        # end = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        # start = i = i + len(self.outerBlockDelim1)
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) > self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent > self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = root = parent.copy()
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@+node:ekr.20071023082323:@test run
if g.unitTesting:

    ic = c.importCommands
    ic.methodName = 'test' ; ic.fileType = '.py'

    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()
    parent = p.copy()

    s = '''\
def spam():
    pass
'''
    s = g.adjustTripleString(s,-4)

    runner.run(s,parent)
#@-node:ekr.20071023082323:@test run
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:ekr.20070808115837.2:Regularize whitespace
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self,event=None):

    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self,event=None):

    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = root = parent.copy()
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@+node:ekr.20071023082323:@test run
if g.unitTesting:

    ic = c.importCommands
    ic.methodName = 'test' ; ic.fileType = '.py'

    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()
    parent = p.copy()

    s = '''\
def spam():
    pass
'''
    s = g.adjustTripleString(s,-4)

    runner.run(s,parent)
#@-node:ekr.20071023082323:@test run
#@-node:ekr.20070707072749:run (baseScannerClass)
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070808115837.2:Regularize whitespace
#@-node:ekr.20070731070208:Added @auto
#@+node:ekr.20070905072809.2:Read @auto nodes during saves if the node has not been read previously
#@+node:ekr.20070912104341:What I did
@nocolor

For the last several days I have been trying to smooth out rough edges in @auto.  Please test the new code on cvs.  All unit tests pass, but use extreme caution if your @auto nodes refer to valuable files.

The changes:

1. Leo will *read* an @auto node if the derived file exists, an 'insignificant' amount of data exists in the @auto tree, and the @auto node has not been read previously.  This promises to fix some quite awkward use cases.

Please report any glitches in the scheme immediately.  Problems may remain.

2. The 'perfect import' code now is a bit more relaxed, especially for 'non-strict' languages (all languages except Python):

- Leo leaves leading whitespace alone for non-strict languages.

- Leo complains about intermixed tabs and blanks in leading whitespace only for strict languages.

- Leo ignores leading whitespace in the perfect import tests for non-strict languages.

The effect is that Leo will import more files without complaint.  **However**, this also means that Leo might actually changes a derived file if such a change occurs only in leading whitespace in a non-strict language.  I *think* this is a reasonable idea: the alternative would be for Leo to be excessively fussy.

As I said earlier, all unit tests pass.  However, it may be that more changes (and more unit tests) will be needed.  Please give the new code a spin and report any problems asap.  I would like to release the latest code this Friday.

Edward
#@nonl
#@-node:ekr.20070912104341:What I did
#@+node:ekr.20070909095656:Notes
@nocolor

> - create a node; 
@auto /tmp/test.txt 

(/tmp/test.txt is an existing file) 

- save the Leo file 
log pane: 
wrote: test.txt 
saved: test.leo 

/tmp/test.txt is now empty

I can see that this is going to cause problems for people.  At

http://sourceforge.net/forum/message.php?msg_id=4453784

I say

[quote] > Leo will not automatically save a dirty @auto tree if Leo has not
already read this tree. This allows you to create an empty @auto node without
having to worry about Leo destroying the corresponding file.

Experience shows that this is not a good idea. It produces confusing and
counter-intuitive behavior. I am about to remove this 'feature'. [end quote]

Thus, what you report is the expected behavior. That is, the first time you
create any @auto node for an existing file you must use the read-at-auto-node
command to populate the @auto node.

But what is the solution to your confusion? As indicated above, the 'obvious'
solution (not writing 'unread' @auto trees) does not work particularly well. (I
forget exactly why not, but trust me, it doesn't.) Documentation is essential,
but probably won't prevent endless bug reports such as yours.

This isn't a fatal flaw in @auto, but it's going to be annoying unless I can
come up with a better plan.

-----

My present plan is to restore the previous way (remembering whether an @auto
node has been previously read) with several modifications:

- More traces and log messages so it is clearer why the old approach did not
work. At the very least I have to document the failed plan thoroughly.

- As Kent has just said, the bug is a "save-time" issue. Yesterday I had the
thought that the *save* operation should do an @auto *read* operation if the
node has not been previously read. That would be convenient (if it works): just
create the @auto node then do a save.

Some notes: 

- There is never much doubt about what to do if the file does not exist: just
create it, using whatever is in the @auto tree.

- I do not plan any dialogs. Long experience has convinced me that they never
work. Not only are they annoying, but at the point that they appear the user
will almost never know how to make the right choice, and will be upset at having
to make an unpleasant and unwelcome choice.

- An interesting kludge may be helpful. In the "hard" case (the derived file
exists but the @auto node has not been read) Leo will do the following:

Plan A. If the @auto node has no children, and contains a 'small' amount of body
text (say less than 100 characters and less than 10 lines), Leo will assume that
the @auto node contain no significant info and will do a *read* of the @auto
node when the user does a save.

Plan B. If the @auto node has children, or if the @auto node contain more than a
'small' amount of text, Leo will issues a warning (in the log pane, not in a
dialog) and will do nothing, neither reading the @auto node nor writing the
corresponding derived file. Thus, the @auto tree will be written to the .leo
file.

Plan B is likely to happen seldom, but if it does happen Leo can not choose
between reading or writing. Furthermore, Leo should not immediately force the
user to make a choice. For example, both the @auto node and the derived file
might contain significant information, and the user won't want to discard
either. True, there could be a cancel button in the dialog, but that will reduce
the user's consternation only slightly. Much better, imo, to do nothing drastic
and let the user 'recover' at her leisure.
#@-node:ekr.20070909095656:Notes
#@+node:ekr.20031218072017.3348:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self):
    # h = self.headString() ; tag = '@auto'
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:ekr.20040705201018:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20040705201018:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20041005105605.26:readAll (atFile)
def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            # g.trace('@auto',p.headString(),'name',p.atAutoNodeName())
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
#@-node:ekr.20041005105605.26:readAll (atFile)
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t)
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')

    if ic.errors or not g.os_path_exists(fileName):
        c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
#@nonl
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    # Not writing @auto nodes is way too dangerous.
    # isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()
    # forceWrite = isIgnore or not (isThin or isAuto) or (isThin and isOrphan)
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@nonl
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
# New in Leo 4.4.3
if not v.t.fileIndex:
    if 0: # This is not necessarily an error.
        # c.dumpOutline() # Can be called inside pdb.
        # Print the @chapters tree
        g.trace('*** missing t.fileIndex','v',repr(v))
        c.chapterController.printChaptersTree()
    v.t.fileIndex = g.app.nodeIndices.getNewIndex()

gnx = g.app.nodeIndices.toString(v.t.fileIndex)
if forceWrite or self.usingClipboard:
    v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
if v.isExpanded(): attr += "E"
if v.isMarked():   attr += "M"
if v.isOrphan():   attr += "O"

# No longer a bottleneck now that we use p.equal rather than p.__cmp__
# Almost 30% of the entire writing time came from here!!!
if not self.use_sax:
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr:
    attrs.append(' a="%s"' % attr)

# Put the archived *current* position in the *root* positions <v> element.
if self.use_sax and p.equal(self.rootPosition):
    aList = [str(z) for z in self.currentPosition.archivedPosition()]
    d = hasattr(v,'unKnownAttributes') and v.unknownAttributes or {}
    d['str_leo_pos'] = ','.join(aList)
    # g.trace(aList,d)
    v.unknownAttributes = d
#@nonl
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

# Debugging.
# if v.isAnyAtFileNode():
    # if hasattr(v.t,"tnodeList"):
        # g.trace(v.headString(),len(v.t.tnodeList))
    # else:
        # g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))

if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

# For testing.
# if p.isAtIgnoreNode():
     # for p2 in p.self_and_subtree_iter():
            # if p2.isAtThinFileNode():
                # g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20070905072809.2:Read @auto nodes during saves if the node has not been read previously
#@+node:ekr.20070919083650:Added read-file-into-node and write-file-from-node commands
These commands are useful for resolving cvs conflicts in derived files.

The read-file-into-node command prompts for a filename, and creates an node
whose headline is @read-file-into-node <filename> and whose body text is the
entire contents of the file.

The write-file-from-node writes the body text of the selected not to a file. If
the headline of the presently selected node starts with @read-file-into-node the
command use the filename that follows in the headline. Otherwise, the command
prompts for a filename.
#@nonl
#@-node:ekr.20070919083650:Added read-file-into-node and write-file-from-node commands
#@-node:ekr.20070703182412.1:Features
#@-node:ekr.20070915101503:4.4.4 b2
#@+node:ekr.20070919132518:4.4.4 b3
#@+node:ekr.20070920083033:Bugs
#@+node:ekr.20070927081004:Fixed yet another new @auto bug
@nocolor

https://sourceforge.net/forum/message.php?msg_id=4539759
By: ktenney

<ctrl-n> new Leo file

rename ``NewHeadline`` to
@auto /tmp/test

type a line in the @auto node

<ctrl-s>

log pane reports

- created:   \tmp\test
- saved: test.leo

type another line in the @auto node

<ctrl-s>

log pane reports

- reading new @auto /tmp/test2
- saved: test.leo

the second line typed has disappeared.

@color
#@nonl
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')

    if ic.errors or not g.os_path_exists(fileName):
        c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
#@nonl
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20070806140208:writeAtAutoNodesHelper
def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString,force=True)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
#@-node:ekr.20070806140208:writeAtAutoNodesHelper
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@-node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
#@-node:ekr.20070927081004:Fixed yet another new @auto bug
#@+node:ekr.20071001054731:Greatly improved speed of unmark-all
# It was appearing to hang.
#@nonl
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll (self,event=None):

    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        changed = False
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                # c.clearMarked(p) # Very slow: calls a hook.
                p.v.clearMarked()
                p.v.t.setDirty()
                u.afterMark(p,undoType,bunch)
        dirtyVnodeList = [p.v for p in c.allNodes_iter() if p.v.isDirty()]
        if changed:
            g.doHook("clear-all-marks",c=c,p=p,v=p)
            c.setChanged(True)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@+node:ekr.20070627082044.682:@test unmarkAll
if g.unitTesting:
    marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
    try:
        ok = True
        try:
            c.unmarkAll()
        except Exception:
            ok = False
    finally:
        for p in c.allNodes_iter():
            if p.v in marks:
                if not p.isMarked():
                    c.setMarked(p)
            else:
                if p.isMarked():
                    c.clearMarked(p)

    if not ok: raise
#@-node:ekr.20070627082044.682:@test unmarkAll
#@-node:ekr.20031218072017.2930:unmarkAll
#@+node:ekr.20071001054731.1:print all nodes
count = 0
for p in c.allNodes_iter():
    # print '.' * p.level(),p.headString()
    count += 1
print count,'nodes'
#@nonl
#@-node:ekr.20071001054731.1:print all nodes
#@+node:ekr.20060906211138:c.clearMarked
def clearMarked  (self,p):

    c = self
    p.v.clearMarked()
    g.doHook("clear-mark",c=c,p=p,v=p)
#@nonl
#@-node:ekr.20060906211138:c.clearMarked
#@+node:ekr.20031218072017.3336:setDirty
def setDirty (self):

    self.statusBits |= self.dirtyBit
#@-node:ekr.20031218072017.3336:setDirty
#@+node:ekr.20031218072017.3391:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20031218072017.3391:v.clearMarked
#@-node:ekr.20071001054731:Greatly improved speed of unmark-all
#@+node:ekr.20071004084327:Fixed string problems in new colorizer
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4544813

When the 'r' in 'str(' is deleted, the closing bracket on the next line changes
color.  There are lots of variations, for example putting the 'r' back causes
the opening bracket on the next line to change color.

@color

g.es(r'abc')
g.es('hello')

@nocolor

The fix was to init self.prev: match_previous was coloring the wrong range.
#@nonl
#@-node:ekr.20071004084327:Fixed string problems in new colorizer
#@+node:ekr.20071001052611:Made sure dirty bits get updated in xemacs plugin
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4543844
By: terry_n_brown

Using the xemacs plug-in for node editing it seems the tree's node-has-contents
and node-is-modified indications are no longer being updated.  The log file
says "updated from: LeoTemp_158688460_test.py" correctly, and the update occurs,
by the indications of change don't.

Also I was creating an @auto node, misspelled it's target file name the first
time, but when I corrected it and tried reading it again it still said it couldn't
find it.  The when I Save As'ed the leo file over itself it immediately read
the @auto file.

The fix was to c.setBodyString.  p.setDirty no longer redraws the screen automatically, so we must do it by hand.

@color
#@nonl
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        c.beginUpdate()
        try:
            v.setTnodeText(s)
            v.t.setSelection(0,0)
            p.setDirty()
            if not c.isChanged():
                c.setChanged(True)
        finally:
            c.endUpdate()
#@-node:ekr.20040305223522:c.setBodyString
#@-node:ekr.20071001052611:Made sure dirty bits get updated in xemacs plugin
#@+node:ekr.20071003204338.1:Fixed backward find bug
@nocolor

Simplified the code:

- Removed selection-only logic: it was never used.
- Only the insert point is ever used to init interactive searches.
- initBatch/NextText now take an optional ins argument.
  Both these methods set the insert point by calling init_s_ctrl.

The bug fix was to change:

pattern.lower()

to:

pattern = pattern.lower()

in backwardsHelper.

@color
#@nonl
#@+node:ekr.20061212084717:class leoFind
class leoFind:

    """The base class for Leo's Find commands."""

    @others
#@+node:ekr.20031218072017.3053:leoFind.__init__ & helpers
def __init__ (self,c,title=None):

    # g.trace('leoFind',c)

    self.c = c

    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        << compute self.title >>

    << init the gui-independent ivars >>

def init (self,c):
    self.oops()
#@+node:ekr.20041121145452:<< compute self.title >>
if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)

self.title = "Find/Change for %s" %  s
#@-node:ekr.20041121145452:<< compute self.title >>
#@+node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

<< do dummy initialization to keep Pychecker happy >>

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos >= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
#@+node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.wrap = None
    self.whole_word = None

if 1:
    self.change_ctrl = None
    self.find_ctrl = None
    self.frame = None
    self.svarDict = {}
#@-node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
#@-node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
#@-node:ekr.20031218072017.3053:leoFind.__init__ & helpers
#@+node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3057:changeAllButton
# The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    else:
        self.changeAll()
#@-node:ekr.20031218072017.3057:changeAllButton
#@+node:ekr.20031218072017.3056:changeButton
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3056:changeButton
#@+node:ekr.20031218072017.3058:changeThenFindButton
# The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
#@-node:ekr.20031218072017.3058:changeThenFindButton
#@+node:ekr.20031218072017.3060:findAllButton
# The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    else:
        self.findAll()
#@-node:ekr.20031218072017.3060:findAllButton
#@+node:ekr.20031218072017.3059:findButton
# The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3059:findButton
#@+node:ekr.20031218072017.3065:setup_button
# Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

    c = self.c
    self.p = c.currentPosition()

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3065:setup_button
#@-node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3061:changeCommand
# The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3061:changeCommand
#@+node:ekr.20031218072017.3062:changeThenFindCommand
# The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
#@-node:ekr.20031218072017.3062:changeThenFindCommand
#@+node:ekr.20051013084200.1:dismiss: defined in subclass class
def dismiss (self):
    pass
#@-node:ekr.20051013084200.1:dismiss: defined in subclass class
#@+node:ekr.20031218072017.3063:findNextCommand
# The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3063:findNextCommand
#@+node:ekr.20031218072017.3064:findPreviousCommand
# The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
#@-node:ekr.20031218072017.3064:findPreviousCommand
#@+node:EKR.20040503070514:handleUserClick
def handleUserClick (self,p):

    """Reset suboutline-only search when the user clicks a headline."""

    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
#@-node:EKR.20040503070514:handleUserClick
#@+node:ekr.20031218072017.3066:setup_command
# Initializes a search when a command is invoked from the menu.

def setup_command(self):

    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3066:setup_command
#@-node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 > pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        << change headline >>
    else:
        << change body >>
#@+node:ekr.20031218072017.2294:<< change headline >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():

    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Headline',undoData)
#@-node:ekr.20031218072017.2294:<< change headline >>
#@+node:ekr.20031218072017.2295:<< change body >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():

    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)

    u.afterChangeNodeContents(p,'Change Body',undoData)
#@-node:ekr.20031218072017.2295:<< change body >>
#@-node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
#@+node:ekr.20031218072017.3068:change
def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
#@-node:ekr.20031218072017.3068:change
#@+node:ekr.20031218072017.3069:changeAll
def changeAll(self):

    # g.trace(g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if pos1 is None: break
            count += 1
            self.batchChange(pos1,pos2)
            s = w.getAllText()
            i,j = g.getLine(s,pos1)
            line = s[i:j]
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
    finally:
        c.endUpdate()
        self.restore(saveData)
#@-node:ekr.20031218072017.3069:changeAll
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start > end: start,end = end,start
    if start == end:
        g.es("No text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
#@+node:ekr.20060526201951:makeRegexSubs
def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\',j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
#@-node:ekr.20060526201951:makeRegexSubs
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20031218072017.3071:changeThenFind
def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
#@-node:ekr.20031218072017.3071:changeThenFind
#@+node:ekr.20031218072017.2417:doChange...Script
def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec self.change_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.2417:doChange...Script
#@+node:ekr.20031218072017.3072:doFind...Script
def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec self.find_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.3072:doFind...Script
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                << create the found node and begin the undo group >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@+node:ekr.20051113110735:<< create the found node and begin the undo group >>
u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110735:<< create the found node and begin the undo group >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.3074:findNext
def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is None:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)
    else:
        self.showSuccess(pos,newpos)
#@-node:ekr.20031218072017.3074:findNext
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p ; self.errors = 0
    attempts = 0
    self.backwardAttempts = 0
    while p:
        pos, newpos = self.search()
        # g.trace('pos',pos,'p',p.headString(),g.callers())
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            g.trace('find errors')
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            attempts += 1
            p = self.p = self.selectNextPosition()
    # g.trace('attempts',attempts,'backwardAttempts',self.backwardAttempts)
    return None, None
#@-node:ekr.20031218072017.3075:findNextMatch
#@+node:ekr.20031218072017.3076:resetWrap
def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
#@-node:ekr.20031218072017.3076:resetWrap
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()

    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        # g.trace("reverse wrap done")
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        # g.trace('wrap done')
        return None, None
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    if swapij and backwards: i,j = j,i

    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # if s: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):

    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i < len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 <= i < len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 <= i < len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c

def backwardsHelper (self,s,i,j,pattern,nocase,word):

    debug = False
    if nocase:
        s = s.lower() ; pattern = pattern.lower() # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if i < 0 or i > len(s) or j < 0 or j > len(s):
        g.trace('bad index: i = %s, j = %s' % (i,j))
        i = 0 ; j = len(s)

    if debug and (s and i == 0 and j == 0):
        g.trace('two zero indices')

    self.backwardAttempts += 1

    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        if debug:
            self.debugCount += 1
            if self.debugCount < 50:
                g.trace(i,j,'len(s)',len(s),self.p.headString())
        return -1,-1

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if debug: g.trace('**word** %3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if debug: g.trace('%3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):

    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@-node:ekr.20031218072017.3077:search & helpers
#@+node:ekr.20031218072017.3081:selectNextPosition
# Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p ; trace = False

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        if trace: g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # if trace: g.trace(p and p.headString() or 'None')

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        if trace: g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@-node:ekr.20031218072017.3081:selectNextPosition
#@-node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20061212095134.1:General utils
#@+node:ekr.20051020120306.26:bringToFront (leoFind)
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl

    # g.trace(g.callers())
    c.widgetWantsFocusNow(w)
    g.app.gui.selectAllText(w)
    c.widgetWantsFocus(w)
#@-node:ekr.20051020120306.26:bringToFront (leoFind)
#@+node:ekr.20061111084423.1:oops (leoFind)
def oops(self):
    print ("leoFind oops:",
        g.callers(10),"should be overridden in subclass")
#@-node:ekr.20061111084423.1:oops (leoFind)
#@+node:ekr.20051020120306.27:selectAllFindText (leoFind)
def selectAllFindText (self,event=None):

    __pychecker__ = '--no-argsused' # event

    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
#@-node:ekr.20051020120306.27:selectAllFindText (leoFind)
#@-node:ekr.20061212095134.1:General utils
#@+node:ekr.20031218072017.3082:Initing & finalizing
#@+node:ekr.20031218072017.3083:checkArgs
def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
#@-node:ekr.20031218072017.3083:checkArgs
#@+node:ekr.20031218072017.3084:initBatchCommands
# Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only:
        self.p = c.currentPosition()
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
#@-node:ekr.20031218072017.3084:initBatchCommands
#@+node:ekr.20031218072017.3085:initBatchText, initNextText & init_s_ctrl
# Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self,ins=None):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    self.init_s_ctrl(s,ins)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self,ins=None):
    p = self.p
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    self.init_s_ctrl(s,ins)

def init_s_ctrl (self,s,ins):

    w = self.s_ctrl
    w.setAllText(s)
    if ins is None:
        ins = g.choose(self.reverse,len(s),0)
        # print g.choose(self.reverse,'.','*'),
    else:
        pass # g.trace('ins',ins)
    w.setInsertPoint(ins)
#@-node:ekr.20031218072017.3085:initBatchText, initNextText & init_s_ctrl
#@+node:ekr.20031218072017.3086:initInHeadline
# Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            # Search headline first.
            self.in_headline = (
                p == c.frame.tree.editPosition() and
                c.get_focus() != c.frame.body.bodyCtrl)
    else:
        self.in_headline = self.search_headline
#@-node:ekr.20031218072017.3086:initInHeadline
#@+node:ekr.20031218072017.3087:initInteractiveCommands
def initInteractiveCommands(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    self.errors = 0

    # We only use the insert point, *never* the selection range.
    ins = w.getInsertPoint()
    # g.trace('ins',ins)
    self.debugCount = 0
    self.initNextText(ins=ins)
    c.widgetWantsFocus(w)

    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = ins
        # Do not set self.wrapPosition here: that must be done after the first search.
#@-node:ekr.20031218072017.3087:initInteractiveCommands
#@+node:ekr.20031218072017.3088:printLine
def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('-' * 20,self.p.headString())
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es(theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('-' * 20,self.p.headString())
        g.es(line)
        self.p.setVisited()
    else:
        g.es(line)
#@-node:ekr.20031218072017.3088:printLine
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data

    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)

    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()

    #g.trace(c.widget_name(t))

    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20031218072017.3090:save
def save (self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = w.getInsertPoint()
    sel = w.getSelectionRange()
    if len(sel) == 2:
        start,end = sel
    else:
        start,end = None,None
    return (self.in_headline,p,w,insert,start,end)
#@-node:ekr.20031218072017.3090:save
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible(c)
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        if not p: g.trace('can not happen: self.p is None')
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20031218072017.1460:update_ivars (leoFind)
# New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):

    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        # g.trace(self.svarDict.get(key))
        val = self.svarDict[key].get()
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@-node:ekr.20031218072017.1460:update_ivars (leoFind)
#@-node:ekr.20031218072017.3082:Initing & finalizing
#@-node:ekr.20061212084717:class leoFind
#@+node:ekr.20031218072017.3074:findNext
def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is None:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)
    else:
        self.showSuccess(pos,newpos)
#@-node:ekr.20031218072017.3074:findNext
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p ; self.errors = 0
    attempts = 0
    self.backwardAttempts = 0
    while p:
        pos, newpos = self.search()
        # g.trace('pos',pos,'p',p.headString(),g.callers())
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            g.trace('find errors')
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            attempts += 1
            p = self.p = self.selectNextPosition()
    # g.trace('attempts',attempts,'backwardAttempts',self.backwardAttempts)
    return None, None
#@-node:ekr.20031218072017.3075:findNextMatch
#@+node:ekr.20031218072017.3081:selectNextPosition
# Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p ; trace = False

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        if trace: g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()

    # if trace: g.trace(p and p.headString() or 'None')

    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        if trace: g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@-node:ekr.20031218072017.3081:selectNextPosition
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.

    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()

    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos is not None and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        # g.trace("reverse wrap done")
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        # g.trace('wrap done')
        return None, None
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):

    if swapij and backwards: i,j = j,i

    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # if s: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1

    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):

    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1

    if backwards: # Scan to the last match.  We must use search here.
        last_mo = None ; i = 0
        while i < len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1 ; last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)

    if 0:
        g.trace('i',i,'j',j,'s[i:j]',repr(s[i:j]),
            'mo.start',mo and mo.start(),'mo.end',mo and mo.end())

    while mo and 0 <= i < len(s):
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 <= i < len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c

def backwardsHelper (self,s,i,j,pattern,nocase,word):

    debug = False
    if nocase:
        s = s.lower() ; pattern = pattern.lower() # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if i < 0 or i > len(s) or j < 0 or j > len(s):
        g.trace('bad index: i = %s, j = %s' % (i,j))
        i = 0 ; j = len(s)

    if debug and (s and i == 0 and j == 0):
        g.trace('two zero indices')

    self.backwardAttempts += 1

    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        if debug:
            self.debugCount += 1
            if self.debugCount < 50:
                g.trace(i,j,'len(s)',len(s),self.p.headString())
        return -1,-1

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if debug: g.trace('**word** %3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if debug: g.trace('%3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):

    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):

    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'

    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)

    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))

    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):

    '''Carefully replace backslashes in a search pattern.'''

    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.

    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@-node:ekr.20031218072017.3077:search & helpers
#@+node:ekr.20031218072017.3085:initBatchText, initNextText & init_s_ctrl
# Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self,ins=None):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    self.init_s_ctrl(s,ins)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self,ins=None):
    p = self.p
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    self.init_s_ctrl(s,ins)

def init_s_ctrl (self,s,ins):

    w = self.s_ctrl
    w.setAllText(s)
    if ins is None:
        ins = g.choose(self.reverse,len(s),0)
        # print g.choose(self.reverse,'.','*'),
    else:
        pass # g.trace('ins',ins)
    w.setInsertPoint(ins)
#@-node:ekr.20031218072017.3085:initBatchText, initNextText & init_s_ctrl
#@+node:ekr.20070228074312.22:getSelectionRange (baseText)
def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] >= 0 and sel[1] >= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i > j: sel = j,i # Bug fix: 10/5/07
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
#@-node:ekr.20070228074312.22:getSelectionRange (baseText)
#@+node:ekr.20031218072017.3087:initInteractiveCommands
def initInteractiveCommands(self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    self.errors = 0

    # We only use the insert point, *never* the selection range.
    ins = w.getInsertPoint()
    # g.trace('ins',ins)
    self.debugCount = 0
    self.initNextText(ins=ins)
    c.widgetWantsFocus(w)

    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = ins
        # Do not set self.wrapPosition here: that must be done after the first search.
#@-node:ekr.20031218072017.3087:initInteractiveCommands
#@+node:ekr.20060526140744:backwardsHelper
debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c

def backwardsHelper (self,s,i,j,pattern,nocase,word):

    debug = False
    if nocase:
        s = s.lower() ; pattern = pattern.lower() # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)

    if i < 0 or i > len(s) or j < 0 or j > len(s):
        g.trace('bad index: i = %s, j = %s' % (i,j))
        i = 0 ; j = len(s)

    if debug and (s and i == 0 and j == 0):
        g.trace('two zero indices')

    self.backwardAttempts += 1

    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        if debug:
            self.debugCount += 1
            if self.debugCount < 50:
                g.trace(i,j,'len(s)',len(s),self.p.headString())
        return -1,-1

    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if debug: g.trace('**word** %3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if debug: g.trace('%3s %3s %5s -> %s %s' % (i,j,g.choose(j==len(s),'(end)',''),k,self.p.headString()))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@-node:ekr.20071003204338.1:Fixed backward find bug
#@+node:ekr.20071005131749:Fixed cursor up/down problem
@
The was to g.getLine.

This is a potentially major change.  All unit tests pass.
#@nonl
#@+node:ekr.20071006090557:Example of problems
At least three bugs.

- Place cursor on last (blank) line.  Cursor up goes one line too far.
- Place cursor at end of line 1.  Second cursor down does nothing.
- Place cursor at end of xxxx line.  Second cursor down goes one line too far.

xxxxxxxxx
line 1
line 2
#@-node:ekr.20071006090557:Example of problems
#@+node:ekr.20061031102333.2:g.getWord & getLine & tests
def getWord (s,i):

    '''Return i,j such that s[i:j] is the word surrounding s[i].'''

    if i >= len(s): i = len(s) - 1
    if i < 0: i = 0
    # Scan backwards.
    while 0 <= i < len(s) and g.isWordChar(s[i]):
        i-= 1
    i += 1
    # Scan forwards.
    j = i
    while 0 <= j < len(s) and g.isWordChar(s[j]):
        j += 1
    return i,j

def getLine (s,i):

    '''Return i,j such that s[i:j] is the line surrounding s[i].
    s[i] is a newline only if the line is empty.
    s[j] is a newline unless there is no trailing newline.
    '''

    if i > len(s): i = len(s) -1 # Bug fix: 10/6/07 (was if i >= len(s))
    if i < 0: i = 0
    j = s.rfind('\n',0,i) # A newline *ends* the line, so look to the left of a newline.
    if j == -1: j = 0
    else:       j += 1
    k = s.find('\n',i)
    if k == -1: k = len(s)
    else:       k = k + 1
    # g.trace('i,j,k',i,j,k,repr(s[j:k]))
    return j,k
#@nonl
#@+node:ekr.20070627082044.839:@test g.getLine
if g.unitTesting:
    s = 'a\ncd\n\ne'
    for i,result in (
        (-1,(0,2)), # One too few.
        (0,(0,2)),(1,(0,2)),
        (2,(2,5)),(3,(2,5)),(4,(2,5)),
        (5,(5,6)),
        (6,(6,7)),
        (7,(6,7)), # One too many.
    ):
        j,k = g.getLine(s,i)
        assert (j,k) == result, 'i: %d, expected %d,%d, got %d,%d' % (i,result[0],result[1],j,k)
#@nonl
#@-node:ekr.20070627082044.839:@test g.getLine
#@+node:ekr.20070627082044.834:@test g.getWord
if g.unitTesting:
    s = 'abc xy_z5 pdq'
    i,j = g.getWord(s,5)
    assert s[i:j] == 'xy_z5','got %s' % s[i:j]
#@-node:ekr.20070627082044.834:@test g.getWord
#@-node:ekr.20061031102333.2:g.getWord & getLine & tests
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper & test
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: #### j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@nonl
#@+node:ekr.20070627082044.269:@test extendHelper
if g.unitTesting:
    c.beginUpdate()
    try:
        ec = c.editCommands ; w = c.frame.body.bodyCtrl

        for i,j,python in (
            # ('1.0','4.5',False),
            (5,50,True),
        ):
            extend = True
            ec.moveSpot = None # It's hard to init this properly.
            ec.extendHelper(w,extend,j)
            i2,j2 = w.getSelectionRange()
            # print i2,j2
            #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
            #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.269:@test extendHelper
#@-node:ekr.20060113130510:extendHelper & test
#@+node:ekr.20060113105246.1:moveUpOrDownHelper & test
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    if trace: g.trace('ins',ins,'row',row,'col',col)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    n = max(0,j2-i2-1) # The length of the new line.
    col2 = min(col,n)
    spot = i2 + col2
    if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@+node:ekr.20070627082044.272:@test moveUpOrDownHelper
if g.unitTesting:
    c.beginUpdate()
    try:

        ec = c.editCommands ; w = c.frame.body.bodyCtrl

        for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
            event = None ; extend = False; ec.moveSpot = None
            w.setInsertPoint(i)
            ec.moveUpOrDownHelper (event,direction,extend)
            i2,j2 = w.getSelectionRange()
            if 1:
                break
            else:
                assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
                assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
                w.setSelectionRange(0,0,insert=None)
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.272:@test moveUpOrDownHelper
#@-node:ekr.20060113105246.1:moveUpOrDownHelper & test
#@+node:ekr.20051218122116:moveToHelper & test
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@+node:ekr.20070627082044.271:@test moveToHelper
if g.unitTesting:
    c.beginUpdate()
    try:
        ec = c.editCommands ; w = c.frame.body.bodyCtrl

        for i,j,python in (
            #('1.0','4.5',False),
            (5,50,True),
        ):
            event = None ; extend = True ; ec.moveSpot = None
            w.setInsertPoint(i)
            ec.moveToHelper (event,j,extend)
            i2,j2 = w.getSelectionRange()
            assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
            assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
            w.setSelectionRange(0,0,insert=None)
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.271:@test moveToHelper
#@-node:ekr.20051218122116:moveToHelper & test
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i >= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j >= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i < j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 < len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 < len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 > j2: return

    self.moveToHelper(event,i2+1,extend)
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i >= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j >= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j < i and s[j].isspace():
        j += 1

    if j < i:
        self.moveToHelper(event,j,extend)
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060209095101:setMoveCol & test
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@+node:ekr.20070627082044.276:@test setMoveCol
if g.unitTesting:
    c.beginUpdate()
    try:
        w = c.frame.body.bodyCtrl
        ec = c.editCommands

        for spot,result in (('1.0',0),(5,5)):
            ec.setMoveCol(w,spot)
            assert ec.moveSpot == result
            assert ec.moveCol == result
    finally:
        c.endUpdate(False)
#@-node:ekr.20070627082044.276:@test setMoveCol
#@-node:ekr.20060209095101:setMoveCol & test
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocusNow(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return

    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20061007082956:extend-to-line
def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@-node:ekr.20061007082956:extend-to-line
#@+node:ekr.20061007214835.4:extend-to-sentence
def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@nonl
#@-node:ekr.20061007214835.4:extend-to-sentence
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not g.isWordChar(s[i]):
        i -= 1
    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@-node:ekr.20050920084036.140:movePastClose
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@-node:ekr.20071005131749:Fixed cursor up/down problem
#@+node:ekr.20071006093912:Created new unit tests
@
for methods that call g.getLine:

backward-delete-char
delete-indentation
fill-region (now uses the reformat-paragraph code).
setFillPrefix
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''

    # New in Leo 4.4.4: just use reformat-paragraph logic.

    c = self.c ; p = c.currentPosition() ; undoType = 'fill-region'
    w = self.editWidget(event)
    i,j = w.getSelectionRange()
    c.undoer.beforeChangeGroup(p,undoType)
    while 1:
        self.c.reformatParagraph(event,undoType='reformat-paragraph')
        ins = w.getInsertPoint()
        s = w.getAllText()
        if ins >= j or ins >= len(s):
            break
    c.undoer.afterChangeGroup(p,undoType)
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.134:indentToCommentColumn
def indentToCommentColumn (self,event):

    '''Insert whitespace to indent the line containing the insert point to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    c1 = int(self.ccolumn)
    line2 = ' ' * c1 + line.lstrip()
    if line2 != line:
        w.delete(i,j)
        w.insert(i,line2)
    w.setInsertPoint(i+c1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.134:indentToCommentColumn
#@+node:ekr.20050920084036.70:setFillPrefix
def setFillPrefix( self, event ):

    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    self.fillPrefix = s[i:j]
#@-node:ekr.20050920084036.70:setFillPrefix
#@-node:ekr.20071006093912:Created new unit tests
#@+node:ekr.20071008110010:Fixed doc bug
http://sourceforge.net/forum/message.php?msg_id=4557854

The customizing attributes code doesn't work from the User's Guide here:

http://webpages.charter.net/edreamleo/customizing.html#adding-extensible-attribu
tes-to-nodes-and-leo-files

I corrected the hasattr problem and added sample read code here:

@color

# Create the uA if necessary.
if not hasattr(p.v.t,'unknownAttributes'):
....p.v.t.unknownAttributes = {}

# Get the inner dictionary for the 'xyzzy' plugin, creating it if necessary.
d = p.v.t.unknownAttributes.get('xyzzy',{})

# Set some values. These values must be picklable.
d ['duration'] = 5
d ['notes'] = "This is a note."

# Update the uA.
p.v.t.unknownAttributes ['xyzzy'] = d

if hasattr(p.v.t,"unknownAttributes"):
....d = p.v.t.unknownAttributes.get("xyzzy",{ })
....g.es(d['duration'])
....g.es(d['notes'])
#@-node:ekr.20071008110010:Fixed doc bug
#@+node:ekr.20071009083345:Regularize newlines in @auto compare
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4558330
By: vransmayr

Hi Edward,

I don't get @auto nodes/trees to work the way I expected them to work ...

Here are the facts as they occur in my environment:

* I'm using the latest CVS-snapshot of Leo.

<Leo Log Pane>

Leo Log Window...
Leo 4.4.4 b3, build  1.210 , October 8, 2007
Python 2.4.3, Tk 8.4.7, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

redefining close-window in all to extend-to-word in all
redefining goto-first-node in tree to goto-first-visible-node in tree
redefining goto-first-node in tree to goto-first-visible-node in all
redefining goto-first-node in tree to goto-first-visible-node in all
redefining forward-sentence in text to propagate-key-event in all
redefining forward-word in text to propagate-key-event in all
redefining kill-region-save in all to propagate-key-event in all
leoID = vr20060903 (in C:\Dokumente und Einstellungen\VR)
global config dir: C:\CVS-Reps\leo\config
home dir: C:\Dokumente und Einstellungen\VR
reading settings in C:\CVS-Reps\leo\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene
Dateien\WLog\WLog.leo
reading: C:\Dokumente und Einstellungen\VR\Eigene Dateien\WLog\WLog.leo

</Leo Log Pane>

I try to create an @auto-node from a simple python file, where I would
not expect
any problems with. - In my case I used "roman.py" in
"C:\Python24\Lib\site-packages\".

@auto C:\\Python24\\Lib\\site-packages\\roman.py

When I try to save the outline I receive the following error-messages:

<Leo Log Pane>

reading new @auto C:\\Python24\\Lib\\site-packages\\roman.py
*** first mismatch at line 1
original line:  u'"""Convert to and from Roman numerals"""\n'
generated line: '"""Convert to and from Roman numerals"""\r\n'
@auto did not import the file perfectly
first mismatched line: 1
'"""Convert to and from Roman numerals"""\r\n'
inserting @ignore
Errors inhibited read @auto C:\\Python24\\Lib\\site-packages\\roman.py
saved: WLog.leo

</Leo Log Pane>

What am I missing ?

Regards,

    Viktor Ransmayr
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@-node:ekr.20071009083345:Regularize newlines in @auto compare
#@+node:ekr.20071010134833:Fixed unicode bug in trace
# This should have been done long ago.
#@nonl
#@+node:ekr.20031218072017.2317:trace
# Convert all args to strings.

def trace (*args,**keys):

    #callers = keys.get("callers",False)
    newline = keys.get("newline",True)
    align =   keys.get("align",0)

    s = ""
    for arg in args:
        if type(arg) == type(u""):
            pass
            # try:    arg = str(arg) 
            # except: arg = repr(arg)
        elif type(arg) != type(""):
            arg = repr(arg)
        if len(s) > 0:
            s = s + " " + arg
        else:
            s = arg
    message = s

    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except: name = ''
    if name == "?":
        name = "<unknown>"

    # if callers:
        # traceback.print_stack()

    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else:         name = pad + name

    message = g.toEncodedString(message,'ascii') # Bug fix: 10/10/07.

    if newline:
        print name + ": " + message
    else:
        print name + ": " + message,
#@-node:ekr.20031218072017.2317:trace
#@-node:ekr.20071010134833:Fixed unicode bug in trace
#@+node:ekr.20071017163533:Fixed chapter typo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4574018
#@-node:ekr.20071017163533:Fixed chapter typo
#@+node:ekr.20071017195431:Fixed chapter crasher
http://sourceforge.net/forum/message.php?msg_id=4573990
#@+node:ekr.20070317085437.52:cc.moveNodeToChapterHelper
def moveNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; u = c.undoer ; undoType = 'Move Node To Chapter'
    p = c.currentPosition()
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        cc.error('chapter "%s" does not exist' % toChapterName)
        return

    if 1: # Defensive code: should never happen.
        if fromChapter.name == 'main' and p.headString().startswith('@chapter'):
            return cc.error('can not move @chapter node')

    c.beginUpdate()
    try:
        if toChapter.name == 'main':
            sel = (p.threadBack() != fromChapter.root and p.threadBack()) or p.nodeAfterTree()
        else:
            sel = p.threadBack() or p.nodeAfterTree()
        if sel:
            # Get 'before' undo data.
            inAtIgnoreRange = p.inAtIgnoreRange()
            undoData = u.beforeMoveNode(p)
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
            # Do the move.
            if toChapter.name == 'main':
                p.unlink()
                p.moveAfter(toChapter.p)
            else:
                p.unlink()
                p.moveToLastChildOf(toChapter.root)
            c.selectPosition(sel)
            c.setChanged(True)
            # Do the 'after' undo operation.
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False) # toChapter.select will do the drawing.

    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.error('Can not move the last node of a chapter.')
#@-node:ekr.20070317085437.52:cc.moveNodeToChapterHelper
#@-node:ekr.20071017195431:Fixed chapter crasher
#@+node:ekr.20071016120719:Fixed several @auto bugs
#@+node:ekr.20070920055354:Fixed new @auto bug
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4527231
By: ktenney

@others doesn't get stripped when creating
scriptfile.py for use by <alt-x> <debug>, so winpdb encounters bad syntax.

@color
#@nonl
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # print '*** script\n',script
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))

    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None

    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@+node:ekr.20070627082044.855:@test pre-definition of g in scripts
if g.unitTesting:
    # print g.listToString(dir())

    for ivar in ('c','g','p'):
        assert ivar in dir()

    assert hasattr(g.app,'tkEncoding')
#@-node:ekr.20070627082044.855:@test pre-definition of g in scripts
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands ; w = c.frame.body.bodyCtrl
    if not p:
        p = c.currentPosition()
    try:
        if g.app.inBridge:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
#@+node:ekr.20050211100535:@test g.getScript strips crlf
if g.unitTesting:

    c,p = g.getTestVars() # Optional: prevents pychecker warnings.
    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@-node:ekr.20050211100535:@test g.getScript strips crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20060519003651:debug & helper
def debug (self,event=None):

    '''Start an external debugger in another process to debug a script.
    The script is the presently selected text or then entire tree's script.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    script = g.getScript(c,p)
    winpdb = self.findDebugger()
    if not winpdb: return

    #check for doctest examples
    try:
        import doctest
        parser = doctest.DocTestParser()
        examples = parser.get_examples(script)

        # if this is doctest, extract the examples as a script
        if len(examples) > 0:
            script = doctest.script_from_examples(script)
    except ImportError:
        pass

    # special case; debug code may include g.es("info string").
    # insert code fragment to make this expression legal outside Leo.
    hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"
    script = hide_ges + script

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213:findDebugger
def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
#@-node:ekr.20060521140213:findDebugger
#@-node:ekr.20060519003651:debug & helper
#@-node:ekr.20070920055354:Fixed new @auto bug
#@+node:ekr.20071012112853:fixed new @auto crasher
@nocolor

RE: C++ Import to @file problem (New)

By: R Shanley (rjshanley1) - 2007-10-11 10:47
I found this problem in last night's CVS download. 

Line's like this, alone or in a larger file, take the exception shown.  

stuff* stuff::m_instance = 0; 


Traceback (most recent call last): 
File "C:\leolatestCVS\leo\src\leoCommands.py", line 276, in doCommand 
val = command(event) 
File "C:\leolatestCVS\leo\src\leoCommands.py", line 1560, in importAtFile 
c.importCommands.importFilesCommand(names,"@file") 
File "C:\leolatestCVS\leo\src\leoImport.py", line 881, in importFilesCommand 
v = self.createOutline(fileName,current) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 737, in createOutline 
self.scanCText(s,p,atAuto=atAuto) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2516, in scanCText 
scanner.run(s,parent) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2449, in run 
scanner.scan(s,parent) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 1981, in scan 
i = start = self.skipDecls(s,0,len(s)) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2154, in skipDecls 
elif self.startsFunction(s,i,quick=True): 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2256, in startsFunction 
i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags) 
File "C:\leolatestCVS\leo\src\leoImport.py", line 2286, in startsHelper 
i, ids, classId = self.skipSigStart(s,j,tags) # Rescan the first id. 
ValueError: need more than 2 values to unpack 

#@-node:ekr.20071012112853:fixed new @auto crasher
#@+node:ekr.20071016111722:Handle over-indented defs
@nocolor

@ For example:

def x():
    pass

if g.unitTesting:
    def test_x(): # over-indented.
        pass

def y():
    pass

@c

@color
#@nonl
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@-node:ekr.20071016111722:Handle over-indented defs
#@+node:ekr.20071016120719.2:Made sure don't see any [nl] at start of line
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@-node:ekr.20071016120719.2:Made sure don't see any [nl] at start of line
#@+node:ekr.20071014112331:Made sure java scanner works with java interfaces
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4566691
By: vransmayr
#@-node:ekr.20071014112331:Made sure java scanner works with java interfaces
#@+node:ekr.20071019072034:Fixed bugs in Java parser
@nocolor

> When I tried to open the 'old' outline w/ the java-interfaces imported as
@auto-nodes Leo 'crashed'. That is using pythonw.exe did not open the outline.

Thanks for this report.  As I understand the rest of the trace, the following files did not import properly:

AdminPermission.java 
BundleEvent.java 
BundleException.java 
BundlePermission.java 
FrameworkEvent.java 
FrameworkUtil.java 
InvalidSyntaxException.java 
package.html 
packageinfo 
PackagePermission.java 
ServiceEvent.java 
ServicePermission.java 
Version.java

That should be enough to get me started :-)

Edward

Read and respond to this message at:
https://sourceforge.net/forum/message.php?msg_id=4576575
By: vransmayr

Hi Edward,

  I'm replying to this thread and not to

http://sourceforge.net/forum/message.php?msg_id=4576197

because I guess that it's not a Java-specific problem.

For the record: I performed a CVS update just before the exercise.

When I tried to open the 'old' outline w/ the java-interfaces imported
as @auto-nodes
Leo 'crashed'. - That is using "pythonw.exe ..." did not open the outline.

When I modified the windows explorer to open outlines w/ "python.exe" I received
the
following output.

<cmd shell output>

reading settings in C:\CVS-Reps\leo\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Frameworks\
OSGi\OSGi\r41\OSGi-Core-Framework-r41.leo
reading C:\Dokumente und Einstellungen\VR\.leoRecentFiles.txt
@enabled-plugins found in myLeoSettings.leo
rst3 plugin: SilverCity not loaded
loadOnePlugin: no init() detect_urls
loadOnePlugin: no init() empty_leo_file
redefining close-window in all to extend-to-word in all
redefining goto-first-node in tree to goto-first-visible-node in tree
redefining goto-first-node in tree to goto-first-visible-node in all
redefining goto-first-node in tree to goto-first-visible-node in all
redefining forward-sentence in text to propagate-key-event in all
redefining forward-word in text to propagate-key-event in all
redefining kill-region-save in all to propagate-key-event in all
*** first mismatch at line 79
original line:  u'\tstatic final long\t\t\t\t\tserialVersionUID\t=
3070510045212
61705L;\n'
generated line: '    private static class ImplHolder implements
PrivilegedAction
{\n'
@auto did not import the file perfectly
first mismatched line: 79
'    private static class ImplHolder implements PrivilegedAction {\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\AdminPermission.java
*** first mismatch at line 41
original line:  u'\tstatic final long\t\tserialVersionUID\t=
4080640865971756012
L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 41
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\BundleEvent.java
*** first mismatch at line 38
original line:  u'\tstatic final long\tserialVersionUID\t=
3571095144220455665L;
\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 38
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\BundleException.java
*** first mismatch at line 51
original line:  u'\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 51
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\BundlePermission.java
*** first mismatch at line 41
original line:  u'\tstatic final long\t\tserialVersionUID\t=
207051004521261705L
;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 41
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\FrameworkEvent.java
*** first mismatch at line 37
original line:  u'\t/*\n'
generated line: '    private static class ImplHolder implements
PrivilegedAction
{\n'
@auto did not import the file perfectly
first mismatched line: 37
'    private static class ImplHolder implements PrivilegedAction {\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\FrameworkUtil.java
*** first mismatch at line 38
original line:  u'\tstatic final long\t\tserialVersionUID\t=
-429519442081649187
5L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 38
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\InvalidSyntaxException.j
ava
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\package.html
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\packageinfo
*** first mismatch at line 50
original line:  u'\tstatic final long\t\t\tserialVersionUID\t=
-5107705877071099
135L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 50
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\PackagePermission.java
*** first mismatch at line 41
original line:  u'\tstatic final long\t\t\t\tserialVersionUID\t=
879290148390940
9299L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 41
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\ServiceEvent.java
*** first mismatch at line 43
original line:  u'\tstatic final long\t\t\tserialVersionUID\t=
-7662148639076511
574L;\n'
generated line: '    /**\n'
@auto did not import the file perfectly
first mismatched line: 43
'    /**\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\ServicePermission.java
*** first mismatch at line 46
original line:  u'\tprivate final int\t\t\tmajor;\n'
generated line: '    public static final Version\temptyVersion\t=
new Version(0,
0, 0);\n'
@auto did not import the file perfectly
first mismatched line: 46
'    public static final Version\temptyVersion\t= new Version(0, 0, 0);\n'
inserting @ignore
Errors inhibited read @auto C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Fra
meworks\OSGi\OSGi\r41\.\OSGI-OPT\src\org\osgi\framework\Version.java

</cmd shell output>

Kind regards,

Viktor
#@-node:ekr.20071019072034:Fixed bugs in Java parser
#@+node:ekr.20071019171754:Suppressed "invalid @+leo sentinel" when importing java
#@+node:ekr.20031218072017.3300:removeSentinelsCommand
def removeSentinelsCommand (self,paths,toString=False):

    c = self.c

    self.setEncoding()

    for fileName in paths:
        g.setGlobalOpenDir(fileName)
        path, self.fileName = g.os_path_split(fileName)
        << Read file into s >>
        << set delims from the header line >>
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        if toString:
            return s
        else:
            << Write s into newFileName >>
            return None
#@+node:ekr.20031218072017.3301:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@-node:ekr.20031218072017.3301:<< Read file into s >>
#@+node:ekr.20031218072017.3302:<< set delims from the header line >>
# Skip any non @+leo lines.
i = 0
while i < len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
if not valid:
    if not toString: g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
#@-node:ekr.20031218072017.3302:<< set delims from the header line >>
#@+node:ekr.20031218072017.1149:<< Write s into newFileName >>
try:
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    theFile = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    if not g.unitTesting:
        g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()
#@-node:ekr.20031218072017.1149:<< Write s into newFileName >>
#@-node:ekr.20031218072017.3300:removeSentinelsCommand
#@-node:ekr.20071019171754:Suppressed "invalid @+leo sentinel" when importing java
#@+node:ekr.20071016124052:Handled nested classes, interface and namespaces properly
#@+node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.classIndent = 0 # The indentation of the start of the class.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]
    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:@test pr
if False or g.unitTesting:
    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:@test pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace only from the classHead and trailing parts.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        ref +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = start = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    # if kind =='class' and g.match(s,i,self.outerBlockDelim1):
        # end = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        # start = i = i + len(self.outerBlockDelim1)
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) > self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent > self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = root = parent.copy()
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@+node:ekr.20071023082323:@test run
if g.unitTesting:

    ic = c.importCommands
    ic.methodName = 'test' ; ic.fileType = '.py'

    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()
    parent = p.copy()

    s = '''\
def spam():
    pass
'''
    s = g.adjustTripleString(s,-4)

    runner.run(s,parent)
#@-node:ekr.20071023082323:@test run
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:edreamleo.20070710110114.1:C scanner
#@+node:edreamleo.20070710110153:scanCText
def scanCText (self,s,parent,atAuto=False):

    scanner = self.cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110153:scanCText
#@+node:edreamleo.20070710093042:class cScanner (baseScannerClass)
class cScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = '#' # A hack: treat preprocess directives as comments(!)
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = ['*']
        self.sigFailTokens = [';','=']
#@-node:edreamleo.20070710093042:class cScanner (baseScannerClass)
#@-node:edreamleo.20070710110114.1:C scanner
#@+node:ekr.20071008130845:C# scanner
#@+node:ekr.20071008130845.1:scanCSharpText
def scanCSharpText (self,s,parent,atAuto=False):

    scanner = self.cSharpScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071008130845.1:scanCSharpText
#@+node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
class cSharpScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class','interface','namespace',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = []
        self.sigFailTokens = [';','='] # Just like C.
#@-node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
#@-node:ekr.20071008130845:C# scanner
#@+node:ekr.20070711060107:Elisp scanner
#@+node:ekr.20070711060107.1:scanElispText
def scanElispText (self,s,parent,atAuto=False):

    scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070711060107.1:scanElispText
#@+node:ekr.20070711060113:class elispScanner (baseScannerClass)
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False
    end = self.skipBlock(s,i)
    if not g.match(s,end,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len(key)
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner (baseScannerClass)
#@-node:ekr.20070711060107:Elisp scanner
#@+node:edreamleo.20070710110114:Java scanner
#@+node:edreamleo.20070710110114.2:scanJavaText
def scanJavaText (self,s,parent,atAuto=False):

    scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110114.2:scanJavaText
#@+node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
class javaScanner (baseScannerClass):

    @others
#@+node:ekr.20071019171430:javaScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
#@-node:ekr.20071019171430:javaScanner.__init__
#@+node:ekr.20071019170943:javaScanner.skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return i, ids and ids[-1]
#@-node:ekr.20071019170943:javaScanner.skipSigId
#@-node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
#@-node:edreamleo.20070710110114:Java scanner
#@+node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711104241.2:scanPascalText
def scanPascalText (self,s,parent,atAuto=False):

    scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@nonl
#@-node:ekr.20070711104241.2:scanPascalText
#@+node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
class pascalScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='pascal')

        # Set the parser delims.
        self.blockCommentDelim1 = '(*'
        self.blockCommentDelim2 = '*)'
        self.lineCommentDelim = '//'
        self.blockDelim1 = 'begin'
        self.blockDelim2 = 'end'
        self.classTags = []
        self.functionTags = ['function','procedure','constructor','destructor',]
#@-node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
#@-node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

    if scanner.isPurePHP(s):
        scanner.run(s,parent)
    else:
        fileName = scanner.fileName
        if not atAuto:
            g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
        scanner.createHeadline(
            parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php or ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return self.skipString()
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
#@-node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070703122141.99:scanPythonText
def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070703122141.99:scanPythonText
#@+node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
class pythonScanner (baseScannerClass):

    @others
#@+node:ekr.20070703122141.101: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

#@-node:ekr.20070703122141.101: __init__
#@+node:ekr.20070707113839:extendSignature
def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j < len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
#@-node:ekr.20070707113839:extendSignature
#@+node:ekr.20070707073627.4:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
#@-node:ekr.20070707073627.4:skipString
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@+node:ekr.20070803101619:skipSigTail
# This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
#@-node:ekr.20070803101619:skipSigTail
#@-node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
#@-node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070713075352:Default scanner
def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    if atAuto:
        for p in p.self_and_subtree_iter():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
#@-node:ekr.20070713075352:Default scanner
#@-node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.classIndent = 0 # The indentation of the start of the class.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]
    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:@test pr
if False or g.unitTesting:
    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:@test pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace only from the classHead and trailing parts.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        ref +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = start = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    # if kind =='class' and g.match(s,i,self.outerBlockDelim1):
        # end = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        # start = i = i + len(self.outerBlockDelim1)
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) > self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent > self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = root = parent.copy()
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@+node:ekr.20071023082323:@test run
if g.unitTesting:

    ic = c.importCommands
    ic.methodName = 'test' ; ic.fileType = '.py'

    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()
    parent = p.copy()

    s = '''\
def spam():
    pass
'''
    s = g.adjustTripleString(s,-4)

    runner.run(s,parent)
#@-node:ekr.20071023082323:@test run
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = start = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    # if kind =='class' and g.match(s,i,self.outerBlockDelim1):
        # end = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        # start = i = i + len(self.outerBlockDelim1)
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) > self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent > self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace only from the classHead and trailing parts.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        ref +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
class javaScanner (baseScannerClass):

    @others
#@+node:ekr.20071019171430:javaScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
#@-node:ekr.20071019171430:javaScanner.__init__
#@+node:ekr.20071019170943:javaScanner.skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return i, ids and ids[-1]
#@-node:ekr.20071019170943:javaScanner.skipSigId
#@-node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@-node:ekr.20071016124052:Handled nested classes, interface and namespaces properly
#@+node:ekr.20071020054649:Fixed problem with @auto files w/o extension
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4579298
By: vransmayr

However, with the plain text file w/o any suffix, a problem still exists:
when I modify it and save the outline it is not written back to the original file.

The fix was to make anything more than 10 characters 'significant', and write a
message when the @auto node contains insignificant text.

@color
#@nonl
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t)
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
def writeAtAutoNodes (self,event=None):

    '''Write all @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)

def writeDirtyAtAutoNodes (self,event=None):

    '''Write all dirty @auto nodes in the selected outline.'''

    at = self
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
#@nonl
#@+node:ekr.20070806140208:writeAtAutoNodesHelper
def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString,force=True)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
#@-node:ekr.20070806140208:writeAtAutoNodesHelper
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@-node:ekr.20070806105859:writeAtAutoNodes & writeDirtyAtFileNodes (atFile) & helpers
#@-node:ekr.20071020054649:Fixed problem with @auto files w/o extension
#@+node:ekr.20071020065730:Better c# tests
#@+node:ekr.20071008130824:c# syntax ref card
@language csharp

csharpfriends.com c# community

// CLASS1.CS -- Syntax-at-a-Glance for the C# programming language.
// A quick code reference for programmers who work in many languages.
// Executable code, minimal comments document the essence of the language.
// Copyright (C) 2001 StructureByDesign.  All Rights Reserved.

using System;
using System.Collections;
using System.IO;

namespace StructureByDesign.Syntax
{
/********************************************************************/
public class Class1: Object
{
    public static int Main(string[] args)       // Entry point.
    {
        System.Console.WriteLine("Hello");
        Class2 aclass2 = new Class2();
        aclass2.run();
        return 0;
    }
}

/********************************************************************/
interface Interface1
{
    void run();
}

/********************************************************************/
class Class2: Class1, Interface1
{
    public const int CONSTANT = 1;          // Access not restricted, implicitly static.
    private int m_intPrivateField;          // Access limited to containing type.
    //////////////////////////////////////////////////////////////
    public Class2() : base()                // Constructor.
    {
        initialize();
    }
    //////////////////////////////////////////////////////////////
    protected void initialize()             // Object initialization.
    {                                       // Access limited to containing class or types derived.
        Number = 1;
    }
    //////////////////////////////////////////////////////////////
    protected int Number                    // Language property feature.
    {
        get
        {
            return m_intPrivateField;
        }
        set
        {
            m_intPrivateField = value;      // Implicit parameter.
        }
    }
    //////////////////////////////////////////////////////////////
    public void run()
    {
        anonymousCode();
        arrays();
        collections();
        comparison();
        control();
        filesStreamsAndExceptions();
        numbersAndMath();
        primitivesAndConstants();
        runtimeTyping();
        strings();
    }
    //////////////////////////////////////////////////////////////
    void anonymousCode()
    {
        Delegate adelegate = new Delegate(Run);
        adelegate();
    }
    delegate void Delegate();
    void Run()
    {
        Console.WriteLine("Run");
    }
    //////////////////////////////////////////////////////////////
    void arrays()
    {
        int[] arrayOfInts = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        arrayOfInts[0] = 9;
        assert(arrayOfInts[0] == arrayOfInts[9]);

        String[] arrayOfStrings = new String[10];
        assert(arrayOfStrings[0] == null);
        assert(arrayOfStrings.Length == 10);

        arrayOfStrings = new String[] { "one", "two" };

        byte[,] arrayOfBytes = { {0,0,0},
                                 {0,1,2},
                                 {0,2,4}};
        assert(arrayOfBytes[2,2] == 4);
    }
    //////////////////////////////////////////////////////////////
    void collections()
    {
        IList ailist = new ArrayList();
        ailist.Add("zero"); ailist.Add("one"); ailist.Add("three");
        ailist[2] = "two";
        assert(ailist[2].Equals("two"));
        ailist.Remove("two");
        ((ArrayList)ailist).Sort();
        for(IEnumerator aie = ((ArrayList)ailist).GetEnumerator(); aie.MoveNext(); )
            ;
        foreach(String astring in ailist)
            ;

        IDictionary aidictionary = new Hashtable();
        aidictionary.Add("key", "value");
        assert(aidictionary["key"].Equals("value"));

        // Set not available.
    }
    //////////////////////////////////////////////////////////////
    void comparison()
    {
        int aint1 = 1;
        int aint2 = 2;
        int aint = 1;
        String astring1 = "one";
        String astring2 = "two";
        String astring = astring1;

        assert(aint == aint1);
        assert(aint1 != aint2);
        assert(astring == astring1);
        assert(astring1 == String.Copy("one"));         // For strings == is overloaded to compare values.
        assert(!astring1.Equals(astring2));
        assert(astring1.Equals(String.Copy("one")));

        astring = null;
        if (astring != null && astring.Length > 0)      // Conditional evaluation.
            assert(false);

        if (aint2 < 0 || 1 < aint2)
            assert(true);
    }
    //////////////////////////////////////////////////////////////
    void control()
    {
        if (true)
            assert(true);
        else
            assert(false);
        /////
        switch ('b') {
            case 'a':
                assert(false);
                break;
            case 'b':
                assert(true);
                break;
            default:
                assert(false);
                break;
        }
        /////
        for (int ai1 = 0; ai1 < 10; ai1++)
            assert(true);
        /////
        int ai = 0;
        while (ai < 10) {
            assert(true);
            ai++;
        }
        /////
        do
            ai--;
        while (ai > 0);
        /////
        for (int x = 0; x < 10; x++)        // Labeled break/continue not available.
            for (int y = 0; y < 10; y++)
                if (x == 9)
                    break;
                else
                    continue;
    }
    //////////////////////////////////////////////////////////////
    void filesStreamsAndExceptions()
    {
        FileInfo afileinfo = new FileInfo("list.txt");
        try {
            StreamWriter asw = new StreamWriter("list.txt");
            asw.WriteLine("line");
            asw.WriteLine("line");
            asw.Close();

            assert(afileinfo.Exists);

            StreamReader asr = new StreamReader("list.txt");
            String astringLine;
            while ((astringLine = asr.ReadLine()) != null)
                assert(astringLine.Equals("line"));
            asr.Close();
        } catch (IOException aexception) {
            System.Console.WriteLine(aexception.Message);
            throw new NotSupportedException();
        }
        finally {
            afileinfo.Delete();
        }
    }
    //////////////////////////////////////////////////////////////
    void numbersAndMath()
    {
        assert(Int32.Parse("123") == 123);
        assert(123.ToString().Equals("123"));

        assert(Math.PI.ToString("n3").Equals("3.142"));

        assert(Int32.MaxValue < Int64.MaxValue);

        assert(Math.Abs(Math.Sin(0) - 0) <= Double.Epsilon);
        assert(Math.Abs(Math.Cos(0) - 1) <= Double.Epsilon);
        assert(Math.Abs(Math.Tan(0) - 0) <= Double.Epsilon);

        assert(Math.Abs(Math.Sqrt(4) - 2) <= Double.Epsilon);
        assert(Math.Abs(Math.Pow(3,3) - 27) <= Double.Epsilon);

        assert(Math.Max(0,1) == 1);
        assert(Math.Min(0,1) == 0);

        assert(Math.Abs(Math.Ceiling(9.87) - 10.0) <= Double.Epsilon);
        assert(Math.Abs(Math.Floor(9.87) - 9.0) <= Double.Epsilon);
        assert(Math.Round(9.87) == 10);

        Random arandom = new Random();
        double adouble = arandom.NextDouble();
        assert(0.0 <= adouble && adouble < 1.0);
        int aint = arandom.Next(10);
        assert(0 <= aint && aint < 10);
    }
    //////////////////////////////////////////////////////////////
    enum Season: byte { Spring=0, Summer, Fall, Winter };

    void primitivesAndConstants()
    {
        bool abool = false;
        char achar = 'A';           // 16 bits, Unicode

        byte abyte = 0x0;           // 8 bits, unsigned, hex constant
        sbyte asbyte = 0;           // 8 bits, signed

        short ashort = 0;           // 16 bits, signed
        ushort aushort = 0;         // 16 bits, unsigned

        int aint = 0;               // 32 bits, signed
        uint aunit = 0;             // 32 bits, unsigned

        long along = 0L;            // 64 bits, signed
        ulong aulong = 0;           // 64 bits, unsigned

        float afloat = 0.0F;        // 32 bits
        double adouble = 0.0;       // 64 bits

        decimal adecimal = 0;       // 128 bits, financial calculations

        Season aseason = Season.Fall;
        assert((byte)aseason == 2);
    }
    //////////////////////////////////////////////////////////////
    void runtimeTyping()
    {
        assert(new int[] { 1 } is int[]);
        assert(new ArrayList() is ArrayList);

        assert((new ArrayList()).GetType() == typeof(ArrayList));
        assert(typeof(Int32) is Type);      // Type of primitive type.

        assert(Type.GetType("System.Collections.ArrayList") == typeof(ArrayList));
    }
    //////////////////////////////////////////////////////////////
    void strings()
    {
        String astring1 = "one";
        String astring2 = "TWO";

        assert((astring1 + "/" + astring2).Equals("one/TWO"));
        assert(astring2.ToLower().Equals("two"));   // Equals ignoring case not available.
        assert(astring1.Length == 3);
        assert(astring1.Substring(0,2).Equals("on"));
        assert(astring1[2] == 'e');
        assert(astring1.ToUpper().Equals("ONE"));
        assert(astring2.ToLower().Equals("two"));
        assert(astring1.CompareTo("p") < 0);
        assert(astring1.IndexOf('e') == 2);
        assert(astring1.IndexOf("ne") == 1);
        assert(astring1.Trim().Length == astring1.Length);

        assert(Char.IsDigit('1'));
        assert(Char.IsLetter('a'));
        assert(Char.IsWhiteSpace('\t'));
        assert(Char.ToLower('A') == 'a');
        assert(Char.ToUpper('a') == 'A');
    }
    //////////////////////////////////////////////////////////////
    private void assert(bool abool)
    {
        if (!abool)
            throw new Exception("assert failed");
    }
}
}

#@-node:ekr.20071008130824:c# syntax ref card
#@+node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.classIndent = 0 # The indentation of the start of the class.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]
    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:@test pr
if False or g.unitTesting:
    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:@test pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace only from the classHead and trailing parts.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        ref +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = start = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    # if kind =='class' and g.match(s,i,self.outerBlockDelim1):
        # end = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        # start = i = i + len(self.outerBlockDelim1)
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) > self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent > self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = root = parent.copy()
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@+node:ekr.20071023082323:@test run
if g.unitTesting:

    ic = c.importCommands
    ic.methodName = 'test' ; ic.fileType = '.py'

    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()
    parent = p.copy()

    s = '''\
def spam():
    pass
'''
    s = g.adjustTripleString(s,-4)

    runner.run(s,parent)
#@-node:ekr.20071023082323:@test run
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:edreamleo.20070710110114.1:C scanner
#@+node:edreamleo.20070710110153:scanCText
def scanCText (self,s,parent,atAuto=False):

    scanner = self.cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110153:scanCText
#@+node:edreamleo.20070710093042:class cScanner (baseScannerClass)
class cScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = '#' # A hack: treat preprocess directives as comments(!)
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = ['*']
        self.sigFailTokens = [';','=']
#@-node:edreamleo.20070710093042:class cScanner (baseScannerClass)
#@-node:edreamleo.20070710110114.1:C scanner
#@+node:ekr.20071008130845:C# scanner
#@+node:ekr.20071008130845.1:scanCSharpText
def scanCSharpText (self,s,parent,atAuto=False):

    scanner = self.cSharpScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071008130845.1:scanCSharpText
#@+node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
class cSharpScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class','interface','namespace',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = []
        self.sigFailTokens = [';','='] # Just like C.
#@-node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
#@-node:ekr.20071008130845:C# scanner
#@+node:ekr.20070711060107:Elisp scanner
#@+node:ekr.20070711060107.1:scanElispText
def scanElispText (self,s,parent,atAuto=False):

    scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070711060107.1:scanElispText
#@+node:ekr.20070711060113:class elispScanner (baseScannerClass)
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False
    end = self.skipBlock(s,i)
    if not g.match(s,end,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len(key)
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner (baseScannerClass)
#@-node:ekr.20070711060107:Elisp scanner
#@+node:edreamleo.20070710110114:Java scanner
#@+node:edreamleo.20070710110114.2:scanJavaText
def scanJavaText (self,s,parent,atAuto=False):

    scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110114.2:scanJavaText
#@+node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
class javaScanner (baseScannerClass):

    @others
#@+node:ekr.20071019171430:javaScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
#@-node:ekr.20071019171430:javaScanner.__init__
#@+node:ekr.20071019170943:javaScanner.skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return i, ids and ids[-1]
#@-node:ekr.20071019170943:javaScanner.skipSigId
#@-node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
#@-node:edreamleo.20070710110114:Java scanner
#@+node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711104241.2:scanPascalText
def scanPascalText (self,s,parent,atAuto=False):

    scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@nonl
#@-node:ekr.20070711104241.2:scanPascalText
#@+node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
class pascalScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='pascal')

        # Set the parser delims.
        self.blockCommentDelim1 = '(*'
        self.blockCommentDelim2 = '*)'
        self.lineCommentDelim = '//'
        self.blockDelim1 = 'begin'
        self.blockDelim2 = 'end'
        self.classTags = []
        self.functionTags = ['function','procedure','constructor','destructor',]
#@-node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
#@-node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

    if scanner.isPurePHP(s):
        scanner.run(s,parent)
    else:
        fileName = scanner.fileName
        if not atAuto:
            g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
        scanner.createHeadline(
            parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php or ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return self.skipString()
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
#@-node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070703122141.99:scanPythonText
def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070703122141.99:scanPythonText
#@+node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
class pythonScanner (baseScannerClass):

    @others
#@+node:ekr.20070703122141.101: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

#@-node:ekr.20070703122141.101: __init__
#@+node:ekr.20070707113839:extendSignature
def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j < len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
#@-node:ekr.20070707113839:extendSignature
#@+node:ekr.20070707073627.4:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
#@-node:ekr.20070707073627.4:skipString
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@+node:ekr.20070803101619:skipSigTail
# This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
#@-node:ekr.20070803101619:skipSigTail
#@-node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
#@-node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070713075352:Default scanner
def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    if atAuto:
        for p in p.self_and_subtree_iter():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
#@-node:ekr.20070713075352:Default scanner
#@-node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = start = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    # if kind =='class' and g.match(s,i,self.outerBlockDelim1):
        # end = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        # start = i = i + len(self.outerBlockDelim1)
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) > self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent > self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace only from the classHead and trailing parts.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        ref +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@-node:ekr.20071020065730:Better c# tests
#@+node:ekr.20071020073107:Don't include leo directives in count of significant characters
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@-node:ekr.20071020073107:Don't include leo directives in count of significant characters
#@+node:ekr.20071023083446:Made sure @auto import failure does result in writing the file
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')

    if ic.errors or not g.os_path_exists(fileName):
        c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
#@nonl
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@-node:ekr.20071023083446:Made sure @auto import failure does result in writing the file
#@-node:ekr.20071016120719:Fixed several @auto bugs
#@+node:ekr.20071019065431:Installed patch to fix Fedora Tk.Text bug
@nocolor

https://sourceforge.net/forum/message.php?msg_id=4576436
By: thyrsus

I found that the effect on the current CVS of Mr. Ignatov's Fedora 7 crash fix
was that if you moved from a node that had text to a node that didn't have text,
the text window would not be blanked.  I instead use this workaround in Code-->Gui
Tkinter classes-->@thin leoTkinterFrame.py-->class leoTkTextWidget
(Tk.Text)-->Wrapper methods (leoTextWidget)-->setAllText (diff taken on
leoTkinterFrame.py).

In case anyone has forgotten: this change is a workaround to a python bug that
so far has only been distributed with Fedora Core 7.  I have reported the bug
to the Fedora Core 7 folks, but they're presumably busy with other things.
It's possible the problem is actually the responsibility of the python maintainers,
in which case they'll either fix it or it will start showing up in other Linux
distributions :-/

***************
*** 3380,3386 ****
          Tk.Text.configure(w,state="normal")

          Tk.Text.delete(w,'1.0','end')
!        Tk.Text.insert(w,'1.0',s)

          Tk.Text.configure(w,state=state)
#@verbatim
      #@-node:ekr.20061113151148.20:setAllText
--- 3376,3382 ----
          Tk.Text.configure(w,state="normal")

          Tk.Text.delete(w,'1.0','end')
!        if s: Tk.Text.insert(w,'1.0',s)

          Tk.Text.configure(w,state=state)
#@verbatim
      #@-node:ekr.20061113151148.20:setAllText

@color
#@+node:ekr.20061113151148.20:setAllText
def setAllText (self,s): # tkTextWidget

    w = self

    state = Tk.Text.cget(w,"state")
    Tk.Text.configure(w,state="normal")

    Tk.Text.delete(w,'1.0','end')
    if s: Tk.Text.insert(w,'1.0',s) # The 'if s:' is a workaround for a fedora bug.

    Tk.Text.configure(w,state=state)
#@-node:ekr.20061113151148.20:setAllText
#@-node:ekr.20071019065431:Installed patch to fix Fedora Tk.Text bug
#@+node:ekr.20071021110417:Fixed new rst3 problem
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4565216
By: hemanthps

I forgot to mention. I use the following options in my top @rst node.
@ @rst-options
code_mode=True
doc_only_mode=False
default_path =
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=False
stylesheet_path=./
write_intermediate_file = True
verbose=True
show_doc_parts_as_paragraphs=True
show_markup_doc_parts=True
underline_characters = #=+*^~"'`-:><_
@c

Remaining nit:
Even though I specify @language c in my @nosent myfile.c node, the generated
rst from this plugin has
.. code-block:: Python

In Plugins-->Text formatting-->rst3-->@thin rst3.py-->class rstClass-->write
methods--> Top-level write code-->initWrite of leoPlugins.leo, there is a line,
language = d.get('language','').lower()
in function initWrite(). But I could not yet figure out how to fill the value
'c' in that dictionary instead of the default "Python".
#@nonl
#@-node:ekr.20071021110417:Fixed new rst3 problem
#@+node:ekr.20071019202447:Fixed bugs when running unit tests externally
@nocolor
@
The run-unit-tests command runs tests using the bridge, which uses a nullGui and a stringTextWidget.

Apparently, this causes problem for unit tests:

1. Added a hack to g.getScript so it always gets the script from p.bodyString
   when g.app.gui.inBridge is True. 

2. Several unit tests fail when run from the bridge.

Both of these problems are symptoms of bugs either in c.frame.body.bodyCtrl (a
stringTextWidget) or in the code (especially c.frame.tree.select) that inits the
text widget.

@color
#@nonl
#@+node:ekr.20031218072017.1934:run
def run(fileName=None,pymacs=None,jyLeo=False,*args,**keywords):

    """Initialize and run Leo"""

    __pychecker__ = '--no-argsused' # keywords not used.

    if not jyLeo and not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    adjustSysPath(g)
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.batchMode = script is not None
    g.app.silentMode = '-silent' in sys.argv or '--silent' in sys.argv
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif jyLeo:
        import leoSwingGui
        g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
if jyLeo:

    print '*** starting jyLeo',sys.platform # will be something like java1.6.0_02

    ### This is a hack.
    ### The jyleo script in test.leo sets the cwd to g.app.loadDir
    ### Eventually, we will have to compute the equivalent here.

    path = os.path.join(os.getcwd()) ### ,'..','src')
    if path not in sys.path:
        print 'appending %s to sys.path' % path
        sys.path.append(path)
    if 0:
        print 'sys.path...'
        for s in sys.path: print s

# Import leoGlobals, but do NOT set g.
import leoGlobals
import leoApp

# Create the app.
leoGlobals.app = leoApp.LeoApp()

# **now** we can set g.
g = leoGlobals
assert(g.app)

if jyLeo:
    startJyleo(g)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
import leoNodes
import leoConfig

# try:
    # import leoNodes
# except ImportError:
    # print "Error importing leoNodes.py"
    # import traceback ; traceback.print_exc()

# try:
    # import leoConfig
# except ImportError:
    # print "Error importing leoConfig.py"
    # import traceback ; traceback.print_exc()
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@-node:ekr.20031218072017.1934:run
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
    c2.beginUpdate()
    try:
        self.copyRoot.expand()
        for p,limit,lookForMark,lookForNodes in (
            (p1,limit1,lookForMark1,lookForNodes1),
            (p2,limit2,lookForMark2,lookForNodes2),
        ):
            while p and p != limit:
                h = p.headString()
                if p.v.t in self.seen:
                    p.moveToNodeAfterTree()
                elif lookForMark and h.startswith(markTag):
                    self.addMarkTree(p)
                    p.moveToNodeAfterTree()
                elif lookForNodes and self.isUnitTestNode(p):
                    self.addNode(p)
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@nonl
#@+node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.currentPosition()
    if p.headString().startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@nonl
#@-node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
#@+node:ekr.20070705080413:addMarkTree
def addMarkTree (self,p):

    # g.trace(len(self.seen),p.headString())

    self.seen.append(p.v.t)

    for p in p.subtree_iter():
        if self.isUnitTestNode(p) and not p.v.t in self.seen:
            self.addNode(p)
#@-node:ekr.20070705080413:addMarkTree
#@+node:ekr.20070705065154.1:addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-test tree as the last child of self.copyRoot.
    '''

    # g.trace(len(self.seen),p.headString())

    p2 = p.copyTreeAfter()
    p2.unlink()
    p2.moveToLastChildOf(self.copyRoot)

    self.seen.append(p.v.t)
#@-node:ekr.20070705065154.1:addNode
#@+node:ekr.20070705075604.3:isUnitTestNode
def isUnitTestNode (self,p):

    h = p.headString()
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@-node:ekr.20070705075604.3:isUnitTestNode
#@-node:ekr.20070627135336.9:createOutline & helpers
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    if ' ' in path and sys.platform.startswith('win'): 
        path = '"' + path + '"'

    args = [sys.executable, path, '--silent']  

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = c.currentPosition()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.allNodes_iter():
        if p.headString().startswith('@mark-for-unit-test'):
            return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):

    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands ; w = c.frame.body.bodyCtrl
    if not p:
        p = c.currentPosition()
    try:
        if g.app.inBridge:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
#@+node:ekr.20050211100535:@test g.getScript strips crlf
if g.unitTesting:

    c,p = g.getTestVars() # Optional: prevents pychecker warnings.
    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@-node:ekr.20050211100535:@test g.getScript strips crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():

    import leoGlobals as g
    windowFlag = False

    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()

    # Bug fix 4/27/07: Don't put a return in a finally clause.
    return script, windowFlag
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20051104075904.4:doTests...
def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        for p in theIter:
            if isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p): # @suite
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5:class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6:__init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@-node:ekr.20051104075904.6:__init__
#@+node:ekr.20051104075904.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.7: fail
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20051104075904.9:tearDown
def tearDown (self):

    pass

    # To do: restore the outline.
#@-node:ekr.20051104075904.9:tearDown
#@+node:ekr.20051104075904.10:runTest
def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!

    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
#@-node:ekr.20051104075904.10:runTest
#@+node:ekr.20051104075904.11:shortDescription
def shortDescription (self):

    return self.p.headString() + '\n'
#@-node:ekr.20051104075904.11:shortDescription
#@-node:ekr.20051104075904.5:class generalTestCase
#@+node:ekr.20051104075904.12:makeTestSuite
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
#@-node:ekr.20051104075904.12:makeTestSuite
#@+node:ekr.20051104075904.13:makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
#@-node:ekr.20051104075904.13:makeTestCase
#@-node:ekr.20051104075904.4:doTests...
#@-node:ekr.20071019202447:Fixed bugs when running unit tests externally
#@-node:ekr.20070920083033:Bugs
#@+node:ekr.20070920083033.1:Features
#@+node:ekr.20070919124912:Added button-font params
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c ; f = self.iconFrame
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    # First define n.
    try:
        g.app.iconWidgetCount += 1
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 1

    if not command:
        def command():
            print "command for widget %s" % (n)

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        # elif sys.platform.startswith('win'):
            # width = max(6,len(text))
            # b.configure(width=width,font=('verdana',7,'bold'))
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@-node:ekr.20070919124912:Added button-font params
#@+node:ekr.20051202094427:Added resolve-cvs-conflicts and write-resolved-conflicts commands
@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1800071&forum_id=10226

Resolving conflictgs in .leo files is completely different from resolving
conflicts in derived files.

Let us use the term **conflict file** to denote a derived file that contains cvs
conflict markers (>>>>). Cvs conflict markers can corrupt sentinels by
duplicating or deleting sentinels, so Leo should not try to read or import files
containing conflicts.

@color
#@nonl
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&check-derived-file',
        '*check-leo-file',
        '-',
        '*&read-outline-only',
        '*write-&outline-only',
        '-',
        '*read-&file-into-node',
        '*writ&e-file-from-node',
        '-',
        ('Read @&auto Nodes','read-at-auto-nodes'),
        ('Write @a&uto Nodes','write-at-auto-nodes'),
        ('Write D&irty @a&uto Nodes','write-dirty-at-auto-nodes'),
        '-',
        ('Read @file &Nodes','read-at-file-nodes'),
        ('Write &Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &Missing @file Nodes','write-missing-at-file-nodes'),
        ('&Write @file Nodes','write-at-file-nodes'),
    ]

    # a,cd,e,f,i,l,m,n,o,r,u,w
#@nonl
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                << create the found node and begin the undo group >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)

    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@+node:ekr.20051113110735:<< create the found node and begin the undo group >>
u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110735:<< create the found node and begin the undo group >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20070915105000:Part 1: derived files: read-file-into-node & write-file-from-node
@nocolor

Conflicts involving derived files.

The **read-file-into-node** reads an entire into a single node.

The **write-file-from-node** command writes a file from a single node.

@color
#@nonl
#@+node:ekr.20070915134101:readFileIntoFile
def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)

    if fileName:    
        try:
            theFile = open(fileName,'r')
            s = theFile.read()
            s = '@nocolor\n' + s
            c.beginUpdate()
            try:
                w = c.frame.body.bodyCtrl
                p = c.insertHeadline(op_name=undoType)
                p.setHeadString('@read-file-into-node ' + fileName)
                p.v.setTnodeText(s)
                w.setAllText(s)
            finally:
                c.endUpdate()
        except:
            g.es("can not open:" + fileName)
#@-node:ekr.20070915134101:readFileIntoFile
#@+node:ekr.20070915142635:writeFileFromNode
def writeFileFromNode (self,event=None):

    # If node starts with @read-file-into-node, use the full path name in the headline.
    # Otherwise, prompt for a file name.

    c = self ; p = c.currentPosition()
    h = p.headString().rstrip()
    s = p.bodyString()
    tag = '@read-file-into-node'

    if h.startswith(tag):
        fileName = h[len(tag):].strip()
    else:
        fileName = None

    if not fileName:
        filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
        fileName = g.app.gui.runSaveFileDialog(
            initialfile=None,
            title='Write File From Node',
            filetypes=filetypes,
            defaultextension=None)
    if fileName:
        try:
            theFile = open(fileName,'w')
        except IOError:
            theFile = None
        if theFile:
            if s.startswith('@nocolor\n'):
                s = s[len('@nocolor\n'):]
            theFile.write(s)
            theFile.flush()
            g.es_print('wrote: %s' % (fileName),color='blue')
            theFile.close()
        else:
            g.es('can not write %s' % (fileName),color='red')
#@nonl
#@-node:ekr.20070915142635:writeFileFromNode
#@-node:ekr.20070915105000:Part 1: derived files: read-file-into-node & write-file-from-node
#@+node:ekr.20070919132643:Part 2: check-derived-file and check-leo-file commands
These commands will do a trial read of the file.
#@nonl
#@+node:ekr.20070919133659:checkDerivedFile (atFile)
def checkDerivedFile (self, event=None):  # based on atFile.read

    at = self ; c = at.c ; p = c.currentPosition() ; s = p.bodyString()

    # Create a dummy vnode as the root.
    fileName='check-derived-file'
    root_t = leoNodes.tnode()
    root_v = leoNodes.vnode(root_t)
    root = leoNodes.position(root_v)
    theFile = g.fileLikeObject(fromString=s)
    thinFile = at.scanHeaderForThin (theFile,fileName)
    # g.trace('thinFile',thinFile)
    at.initReadIvars(root,fileName,thinFile=thinFile)
    if at.errors: return
    at.openFileForReading(fileName,fromString=s)
    if not at.inputFile: return
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    if at.errors == 0:
        g.es_print('check-derived-file passed',color='blue')
#@-node:ekr.20070919133659:checkDerivedFile (atFile)
#@+node:ekr.20070919133659.1:checkLeoFile (fileCommands)
def checkLeoFile (self,event=None):

    fc = self ; c = fc.c ; p = c.currentPosition()

    # Put the body (minus the @nocolor) into the file buffer.
    s = p.bodyString() ; tag = '@nocolor\n'
    if s.startswith(tag): s = s[len(tag):]
    self.fileBuffer = s ; self.fileIndex = 0

    # Do a trial read.
    self.checking = True
    self.initReadIvars()
    c.loading = True # disable c.changed
    try:
        try:
            self.getAllLeoElements(fileName='check-leo-file',silent=False)
            g.es_print('check-leo-file passed',color='blue')
        except BadLeoFile, message:
            # g.es_exception()
            g.es_print('check-leo-file failed: %s' % str(message),color='red')
    finally:
        self.checking = False
        c.loading = False # reenable c.changed
#@-node:ekr.20070919133659.1:checkLeoFile (fileCommands)
#@-node:ekr.20070919132643:Part 2: check-derived-file and check-leo-file commands
#@+node:ekr.20070915105000.1:Part 3: .leo files: compare-leo-files
@nocolor

Conflicts involving .leo files.

In general, cvs conflict markers will make it impossible to read .leo files
without 'heroic' measures. Instead of using conflict inforamtion in the .leo.txt
file, Leo will simply compare the *unadulterated* .leo files.

It is easy to compare .leo files. Indeed, gnx's uniquely identify individual
nodes, so a simple pass over both files suffices to show which nodes appear in
both files, and which nodes appear in only one file. If we consider one file to
be the 'original' .leo file, and the other file to be the 'modified' .leo file,
we can then immediately see which nodes have been inserted (appear only in the
modified file), deleted (appear only in the original file) or changed (appear in
both files but with different headline or body text).

To resolve conflicts in .leo files, the user will do the following:

1. Open one of the unadulterated .leo files: this is the 'original' file.

2. Invoke the **compare-leo-files** command.  This will prompt for the 'modified' file.

This command will create a **comparison tree*, similar to the tree created by
the clone-find-all commands. This tree will have clones for all inserted,
deleted and changed nodes. The user modifies original outline as needed, then
saves the outline as usual. The comparison tree can then be deleted and the
original file saved.

@color
#@nonl
#@+node:ekr.20070920104110:compareLeoFiles
def compareLeoFiles (self,event):

    c = c1 = self.c ; w = c.frame.body.bodyCtrl

    # Prompt for the file to be compared with the present outline.
    filetypes = [("Leo files", "*.leo"),("All files", "*"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Compare .leo Files",filetypes=filetypes,defaultextension='.leo')
    if not fileName: return

    # Read the file into the hidden commander.
    c2 = self.createHiddenCommander(fileName)
    if not c2: return

    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)  
    inserted, deleted, changed = self.computeChangeDicts(d1,d2)
    self.dumpCompareNodes(fileName,c1.mFileName,inserted,deleted,changed)

    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(inserted,deleted,changed)
    c2.frame.destroySelf()
    g.app.gui.set_focus(c,w)


#@+node:ekr.20070921072608:computeChangeDicts
def computeChangeDicts (self,d1,d2):

    '''Compute inserted, deleted, changed dictionaries.'''

    inserted = {}
    for key in d2.keys():
        if not d1.get(key):
            inserted[key] = d2.get(key)

    deleted = {}
    for key in d1.keys():
        if not d2.get(key):
            deleted[key] = d1.get(key)

    changed = {}
    for key in d1.keys():
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.headString() != p2.headString() or p1.bodyString() != p2.bodyString():
                changed[key] = p1

    return inserted, deleted, changed
#@-node:ekr.20070921072608:computeChangeDicts
#@+node:ekr.20070921072910:createAllCompareClones & helper
def createAllCompareClones(self,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    c.beginUpdate()
    try:
        # Create parent node at the start of the outline.
        u = c.undoer ; undoType = 'Compare .leo Files'
        u.beforeChangeGroup(c.currentPosition(),undoType)
        undoData = u.beforeInsertNode(c.currentPosition())
        parent = c.currentPosition().insertAfter()
        c.setHeadString(parent,undoType)
        u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
        for d,kind in (
            (deleted,'deleted'),(inserted,'inserted'),(changed,'changed')
        ):
            self.createCompareClones(d,kind,parent)
        c.selectPosition(parent)
        u.afterChangeGroup(parent,undoType,reportFlag=True) 
    finally:
        c.endUpdate(False)
    c.redraw_now()
#@nonl
#@+node:ekr.20070921074410:createCompareClones
def createCompareClones (self,d,kind,parent):

    c = self.c # Always use the visible commander.

    if d.keys():
        parent = parent.insertAsLastChild()
        c.setHeadString(parent,kind)

        for key in d.keys():
            p = d.get(key)
            clone = p.clone()
            clone.moveToLastChildOf(parent)
#@-node:ekr.20070921074410:createCompareClones
#@-node:ekr.20070921072910:createAllCompareClones & helper
#@+node:ekr.20070921070101:createHiddenCommander
def createHiddenCommander(self,fileName):

    # Read the file into a hidden commander (Similar to g.openWithFileName).
    import leoGui
    import leoFrame
    import leoCommands

    nullGui = leoGui.nullGui('nullGui')
    frame = leoFrame.nullFrame('nullFrame',nullGui,useNullUndoer=True)
    c2 = leoCommands.Commands(frame,fileName)
    theFile,c2.isZipped = g.openLeoOrZipFile(fileName)
    if theFile:
        c2.fileCommands.open(theFile,fileName,readAtFileNodesFlag=True,silent=True)
        return c2
    else:
        return None
#@nonl
#@-node:ekr.20070921070101:createHiddenCommander
#@+node:ekr.20070921070101.1:createFileDict
def createFileDict (self,c):

    '''Create a dictionary of all relevant positions in commander c.'''

    d = {}
    for p in c.allNodes_iter():
        try:
            # fileIndices for pre-4.x versions of .leo files have a different format.
            i,j,k = p.v.t.fileIndex
            d[str(i),str(j),str(k)] = p.copy()
        except Exception:
            pass
    return d
#@-node:ekr.20070921070101.1:createFileDict
#@+node:ekr.20070921072608.1:dumpCompareNodes
def dumpCompareNodes (self,fileName1,fileName2,inserted,deleted,changed):

    for d,kind in (
        (inserted,'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        print ; print kind
        for key in d.keys():
            p = d.get(key)
            print '%-32s %s' % (key,g.toEncodedString(p.headString(),'ascii'))
#@-node:ekr.20070921072608.1:dumpCompareNodes
#@-node:ekr.20070920104110:compareLeoFiles
#@-node:ekr.20070915105000.1:Part 3: .leo files: compare-leo-files
#@-node:ekr.20051202094427:Added resolve-cvs-conflicts and write-resolved-conflicts commands
#@+node:ekr.20070927044711:Added @buttons trees in @settings trees
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):

    self.c = c

    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultMenuFontSize = g.app.config.defaultMenuFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize

    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)

    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):

    c = self.c

    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041119204714:visitNode (settingsTreeParser)
def visitNode (self,p):

    """Init any settings found in node p."""

    # g.trace(p.headString())

    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    if kind == "settings":
        pass
    elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all basic types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind

    return None
#@-node:ekr.20041119204714:visitNode (settingsTreeParser)
#@+node:ekr.20041118053731:Getters (c.configSettings)
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getAbbrevDict(self):         return g.app.config.getAbbrevDict(self.c)
def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getButtons   (self):         return g.app.config.buttonsList # unusual.
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getMenusList (self):         return g.app.config.menusList # unusual.
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getOpenWith  (self):         return g.app.config.getOpenWith (self.c)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting,):return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@-node:ekr.20041118053731:Getters (c.configSettings)
#@+node:ekr.20070925144337:doButtons
def doButtons (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    aList = [] ; c = self.c ; tag = '@button'
    for p in p.subtree_iter():
        h = p.headString()
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.headString(),script),)

    # g.trace(g.listToString([h for h,script in aList]))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.buttonsList = aList
    g.app.config.buttonsFileName = c and c.shortFileName() or '<no settings file>'

#@-node:ekr.20070925144337:doButtons
#@+node:ekr.20041119203941.2:<< class parserBaseClass >>
class parserBaseClass:

    """The base class for settings parsers."""

    << parserBaseClass data >>

    @others
#@+node:ekr.20041121130043:<< parserBaseClass data >>
# These are the canonicalized names.  Case is ignored, as are '_' and '-' characters.

basic_types = [
    # Headlines have the form @kind name = var
    'bool','color','directory','int','ints',
    'float','path','ratio','shortcut','string','strings']

control_types = [
    'abbrev','enabledplugins','font','if','ifgui','ifplatform','ignore','mode',
    'openwith','page','settings','shortcuts',
    'buttons','menus', # New in Leo 4.4.4.
    ]

# Keys are settings names, values are (type,value) tuples.
settingsDict = {}
#@-node:ekr.20041121130043:<< parserBaseClass data >>
#@+node:ekr.20041119204700: ctor (parserBaseClass)
def __init__ (self,c):

    self.c = c
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    self.openWithList = []
        # A list of dicts containing 'name','shortcut','command' keys.

    # Keys are canonicalized names.
    self.dispatchDict = {
        'abbrev':       self.doAbbrev, # New in 4.4.1 b2.
        'bool':         self.doBool,
        'buttons':      self.doButtons, # New in 4.4.4
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'enabledplugins': self.doEnabledPlugins,
        'font':         self.doFont,
        'if':           self.doIf,
        # 'ifgui':        self.doIfGui,  # Removed in 4.4 b3.
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'menus':        self.doMenus, # New in 4.4.4
        'mode':         self.doMode, # New in 4.4b1.
        'openwith':     self.doOpenWith, # New in 4.4.3 b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        # 'shortcut':     self.doShortcut, # Removed in 4.4.1 b1.
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }
#@-node:ekr.20041119204700: ctor (parserBaseClass)
#@+node:ekr.20060102103625:createModeCommand
def createModeCommand (self,name,modeDict):

    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')

    # g.trace(name,len(modeDict.keys()))

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [commandName] = modeDict
#@-node:ekr.20060102103625:createModeCommand
#@+node:ekr.20041120103012:error
def error (self,s):

    print s

    # Does not work at present because we are using a null Gui.
    g.es(s,color="blue")
#@-node:ekr.20041120103012:error
#@+node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20060608221203:doAbbrev
def doAbbrev (self,p,kind,name,val):

    d = {}
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseAbbrevLine(line)
            if name: d [val] = name

    self.set (p,'abbrev','abbrev',d)
#@-node:ekr.20060608221203:doAbbrev
#@+node:ekr.20041120094940.1:doBool
def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.1:doBool
#@+node:ekr.20070925144337:doButtons
def doButtons (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    aList = [] ; c = self.c ; tag = '@button'
    for p in p.subtree_iter():
        h = p.headString()
        if g.match_word(h,0,tag):
            # We can not assume that p will be valid when it is used.
            script = g.getScript(c,p,useSelectedText=False,forcePythonSentinels=True,useSentinels=True)
            aList.append((p.headString(),script),)

    # g.trace(g.listToString([h for h,script in aList]))

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    g.app.config.buttonsList = aList
    g.app.config.buttonsFileName = c and c.shortFileName() or '<no settings file>'

#@-node:ekr.20070925144337:doButtons
#@+node:ekr.20041120094940.2:doColor
def doColor (self,p,kind,name,val):

    # At present no checking is done.
    val = val.lstrip('"').rstrip('"')
    val = val.lstrip("'").rstrip("'")

    self.set(p,kind,name,val)
#@-node:ekr.20041120094940.2:doColor
#@+node:ekr.20041120094940.3:doDirectory & doPath
def doDirectory (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
#@-node:ekr.20041120094940.3:doDirectory & doPath
#@+node:ekr.20070224075914:doEnabledPlugins
def doEnabledPlugins (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c
    s = p.bodyString()

    # This setting is handled differently from all other settings,
    # because the last setting must be retrieved before any commander exists.

    # g.trace('len(s)',len(s))

    # Set the global config ivars.
    g.app.config.enabledPluginsString = s
    g.app.config.enabledPluginsFileName = c and c.shortFileName() or '<no settings file>'
#@-node:ekr.20070224075914:doEnabledPlugins
#@+node:ekr.20041120094940.6:doFloat
def doFloat (self,p,kind,name,val):

    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.6:doFloat
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind not used.

    d = self.parseFont(p)

    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120103933:doIf
def doIf(self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
#@-node:ekr.20041120103933:doIf
#@+node:ekr.20041121125416:doIfGui
@ Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
@c

if 0:

    def doIfGui (self,p,kind,name,val):

        __pychecker__ = '--no-argsused' # args not used.

        # g.trace(repr(name))

        if not g.app.gui or not g.app.gui.guiName():
            s = '@if-gui has no effect: g.app.gui not defined yet'
            g.es_print(s,color='blue')
            return "skip"
        elif g.app.gui.guiName().lower() == name.lower():
            return None
        else:
            return "skip"
#@-node:ekr.20041121125416:doIfGui
#@+node:ekr.20041120104215:doIfPlatform
def doIfPlatform (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # args not used.

    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
#@-node:ekr.20041120104215:doIfPlatform
#@+node:ekr.20041120104215.1:doIgnore
def doIgnore(self,p,kind,name,val):

    return "skip"
#@-node:ekr.20041120104215.1:doIgnore
#@+node:ekr.20041120094940.5:doInt
def doInt (self,p,kind,name,val):

    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041120094940.5:doInt
#@+node:ekr.20041217132253:doInts
def doInts (self,p,kind,name,val):

    '''We expect either:
    @ints [val1,val2,...]aName=val
    @ints aName[val1,val2,...]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')

    # g.trace(kind,name,val)

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[:i]+name[j+1:].strip()
        # g.trace(name,items)
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041217132253:doInts
#@+node:ekr.20070925144337.2:doMenus & helper
def doMenus (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c ; aList = [] ; tag = '@menu'
    p = p.copy() ; after = p.nodeAfterTree()
    while p and p != after:
        h = p.headString()
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    # self.dumpMenuList(aList)
    # g.trace(g.listToString(aList))
    # g.es_print('creating menu from %s' % (c.shortFileName()),color='blue')
    g.app.config.menusList = aList
    g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            print
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helper
#@+node:ekr.20060102103625.1:doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    __pychecker__ = '--no-argsused' # val not used.

    c = self.c ; k = c.k

    # g.trace('%20s' % (name),c.fileName())
    << Compute modeName >>

    # Create a local shortcutsDict.
    old_d = self.shortcutsDict
    d = self.shortcutsDict = {}

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if not name:
                # An entry command: put it in the special *entry-commands* key.
                aList = d.get('*entry-commands*',[])
                aList.append(bunch.entryCommandName)
                d ['*entry-commands*'] = aList
            elif bunch is not None:
                # A regular shortcut.
                bunch.val = k.strokeFromSetting(bunch.val)
                bunch.pane = modeName
                bunchList = d.get(name,[])
                # Important: use previous bindings if possible.
                key2,bunchList2 = c.config.getShortcut(name)
                bunchList3 = [b for b in bunchList2 if b.pane != modeName]
                if bunchList3:
                    # g.trace('inheriting',[b.val for b in bunchList3])
                    bunchList.extend(bunchList3)
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)

    # Restore the global shortcutsDict.
    self.shortcutsDict = old_d

    # Create the command, but not any bindings to it.
    self.createModeCommand(modeName,d)
#@+node:ekr.20060618110649:<< Compute modeName >>
name = name.strip().lower()
j = name.find(' ')
if j > -1: name = name[:j]
if name.endswith('mode'):
    name = name[:-4].strip()
if name.endswith('-'):
    name = name[:-1]
modeName = name + '-mode'
#@-node:ekr.20060618110649:<< Compute modeName >>
#@-node:ekr.20060102103625.1:doMode (ParserBaseClass)
#@+node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
def doOpenWith (self,p,kind,name,val):

    # g.trace('kind',kind,'name',name,'val',val,'c',self.c)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
#@-node:ekr.20070411101643.1:doOpenWith (ParserBaseClass)
#@+node:ekr.20041120104215.2:doPage
def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
#@-node:ekr.20041120104215.2:doPage
#@+node:ekr.20041121125741:doRatio
def doRatio (self,p,kind,name,val):

    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@-node:ekr.20041121125741:doRatio
#@+node:ekr.20041120105609:doShortcuts (ParserBaseClass)
def doShortcuts(self,p,kind,name,val,s=None):

    __pychecker__ = '--no-argsused' # kind,val.

    # g.trace(self.c.fileName(),name)

    c = self.c ; d = self.shortcutsDict
    if s is None: s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            if bunch is not None:
                # A regular shortcut.
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)
#@-node:ekr.20041120105609:doShortcuts (ParserBaseClass)
#@+node:ekr.20041217132028:doString
def doString (self,p,kind,name,val):

    # At present no checking is done.
    self.set(p,kind,name,val)
#@-node:ekr.20041217132028:doString
#@+node:ekr.20041120094940.8:doStrings
def doStrings (self,p,kind,name,val):

    '''We expect one of the following:
    @strings aName[val1,val2...]=val
    @strings [val1,val2,...]aName=val'''

    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[:i]+name[j+1:].strip()
        kind = "strings[%s]" % (','.join(items))
        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@-node:ekr.20041120094940.8:doStrings
#@-node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20041124063257:munge
def munge(self,s):

    return g.app.config.canonicalizeSettingName(s)
#@-node:ekr.20041124063257:munge
#@+node:ekr.20041119204700.2:oops
def oops (self):
    print ("parserBaseClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@-node:ekr.20041119204700.2:oops
#@+node:ekr.20041213082558:parsers
#@+node:ekr.20041213083651:fontSettingNameToFontKind
def fontSettingNameToFontKind (self,name):

    s = name.strip()
    if s:
        for tag in ('_family','_size','_slant','_weight'):
            if s.endswith(tag):
                return tag[1:]

    return None
#@-node:ekr.20041213083651:fontSettingNameToFontKind
#@+node:ekr.20041213082558.1:parseFont & helper
def parseFont (self,p):

    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)

    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)

    return d
#@+node:ekr.20041213082558.2:parseFontLine
def parseFontLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip()
            val = s[i+1:].strip()
            val = val.lstrip('"').rstrip('"')
            val = val.lstrip("'").rstrip("'")

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
#@-node:ekr.20041213082558.2:parseFontLine
#@-node:ekr.20041213082558.1:parseFont & helper
#@+node:ekr.20041119205148:parseHeadline
def parseHeadline (self,s):

    """Parse a headline of the form @kind:name=val
    Return (kind,name,val)."""

    kind = name = val = None

    if g.match(s,0,'@'):
        i = g.skip_id(s,1,chars='-')
        kind = s[1:i].strip()
        if kind:
            # name is everything up to '='
            j = s.find('=',i)
            if j == -1:
                name = s[i:].strip()
            else:
                name = s[i:j].strip()
                # val is everything after the '='
                val = s[j+1:].strip()

    # g.trace("%50s %10s %s" %(name,kind,val))
    return kind,name,val
#@-node:ekr.20041119205148:parseHeadline
#@+node:ekr.20070411101643.2:parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
#@+node:ekr.20070411101643.4:parseOpenWithLine
def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
#@-node:ekr.20070411101643.4:parseOpenWithLine
#@-node:ekr.20070411101643.2:parseOpenWith & helper
#@+node:ekr.20041120112043:parseShortcutLine (g.app.config)
def parseShortcutLine (self,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name -> mode-name = binding
    command-name -> same = binding
    '''

    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        return None,g.Bunch(entryCommandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)
#@-node:ekr.20041120112043:parseShortcutLine (g.app.config)
#@+node:ekr.20060608222828:parseAbbrevLine (g.app.config)
def parseAbbrevLine (self,s):

    '''Parse an abbreviation line:
    command-name = abbreviation
    return (command-name,abbreviation)
    '''

    i = j = g.skip_ws(s,0)
    i = g.skip_id(s,i,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None

    i = g.skip_ws(s,i)
    if not g.match(s,i,'='): return None,None

    i = g.skip_ws(s,i+1)
    val = s[i:].strip()
    # Ignore comments after the shortcut.
    i = val.find('#')
    if i > -1: val = val[:i].strip()

    if val: return name,val
    else:   return None,None
#@-node:ekr.20060608222828:parseAbbrevLine (g.app.config)
#@-node:ekr.20041213082558:parsers
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    __pychecker__ = '--no-argsused' # p used in subclasses, not here.

    c = self.c ; key = self.munge(name)
    # if kind and kind.startswith('setting'): g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d [key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')

#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,bunch):

    c = self.c

    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",bunch)

    # g.trace(bunch.pane,rawKey,bunch.val)
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            if 0:
                s = 'skipping settings in %s' % p.headString()
                g.es_print(s,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041120094940.10:valueError
def valueError (self,p,kind,name,val):

    """Give an error: val is not valid for kind."""

    __pychecker__ = '--no-argsused' # p not used, but needed.

    self.error("%s is not a valid %s for %s" % (val,kind,name))
#@-node:ekr.20041120094940.10:valueError
#@+node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
def visitNode (self,p):

    __pychecker__ = '--no-argsused' # p not used, but needed.

    self.oops()
#@-node:ekr.20041119204700.3:visitNode (must be overwritten in subclasses)
#@-node:ekr.20041119203941.2:<< class parserBaseClass >>
#@-node:ekr.20070927044711:Added @buttons trees in @settings trees
#@+node:ekr.20070925144337.1:Added @menus trees in @settings trees
#@+node:ekr.20031218072017.3751: leoMenu.__init__
def __init__ (self,frame):

    # g.trace('leoMenu',g.callers())

    self.c = c = frame.c
    self.frame = frame
    self.menus = {} # Menu dictionary.
    self.menuShortcuts = {}

    # To aid transition to emacs-style key handling.
    self.useCmdMenu = c.config.getBool('useCmdMenu')

    self.newBinding = True
        # True if using new binding scheme.
        # You can set this to False in an emergency to revert to the old way.

    if 0: # Must be done much later.
        self.defineMenuTables()
#@-node:ekr.20031218072017.3751: leoMenu.__init__
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('c',self.c)

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if type(data) in (type(''),type(u'')): # Bug fix: 10/10/07: Allow unicode labels.
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20070925144337.2:doMenus & helper
def doMenus (self,p,kind,name,val):

    __pychecker__ = '--no-argsused' # kind,name,val not used.

    c = self.c ; aList = [] ; tag = '@menu'
    p = p.copy() ; after = p.nodeAfterTree()
    while p and p != after:
        h = p.headString()
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # This setting is handled differently from most other settings,
    # because the last setting must be retrieved before any commander exists.
    # self.dumpMenuList(aList)
    # g.trace(g.listToString(aList))
    # g.es_print('creating menu from %s' % (c.shortFileName()),color='blue')
    g.app.config.menusList = aList
    g.app.config.menusFileName = c and c.shortFileName() or '<no settings file>'
#@+node:ekr.20070926141716:doItems
def doItems (self,p,aList):

    p = p.copy() ; after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        h = p.headString()
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.bodyString()
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.headString())
            p.moveToThreadNext()
#@nonl
#@-node:ekr.20070926141716:doItems
#@+node:ekr.20070926142312:dumpMenuList
def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            print
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)
#@nonl
#@-node:ekr.20070926142312:dumpMenuList
#@-node:ekr.20070925144337.2:doMenus & helper
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):

    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):

    self.editMenuTopTable = [
        # &: u,r reserved for undo/redo: a,d,p,t,y.
        # & (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&t','cut-text'),
        ('Cop&y','copy-text'),
        ('&Paste','paste-text'),
        ('&Delete','backward-delete-char'),
        ('Select &All','select-all'),
        '-',
    ]
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):

    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&section',
        '*extract-&names',
        '*&extract',
        '-',
        '*convert-all-b&lanks',
        '*convert-all-t&abs',
        '*convert-&blanks',
        '*convert-&tabs',
        '*insert-body-&time',
        '*&reformat-paragraph',
        '-',
        '*&indent-region',
        '*&unindent-region',
        '*&match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):

    self.editMenuEditHeadlineTable = [
        '*edit-&headline',
        '*&end-edit-headline',
        '*&abort-edit-headline',
        '*insert-headline-&time',
        '*toggle-&angle-brackets',
    ]
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):

    self.editMenuFindMenuTable = [
        # &: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&open-find-tab',
        '*&hide-find-tab',
        '*search-&with-present-options',
        '-',
        '*find-&next',
        '*find-&prev',
        '*&change',
        '*find-&all',
        '*clone-fi&nd-all',
        '*change-a&ll',
        '-',
        '*&find-character',
        '*find-character-extend-&selection',
        '*&backward-find-character',
        '*backward-find-character-&extend-selection',
        '-',
        '*&isearch-forward',
        '*isea&rch-backward',
        '*isearch-forward-rege&xp',
        '*isearch-backward-regex&p',
        '-',
        '*&query-replace',
        '*q&uery-replace-regex',
    ]
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):

    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")

    self.editMenuTop2Table = [
        '*&goto-global-line',
        '*&execute-script',
        (label,'toggle-invisibles'),
        ("Setti&ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):

    self.fileMenuTopTable = [
        '*&new',
        ('&Open...','open-outline'),
    ]
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):

    self.fileMenuTop2Table = [
        '-',
        ('&Close','close-window'),
        ('&Save','save-file'),
        ('Save &As','save-file-as'),
        ('Save As &Unzipped','save-file-as-unzipped'),
        ('Save As &Zipped','save-file-as-zipped'),
        ('Save &To','save-file-to'),
        ('Re&vert To Saved','revert'),
    ]
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&check-derived-file',
        '*check-leo-file',
        '-',
        '*&read-outline-only',
        '*write-&outline-only',
        '-',
        '*read-&file-into-node',
        '*writ&e-file-from-node',
        '-',
        ('Read @&auto Nodes','read-at-auto-nodes'),
        ('Write @a&uto Nodes','write-at-auto-nodes'),
        ('Write D&irty @a&uto Nodes','write-dirty-at-auto-nodes'),
        '-',
        ('Read @file &Nodes','read-at-file-nodes'),
        ('Write &Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &Missing @file Nodes','write-missing-at-file-nodes'),
        ('&Write @file Nodes','write-at-file-nodes'),
    ]

    # a,cd,e,f,i,l,m,n,o,r,u,w
#@nonl
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):

    self.fileMenuTangleMenuTable = [
        '*tangle-&all',
        '*tangle-&marked',
        '*&tangle',
    ]
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):

    self.fileMenuUntangleMenuTable = [
        '*untangle-&all',
        '*untangle-&marked',
        '*&untangle',
    ]
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):

    self.fileMenuImportMenuTable = [
        #&: c,d,f,n,o,r,
        '*import-&derived-file',
        ('Import To @&file','import-at-file'),
        ('Import To @&root','import-at-root'),
        '*import-&cweb-files',
        '*import-&noweb-files',
        '*import-flattened-&outline',
    ]
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):

    self.fileMenuExportMenuTable = [
        '*export-&headlines',
        '*outline-to-&cweb',
        '*outline-to-&noweb',
        '*&flatten-outline',
        '*&remove-sentinels',
        '*&weave',
    ]
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):

    self.fileMenuTop3MenuTable = [
        ('E&xit','exit-leo'),
    ]
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&ut-node',
        '*c&opy-node',
        '*&paste-node',
        ('Pas&te Node As Clone','paste-retaining-clones'),
        '*&delete-node',
        '-',
        '*&insert-node',
        '*&clone-node',
        '*sort-childre&n',
        '*&sort-siblings',
        '-',
        '*&hoist',
        ('D&e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):

    self.outlineMenuCheckOutlineMenuTable = [
        # &: a,c,d,l,o
        '*check-&outline',
        '*&dump-outline',
        '-',
        '*compare-&leo-files',
        '-',
        '*check-&all-python-code',
        '*&check-python-code',
    ]
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):

    self.outlineMenuExpandContractMenuTable = [
        '*&contract-all',
        '*contract-&node',
        '*contract-&parent',
        '*contract-or-go-&left',
        '-',
        '*expand-p&rev-level',
        '*expand-n&ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&1',
        '*expand-to-level-&2',
        '*expand-to-level-&3',
        '*expand-to-level-&4',
        '*expand-to-level-&5',
        '*expand-to-level-&6',
        '*expand-to-level-&7',
        '*expand-to-level-&8',
        '-',
        '*expand-&all',
        '*expand-n&ode',
    ]
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):

    self.outlineMenuMoveMenuTable = [
        ('Move &Down','move-outline-down'),
        ('Move &Left','move-outline-left'),
        ('Move &Right','move-outline-right'),
        ('Move &Up','move-outline-up'),
        '-',
        '*&promote',
        '*&demote',
    ]
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):

    self.outlineMenuMarkMenuTable = [
        '*&mark',
        '*mark-&subheads',
        '*mark-changed-&items',
        '*mark-changed-&roots',
        '*mark-&clones',
        '*&unmark-all',
    ]
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &: a,b,c,d,e,f,g,h,i,l,m,n,o,p,r,s,t,v,
        ('Go To &First Node','goto-first-node'),
        ('Go To First V&isible','goto-first-visible-node'),
        ('Go To First Si&bling','goto-first-sibling'),
        '-',
        ('Go To Next C&hanged','goto-next-changed'),
        ('Go To Next &Clone','goto-next-clone'),
        ('Go To Next &Marked','goto-next-marked'),
        ('Go To Next N&ode','goto-next-node'),
        ('Go To Next &Sibling','goto-next-sibling'),
        ('Go To Next Visibl&e','goto-next-visible'),
        ('Go To Next Visite&d','go-forward'),
        '-',
        ('Go To P&arent','goto-parent'),
        '-',
        ('Go To &Prev Node','goto-prev-node'),
        ('Go To P&rev Sibling','goto-prev-sibling'),
        ('Go To Pre&v Visible','goto-prev-visible'),
        ('Go To Prev Visi&ted','go-back'),
        '-',
        ('Go To Last Node','goto-last-node'),
        ('Go To Last Siblin&g','goto-last-sibling'),
        ('Go To &Last Visible','goto-last-visible-node'),
    ]
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):

    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuChaptersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()
#@nonl
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
def defineCmdsMenuAbbrevTable (self):

    self.cmdsMenuAbbrevTable = [
        # &: a,e,i,k,l,r,w,v
        'abbre&v-mode',
        '-',
        '&list-abbrevs',
        '&read-abbrev-file',
        '&write-abbrev-file',
        '-',
        '&add-global-abbrev',
        '&inverse-add-global-abbrev',
        '&kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&expand-region-abbrevs',
    ]
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
#@+node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &: a,c,d
        '&add-editor',
        '&cycle-editor-focus',
        '&delete-editor',
    ]
#@nonl
#@-node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&append-to-buffer',
        '&kill-buffer',
        'list-&buffers',
        '&list-buffers-alphabetically',
        '&prepend-to-buffer',
        '&rename-buffer',
        '&switch-to-buffer',
    ]
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20070604205927:defineCmdsMenuChaptersTable
def defineCmdsMenuChaptersTable (self):

    self.cmdsMenuChaptersTable = [
        '&clone-node-to-chapter',
        'c&opy-node-to-chapter',
        'c&reate-chapter',
        '&move-node-to-chapter',
        '&remove-chapter',
        '&select-chapter',
    ]
#@-node:ekr.20070604205927:defineCmdsMenuChaptersTable
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]

    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]

    self.cursorMenuExtendTable = [
        # &: l,p,s,w
        'extend-to-&line',
        'extend-to-&paragraph',
        'extend-to-&sentence',
        'extend-to-&word',
    ]

    self.cursorMenuForwardTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&end-word',
        'forward-&word',
        '-',
        '&next-line',
    ]

    self.cursorMenuForwardExtendTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&end-word-extend-selection',
        'forward-&word-extend-selection',#
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20060923060822:defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
#@-node:ekr.20060923060822:defineCmdsMenuFocusTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable
def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&load-file',
        '-',
        '&start-kbd-macro',
        '&end-kbd-macro',
        '&name-last-kbd-macro',
        '-',
        '&call-last-keyboard-macro',
        '&insert-keyboard-macro',
    ]
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable
#@+node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
def defineCmdsMenuMinibufferTable (self):

    self.cmdsMenuMinibufferTable = [
        # &: f,h,i,q,r,s,v
        '&full-command',
        'keyboard-&quit',
        '&repeat-complex-command',
        '&view-lossage',
        '-',
        '&show-mini-buffer',
        'h&ide-mini-buffer',
        '-',
        '&help-for-minibuffer',
    ]
#@-node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
#@+node:ekr.20061011085641:defineCmdsMenuPickersTable
def defineCmdsMenuPickersTable (self):

    self. cmdsMenuPickersTable = [
        'show-&colors',
        'show-find-&options',
        'show-&fonts',
    ]
#@nonl
#@-node:ekr.20061011085641:defineCmdsMenuPickersTable
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&clear-rectangle',
        'c&lose-rectangle',
        '&delete-rectangle',
        '&kill-rectangle',
        '&open-rectangle',
        '&string-rectangle',
        '&yank-rectangle',
    ]
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &: a,c,e,i,j,n,p,r,v
        '&append-to-register',
        'copy-r&ectangle-to-register',
        '&copy-to-register',
        'i&ncrement-register',
        '&insert-register',
        '&jump-to-register',
        # 'number-to-register',
        '&point-to-register',
        'p&repend-to-register',
        '&view-register',
    ]
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
#@+node:ekr.20061119061958:defineCmdsMenuRunTable
def defineCmdsMenuRunTable (self):

    self.cmdsMenuRunTable = [
    # &: e,r
    '&execute-script',
    '&run-unit-tests',
    ]
#@-node:ekr.20061119061958:defineCmdsMenuRunTable
#@+node:ekr.20060923060822.1:defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-&down',
        'scroll-&up',
        '-',
        'scroll-down-&extend-selection',
        'scroll-up-e&xtend-selection',
    ]
#@nonl
#@-node:ekr.20060923060822.1:defineCmdsMenuScrollTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&open-spell-tab',
        'spell-&change',
        'spell-change-&then-find',
        'spell-&find',
        'spell-&ignore',
    ]
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@+node:ekr.20060924161901:defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&beautify',
        'beautify-&all',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
#@nonl
#@-node:ekr.20060924161901:defineCmdsMenuTextTable
#@+node:ekr.20060926161940:defineCmdsMenuToggleTable
def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &: d,e,m,s,t,u,v
        'toggle-a&utocompleter',
        'toggle-call&tips',
        'toggle-&extend-mode',
        'toggle-input-&state',
        'toggle-in&visibles',
        'toggle-&mini-buffer',
        'toggle-split-&direction',
        '-',
        # &: a,b,c,f,h,i,r,w,x
        'toggle-find-&ignore-case-option',
        'toggle-find-in-&body-option',
        'toggle-find-in-&headline-option',
        'toggle-find-mark-&changes-option',
        'toggle-find-mark-&finds-option',
        'toggle-find-rege&x-option',
        'toggle-find-&reverse-option',
        'toggle-find-&word-option',
        'toggle-find-wrap-&around-option',
    ]
#@-node:ekr.20060926161940:defineCmdsMenuToggleTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):

    self.windowMenuTopTable = [
        # &: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&equal-sized-panes',
        '*&toggle-active-pane',
        '*toggle-&split-direction',
        '-',
        '*contract-&body-pane',
        '*contract-&log-pane',
        '*contract-&outline-pane',
        '*contract-&pane',
        '-',
        '*expand-bo&dy-pane',
        '*expand-lo&g-pane',
        '*expand-o&utline-pane',
        '*expand-pa&ne',
        '-',
        '*&fully-expand-body-pane',
        '*full&y-expand-log-pane',
        '*fully-e&xpand-outline-pane',
        '*fully-exp&and-pane',
        '-',
        '*&resize-to-screen',
        '*&cascade-windows',
        '*&minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&window',
    ]
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&debugging-commands',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@+node:ekr.20031218072017.3785:createMenusFromTables & helpers
def createMenusFromTables (self):

    c = self.c

    aList = c.config.getMenusList()
    if aList:
        self.createMenusFromConfigList(aList)
    else:
        self.defineMenuTables()

        self.createFileMenuFromTable()
        self.createEditMenuFromTable()
        self.createOutlineMenuFromTable()

        g.doHook("create-optional-menus",c=c)

        if self.useCmdMenu:
            self.createCmndsMenuFromTable()

        self.createWindowMenuFromTable()
        self.createHelpMenuFromTable()
#@+node:ekr.20031218072017.3790:createFileMenuFromTable
def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("Tan&gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:createFileMenuFromTable
#@+node:ekr.20031218072017.3786:createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:createEditMenuFromTable
#@+node:ekr.20031218072017.3797:createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:createOutlineMenuFromTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&Cmds')

    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Chapters...',        self.cmdsMenuChaptersTable),
        ('C&ursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('M&inibuffer',         self.cmdsMenuMinibufferTable),
        #('&Panes...',           self.cmdsMenuPanesTable),
        ('&Pickers...',         self.cmdsMenuPickersTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('R&un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,t,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &To...',                self.cursorMenuExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.3802:createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
#@-node:ekr.20031218072017.3802:createWindowMenuFromTable
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@+node:ekr.20070926135612:createMenusFromConfigList & helpers
def createMenusFromConfigList (self,aList):

    '''Create menus from dictionary d instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))
#@+node:ekr.20070927082205:createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
                table = []
            if not self.handleSpecialMenus(name,parentName):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
#@nonl
#@-node:ekr.20070927082205:createMenuFromConfigList
#@+node:ekr.20070927172712:handleSpecialMenus
def handleSpecialMenus (self,name,parentName):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.  createRecentFilesMenuItems will be called later.
        self.createNewMenu(name,parentName)
        c.recentFiles = c.config.getRecentFiles()
        return True
    else:
        return False
#@-node:ekr.20070927172712:handleSpecialMenus
#@-node:ekr.20070926135612:createMenusFromConfigList & helpers
#@-node:ekr.20031218072017.3785:createMenusFromTables & helpers
#@+node:ekr.20070926135612:createMenusFromConfigList & helpers
def createMenusFromConfigList (self,aList):

    '''Create menus from dictionary d instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))
#@+node:ekr.20070927082205:createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
                table = []
            if not self.handleSpecialMenus(name,parentName):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
#@nonl
#@-node:ekr.20070927082205:createMenuFromConfigList
#@+node:ekr.20070927172712:handleSpecialMenus
def handleSpecialMenus (self,name,parentName):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.  createRecentFilesMenuItems will be called later.
        self.createNewMenu(name,parentName)
        c.recentFiles = c.config.getRecentFiles()
        return True
    else:
        return False
#@-node:ekr.20070927172712:handleSpecialMenus
#@-node:ekr.20070926135612:createMenusFromConfigList & helpers
#@+node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
def createRecentFilesMenuItems (self):

    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    if not recentFilesMenu:
        g.trace('Recent Files Menu does not exist')
        return

    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)

    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)

    # Create all the other entries (a maximum of 36).
    accel_ch = string.digits + string.ascii_uppercase # Not a unicode problem.
    i = 0 ; n = len(accel_ch)
    for name in c.recentFiles[:n]:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        label = "%s %s" % (accel_ch[i],g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
#@-node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
#@-node:ekr.20070925144337.1:Added @menus trees in @settings trees
#@+node:ekr.20071002093247:Added convenience methods to a canvas log
@nocolor

Cvs now contains a createCanvas convenience method to create a canvas tab in the log pane.  Here is a sample script in test.leo:

log = c.frame.log ; tag = 'my-canvas'

w = log.canvasDict.get(tag)
if not w:
..w = log.createCanvas(tag)
..w.configure(bg='yellow')

log.selectTab(tag)

I have not added a corresponding minibuffer command: only scripts have any real use for canvas tabs at present.  I'm not going to do more work on this unless somebody has a real need for it.

For an introduction to what can be done with Tk canvas widgets, see:

http://www.pythonware.com/library/tkinter/introduction/

@color
#@+node:ekr.20071002143627:tkLog.createCanvasWidget
def createCanvasWidget (self,parentFrame):

    self.logNumber += 1

    w = Tk.Canvas(parentFrame)

    logBar = Tk.Scrollbar(parentFrame,name="logBar")
    w['yscrollcommand'] = logBar.set
    logBar['command'] = w.yview
    logBar.pack(side="right", fill="y")

    logXBar = Tk.Scrollbar(parentFrame,name='logXBar',orient="horizontal") 
    w['xscrollcommand'] = logXBar.set 
    logXBar['command'] = w.xview 
    logXBar.pack(side="bottom", fill="x")

    w.pack(expand=1, fill="both")

    # Set the background color.
    configName = 'log_canvas_pane_tab_background_color'
    bg = self.c.config.getColor(configName) or 'MistyRose1'
    try: w.configure(bg=bg)
    except Exception: pass # Could be a user error.

    return w
#@-node:ekr.20071002143627:tkLog.createCanvasWidget
#@+node:ekr.20071002143627.1:createCanvas
def createCanvas (self,tabName=None):

    c = self.c ; k = c.k

    if tabName is None:
        self.logNumber += 1
        tabName = 'Canvas %d' % self.logNumber

    tabFrame = self.nb.add(tabName)
    menu = self.makeTabMenu(tabName,allowRename=False)

    w = self.createCanvasWidget(tabFrame)

    self.canvasDict [tabName ] = w
    self.textDict [tabName] = None
    self.frameDict [tabName] = tabFrame

    self.setCanvasTabBindings(tabName,menu)

    return w
#@-node:ekr.20071002143627.1:createCanvas
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None,allowRename=True):

    '''Create a tab popup menu.'''

    # g.trace(tabName,g.callers())

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.

    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    menu.add_command(label='New CanvasTab',command=self.newCanvasTabFromMenu)

    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            return self.deleteTab(tabName)

        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)

        def renameTabCallback():
            return self.renameTabFromMenu(tabName)

        if allowRename:
            menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@+node:ekr.20051019140004.1:newTabFromMenu & newCanvasTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)

    # This is called by getTabName.
    def selectTabCallback (newName):
        return self.selectTab(newName)

    self.getTabName(selectTabCallback)

def newCanvasTabFromMenu (self):

    self.createCanvas()
#@-node:ekr.20051019140004.1:newTabFromMenu & newCanvasTabFromMenu
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):

    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)

    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('<Key>',       k.masterKeyHandler),
        ('<Button-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)

    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    tab.bind('<Button-1>',tabMenuClickCallback)
    tab.bind('<Button-3>',tabMenuRightClickCallback)

    k.completeAllBindingsForWidget(w)
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20071003090546:setCanvasTabBindings
def setCanvasTabBindings (self,tabName,menu):

    c = self.c ; tab = self.nb.tab(tabName)

    def tabMenuRightClickCallback(event,menu=menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    tab.bind('<Button-1>',tabMenuClickCallback)
    tab.bind('<Button-3>',tabMenuRightClickCallback)

#@-node:ekr.20071003090546:setCanvasTabBindings
#@-node:ekr.20071002093247:Added convenience methods to a canvas log
#@+node:ekr.20071004083334:Installed graphed.py plugin
#@-node:ekr.20071004083334:Installed graphed.py plugin
#@+node:ekr.20071005174441:Added insert-child command
#@+node:ekr.20071005173203.1:c.insertChild
def insertChild (self,event=None):

    '''Insert a node after the presently selected node.'''

    c = self

    return c.insertHeadline(event=event,op_name='Insert Child',as_child=True)
#@-node:ekr.20071005173203.1:c.insertChild
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()

    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (as_child or
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.selectPosition(p)
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@-node:ekr.20071005174441:Added insert-child command
#@+node:ekr.20071003123335:Improved yank and yank-pop commands
# New ekr bindings: Alt-Y: yank-pop.  Alt-Ctrl-Y: cycle-all-focus.

# - Option: add-ws-to-kill-ring (or kill-ws-adds-to-kill-ring)
#@+node:ekr.20050920084036.174:killBufferCommandsClass
class killBufferCommandsClass (baseEditCommandsClass):

    '''A class to manage the kill buffer.'''

    @others
#@+node:ekr.20050920084036.175: ctor & finishCreate
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.addWsToKillRing = c.config.getBool('add-ws-to-kill-ring')
    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.lastYankP = None # The position of the last item returned by iterateKillBuffer.
    self.reset = None
        # None, or the index of the next item to be returned in killBuffer by iterateKillBuffer.

def finishCreate (self):

    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k

    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
#@-node:ekr.20050920084036.175: ctor & finishCreate
#@+node:ekr.20050920084036.176: getPublicCommands
def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'kill-ws':                  self.killWs,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
#@-node:ekr.20050920084036.176: getPublicCommands
#@+node:ekr.20050920084036.183:addToKillBuffer
def addToKillBuffer (self,text):

    '''Insert the text into the kill buffer if force is True or
    the text contains something other than whitespace.'''

    if self.addWsToKillRing or text.strip():
        self.killBuffer = [z for z in self.killBuffer if z != text]
        self.killBuffer.insert(0,text)
#@-node:ekr.20050920084036.183:addToKillBuffer
#@+node:ekr.20050920084036.181:backwardKillSentence
def backwardKillSentence (self,event):

    '''Kill the previous sentence.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.181:backwardKillSentence
#@+node:ekr.20050920084036.180:backwardKillWord & killWord
def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20050920084036.180:backwardKillWord & killWord
#@+node:ekr.20051216151811:clearKillRing
def clearKillRing (self,event=None):

    '''Clear the kill ring.'''

    self.killBuffer = []
#@-node:ekr.20051216151811:clearKillRing
#@+node:ekr.20050920084036.185:getClipboard
def getClipboard (self,w):

    '''Return the contents of the clipboard.'''

    __pychecker__ = '--no-argsused' # w not used.

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except:
        g.es_exception()

    return None
#@-node:ekr.20050920084036.185:getClipboard
#@+node:ekr.20050920084036.184:iterateKillBuffer
class killBuffer_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def iterateKillBuffer (self):

    return self.killBuffer_iter_class(self.c)
#@+node:ekr.20071003160252.1:__init__ & __iter__
def __init__(self,c):

    # g.trace('iterateKillBuffer.__init')
    self.c = c
    self.index = 0 # The index of the next item to be returned.

def __iter__(self):

    return self
#@-node:ekr.20071003160252.1:__init__ & __iter__
#@+node:ekr.20071003160252.2:next
def next(self):

    commands = self.c.killBufferCommands
    aList = commands.killBuffer

    # g.trace(g.listToString([repr(z) for z in aList]))

    if not aList:
        self.index = 0
        return None

    if commands.reset is None:
        i = self.index
    else:
        i = commands.reset
        commands.reset = None

    if i < 0 or i >= len(aList): i = 0
    # g.trace(i)
    val = aList[i]
    self.index = i + 1
    return val
#@-node:ekr.20071003160252.2:next
#@-node:ekr.20050920084036.184:iterateKillBuffer
#@+node:ekr.20050920084036.178:kill
def kill (self,event,frm,to,undoType=None):

    '''A helper method for all kill commands.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.178:kill
#@+node:ekr.20071003183657:KillLine
def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins >= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j > i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
#@-node:ekr.20071003183657:KillLine
#@+node:ekr.20050920084036.182:killRegion & killRegionSave & helper
def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)

def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return

    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
#@-node:ekr.20050920084036.182:killRegion & killRegionSave & helper
#@+node:ekr.20050930095323.1:killSentence
def killSentence (self,event):

    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930095323.1:killSentence
#@+node:ekr.20050930100733:killWs
def killWs (self,event,undoType='kill-ws'):

    '''Kill whitespace.'''

    ws = ''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    i = j = ins = w.getInsertPoint()

    while i >= 0 and s[i] in (' ','\t'):
        i-= 1
    if i < ins: i += 1

    while j < len(s) and s[j] in (' ','\t'):
        j += 1

    if j > i:
        ws = s[i:j]
        # g.trace(i,j,repr(ws))
        w.delete(i,j)
        if undoType: self.beginCommand(undoType=undoType)
        if self.addWsToKillRing:
            self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930100733:killWs
#@+node:ekr.20050930091642.1:yank
def yank (self,event,pop=False):

    '''yank: insert the first entry of the kill ring.
    yank-pop: insert the next entry of the kill ring.
    '''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    current = c.currentPosition()
    if not current: return
    text = w.getAllText()
    i, j = w.getSelectionRange()
    clip_text = self.getClipboard(w)
    if not self.killBuffer and not clip_text: return

    undoType = g.choose(pop,'yank-pop','yank')
    self.beginCommand(undoType=undoType)
    try:
        if not pop or self.lastYankP and self.lastYankP != current:
            self.reset = 0
        s = self.kbiterator.next()
        if s is None: s = clip_text or ''
        if i != j: w.deleteTextSelection()
        if s != s.lstrip(): # s contains leading whitespace.
            i2,j2 = g.getLine(text,i)
            k = g.skip_ws(text,i2)
            if i2 < i <= k:
                # Replace the line's leading whitespace by s's leading whitespace.
                w.delete(i2,k)
                i = i2
        w.insert(i,s)
        w.setSelectionRange(i,i+len(s),insert=i+len(s))
        self.lastYankP = current.copy()
        c.frame.body.forceFullRecolor()
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930091642.1:yank
#@+node:ekr.20050930091642.2:yankPop
def yankPop (self,event):

    '''Insert the next entry of the kill ring.'''

    self.yank(event,pop=True)

#@-node:ekr.20050930091642.2:yankPop
#@+node:ekr.20050920084036.128:zapToCharacter
def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        if ch.isspace(): return
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.128:zapToCharacter
#@-node:ekr.20050920084036.174:killBufferCommandsClass
#@+node:ekr.20050920084036.184:iterateKillBuffer
class killBuffer_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def iterateKillBuffer (self):

    return self.killBuffer_iter_class(self.c)
#@+node:ekr.20071003160252.1:__init__ & __iter__
def __init__(self,c):

    # g.trace('iterateKillBuffer.__init')
    self.c = c
    self.index = 0 # The index of the next item to be returned.

def __iter__(self):

    return self
#@-node:ekr.20071003160252.1:__init__ & __iter__
#@+node:ekr.20071003160252.2:next
def next(self):

    commands = self.c.killBufferCommands
    aList = commands.killBuffer

    # g.trace(g.listToString([repr(z) for z in aList]))

    if not aList:
        self.index = 0
        return None

    if commands.reset is None:
        i = self.index
    else:
        i = commands.reset
        commands.reset = None

    if i < 0 or i >= len(aList): i = 0
    # g.trace(i)
    val = aList[i]
    self.index = i + 1
    return val
#@-node:ekr.20071003160252.2:next
#@-node:ekr.20050920084036.184:iterateKillBuffer
#@+node:ekr.20050920084036.183:addToKillBuffer
def addToKillBuffer (self,text):

    '''Insert the text into the kill buffer if force is True or
    the text contains something other than whitespace.'''

    if self.addWsToKillRing or text.strip():
        self.killBuffer = [z for z in self.killBuffer if z != text]
        self.killBuffer.insert(0,text)
#@-node:ekr.20050920084036.183:addToKillBuffer
#@+node:ekr.20050930091642.1:yank
def yank (self,event,pop=False):

    '''yank: insert the first entry of the kill ring.
    yank-pop: insert the next entry of the kill ring.
    '''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    current = c.currentPosition()
    if not current: return
    text = w.getAllText()
    i, j = w.getSelectionRange()
    clip_text = self.getClipboard(w)
    if not self.killBuffer and not clip_text: return

    undoType = g.choose(pop,'yank-pop','yank')
    self.beginCommand(undoType=undoType)
    try:
        if not pop or self.lastYankP and self.lastYankP != current:
            self.reset = 0
        s = self.kbiterator.next()
        if s is None: s = clip_text or ''
        if i != j: w.deleteTextSelection()
        if s != s.lstrip(): # s contains leading whitespace.
            i2,j2 = g.getLine(text,i)
            k = g.skip_ws(text,i2)
            if i2 < i <= k:
                # Replace the line's leading whitespace by s's leading whitespace.
                w.delete(i2,k)
                i = i2
        w.insert(i,s)
        w.setSelectionRange(i,i+len(s),insert=i+len(s))
        self.lastYankP = current.copy()
        c.frame.body.forceFullRecolor()
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930091642.1:yank
#@+node:ekr.20050930091642.2:yankPop
def yankPop (self,event):

    '''Insert the next entry of the kill ring.'''

    self.yank(event,pop=True)

#@-node:ekr.20050930091642.2:yankPop
#@-node:ekr.20071003123335:Improved yank and yank-pop commands
#@+node:ekr.20071009104339:Disabled unnecessary recolors
@nocolor

What I did:

- Fixed a major bug in findMarkAtIndex, the method that computes the starting point for incremental colorizing.  This was likely the source of the so-called 'docstring' bug.

- Rewrote and re-enabled the code in partialColor that determines when to end coloring. I suspect that the bug in findMarkAtIndex was making this code look more buggy than it was.

- Added the isSameColorState method in the threading colorizer (and a dummy in the old colorizer).  This allows the crucial node-switching code in treeSelectHelper to avoid colorizing a node if no real change has been made.  This can speed up the find command significantly when many matches occur in large body text.

@color
#@nonl
#@+node:ekr.20070423101911:treeSelectHelper
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def treeSelectHelper (self,p,updateBeadList,scroll):

    c = self.c ; frame = c.frame
    body = w = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p:
        # Bug fix: 5/31/07: do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    # g.trace('      ===',id(w),p and p.headString())
    if self.trace_select and not g.app.unitTesting: g.trace('tree',g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p,updateBeadList) # Remember this position.
    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
if not body: g.trace('no body!','c.frame',c.frame,'old_p',old_p)

yview = body.getYScrollPosition()
insertSpot = c.frame.body.getInsertPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.

s = g.toUnicode(p.v.t.bodyString,"utf-8")
old_s = w.getAllText()

if True and p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
    pass
else:
    # This destroys all color tags, so do a full recolor.
    w.setAllText(s)
    self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)

# g.trace("select:",p.headString())
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.headString())

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20070423101911:treeSelectHelper
#@-node:ekr.20071009104339:Disabled unnecessary recolors
#@+node:ekr.20071009145420:Improved (I hope) the rst3 plugin
Suppressed doc-part-delims when show_doc_parts_as_paragraphs is True
#@nonl
#@-node:ekr.20071009145420:Improved (I hope) the rst3 plugin
#@+node:ekr.20071010113431:Allow chinese characters work in @menus trees
#@+node:ekr.20070927082205:createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
                table = []
            if not self.handleSpecialMenus(name,parentName):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
#@nonl
#@-node:ekr.20070927082205:createMenuFromConfigList
#@+node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
# Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)

def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()
#@-node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
#@+node:ekr.20031218072017.3804:createNewMenu
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
#@-node:ekr.20031218072017.3804:createNewMenu
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    # g.trace('c',self.c)

    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if type(data) in (type(''),type(u'')): # Bug fix: 10/10/07: Allow unicode labels.
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    s = data
    removeHyphens = s and s[0]=='*'
    if removeHyphens: s = s[1:]
    label = self.capitalizeMinibufferMenuName(s,removeHyphens)
    command = s.replace('&','').lower()
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data

        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20071010113431:Allow chinese characters work in @menus trees
#@+node:ekr.20071010211808:Rewrote threading colorizer: hurray!
#@+node:ekr.20071010211707:Not used in new colorizer
#@+node:ekr.20071010211707.1:findMarkAtIndex
def findMarkAtIndex(self,d,i):

    '''Return the higest match that starts strictly before i.
    Return 0 if no such match.'''

    keys = d.keys()
    keys.sort()
    last_i = 0 
    for key in keys:
        if key >= i:
            break
        else:
            last_i = key

    if self.trace: g.trace('*******',last_i)
    return last_i
#@-node:ekr.20071010211707.1:findMarkAtIndex
#@+node:ekr.20071010211707.2:finishColoring
def finishColoring (self):

    if self.trace:
        g.trace('%d' % self.threadCount,'globalTagList',len(self.globalTagList))

    limit = 500

    if self.killFlag:
        tagList = []
        self.globalTagList = []
    else:
        tagList = self.globalTagList[:limit]
        self.globalTagList = self.globalTagList[limt:]
        self.tagAll(tagList)
#@nonl
#@-node:ekr.20071010211707.2:finishColoring
#@+node:ekr.20071010211707.3:partialColor (in helper thread)
def partialColor (self,s):

    '''Partially recolor s'''

    mid_i,tail_i,delta,all = self.computeIndices()
    if all:
        if self.trace: g.trace('*** all lines match: recolor all')
        return self.fullColor(s)

    d = self.marksDict = self.adjustMarksDict(self.marksDict,mid_i,tail_i,delta)
    assert(mid_i == 0 or s[mid_i-1] == '\n')
    i = self.findMarkAtIndex(d,max(0,mid_i-1))
    self.start_i = self.self_end_i = i
    # if mid_i-1 != i: g.trace('backtrack',repr(s[i:mid_i]))

    # Create a list of (i,n) pairs from marksDict.
    d = self.marksDict ; keys = d.keys() ; keys.sort()
    endList = [(z,d.get(z)) for z in keys if z + d.get(z) >= tail_i]
    self.marksDict = {}
    if self.trace: g.trace(self.language,'thread',self.threadCount,'i',i)
    while i < len(s):
        progress = i
        if self.c.frame not in g.app.windowList:
            # print 'threading_colorizer: partialColor: window killed'
            return
        if self.killFlag:
            if self.trace: g.trace('*** killed %d*' % self.threadCount)
            return
        # if i < 0 or i >= len(s):
            # g.trace('can not happen','i out of range',i)
        for f in self.rulesDict.get(s[i],[]):
            n = f(self,s,i)
            if n is None: g.trace('Can not happen: matcher returns None')
            elif n > 0:
                if (trace_all_matches) and f.__name__ != 'match_blanks':
                    g.trace(f.__name__,repr(s[i:i+n]))
                self.marksDict[i] = n
                i += n ; break
        else:
            i += 1
        if i > tail_i:
            << finish if no item in endList covers i >>
        assert progress < i
    self.end_i = i
    self.old_s = self.s
    if self.trace: g.trace('*** done',self.threadCount)
#@+node:ekr.20071010211707.4:<< finish if no item in endList covers i >>
done = False ; n = 0 # count of elements to be removed.
for z in endList:
    i2,n2 = z
    if i2 <= i:
        if i2 + n2 < i:
            n += 1 # strictly before i. Remove it below.
        else:
            break # covers i.  Not done.
    else: # i2 > i:
        done = True
    if done: # Add trailing items in endList to the marksDict.
        self.marksDict[i2] = n2
else:
    done = True

if done:
    if self.trace: g.trace('*** found end: i: %d %s' % (i,repr(s[i:i+20])))
    break
else:
    # Delete n entries from the front of endList.
    if n > 0:
        endList = endList[n:]
#@nonl
#@-node:ekr.20071010211707.4:<< finish if no item in endList covers i >>
#@-node:ekr.20071010211707.3:partialColor (in helper thread)
#@+node:ekr.20071010211707.5:adjustMarksDict
def adjustMarksDict (self,d,mid_i,tail_i,delta):

    '''Adjust the marksDict d by adding delta to
    all keys and values whose keys are >= mid_i.'''

    # Pass 1: Add changed items to d2, and delete them from d.
    # Important: missing entries do not cause bugs--
    # at worst they slow down the colorizer.
    # Thus, we err on the side of caution.
    d2 = {}
    for i in d.keys():
        if i > tail_i:
            # d2 [i+delta] = d.get(i) + delta
            if i + delta >= 0:
                val = d.get(i) + delta
                if val >= 0:
                    d2 [i+delta] = val
            del d[i]
        elif i >= mid_i:
            del d[i]

    # Pass 2: Insert changed items back into d.
    for i in d2.keys():
        d[i] = d2.get(i)

    return d
#@-node:ekr.20071010211707.5:adjustMarksDict
#@+node:ekr.20071010211707.6:removeTagsFromRange
def removeTagsFromRange(self,i,j):

    s = self.s ; w = self.w

    if self.trace: g.trace('i',i,'j',j)

    names = [z for z in w.tag_names() if z not in ('sel','insert')]

    x1,x2 = w.toGuiIndex(self.start_i,s=s), w.toGuiIndex(self.end_i,s=s)
    for tag in names:
        # g.trace(tag,x1,x2)
        w.tag_remove(tag,x1,x2)
#@-node:ekr.20071010211707.6:removeTagsFromRange
#@+node:ekr.20071010211707.7:computeIndices
def computeIndices (self):

    '''Return (mid_i,tail_i,delta,all) where
    - mid_i is the index of the start of the changed text,
    - tail_i is the index of the start of the **new** trailing lines,
    - delta is the change in the size of the changed text,
    - all is true if all text must be recolored.'''

    old_s,new_s = self.old_s,self.s

    # The first optimization: recolor **everything** if all lines match.
    # Some routines delete, then insert the text again, deleting all tags in the process.
    if old_s == new_s:
        all = True
        return 0,0,0,all

    # The second optimization. Check to see if only one line has changed.
    ins = self.insertPoint # We must *not* call Tk here!
    new_i,new_j = g.getLine(new_s,ins)
    old_i,old_j = g.getLine(old_s,new_i)
    new_head = new_s[:new_i]
    old_head = old_s[:old_i]
    new_tail = new_s[new_j:]
    old_tail = old_s[old_j:]
    #g.trace('new_head',repr(new_head),'\n','old_head',repr(old_head))
    #g.trace('new_tail',repr(new_tail),'\n','old_tail',repr(old_tail))
    if new_head == old_head and new_tail == old_tail:
        # g.trace('**one line changed')
        mid_i = new_i
        tail_i = new_j
        #new_line = new_s[new_i:new_j]
        #old_line = old_s[old_i:old_j]
        #delta = len(new_line) - len(old_line)
        delta = (new_j-new_i) - (old_j-old_i)
        all = False
        return mid_i,tail_i,delta,all

    # The general case: compare line-by line to find the head and tail.
    new_lines = g.splitLines(new_s)
    old_lines = g.splitLines(old_s)
    new_len = len(new_lines)
    old_len = len(old_lines)
    # Find the head lines, the leading matching lines.
    i = 0
    while i < new_len and i < old_len and old_lines[i] == new_lines[i]:
        i += 1
    head = i
    # Find the tail lines, the trailing matching lines.
    i = 0
    while (
        old_len-i-1 >=0 and new_len-i-1 >=0 and
        old_lines[old_len-i-1] == new_lines[new_len-i-1]
    ):
        i += 1
    tail = i
    # Compute the change (middle) lines.
    new_head = ''.join(new_lines[:head])
    old_head = ''.join(old_lines[:head])
    # assert old_head == new_head
    if tail:
        new_tail = ''.join(new_lines[-tail:])
        old_tail = ''.join(old_lines[-tail:])
        new_middle = ''.join(new_lines[head:-tail])
        old_middle = ''.join(old_lines[head:-tail])
    else:
        # g.trace('no tail')
        new_tail = old_tail = ''
        new_middle = ''.join(new_lines[head:])
        old_middle = ''.join(old_lines[head:])
    # assert old_tail == new_tail

    # This recolors all of all changed lines.
    # We could optimize this a bit, but I doubt it would make much difference.
    mid_i = len(new_head)
    tail_i = mid_i + len(new_middle)
    delta = len(new_middle) - len(old_middle)
    all = False
    # g.trace('mid_i',mid_i,'tail_i',tail_i,'delta',delta,'all',all)
    return mid_i,tail_i,delta,all
#@-node:ekr.20071010211707.7:computeIndices
#@-node:ekr.20071010211707:Not used in new colorizer
#@+node:ekr.20071011085119:Related to new colorizer
#@+node:ekr.20061113151148.9:tag_ranges
def tag_ranges(self,tagName):

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
#@-node:ekr.20061113151148.9:tag_ranges
#@+node:ekr.20061117085824.1:w.toPythonIndex
def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
#@-node:ekr.20061117085824.1:w.toPythonIndex
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex & test
def convertRowColToPythonIndex (s,row,col,lines=None):

    '''Convert zero-based row/col indices into a python index into string s.'''

    if row < 0: return 0

    if lines is None:
        lines = g.splitLines(s)

    if row >= len(lines):
        return len(s)

    col = min(col, len(lines[row]))

    #### A big bottleneck
    prev = 0
    for line in lines[:row]:
        prev += len(line)

    return prev + col
#@+node:ekr.20070627082044.833:@test g.convertRowColToPythonIndex
if g.unitTesting:
    s1 = 'abc\n\np\nxy'
    s2 = 'abc\n\np\nxy\n'
    table1 = (
        (0,(-1,0)), # One too small.
        (0,(0,0)),
        (1,(0,1)),
        (2,(0,2)),
        (3,(0,3)), # The newline ends a row.
        (4,(1,0)),
        (5,(2,0)),
        (6,(2,1)),
        (7,(3,0)),
        (8,(3,1)),
        (9,(3,2)), # One too large.
    )
    table2 = (
        (9,(3,2)),
        (10,(4,0)), # One two many.
    )
    for s,table in ((s1,table1),(s2,table2)):
        for i,data in table:
            row,col = data
            result = g.convertRowColToPythonIndex(s,row,col)
            assert i == result, 'row: %d, col: %d, expected: %d, got: %s' % (row,col,i,result)
#@nonl
#@-node:ekr.20070627082044.833:@test g.convertRowColToPythonIndex
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex & test
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol & test
def convertPythonIndexToRowCol (s,i):

    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i <= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
#@+node:ekr.20070627082044.835:@test g.convertPythonIndexToRowCol
if g.unitTesting:
    s1 = 'abc\n\np\nxy'
    table1 = (
        (-1,(0,0)), # One too small.
        (0,(0,0)),
        (1,(0,1)),
        (2,(0,2)),
        (3,(0,3)), # The newline ends a row.
        (4,(1,0)),
        (5,(2,0)),
        (6,(2,1)),
        (7,(3,0)),
        (8,(3,1)),
        (9,(3,2)), # One too many.
        (10,(3,2)), # Two too many.
    )
    s2 = 'abc\n\np\nxy\n'
    table2 = (
        (9,(3,2)),
        (10,(4,0)), # One too many.
        (11,(4,0)), # Two too many.
    )
    s3 = 'ab' # Test special case.  This was the cause of off-by-one problems.
    table3 = (
        (-1,(0,0)), # One too small.
        (0,(0,0)),
        (1,(0,1)),
        (2,(0,2)), # One too many.
        (3,(0,3)), # Two too many.
    )

    for s,table in ((s1,table1),(s2,table2)):
        for i,result in table:
            row,col = g.convertPythonIndexToRowCol(s,i)
            assert row == result[0], 'i: %d, expected row %d, got %d' % (i,result[0],row)
            assert col == result[1], 'i: %d, expected col %d, got %d' % (i,result[1],col)
#@-node:ekr.20070627082044.835:@test g.convertPythonIndexToRowCol
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol & test
#@-node:ekr.20071011085119:Related to new colorizer
#@-node:ekr.20071010211808:Rewrote threading colorizer: hurray!
#@+node:ekr.20071012112853.1:Optimized yank, by using yanked leading whitespace if it exists
#@+node:ekr.20050930091642.1:yank
def yank (self,event,pop=False):

    '''yank: insert the first entry of the kill ring.
    yank-pop: insert the next entry of the kill ring.
    '''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    current = c.currentPosition()
    if not current: return
    text = w.getAllText()
    i, j = w.getSelectionRange()
    clip_text = self.getClipboard(w)
    if not self.killBuffer and not clip_text: return

    undoType = g.choose(pop,'yank-pop','yank')
    self.beginCommand(undoType=undoType)
    try:
        if not pop or self.lastYankP and self.lastYankP != current:
            self.reset = 0
        s = self.kbiterator.next()
        if s is None: s = clip_text or ''
        if i != j: w.deleteTextSelection()
        if s != s.lstrip(): # s contains leading whitespace.
            i2,j2 = g.getLine(text,i)
            k = g.skip_ws(text,i2)
            if i2 < i <= k:
                # Replace the line's leading whitespace by s's leading whitespace.
                w.delete(i2,k)
                i = i2
        w.insert(i,s)
        w.setSelectionRange(i,i+len(s),insert=i+len(s))
        self.lastYankP = current.copy()
        c.frame.body.forceFullRecolor()
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930091642.1:yank
#@-node:ekr.20071012112853.1:Optimized yank, by using yanked leading whitespace if it exists
#@+node:ekr.20071015080259:Added doctest patch to debug command
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4568499
By: ktenney

I like doctests, often debug with g.es()
statements, and open winpdb to examine what's
going on.

I've a small patch to the debug command
leoEditCommands.py-->debugCommandsClass-->debug
to simplify this.

The patch writes the following to the beginning of
the script being debugged;

class G:
def es(s,c=None):
  pass
g = G()

This makes the g.es() statements legal.

The patch also checks for doctests in the script,
and if found, converts them to regular code.

A node containing;

>>> import inspect, sys
>>> insp = sys.modules['inspect']
>>> print insp.__name__
inspect
>>> g.es(dir(insp))

can be run as a doctest;
<alt x> dt
(if the dtest.py plugin is active)

or sent to winpdb;
<alt x> debug

The patch doesn't change the handling of regular scripts.

It goes right after;
if not winpdb: return

#check for doctest examples
try:
....import doctest
....parser = doctest.DocTestParser()
....examples = parser.get_examples(script)

....# if this is doctest, extract the examples as a script
....if len(examples) > 0:
........script = doctest.script_from_examples(script)

except ImportError:
....pass

# special case; debug code may include g.es("info string")
# insert code fragment to make this expression legal outside Leo
hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"

script = hide_ges + script

@color
#@nonl
#@+node:ekr.20060519003651:debug & helper
def debug (self,event=None):

    '''Start an external debugger in another process to debug a script.
    The script is the presently selected text or then entire tree's script.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    script = g.getScript(c,p)
    winpdb = self.findDebugger()
    if not winpdb: return

    #check for doctest examples
    try:
        import doctest
        parser = doctest.DocTestParser()
        examples = parser.get_examples(script)

        # if this is doctest, extract the examples as a script
        if len(examples) > 0:
            script = doctest.script_from_examples(script)
    except ImportError:
        pass

    # special case; debug code may include g.es("info string").
    # insert code fragment to make this expression legal outside Leo.
    hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"
    script = hide_ges + script

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213:findDebugger
def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
#@-node:ekr.20060521140213:findDebugger
#@-node:ekr.20060519003651:debug & helper
#@-node:ekr.20071015080259:Added doctest patch to debug command
#@+node:ekr.20071015102710.1:Added rst3 strip_at_file_prefixes option
@nocolor

From the documentation at: http://webpages.charter.net/edreamleo/rstplugin3.html#options

strip_at_file_prefixes (default: True)

True: remove @auto, @file, @nosent and @thin from the start of headlines.
#@nonl
#@-node:ekr.20071015102710.1:Added rst3 strip_at_file_prefixes option
#@+node:ekr.20071008130552:Added c# importer
#@+node:ekr.20071008130824:c# syntax ref card
@language csharp

csharpfriends.com c# community

// CLASS1.CS -- Syntax-at-a-Glance for the C# programming language.
// A quick code reference for programmers who work in many languages.
// Executable code, minimal comments document the essence of the language.
// Copyright (C) 2001 StructureByDesign.  All Rights Reserved.

using System;
using System.Collections;
using System.IO;

namespace StructureByDesign.Syntax
{
/********************************************************************/
public class Class1: Object
{
    public static int Main(string[] args)       // Entry point.
    {
        System.Console.WriteLine("Hello");
        Class2 aclass2 = new Class2();
        aclass2.run();
        return 0;
    }
}

/********************************************************************/
interface Interface1
{
    void run();
}

/********************************************************************/
class Class2: Class1, Interface1
{
    public const int CONSTANT = 1;          // Access not restricted, implicitly static.
    private int m_intPrivateField;          // Access limited to containing type.
    //////////////////////////////////////////////////////////////
    public Class2() : base()                // Constructor.
    {
        initialize();
    }
    //////////////////////////////////////////////////////////////
    protected void initialize()             // Object initialization.
    {                                       // Access limited to containing class or types derived.
        Number = 1;
    }
    //////////////////////////////////////////////////////////////
    protected int Number                    // Language property feature.
    {
        get
        {
            return m_intPrivateField;
        }
        set
        {
            m_intPrivateField = value;      // Implicit parameter.
        }
    }
    //////////////////////////////////////////////////////////////
    public void run()
    {
        anonymousCode();
        arrays();
        collections();
        comparison();
        control();
        filesStreamsAndExceptions();
        numbersAndMath();
        primitivesAndConstants();
        runtimeTyping();
        strings();
    }
    //////////////////////////////////////////////////////////////
    void anonymousCode()
    {
        Delegate adelegate = new Delegate(Run);
        adelegate();
    }
    delegate void Delegate();
    void Run()
    {
        Console.WriteLine("Run");
    }
    //////////////////////////////////////////////////////////////
    void arrays()
    {
        int[] arrayOfInts = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        arrayOfInts[0] = 9;
        assert(arrayOfInts[0] == arrayOfInts[9]);

        String[] arrayOfStrings = new String[10];
        assert(arrayOfStrings[0] == null);
        assert(arrayOfStrings.Length == 10);

        arrayOfStrings = new String[] { "one", "two" };

        byte[,] arrayOfBytes = { {0,0,0},
                                 {0,1,2},
                                 {0,2,4}};
        assert(arrayOfBytes[2,2] == 4);
    }
    //////////////////////////////////////////////////////////////
    void collections()
    {
        IList ailist = new ArrayList();
        ailist.Add("zero"); ailist.Add("one"); ailist.Add("three");
        ailist[2] = "two";
        assert(ailist[2].Equals("two"));
        ailist.Remove("two");
        ((ArrayList)ailist).Sort();
        for(IEnumerator aie = ((ArrayList)ailist).GetEnumerator(); aie.MoveNext(); )
            ;
        foreach(String astring in ailist)
            ;

        IDictionary aidictionary = new Hashtable();
        aidictionary.Add("key", "value");
        assert(aidictionary["key"].Equals("value"));

        // Set not available.
    }
    //////////////////////////////////////////////////////////////
    void comparison()
    {
        int aint1 = 1;
        int aint2 = 2;
        int aint = 1;
        String astring1 = "one";
        String astring2 = "two";
        String astring = astring1;

        assert(aint == aint1);
        assert(aint1 != aint2);
        assert(astring == astring1);
        assert(astring1 == String.Copy("one"));         // For strings == is overloaded to compare values.
        assert(!astring1.Equals(astring2));
        assert(astring1.Equals(String.Copy("one")));

        astring = null;
        if (astring != null && astring.Length > 0)      // Conditional evaluation.
            assert(false);

        if (aint2 < 0 || 1 < aint2)
            assert(true);
    }
    //////////////////////////////////////////////////////////////
    void control()
    {
        if (true)
            assert(true);
        else
            assert(false);
        /////
        switch ('b') {
            case 'a':
                assert(false);
                break;
            case 'b':
                assert(true);
                break;
            default:
                assert(false);
                break;
        }
        /////
        for (int ai1 = 0; ai1 < 10; ai1++)
            assert(true);
        /////
        int ai = 0;
        while (ai < 10) {
            assert(true);
            ai++;
        }
        /////
        do
            ai--;
        while (ai > 0);
        /////
        for (int x = 0; x < 10; x++)        // Labeled break/continue not available.
            for (int y = 0; y < 10; y++)
                if (x == 9)
                    break;
                else
                    continue;
    }
    //////////////////////////////////////////////////////////////
    void filesStreamsAndExceptions()
    {
        FileInfo afileinfo = new FileInfo("list.txt");
        try {
            StreamWriter asw = new StreamWriter("list.txt");
            asw.WriteLine("line");
            asw.WriteLine("line");
            asw.Close();

            assert(afileinfo.Exists);

            StreamReader asr = new StreamReader("list.txt");
            String astringLine;
            while ((astringLine = asr.ReadLine()) != null)
                assert(astringLine.Equals("line"));
            asr.Close();
        } catch (IOException aexception) {
            System.Console.WriteLine(aexception.Message);
            throw new NotSupportedException();
        }
        finally {
            afileinfo.Delete();
        }
    }
    //////////////////////////////////////////////////////////////
    void numbersAndMath()
    {
        assert(Int32.Parse("123") == 123);
        assert(123.ToString().Equals("123"));

        assert(Math.PI.ToString("n3").Equals("3.142"));

        assert(Int32.MaxValue < Int64.MaxValue);

        assert(Math.Abs(Math.Sin(0) - 0) <= Double.Epsilon);
        assert(Math.Abs(Math.Cos(0) - 1) <= Double.Epsilon);
        assert(Math.Abs(Math.Tan(0) - 0) <= Double.Epsilon);

        assert(Math.Abs(Math.Sqrt(4) - 2) <= Double.Epsilon);
        assert(Math.Abs(Math.Pow(3,3) - 27) <= Double.Epsilon);

        assert(Math.Max(0,1) == 1);
        assert(Math.Min(0,1) == 0);

        assert(Math.Abs(Math.Ceiling(9.87) - 10.0) <= Double.Epsilon);
        assert(Math.Abs(Math.Floor(9.87) - 9.0) <= Double.Epsilon);
        assert(Math.Round(9.87) == 10);

        Random arandom = new Random();
        double adouble = arandom.NextDouble();
        assert(0.0 <= adouble && adouble < 1.0);
        int aint = arandom.Next(10);
        assert(0 <= aint && aint < 10);
    }
    //////////////////////////////////////////////////////////////
    enum Season: byte { Spring=0, Summer, Fall, Winter };

    void primitivesAndConstants()
    {
        bool abool = false;
        char achar = 'A';           // 16 bits, Unicode

        byte abyte = 0x0;           // 8 bits, unsigned, hex constant
        sbyte asbyte = 0;           // 8 bits, signed

        short ashort = 0;           // 16 bits, signed
        ushort aushort = 0;         // 16 bits, unsigned

        int aint = 0;               // 32 bits, signed
        uint aunit = 0;             // 32 bits, unsigned

        long along = 0L;            // 64 bits, signed
        ulong aulong = 0;           // 64 bits, unsigned

        float afloat = 0.0F;        // 32 bits
        double adouble = 0.0;       // 64 bits

        decimal adecimal = 0;       // 128 bits, financial calculations

        Season aseason = Season.Fall;
        assert((byte)aseason == 2);
    }
    //////////////////////////////////////////////////////////////
    void runtimeTyping()
    {
        assert(new int[] { 1 } is int[]);
        assert(new ArrayList() is ArrayList);

        assert((new ArrayList()).GetType() == typeof(ArrayList));
        assert(typeof(Int32) is Type);      // Type of primitive type.

        assert(Type.GetType("System.Collections.ArrayList") == typeof(ArrayList));
    }
    //////////////////////////////////////////////////////////////
    void strings()
    {
        String astring1 = "one";
        String astring2 = "TWO";

        assert((astring1 + "/" + astring2).Equals("one/TWO"));
        assert(astring2.ToLower().Equals("two"));   // Equals ignoring case not available.
        assert(astring1.Length == 3);
        assert(astring1.Substring(0,2).Equals("on"));
        assert(astring1[2] == 'e');
        assert(astring1.ToUpper().Equals("ONE"));
        assert(astring2.ToLower().Equals("two"));
        assert(astring1.CompareTo("p") < 0);
        assert(astring1.IndexOf('e') == 2);
        assert(astring1.IndexOf("ne") == 1);
        assert(astring1.Trim().Length == astring1.Length);

        assert(Char.IsDigit('1'));
        assert(Char.IsLetter('a'));
        assert(Char.IsWhiteSpace('\t'));
        assert(Char.ToLower('A') == 'a');
        assert(Char.ToUpper('a') == 'A');
    }
    //////////////////////////////////////////////////////////////
    private void assert(bool abool)
    {
        if (!abool)
            throw new Exception("assert failed");
    }
}
}

#@-node:ekr.20071008130824:c# syntax ref card
#@-node:ekr.20071008130552:Added c# importer
#@+node:ekr.20071018114556:Allow unicode characters in Leo file names
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,fileName=None,gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ""
    if not gui: gui = g.app.gui
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):

    import leoGlobals as g

    if not fileName:
        return None

    # This does not depend on config settings.
    try:
        import sys
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    fileName = g.os_path_join(os.getcwd(),fileName)
    head,ext = g.os_path_splitext(fileName)

    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print()
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(fileName=path,initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):

    """Create a LeoFrame during Leo's startup process."""

    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName,initEditCommanders=True)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if frame.c.chapterController:
        frame.c.chapterController.finishCreate()
        frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20071018120804:Report
@nocolor

> Oh joy. The problem can be fixed in Leo.

Maybe I spoke too soon.  The crasher in print can be worked around.  But that is not the end of the story.

The problem is determining the proper way to convert Lasidor.leo to unicode.  Using 'utf-8' in g.toUnicode doesn't work on XP. It produces byte hash for the .  Using 'utf-8' fails spectacularly: the entire file name looks like chinese!  It's possible that some other encoding would work, but how to discover it?

Furthermore, g.os_path_exists returns False for Lasidor.leo.  That may indicate a problem with the Python library, or not.

Moreover, Lasidor.leo isn't shown properly in the Leo window: 'byte hash' is shown for the  character.  Saving *this* (new) file gives a file with the dreaded square instead of  in XP.  And loading this new file also doesn't work: the file is not found and yet another new file is created.

This could be a hard problem to solve.  I'm not sure I understand the interaction between unicode and file systems well enough to fix it.

So for now, the workaround of avoiding non-ascii characters in file names seems prudent.  Sorry about this.  I would fix it if I could: it's most annoying to limit oneself to ascii file names.

Edward
#@-node:ekr.20071018120804:Report
#@+node:ekr.20071018121409:Tests of file names
@first # -*- coding: utf-8 -*-

# The encoding above does not seem to matter--
# it suppresses a warning given by execute-script.

import os

for name in ('Lasidor.leo','test.leo'):
    g.es('--')
    for encoding in ('utf-16','utf-8','mbcs'):
        s = r'c:\prog\tigris-cvs\leo\test\%s' % name
        s = g.toUnicode(s,encoding) # pep 277 allows unicode file names.
        g.es(encoding,s,os.path.exists(s))
#@-node:ekr.20071018121409:Tests of file names
#@+node:ekr.20050208093800.1:toUnicode
def toUnicode (s,encoding,reportErrors=False):

    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
#@-node:ekr.20050208093800.1:toUnicode
#@-node:ekr.20071018114556:Allow unicode characters in Leo file names
#@+node:ekr.20071014113031:Simplified how @auto works
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4566692
By: vransmayr

I tried to import

* an HTML file
* a plain version file (w/o any file extension)

In this case Leo wrote out the new empty @auto-node and didn't read in the
content of the original file.

This is not what I had expected ;-)

----- What I did:

- Removed c.atAutoDict and related logic:  The code now does not depend on past history.
- Added force keyword arg to writeOneAtAutoNode.
- Writing a .leo file never reads an @auto node.
- @auto nodes overwrite existing files only if a) they are dirty and b) they have significant info.

@color
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20041005105605.147:writeAll (atFile)
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t)
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll (atFile)
#@+node:ekr.20070806140208:writeAtAutoNodesHelper
def writeAtAutoNodesHelper(self,toString=False,writeDirtyOnly=True):

    """Write @auto nodes in the selected outline"""

    at = self ; c = at.c
    p = c.currentPosition() ; after = p.nodeAfterTree()
    found = False
    c.fileCommands.assignFileIndices()
    while p and p != after:
        if p.isAtAutoNode() and not p.isAtIgnoreNode() and (p.isDirty() or not writeDirtyOnly):
            ok = self.writeOneAtAutoNode(p,toString=toString,force=True)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    if found:
        g.es("finished")
    elif writeDirtyOnly:
        g.es("no dirty @auto nodes in the selected tree")
    else:
        g.es("no @auto nodes in the selected tree")
#@-node:ekr.20070806140208:writeAtAutoNodesHelper
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')

    if ic.errors or not g.os_path_exists(fileName):
        c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
#@nonl
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@-node:ekr.20071014113031:Simplified how @auto works
#@+node:ekr.20071021054356:Added g.app.inBridge ivar
# This is used, at present, by g.getScript.  It is a natural status ivar in any case.
#@nonl
#@-node:ekr.20071021054356:Added g.app.inBridge ivar
#@+node:ekr.20071021102619:Improved the scripting and plugins chapters of Leo's Users Guide
@nocolor

- Use the term 'event handler' for hook.  This is much better terminology.

- Move the discussion of event handlers to the scripting chapter.

- Removed the discussion of all menu convenience routines: they are not needed now that Leo supports @menus nodes.

- The 'writing plugins' chapter is now very simple.
#@nonl
#@-node:ekr.20071021102619:Improved the scripting and plugins chapters of Leo's Users Guide
#@+node:ekr.20071021110355:Added rst3 strip_at_file_prefixes option
#@-node:ekr.20071021110355:Added rst3 strip_at_file_prefixes option
#@-node:ekr.20070920083033.1:Features
#@-node:ekr.20070919132518:4.4.4 b3
#@+node:ekr.20071023175714:4.4.4 final
#@+node:ekr.20071023105313:Fixed aspell problem
# Replaced the (useless) trace with an error message to the console window.
#@nonl
#@+node:ekr.20071023174056:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4584199
By: ktenney

I found the Windows aspell installer and ran it.

I edited @settings
@string aspell_dir and @string aspell_bin_dir

Leo then failed to start, traceback follows

[snip]

in getAspellWithCtypes
    raise Exception('aspell checker not enabled')
Exception: aspell checker not enabled

** To do: print the settings if there are init problems.
#@nonl
#@-node:ekr.20071023174056:Report
#@+node:ekr.20051025071455.6:class AspellClass
class AspellClass:

    """A wrapper class for Aspell spell checker"""

    @others
#@+node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.8:__init__
def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = g.os_path_abspath(c.config.getString('aspell_dir'))
    self.aspell_bin_dir = g.os_path_abspath(c.config.getString('aspell_bin_dir'))

    self.local_language_code = local_language_code or 'en'
    self.local_dictionary_file = g.os_path_abspath(local_dictionary_file)
    self.local_dictionary = "%s.wl" % os.path.splitext(self.local_dictionary_file) [0]

    # g.trace('code',self.local_language_code,'dict',self.local_dictionary_file)
    # g.trace('dir',self.aspell_dir,'bin_dir',self.aspell_bin_dir)

    try:
        import ctypes
        import ctypes.util
        self.use_ctypes = True
    except ImportError:
        self.use_ctypes = False
    self.aspell = self.sc = None

    if self.use_ctypes:
        self.getAspellWithCtypes()
    else:
        self.getAspell()
#@-node:ekr.20051025071455.8:__init__
#@+node:ekr.20061017125710:getAspell
def getAspell (self):

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=None,verbose=False)

    self.aspell = aspell
    self.sc = aspell and aspell.spell_checker(prefix=self.aspell_dir,lang=self.local_language_code)
#@-node:ekr.20061017125710:getAspell
#@+node:ekr.20061018111331:getAspellWithCtypes
def getAspellWithCtypes (self):

    import ctypes
    import ctypes.util
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    try:
        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        print 'Can not load %s' % (path)
        self.aspell = self.check = self.sc = None
        return

    try:
        << define and configure aspell entry points >>
    except Exception:
        print 'aspell checker not enabled'
        self.aspell = self.check = self.sc = None
        return

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
#@+node:ekr.20061018111933:<< define and configure aspell entry points >>
# new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]
#@nonl
#@-node:ekr.20061018111933:<< define and configure aspell entry points >>
#@-node:ekr.20061018111331:getAspellWithCtypes
#@-node:ekr.20051025071455.7:Birth & death
#@+node:ekr.20051025071455.10:processWord
def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    & original count offset: miss, miss, ... 
    None: 
    # original offset 
    simplifyed to not create the string then make a list from it
    """

    # g.trace('word',word)

    if not self.aspell:
        g.trace('aspell not installed')
        return None
    elif self.use_ctypes:
        if self.check(self.spell_checker,word,len(word)):
            return None
        else:
            return self.suggestions(word)
    else:
        if self.sc.check(word):
            return None
        else:
            return self.sc.suggest(word)
#@-node:ekr.20051025071455.10:processWord
#@+node:ekr.20061018101455.4:suggestions
def suggestions(self,word):

    "return list of words found"

    aList = []
    sw = self.suggest(self.spell_checker, word, len(word))

    if self.word_list_size(sw):
        ewords = self.word_list_elements(sw)
        while 1: 
            x = self.string_enumeration_next(ewords)
            if x is None: break
            aList.append(x)
    return aList
#@nonl
#@-node:ekr.20061018101455.4:suggestions
#@+node:ekr.20051025071455.11:updateDictionary
def updateDictionary(self):

    """Update the aspell dictionary from a list of words.

    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl < %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        # g.es_print("Unable to update local aspell dictionary: %s" % err)
        print "Unable to update local aspell dictionary: %s" % (err)
        return False
#@-node:ekr.20051025071455.11:updateDictionary
#@-node:ekr.20051025071455.6:class AspellClass
#@+node:ekr.20061018111331:getAspellWithCtypes
def getAspellWithCtypes (self):

    import ctypes
    import ctypes.util
    c_int, c_char_p = ctypes.c_int, ctypes.c_char_p

    try:
        if sys.platform.startswith('win'):
            path = g.os_path_join(self.aspell_bin_dir, "aspell-15.dll")
            self.aspell = aspell = ctypes.CDLL(path)
        else:
            path = 'aspell'
            libname = ctypes.util.find_library(path)
            assert(libname)
            self.aspell = aspell = ctypes.CDLL(libname)
    except Exception:
        print 'Can not load %s' % (path)
        self.aspell = self.check = self.sc = None
        return

    try:
        << define and configure aspell entry points >>
    except Exception:
        print 'aspell checker not enabled'
        self.aspell = self.check = self.sc = None
        return

    # Remember these functions (bound methods).
    # No other ctypes data is known outside this method.
    self.check = check
    self.spell_checker = spell_checker
    self.string_enumeration_next = string_enumeration_next
    self.suggest = suggest
    self.word_list_elements = word_list_elements
    self.word_list_size = word_list_size
#@+node:ekr.20061018111933:<< define and configure aspell entry points >>
# new_aspell_config
new_aspell_config = aspell.new_aspell_config 
new_aspell_config.restype = c_int

# aspell_config_replace
aspell_config_replace = aspell.aspell_config_replace 
aspell_config_replace.argtypes = [c_int, c_char_p, c_char_p] 

# aspell_config_retrieve
aspell_config_retrieve = aspell.aspell_config_retrieve 
aspell_config_retrieve.restype = c_char_p  
aspell_config_retrieve.argtypes = [c_int, c_char_p] 

# aspell_error_message
aspell_error_message = aspell.aspell_error_message 
aspell_error_message.restype = c_char_p  

sc = new_aspell_config()
if 0:
    print sc 
    print aspell_config_replace(sc, "prefix", aspell_dir) #1/0 
    print 'prefix', aspell_dir, `aspell_config_retrieve(sc, "prefix")`
    print aspell_config_retrieve(sc, "lang")
    print aspell_config_replace(sc, "lang",self.local_language_code)
    print aspell_config_retrieve(sc, "lang")

possible_err = aspell.new_aspell_speller(sc)
aspell.delete_aspell_config(c_int(sc))

# Rudimentary error checking, needs more.  
if aspell.aspell_error_number(possible_err) != 0:
    print 'err', aspell_error_message(possible_err)
    spell_checker = None
else: 
    spell_checker = aspell.to_aspell_speller(possible_err)

if not spell_checker:
    raise Exception('aspell checker not enabled')

word_list_size = aspell.aspell_word_list_size
word_list_size.restype = c_int
word_list_size.argtypes = [c_int,]

# word_list_elements
word_list_elements = aspell.aspell_word_list_elements
word_list_elements.restype = c_int
word_list_elements.argtypes = [c_int,]

# string_enumeration_next
string_enumeration_next = aspell.aspell_string_enumeration_next
string_enumeration_next.restype = c_char_p
string_enumeration_next.argtypes = [c_int,]

# check
check = aspell.aspell_speller_check
check.restype = c_int 
check.argtypes = [c_int, c_char_p, c_int]

# suggest
suggest = aspell.aspell_speller_suggest
suggest.restype = c_int 
suggest.argtypes = [c_int, c_char_p, c_int]
#@nonl
#@-node:ekr.20061018111933:<< define and configure aspell entry points >>
#@-node:ekr.20061018111331:getAspellWithCtypes
#@-node:ekr.20071023105313:Fixed aspell problem
#@+node:ekr.20071017163243:Fixed bug: utf-8 files now get imported properly
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4574271
By: hibou-57

I've tried the Leo's import features, and it seems that my JavaScripts, written
in UTF-8, are imported as if it was ASCII. I.e., all accented characters are
imported as a sequence of character (just like what you can see with a none-utf-8
editor).

There is a work around : just create a node, and make a simple copy-past from
another editor to Leo body panel.

---------------

> I've added an entry in the Windows registry to open *.leo files with Leo. The entry is like this: 

pathToPythonInterpreter pathToLeoScript "%1"

...this fails when the path to the leo file ("%1") contains accented characters (e.g. like Lasidor.leo for example). 

> But not sure this is due to Leo, indeed, I think this is rather due to the Python environment. 

Well, I hope it's a problem in Leo--it will be easier to fix :-) I'll look into this soon. Thanks for this helpful report.

@color
#@nonl
#@+node:ekr.20070909100252:readOneAtAutoNode (atFile)
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    # g.trace(fileName)

    # Delete all children.
    c.beginUpdate()
    try:
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.endUpdate(False)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')

    if ic.errors or not g.os_path_exists(fileName):
        c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
#@nonl
#@-node:ekr.20070909100252:readOneAtAutoNode (atFile)
#@+node:ekr.20070806141607:writeOneAtAutoNode & helpers
def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = g.os_path_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    g.trace('toString',toString)
    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"<string-file>",fileName)
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString,write_strips_blank_lines=False)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        at.replaceTargetFileIfDifferent()
        # c.atAutoDict [fileName] = True
    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("Not written: " + at.outputFileName)

    return ok
#@+node:ekr.20071019141745:shouldWriteAtAutoNode
@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantAtAutoTree(p): # There is noting of value to write.
        g.es_print('@auto node not written:\nno children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
#@-node:ekr.20071019141745:shouldWriteAtAutoNode
#@+node:ekr.20070909103844:isSignificantAtAutoTree & test
def isSignificantAtAutoTree (self,p):

    '''Return True if p's tree has a significant amount of information.'''

    s = p.bodyString()

    # Remove all blank lines and all Leo directives.
    lines = []
    for line in g.splitLines(s):
        if not line.strip():
            pass
        elif line.startswith('@'):
            i = 1 ; j = g.skip_id(line,i,chars='-')
            word = s[i:j]
            if not (word and word in g.globalDirectiveList):
                lines.append(line)
        else:
            lines.append(line)

    s2 = ''.join(lines)
    # g.trace('s2',s2)

    return p.hasChildren() or len(s2.strip()) >= 10
#@+node:ekr.20071020082208:@test test isSignificantAtAutoTree
if g.unitTesting:

    assert c.atFileCommands.isSignificantAtAutoTree(p)

#@-node:ekr.20071020082208:@test test isSignificantAtAutoTree
#@-node:ekr.20070909103844:isSignificantAtAutoTree & test
#@-node:ekr.20070806141607:writeOneAtAutoNode & helpers
#@+node:ekr.20031218072017.1463:setEncoding
def setEncoding (self,p=None):

    # scanDirectives checks the encoding: may return None.
    c = self.c
    if p is None: p = c.currentPosition()
    theDict = g.scanDirectives(c,p)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
#@-node:ekr.20031218072017.1463:setEncoding
#@+node:ekr.20031218072017.3209:Import
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.currentPosition() ; after = p.nodeAfterTree()

    c.beginUpdate()
    try:
        found = False
        while p and p != after:
            if p.isAtAutoNode():
                if p.isAtIgnoreNode():
                    g.es_print('ignoring %s' % (p.headString()),color='blue')
                    p.moveToThreadNext()
                else:
                    self.readOneAtAutoNode(p)
                    found = True
                    p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        g.es(g.choose(found,'finished','no @auto nodes in the selected tree'),color='blue')
    finally:
        c.endUpdate()

#@+node:ekr.20070807084545:readOneAtAutoNode
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    c.setBodyString(p,p.bodyString())
    c.frame.body.onBodyChanged(undoType=None)
#@-node:ekr.20070807084545:readOneAtAutoNode
#@-node:ekr.20070806111212:readAtAutoNodes (importCommands) & helper
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            << set isThin if fileName is a thin derived file >>
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@+node:ekr.20051208100903.1:forceGnxOnPosition
def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
#@-node:ekr.20051208100903.1:forceGnxOnPosition
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            << Create a parent for two files having a common prefix >>
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                if not g.unitTesting:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:ekr.20031218072017.3214:importFlattenedOutline & allies
#@+node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
# Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

    __pychecker__ = '--no-objattrs' # suppress bad warnings re lastVnode.

    c = self.c
    if len(strings) == 0: return None
    if not self.stringsAreValidMoreFile(strings): return None
    c.beginUpdate()
    try: # range of update...
        firstLevel, junk = self.moreHeadlineLevel(strings[0])
        lastLevel = -1 ; theRoot = lastVnode = None
        index = 0
        while index < len(strings):
            progress = index
            s = strings[index]
            level, newFlag = self.moreHeadlineLevel(s)
            level -= firstLevel
            if level >= 0:
                << Link a new vnode v into the outline >>
                << Set the headline string, skipping over the leader >>
                << Count the number of following body lines >>
                << Add the lines to the body text of v >>
                v.setDirty()
            else: index += 1
            assert progress < index
        if theRoot:
            theRoot.setDirty()
            c.setChanged(True)
    finally:
        c.endUpdate()
    return theRoot
#@+node:ekr.20031218072017.3216:<< Link a new vnode v into the outline >>
assert(level >= 0)
if lastVnode is None:
    # g.trace(firstVnode)
    theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
    v = lastVnode.insertAfter()
elif level == lastLevel + 1:
    v = lastVnode.insertAsNthChild(0)
else:
    assert(level < lastLevel)
    while level < lastLevel:
        lastLevel -= 1
        lastVnode = lastVnode.parent()
        assert(lastVnode)
        assert(lastLevel >= 0)
    v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level
#@-node:ekr.20031218072017.3216:<< Link a new vnode v into the outline >>
#@+node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
j = 0
while g.match(s,j,'\t'):
    j += 1
if g.match(s,j,"+ ") or g.match(s,j,"- "):
    j += 2

v.initHeadString(s[j:])
#@-node:ekr.20031218072017.3217:<< Set the headline string, skipping over the leader >>
#@+node:ekr.20031218072017.3218:<< Count the number of following body lines >>
bodyLines = 0
index += 1 # Skip the headline.
while index < len(strings):
    s = strings[index]
    level, junk = self.moreHeadlineLevel(s)
    level -= firstLevel
    if level >= 0:
        break
    # Remove first backslash of the body line.
    if g.match(s,0,'\\'):
        strings[index] = s[1:]
    bodyLines += 1
    index += 1
#@-node:ekr.20031218072017.3218:<< Count the number of following body lines >>
#@+node:ekr.20031218072017.3219:<< Add the lines to the body text of v >>
if bodyLines > 0:
    body = ""
    n = index - bodyLines
    while n < index:
        body += strings[n]
        if n != index - 1:
            body += "\n"
        n += 1
    v.setTnodeText(body)
#@-node:ekr.20031218072017.3219:<< Add the lines to the body text of v >>
#@-node:ekr.20031218072017.3215:convertMoreString/StringsToOutlineAfter
#@+node:ekr.20031218072017.3220:importFlattenedOutline
def importFlattenedOutline (self,files): # Not a command, so no event arg.

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) < 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    << Read the file into array >>

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
#@+node:ekr.20031218072017.3221:<< Read the file into array >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@-node:ekr.20031218072017.3221:<< Read the file into array >>
#@-node:ekr.20031218072017.3220:importFlattenedOutline
#@+node:ekr.20031218072017.3222:moreHeadlineLevel
# return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

    level = 0 ; i = 0
    while g.match(s,i,'\t'):
        level += 1
        i += 1
    plusFlag = g.choose(g.match(s,i,"+"),True,False)
    if g.match(s,i,"+ ") or g.match(s,i,"- "):
        return level, plusFlag
    else:
        return -1, plusFlag
#@-node:ekr.20031218072017.3222:moreHeadlineLevel
#@+node:ekr.20031218072017.3223:stringIs/stringsAreValidMoreFile
# Used by paste logic.

def stringIsValidMoreFile (self,s):

    s = string.replace(s,"\r","")
    strings = string.split(s,"\n")
    return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

    if len(strings) < 1: return False
    level1, plusFlag = self.moreHeadlineLevel(strings[0])
    if level1 == -1: return False
    # Check the level of all headlines.
    i = 0 ; lastLevel = level1
    while i < len(strings):
        s = strings[i] ; i += 1
        level, newFlag = self.moreHeadlineLevel(s)
        if level > 0:
            if level < level1 or level > lastLevel + 1:
                return False # improper level.
            elif level > lastLevel and not plusFlag:
                return False # parent of this node has no children.
            elif level == lastLevel and plusFlag:
                return False # last node has missing child.
            else:
                lastLevel = level
                plusFlag = newFlag
    return True
#@-node:ekr.20031218072017.3223:stringIs/stringsAreValidMoreFile
#@-node:ekr.20031218072017.3214:importFlattenedOutline & allies
#@+node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:ekr.20031218072017.3225:createOutlineFromWeb
def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)

    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        c.setBodyString(p,"@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
#@-node:ekr.20031218072017.3225:createOutlineFromWeb
#@+node:ekr.20031218072017.3226:importWebCommand
def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.webType = webType

    c.beginUpdate()
    try:
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutlineFromWeb(fileName,current)
            v.contract()
            v.setDirty()
            c.setChanged(True)
        c.selectVnode(current)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.3226:importWebCommand
#@+node:ekr.20031218072017.3227:findFunctionDef
def findFunctionDef (self,s,i):

    # Look at the next non-blank line for a function name.
    i = g.skip_ws_and_nl(s,i)
    k = g.skip_line(s,i)
    name = None
    while i < k:
        if g.is_c_id(s[i]):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
        elif s[i] == '(':
            if name: return name
            else: break
        else: i += 1
    return None
#@-node:ekr.20031218072017.3227:findFunctionDef
#@+node:ekr.20031218072017.3228:scanBodyForHeadline
@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):

    if self.webType == "cweb":
        << scan cweb body for headline >>
    else:
        << scan noweb body for headline >>
    return "@" # default.
#@+node:ekr.20031218072017.3229:<< scan cweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    # Allow constructs such as @ @c, or @ @<.
    if self.isDocStart(s,i):
        i += 2 ; i = g.skip_ws(s,i)
    if g.match(s,i,"@d") or g.match(s,i,"@f"):
        # Look for a macro name.
        directive = s[i:i+2]
        i = g.skip_ws(s,i+2) # skip the @d or @f
        if i < len(s) and g.is_c_id(s[i]):
            j = i ; g.skip_c_id(s,i) ; return s[j:i]
        else: return directive
    elif g.match(s,i,"@c") or g.match(s,i,"@p"):
        # Look for a function def.
        name = self.findFunctionDef(s,i+2)
        return g.choose(name,name,"outer function")
    elif g.match(s,i,"@<"):
        # Look for a section def.
        # A small bug: the section def must end on this line.
        j = i ; k = g.find_on_line(s,i,"@>")
        if k > -1 and (g.match(s,k+2,"+=") or g.match(s,k+2,"=")):
            return s[j:k+2] # return the section ref.
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3229:<< scan cweb body for headline >>
#@+node:ekr.20031218072017.3230:<< scan noweb body for headline >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if g.match(s,i,"<<"):
        k = g.find_on_line(s,i,">>=")
        if k > -1:
            ref = s[i:k+2]
            name = string.strip(s[i+2:k])
            if name != "@others":
                return ref
    else:
        name = self.findFunctionDef(s,i)
        if name:
            return name
    i = g.skip_line(s,i)
#@-node:ekr.20031218072017.3230:<< scan noweb body for headline >>
#@-node:ekr.20031218072017.3228:scanBodyForHeadline
#@+node:ekr.20031218072017.3231:scanWebFile (handles limbo)
def scanWebFile (self,fileName,parent):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")

    try: # Read the file into s.
        f = open(fileName)
        s = f.read()
    except:
        g.es("Can not import " + fileName, color="blue")
        return

    << Create a symbol table of all section names >>
    << Create nodes for limbo text and the root section >>
    while i < len(s):
        outer_progress = i
        << Create a node for the next module >>
        assert(i > outer_progress)
#@nonl
#@+node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
i = 0 ; self.web_st = []

while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    # line = g.get_line(s,i) ; g.trace(line)
    if self.isDocStart(s,i):
        if theType == "cweb": i += 2
        else: i = g.skip_line(s,i)
    elif theType == "cweb" and g.match(s,i,"@@"):
        i += 2
    elif g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1: self.cstEnter(s[j:k])
    else: i += 1
    assert (i > progress)

# g.trace(self.cstDump())
#@-node:ekr.20031218072017.3232:<< Create a symbol table of all section names >>
#@+node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
i = 0
while i < len(s):
    progress = i
    i = g.skip_ws_and_nl(s,i)
    if self.isModuleStart(s,i) or g.match(s,i,lb):
        break
    else: i = g.skip_line(s,i)
    assert(i > progress)

j = g.skip_ws(s,0)
if j < i:
    self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if g.match(s,i,lb):
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        else: i = g.skip_line(s,i)
        assert(i > progress)
    self.createHeadline(parent,s[j:i],g.angleBrackets(" @ "))

# g.trace(g.get_line(s,i))
#@-node:ekr.20031218072017.3233:<< Create nodes for limbo text and the root section >>
#@+node:ekr.20031218072017.3234:<< Create a node for the next module >>
if theType=="cweb":
    assert(self.isModuleStart(s,i))
    start = i
    if self.isDocStart(s,i):
        i += 2
        while i < len(s):
            progress = i
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i): break
            else: i = g.skip_line(s,i)
            assert (i > progress)
    << Handle cweb @d, @f, @c and @p directives >>
else:
    assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
    start = i ; i = g.skip_line(s,i)
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if self.isDocStart(s,i): break
        else: i = g.skip_line(s,i)
        assert (i > progress)

body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)
#@+node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
if g.match(s,i,"@d") or g.match(s,i,"@f"):
    i += 2 ; i = g.skip_line(s,i)
    # Place all @d and @f directives in the same node.
    while i < len(s):
        progress = i
        i = g.skip_ws_and_nl(s,i)
        if g.match(s,i,"@d") or g.match(s,i,"@f"): i = g.skip_line(s,i)
        else: break
        assert (i > progress)
    i = g.skip_ws_and_nl(s,i)

while i < len(s) and not self.isModuleStart(s,i):
    progress = i
    i = g.skip_line(s,i)
    i = g.skip_ws_and_nl(s,i)
    assert (i > progress)

if g.match(s,i,"@c") or g.match(s,i,"@p"):
    i += 2
    while i < len(s):
        progress = i
        i = g.skip_line(s,i)
        i = g.skip_ws_and_nl(s,i)
        if self.isModuleStart(s,i):
            break
        assert (i > progress)
#@-node:ekr.20031218072017.3235:<< Handle cweb @d, @f, @c and @p directives >>
#@-node:ekr.20031218072017.3234:<< Create a node for the next module >>
#@-node:ekr.20031218072017.3231:scanWebFile (handles limbo)
#@+node:ekr.20031218072017.3236:Symbol table
#@+node:ekr.20031218072017.3237:cstCanonicalize
# We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.

def cstCanonicalize (self,s,lower=True):

    if lower:
        s = string.lower(s)
    s = string.replace(s,"\t"," ")
    s = string.replace(s,"\r","")
    s = string.replace(s,"\n"," ")
    s = string.replace(s,"  "," ")
    s = string.strip(s)
    return s
#@-node:ekr.20031218072017.3237:cstCanonicalize
#@+node:ekr.20031218072017.3238:cstDump
def cstDump (self):

    self.web_st.sort()
    s = "Web Symbol Table...\n\n"
    for name in self.web_st:
        s += name + "\n"
    return s
#@-node:ekr.20031218072017.3238:cstDump
#@+node:ekr.20031218072017.3239:cstEnter
# We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

    # Don't enter names that end in "..."
    s = string.rstrip(s)
    if s.endswith("..."): return

    # Put the section name in the symbol table, retaining capitalization.
    lower = self.cstCanonicalize(s,True)  # do lower
    upper = self.cstCanonicalize(s,False) # don't lower.
    for name in self.web_st:
        if string.lower(name) == lower:
            return
    self.web_st.append(upper)
#@-node:ekr.20031218072017.3239:cstEnter
#@+node:ekr.20031218072017.3240:cstLookup
# This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):

    # Do nothing if the ... convention is not used.
    target = string.strip(target)
    if not target.endswith("..."): return target
    # Canonicalize the target name, and remove the trailing "..."
    ctarget = target[:-3]
    ctarget = self.cstCanonicalize(ctarget)
    ctarget = string.strip(ctarget)
    found = False ; result = target
    for s in self.web_st:
        cs = self.cstCanonicalize(s)
        if cs[:len(ctarget)] == ctarget:
            if found:
                g.es("****** " + target + ": is also a prefix of: " + s)
            else:
                found = True ; result = s
                # g.es("replacing: " + target + " with: " + s)
    return result
#@-node:ekr.20031218072017.3240:cstLookup
#@-node:ekr.20031218072017.3236:Symbol table
#@-node:ekr.20031218072017.3224:importWebCommand & allies
#@+node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.classIndent = 0 # The indentation of the start of the class.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]
    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:@test pr
if False or g.unitTesting:
    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:@test pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldClassIndent = self.classIndent
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classIndent = self.getIndent(s,i)
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,indentFlag,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)

    # g.trace(class_name,'indent',self.classIndent,'indentFlag',indentFlag)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name,indentFlag) or ''

    # Remove the leading whitespace only from the classHead and trailing parts.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        ref +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.classIndent = oldClassIndent
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070703122141.106:appendRefToClassNode
def getClassNodeRef (self,class_name,indentFlag):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    # Increase effective indentation by the width of self.tab_ws.
    # g.trace('class_name',class_name,indentFlag)

    if indentFlag:
        return '%s%s\n' % (self.tab_ws,s)
    else:
        return '%s\n' % (s)

    # if indentFlag:
        # self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
    # else:
        # self.appendTextToClassNode(class_node,'%s\n' % s)
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    start = i = self.skipDecls(s,i,end,inClass=True)
    decls = s[start:i]

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,indentFlag = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,indentFlag = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,indentFlag,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):

    self.errors += 1
    self.importCommands.errors += 1
    if g.app.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict['actualErrorMessage'] = s
        g.app.unitTestDict['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.es_print(s,color='red')
    else:
        g.es_print(s,color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = start = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    assert kind in ('class','outer')
    start = i ; putRef = False ; indentFlag = None
    # if kind =='class' and g.match(s,i,self.outerBlockDelim1):
        # end = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        # start = i = i + len(self.outerBlockDelim1)
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if indentFlag is None: indentFlag = self.getIndent(s,i) > self.classIndent
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True ; indent = self.getIndent(s,i)
            if indentFlag is None: indentFlag = indent > self.classIndent
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = start = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,indentFlag
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,self.classId) # 'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            break
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None: i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    return j

    # if s[j:i].strip():
        # self.error(
            # '%s %s does not start a line. Leo must insert a newline\n%s' % (
                # tag,self.sigId,g.get_line(s,j)))
        # return i
    # else:
        # return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False
        if quick: return True

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace:
        if 1:
            g.trace(kind,'returns\n'+s[self.sigStart:i])
        else:
            g.trace(kind,'returns s[sigStart:i] = [%d:%d]' % (self.sigStart,i))
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = root = parent.copy()
    scanner.file_s = s

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()

    # Regularize leading whitespace for strict languages only.
    if self.strict:
        s = scanner.regularizeWhitespace(s)

    # Generate the nodes, including directive and section references.
    scanner.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: scanner.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed: self.regularizeError()

    return ''.join(result)
#@+node:ekr.20070808121958:regularizeError
def regularizeError (self):

    # Create the message.
    kind = g.choose(self.strict,'error','warning')
    s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
    message = '%s: inconsistent leading whitespace. %s' % (kind,s)

    # Issue an error or warning.
    if self.strict:
        self.error(message)
    else:
        print message
        g.es(message,color='red')

#@-node:ekr.20070808121958:regularizeError
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@+node:ekr.20071023082323:@test run
if g.unitTesting:

    ic = c.importCommands
    ic.methodName = 'test' ; ic.fileType = '.py'

    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()
    parent = p.copy()

    s = '''\
def spam():
    pass
'''
    s = g.adjustTripleString(s,-4)

    runner.run(s,parent)
#@-node:ekr.20071023082323:@test run
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:edreamleo.20070710110114.1:C scanner
#@+node:edreamleo.20070710110153:scanCText
def scanCText (self,s,parent,atAuto=False):

    scanner = self.cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110153:scanCText
#@+node:edreamleo.20070710093042:class cScanner (baseScannerClass)
class cScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = '#' # A hack: treat preprocess directives as comments(!)
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = ['*']
        self.sigFailTokens = [';','=']
#@-node:edreamleo.20070710093042:class cScanner (baseScannerClass)
#@-node:edreamleo.20070710110114.1:C scanner
#@+node:ekr.20071008130845:C# scanner
#@+node:ekr.20071008130845.1:scanCSharpText
def scanCSharpText (self,s,parent,atAuto=False):

    scanner = self.cSharpScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071008130845.1:scanCSharpText
#@+node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
class cSharpScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class','interface','namespace',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = []
        self.sigFailTokens = [';','='] # Just like C.
#@-node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
#@-node:ekr.20071008130845:C# scanner
#@+node:ekr.20070711060107:Elisp scanner
#@+node:ekr.20070711060107.1:scanElispText
def scanElispText (self,s,parent,atAuto=False):

    scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070711060107.1:scanElispText
#@+node:ekr.20070711060113:class elispScanner (baseScannerClass)
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False
    end = self.skipBlock(s,i)
    if not g.match(s,end,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len(key)
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner (baseScannerClass)
#@-node:ekr.20070711060107:Elisp scanner
#@+node:edreamleo.20070710110114:Java scanner
#@+node:edreamleo.20070710110114.2:scanJavaText
def scanJavaText (self,s,parent,atAuto=False):

    scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110114.2:scanJavaText
#@+node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
class javaScanner (baseScannerClass):

    @others
#@+node:ekr.20071019171430:javaScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
#@-node:ekr.20071019171430:javaScanner.__init__
#@+node:ekr.20071019170943:javaScanner.skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return i, ids and ids[-1]
#@-node:ekr.20071019170943:javaScanner.skipSigId
#@-node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
#@-node:edreamleo.20070710110114:Java scanner
#@+node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711104241.2:scanPascalText
def scanPascalText (self,s,parent,atAuto=False):

    scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@nonl
#@-node:ekr.20070711104241.2:scanPascalText
#@+node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
class pascalScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='pascal')

        # Set the parser delims.
        self.blockCommentDelim1 = '(*'
        self.blockCommentDelim2 = '*)'
        self.lineCommentDelim = '//'
        self.blockDelim1 = 'begin'
        self.blockDelim2 = 'end'
        self.classTags = []
        self.functionTags = ['function','procedure','constructor','destructor',]
#@-node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
#@-node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

    if scanner.isPurePHP(s):
        scanner.run(s,parent)
    else:
        fileName = scanner.fileName
        if not atAuto:
            g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
        scanner.createHeadline(
            parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php or ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return self.skipString()
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
#@-node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070703122141.99:scanPythonText
def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070703122141.99:scanPythonText
#@+node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
class pythonScanner (baseScannerClass):

    @others
#@+node:ekr.20070703122141.101: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

#@-node:ekr.20070703122141.101: __init__
#@+node:ekr.20070707113839:extendSignature
def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j < len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
#@-node:ekr.20070707113839:extendSignature
#@+node:ekr.20070707073627.4:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
#@-node:ekr.20070707073627.4:skipString
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@+node:ekr.20070803101619:skipSigTail
# This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
#@-node:ekr.20070803101619:skipSigTail
#@-node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
#@-node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070713075352:Default scanner
def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    if atAuto:
        for p in p.self_and_subtree_iter():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
#@-node:ekr.20070713075352:Default scanner
#@-node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070713075450:Unit tests
# atAuto must be False for unit tests: otherwise the test gets wiped out.

def cUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c')

def cSharpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c#')

def elispUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')

def htmlUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.htm')

def javaUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.java')

def pascalUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.pas')

def phpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.php')

def pythonUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.py')

def textUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.txt')

def defaultImporterUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,ext='.xxx')
#@+node:ekr.20070713082220:scannerUnitTest
def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.headString() ; old_root = p.copy()
    oldChanged = c.changed
    c.beginUpdate()
    try:
        d = g.app.unitTestDict
        expectedErrors = d.get('expectedErrors')
        expectedErrorMessage = d.get('expectedErrorMessage')
        expectedMismatchLine = d.get('expectedMismatchLine')
        g.app.unitTestDict = {
            'expectedErrors':expectedErrors,
            'expectedErrorMessage':expectedErrorMessage,
            'expectedMismatchLine':expectedMismatchLine,
        }
        if not fileName: fileName = p.headString()
        if not s: s = self.removeSentinelsCommand([fileName],toString=True)
        title = g.choose(h.startswith('@test'),h[5:],h)
        self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
        d = g.app.unitTestDict
        ok = ((d.get('result') and expectedErrors in (None,0)) or
            (
                # checkTrialWrite returns *True* if the following match.
                # d.get('result') == False and
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
                (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
            ))
        if not ok:
            g.trace('result',d.get('result'),
                'actualErrors',d.get('actualErrors'),
                'expectedErrors',d.get('expectedErrors'),
                'actualMismatchLine',d.get('actualMismatchLine'),
                'expectedMismatchLine', d.get('expectedMismatchLine'),
                '\nactualErrorMessage  ',d.get('actualErrorMessage'),
                '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
            )
        if not showTree and ok:
            while old_root.hasChildren():
                old_root.firstChild().doDelete()
            c.setChanged(oldChanged)

    finally:
        c.selectPosition(old_root)
        c.endUpdate()

    if g.app.unitTesting:
        assert ok

    return ok
#@-node:ekr.20070713082220:scannerUnitTest
#@-node:ekr.20070713075450:Unit tests
#@-node:ekr.20031218072017.3209:Import
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite & tests
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@+node:ekr.20070816103348:@test checkTriailWrite
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    runner.root = p.copy()

    g.app.unitTestDict ['expectedErrors'] = 1

    s1 = g.toUnicode('line1 , ,  , \nline2\n',encoding='utf-8')
    s2 = g.toUnicode('line1 , ,  , \nline2a\n',encoding='utf-8')
    runner.checkTrialWrite(s1=s1,s2=s2)
#@-node:ekr.20070816103348:@test checkTriailWrite
#@-node:ekr.20070703122141.104:checkTrialWrite & tests
#@+node:ekr.20070730093735:compareHelper & tests
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if not g.app.unitTesting or i+1 != expectedMismatch:
            # g.es_print('compareHelper')
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@+node:ekr.20070816101019:@test compareHelper
if g.unitTesting:

    ic = c.importCommands
    runner = ic.baseScannerClass(ic,atAuto=True,language='python')
    i = 0
    lines1 = ['abc',]
    lines2 = ['xyz',]
    runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20070816101019:@test compareHelper
#@-node:ekr.20070730093735:compareHelper & tests
#@+node:ekr.20070911110507:reportMismatch & test
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:@test pr
if False or g.unitTesting:
    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:@test pr
#@-node:ekr.20070911110507:reportMismatch & test
#@-node:ekr.20070808115837:Checking
#@-node:ekr.20071017163243:Fixed bug: utf-8 files now get imported properly
#@-node:ekr.20071023175714:4.4.4 final
#@-node:ekr.20070703172548:Leo 4.4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
