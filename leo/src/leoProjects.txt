#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20070626112754.1:Leo 4.4.3 beta 1 projects
#@+node:ekr.20070626112849:Bugs
#@+node:ekr.20070626111306:Fixed improper can not open myLeoSettings message
# can not open: C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es("%s not found in %s" % (name,configDir))
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20070626111306:Fixed improper can not open myLeoSettings message
#@-node:ekr.20070626112849:Bugs
#@+node:ekr.20070626150414:Features
#@+node:ekr.20070626150414.1:g.es and g.es_print print only to console during unit tests
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):

    print g.toEncodedString(s,'ascii')

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
#@+node:ekr.20070621092938:@test g.es_print
if g.unitTesting:

    g.es_print('\ntest of es_print: Ä‚',color='red')
#@-node:ekr.20070621092938:@test g.es_print
#@-node:ekr.20050707064040:es_print & test
#@+node:ekr.20070626132332:es
def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    log = app.log
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@-node:ekr.20070626132332:es
#@-node:ekr.20070626150414.1:g.es and g.es_print print only to console during unit tests
#@+node:ekr.20070626150545:Suppressed status messages during unit testing
#@-node:ekr.20070626150545:Suppressed status messages during unit testing
#@-node:ekr.20070626150414:Features
#@-node:ekr.20070626112754.1:Leo 4.4.3 beta 1 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
