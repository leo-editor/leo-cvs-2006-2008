#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20060904165452:4.4.2 projects
#@+node:ekr.20061010104745:Bugs
#@+node:ekr.20061010105844:Fixed crash when searching for headllines containing unicode chars
leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\unitTest.leo
FAILED (failures=1)
UnicodeDecodeError Exception in Tk callback
  Function: <function masterBindKeyCallback at 0x018BD970> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x02B0B5F8>,)
  Event type: KeyPress (type num: 2)
  
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2118, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 3133, in masterKeyHandler
    return k.getArg(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2755, in getArg
    if handler: handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7191, in searchWithPresentOptions
    self.generalSearchHelper(k.arg)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7066, in generalSearchHelper
    self.finder.findNextCommand()
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 7676, in findNextCommand
    self.findNext()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 684, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 711, in findNextMatch
    pos, newpos = self.search()
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 746, in search
    regexp=self.pattern_match,word=self.whole_word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 780, in searchHelper
    pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 856, in plainHelper
    elif self.matchWord(s,k,pattern):
  File "c:\prog\tigris-cvs\leo\src\leoFind.py", line 871, in matchWord
    s[i-1] not in self.word_chars or
UnicodeDecodeError: 'ascii' codec can't decode byte 0x83 in position 52: ordinal not in range(128)

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 49425
    state: 0
    time: 17007655
    type: 2
    widget: .21619056.21619656.24867464.minibuffer
    width: ??
    x: 526
    x_root: 782
    y: -648
    y_root: 240

#@+node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated (in the subclass by update_ivars) just before doing any find.
@c

<< do dummy initialization to keep Pychecker happy >>

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = None # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos >= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
#@+node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None
#@-node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
#@-node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
#@+node:ekr.20060417194232.2:findWord
def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            while i < len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1]))
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()

#@-node:ekr.20060417194232.2:findWord
#@+node:ekr.20051025071455.47:findNextWord
# Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # Start the word at the first letter.
        i = 0
        while i < len(line) and not g.isWordChar1(line[i]):
            i += 1
        if i < len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j < len(line) and g.isWordChar(line[j]):
                j += 1
            word = line[i:j]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert",">=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@-node:ekr.20061010105844:Fixed crash when searching for headllines containing unicode chars
#@+node:ekr.20061010105932:Fixed failed unit test
@nocolor

FAIL: @test k.inverseCommandsDict is inverse of c.commandsDict
AssertionError: cl not in inverseCommandsDict.values()

I just hacked the unit test not to complain about abbreviations.
Another solution would be to allow the values of k.inverseCommandsDict to be lists.
#@nonl
#@+node:ekr.20060609150503:k.initAbbrev
def initAbbrev (self):
    
    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d.keys():
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

def initOneAbbrev (self,commandName,key):
    k = self ; c = k.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.es_print('bad abbrev: %s: unknown command name: %s' %
                (key,commandName),color='blue')
#@-node:ekr.20060609150503:k.initAbbrev
#@-node:ekr.20061010105932:Fixed failed unit test
#@+node:ekr.20061007094817:Fixed bugs in cycle-all-focus command
@

The logic in cycleAllFocus is now much cleaner.
The cycle focus commands work in the minibuffer *only* if not tab-completion is done.
I think this is the old, horrible problems with Pmw focus: it's a very small nit.
#@nonl
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget
   
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i >= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body
    
    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)
    
    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@+node:ekr.20060613090701:cycleAllFocus
editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        if n > 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount > n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n > 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount > n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = self.logWidgetCount = 0
        
    if trace: print 'old: %10s new: %10s' % (w_name(w),w_name(pane))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)
#@nonl
#@-node:ekr.20060613090701:cycleAllFocus
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName,wrap=wrap)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20060528170438:cycleEditorFocus
def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.onFocusIn(w2,setFocus=True)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # print '***',g.app.gui.widget_name(w2),id(w2)

    return 'break'
#@-node:ekr.20060528170438:cycleEditorFocus
#@+node:ekr.20060613131217:cycleTabFocus
def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() > 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return 
#@nonl
#@-node:ekr.20060613131217:cycleTabFocus
#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    
    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@-node:ekr.20050920085536.45:callAltXFunction
#@+node:ekr.20051001050607:endCommand
def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # print 'endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers()
            k.newMinibufferWidget = None
#@-node:ekr.20051001050607:endCommand
#@+node:ekr.20060207142332:c.traceFocus
trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        print '%4d' % (c.trace_focus_count),c.widget_name(w),g.callers(8)
#@-node:ekr.20060207142332:c.traceFocus
#@+node:ekr.20060207140352:c.masterFocusHandler
def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if trace: print \
        'requested',c.widget_name(c.requestedFocusWidget),\
        'present',c.widget_name(c.hasFocusWidget)
    
    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        if trace: print 'no change.',c.widget_name(w)
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        if trace: print '*'*20,'oops: moving to body pane.'
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler
#@-node:ekr.20060207140352:c.masterFocusHandler
#@+node:ekr.20060127183752:masterKeyHandler
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>
        
    << handle per-pane bindings >>
    << handle keys without bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
    
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(
        # 'keysym',repr(event.keysym or ''),
        'stroke',repr(stroke),
        'state',state,
        'unboundKeyAction',k.unboundKeyAction)
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(g.app.gui.isTextWidget(w),w_name,key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@+node:ekr.20060608070318:<< handle keys without bindings >>
if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  <Return> is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif event and event.keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    # g.trace(stroke,event.char,event.keysym)
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20060608070318:<< handle keys without bindings >>
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
        c.traceFocus(w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
#@-node:ekr.20060205103842:c.get/request/set_focus
#@-node:ekr.20061007094817:Fixed bugs in cycle-all-focus command
#@+node:ekr.20061008091617:Fixed bug: with Alt-n keys
@

@command whaterver @key Alt-1 didn't work
Actually, no Alt-n keys worked for n in (1,2,3,4,5) in any context.

Happily, the problem was a confusion about what Alt-1 means.
Apparently it means Alt-Button-1 rather than Alt-Key-1.

The solution was to insert an explicit Key- prefix in k.tkBindingFromStroke.
I also made a minor mod to printBindings.
#@nonl
#@+node:ekr.20051015110547:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=False):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    f = c.commandsDict.get(commandName)
    verbose = verbose and not g.app.unitTesting
    if f and f.__name__ != 'dummyCallback' and verbose:
        g.es_print('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
    else:
        # Try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel2 = bunch.val ; pane2 = bunch.pane
            if accel2 and not pane2.endswith('-mode'):
                shortcut2 = accel2
                stroke = k.shortcutFromSetting(shortcut2)
                break
        else: stroke = None
  
    if stroke:
        ok = k.bindKey (pane,stroke,func,commandName) # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if verbose and ok:
             g.es_print('@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    elif verbose:
        g.es_print('@command: %s' % (commandName),color='blue')
                
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in d.values():
            for key in d.keys():
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
#@nonl
#@-node:ekr.20051015110547:k.registerCommand
#@+node:ekr.20060605130652:makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):
    
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    
    k = self ; c = k.c ; f = c.frame
   
    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)
    
    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        widgets=(c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)
    
    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
#@-node:ekr.20060605130652:makeMasterGuiBinding
#@+node:ekr.20060131075440:k.tkbindingFromStroke
def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    # g.trace('<%s>' % stroke)
    return '<%s>' % stroke
#@-node:ekr.20060131075440:k.tkbindingFromStroke
#@+node:ekr.20051012201831:printBindings & helper
def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)
    data = [] ; n1 = 4 ; n2 = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' %s:' % (b.pane))
            s1 = pane
            s2 = k.prettyPrintKey(key,brief=True)
            s3 = b.commandName
            n1 = max(n1,len(s1))
            n2 = max(n2,len(s2))
            data.append((s1,s2,s3),)
            
    # Print keys by type:
    sep = '-' * n1
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Shift', 'Alt+Ctrl', 'Alt+Key','Alt',
        'Ctrl+Shift', 'Ctrl', 'Shift',
    ):
        data2 = []
        for item in data:
            s1,s2,s3 = item
            if s2.startswith(prefix):
                data2.append(item)
        g.es('%s %s' % (sep, prefix),tabName=tabName)
        self.printBindingsHelper(data2,n1,n2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    g.es('%s %s' % (sep, 'Plain Keys',),tabName=tabName)
    self.printBindingsHelper(data,n1,n2,prefix=None)
    state = k.unboundKeyAction 
    k.showStateAndMode()
#@+node:ekr.20061007185125:printBindingsHelper
def printBindingsHelper (self,data,n1,n2,prefix):
        
    n = prefix and len(prefix)+1 or 0 # Add 1 for the '+' after the prefix.
    
    data1 = [z for z in data if z and z[1] and len(z[1][n:]) == 1]
        # The list of all items with only one character following the prefix.
    data2 = [z for z in data if z and z[1] and len(z[1][n:]) >  1]
        # The list of all other items.
                
    # This isn't perfect in variable-width fonts.
    for data in (data1,data2):
        data.sort(lambda x,y: cmp(x[1],y[1]))
        for s1,s2,s3 in data:
            g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
#@-node:ekr.20061007185125:printBindingsHelper
#@-node:ekr.20051012201831:printBindings & helper
#@+node:ekr.20060201083154:k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):
    
    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.tkBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'<%s>' % s)
#@-node:ekr.20060201083154:k.prettyPrintKey
#@-node:ekr.20061008091617:Fixed bug: with Alt-n keys
#@+node:ekr.20061010192251:Fix bug in ops plugin
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3956836

p.clone(p) -> p.clone() in the big reorg.
#@-node:ekr.20061010192251:Fix bug in ops plugin
#@+node:ekr.20061011163719:Fixed crasher on script button balloons
http://sourceforge.net/forum/message.php?msg_id=3958333
By: mstarzyk

I get the following exception while opening a leo file:

Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoGlobals.py", line 2441, in doHook
    return f(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 91, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 69, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 48, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 193, in onCreate
    sc.createAllButtons()
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 249,
in createAllButtons
    self.createAtButtonButton(p)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 316,
in createAtButtonButton
    b = self.createAtButtonIconButton(p,buttonText,statusLine,shortcut)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 588,
in createAtButtonIconButton
    b = self.createIconButton(text=buttonText,statusLine=statusLine,bg=bg)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 431,
in createIconButton
    self.createBalloon(b,statusLine)
  File "C:\Program Files\Leo\plugins\mod_scripting.py", line 459,
in createBalloon
    balloon.bind(w,label)
  File "C:\Program Files\Leo\extensions\Pmw\Pmw_1_2\lib\PmwBalloon.py", line
76, in bind
    enterId = widget.bind('<Enter>',
AttributeError: 'NoneType' object has no attribute 'bind'

@nocolor

This is strange: I never have a problem with it.
The fix: don't call balloon.bind if balloon is None.
#@nonl
#@-node:ekr.20061011163719:Fixed crasher on script button balloons
#@+node:ekr.20060928194335:Fix bug: closing a window after removing a script button can crash
#@-node:ekr.20060928194335:Fix bug: closing a window after removing a script button can crash
#@+node:ekr.20061011184009:The end-of-script message no longer yanks focus from tabs
@nocolor

Do *not* bother with trying to preserve the focus.
Instead, the 'end of script' message should just go to whatever log pane is on top.

@color
#@nonl
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@-node:EKR.20040627100424:<< unredirect output >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@-node:ekr.20061011184009:The end-of-script message no longer yanks focus from tabs
#@+node:ekr.20061011151640:Fixed  warning if minibuffer command does not exist when making menus
@ The warning was disabled due to a programming error (not not)
Enabling this found two errors: view-lossage (missing comma) and
find-with-present-options --> search-with-present-options.
#@nonl
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@+node:ekr.20051021091958:<< get label & command or continue >>
if type(data) == type(''):
    # New in Leo 4.4.2: Can use the same string for both the label and the command string.
    ok = True
    label = self.capitalizeMinibufferMenuName(data)
    command = data.replace('&','')
    if label == '-':
        self.add_separator(menu)
        continue # That's all.
else:
    ok = type(data) in (type(()), type([])) and len(data) in (2,3)
    if ok:
        if len(data) == 2:
            # New in 4.4b2: command can be a minibuffer-command name (a string)
            label,command = data
        else:
            # New in 4.4: we ignore shortcuts bound in menu tables.
            label,junk,command = data
            
        if label in (None,'-'):
            self.add_separator(menu)
            continue # That's all.
    else:
        g.trace('bad data in menu table: %s' % repr(data))
        continue # Ignore bad data
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val
                if bunch.pane  == 'text': break # New in Leo 4.4.2: prefer text bindings.
    else:
        if not g.app.unitTesting and not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20061011151640:Fixed  warning if minibuffer command does not exist when making menus
#@+node:ekr.20061011131836:Fixed new unicode bug
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3957980
By: dcbbcd

This was a major effort.

What I did:
    
- Defined g.isWordChar in terms of ch.isalnum()

- Replace almost all instances of string.letters and string.digits by calls to
  ch.isalnum(), ch.isalpha(), ch.isdigit(), etc.
  
- Similarly, replaced word_chars.

- The new code uses string literals only for

a) small constants like '+-' and
b) constants in a very limited context, as in the input to regexp.

To do: look for string.printable

@color
#@nonl
#@+node:ekr.20061012161012:Found: string.letters
# most uses of these should be converted to g.isWordChar.
#@nonl
#@+node:ekr.20060417194232.2:findWord
def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            while i < len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1]))
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()

#@-node:ekr.20060417194232.2:findWord
#@+node:ekr.20051025071455.47:findNextWord
# Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # Start the word at the first letter.
        i = 0
        while i < len(line) and not g.isWordChar1(line[i]):
            i += 1
        if i < len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j < len(line) and g.isWordChar(line[j]):
                j += 1
            word = line[i:j]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert",">=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@+node:ekr.20060220104902:insertNormalChar
def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = g.app.gui.getSelectedText(w) + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = g.app.gui.getSelectedText(w)
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = g.app.gui.getSelectedText(w)
        if keysym == 'parenleft':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20060220104902:insertNormalChar
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and not g.isWordChar(prev[-1]):
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20050920084036.238:appendToRegister
def appendToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('append-to-reg')
    
    if state == 0:
        k.setLabelBlue('Append to register: ',protect=True)
        k.setState('append-to-reg',1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = val + w.get('sel.first','sel.last')
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.238:appendToRegister
#@+node:ekr.20050920084036.237:prependToRegister
def prependToRegister (self,event):
    
    '''Prompt for a register name and prepend the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('prepend-to-reg')
    
    if state == 0:
        k.setLabelBlue('Prepend to register: ',protect=True)
        k.setState('prepend-to-reg',1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                try:
                    val = w.get('sel.first','sel.last') + val
                except Exception:
                    pass
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.237:prependToRegister
#@+node:ekr.20050920084036.239:copyRectangleToRegister
def copyRectangleToRegister (self,event):
    
    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 <= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.239:copyRectangleToRegister
#@+node:ekr.20050920084036.240:copyToRegister
def copyToRegister (self,event):
    
    '''Prompt for a register name and append the selected text to the register's contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('copy-to-reg')
    
    if state == 0:
        k.commandName = 'copy-to-register'
        k.setLabelBlue('Copy to register: ',protect=True)
        k.setState('copy-to-reg',1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                try:
                    val = w.get('sel.first','sel.last')
                except Exception:
                    g.es_exception()
                    val = ''
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.240:copyToRegister
#@+node:ekr.20050920084036.241:incrementRegister
def incrementRegister (self,event):
    
    '''Prompt for a register name and increment its value if it has a numeric value.'''
    
    c = self.c ; k = self.k ; state = k.getState('increment-reg')
    
    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.241:incrementRegister
#@+node:ekr.20050920084036.242:insertRegister
def insertRegister (self,event):
    
    '''Prompt for a register name and and insert the value of another register into its contents.'''
    
    c = self.c ; k = self.k ; state = k.getState('insert-reg')
    
    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    w.insert('insert',val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.242:insertRegister
#@+node:ekr.20050920084036.243:jumpToRegister
def jumpToRegister (self,event):
    
    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            if self._checkIfRectangle(event): return
            key = event.keysym.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.mark_set('insert',val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.243:jumpToRegister
#@+node:ekr.20050920084036.244:numberToRegister (not used)
@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):
    
    k = self.k ; state = k.getState('number-to-reg')
    
    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            # self.registers[event.keysym.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
#@-node:ekr.20050920084036.244:numberToRegister (not used)
#@+node:ekr.20050920084036.245:pointToRegister
def pointToRegister (self,event):
    
    '''Prompt for a register name and put a value indicating the insert point in the register.'''
    
    c = self.c ; k = self.k ; state = k.getState('point-to-reg')
    
    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = w.index('insert')
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.245:pointToRegister
#@+node:ekr.20050920084036.246:viewRegister
def viewRegister (self,event):
    
    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')
    
    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@-node:ekr.20050920084036.246:viewRegister
#@+node:ekr.20060621164312.4:<< create press-buttonText-button command >>
aList = [g.choose(ch.isalnum(),ch,'-') for ch in buttonText]

buttonCommandName = ''.join(aList)
buttonCommandName = buttonCommandName.replace('--','-')
buttonCommandName = 'press-%s-button' % buttonCommandName.lower()

# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName,None,executeScriptCallback,pane='button',verbose=False)
#@-node:ekr.20060621164312.4:<< create press-buttonText-button command >>
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@+node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        accel_ch = (string.digits + string.letters.upper()) # Not a unicode problem.
        label = "%s %s" % (accel_ch[i-2],g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1
#@-node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
#@-node:ekr.20061012161012:Found: string.letters
#@+node:ekr.20061012172219:Found: string.digits
#@+node:ekr.20050920084036.128:zapToCharacter
def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        c = k.c
        ch = event and event.char
        k.resetLabel()
        k.clearState()
        if len(event.char) != 0 and not ch.isspace():
            i = w.search(ch,'insert',stopindex='end')
            if i != -1:
                s = w.get('insert','%s' % i)
                self.addToKillBuffer(s)
                w.delete('insert','%s' % i)
#@-node:ekr.20050920084036.128:zapToCharacter
#@+node:ekr.20041005105605.52:<< Set childIndex >>
i = g.skip_ws(s,i) ; j = i
while i < len(s) and s[i].isdigit():
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
#@-node:ekr.20041005105605.52:<< Set childIndex >>
#@+node:ekr.20041005105605.53:<< Set cloneIndex >>
while i < len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i < len(s) and s[i].isdigit():
            i += 1
        if j < i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
#@-node:ekr.20041005105605.53:<< Set cloneIndex >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Pre Leo 4.4.1: Skip to the next minus sign or end-of-line.
    # Leo 4.4.1 +:   Skip to next minus sign, end-of-line, or non numeric character.
    # This is required to handle trailing comment delims properly.
    i += len(version_tag)
    j = i
    while i < len(s) and (s[i] == '.' or s[i].isdigit()):
        i += 1

    if j < i:
        pass
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20031218072017.2808:skip_id
def skip_id(self,s,i,chars=None):

    n = len(s)
    chars = chars and g.toUnicode(chars,encoding='ascii') or u''
    while i < n and (g.isWordChar(s[i]) or s[i] in chars):
            i += 1
    return i
#@-node:ekr.20031218072017.2808:skip_id
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1].isdigit():
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:EKR.20040526204706.1:getDouble
def getDouble (self):

    self.skipWs()
    i = self.fileIndex ; buf = self.fileBuffer
    floatChars = 'eE.+-'
    n = len(buf)
    while i < n and (buf[i].isdigit() or buf[i] in floatChars):
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting float constant")
    val = float(buf[self.fileIndex:i])
    self.fileIndex = i
    return val
#@-node:EKR.20040526204706.1:getDouble
#@+node:EKR.20040526204706.6:getLong
def getLong (self):

    self.skipWs() # guarantees at least one more character.
    i = self.fileIndex
    if self.fileBuffer[i] == u'-':
        i += 1
    n = len(self.fileBuffer)
    while i < n and self.fileBuffer[i].isdigit():
        i += 1
    if i == self.fileIndex:
        raise BadLeoFile("expecting int constant")
    val = int(self.fileBuffer[self.fileIndex:i])
    self.fileIndex = i
    return val
#@-node:EKR.20040526204706.6:getLong
#@+node:ekr.20031218072017.3177:is_c_id
def is_c_id(ch):

    return g.isWordChar(ch)

#@-node:ekr.20031218072017.3177:is_c_id
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20031218072017.3186:skip_c_id
def skip_c_id(s,i):

    n = len(s)
    while i < n and g.isWordChar(s[i]):
        i += 1
    return i
#@-node:ekr.20031218072017.3186:skip_c_id
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i < n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
#@nonl
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.3188:skip_long
def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i >= n or (not s[i].isdigit() and s[i] not in u'+-'):
        return i, None
    j = i
    if s[i] in u'+-': # Allow sign before the first digit
        i +=1
    while i < n and s[i].isdigit():
        i += 1
    try: # There may be no digits.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
#@-node:ekr.20031218072017.3188:skip_long
#@+node:ekr.20031218072017.3267:skipElispId
def skipElispId (self,s,i):

    n = len(s)
    while i < n and g.isWordChar(s[i]):
        i += 1
    return i
#@-node:ekr.20031218072017.3267:skipElispId
#@+node:ekr.20060128103640.2:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
            
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20060128103640.2:<< compute the last field >>
#@+node:ekr.20050920085536.73:universalDispatcher & helpers
def universalDispatcher (self,event):
    
    '''Handle accumulation of universal argument.'''
    
    << about repeat counts >>

    k = self ; state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = event.keysym
            # Stroke is <Key> for plain keys, <Control-u> (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '<Key>' and (keysym.isdigit() or keysym == u'-'):
            k.updateLabel(event)
        elif stroke == '<Key>' and keysym in (
            'Alt_L','Alt_R','Shift_L','Shift_R','Control_L','Control_R'):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '<Control-x>':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
#@+node:ekr.20051006083627.1:<< about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@-node:ekr.20051006083627.1:<< about repeat counts >>
#@+node:ekr.20050920085536.75:executeNTimes
def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'<%s>' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('<Key>',keycode=event.keycode,keysym=event.keysym)
#@-node:ekr.20050920085536.75:executeNTimes
#@+node:ekr.20050920085536.76:doControlU
def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@-node:ekr.20050920085536.76:doControlU
#@-node:ekr.20050920085536.73:universalDispatcher & helpers
#@+node:ekr.20031218072017.3593:scan_short_val
# This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):
    
    
    if i >= len(s) or not s[i].isdigit():
        return i, -1
    j = i
    while i < len(s) and s[i].isdigit():
        i += 1
    val = int(s[j:i])
    # g.trace(s[j:i],val)
    return i, val
#@nonl
#@-node:ekr.20031218072017.3593:scan_short_val
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch.isalnum()])
    
def canonicalizeTranslatedMenuName (self,name):
    
    return ''.join([ch for ch in name.lower() if ch not in u'& \t\n\r'])

#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20051022044950:computeOldStyleShortcutKey
def computeOldStyleShortcutKey (self,s):
    
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    
    return ''.join([ch for ch in s.strip().lower() if ch.isalnum()])
#@-node:ekr.20051022044950:computeOldStyleShortcutKey
#@+node:ekr.20031218072017.1989:<< eliminate invalid characters >>
e = self.id_entry
s = e.get().strip()
i = 0 ; ok = True
while i < len(s):
    ch = s[i]
    if not ch.isalnum():
        e.delete(str(i))
        s = e.get()
        ok = False
    else:
        i += 1
if not ok: return
#@-node:ekr.20031218072017.1989:<< eliminate invalid characters >>
#@+node:ekr.20031218072017.3881:<< eliminate non-numbers >>
e = self.number_entry
s = e.get().strip()

i = 0
while i < len(s):
    ch = s[i]
    if not ch.isdigit():
        e.delete(str(i))
        s = e.get()
    else:
        i += 1
#@-node:ekr.20031218072017.3881:<< eliminate non-numbers >>
#@-node:ekr.20061012172219:Found: string.digits
#@+node:ekr.20061012185332:Found: string.
#@+node:ekr.20031218072017.1896:doNormalState
def doNormalState (self,s,i):
    
    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&<>' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&*()_+-={}|[];':\",./<>?")
    ):
        << handle possible keyword >>
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        << handle at keyword >>
    elif g.match(s,i,self.single_comment_start):
        << handle single-line comment >>
    elif g.match(s,i,self.block_comment_start):
        << start block comment >>
    elif ch == '%' and self.language=="cweb":
        << handle latex line >>
    elif self.language=="latex":
        << handle latex normal character >>
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        << handle string >>
    elif ch == '#' and self.has_pp_directives:
        << handle C preprocessor line >>
    elif self.language == "php" and (g.match(s,i,"<") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        << handle special php keywords >>
    elif ch == ' ':
        << handle blank >>
    elif ch == '\t':
        << handle tab >>
    else:
        << handle normal character >>

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress < i)
    return i,state
#@+node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
    << handle possible latex keyword >>
elif self.language == "html":
    << handle possible html keyword >>
elif self.language == "forth":
    << handle possible forth keyword >>
else:
    << handle general keyword >>
i = j
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
    if i + 1 < len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
    if g.match(s,i,"<!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
    if g.match(s,i,"</"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,">"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20041107093219.3:<< handle possible forth keyword >>
j = self.skip_id(s,i+1,chars="`~!@#$%^&*()-_=+[]{};:'\\\",./<>?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
#@-node:ekr.20041107093219.3:<< handle possible forth keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@<"):
        << handle cweb ref or def >>
    else:
        word = self.getCwebWord(s,i)
        if word:
            << Handle cweb control word >>
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@>",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
    j = s.find("@>",i)
    if j > -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@-node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@-node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1612:<< handle string >>
# g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?>"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1
#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1908:Valid when not in latex_mode
#@-node:ekr.20031218072017.1896:doNormalState
#@+node:ekr.20031218072017.2803:getCwebWord
def getCwebWord (self,s,i):
    
    # g.trace(g.get_line(s,i))
    if not g.match(s,i,"@"):
        return None
    
    ch1 = ch2 = word = None
    if i + 1 < len(s): ch1 = s[i+1]
    if i + 2 < len(s): ch2 = s[i+2]

    if g.match(s,i,"@**"):
        word = "@**"
    elif not ch1:
        word = "@"
    elif not ch2:
        word = s[i:i+2]
    elif (
        (ch1 in string.ascii_letters and not ch2 in string.ascii_letters) or # single-letter control code
        ch1 not in string.ascii_letters # non-letter control code
    ):
        word = s[i:i+2]

    # if word: g.trace(word)
        
    return word
#@-node:ekr.20031218072017.2803:getCwebWord
#@+node:ekr.20031218072017.3132:init_trace
def init_trace(args,echo=1):

    t = app.trace_list
    args = g.get_Sherlock_args(args)

    for arg in args:
        if arg[0] in string.ascii_letters: prefix = '+'
        else: prefix = arg[0] ; arg = arg[1:]
        
        if prefix == '?':
            print "trace list:", t
        elif prefix == '+' and not arg in t:
            t.append(string.lower(arg))
            if echo:
                print "enabling:", arg
        elif prefix == '-' and arg in t:
            t.remove(string.lower(arg))
            if echo:
                print "disabling:", arg
        else:
            print "ignoring:", prefix + arg
#@-node:ekr.20031218072017.3132:init_trace
#@+node:ekr.20031218072017.3124:sanitize_filename
def sanitize_filename(s):

    """Prepares string s to be a valid file name:
    
    - substitute '_' whitespace and characters used special path characters.
    - eliminate all other non-alphabetic characters.
    - strip leading and trailing whitespace.
    - return at most 128 characters."""

    result = ""
    for ch in s.strip():
        if ch in string.ascii_letters:
            result += ch
        elif ch in string.whitespace: # Translate whitespace.
            result += '_'
        elif ch in ('.','\\','/',':'): # Translate special path characters.
            result += '_'
    while 1:
        n = len(result)
        result = result.replace('__','_')
        if len(result) == n:
            break
    result = result.strip()
    return result [:128]
#@-node:ekr.20031218072017.3124:sanitize_filename
#@+node:ekr.20031218072017.3601:<< set token_type for CWEB mode >>
i = g.skip_ws(s,i)
if g.match(s,i,"@*") or g.match(s,i,"@ "): kind = at_doc
elif g.match(s,i,"@<"): i, kind, end = self.skip_section_name(s,i)
elif g.match(s,i,"@@"): kind = at_at
elif g.match_word(s,i,"@c") or g.match_word(s,i,"@p"): kind = at_code
elif i < len(s) and s[i] == '@':
    if   i + 1 >= len(s): kind = at_doc
    elif i + 1 < len(s) and s[i+1] not in string.ascii_letters:
        kind = at_web
    else: kind = at_other # Set kind later
else: kind = plain_line
#@-node:ekr.20031218072017.3601:<< set token_type for CWEB mode >>
#@+node:ekr.20031218072017.1607:<< define dispatch dicts >>
self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}
    
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns
    
    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.
    
    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective
                
    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword
    
    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword
        
    if self.language == "php":
        dict1 ['<'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword
    
    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["<<"] = self.doPossibleSectionRefOrDef
        
    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
    
    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
#@-node:ekr.20031218072017.1607:<< define dispatch dicts >>
#@+node:ekr.20041005105605.52:<< Set childIndex >>
i = g.skip_ws(s,i) ; j = i
while i < len(s) and s[i].isdigit():
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
#@-node:ekr.20041005105605.52:<< Set childIndex >>
#@+node:ekr.20060216163305:definePatterns
def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20060216163305:definePatterns
#@+node:ekr.20051126124705:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):
    
    c = self.c ; k = self.k
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = event and event.keysym
    ch = event and event.char or ''
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in ('space','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == 'period':
        self.chain()
    elif keysym == 'question':
        self.info()
    elif keysym == 'exclam':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20051126124705:autoCompleterStateHandler
#@+node:ekr.20041005105605.198:directiveKind4 & test
def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 >= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if s[i+1] not in string.ascii_letters:
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@+node:ekr.20050608103755:test_directiveKind4
def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
#@-node:ekr.20050608103755:test_directiveKind4
#@-node:ekr.20041005105605.198:directiveKind4 & test
#@+node:ekr.20060606095344:test_isPlainKey
def test_isPlainKey (self):
    
    import string
    
    k = c.k # self is a dummy argument
    
    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)
        
    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
#@-node:ekr.20060606095344:test_isPlainKey
#@-node:ekr.20061012185332:Found: string.
#@-node:ekr.20061011131836:Fixed new unicode bug
#@+node:ekr.20061012213447:Made 'About Plugin' dialog scrollable
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3960993

I happen to select Plugins->Scripting and the "About Scripting" window opened...a
huge, long, "about" window with no scroll-bars that was taller than my screen.

Can the "About" info be put into a resizable window (with scroll-bars) instead,
with a reasonable initial size?

Kam-Yung

#@-node:ekr.20061012213447:Made 'About Plugin' dialog scrollable
#@+node:ekr.20061013092901:Removed unwanted key-state message
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3961623
By: vpe

Leo periodically prints 'Key state: Insert' message in the status area even
though I never change insert mode. It does not seem to be necessary and it destroys
UNL info. I get this message when I open new file, insert new node, type (,
type . in Python nodes, and probably on other events.

To get rid of it, I added one line to showStateAndMode(self) in
Code-->@thin leoKeys.py-->class keyHandlerClass-->Input
State-->showStateAndMode

....if hasattr(frame,'clearStatusLine'):
........if not state.capitalize()=='Insert': # <---- added
............frame.clearStatusLine()
............put = frame.putStatusLine
............put('Key state: ',color='blue')
............put('%s' % state.capitalize())

There should be a more intelligent solution. 


Also, command set-overwrite-state works but generates a Tk error.

specs:
Leo 4.4.2 beta 2, build  1.69 , October 9, 2006
Python 2.5.0, Tk 8.4.12, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4
#@-node:ekr.20061013092901:Removed unwanted key-state message
#@-node:ekr.20061010104745:Bugs
#@+node:ekr.20061010115312:Features
#@+node:ekr.20061009152554:Removed .leoRecentFiles.txt from distribution and cvs
@nocolor

- @bool write_recent_files_as_needed = True

People who don't want Leo to update .leoRecentFiles.txt can set this to False.

- Remove .leoRecentFiles from cvs
- Remove .leoRecentFiles from distribution list.

@color
#@nonl
#@+node:ekr.20041117062717.2:ctor (configClass)
def __init__ (self):
    
    self.configsExist = False # True when we successfully open a setting file.
    self.defaultFont = None # Set in gui.getDefaultConfigFont.
    self.defaultFontFamily = None # Set in gui.getDefaultConfigFont.
    self.globalConfigFile = None # Set in initSettingsFiles
    self.homeFile = None # Set in initSettingsFiles
    self.inited = False
    self.modeCommandsDict = {} # For use by @mode logic. Keys are command names, values are g.Bunches.
    self.myGlobalConfigFile = None
    self.myHomeConfigFile = None
    self.recentFilesFiles = [] # List of g.Bunches describing .leoRecentFiles.txt files.
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Inited later...
    self.panes = None
    self.sc = None
    self.tree = None

    self.initDicts()
    self.initIvarsFromSettings()
    self.initSettingsFiles()
    self.initRecentFiles()
#@-node:ekr.20041117062717.2:ctor (configClass)
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []

    # This can't be done in initSettingsFiles because the local directory does not exits.
    localDirectory = g.os_path_dirname(fileName)
    
    #  Set the local leoSettings.leo file.
    localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
    if not g.os_path_exists(localConfigFile): localConfigFile = None
    
    # Set the local myLeoSetting.leo file.
    myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
    if not g.os_path_exists(myLocalConfigFile): myLocalConfigFile = None
    
    self.write_recent_files_as_needed = False # Will be set later.
    
    # Init settings from leoSettings.leo files, including myLeoSettings.leo.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            if c and localFlag:
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
            self.readRecentFilesFile(c,path)
    if self.write_recent_files_as_needed:
        self.createRecentFiles(fileName)

    self.inited = True
    self.setIvarsFromSettings(None)
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,c,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'
    
    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    if not g.os_path_exists(fileName):
        # g.trace('does not exist',fileName)
        return
        
    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return

    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
        self.appendToRecentFiles(lines)
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self,fileName):
    
    localPath,junk = g.os_path_split(fileName)

    for path in (g.app.homeDir,g.app.globalConfigDir,localPath):
        fileName = g.os_path_join(path,'.leoRecentFiles.txt')
        if g.os_path_exists(fileName):
            # g.es_print('found %s' % fileName)
            return

    # Create the file in the home directory.
    try:
        fileName = g.os_path_join(g.app.homeDir,'.leoRecentFiles.txt')
        f = file(fileName,'w')
        f.close()
        g.es_print('Created %s' % (fileName),color='red')
        return
    except Exception:
        g.es_print('Exception creating %s' % (fileName),color='red')
        g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,'.leoRecentFiles.txt')
            if g.os_path_exists(fileName):
                # g.es_print('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        g.trace('----- not found:',localFileName)
        return
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@-node:ekr.20061009152554:Removed .leoRecentFiles.txt from distribution and cvs
#@+node:ekr.20060527184656:Added minibuffer and Settings menus
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3588148
By: vpe

One way to make Leo more newbie friendly is to add menu items for key features
that are likely to cause confusion in the beginning.

What I did:
    
- Added minibuffer submenu.
- Renamed help to help-for-minibuffer
- Added Pickers submenu
- Added help-for-settings command

@color
#@nonl
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPanesTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()
#@nonl
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
def defineCmdsMenuAbbrevTable (self):
    
    self.cmdsMenuAbbrevTable = [
        # &: a,e,i,k,l,r,w,v
        'abbre&v-mode',
        '-',
        '&list-abbrevs',
        '&read-abbrev-file',
        '&write-abbrev-file',
        '-',
        '&add-global-abbrev',
        '&inverse-add-global-abbrev',
        '&kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&expand-region-abbrevs',
    ]
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
#@+node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &: a,c,d
        '&add-editor',
        '&cycle-editor-focus',
        '&delete-editor',
    ]
#@nonl
#@-node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&append-to-buffer',
        '&kill-buffer',
        'list-&buffers',
        '&list-buffers-alphabetically',
        '&prepend-to-buffer',
        '&rename-buffer',
        '&switch-to-buffer',
    ]
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &: l,p,s,w
        'extend-to-&line',
        'extend-to-&paragraph',
        'extend-to-&sentence',
        'extend-to-&word',
    ]
    
    self.cursorMenuForwardTable = [
        # &: b,c,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&word',
        '-',
        '&next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &: b,c,l,n,p,s,w
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&word-extend-selection',#
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20060923060822:defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
#@-node:ekr.20060923060822:defineCmdsMenuFocusTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable
def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&load-file',
        '-',
        '&start-kbd-macro',
        '&end-kbd-macro',
        '&name-last-kbd-macro',
        '-',
        '&call-last-keyboard-macro',
        '&insert-keyboard-macro',
    ]
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable
#@+node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
def defineCmdsMenuMinibufferTable (self):
    
    self.cmdsMenuMinibufferTable = [
        # &: f,h,i,q,r,s,v
        '&full-command',
        'keyboard-&quit',
        '&repeat-complex-command',
        '&view-lossage',
        '-',
        '&show-mini-buffer',
        'h&ide-mini-buffer',
        '-',
        '&help-for-minibuffer',
    ]
#@-node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
#@+node:ekr.20060924120752:defineCmdsMenuPanesTable
def defineCmdsMenuPanesTable (self):

    self.cmdsMenuPanesTable = [
        # &: a,b,d,f,l,n,o,p,u,x,y
        'contract-&body-pane',
        'contract-&log-pane',
        'contract-&outline-pane',
        'contract-&pane',
        '-',
        'expand-bo&dy-pane',
        'expand-lo&g-pane',
        'expand-o&utline-pane',
        'expand-pa&ne',
        '-',
        '&fully-expand-body-pane',
        'full&y-expand-log-pane',
        'fully-e&xpand-outline-pane',
        'fully-exp&and-pane',
    ]
    
#@nonl
#@-node:ekr.20060924120752:defineCmdsMenuPanesTable
#@+node:ekr.20061011085641:defineCmdsMenuPickersTable
def defineCmdsMenuPickersTable (self):
    
    self. cmdsMenuPickersTable = [
        'show-&colors',
        'show-find-&options',
        'show-&fonts',
    ]
#@nonl
#@-node:ekr.20061011085641:defineCmdsMenuPickersTable
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&clear-rectangle',
        'c&lose-rectangle',
        '&delete-rectangle',
        '&kill-rectangle',
        '&open-rectangle',
        '&string-rectangle',
        '&yank-rectangle',
    ]
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &: a,c,e,i,j,n,p,r,v
        '&append-to-register',
        'copy-r&ectangle-to-register',
        '&copy-to-register',
        'i&ncrement-register',
        '&insert-register',
        '&jump-to-register',
        # 'number-to-register',
        '&point-to-register',
        'p&repend-to-register',
        '&view-register',
    ]
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
#@+node:ekr.20060923060822.1:defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-&down',
        'scroll-&up',
        '-',
        'scroll-down-&extend-selection',
        'scroll-up-e&xtend-selection',
    ]
#@nonl
#@-node:ekr.20060923060822.1:defineCmdsMenuScrollTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&open-spell-tab',
        'spell-&change',
        'spell-change-&then-find',
        'spell-&find',
        'spell-&ignore',
    ]
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@+node:ekr.20060924161901:defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &: b,c,d,e,f,g,i,l,m,n,o,p,r,s,u,y
        '&beautify-python-code',
        'beautify-all-p&ython-code',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
#@nonl
#@-node:ekr.20060924161901:defineCmdsMenuTextTable
#@+node:ekr.20060926161940:defineCmdsMenuToggleTable
def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &: d,e,m,s,t,u,v
        'toggle-a&utocompleter',
        'toggle-call&tips',
        'toggle-&extend-mode',
        'toggle-input-&state',
        'toggle-in&visibles',
        'toggle-&mini-buffer',
        'toggle-split-&direction',
        '-',
        # &: a,b,c,f,h,i,r,w,x
        'toggle-find-&ignore-case-option',
        'toggle-find-in-&body-option',
        'toggle-find-in-&headline-option',
        'toggle-find-mark-&changes-option',
        'toggle-find-mark-&finds-option',
        'toggle-find-rege&x-option',
        'toggle-find-&reverse-option',
        'toggle-find-&word-option',
        'toggle-find-wrap-&around-option',
    ]
#@-node:ekr.20060926161940:defineCmdsMenuToggleTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&Cmds')
    
    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Cursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('M&inibuffer',         self.cmdsMenuMinibufferTable),
        ('&Panes...',           self.cmdsMenuPanesTable),
        ('Pic&kers...',         self.cmdsMenuPickersTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',     self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,t,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &To...',                self.cursorMenuExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &: a,b,c,d,f,h,l,m,n,o,p,r,s,t,u
        ("&About Leo...",           'about-leo'),
        ("Online &Home Page",       'open-online-home'),
        ("Open Online &Tutorial",   'open-online-tutorial'),
        ("Open &Users Guide",       'open-users-guide'),
        '-',
        ("Open Leo&Docs.leo",       'open-leoDocs-leo'),
        ("Open Leo&Plugins.leo",    'open-leoPlugins-leo'),
        ("Open Leo&Settings.leo",   'open-leoSettings-leo'),
        ("Open &myLeoSettings.leo", 'open-myLeoSettings-leo'),
        '-',
        'he&lp-for-minibuffer',
        'help-for-&command',
        '-',
        '&apropos-autocompletion',
        'apropos-&bindings',
        'apropos-&find-commands',
        '-',
        'pri&nt-bindings',
        'print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20060527184656:Added minibuffer and Settings menus
#@+node:ekr.20061011070742.4:Created do-nothing command and tested binding to unicode character
# It's not clear how to specify a setting for unicode characters.
# Leo crashes on do-nothing = ц
#@nonl
#@+node:ekr.20061012113455:doNothing
def doNothing (self,event):
    
    '''A placeholder command, useful for testing bindings.'''

    g.trace()
#@nonl
#@-node:ekr.20061012113455:doNothing
#@-node:ekr.20061011070742.4:Created do-nothing command and tested binding to unicode character
#@+node:ekr.20061012113708:Toggling autocompleter and calltips now write to log (in red) instead of the statusLine
# This is much more visible.
#@nonl
#@+node:ekr.20060609171919:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''
    
    k = self.k
    
    if 1:
        g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Autocompleter ',color='blue')
        frame.putStatusLine(g.choose(k.enable_autocompleter,'On','Off'))
    
def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    if 1:
        g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Calltips ',color='blue')
        frame.putStatusLine(g.choose(k.enable_calltips,'On','Off'))
#@nonl
#@-node:ekr.20060609171919:showAutocompleter/CalltipsStatus
#@-node:ekr.20061012113708:Toggling autocompleter and calltips now write to log (in red) instead of the statusLine
#@+node:ekr.20061008114340:Finished collapse-on-move-left
@nocolor

Added support for @bool sparse_move_outline_left

When True, Leo collapses the (former) parent of a node when moving that node left.
Takes getting used to, but I like it.

Note that the move-outline-up/down commands can have the effect of moving an outline left.

@color
#@nonl
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20031218072017.1767:demote
def demote (self,event=None):
    
    '''Make all following siblings children of the selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext():
        c.treeWantsFocusNow()
        return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            c.treeWantsFocusNow()
            return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(current)  # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown (self,event=None):
    
    '''Move the selected node down.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown():
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next:
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        << Move p down & set moved if successful >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
parent = p.parent()

if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)
        
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft (self,event=None):
    
    '''Move the selected node left if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasParent():
        c.treeWantsFocusNow()
        return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        if sparseMove: # New in Leo 4.4.2
            parent.contract()
    finally:
        c.selectPosition(p) # Also sets rootPosition.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight (self,event=None):
    
    '''Move the selected node right if possible.'''
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    if not p.hasBack:
        c.treeWantsFocusNow()
        return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True):
        c.treeWantsFocusNow()
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp (self,event=None):
    
    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        c.treeWantsFocusNow()
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        c.treeWantsFocusNow()
        return

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        << Move p up >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())
    
parent = p.parent()

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(oldRoot=c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)

if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote (self,event=None):
    
    '''Make all children of the selected nodes siblings of the selected node.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren():
        c.treeWantsFocusNow()
        return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
        c.treeWantsFocusNow()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1774:promote
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@-node:ekr.20061008114340:Finished collapse-on-move-left
#@-node:ekr.20061010115312:Features
#@+node:ekr.20061012064024:Plugins
#@+node:ekr.20061011163905:Fixed keyBindings plugin
http://sourceforge.net/forum/message.php?msg_id=3958380
By: paulpaterson

Printing from the KeyBindings plugin is broken. The fix is,

Change (line 306, printKeys()): 

fname = os.path.abspath(g.os_path_join("..", "plugins", "keyreport.html"))

To:

fname = os.path.abspath(g.os_path_join("..", "..", "plugins",
"keyreport.html"))


(Note the additional "..")

It appears that the current directory in use when running Leo has changed to
/Leo/test/plugins ?!
#@nonl
#@-node:ekr.20061011163905:Fixed keyBindings plugin
#@+node:ekr.20051112080017:The scripting plugin now creates a delete-x-script-button command for each script button
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?
#@nonl
#@-node:ekr.20051112080017:The scripting plugin now creates a delete-x-script-button command for each script button
#@-node:ekr.20061012064024:Plugins
#@+node:ekr.20061009154800:Settings
#@+node:ekr.20061009153504:Made unlimited undo the default
@nocolor

As always, you can set max_undo_stack_size in myLeoSettings.leo.
#@nonl
#@-node:ekr.20061009153504:Made unlimited undo the default
#@+node:ekr.20061009153818:Added @bool select_all_text_when_editing_headlines
A highly useful option.
However, creating a new node always selects the entire text, regardless of this options.
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove('sel','1.0','end')
        selectAll = selectAll or c.config.getBool('select_all_text_when_editing_headlines')
        start = g.choose(selectAll,'1.0','end')
        w.tag_add('sel',start,'end')
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.127:editLabel
def editLabel (self,p,selectAll=False):
    
    """Start editing p's headline."""

    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

    if p and c.edit_widget(p):
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
#@-node:ekr.20040803072955.127:editLabel
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.2991:c.editPosition
# Selects v: sets the focus to p and edits p.

def editPosition(self,p,selectAll=False):

    c = self ; k = c.k

    if p:
        c.selectPosition(p)
        c.frame.tree.editLabel(p,selectAll=selectAll)
        
        if k:
            k.setDefaultUnboundKeyAction()
            k.showStateAndMode()
#@-node:ekr.20031218072017.2991:c.editPosition
#@-node:ekr.20061009153818:Added @bool select_all_text_when_editing_headlines
#@+node:ekr.20061011080052:Added bindings to toggle-autocompleter and toggle-calltips
@nocolor

- Added bindings for toggle-autocompleter (Alt-1) and toggle-calltips (Alt-2)

- Ctrl-. and ctrl-( do not seem to do anything.

** Mystery solved: there was a trace in the calltip logic!

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off. It's been added to a 'later'
section of the to-do list.
#@nonl
#@-node:ekr.20061011080052:Added bindings to toggle-autocompleter and toggle-calltips
#@+node:ekr.20061011070742.3:Added 'Candidates for myLeoSettings.leo' to leoSettings.leo
@nocolor

Added the node: Candidates for settings in myLeoSettings.leo. This lists the
most 'controversial' settings in leoSetting.leo, and is a quick-start to
creating myLeoSettings.leo."
#@-node:ekr.20061011070742.3:Added 'Candidates for myLeoSettings.leo' to leoSettings.leo
#@+node:ekr.20061011154712:Recent changes to settings
- Added shift-ctrl keys to extend the selection.
focus-to-body = Alt-D
focus-to-tree = Alt-T
toggle-extend-mode = Alt-3
#@nonl
#@-node:ekr.20061011154712:Recent changes to settings
#@+node:ekr.20040213090121:Added @boo insert_new_nodes_at_end
@nocolor

By: tibi ( Thiébaut Champenier ) 
 inserting a new node   
2004-02-13 13:23  

 Hi,

When doing ctrl+i I on the node that has children I would prefer Leo to insert the new node as the last children instead of the first. It just makes more sense to me, for exemple when you take a big file and cut it in subnodes you typically start at the top and create new nodes while paging down the file.
What do you think ?
To try it just make this little change:
RCS file: /cvsroot/leo/leo/src/leoCommands.py,v
retrieving revision 1.76
diff -r1.76 leoCommands.py
2516c2516
< v = current.insertAsNthChild(0)
---
> v = current.insertAsLastChild()

What I did:
    
Added @bool insert_new_nodes_at_end

@color
#@nonl
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if (
            (current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)
        ):
            if c.config.getBool('insert_new_nodes_at_end'):
                p = current.insertAsLastChild()
            else:
                p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.beginUpdate()
    try:
        c.editPosition(p,selectAll=True)
    finally:
        c.endUpdate(False)

    return p # for mod_labels plugin.
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@-node:ekr.20040213090121:Added @boo insert_new_nodes_at_end
#@-node:ekr.20061009154800:Settings
#@-node:ekr.20060904165452:4.4.2 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
