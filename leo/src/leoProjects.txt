#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20060702103435:4.4.1 b4 projects
#@+node:ekr.20060702103435.1:Bugs fixed
#@+node:ekr.20060726122814:Added bindings to text panes for show-font command
#@+node:ekr.20060726133852.1:Report
http://sourceforge.net/forum/forum.php?thread_id=1542384&forum_id=10228

@nocolor

In the show-fonts pane when I place the cursor in the preview text field and press Ctrl-t for switching the active pane the cursor stays in the show-fonts pane and the two characters before the cursor are reversed.
#@nonl
#@-node:ekr.20060726133852.1:Report
#@+node:ekr.20051019201809:show-fonts & helpers
def showFonts (self,event):
    
    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)
#@nonl
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
    self.createBindings()
#@nonl
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@nonl
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

self.familyBox = familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4)
sizeEntry.insert(0,'12')
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
self.sampleWidget = sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)
#@nonl
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('<Return>',fontCallback)
#@nonl
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20060726133852:createBindings (fontPicker)
def createBindings (self):
    
    c = self.c ; k = c.k
    
    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       k.masterKeyHandler),
        ("<Escape>",    self.hideTab),
    )

    w = self.sampleWidget
    for event, callback in table:
        w.bind(event,callback)
        
    k.completeAllBindingsForWidget(w)
#@nonl
#@-node:ekr.20060726133852:createBindings (fontPicker)
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@nonl
#@-node:ekr.20051019201809.7:setFont
#@+node:ekr.20060726134339:hideTab
def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20060726134339:hideTab
#@-node:ekr.20051019201809:show-fonts & helpers
#@+node:ekr.20060127183752:masterKeyHandler
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>
        
    << handle per-pane bindings >>
    << handle keys without bindings >>
#@nonl
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
    
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(
        # 'keysym',repr(event.keysym or ''),
        'stroke',repr(stroke),
        'state',state,
        'unboundKeyAction',k.unboundKeyAction)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(g.app.gui.isTextWidget(w),w_name,key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@+node:ekr.20060608070318:<< handle keys without bindings >>
if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  <Return> is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'

else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060608070318:<< handle keys without bindings >>
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler
#@-node:ekr.20060726122814:Added bindings to text panes for show-font command
#@+node:ekr.20060727075804:Fixed kill-line, kill-word, kill-sentence, etc
#@+node:ekr.20060727075804.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3839322
By: paulpaterson

I think I may have confused the issue by combining two reports; just to be clear
... kill-line doesn't work on 4.4.1 beta 3.

1. Open Leo
2. Create Node
3. Create Node
4. Type three lines
5. Go to one line and press CTRL-SHIFT-K (or kill-line) - the line is removed
6. Go up a node
7. Go down a node

The line you "removed" is back.
#@-node:ekr.20060727075804.1:Report
#@+node:ekr.20050920084036.178:kill, killLine, killWord
def kill (self,event,frm,to,undoType=None):

    k = self.k ; w = event.widget
    s = w.get(frm,to)
    
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    w.delete(frm,to)
    if undoType: self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    self.kill(event,'insert linestart','insert lineend+1c','kill-line')

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    self.kill(event,'insert wordstart','insert wordend','kill-word')
    self.killWs(event)
#@-node:ekr.20050920084036.178:kill, killLine, killWord
#@-node:ekr.20060727075804:Fixed kill-line, kill-word, kill-sentence, etc
#@+node:ekr.20060705084548:Fixed minor scrolling problem
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3805745

can scroll the tree upwards even if it is already at the first node. When I do
this empty lines and sometimes even text appears above the normal nodes. 

@color
#@nonl
#@+node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text down one page.'''
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text up one page.'''
    self.scrollHelper(event,'up',extend=True)
#@nonl
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    # g.trace(g.app.gui.widget_name(w))

    if g.app.gui.isTextWidget(w):

        c.widgetWantsFocus(w)
    
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')
        row, col = ins1.split('.') ; row = int(row) ; col = int(col)
    
        # Compute the spot.
        chng = self.measure(w) ; delta = chng [0]
        row1 = g.choose(direction=='down',row+delta,row-delta)
        spot = w.index('%d.%d' % (row1,col))
        w.mark_set('insert',spot)
    
        # Handle the extension.
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see('insert')
    elif g.app.gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@nonl
#@-node:ekr.20060113082917:scrollHelper
#@+node:ekr.20050920084036.147:measure
def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart < 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom
#@nonl
#@-node:ekr.20050920084036.147:measure
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    a,b = self.c.frame.treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"unit")
    
def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    a,b = self.c.frame.treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    a,b = self.c.frame.treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    a,b = self.c.frame.treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"page")
#@nonl
#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@+node:ekr.20060726154531:scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(1,"unit")
    
def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(-1,"unit")
#@-node:ekr.20060726154531:scrollOutlineLeftRight
#@-node:ekr.20060309060654:scrolling...
#@-node:ekr.20060705084548:Fixed minor scrolling problem
#@+node:ekr.20060730103005:Fixed bug in backward-kill-word
# There is still some doubt about what the best operation of this command should be.
#@nonl
#@+node:ekr.20060804110605:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3841115
By: paulpaterson

I'm not sure if this is fixed also but backward-kill-word has an interesting
bug.

If you do a backward-kill-word on the following with the cursor at the * position
...

-- The cat sat* on the mat

Then you get the following ...

-- The *cat on the mat

ie. the word was deleted but the cursor also moved an additional work back,
which is quite perplexing when it first happens.

Perhaps the command should be called,
backward-kill-word-and-then-move-back-another-word!

Paul
#@nonl
#@-node:ekr.20060804110605:Report
#@+node:ekr.20050920084036.180:backwardKillWord
def backwardKillWord (self,event):
    
    '''Kill the previous word.'''

    c = self.c
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.killWord(event)
    # c.editCommands.backwardWord(event)
#@nonl
#@-node:ekr.20050920084036.180:backwardKillWord
#@-node:ekr.20060730103005:Fixed bug in backward-kill-word
#@-node:ekr.20060702103435.1:Bugs fixed
#@+node:ekr.20060702103435.2:New features
#@+node:ekr.20060702094931:Created menu font settings
#@+node:ekr.20060702095034:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3802624
By: dcbbcd

How can I set the font for the menu?


-----------------

This works well on Windows XP, but there is the potential for problems on other
platforms. 
 
If I am not mistaken (I could be) the present code uses a dummy Tk.Text widget
to compute what the default font *family* is, and this seems dubious when
setting menu fonts. That this works on XP may be coincidence. Please report any
problems immediately. What I want to avoid is having to specify a default system
menu font family explicitly in leoSettings.leo. 
 
The font settings do not have any effect on the menus shown at the top-level.
I've tried setting the top-level font without result.
#@nonl
#@-node:ekr.20060702095034:Request
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultMenuFontSize = g.choose(sys.platform=="win32",9,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","python"),
    ("target_language","language","python"), # Bug fix: 6/20,2005.
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","string","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20031218072017.4102:leoTkinterMenu.__init__
def __init__ (self,frame):
    
    # Init the base class.
    leoMenu.leoMenu.__init__(self,frame)
    
    self.top = frame.top
    self.c = c = frame.c
    self.frame = frame
    
    self.font = c.config.getFontFromParams(
        'menu_text_font_family', 'menu_text_font_size',
        'menu_text_font_slant',  'menu_text_font_weight',
        c.config.defaultMenuFontSize)
#@nonl
#@-node:ekr.20031218072017.4102:leoTkinterMenu.__init__
#@+node:ekr.20031218072017.4113:new_menu
def new_menu(self,parent,tearoff=False):
    
    """Wrapper for the Tkinter new_menu menu method."""
    
    if self.font:
        try:
            return Tk.Menu(parent,tearoff=tearoff,font=self.font)
        except Exception:
            g.es_exception()
            return Tk.Menu(parent,tearoff=tearoff)
    else:
        return Tk.Menu(parent,tearoff=tearoff)
#@nonl
#@-node:ekr.20031218072017.4113:new_menu
#@+node:ekr.20031218072017.4115:createMenuBar
def createMenuBar(self,frame):

    top = frame.top
    
    # Note: font setting has no effect here.
    topMenu = Tk.Menu(top,postcommand=self.updateAllMenus)
    
    # Do gui-independent stuff.
    self.setMenu("top",topMenu)
    self.createMenusFromTables()
    
    top.config(menu=topMenu) # Display the menu.
#@nonl
#@-node:ekr.20031218072017.4115:createMenuBar
#@-node:ekr.20060702094931:Created menu font settings
#@+node:ekr.20060724074426:Added scroll-outline-left/right commands
http://sourceforge.net/forum/message.php?msg_id=3834645
#@nonl
#@+node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text down one page.'''
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text up one page.'''
    self.scrollHelper(event,'up',extend=True)
#@nonl
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    # g.trace(g.app.gui.widget_name(w))

    if g.app.gui.isTextWidget(w):

        c.widgetWantsFocus(w)
    
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')
        row, col = ins1.split('.') ; row = int(row) ; col = int(col)
    
        # Compute the spot.
        chng = self.measure(w) ; delta = chng [0]
        row1 = g.choose(direction=='down',row+delta,row-delta)
        spot = w.index('%d.%d' % (row1,col))
        w.mark_set('insert',spot)
    
        # Handle the extension.
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see('insert')
    elif g.app.gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@nonl
#@-node:ekr.20060113082917:scrollHelper
#@+node:ekr.20050920084036.147:measure
def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart < 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom
#@nonl
#@-node:ekr.20050920084036.147:measure
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    a,b = self.c.frame.treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"unit")
    
def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    a,b = self.c.frame.treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    a,b = self.c.frame.treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    a,b = self.c.frame.treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"page")
#@nonl
#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@+node:ekr.20060726154531:scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(1,"unit")
    
def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(-1,"unit")
#@-node:ekr.20060726154531:scrollOutlineLeftRight
#@-node:ekr.20060309060654:scrolling...
#@-node:ekr.20060724074426:Added scroll-outline-left/right commands
#@+node:ekr.20060702091716:Generalized bracket flasher
#@+node:ekr.20060804095512.1:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3802513
By: tfer

Could you make the set of symbols to flash user settable?

Added these settings:
    
@string open_flash_brackets = ([{
@string close_flash_brackets = )]}
#@-node:ekr.20060804095512.1:Request
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.widget = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
#@nonl
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@nonl
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    brackets = self.openBracketsList + self.closeBracketsList
    
    if trace: g.trace(name,repr(ch),ch in brackets)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in brackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)
        if ch in brackets and self.flashMatchingBrackets: # New in 4.4.1.
           self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'
        
    # New in 4.4.1: Set the column for up and down keys.
    spot = w.index('insert')
    c.editCommands.setMoveCol(spot)

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    if (
        (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
        undoType != "Change"
    ):
        # No auto-indent if in @nocolor mode or after a Change command.
        self.updateAutoIndent(p,w)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@nonl
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
#@nonl
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    def addFlashCallback(w,count,index):
        w.tag_add('flash',index,'%s+1c' % (index))
        w.after(delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        w.tag_remove('flash','1.0','end')
        if count > 0:
            w.after(delay,addFlashCallback,w,count,index)

    try:
        w.tag_configure('flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass
#@nonl
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
#@nonl
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@-node:ekr.20060702091716:Generalized bracket flasher
#@+node:ekr.20050419060645:Leo *already* supports Python decorators
#@+node:ekr.20060808085830:Notes
@nocolor

For a nice intro to decorators, see: http://www.ddj.com/184406073

Background

Python 2.4 uses the at-sign @ to start decorators; Leo uses @ to denote Leo
directives. The @ that starts a Python decorator must start in column one (the
leftmost column); most Leo directives must also start in column one, but leading
whitespace is significant in the @others and @all directives. Supporting Python
decorators is a significant change to Leo because it will alter Leo's read/write
logic for derived files.

Choices

There are two possible approaches to solving this problem:

1.  Treat Leo directives (including directives defined in plugins) as special cases.

Leo would treat @x as a decorator (i.e., plain source code) unless x is a Leo
directive. Note that plugins can define Leo directives... This way requires no
change to most Leo files and so is simpler to use. It requires only that
decorators have names that do not conflict with Leo directives.

2.  Generalize the **leadin string** that introduces Leo directives.

Leo would allow uses to specify alternatives for '@' as follows:

A.  Add a new option in leoSettings.leo: @string leadin-string = @

B. Add a new directive: <default-leadin-string>leadin <string>.

If present, this directive would have to be the very first line of body text. It
would change the leadin string from the string specified by the leadin-string
*setting* to the string specified in the @leadin *directive*. As usual, the
scope of this directive would be the entire subtree of the node containing the
directive unless overridden in a descendent node.

The second approach is more general, and clearly separates Python decorators
from Leo directives. But this way disrupts the vast majority of Leo source code
in order to handle an extremely rare problem, namely of a conflict between a
Python decorator and a Leo directive. How often do we expect a Python decorator
to be name @others or @tabwidth or @code?

Conclusion

Unless I hear howls of protest I shall go ahead with the first approach. That
is, Leo will treat directives as special cases; all other strings that look like
directives will be output as plain source code.
#@nonl
#@-node:ekr.20060808085830:Notes
#@+node:ekr.20060808085830.1:Already works!
@nocolor

A big surprise: Leo *already* outputs decorators correctly, assuming the
decorator does not conflict with a Leo directive.

I had misremembered how the write logic works: it puts a verbatim sentinel only
if a line starts with the comment delimiter followed by an '@'. Lines that
merely start with an '@' are output as is unless the @ starts with a Leo
directive.

I appreciate all the various suggestions, but the most important objectives
are:

1. having the atFile.read logic recreate the outline properly from derived files.

2. forcing minimal changes to the appearance of Leo source code.

The present scheme meets these two objectives in the simplest possible way, so I
shall do nothing more unless there is a real need for more, which I do not
expect. So for now I only need to update Leo's documentation.
#@nonl
#@-node:ekr.20060808085830.1:Already works!
#@+node:ekr.20041005105605.174:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # c.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20041005105605.174:putCodeLine
#@-node:ekr.20050419060645:Leo *already* supports Python decorators
#@-node:ekr.20060702103435.2:New features
#@+node:ekr.20060702103435.3:New settings
#@+node:ekr.20060702103435.4:Added @font menu font setting
#@-node:ekr.20060702103435.4:Added @font menu font setting
#@-node:ekr.20060702103435.3:New settings
#@-node:ekr.20060702103435:4.4.1 b4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
