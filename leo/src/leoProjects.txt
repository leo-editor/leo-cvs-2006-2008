#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20070626112754.1:Leo 4.4.3 beta 1 projects
#@+node:ekr.20070626112849:Bugs
#@+node:ekr.20070626111306:Fixed improper can not open myLeoSettings message
# can not open: C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es("%s not found in %s" % (name,configDir))
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20070626111306:Fixed improper can not open myLeoSettings message
#@-node:ekr.20070626112849:Bugs
#@+node:ekr.20070626150414:Features
#@+node:ekr.20070626150414.1:g.es and g.es_print print only to console during unit tests
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):

    print g.toEncodedString(s,'ascii')

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
#@+node:ekr.20070621092938:@test g.es_print
if g.unitTesting:
    if 0: # Not usually enabled.
        g.es_print('\ntest of es_print: Ä‚',color='red')
#@-node:ekr.20070621092938:@test g.es_print
#@-node:ekr.20050707064040:es_print & test
#@+node:ekr.20070626132332:es
def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    log = app.log
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@-node:ekr.20070626132332:es
#@-node:ekr.20070626150414.1:g.es and g.es_print print only to console during unit tests
#@+node:ekr.20070626150545:Suppressed status messages during unit testing
#@-node:ekr.20070626150545:Suppressed status messages during unit testing
#@+node:ekr.20070627171855:Run unit tests in a separate process
@nocolor

For full details, see: http://sourceforge.net/forum/forum.php?thread_id=1765685&forum_id=10226

What I did:

- Added support for @unit-tests: the entire tree is copied to the dynamic.leo file
- Put most unit tests in @thin unitTests.txt (with @all).
- Added support for -silent command-line option.  It suppresses most startup messages.
- Modified run-unit-test command so it runs dynamically.
    - The new commands are run-unit-tests, run-all-unit-tests,
      run-unit-tests-locally and run-all-unit-tests-locally.
- Created unit test buttons with Alt-4 and Alt-5 bindings.
- Tell how long it took to create .leo file.
- @testcase not needed: @suite is good enough

@color
#@nonl
#@+node:ekr.20060127162818.1:debugCommandsClass
class debugCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20060127162921: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@-node:ekr.20060127162921: ctor
#@+node:ekr.20060127163325: getPublicCommands
def getPublicCommands (self):

    k = self

    return {
        'collect-garbage':              self.collectGarbage,
        'debug':                        self.debug,
        'disable-gc-trace':             self.disableGcTrace,
        'dump-all-objects':             self.dumpAllObjects,
        'dump-new-objects':             self.dumpNewObjects,
        'enable-gc-trace':              self.enableGcTrace,
        'free-tree-widgets':            self.freeTreeWidgets,
        'print-focus':                  self.printFocus,
        'print-stats':                  self.printStats,
        'print-gc-summary':             self.printGcSummary,
        'run-all-unit-tests':           self.runAllUnitTests, # The new way...
        'run-unit-tests':               self.runUnitTests,
        'run-all-unit-tests-locally':   self.runAllUnitTestsLocally, # The old way...
        'run-unit-tests-locally':       self.runUnitTestsLocally,
        'verbose-dump-objects':         self.verboseDumpObjects,
    }
#@-node:ekr.20060127163325: getPublicCommands
#@+node:ekr.20060205050659:collectGarbage
def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
#@-node:ekr.20060205050659:collectGarbage
#@+node:ekr.20060519003651:debug & helper
def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213:findDebugger
def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
#@-node:ekr.20060521140213:findDebugger
#@-node:ekr.20060519003651:debug & helper
#@+node:ekr.20060202160523:dumpAll/New/VerboseObjects
def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
#@-node:ekr.20060202160523:dumpAll/New/VerboseObjects
#@+node:ekr.20060127163325.1:enable/disableGcTrace
def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = True
    g.enable_gc_debug()

    if g.app.trace_gc_verbose:
        g.es('enabled verbose gc stats',color='blue')
    else:
        g.es('enabled brief gc stats',color='blue')
#@-node:ekr.20060127163325.1:enable/disableGcTrace
#@+node:ekr.20060202154734:freeTreeWidgets
def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
#@-node:ekr.20060202154734:freeTreeWidgets
#@+node:ekr.20060210100432:printFocus
# Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
#@-node:ekr.20060210100432:printFocus
#@+node:ekr.20060205043324.3:printGcSummary
def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
#@-node:ekr.20060205043324.3:printGcSummary
#@+node:ekr.20060202133313:printStats
def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
#@-node:ekr.20060202133313:printStats
#@+node:ekr.20060328121145:runUnitTest commands
def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=True)

def runUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=False)

def runAllUnitTests (self,event=None):
    '''Run all unit tests contained in the entire outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True)

def runUnitTests(self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False)
#@-node:ekr.20060328121145:runUnitTest commands
#@-node:ekr.20060127162818.1:debugCommandsClass
#@+node:ekr.20051104075904.4:doTests...
def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        for p in theIter:
            if isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p): # @suite
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
            # elif isTestCaseNode(p): # @testcase or @test-case
                # test = makeTestClass(c,p)
                # if test: suite.addTest(test)

        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5:class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6:__init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@-node:ekr.20051104075904.6:__init__
#@+node:ekr.20051104075904.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.7: fail
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20051104075904.9:tearDown
def tearDown (self):

    pass

    # To do: restore the outline.
#@-node:ekr.20051104075904.9:tearDown
#@+node:ekr.20051104075904.10:runTest
def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!
    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
#@-node:ekr.20051104075904.10:runTest
#@+node:ekr.20051104075904.11:shortDescription
def shortDescription (self):

    return self.p.headString() + '\n'
#@-node:ekr.20051104075904.11:shortDescription
#@-node:ekr.20051104075904.5:class generalTestCase
#@+node:ekr.20051104075904.12:makeTestSuite
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
#@-node:ekr.20051104075904.12:makeTestSuite
#@+node:ekr.20051104075904.13:makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
#@-node:ekr.20051104075904.13:makeTestCase
#@-node:ekr.20051104075904.4:doTests...
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@nonl
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.fileName = 'dynamicUnitTest.leo'

    self.tags = ('@test','@suite','@unittests','@unit-tests') # '@testcase','test-case'
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c
    c2root = c2.rootPosition()
    c2root.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    c2.beginUpdate()
    if self.all:
        p = c.rootPosition() ; limit_p = None
    else:
        p = c.currentPosition() ; limit_p = p.nodeAfterTree()
    try:
        c2root.expand()
        while p and p != limit_p:
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    # print h
                    p2 = p.copyTreeAfter()
                    p2.unlink()
                    p2.moveToLastChildOf(c2root)
                    p.moveToNodeAfterTree()
                    break
            else:
                p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@-node:ekr.20070627135336.9:createOutline
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    args = [sys.executable, path, '--silent']

    srcDir = g.os_path_abspath(g.os_path_join(g.app.load,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    #c.redraw()
                    return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20070627171855:Run unit tests in a separate process
#@-node:ekr.20070626150414:Features
#@-node:ekr.20070626112754.1:Leo 4.4.3 beta 1 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
