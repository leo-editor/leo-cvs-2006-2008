#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20061021144254:Leo 4.4.2 final projects
#@+node:ekr.20061021150733:Bugs
#@+node:ekr.20061019170752.1:Changed leo_rst.css to pass the w3 validator
#@-node:ekr.20061019170752.1:Changed leo_rst.css to pass the w3 validator
#@+node:ekr.20061021100018:Fixed 'Run on string' message when typing ( with no @color in effect
Typing in leoDocs.leo will show the problem.
#@nonl
#@+node:ekr.20031218072017.2369:skip_string
def skip_string(s,i,verbose=True):
    
    '''Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True'''
    
    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')
    
    n = len(s)
    while i < n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i >= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
#@-node:ekr.20031218072017.2369:skip_string
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = self.editWidget(event)
    if not w: return 'break'

    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w) or (None,None)
    oldText = name.startswith('body') and p.bodyString() or ''
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    brackets = self.openBracketsList + self.closeBracketsList
    inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
    
    if trace: g.trace(name,repr(ch),ch in brackets)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)
        if inBrackets and self.flashMatchingBrackets: # New in 4.4.1.
           self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'
        
    # New in 4.4.1: Set the column for up and down keys.
    spot = w.index('insert')
    c.editCommands.setMoveCol(spot)

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    if (
        (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
        undoType != "Change"
    ):
        # No auto-indent if in @nocolor mode or after a Change command.
        self.updateAutoIndent(p,w)
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20060831163241:test_selfInsertCommand
def test_selfInsertCommand(self):
    
    self = c.editCommands
    event = g.Bunch(char='Ã‰',keysym=None,widget=c.frame.body.bodyCtrl)
    self.selfInsertCommand(event)
#@nonl
#@-node:ekr.20060831163241:test_selfInsertCommand
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    def addFlashCallback(w,count,index):
        w.tag_add('flash',index,'%s+1c' % (index))
        w.after(delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        w.tag_remove('flash','1.0','end')
        if count > 0:
            w.after(delay,addFlashCallback,w,count,index)

    try:
        w.tag_configure('flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@+node:ekr.20031218072017.3189:skip_matching_python_delims
def skip_matching_python_delims(s,i,delim1,delim2,reverse=False):
    
    '''Skip from the opening delim to the matching delim2.
    
    Return the index of the matching ')', or -1'''
    
    level = 0 ; n = len(s)
    assert(g.match(s,i,delim1))
    if reverse:
         while i >= 0:
            ch = s[i]
            if ch == delim1:
                level += 1 ; i -= 1
            elif ch == delim2:
                level -= 1
                if level <= 0:  return i
                i -= 1
            # Doesn't handle strings and comments properly...
            else: i -= 1
    else:
        while i < n:
            progress = i
            ch = s[i]
            if ch == delim1:
                level += 1 ; i += 1
            elif ch == delim2:
                level -= 1
                if level <= 0:  return i
                i += 1
            elif ch == '\'' or ch == '"': i = g.skip_string(s,i,verbose=False)
            elif g.match(s,i,'#'):  i = g.skip_to_end_of_line(s,i)
            else: i += 1
            if i == progress: return -1
    return -1
#@-node:ekr.20031218072017.3189:skip_matching_python_delims
#@-node:ekr.20061021100018:Fixed 'Run on string' message when typing ( with no @color in effect
#@+node:ekr.20061019171123.2:Fixed problem with c++ extensions
@nocolor
@language python

http://sourceforge.net/forum/message.php?msg_id=3971242
By: nobody

I just tried to use mod_shadow plugin the first time and it took me sometime
to figure out that I immediately triggered a bug.

The problem is, that I use c++ as programming language, but leo only provides an
\@language c directive. This is OK for colorizing, but it prevents the mod_shadow
plugin to derive the correct file name extension from the language directive (at
least thatÂ´s what I guessed from the error messages). To fix it I simply copied
all c language entries in leoApp.py to create cpp new similar cpp language
entries. I have not tried to understand the code that triggers this error in
detail, so I donÂ´t know if this fixes all issues, but at least it seems to work
at the moment.

@color
#@nonl
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20061019171123.2:Fixed problem with c++ extensions
#@+node:ekr.20060927173836.2:Move on if regexp matches an empty string
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
#@-node:ekr.20060526092203:regexHelper
#@-node:ekr.20060927173836.2:Move on if regexp matches an empty string
#@+node:ekr.20061019171123:Fixed several bugs related to multiple body panes
@nocolor

Two body editors open looking at the same node, so you can write 
code at the bottom of the body based on something close to the top. 
Let's say the top pane's showing a data structure defined a page or 
so down from the start of the body, and the bottom pane's showing a
method you're writing at the bottom on the body.

As soon as you enter a character in the bottom pane the point of 
view of the top pane snaps back to the first line of the body, no 
damage caused but now you can't see the datastructure definition you 
were using for reference.

This probably indicates that the body should be split into more than 
one node... but thought I'd let you know it was doing that anyway.

--------------

Still something funky I'm afraid.  Two body panes one above the 
other looking at the same body text.

Say each one is displaying 10 lines.

In one I scroll down to view lines 80-90 by dragging the scroll bar 
on the right, but when I click line 85 to position the cursor it 
jumps to line 5.

@color
#@nonl
#@+node:ekr.20061017083312:selectEditor
def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    # Inactivate the previously active editor.
    # Don't capture ivars here! selectMainEditor keeps them up-to-date.
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
            w2.leo_selection = g.app.gui.getSelectionRange(w2)
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            break
    else:
        if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocusNow()
    return 'break'
#@nonl
#@+node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
#@-node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20061017083312:selectEditor
#@+node:ekr.20060129052538.2:masterClickHandler
def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol <= xcol <= jcol)
        if icol <= xcol <= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
#@-node:ekr.20060129052538.2:masterClickHandler
#@+node:ekr.20061017082211:onClick
def onClick (self,event):
    
    c = self.c ; k = c.k
    w = event and event.widget
    wname = c.widget_name(w)
    
    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        x, y = event.x, event.y
        k.previousSelection = g.app.gui.getSelectionRange(w)
        i = w.index('@%s,%s' % (x,y))
        # g.trace(x,y,i)
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
#@nonl
#@-node:ekr.20061017082211:onClick
#@+node:ekr.20060528100747.3:tkBody.createTextWidget
def createTextWidget (self,frame,parentFrame,p,name):
    
    c = self.c
    
    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = w = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    
    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y)
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)
   
    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = body.leo_p.v
    w.leo_active = True
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
#@nonl
#@-node:ekr.20060528100747.3:tkBody.createTextWidget
#@-node:ekr.20061019171123:Fixed several bugs related to multiple body panes
#@+node:ekr.20061019171123.1:Fixed multipath plugin so it works with new colorizier
@nocolor

The new colorizer was innocent: the problem is that at.directiveKind4 uses leoColor.leoKeywords,
so multipath must add entroes to leoColor.leoColors.

This should be changed, but it is too late in the development cycle to do more than put a band-aid on the problem.

@color
#@nonl
#@+node:ekr.20041005105605.198:directiveKind4 & test
def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 >= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if not s[i+1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@+node:ekr.20050608103755:test_directiveKind4
def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
#@-node:ekr.20050608103755:test_directiveKind4
#@-node:ekr.20041005105605.198:directiveKind4 & test
#@+node:ekr.20031218072017.1595:<< define leo keywords >>
# leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
    "@","@all","@c","@code","@color","@comment",
    "@delims","@doc","@encoding","@end_raw",
    "@first","@header","@ignore",
    "@killcolor",
    "@language","@last","@lineending",
    "@nocolor","@noheader","@nowrap","@others",
    "@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
    "@silent","@tabwidth","@terse",
    "@unit","@verbose","@wrap" ]
#@-node:ekr.20031218072017.1595:<< define leo keywords >>
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]

global globalDirectiveList

if word in globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@-node:ekr.20061019171123.1:Fixed multipath plugin so it works with new colorizier
#@+node:ekr.20061016104544:Fixed bug in new colorizer
@ 

New colorizer did not handle @<newline> properly.
(It required a space after the '@').
#@nonl
#@-node:ekr.20061016104544:Fixed bug in new colorizer
#@+node:ekr.20061023071509:Fixed config bug
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3975898

If the setting "@int initial_window_left" has a value of 0 (zero), leo starts
up without showing a single pane.

@color
#@nonl
#@+node:ekr.20031218072017.1625:setInitialWindowGeometry
def setInitialWindowGeometry(self):
    
    """Set the position and size of the frame to config params."""
    
    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10
    
    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
#@-node:ekr.20031218072017.1625:setInitialWindowGeometry
#@-node:ekr.20061023071509:Fixed config bug
#@+node:ekr.20061026083956:Investigated problems with leoRecentFiles.txt
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3978307
By: johnmwhite

The auto-creation of .leoRecentFiles.txt doesn't seem to work. Everything is
fine if myLeoSettings.leo is in the home directory along with .leoRecentFiles.txt,
but strange things happen if .leoRecentFiles.txt does not exist.

----

I simply removed a very misleading message in writeRecentFiles.
#@nonl
#@+node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20060416113431:computeLeoDir
def computeLeoDir ():
    
    loadDir = g.app.loadDir
    
    g.app.leoDir = theDir = g.os_path_dirname(loadDir)
    
    if theDir not in sys.path:
        sys.path.append(theDir)
        
    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
#@-node:ekr.20060416113431:computeLeoDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        ### import leo
        import sys
        
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) > 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20050328133444:computeStandardDirectories
def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    if 0:
        import sys
        for s in sys.path: g.trace(s)
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
        
    g.app.leoDir = g.computeLeoDir()
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
        
    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
#@-node:ekr.20050328133444:computeStandardDirectories
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
#@-node:ekr.20041117151301.1:startupEncoding
#@-node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        g.trace('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                g.trace('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@-node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@-node:ekr.20061026083956:Investigated problems with leoRecentFiles.txt
#@-node:ekr.20061021150733:Bugs
#@+node:ekr.20061026081935:New features
#@+node:ekr.20061023214728:Created leoPymacs.py for interaction with pymacs
@nocolor

See the node Users Guide-->Chapter 18: Emacs and Leo in LeoDocs.leo for full details.
#@nonl
#@-node:ekr.20061023214728:Created leoPymacs.py for interaction with pymacs
#@+node:ekr.20061025094855:Further improvements to leoPymacs
# It is set by tkFrame.finishCreate
#@nonl
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@nonl
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    app = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = app.gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
        
    frame.finishCreate(c)
    c.finishCreate()
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            if c.config.getBool('outline_pane_has_initial_focus'):
                c.treeWantsFocusNow()
            else:
                c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,pymacs=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    if pymacs:
        script = windowFlag = False
    else:
        script, windowFlag = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.  This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if pymacs:
        createNullGuiWithScript(None)
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'):
        g.enableIdleTimeHook()
    if not fileName:
        c.redraw_now()
    c.bodyWantsFocus()
    g.app.gui.runMainLoop()
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        g.app.use_psyco = False
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
        g.app.use_psyco = False
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@nonl
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    windowFlag = False
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        if arg in ("--script-window","-script-window"):
            name = sys.argv[i+1].strip() ; windowFlag = True ; break
        i += 1

    if not name:
        return None, windowFlag
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es_print("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script, windowFlag
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@-node:ekr.20061025094855:Further improvements to leoPymacs
#@+node:ekr.20061026054758:Added forward-end-word/-extend-selection commands
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3980193

What I'm needing is 2 commands:

1) move cursor to the end of the current word (if cursor is in a word) or end
of next word (if cursor is not in a word), WITHOUT SELECTING - the functionality
of Ctrl-RtArrow in normal editors

2) extend selection from current cursor position to the end of the current or
next word - the functionality of Shift-Ctrl-RtArrow in normal editors.

EKR: The term 'normal' editor is misleading.  There are two different ways of moving forward:
forward-word and forward-end-word.

@color
#@nonl
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &: l,p,s,w
        'extend-to-&line',
        'extend-to-&paragraph',
        'extend-to-&sentence',
        'extend-to-&word',
    ]
    
    self.cursorMenuForwardTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&end-word',
        'forward-&word',
        '-',
        '&next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&end-word-extend-selection',
        'forward-&word-extend-selection',#
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c ; k = self.k 

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)
    
def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)
        
def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    c.widgetWantsFocusNow(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)

    i = toPython(w.index('insert'))
    
    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1
    
    self.moveToHelper(event,toGui(i),extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20061008140603:runEditCommandTest
def runEditCommandTest (c,p):
    
    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)
    
    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    
    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        g.app.gui.setTextSelection(w,sel1[0],sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'expected body: %s, got: %s' % (repr(s1),repr(s2))
        sel3 = g.app.gui.getTextSelection(w)
        assert sel2 == sel3, 'expected sel: %s, got: %s' % (sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20061008140603:runEditCommandTest
#@-node:ekr.20061026054758:Added forward-end-word/-extend-selection commands
#@-node:ekr.20061026081935:New features
#@-node:ekr.20061021144254:Leo 4.4.2 final projects
#@+node:ekr.20061028084753:Leo 4.4.2.1 final projects
#@+node:ekr.20061028072406:Fixed bug reading recent files
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):
    
    """Set self.globalConfigFile, self.homeFile and self.myConfigFile."""
    
    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    
    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@-node:ekr.20041117083857:initSettingsFiles
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
        
    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
    # Read all .leoRecentFiles.txt files.
    # The order of files in this list affects the order of the recent files list.
    seen = []
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (
        g.app.homeDir,
        g.app.globalConfigDir,
        localConfigPath,
    ):
        if path and path not in seen:
            ok = self.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and self.write_recent_files_as_needed:
        self.createRecentFiles()

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles
#@+node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@+node:ekr.20061010121944:createRecentFiles
def createRecentFiles (self):
    
    '''Trye to reate .leoRecentFiles.txt in
    - the users home directory first,
    - Leo's config directory second.'''

    for theDir in (g.app.homeDir,g.app.globalConfigDir):
        if theDir:
            try:
                fileName = g.os_path_join(theDir,'.leoRecentFiles.txt')
                f = file(fileName,'w')
                f.close()
                g.es_print('created %s' % (fileName),color='red')
                return
            except Exception:
                g.es_print('can not create %s' % (fileName),color='red')
                g.es_exception()
#@nonl
#@-node:ekr.20061010121944:createRecentFiles
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):

    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    ok = g.os_path_exists(fileName)
    if ok:
    
        g.trace('reading %s' % fileName)
        lines = file(fileName).readlines()
        if lines and self.munge(lines[0])=='readonly':
            lines = lines[1:]
        if lines:
            lines = [g.toUnicode(g.os_path_normpath(line),'utf-8') for line in lines]
            self.appendToRecentFiles(lines)
            
    return ok
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                g.trace('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@-node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@-node:ekr.20061028072406:Fixed bug reading recent files
#@-node:ekr.20061028084753:Leo 4.4.2.1 final projects
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.
#@nonl
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self
    
    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):
    
    p = self
    
    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))
        
__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):
    
    '''Return a representation of a position suitable for use in .leo files.'''
    
    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual
def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )
        
isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual
#@+node:ekr.20061028070057.11:p.key
def key (self):
    
    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):
    
    '''Move position p to its previous sibling.'''
    
    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen')
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):
    
    '''Move a position to it's last child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''
    
    p = self
    if p and p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):
    
    p = self
    if p and p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):
    
    '''Move a position to its parent position.'''
    
    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p
    
    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):
    
    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):
    
    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):
    
    p = self
    
    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):
    
    if p.v:
        return len(p.v.t.links)
    else:
        return 0
    
    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    parent = self.stack and self.stack[-1]
    return parent and self._childIndex < len(parent.v.t.links)
    # return self.v and self.v._next
    
def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):
    
    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):
    
    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)
def isAncestorOf (self, p2):
    
    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False
    
    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):
    
    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""
    
    p = self
    if p and p.stack:
        for v in p.stack:
            if not v.isExpanded():
                return False
        return True
    else:
        return False

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)
    
simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""
    
    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return
    
    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New
        
    #### p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.
    
    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""
    
    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return
        
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)
    
    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v.t.links does NOT change."""

    p = self ; v = p.v
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)
    
    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028070132:New positions
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
