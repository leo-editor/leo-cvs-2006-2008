#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20060901085739:4.4.1.1 projects
#@+node:ekr.20060831211210:Fixed unicode problems
@

http://sourceforge.net/forum/message.php?msg_id=3893628
#@nonl
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w) or (None,None)
    oldText = name.startswith('body') and p.bodyString() or ''
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    brackets = self.openBracketsList + self.closeBracketsList
    inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
    
    if trace: g.trace(name,repr(ch),ch in brackets)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)
        if inBrackets and self.flashMatchingBrackets: # New in 4.4.1.
           self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'
        
    # New in 4.4.1: Set the column for up and down keys.
    spot = w.index('insert')
    c.editCommands.setMoveCol(spot)

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20060831163241:test_selfInsertCommand
def test_selfInsertCommand(self):
    
    self = c.editCommands
    event = g.Bunch(char='Ã‰',keysym=None,widget=c.frame.body.bodyCtrl)
    self.selfInsertCommand(event)
#@nonl
#@-node:ekr.20060831163241:test_selfInsertCommand
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    if (
        (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
        undoType != "Change"
    ):
        # No auto-indent if in @nocolor mode or after a Change command.
        self.updateAutoIndent(p,w)
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    def addFlashCallback(w,count,index):
        w.tag_add('flash',index,'%s+1c' % (index))
        w.after(delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        w.tag_remove('flash','1.0','end')
        if count > 0:
            w.after(delay,addFlashCallback,w,count,index)

    try:
        w.tag_configure('flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@-node:ekr.20060831211210:Fixed unicode problems
#@-node:ekr.20060901085739:4.4.1.1 projects
#@+node:ekr.20060824095221:4.4.1 final projects
#@+node:ekr.20060826062302:Removed warning about changed nodes
# Possibly a less intrusive warning should be used.
#@nonl
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just setting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # print "***",at.t,at.root.t
            g.es("Warning: updating changed text in %s" %
                (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20060824130443:Found: tempBodyString
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            c.setBodyString(p,s) # Sets c and p dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@+node:ekr.20041005105605.50:<< scan @+body >> 3.x
assert(g.match(s,i,"+body"))

child_out = [] ; child = p.copy() # Do not change out or p!
oldIndent = at.indent ; at.indent = lineIndent
at.scanText3(theFile,child,child_out,at.endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = g.toUnicode(body,g.app.tkEncoding) # 9/28/03

if at.importing:
    child.t.bodyString = body
else:
    child.t.tempBodyString = body

at.indent = oldIndent
#@-node:ekr.20041005105605.50:<< scan @+body >> 3.x
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just setting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # print "***",at.t,at.root.t
            g.es("Warning: updating changed text in %s" %
                (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just setting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # print "***",at.t,at.root.t
            g.es("Warning: updating changed text in %s" %
                (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
def  copyAllTempBodyStringsToTnodes (self,root,thinFile):
    
    c = self.c
    for p in root.self_and_subtree_iter():
        try: s = p.v.t.tempBodyString
        except: s = ""
        old_body = p.bodyString()
        if s != old_body:
            if 0: # For debugging.
                print ; print "changed: " + p.headString()
                print ; print "new:",s
                print ; print "old:",p.bodyString()
            if thinFile:
                p.v.setTnodeText(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                c.setBodyString(p,s) # Sets c and p dirty.

            if not thinFile or (thinFile and p.v.isDirty()):
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                g.es("changed: " + p.headString(),color="blue")
                p.setMarked()
#@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
#@-node:ekr.20060824130443:Found: tempBodyString
#@-node:ekr.20060826062302:Removed warning about changed nodes
#@+node:ekr.20060830064138:Bugs fixed
#@+node:ekr.20060825181348.1:Fixed serious bug in Paste Node as Clone
#@+node:ekr.20060825181348.2:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3885494
By: mikecrowe

OK, I found out how to duplicate this one.  This caused me a lot of grief until
I found out what is causing it.

NodeA:
...Child1
...Child2
...Child3

NodeB:
...CloneChild1
...CloneChild2
...CloneChild3

Now, put cursor on NodaA.  Ctrl-Shift-C (copy node).
Next, put cursor on CloneChild3.  Paste Node as Clone
You should get an invalid paste clone message.

Now, first cursor move (for me) puts NodeB as top node, ERASING all other nodes.
Warning:  DO NOT SAVE NOW.  It will erase all other nodes.
#@-node:ekr.20060825181348.2:Report
#@+node:ekr.20060826061456:What I did
@nocolor

- Created getLeoOutlineHelper.  This simplifies the code.
- Init self.checking in getLeoFile and getLeoOutline.
- Use self.checking in getVnodes, getVnode and createVnode.
  Using self.checking in getVnode complicates an already way-too-complex method, but it can't be helped.
#@nonl
#@-node:ekr.20060826061456:What I did
#@+node:ekr.20060826061038:Changed:
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed
    
    try:
        ok = True
        if use_sax:
            v = self.readSaxFile(theFile,fileName,silent)
            if v: # v == None for minimal .leo files.
                c.setRootVnode(v)
                self.rootVnode = v
            else:
                self.rootVnode = c.rootPosition().v
        else:
            self.getAllLeoElements(fileName,silent)
    except BadLeoFile, message:
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False
        
    # New in Leo 4.2.2: before reading derived files.
    if use_sax:
        self.resolveTnodeLists()
    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
    
    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()
    if use_sax:
        self.setPositionsFromVnodes()
    else:
        if not self.usingClipboard:
            self.setPositionsFromStacks()
        if not c.currentPosition():
            c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):
    
    '''Read a Leo outline from string s in clipboard format.'''

    try:
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=False)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    return v
    
getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@nonl
#@+node:ekr.20031218072017.1557:finishPaste
def finishPaste(self,reassignIndices=True):
    
    """Finish pasting an outline from the clipboard.
    
    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        << reassign tnode indices >>
    c.selectPosition(current)
    return current
#@+node:ekr.20031218072017.1558:<< reassign tnode indices >>
@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

nodeIndices = g.app.nodeIndices

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        # New in Leo 4.4.2 b2: use gnx's.  maxTnodeIndex is no longer used.
        t.fileIndex = nodeIndices.getNewIndex()
        # g.trace(t.fileIndex)
#@nonl
#@-node:ekr.20031218072017.1558:<< reassign tnode indices >>
#@-node:ekr.20031218072017.1557:finishPaste
#@+node:ekr.20060826052453.1:getLeoOutlineHelper
def getLeoOutlineHelper (self,s,reassignIndices,checking):
    
    self.checking = checking
    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.descendentUnknownAttributesDictList = []
    v = None

    self.tnodesDict = {}
    if not reassignIndices:
        << recreate tnodesDict >>
    try:
        self.getXmlVersionTag()
        self.getXmlStylesheetTag()
        self.getTag("<leo_file>")
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        if not checking:
            v = self.finishPaste(reassignIndices)
    finally:
        self.fileBuffer = None ; self.fileIndex = 0
        self.usingClipboard = False
        self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20060826052453.1:getLeoOutlineHelper
#@+node:ekr.20031218072017.3022:getClipboardHeader
def getClipboardHeader (self):

    if self.getOpenTag("<leo_header"):
        return # <leo_header> or <leo_header/> has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("></leo_header>"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/>")
            break
#@-node:ekr.20031218072017.3022:getClipboardHeader
#@-node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard and not self.checking:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("</vnodes>")
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode & helpers
# changed for 4.2 & 4.4
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched <v.
    
    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if self.checking: return None
        else: return v
    
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if not self.checking:
            skip = skip or skip2
            if tnodeList:
                v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    if not self.checking:
        << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
    
    if not self.checking:
        << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@+node:ekr.20031218072017.1860:createVnode
# (changed for 4.2) sets skip

def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
            
    if self.checking: return None,False
    
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(t)
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict
    v._p_changed = 1

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        g.es_print(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode
#@+node:ekr.20040326063413:getExistingVnode
def getExistingVnode (self,tref,headline):

    assert(tref > -1)
    tref = self.canonicalTnodeIndex(tref)
    t = self.tnodesDict.get(tref)
    try:
        return t.vnodeList[0]
    except (IndexError,AttributeError):
        g.es("Missing vnode:",headline,color="red")
        g.es("Probably an outline topology error.")
        return None
#@-node:ekr.20040326063413:getExistingVnode
#@-node:ekr.20031218072017.1566:getVnode & helpers
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame
    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20031218072017.1860:createVnode
# (changed for 4.2) sets skip

def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
            
    if self.checking: return None,False
    
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(t)
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict
    v._p_changed = 1

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        g.es_print(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode
#@-node:ekr.20060826061038:Changed:
#@-node:ekr.20060825181348.1:Fixed serious bug in Paste Node as Clone
#@+node:ekr.20060829091456:Fixed minor .leoID.txt bug
#@+node:ekr.20060829113741:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3886250
By: znafets

A .leoID.txt with a \n behind the idstring creates a problem. 
It will be read in g.app.leoID and being used as is when writing the Leo file.

The fix is in app.setLeoID -> << return if we can set leoID from "leoID.txt" >>
#@nonl
#@-node:ekr.20060829113741:Report
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir
    
    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es_print("leoID = " + g.app.leoID, color='red')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es_print("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es_print("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es_print('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId
        return
        
except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# g.trace(g.app.leoID)
g.es_print("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                g.es_print(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@-node:ekr.20060829091456:Fixed minor .leoID.txt bug
#@+node:ekr.20060830063143:Improved speed of unmark-all and corresponding undo/redo
#@+node:ekr.20060830065450:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3890031
By: terry_n_brown

I have a tree of some 2500 nodes, run a script that marks
probably 1500-2000 of them, and that's quick (2-3 seconds max.).

I can clear all the marks with:

for p in c.allNodes_iter():
    p.v.clearMarked()

and that also is quick (2-3 seconds max.).  But when I use the menu option Unmark
All, that takes forever (1-2 minutes :-) running 100% CPU all the while.
#@nonl
#@-node:ekr.20060830065450:Report
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll (self,event=None):
    
    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        changed = False
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.clearMarked(p)
                p.v.t.setDirty()
                u.afterMark(p,undoType,bunch)
        dirtyVnodeList = [p.v for p in c.allNodes_iter() if p.v.isDirty()]
        if changed: c.setChanged(True)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2930:unmarkAll
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):
    
    '''Update dirty and marked bits.'''
    
    u = self ; c = u.c
    
    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    dirty   = g.choose(isOld,u.oldDirty,  u.newDirty)
    marked  = g.choose(isOld,u.oldMarked, u.newMarked)
    changed = g.choose(isOld,u.oldChanged,u.newChanged)

    if dirty:   u.p.setDirty(setDescendentsDirty=False)
    else:       u.p.clearDirty()
        
    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    u.c.setChanged(changed)
#@-node:ekr.20050410095424:updateMarks
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    
    '''Create an undo node for mark and unmark commands.'''
    
    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.
    
    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    
    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050526124906:undoMark
def undoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('old')
    
    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.clearDirty()
        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@-node:ekr.20060830063143:Improved speed of unmark-all and corresponding undo/redo
#@-node:ekr.20060830064138:Bugs fixed
#@-node:ekr.20060824095221:4.4.1 final projects
#@+node:ekr.20060904165452:4.4.2 projects
#@+node:ekr.20060929090247.1:4.4.2 b1
#@+node:ekr.20060908092306:Bugs
#@+node:ekr.20060906220124:Clone-find-all doesn't put focus in minibuffer
# getArg now has:
    
if k.useTextWidget: c.minibufferWantsFocusNow() # 9/8/06

instead of:
    
if k.useTextWidget: c.minibufferWantsFocus()
#@nonl
#@+node:ekr.20050920085536.62:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20050928092516:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20050928092516:<< init altX vars >>
#@-node:ekr.20050920085536.62:getArg
#@-node:ekr.20060906220124:Clone-find-all doesn't put focus in minibuffer
#@+node:ekr.20060908091132:Fixed undo clone-find-all 
#@+node:ekr.20060908095225:Notes
@nocolor

Undo crashed or didn't work.  Redo clone-find-all could hang.
#@-node:ekr.20060908095225:Notes
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; t = self.s_ctrl ; u = c.undoer
    gui = g.app.gui ; undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if not pos: break
        count += 1
        line = gui.getLineContainingIndex(t,pos)
        self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            if not clones:
                << create the found node and begin the undo group >>
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)
          
    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@+node:ekr.20051113110735:<< create the found node and begin the undo group >>
u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110735:<< create the found node and begin the undo group >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
clones.append(self.p.v.t)
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20040803140033.3:c.setRootPosition
def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
#@nonl
#@-node:ekr.20040803140033.3:c.setRootPosition
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position. For internal use only.
    
    Client code should use c.selectPosition instead."""
    
    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
            
        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        c.setRootPosition(c.findRootPosition(c._currentPosition))
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()
    
    u.groupCount += 1

    
    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        c.beginUpdate()
        try:
            for z in bunch.items:
                self.setIvarsFromBunch(z)
                if z.redoHelper:
                    # g.trace(z.redoHelper)
                    z.redoHelper() ; count += 1
                else:
                    g.trace('oops: no redo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1
    
    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)
        
    c.selectPosition(p)
    newSel and c.frame.body.setTextSelection(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):
    
    """Deletes the selected outline."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
       undoData = u.beforeDeleteNode(p)
       dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
       p.doDelete()
       c.selectPosition(newNode)
       c.setChanged(True)
       u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20040409203454.1:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@+node:ekr.20040410170806:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20040410170806:p.deleteLinksInSubtree
#@+node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
#@-node:ekr.20040409203454.1:p.deleteLinksInTree & allies
#@-node:ekr.20060908091132:Fixed undo clone-find-all 
#@+node:ekr.20060908104646:Fixed several bugs in UNL plugin
#@-node:ekr.20060908104646:Fixed several bugs in UNL plugin
#@+node:ekr.20060912073120:Fixed crasher with multiple editors
#@+node:ekr.20060912073340:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3910237
Kam-Yung
Python 2.4.3, Tk 8.4.12, Pmw 1.2

I'm getting "TclError Exception in Tk" callback with the new multi-editor
feature.

Steps to reproduce:

* start up Leo with no files
* execute "add-editor"
* make sure the left-most body pane is selected
* execute "delete-editor"

Up comes a TK error box.
#@nonl
#@-node:ekr.20060912073340:Report
#@+node:ekr.20060912073340.1:Traceback
TclError Exception in Tk callback
  Function: <function masterBindKeyCallback at 0x0164DBB0> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x01840FD0>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2117, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 3096, in masterKeyHandler
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2241, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2318, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2355, in callAltXFunction
    func(event)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 2124, in deleteEditor
    self.onFocusIn(w)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 2173, in onFocusIn
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 6381, in selectPosition
    c.frame.tree.select(p,updateBeadList)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterTree.py", line 2548, in select
    c.frame.updateStatusLine() # New in Leo 4.4.1.
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 1002, in updateStatusLine
    if self.statusLine: self.statusLine.update()
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 727, in update
    index = w.index("insert")
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2938, in index
    return self.tk.call(self._w, 'index', index)
TclError: invalid command name ".20195728.20196288.22611848.22611928.23069560.23069920.body-pane"

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 1356
    state: 8
    time: 3053230
    type: 2
    widget: .20195728.20196288.22412264.minibuffer
    width: ??
    x: 244
    x_root: 678
    y: -164
    y_root: 518

#@-node:ekr.20060912073340.1:Traceback
#@+node:ekr.20060912083415:What I did
@nocolor

- in statusLine.update:
    
replace self.bodyCtrl with c.frame.bodyCtrl.

- Removed bodyCtrl ivar from statusLine class.  This value can not be cached!

- in deleteEditor: add:

self.bodyCtrl = self.frame.bodyCtrl = w

just before the call to self.onFocusIn(w).
#@nonl
#@-node:ekr.20060912083415:What I did
#@+node:ekr.20060528113806:deleteEditor
def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w # Bug fix: 9/12/06
    self.onFocusIn(w)
#@-node:ekr.20060528113806:deleteEditor
#@+node:ekr.20031218072017.1733:update (statusLine)
def update (self):
    
    c = self.c ; w = c.frame.bodyCtrl ; lab = self.labelWidget

    if g.app.killed or not self.isVisible:
        return

    index = w.index("insert")
    row,col = g.app.gui.getindex(w,index)

    if col > 0:
        s = w.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)
    
    s = "line %d, col %d " % (row,col)
    # Important: this does not change the focus because labels never get focus.
    lab.configure(text=s)
    self.lastRow = row
    self.lastCol = col
#@-node:ekr.20031218072017.1733:update (statusLine)
#@+node:ekr.20060528100747:Editors
@ **Important**: body.bodyCtrl and body.frame.bodyCtrl must always be the same.
#@+node:ekr.20060530204135:recolorWidget
def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl
    
    # g.trace(id(w),c.currentPosition().headString())
    
    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w
    
    c.recolor_now(interruptable=False) # Force a complete recoloring.
    
    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w
#@nonl
#@-node:ekr.20060530204135:recolorWidget
#@+node:ekr.20060530210057:create/select/unselect/Label
def unselectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='LightSteelBlue1')
        
def selectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='white')
        
def createLabel (self,w):

    w.leo_label = Tk.Label(w.leo_frame)
    w.pack_forget()
    w.leo_label.pack(side='top')
    w.pack(expand=1,fill='both')
#@-node:ekr.20060530210057:create/select/unselect/Label
#@+node:ekr.20060528100747.1:addEditor
def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
     
    if self.numberOfEditors == 1:
        # Inject the ivars into the first editor.
        w = self.editorWidgets.get('1')
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v
        w.leo_label_s = p.headString()

    self.numberOfEditors += 1
    name = '%d' % self.numberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    << create label and text widgets >>
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.updateEditors()
    # self.onFocusIn(w,setFocus=True)
    c.bodyWantsFocusNow()
#@+node:ekr.20060528110922:<< create label and text widgets >>
f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,f,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
w.see('1.0')
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
#@-node:ekr.20060528110922:<< create label and text widgets >>
#@-node:ekr.20060528100747.1:addEditor
#@+node:ekr.20060606090542:setEditorColors
def setEditorColors (self,bg,fg):
    
    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
#@-node:ekr.20060606090542:setEditorColors
#@+node:ekr.20060528170438:cycleEditorFocus
def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.onFocusIn(w2,setFocus=True)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # g.trace('***',g.app.gui.widget_name(w2),id(w2))

    return 'break'
#@-node:ekr.20060528170438:cycleEditorFocus
#@+node:ekr.20060528113806:deleteEditor
def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w # Bug fix: 9/12/06
    self.onFocusIn(w)
#@-node:ekr.20060528113806:deleteEditor
#@+node:ekr.20060528104554:onFocusIn
lockout_onFocusIn = False

def onFocusIn(self,w,setFocus=False):

    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.callers())
    if self.lockout_onFocusIn:
        if trace: g.trace('lockout')
        return 'break'
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    
    # Disable recursive calls: some of the calls below generate OnFocusInEvents.
    self.lockout_onFocusIn = True
    try:
        if trace: g.trace(w)
    
        # Inactivate the previously active editor.
        # Don't capture ivars here! selectMainEditor keeps them up-to-date.
        for key in d.keys():
            w2 = d.get(key)
            if w2 != w and w2.leo_active:
                w2.leo_active = False
                self.unselectLabel(w2)
                w2.leo_scrollBarSpot = w2.yview()
                w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
                w2.leo_selection = g.app.gui.getSelectionRange(w2)
                break
        else:
            if trace: g.trace('no active editor!')
    
        # Careful, leo_p may not exist.
        if not c.positionExists(w.leo_p):
            g.trace('does not exist',w.leo_name)
            for p2 in c.allNodes_iter():
                if p2.v == w.leo_v:
                    w.leo_p = p2.copy()
                    break
            else:
                if trace: g.trace("Can't happen")
                return 'break'

        self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
        w.leo_active = True
        c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
        c.recolor_now()
        << restore the selection, insertion point and the scrollbar >>
        w3 = g.app.gui.get_focus(c)
        if setFocus or w3 and not g.app.gui.widget_name(w3).startswith('body'):
            if trace: g.trace(g.app.gui.widget_name(w),id(w))
            c.bodyWantsFocusNow()
    finally:
        self.lockout_onFocusIn = False

    return 'break'
#@+node:ekr.20060605190146:<< restore the selection, insertion point and the scrollbar >>
if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
#@-node:ekr.20060605190146:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20060528104554:onFocusIn
#@+node:ekr.20060528132829:selectMainEditor
def selectMainEditor (self,p):

    c = self.c ; p = c.currentPosition() ; w = self.bodyCtrl

    # Don't inject ivars if there is only one editor.
    if w.leo_p is not None:
        # Keep w's ivars up-to-date.
        w.leo_p = p.copy()
        w.leo_v = p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w)
        # g.trace(w.leo_name,p.headString())
#@-node:ekr.20060528132829:selectMainEditor
#@+node:ekr.20060528131618:updateEditors
def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) < 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.frame.bodyWantsFocus()
#@-node:ekr.20060528131618:updateEditors
#@-node:ekr.20060528100747:Editors
#@+node:ekr.20041223104933:class statusLineClass
class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("<Button-1>", self.onActivate)
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(g.callers())
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.widgetWantsFocus(t)
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)
        
show = pack
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(s,g.callers())
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update (statusLine)
def update (self):
    
    c = self.c ; w = c.frame.bodyCtrl ; lab = self.labelWidget

    if g.app.killed or not self.isVisible:
        return

    index = w.index("insert")
    row,col = g.app.gui.getindex(w,index)

    if col > 0:
        s = w.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)
    
    s = "line %d, col %d " % (row,col)
    # Important: this does not change the focus because labels never get focus.
    lab.configure(text=s)
    self.lastRow = row
    self.lastCol = col
#@-node:ekr.20031218072017.1733:update (statusLine)
#@-node:ekr.20041223104933:class statusLineClass
#@-node:ekr.20060912073120:Fixed crasher with multiple editors
#@+node:ekr.20060915113237:Fixed problem with body/outline ratio
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3914969

This body-outline ratio in the .leo file is not used, regardless of orientation.

The problem that tkFrame.resizePanesToRatio got deleted sometime after 4.4 final,
so the do-nothing base class method was executed instead.
@color
#@nonl
#@+node:ekr.20031218072017.2306:getGlobals
def getGlobals (self):

    if self.getOpenTag("<globals"):
        # <globals/> seen: set reasonable defaults:
        self.ratio = 0.5
        y,x,h,w = 50,50,500,700
    else:
        self.getTag("body_outline_ratio=\"")
        self.ratio = self.getDouble() ; self.getDquote() ; self.getTag(">")

        self.getTag("<global_window_position")
        y,x,h,w = self.getPosition()
        self.getTag("/>")

        self.getTag("<global_log_window_position")
        self.getPosition()
        self.getTag("/>") # no longer used.

        self.getTag("</globals>")

    # Redraw the window before writing into it.
    self.frame.setTopGeometry(w,h,x,y)
    self.frame.deiconify()
    self.frame.lift()
    self.frame.update()
#@-node:ekr.20031218072017.2306:getGlobals
#@+node:ekr.20060915124834:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    self.divideLeoSplitter(self.splitVerticalFlag,ratio)
    self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@-node:ekr.20060915124834:resizePanesToRatio
#@-node:ekr.20060915113237:Fixed problem with body/outline ratio
#@+node:ekr.20060918091042:Guarded against strange crasher
#@+node:ekr.20031218072017.1999:toString
def toString (self,index,removeDefaultId=False):
    
    """Convert a gnx (a tuple) to its string representation"""

    try:
        theId,t,n = index
        if removeDefaultId and theId == self.defaultId:
            theId = ""
        if not n: # None or ""
            return "%s.%s" % (theId,t)
        else:
            return "%s.%s.%d" % (theId,t,n)
    except TypeError:
        g.trace('unusual gnx',repr(index))
        return repr(index)
#@nonl
#@-node:ekr.20031218072017.1999:toString
#@-node:ekr.20060918091042:Guarded against strange crasher
#@+node:ekr.20060920145332:Fixed compare bug
#@+node:ekr.20060920151334:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3924236

Comparing directory A, with files A1 and A2, and directory B, with files B1 and B2
(A1, A2, B1, B2 all being different) shows up in the log as A1 and A2 not being founnd.

I think also B1 and B2 should be mentioned somewhere (e.g. using headings like 'Only present in A' and 'Only present in B').

#@-node:ekr.20060920151334:Report
#@+node:ekr.20031218072017.3635:compare_directories (entry)
# We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
    
    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)
    
    if dir1 == dir2:
        return self.show("Please pick distinct directories.")
    try:
        list1 = os.listdir(dir1)
    except:
        return self.show("invalid directory:" + dir1)
    try:
        list2 = os.listdir(dir2)
    except:
        return self.show("invalid directory:" + dir2)
        
    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok: return None

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and missing lists.
    yes = [] ; no = [] ; missing1 = [] ; missing2 = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                missing1.append(f1)
        else:
            missing1.append(f1)
    for f2 in files2:
        head,f1 = g.os_path_split(f2)
        if f1 not in files1:
            missing2.append(f1)
    
    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found 1 ------",missing1),
        ("----- not found 2 ------",missing2),
    ):
        self.show(kind)
        for f in files:
            self.show(f)
    
    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None

    return None # To keep pychecker happy.
#@nonl
#@-node:ekr.20031218072017.3635:compare_directories (entry)
#@-node:ekr.20060920145332:Fixed compare bug
#@+node:ekr.20060921113950:Fixed problem with g.CheckVersion
# The new version of g.CheckVersion is simpler, and works more often, but is perhaps less general.
#@nonl
#@+node:ekr.20031218072017.3097:CheckVersion 
#@+node:ekr.20060921100435:checkVersion (EKR)
# Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition=">=",stringCompare=None,delimiter='.',trace=False):
    
    vals1 = [int(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [int(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 < n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 < n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('<',  vals1 <  vals2), ('<=', vals1 <= vals2),
        ('>',  vals1 >  vals2), ('>=', vals1 >= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
    
    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result
#@nonl
#@-node:ekr.20060921100435:checkVersion (EKR)
#@+node:ekr.20060921100435.1:oldCheckVersion (Dave Hein)
@
g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", ">=", "<=", ">", or "<"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def oldCheckVersion( version, againstVersion, condition=">=", stringCompare="0.0.0.0", delimiter='.' ):

    __pychecker__ = 'maxreturns=20'
    
    # g.pdb()

    # tokenize the stringCompare flags
    compareFlag = string.split( stringCompare, '.' )

    # tokenize the version strings
    testVersion = string.split( version, delimiter )
    testAgainst = string.split( againstVersion, delimiter )

    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount > len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount > len(testVersion):
        tokenCount = len(testVersion)

    # Apply the stringCompare flags
    justInteger = re.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError,errMsg

    # Compare the versions
    if condition == ">=":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == ">":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "<":
        for i in range(tokenCount):
            if testVersion[i] >= testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "<=":
        for i in range(tokenCount):
            if testVersion[i] > testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal

    # didn't find a condition that we expected.
    raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
#@nonl
#@-node:ekr.20060921100435.1:oldCheckVersion (Dave Hein)
#@-node:ekr.20031218072017.3097:CheckVersion 
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        # g.trace(repr(version),g.CheckVersion(version,"8.4.3"))
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32":
            
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        ok = g.CheckVersion(version,'2.2.1')
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@-node:ekr.20060921113950:Fixed problem with g.CheckVersion
#@+node:ekr.20060925080505:Added force argument to c.set_focus
@
This should *finally* fix the problems with focus going to limbo.
All xWantsFocusNow methods set the force arg.
#@nonl
#@+node:ekr.20060210102201:c.xWantsFocusNow
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    #g.trace(body and body.bodyCtrl)
    c.set_focus(body and body.bodyCtrl,force=True)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and c.edit_widget(p),force=True)
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl,force=True)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas,force=True)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w,force=True)
#@-node:ekr.20060210102201:c.xWantsFocusNow
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
#@-node:ekr.20060205103842:c.get/request/set_focus
#@+node:ekr.20050120092028:c.xWantsFocus
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and c.edit_widget(p))
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@-node:ekr.20050120092028:c.xWantsFocus
#@-node:ekr.20060925080505:Added force argument to c.set_focus
#@+node:ekr.20060927070439:Fixed crasher involving CheckVersion
http://sourceforge.net/forum/message.php?msg_id=3929272
#@nonl
#@+node:ekr.20060921100435:checkVersion (EKR)
# Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition=">=",stringCompare=None,delimiter='.',trace=False):
    
    vals1 = [int(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [int(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 < n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 < n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('<',  vals1 <  vals2), ('<=', vals1 <= vals2),
        ('>',  vals1 >  vals2), ('>=', vals1 >= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
    
    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result
#@nonl
#@-node:ekr.20060921100435:checkVersion (EKR)
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        # g.trace(repr(version),g.CheckVersion(version,"8.4.3"))
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32":
            
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20060212061804:runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    
    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        if (
            g.CheckVersion(version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)
#@-node:ekr.20060212061804:runOpenFileDialog
#@-node:ekr.20060927070439:Fixed crasher involving CheckVersion
#@+node:ekr.20060928111850:Fixed recent bug in c.setHeadSring
#@+node:ekr.20040305223225:c.setHeadString
def setHeadString (self,p,s,encoding="utf-8"):

    c = self ; t = c.edit_widget(p)
    
    p.initHeadString(s,encoding)

    if t:
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state,width=c.frame.tree.headWidth(s=s))

    p.setDirty()
#@nonl
#@-node:ekr.20040305223225:c.setHeadString
#@-node:ekr.20060928111850:Fixed recent bug in c.setHeadSring
#@-node:ekr.20060908092306:Bugs
#@+node:ekr.20060905091234:Code level
#@+node:ekr.20060904114302:Added OPML support to fileCommands
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    self.putCount = 0
    self.toString = toString
    self.assignFileIndices()
    if not outlineOnlyFlag or toOPML:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        << create backup file >>
        self.mFileName = fileName
        if toOPML:
            << ensure that filename ends with .opml >>
        self.outputFile = cStringIO.StringIO()
        << create theActualFile >>
        # t1 = time.clock()
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        # t2 = time.clock()
        s = self.outputFile.getvalue()
        # g.trace(self.leo_file_encoding)
        if toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            << delete backup file >>
            # t3 = time.clock()
            # g.es_print('len %d, putCount %d' % (len(s),self.putCount)) # 'put',t2-t1,'write&close',t3-t2)
        self.outputFile = None
        self.toString = False
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        if backupName:
            << delete fileName >>
            << rename backupName to fileName >>
        self.toString = False
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20060919070145:<< ensure that filename ends with .opml >>
if not self.mFileName.endswith('opml'):
    self.mFileName = self.mFileName + '.opml'
fileName = self.mFileName
#@nonl
#@-node:ekr.20060919070145:<< ensure that filename ends with .opml >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
backupName = None

# rename fileName to fileName.bak if fileName exists.
if not toString and g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@+node:ekr.20060929103258:<< create theActualFile >>
if toString:
    theActualFile = None
else:
    theActualFile = open(fileName, 'wb')
#@nonl
#@-node:ekr.20060929103258:<< create theActualFile >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@-node:ekr.20060904114302:Added OPML support to fileCommands
#@+node:ekr.20060905092512.2:Eliminated v.c and p.c
@nocolor

To do:
    
- Eliminate most calls to c.setRootPosition(c.findRootPosition(p))
    ** Just have c.rootPosition call c.findRootPosition(c.currentPosition())
    
What I did:

- Removed c argument from t, v and p ctors.
- Removed c argument from most position methods.
    - In particular, p.link, p.unlink, v.link and v.unlink no longer update c.currentPosition()
    - Moved all position methods that still had a c argument to the Commands class.
- Removed p.allNodes_iter.
- Added c.findRootPosition and c.findRootVnode.
- c.rootPosition now returns c.findRootPosition(c.currentPosition())

As a result:
    
- The tnode, vnode and position classes are *completely* independent of Leo.
  In particular, no tnode, vnode or position method gets a c argument.
- The p.link, p.unlink, v.link and v.unlink are significantly simpler.
- The machinery for keeping the root position up-to-date is
  simple and confined to one place in the Commands class.
  
@color
#@nonl
#@+node:ekr.20060905181927:Added new methods
#@+node:ekr.20060906134053:c.findRootPosition New in 4.4.2
@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):
    
    '''Return the root position of the outline containing p.'''
    
    c = self ; p = p.copy()
    
    while p and p.hasParent():
        p.moveToParent()
        
    while p and p.hasBack():
        p.moveToBack()
        
    # g.trace(p and p.headString())

    return p
#@nonl
#@-node:ekr.20060906134053:c.findRootPosition New in 4.4.2
#@+node:ekr.20060906131836:c.setRootVnode New in 4.4.2
def setRootVnode (self, v):
    
    c = self
    newRoot = leoNodes.position(v,[])
    c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20060906131836:c.setRootVnode New in 4.4.2
#@-node:ekr.20060905181927:Added new methods
#@+node:ekr.20060905165341.1:Unchanged signatures (just removed v.c or other minor changes)
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self.stack,trace=False)
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040303175026.3:p.insertAfter
def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2
#@-node:ekr.20040303175026.3:p.insertAfter
#@+node:ekr.20040303175026.5:p.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2
#@-node:ekr.20040303175026.5:p.insertAsNthChild
#@+node:ekr.20051104075904.30:u.findNodeInTree
def findNodeInTree(self,p,headline):

    """Search for a node in p's tree matching the given headline."""

    c = self.c
    for p in p.subtree_iter():
        h = headline.strip().lower()
        if p.headString().strip().lower() == h:
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20051104075904.30:u.findNodeInTree
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!

    return dirtyVnodeList
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []
    
    # g.trace(p.headString(),g.callers())

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@+node:EKR.20040506075328.2:perfectImport
def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    __pychecker__ = 'maxlines=500'
    
    << about this algorithm >>
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        << clear all dirty bits >>
    << Assign file indices >>
    << Write root's tree to to string s >>

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            << put the corrected fat lines in a new node >>
        << correct root's tree using write_lines >>
    if verify:
        << verify that writing the tree would produce the original file >>
#@+node:ekr.20040717112739:<< about this algorithm >>
@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
#@-node:ekr.20040717112739:<< about this algorithm >>
#@+node:ekr.20040716065356:<< clear all dirty bits >>
for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
#@-node:ekr.20040716065356:<< clear all dirty bits >>
#@+node:ekr.20040716064333:<< Assign file indices  >>
nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
#@-node:ekr.20040716064333:<< Assign file indices  >>
#@+node:ekr.20040716064333.1:<< Write root's tree to to string s >>
at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
#@-node:ekr.20040716064333.1:<< Write root's tree to to string s >>
#@+node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
#@-node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
#@+node:ekr.20040717113036:<< correct root's tree using write_lines >>
@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "<perfectImport string-file>"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
#@-node:ekr.20040717113036:<< correct root's tree using write_lines >>
#@+node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            << dump the files >>
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
#@+node:ekr.20040718045423:<< dump the files >>
print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j < i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k < i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
#@-node:ekr.20040718045423:<< dump the files >>
#@-node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
#@-node:EKR.20040506075328.2:perfectImport
#@+node:ekr.20040803072955.21:tkTree.injectCallbacks
def injectCallbacks(self):
    
    c = self.c
    
    << define tkinter callbacks to be injected in the position class >>

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):
        
        g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20040803072955.22:<< define tkinter callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event=None,c=c):
    
    """Callback injected into position class."""
    
    p = self
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@+node:ekr.20040803072955.24:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None,c=c):
    
    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
#@-node:ekr.20040803072955.24:OnHyperLinkEnter
#@+node:ekr.20040803072955.25:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None,c=c):
    
    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
#@-node:ekr.20040803072955.25:OnHyperLinkLeave
#@-node:ekr.20040803072955.22:<< define tkinter callbacks to be injected in the position class >>
#@-node:ekr.20040803072955.21:tkTree.injectCallbacks
#@-node:ekr.20060905165341.1:Unchanged signatures (just removed v.c or other minor changes)
#@+node:ekr.20060907085253:Removed p.allNodes_iter
#@+node:ekr.20040305171133:p.allNodes_iter
class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,c,copy=False):
    
    return self.allNodes_iter_class(self,c,copy)
#@+node:ekr.20040305171133.1:__init__ & __iter__ (p.allNodesIter)
def __init__(self,p,c,copy):
    
    # g.trace('p.allNodes_iter.__init','p',p,'c',c)

    self.first = c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305171133.1:__init__ & __iter__ (p.allNodesIter)
#@+node:ekr.20040305171133.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:p.allNodes_iter
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
# New in Leo 4.4.2 (It used to be defined in terms of p.allNodes_iter.)

class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    c = self
    return self.allNodes_iter_class(c,copy)

all_positions_iter = allNodes_iter
#@nonl
#@+node:ekr.20060907085906.1:__init__ & __iter__ (p.allNodesIter)
def __init__(self,c,copy):
    
    # g.trace('c.allNodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20060907085906.1:__init__ & __iter__ (p.allNodesIter)
#@+node:ekr.20060907085906.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20060907085906.2:next
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@-node:ekr.20060907085253:Removed p.allNodes_iter
#@+node:ekr.20060906130502:Removed p arg
#@+node:ekr.20040303175026.8:p.clone (does not need any args)
def clone (self):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self

    p2 = p.copy()
    p2.v = vnode(p.v.t)
    p2.linkAfter(p)

    return p2
#@nonl
#@-node:ekr.20040303175026.8:p.clone (does not need any args)
#@+node:ekr.20060905104612:Found: .clone
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):
    
    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone()
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    
    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone & dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
#@+node:ekr.20031218072017.2948:c.dragCloneAfter
def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2948:c.dragCloneAfter
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
clones.append(self.p.v.t)
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20060905104612:Found: .clone
#@-node:ekr.20060906130502:Removed p arg
#@+node:ekr.20060905165341.2:Removed c arg
#@+node:ekr.20031218072017.892:p.__init__
# New in Leo 4.4.2: make stack default to None.

def __init__ (self,v,stack=None,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    # assert(v is None or v.t)
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # if g.app.tracePositions and trace: g.trace(g.callers())
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20031218072017.892:p.__init__
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v
    
    # p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)

    return p
#@nonl
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20040306060312:p.moveToLastChildOf
def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = parent.numberOfChildren()
    p.linkAsNthChild(parent,n)
        
    return p
#@nonl
#@-node:ekr.20040306060312:p.moveToLastChildOf
#@+node:ekr.20040303175026.11:p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsNthChild(parent,n)

    return p
#@nonl
#@-node:ekr.20040303175026.11:p.moveToNthChildOf
#@+node:ekr.20040303175026.6:p.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a position to the root position.
    
    Important: oldRoot must the previous root position if it exists.'''

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p
#@-node:ekr.20040303175026.6:p.moveToRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.5:p.unlink
#@+node:ekr.20051104075904.35:replaceOutline (leoTest)
def replaceOutline (self,outline1,outline2):

    """Replace outline1 by a copy of outline 2,

    retaining the headline of outline1."""

    c = outline1.c
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete()
    c.setRootPosition(c.findRootPosition(copy)) # New in 4.4.2.
    c.selectPosition(copy)
#@-node:ekr.20051104075904.35:replaceOutline (leoTest)
#@+node:ekr.20031218072017.3344:v.__init__
def __init__ (self,t):

    assert(t)
    
    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits
    
    # Structure links.
    self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20031218072017.3344:v.__init__
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.
    
    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20060905165341.2:Removed c arg
#@+node:ekr.20060905114409:Added c arg
#@+node:ekr.20031218072017.1385:g.findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@-node:ekr.20060905114409:Added c arg
#@+node:ekr.20060905172505.1:Converted p.x(c) to c.x(p)
#@+node:ekr.20040315032503:c.appendStringToBody
def appendStringToBody (self,p,s,encoding="utf-8"):
    
    c = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    c.setBodyString(p,body + s,encoding)
#@-node:ekr.20040315032503:c.appendStringToBody
#@+node:ekr.20060906211138:c.clearMarked
def clearMarked  (self,p):
    
    c = self
    p.v.clearMarked()
    g.doHook("clear-mark",c=c,p=p,v=p)
#@nonl
#@-node:ekr.20060906211138:c.clearMarked
#@+node:ekr.20040306220230.1:c.edit_widget
def edit_widget (self,p):
    
    c = self
    
    return p and c.frame.tree.edit_widget(p)
#@nonl
#@-node:ekr.20040306220230.1:c.edit_widget
#@+node:ekr.20031218072017.4146:c.lastVisible
def lastVisible(self):
    
    """Move to the last visible node of the entire tree."""

    c = self ; p = c.rootPosition()
    
    # Move to the last top-level node.
    while p.hasNext():
        p.moveToNext()
    assert(p.isVisible())

    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        p.moveToLastChild()
    
    return p
#@-node:ekr.20031218072017.4146:c.lastVisible
#@+node:ekr.20040307104131.3:c.positionExists
def positionExists(self,p):
    
    """Return True if a position exists in c's tree"""
    
    c = self ; p = p.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p.headString(),'parent',p.parent(),'back',p.back())
        if p.equal(root):
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    # g.trace('does not exist in root:',root.headString())
    return False
#@-node:ekr.20040307104131.3:c.positionExists
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
#@-node:ekr.20040305223522:c.setBodyString
#@+node:ekr.20060906211138.1:c.setMarked
def setMarked (self,p):
    
    c = self
    p.v.setMarked()
    g.doHook("set-mark",c=c,p=p,v=p)
#@nonl
#@-node:ekr.20060906211138.1:c.setMarked
#@+node:ekr.20031218072017.3404:c.trimTrailingLines
def trimTrailingLines (self,p):

    """Trims trailing blank lines from a node.
    
    It is surprising difficult to do this during Untangle."""

    c = self
    body = p.bodyString()
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i >= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        c.setBodyString(p,body)
        # Don't set the dirty bit: it would just be annoying.
#@nonl
#@-node:ekr.20031218072017.3404:c.trimTrailingLines
#@+node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
#@-node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
#@-node:ekr.20060905172505.1:Converted p.x(c) to c.x(p)
#@+node:ekr.20060905103748:Removed p and v methods using v.c or p.c
#@+node:ekr.20040312015705:p.clearAllVisited
# Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()
#@-node:ekr.20040312015705:p.clearAllVisited
#@+node:ekr.20040803140033.4:p.isCurrentPosition
def isCurrentPosition (self,c):
    
    p = self
    
    return c.isCurrentPosition(p)
#@-node:ekr.20040803140033.4:p.isCurrentPosition
#@+node:ekr.20040803140033.5:p.isRootPosition
def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)
#@-node:ekr.20040803140033.5:p.isRootPosition
#@+node:ekr.20060905090957:removed findRoot methods
# A step towards removing c ivars from vnode and position classes.
#@nonl
#@+node:ekr.20031218072017.3381:v.findRoot (4.2)
def findRoot (self):
    
    return self.c.rootPosition()
#@-node:ekr.20031218072017.3381:v.findRoot (4.2)
#@+node:ekr.20040306215548:p.findRoot
def findRoot (self):
    
    return self.c.frame.rootPosition()
#@-node:ekr.20040306215548:p.findRoot
#@-node:ekr.20060905090957:removed findRoot methods
#@+node:ekr.20060905121515:v.clearDirtyJoined
def clearDirtyJoined (self,c):

    v = self
    c.beginUpdate()
    try:
        v.t.clearDirty()
    finally:
        c.endUpdate() # recomputes all icons
#@-node:ekr.20060905121515:v.clearDirtyJoined
#@+node:ekr.20031218072017.3379:v.currentVnode (and c.currentPosition 4.2)
if 0:
    def currentPosition (self):
        return self.c.currentPosition()
            
    def currentVnode (self):
        return self.c.currentVnode()
#@nonl
#@-node:ekr.20031218072017.3379:v.currentVnode (and c.currentPosition 4.2)
#@-node:ekr.20060905103748:Removed p and v methods using v.c or p.c
#@-node:ekr.20060905092512.2:Eliminated v.c and p.c
#@+node:ekr.20060907101636:Call c.findRootPosition in c.setCurrentPosition
# Very important: it guarantees that c.rootPosition always returns the proper value.
#@nonl
#@+node:ekr.20060906134053:c.findRootPosition New in 4.4.2
@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):
    
    '''Return the root position of the outline containing p.'''
    
    c = self ; p = p.copy()
    
    while p and p.hasParent():
        p.moveToParent()
        
    while p and p.hasBack():
        p.moveToBack()
        
    # g.trace(p and p.headString())

    return p
#@nonl
#@-node:ekr.20060906134053:c.findRootPosition New in 4.4.2
#@+node:ekr.20040803140033:c.currentPosition
def currentPosition (self,copy=True):
    
    """Return the presently selected position."""
    
    c = self

    if c._currentPosition:
        # New in Leo 4.4.2: *always* return a copy.
        return c._currentPosition.copy()
    else:
        return c.nullPosition()
    
# For compatibiility with old scripts.
currentVnode = currentPosition
#@-node:ekr.20040803140033:c.currentPosition
#@+node:ekr.20040803140033.3:c.setRootPosition
def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
#@nonl
#@-node:ekr.20040803140033.3:c.setRootPosition
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p,updateBeadList=True):
    
    """Select a new position."""

    c = self
    
    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)
    
    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20040803140033.2:c.rootPosition
def rootPosition(self):
    
    """Return the root position."""
    
    c = self
    
    if self._rootPosition:
        return self._rootPosition.copy()
    else:
        return  c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
#@nonl
#@-node:ekr.20040803140033.2:c.rootPosition
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position. For internal use only.
    
    Client code should use c.selectPosition instead."""
    
    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
            
        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        c.setRootPosition(c.findRootPosition(c._currentPosition))
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@-node:ekr.20060907101636:Call c.findRootPosition in c.setCurrentPosition
#@+node:ekr.20060908075800.1:Removed redundant calls to c.findRootPosition
#@-node:ekr.20060908075800.1:Removed redundant calls to c.findRootPosition
#@+node:ekr.20060908115325:Reviewed p.deleteLinksInTree
# In fact, p.deleteLinksInTree is needed: as unit tests show that some adjustments are made.
#@nonl
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040409203454.1:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@+node:ekr.20040410170806:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20040410170806:p.deleteLinksInSubtree
#@+node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
#@-node:ekr.20040409203454.1:p.deleteLinksInTree & allies
#@-node:ekr.20060908115325:Reviewed p.deleteLinksInTree
#@+node:ekr.20060913082305:Fixed problem with t.hash
#@+node:ekr.20060908205857:t.__hash__ (only for zodb)
if use_zodb and ZODB:
    
    # The only required property is that objects
    # which compare equal have the same hash value.
    
    def __hash__(self):

        return hash(g.app.nodeIndices.toString(self.fileIndex))
        
        # return sum([ord(ch) for ch in g.app.nodeIndices.toString(self.fileIndex)])
#@nonl
#@-node:ekr.20060908205857:t.__hash__ (only for zodb)
#@+node:ekr.20060910100316:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20060910100316:v.__hash__ (only for zodb)
#@-node:ekr.20060913082305:Fixed problem with t.hash
#@+node:ekr.20060920180657:Investigated removing t.vnodeList (not a good idea)
@nocolor
@

It's tempting to try to remove t.vnodeList, but it would not be wise:
    
1. The present code works, and is not actually inefficient.
2. Whan a clone is deleted, we need to update the parent if the tnode that the clone shared.
   Other ways of doing so are conceivable, but they won't be significantly simpler.
3. The markAllAncestorAtFileNodesDirty algorithm is usually *much* faster than searching the entire tree.
4. Although mostly the code tests whether len(vnodeList) > 1, there *are* other uses.

The actual usages of vnodeList:
    
- In createVnode: skip = len(vnodeList) > 1.
- getExistingVnode uses vnodeList[0].
- adjustParentLinksInSubtree uses vnodeList[0]
- isCloned: returns len(vnodeList) > 1.
- directParents: returns vnodeList (but directParents only used by setAllAncestorAtFileNodesDirty.
- findAllPotentiallyDirtyNodes: uses vnodeList.
- moveToParent: use len(vnodeList)
- vParentWithStack: uses len(vnodeList)
** moveOutlineUp: if back2 and p.v in back2.v.t.vnodeList:
* findChild4: uses vnodeList[0], but it's a weird use.
#@nonl
#@-node:ekr.20060920180657:Investigated removing t.vnodeList (not a good idea)
#@-node:ekr.20060905091234:Code level
#@+node:ekr.20060912093334:New features
#@+node:ekr.20060911160213:Added multiple editor commands to Cmds menu
#@+node:ekr.20060912093334.1:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3909651

Could the multiple editor activation be added to the standard Leo menus?
#@nonl
#@-node:ekr.20060912093334.1:Request
#@-node:ekr.20060911160213:Added multiple editor commands to Cmds menu
#@+node:ekr.20060913090832:Created convenience methods for zodb scripts
# Also, the 'stack' arg to the position ctor now defaults to None.
#@nonl
#@+node:ekr.20060913090832.1:g.init_zodb
init_zodb_import_failed = False
init_zodb_failed = {} # Keys are paths, values are True.
init_zodb_db = {} # Keys are paths, values are ZODB.DB instances.

def init_zodb (pathToZodbStorage,verbose=True):
    
    '''Return an ZODB.DB instance from ZODB.FileStorage.FileStorage(pathToZodbStorage)
    return None on any error.'''
    
    global init_zodb_db, init_zodb_failed, init_zodb_import_failed
    
    db = init_zodb_db.get(pathToZodbStorage)
    if db: return db
    
    if init_zodb_import_failed: return None

    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed: return None

    try:
        import ZODB
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None
    
    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db [pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed [pathToZodbStorage] = True
        return None
#@nonl
#@-node:ekr.20060913090832.1:g.init_zodb
#@+node:ekr.20031218072017.892:p.__init__
# New in Leo 4.4.2: make stack default to None.

def __init__ (self,v,stack=None,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    # assert(v is None or v.t)
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # if g.app.tracePositions and trace: g.trace(g.callers())
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20031218072017.892:p.__init__
#@+node:ekr.20060913091805.1:v.detach
def detach (self):
    
    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''
    
    v = self
    
    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())
    
    return vnode(t2)
#@nonl
#@-node:ekr.20060913091805.1:v.detach
#@-node:ekr.20060913090832:Created convenience methods for zodb scripts
#@+node:ekr.20060923043120:Improved help-for-command
# It now prints the binding for the command.
#@nonl
#@-node:ekr.20060923043120:Improved help-for-command
#@+node:ekr.20060923065819:Put cursor/focus/pane/scroll/selection commands in Cmds menu
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    c = self.c
    
    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]
    
    self.cursorMenuForwardTable = [
        # &: b,c,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&word',
        '-',
        '&next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &: e,b,c,l,n,p,s,w
        '&extend-to-word',
        '-',
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&word-extend-selection',
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&Cmds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # Used in top table: q,u,x
        # &: a,b,c,d,f,g,h,m,n,o,p,r,s,t
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Cursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('&Panes...',           self.cmdsMenuPanesTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',     self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20060924161901:defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    c = self.c

    self.cmdsMenuTextTable = [
        # &: b,c,d,e,f,g,i,l,m,n,o,p,r,s,u,y
        '&beautify-python-code',
        'beautify-all-p&ython-code',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
#@nonl
#@-node:ekr.20060924161901:defineCmdsMenuTextTable
#@+node:ekr.20060923060822:defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    c = self.c

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
#@-node:ekr.20060923060822:defineCmdsMenuFocusTable
#@+node:ekr.20060924120752:defineCmdsMenuPanesTable
def defineCmdsMenuPanesTable (self):

    c = self.c

    self.cmdsMenuPanesTable = [
        # &: a,b,d,f,l,n,o,p,u,x,y
        'contract-&body-pane',
        'contract-&log-pane',
        'contract-&outline-pane',
        'contract-&pane',
        '-',
        'expand-bo&dy-pane',
        'expand-lo&g-pane',
        'expand-o&utline-pane',
        'expand-pa&ne',
        '-',
        '&fully-expand-body-pane',
        'full&y-expand-log-pane',
        'fully-e&xpand-outline-pane',
        'fully-exp&and-pane',
    ]
    
#@nonl
#@-node:ekr.20060924120752:defineCmdsMenuPanesTable
#@+node:ekr.20060923060822.1:defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    c = self.c

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-&down',
        'scroll-&up',
        '-',
        'scroll-down-&extend-selection',
        'scroll-up-e&xtend-selection',
    ]
#@nonl
#@-node:ekr.20060923060822.1:defineCmdsMenuScrollTable
#@-node:ekr.20060923065819:Put cursor/focus/pane/scroll/selection commands in Cmds menu
#@+node:ekr.20060926085352:Improved  quick-find commands
# Rewrote moveWordHelper. It now avoids Tk and regexes.  *Much* simpler.
#@nonl
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,t,u,w,x
        '&open-find-tab',
        '&hide-find-tab',
        'search-&with-present-options',
        '-',
        'find-tab-find-&next',
        'find-tab-find-&prev',
        'find-tab-&change',
        'find-with-present-op&tions',
        'find-tab-find-&all',
        'clone-fi&nd-all',
        'find-tab-change-a&ll',
        '-',
        '&find-character',
        'find-character-extend-&selection',
        '&backward-find-character',
        'backward-find-character-&extend-selection',
        '-',
        '&isearch-forward',
        'isea&rch-backward',
        'isearch-forward-rege&xp',
        'isearch-backward-regex&p',
        '-',
        '&query-replace',
        'q&uery-replace-regex',
    ]

# find-character-reverse            = Alt-P
# isearch-with-present-options      = None
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'<',i):
            spot = i
        elif w.compare(spot,'>',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)
    
def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)
    
def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)
    
def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        self.event = event ; self.widget = w = event.widget
        self.backward = backward ; self.extend = extend ;
        self.insert = w.index('insert')
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.widget
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = g.app.gui.getAllText(w)
        def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
        def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
        ins = toPython(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1:
                spot = toGui(j)
                self.moveToHelper(event,spot,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1:
                spot = toGui(j)
                self.moveToHelper(event,spot,extend)
        c.frame.clearStatusLine()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord
def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.widget ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            word_chars = string.letters + string.digits + '_'
            while i < len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or s[i-1] not in word_chars)
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()
#@-node:ekr.20060417194232.2:findWord
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
    def isWordChar(ch): return ch in (string.letters + string.digits + '_')

    i = toPython(w.index('insert'))
    delta = g.choose(forward,1,-1)
    
    if forward:
        while 0 <= i < n and isWordChar(s[i]):
            i += delta
        while 0 <= i < n and not isWordChar(s[i]):
            i += delta
    else:
        i -= 1
        while 0 <= i < n and not isWordChar(s[i]):
            i += delta
        while 0 <= i < n and isWordChar(s[i]):
            i += delta
        i += 1

    self.moveToHelper(event,toGui(i),extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)
    
def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)
    
def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)
    
def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
#@+node:ekr.20060420144640:iSearchBackspace
def iSearchBackspace (self):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w
    
    if not self.isearch_stack:
        ins = gui.getInsertPoint(w)
        self.endSearch(ins,ins)
        return 
    
    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()
    
    if sel:
        i,j = sel
        gui.setTextSelection(w,i,j,insert=ins)
    else:
        gui.setInsertPoint(w,ins)

    w.see('insert')
    
    if not self.isearch_stack:
        self.endSearch(ins,ins)
#@-node:ekr.20060420144640:iSearchBackspace
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w
    
    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!
    
    self.ins1 = ins = g.app.gui.getInsertPoint(w)
    sel = g.app.gui.getSelectionRange(w) or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20050920084036.264:iSearchStateHandler
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocusNow()
    if keysym == 'Return':
        sel = g.app.gui.getSelectionRange(w)
        if sel: i,j = sel
        else:   i = j = g.app.gui.getInsertPoint(w)
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
#@-node:ekr.20050920084036.264:iSearchStateHandler
#@+node:ekr.20050920084036.265:scolorizer
def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = '1.0'
    index = w.index('insert')
    index2 = w.index('%s+%dc' % (index,len(s)))
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@-node:ekr.20050920084036.265:scolorizer
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''
    
    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition() ;
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = gui.getAllText(w)

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = gui.getSelectionRange(w)
    startindex = insert = gui.getInsertPoint(w)
    
    if self.forward:
        i1 = gui.toPythonIndex(s,w,startindex)
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),gui.toPythonIndex(s,w,startindex) + len(pattern))
    
    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        pos    = gui.toGuiIndex(s,w,i)
        newpos = gui.toGuiIndex(s,w,j)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        gui.setTextSelection(w,pos,newpos,insert=pos)
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')
    
    insert = g.choose(self.forward,'sel.end','sel.start')
    g.app.gui.setTextSelection (self.w,i,j,insert=insert)

    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20060926085352:Improved  quick-find commands
#@+node:ekr.20041228084018.5:Finished/retired zodb plugin
@nocolor

My present thinking is that scripts should be able to store/retrieve persistent
objects to/from the zodb. That is, the zodb plugin is likely to be retired.

Leo's vnode and tnode classes now derive from ZODB.Persistence.Persistent if
leoNodes.use_zodb is True. It remains to be seen whether having use_zodb = True
will cause any serious problems.

See the posting below (Scripting using zodb) for latest details.

See the node 'zodb get/put buttons' in test.leo for examples of how scripts can access zodb easily.
#@nonl
#@+node:ekr.20060913084832:@ulr http://www.zope.org/Wikis/ZODB/guide/zodb.html
#@-node:ekr.20060913084832:@ulr http://www.zope.org/Wikis/ZODB/guide/zodb.html
#@+node:ekr.20060913085557:Scripting using zodb
> Do you see zodb as persisting Leo files or Leo nodes?

Interesting question.  I now see the zodb plugin as a proof-of-concept for *user-defined* scripts.  The zodb plugin is probably going to go away.

Let us suppose that db is a ZODB.DB instance. (To see how to create such an instance, see the init_zodb method in the zodb plugin.  Perhaps I'll defines something like g.openZodb to make this easier.)  Then the statements:

connection = db.open()
root = connection.root()
root[aKey] = v
get_transaction().commit()
connection.close()

will write all of v's data (all vnodes and tnodes) to the zodb.  This is true whatever v is: it can be the root of an entire outline, or any suboutline.  If you want to write a single node, you would have to 'detach' that node from the outline.  You can do this by copying the node and then unlinking the node from its descendents. Perhaps I could add a convenience method to the vnode class to make this easier.

>Do you see zodb work as providing enhanced access to nodes across multiple files?

Scripts could do so easily.  Happily, the distinction between 'long-lived' and 'short-lived' connections is not important for scripts: a script should hold a connection open only for as long as needed.  So it would be easy to write any number of vnode trees to the zodb.  Later, another script could access any of the data in the zodb by zodb key.  Like this:

connection = db.open()
root = connection.root()
v = root.get(aKey)
p = leoNodes.position(v,[])

After running this script, p is a position representing the root of the tree of 'imported' vnodes.  The script above does not 'connect' the imported trees to an outline, nor should it do so.  As I write this, I realize that the position ctor should make the second argument optional, so that leoNodes.position(v) would be equivalent to leoNodes.position(v,[]).

Each script should open at most connection at a time and be sure to close any zodb connection it creates.  The proper way to do this is in a finally statement, like this:

try:
....connection = db.open()
....root = connection.root()
....v = root.get(aKey)
....p = leoNodes.position(v,[])
....<< do something with the nodes in p's tree>>
finally:
....get_transaction().commit()
....connection.close()

In short, the recent changes to Leo's vnode and tnode classes give scripts the ability to save/retrieve Leo data to/from the zodb in any way a script wants, without any further support from Leo, or from me.

I shall spend an hour or two more with the zodb plugin, but it looks to me that the plugin has served its purpose.  Rather than trying to guess how people will want to use the zodb, it will be simpler and more general to have people write scripts that do exactly what they want.  In particular, such scripts can easily sidestep the problems with multiple open connections.

Edward

P.S. Please note that the scripts shown above could not have been written without all the recent work with the zodb plugin and the big code reorg.

P.P.S. A couple of unit tests involving the new v/t.__hash__ methods just failed, so it may be just a little bit longer before the code on cvs is truly zodb ready.  I'll also be working on example scripts and the convenience methods described above.

EKR
#@-node:ekr.20060913085557:Scripting using zodb
#@-node:ekr.20041228084018.5:Finished/retired zodb plugin
#@+node:ekr.20060923043845:Improved how Leo works w/o the mousre
#@+node:ekr.20060924173041:What I did
@nocolor

- Removed all modes except Alt-C mode.
- Use Shift-arrows for outline moves when focus is in outline pane.
- Put help / apropos commands in help menu.
- Put focus commands in Cmds menu.
- When focus is in outline, normal character navagates like Windows explorer.
- Put Scrolling commands in Cmds menu.
- Screened out(some) unwanted characters from affecting outline navigation.More work is needed.
- Esc character is never inserted into text.
- Replaced @button clones-tab with @command clones-tab.
- Scripting plugins now sets verbose=True so @commands get shown.
* Alt keys (outline move commands) should set focus to outline even if nothing else happens.
- Closing a window no longer puts focus in limbo: added force argument to c.set_focus.
- New gui bindings: (I should actually be able to remember these).
    cycle-all-focus                     = Alt-Y
    contract-pane                       = Alt+Ctrl+-
    expand-pane                         = Alt+Ctrl-=
    focus-to-tree                       = Alt-space
    scroll-outline-down-page            = Alt-PageDn
    scroll-outline-down-page            ! tree = PageDn
    scroll-outline-up-page              = Alt-PageUp
    scroll-outline-up-page              ! tree = PageUp
    scroll-outline-left                 = Alt+Ctrl+LtArrow
    scroll-outline-right                = Alt+Ctrl+RtArrow
- Put find-character and back-find-character in Edit:Find menu.
- Use Alt-S,Alt-R for incremental searches.
- Created find-character-extend-selection and back-find-character-extend-selection.
- Added binding (Ctrl-W) and entry in Cmds menu for select-word-at-cursor.
- Added binding (Ctrl-P) for repeat-complex-command.
- Added binding (Ctrl-B) for execute-script.
* Fixed bug in extend mode.
- Added binding (Ctrl-space) for toggle extend mode.
- Removed most cursor move bindings involving ctrl keys. Exception: ctrl-a and ctrl-e.
    ** The idea is that I'll use extend mode instead.
- Stay in outline mode: added @bool stayInTreeAfterEditHeadline setting.
- Added Cmds:Toggle Settings submenu.
- Use emacs names in Cmds menu (and in some other places): allow single item in menu tables.
     - regex: \(.*\ '  --> '
#@nonl
#@-node:ekr.20060924173041:What I did
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c ; w = event.widget
    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocus(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20060926213642:capitalizeMinibufferMenuName
def capitalizeMinibufferMenuName (self,s):
    
    result = []
    for i in xrange(len(s)):
        ch = s[i]
        prev = i > 0 and s[i-1] or ''
        prevprev = i > 1 and s[i-2] or ''
        if 1: # Just capitalize the start of each word.
            if (
                i == 0 or
                i == 1 and prev == '&' or
                prev == '-' or
                prev == '&' and prevprev == '-'
            ):
                result.append(ch.capitalize())
            else:
                result.append(ch)
        else: # Capitalizing accelerators in the middle of a word is dubious.
            next = i+1 < len(s) and s[i+1] or ''
            if (
                i == 0 and next != '&' or
                prev == '&' or
                prev == '-' and next != '&'
            ):
                result.append(ch.capitalize())
            else:
                result.append(ch)
    return ''.join(result)
        
    
#@nonl
#@-node:ekr.20060926213642:capitalizeMinibufferMenuName
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &R reserved for Redo
        ("-",None),
        ("Cu&t",f.OnCutFromMenu), 
        ("Cop&y",f.OnCopyFromMenu),
        ("&Paste",f.OnPasteFromMenu),
        ("&Delete",c.editCommands.backwardDeleteCharacter),
        ("Select &All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20050711091931:defineEditMenuEditCursorTable (not ready yet)
def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]
#@-node:ekr.20050711091931:defineEditMenuEditCursorTable (not ready yet)
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &Section",c.extractSection),
        ("Extract &Names",c.extractSectionNames),
        ("&Extract",c.extract),
        ("-",None,None),
        ("Convert All B&lanks",c.convertAllBlanks),
        ("Convert All T&abs",c.convertAllTabs),
        ("Convert &Blanks",c.convertBlanks),
        ("Convert &Tabs",c.convertTabs),
        ("Insert Body Time/&Date",c.insertBodyTime),
        ("&Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&Indent",c.indentBody),
        ("&Unindent",c.dedentBody),
        ("&Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &Headline",c.editHeadline),
        ("&End Edit Headline",f.endEditLabelCommand),
        ("&Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,t,u,w,x
        '&open-find-tab',
        '&hide-find-tab',
        'search-&with-present-options',
        '-',
        'find-tab-find-&next',
        'find-tab-find-&prev',
        'find-tab-&change',
        'find-with-present-op&tions',
        'find-tab-find-&all',
        'clone-fi&nd-all',
        'find-tab-change-a&ll',
        '-',
        '&find-character',
        'find-character-extend-&selection',
        '&backward-find-character',
        'backward-find-character-&extend-selection',
        '-',
        '&isearch-forward',
        'isea&rch-backward',
        'isearch-forward-rege&xp',
        'isearch-backward-regex&p',
        '-',
        '&query-replace',
        'q&uery-replace-regex',
    ]

# find-character-reverse            = Alt-P
# isearch-with-present-options      = None
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")
        
    self.editMenuTop2Table = [
        ("&Go To Line Number",c.goToLineNumber),
        ("&Execute Script",c.executeScript),
        (label,c.toggleShowInvisibles),
        ("Setti&ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&New",c.new),
        ("&Open...",c.open),
    ]
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&Close",c.close),
        ("&Save",c.save),
        ("Save &As",c.saveAs),
        ("Save &To",c.saveTo), # &Tangle
        ("Re&vert To Saved",c.revert), # &Read/Write
    ]
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&Read Outline Only",c.readOutlineOnly),
        ("Read @file &Nodes",c.readAtFileNodes),
        ("Write &Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &Outline Only",fc.writeOutlineOnly),
        ("&Write @file Nodes",fc.writeAtFileNodes),
    ]
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &All",c.tangleAll),
        ("Tangle &Marked",c.tangleMarked),
        ("&Tangle",c.tangle),
    ]
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &All",c.untangleAll),
        ("Untangle &Marked",c.untangleMarked),
        ("&Untangle",c.untangle),
    ]
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&file",c.importAtFile),
        ("Import To @&root",c.importAtRoot),
        ("Import &CWEB Files",c.importCWEBFiles),
        ("Import &noweb Files",c.importNowebFiles),
        ("Import Flattened &Outline",c.importFlattenedOutline),
    ]
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &Headlines",c.exportHeadlines),
        ("Outline To &CWEB",c.outlineToCWEB),
        ("Outline To &Noweb",c.outlineToNoweb),
        ("&Flatten Outline",c.flattenOutline),
        ("&Remove Sentinels",c.removeSentinels),
        ("&Weave",c.weave),
    ]
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&xit",g.app.onQuit),
    ]
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&ut Node",c.cutOutline),
        ("C&opy Node",c.copyOutline),
        ("&Paste Node",c.pasteOutline),
        ("Pas&te Node As Clone",c.pasteOutlineRetainingClones),
        ("&Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&Insert Node",c.insertHeadline),
        ("&Clone Node",c.clone),
        ("Sort Childre&n",c.sortChildren), # Conflicted with Hoist.
        ("&Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&Hoist",c.hoist),
        ("D&e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &Outline",c.checkOutline),
        ("&Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &All Python Code",c.checkAllPythonCode),
        ("&Check Python &Code",c.checkPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&Contract All",c.contractAllHeadlines),
        ("Contract &Node",c.contractNode),
        ("Contract &Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&rev Level",c.expandPrevLevel),
        ("Expand N&ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &1",c.expandLevel1),
        ("Expand To Level &2",c.expandLevel2),
        ("Expand To Level &3",c.expandLevel3),
        ("Expand To Level &4",c.expandLevel4),
        ("Expand To Level &5",c.expandLevel5),
        ("Expand To Level &6",c.expandLevel6),
        ("Expand To Level &7",c.expandLevel7),
        ("Expand To Level &8",c.expandLevel8),
        ("-",None),
        ("Expand &All",c.expandAllHeadlines),
        ("Expand N&ode",c.expandNode),
    ]
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &Down",c.moveOutlineDown),
        ("Move &Left",c.moveOutlineLeft),
        ("Move &Right",c.moveOutlineRight),
        ("Move &Up",c.moveOutlineUp),
        ("-",None),
        ("&Promote",c.promote),
        ("&Demote",c.demote),
    ]
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&Mark",c.markHeadline),
        ("Mark &Subheads",c.markSubheads),
        ("Mark Changed &Items",c.markChangedHeadlines),
        ("Mark Changed &Roots",c.markChangedRoots),
        ("Mark &Clones",c.markClones),
        ("&Unmark All",c.unmarkAll),
    ]
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuPanesTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()
#@nonl
#@+node:ekr.20060117094955: defineCmdsMenuTopTable
def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        'repeat-comple&x-command',
        'f&ull-command',
        'keyboard-&quit',
        '-',
    ]
#@-node:ekr.20060117094955: defineCmdsMenuTopTable
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        # &: a,e,i,k,l,r,w,v
        'abbre&v-mode',
        '-',
        '&list-abbrevs',
        '&read-abbrev-file',
        '&write-abbrev-file',
        '-',
        '&add-global-abbrev',
        '&inverse-add-global-abbrev',
        '&kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&expand-region-abbrevs',
    ]
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
#@+node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &: a,c,d
        '&add-editor',
        '&cycle-editor-focus',
        '&delete-editor',
    ]
#@nonl
#@-node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&append-to-buffer',
        '&kill-buffer',
        'list-&buffers',
        '&list-buffers-alphabetically',
        '&prepend-to-buffer',
        '&rename-buffer',
        '&switch-to-buffer',
    ]
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    c = self.c
    
    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]
    
    self.cursorMenuForwardTable = [
        # &: b,c,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&word',
        '-',
        '&next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &: e,b,c,l,n,p,s,w
        '&extend-to-word',
        '-',
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&word-extend-selection',
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20060923060822:defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    c = self.c

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
#@-node:ekr.20060923060822:defineCmdsMenuFocusTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable
def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        '&load-file',
        '-',
        '&start-kbd-macro',
        '&end-kbd-macro',
        '&name-last-kbd-macro',
        '-',
        '&call-last-keyboard-macro',
        '&insert-keyboard-macro',
    ]
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable
#@+node:ekr.20060924120752:defineCmdsMenuPanesTable
def defineCmdsMenuPanesTable (self):

    c = self.c

    self.cmdsMenuPanesTable = [
        # &: a,b,d,f,l,n,o,p,u,x,y
        'contract-&body-pane',
        'contract-&log-pane',
        'contract-&outline-pane',
        'contract-&pane',
        '-',
        'expand-bo&dy-pane',
        'expand-lo&g-pane',
        'expand-o&utline-pane',
        'expand-pa&ne',
        '-',
        '&fully-expand-body-pane',
        'full&y-expand-log-pane',
        'fully-e&xpand-outline-pane',
        'fully-exp&and-pane',
    ]
    
#@nonl
#@-node:ekr.20060924120752:defineCmdsMenuPanesTable
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        '&clear-rectangle',
        'c&lose-rectangle',
        '&delete-rectangle',
        '&kill-rectangle',
        '&open-rectangle',
        '&string-rectangle',
        '&yank-rectangle',
    ]
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        # &: a,c,e,i,j,n,p,r,v
        '&append-to-register',
        'copy-r&ectangle-to-register',
        '&copy-to-register',
        'i&ncrement-register',
        '&insert-register',
        '&jump-to-register',
        # 'number-to-register',
        '&point-to-register',
        'p&repend-to-register',
        '&view-register',
    ]
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
#@+node:ekr.20060923060822.1:defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    c = self.c

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-&down',
        'scroll-&up',
        '-',
        'scroll-down-&extend-selection',
        'scroll-up-e&xtend-selection',
    ]
#@nonl
#@-node:ekr.20060923060822.1:defineCmdsMenuScrollTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        '&open-spell-tab',
        'spell-&change',
        'spell-change-&then-find',
        'spell-&find',
        'spell-&ignore',
    ]
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@+node:ekr.20060924161901:defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    c = self.c

    self.cmdsMenuTextTable = [
        # &: b,c,d,e,f,g,i,l,m,n,o,p,r,s,u,y
        '&beautify-python-code',
        'beautify-all-p&ython-code',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
#@nonl
#@-node:ekr.20060924161901:defineCmdsMenuTextTable
#@+node:ekr.20060926161940:defineCmdsMenuToggleTable
def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &: d,e,m,s,t,u,v
        'toggle-a&utocompleter',
        'toggle-call&tips',
        'toggle-&extend-mode',
        'toggle-input-&state',
        'toggle-in&visibles',
        'toggle-&mini-buffer',
        'toggle-split-&direction',
        '-',
        # &: a,b,c,f,h,i,r,w,x
        'toggle-find-&ignore-case-option',
        'toggle-find-in-&body-option',
        'toggle-find-in-&headline-option',
        'toggle-find-mark-&changes-option',
        'toggle-find-mark-&finds-option',
        'toggle-find-rege&x-option',
        'toggle-find-&reverse-option',
        'toggle-find-&word-option',
        'toggle-find-wrap-&around-option',
    ]
#@-node:ekr.20060926161940:defineCmdsMenuToggleTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &Active Pane",f.toggleActivePane),
        ("Toggle &Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&de",f.cascade),
        ("&Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &Compare Window",c.openCompareWindow),
        ("Open &Python Window",c.openPythonWindow),
    ]
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTable = [
        # &: a,b,c,d,f,h,l,m,n,o,p,r,s,t,u
        ("&About Leo...",           c.about),
        ("Online &Home Page",       c.leoHome),
        ("Open Online &Tutorial",   c.leoTutorial),
        ("Open &Users Guide",       c.leoUsersGuide),
        '-',
        ("Open Leo&Docs.leo",       c.leoDocumentation),
        ("Open Leo&Plugins.leo",    c.openLeoPlugins),
        ("Open Leo&Settings.leo",   c.openLeoSettings),
        ("Open &myLeoSettings.leo", c.openMyLeoSettings),
        '-',
        'he&lp',
        'help-for-&command',
        '-',
        '&apropos-autocompletion',
        'apropos-&bindings',
        'apropos-&find-commands',
        '-',
        'pri&nt-bindings',
        'print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@-node:ekr.20060923043845:Improved how Leo works w/o the mousre
#@+node:ekr.20060928054124:Increased speed of arrow keys
http://sourceforge.net/forum/message.php?msg_id=3935368
#@nonl
#@+node:ekr.20031218072017.2996:selectVisNext
def selectVisNext (self,event=None):
    
    '''Select the visible node following the presently selected node.'''

    c = self ; current = c.currentPosition()
    if not current: return
    
    p = current.visNext()
    if p:
        redraw = not p.isVisible()
        if not redraw: c.frame.tree.setSelectedLabelState(current)
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate(redraw)

    c.treeWantsFocusNow()
#@-node:ekr.20031218072017.2996:selectVisNext
#@+node:ekr.20031218072017.2995:selectVisBack
# This has an up arrow for a control key.

def selectVisBack (self,event=None):
    
    '''Select the visible node preceding the presently selected node.'''

    c = self ; current = c.currentPosition()
    if not current: return

    p = current.visBack()
    if p:
        redraw = not p.isVisible()
        if not redraw: c.frame.tree.setSelectedLabelState(current)
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate(redraw)
    c.treeWantsFocusNow()
#@-node:ekr.20031218072017.2995:selectVisBack
#@-node:ekr.20060928054124:Increased speed of arrow keys
#@+node:ekr.20060928110801:Allow -- comments in @url nodes
http://sourceforge.net/forum/message.php?msg_id=3935981
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            << stop the url after any whitespace >>
        # g.trace(url)
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,p=p,v=p)
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
#@-node:ekr.20060928110801:Allow -- comments in @url nodes
#@-node:ekr.20060912093334:New features
#@-node:ekr.20060929090247.1:4.4.2 b1
#@+node:ekr.20060929090247:4.4.2 b2
#@+node:ekr.20060929091051:Bugs
#@+node:ekr.20060927073203:Fixed rst3 problem
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3932641

LEO *always* outputs the first line of a node without indentation even if it is indented in the node.
#@-node:ekr.20060927073203:Fixed rst3 problem
#@+node:ekr.20060929133002:Fixed apparent bug in pmw
@nocolor

This was a very weird one.  It's not clear why it wasn't biting before.


Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 321, in <module>
    run(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 151, in run
    g.app.gui.runMainLoop()
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 182, in runMainLoop
    self.root.mainloop()
  File "c:\python25\lib\lib-tk\Tkinter.py", line 1023, in mainloop
    self.tk.mainloop(n)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1756, in __call__
    _reporterror(self.func, args)
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1782, in _reporterror
    msg = exc_type + ' Exception in Tk callback\n'
TypeError: unsupported operand type(s) for +: 'type' and 'str'
>>>
#@nonl
#@-node:ekr.20060929133002:Fixed apparent bug in pmw
#@+node:ekr.20061002135140:Looked at problems with unicode characters in scripts
@

The conclusion is:
- Unicode strings: use unicode escapes for all non-ascii characters.
- Plain strings: use the actual characters.

No changes were made to any of Leo's methods.
In particular, getScript *is* correct.
#@nonl
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    g.es("end of script",color="purple")
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@-node:EKR.20040627100424:<< unredirect output >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@-node:ekr.20061002135140:Looked at problems with unicode characters in scripts
#@-node:ekr.20060929091051:Bugs
#@+node:ekr.20060929141921:Features
#@+node:ekr.20060929141750:Improved the mod_scripting plugin
@nocolor

- Make showing the Run Script button optional.
- The Script Button button now creates the press-script-button-button command.
- A new utility method does a much better job of massaging button and command names.
#@-node:ekr.20060929141750:Improved the mod_scripting plugin
#@+node:ekr.20060929090247.2:rst3 plugin now register rst3-process-tree command
#@-node:ekr.20060929090247.2:rst3 plugin now register rst3-process-tree command
#@+node:ekr.20060928082153:Completed support for myLeoSettings.leo
@nocolor

New in beta 2: Leo looks for myLeoSettings.leo files in the same place Leo looks for leoSettings.leo files.

@color
#@nonl
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):
    
    """Set self.globalConfigFile, self.homeFile and self.myConfigFile."""
    
    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    
    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global:',self.globalConfigFile)
        g.trace('home:',self.homeFile)
        g.trace('myGlobal:',self.myGlobalConfigFile)
        g.trace('myHome:',self.myHomeConfigFile)
#@nonl
#@-node:ekr.20041117083857:initSettingsFiles
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')
    
def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')
    
def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []

    # This can't be done in initSettingsFiles because the local directory does not exits.
    localDirectory = g.os_path_dirname(fileName)
    
    #  Set the local leoSettings.leo file.
    localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
    if not g.os_path_exists(localConfigFile): localConfigFile = None
    
    # Set the local myLeoSetting.leo file.
    myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
    if not g.os_path_exists(myLocalConfigFile): myLocalConfigFile = None
    
    # Init settings from leoSettings.leo files, including myLeoSettings.leo.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles
#@+node:ekr.20041117083857.1:g.app.config.readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@-node:ekr.20041117083857.1:g.app.config.readSettings
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c)
    
    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)
            
    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@-node:ekr.20060928082153:Completed support for myLeoSettings.leo
#@+node:ekr.20060930110140:Added settings for all mod_scripting switches
#@-node:ekr.20060930110140:Added settings for all mod_scripting switches
#@+node:ekr.20060928062431.1:Sparse find command
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3935780

This greatly speeds searches that used to open many nodes.

New in Leo 4.4.2 b2: support for @bool collapse_nodes_during_finds setting.
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify-all-python-code':     c.beautifyAllPythonCode,
    'beautify-python-code':         c.beautifyPythonCode,
    'cascade-windows':              f.cascade,
    'clear-recent-files':           c.clearRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible':            c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-bracket':                c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-users-guide':             c.leoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-CWEB':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-to':                 c.saveTo,
    'select-all':                   f.body.selectAllText,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@+node:ekr.20060928062431:expandOnlyAncestorsOfNode
def expandOnlyAncestorsOfNode (self,event=None):
    
    '''Contract all nodes in the outline.'''

    c = self ; level = 1
    
    c.beginUpdate()
    try:
        for p in c.allNodes_iter():
            p.contract()
        for p in c.currentPosition().parents_iter():
            p.expand()
            level += 1
    finally:
        c.endUpdate()
        c.treeWantsFocusNow()

    c.expansionLevel = level # Reset expansion level.
#@-node:ekr.20060928062431:expandOnlyAncestorsOfNode
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible()
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    # g.trace(id(t),pos,newpos)
    c.widgetWantsFocusNow(t)
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    # c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20060928062431.1:Sparse find command
#@+node:ekr.20060930125206:Made writing .leo files faster
@nocolor

The code that writes .leo files is now almost exactly twice as fast as the old code.
#@nonl
#@+node:EKR.20040526202501:putUnknownAttributes & helper
def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        return ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
#@nonl
#@+node:ekr.20050418161620.2:putUaHelper
def putUaHelper (self,torv,key,val):
    
    '''Put attribute whose name is key and value is val to the output stream.'''
    
    # g.trace(key,repr(val))
    
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,xml.sax.saxutils.escape(val))
            return attr
        else:
            g.es("ignoring non-string attribute %s in %s" % (
                key,torv),color="blue")
            return ''
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
        python23 = g.CheckVersion(version,'2.3')
        try:
            if python23:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            else:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            return attr
        except Exception:
            g.es('putUaHelper: unexpected pickling exception',color='red')
            g.es_exception()
            return ''
    except pickle.PicklingError:
        # New in 4.2 beta 1: keep going after error.
        g.es("ignoring non-pickleable attribute %s in %s" % (
            key,torv),color="blue")
        return ''
#@-node:ekr.20050418161620.2:putUaHelper
#@-node:EKR.20040526202501:putUnknownAttributes & helper
#@+node:ekr.20031218072017.1577:putTnode
def putTnode (self,t):
    
    # New in Leo 4.4.2 b2: call put just once.
    gnx = g.app.nodeIndices.toString(t.fileIndex)
    ua = hasattr(t,'unknownAttributes') and self.putUnknownAttributes(t) or ''
    body = t.bodyString and xml.sax.saxutils.escape(t.bodyString) or ''
    self.put('<t tx="%s"%s>%s</t>\n' % (gnx,ua,body))
#@nonl
#@-node:ekr.20031218072017.1577:putTnode
#@+node:ekr.20031218072017.1579:putVnodes & helpers
def putVnodes (self):

    """Puts all <v> elements in the order in which they appear in the outline."""

    c = self.c
    c.clearAllVisited()

    self.put("<vnodes>\n")

    # Make only one copy for all calls.
    self.currentPosition = c.currentPosition() 
    self.topPosition     = c.topPosition()

    if self.usingClipboard:
        self.putVnode(self.currentPosition) # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings_iter():
            # New in Leo 4.4.2 b2 An optimization:
            self.putVnode(p,isIgnore=p.isAtIgnoreNode()) # Write the next top-level node.

    self.put("</vnodes>\n")
#@nonl
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p,isIgnore=False):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isOrphan = p.isOrphan()
    if not isIgnore: isIgnore = p.isAtIgnoreNode()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)
    << Set gnx = tnode index >>
    attrs = []
    << Append attribute bits to attrs >>
    << Append tnodeList and unKnownAttributes to attrs >>
    attrs = ''.join(attrs)
    v_head = '<v t="%s"%s><vh>%s</vh>' % (gnx,attrs,xml.sax.saxutils.escape(p.v.headString()or''))
    # The string catentation is faster than repeated calls to fc.put.
    if not self.usingClipboard:
        << issue informational messages >>
    # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren() and (forceWrite or self.usingClipboard):
        fc.put('%s\n' % v_head)
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            fc.putVnode(p,isIgnore)
            if p.hasNext(): p.moveToNext()
            else:           break
        p.moveToParent() # Restore p in the caller.
        fc.put('</v>\n')
    else:
        fc.put('%s</v>\n' % v_head) # Call put only once.
#@nonl
#@+node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@-node:ekr.20031218072017.1864:<< Set gnx = tnode index >>
#@+node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
# These string catenations are benign because they rarely happen.
attr = ""
if v.isExpanded(): attr += "E"
if v.isMarked():   attr += "M"
if v.isOrphan():   attr += "O"

# No longer a bottleneck now that we use p.equal rather than p.__cmp__
# Almost 30% of the entire writing time came from here!!!
if p.equal(self.topPosition):     attr += "T" # was a bottleneck
if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr:
    attrs.append(' a="%s"' % (attr))
#@nonl
#@-node:ekr.20031218072017.1865:<< Append attribute bits to attrs >>
#@+node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

# Debugging.
# if v.isAnyAtFileNode():
    # if hasattr(v.t,"tnodeList"):
        # g.trace(v.headString(),len(v.t.tnodeList))
    # else:
        # g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        attrs.append(fc.putTnodeList(v)) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    attrs.append(self.putUnknownAttributes(v))
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    attrs.append(self.putDescendentUnknownAttributes(p))
    attrs.append(self.putDescendentAttributes(p))
#@nonl
#@-node:ekr.20040324082713:<< Append tnodeList and unKnownAttributes to attrs>>
#@+node:ekr.20040702085529:<< issue informational messages >>
if isOrphan and isThin:
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

# For testing.
# if p.isAtIgnoreNode():
     # for p2 in p.self_and_subtree_iter():
            # if p2.isAtThinFileNode():
                # g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@-node:ekr.20040702085529:<< issue informational messages >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
def putTnodeList (self,v):
    
    """Put the tnodeList attribute of a tnode."""
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

    fc = self ; nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        for t in tnodeList:
            try: # Will fail for None or any pre 4.1 file index.
                theId,time,n = t.fileIndex
            except:
                g.trace("assigning gnx for ",v,t)
                gnx = nodeIndices.getNewIndex()
                v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
        s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        return ' tnodeList="%s"' % (s)
    else:
        return ''
#@nonl
#@-node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
#@+node:ekr.20040701065235.2:putDescendentAttributes
def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    if 1: # New in Leo 4.4.2 b2.
        # Put each tnode in the list only once.
        # This should have been done long ago.
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            t = p.v.t
            if p.isMarked() and p.v.t not in marks:
                marks.append(t)
            if p.hasChildren() and p.isExpanded() and t not in expanded:
                expanded.append(t)
    
        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for t in theList:
                    gnx = t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))
    else:
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            if p.isMarked() and not p in marks:
                marks.append(p.copy())
            if p.hasChildren() and p.isExpanded() and not p in expanded:
                expanded.append(p.copy())
    
        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for p in theList:
                    gnx = p.v.t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))
            
    return ''.join(result)
#@nonl
#@-node:ekr.20040701065235.2:putDescendentAttributes
#@+node:EKR.20040627113418:putDescendentUnknownAttributes
def putDescendentUnknownAttributes (self,p):
    
    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    python23 = g.CheckVersion(version,'2.3')

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    tnodesData = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                # g.trace(p2.headString(),t)
                tnodes.append(t) # Bug fix: 10/4/06.
                tnodesData.append((p2,t),)
    
    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodesData:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.
            
            for key in d.keys():
                try:
                    # We don't actually save the pickled values here.
                    if python23:
                        pickle.dumps(d[key],protocol=1) # Requires Python 2.3
                    else:
                        pickle.dumps(d[key],bin=True) # Requires earlier versions of Python.
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
                except Exception:
                    del d[key]
                    g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
                    g.es_exception()
            data.append((t,d),)
            
    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d
    
    if 0:
        print "resultDict..."
        for key in resultDict:
            print repr(key),repr(resultDict.get(key))

    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            if python23:
                s = pickle.dumps(resultDict,protocol=1) # Requires Python 2.3
                # g.trace('protocol=1')
            else:
                s = pickle.dumps(resultDict,bin=True) # Requires Earlier version of Python.
                # g.trace('bin=True')
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            return field
        except pickle.PicklingError:
            g.trace("putDescendentUnknownAttributes can't happen 1",color="red")
        except Exception:
            g.es("putDescendentUnknownAttributes can't happen 2",color='red')
            g.es_exception()
    return ''
#@-node:EKR.20040627113418:putDescendentUnknownAttributes
#@-node:ekr.20031218072017.1579:putVnodes & helpers
#@-node:ekr.20060930125206:Made writing .leo files faster
#@+node:ekr.20061002073144:Installed latest word patch
@nocolor 

A patch for 4.4.2 beta 1 to make Leo jump to the start of word while searching backwards. It is default behavior windows editors:

--- E:/ENV/Leo/src/leoEditCommands_old.py   Sun Oct 01 14:35:38 2006
+++ E:/ENV/Leo/src/leoEditCommands_var2.py  Sun Oct 01 14:42:48 2006
@@ -3302,12 +3302,18 @@
         i = toPython(w.index('insert'))
         delta = g.choose(forward,1,-1)
         
-        if not forward: i -= 1
-        while 0 <= i < n and isWordChar(s[i]):
-            i += delta
-        while 0 <= i < n and not isWordChar(s[i]):
-            i += delta
-        if not forward: i += 1;
+        if not forward:
+            i -= 1
+            while 0 <= i < n and not isWordChar(s[i]):
+                i += delta
+            while 0 <= i < n and isWordChar(s[i]):
+                i += delta
+            i += 1
+        else:
+            while 0 <= i < n and isWordChar(s[i]):
+                i += delta
+            while 0 <= i < n and not isWordChar(s[i]):
+                i += delta
     
         self.moveToHelper(event,toGui(i),extend)
#@verbatim
     #@nonl
     
@color
#@nonl
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
    def isWordChar(ch): return ch in (string.letters + string.digits + '_')

    i = toPython(w.index('insert'))
    delta = g.choose(forward,1,-1)
    
    if forward:
        while 0 <= i < n and isWordChar(s[i]):
            i += delta
        while 0 <= i < n and not isWordChar(s[i]):
            i += delta
    else:
        i -= 1
        while 0 <= i < n and not isWordChar(s[i]):
            i += delta
        while 0 <= i < n and isWordChar(s[i]):
            i += delta
        i += 1

    self.moveToHelper(event,toGui(i),extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@-node:ekr.20061002073144:Installed latest word patch
#@+node:ekr.20061002064811:Added support for outline_pane_has_initial_focus setting
@nocolor

Added support for @bool outline_pane_has_initial_focus setting

@color
#@nonl
#@+node:ekr.20061002060833:Finish opml plugin: enhance open/save dialogs when opml is present
#@-node:ekr.20061002060833:Finish opml plugin: enhance open/save dialogs when opml is present
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            if c.config.getBool('outline_pane_has_initial_focus'):
                c.treeWantsFocusNow()
            else:
                c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):
    
    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):
    
    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
            
    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):
    
    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save
def save (self,event=None):
    
    '''Save a Leo outline to a file.'''

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
#@-node:ekr.20031218072017.2834:save
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):
    
    '''Save a Leo outline to a file with a new filename.'''
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):
    
    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):
    
    '''Revert the contents of a Leo outline to last saved contents.'''
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002064811:Added support for outline_pane_has_initial_focus setting
#@+node:ekr.20061001145550:Generalized navigation in outline pane to ignore @file, @thin, etc prefixes
#@+node:ekr.20060923202156:c.onCanvasKey
def onCanvasKey (self,event):
    
    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''
    
    if not event or not event.char or not event.keysym.isalnum():
        return
    c  = self ; p = c.currentPosition() ; p1 = p.copy()
    ch = event.char ; all = ch.isupper()
    found = False
    extend = self.navQuickKey(p)
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if all:
                p.moveToThreadNext()
            else:
                p.moveToVisNext()
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,all,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        if all: self.expandAllAncestors(p)
        c.selectPosition(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.headString())
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocusNow()
#@nonl
#@+node:ekr.20061002095711.1:c.navQuickKey
def navQuickKey (self,p):
    
    '''return true if there are two quick outline navigation keys
    in quick succession.
    
    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''
    
    c = self
   
    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime < deltaTime
        # g.trace(nearTime,p.headString())
        return nearTime
#@nonl
#@-node:ekr.20061002095711.1:c.navQuickKey
#@+node:ekr.20061002095711:c.navHelper
def navHelper (self,p,ch,all,extend):
    
    c = self ; h = p.headString().lower()
    
    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch
    
    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent','noref'):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n < len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
#@nonl
#@-node:ekr.20061002095711:c.navHelper
#@-node:ekr.20060923202156:c.onCanvasKey
#@-node:ekr.20061001145550:Generalized navigation in outline pane to ignore @file, @thin, etc prefixes
#@+node:ekr.20061002064543:Make outline navigation cumulative
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3941670

The code on cvs now supports the 'extended' character search. When keystrokes
(in the outline pane) are typed 'close' together in time Leo first tries to look
for prefix + ch, where ch is the character just typed and prefix is the previous
match.

By 'close together' I mean the time interval specified by the new setting:

@float outline_nav_extend_delay = 2.0

The unit of time is seconds.

The outline nav search revers to a single-character if the extended search
fails, so in fact the delay is not too significant. In practice everything works
well without me thinking at all about what is happening.

@color
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = '' # Must always be a string.
self.navTime = None
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@+node:ekr.20060923202156:c.onCanvasKey
def onCanvasKey (self,event):
    
    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''
    
    if not event or not event.char or not event.keysym.isalnum():
        return
    c  = self ; p = c.currentPosition() ; p1 = p.copy()
    ch = event.char ; all = ch.isupper()
    found = False
    extend = self.navQuickKey(p)
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if all:
                p.moveToThreadNext()
            else:
                p.moveToVisNext()
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,all,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        if all: self.expandAllAncestors(p)
        c.selectPosition(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.headString())
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocusNow()
#@nonl
#@+node:ekr.20061002095711.1:c.navQuickKey
def navQuickKey (self,p):
    
    '''return true if there are two quick outline navigation keys
    in quick succession.
    
    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''
    
    c = self
   
    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime < deltaTime
        # g.trace(nearTime,p.headString())
        return nearTime
#@nonl
#@-node:ekr.20061002095711.1:c.navQuickKey
#@+node:ekr.20061002095711:c.navHelper
def navHelper (self,p,ch,all,extend):
    
    c = self ; h = p.headString().lower()
    
    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch
    
    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent','noref'):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n < len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
#@nonl
#@-node:ekr.20061002095711:c.navHelper
#@-node:ekr.20060923202156:c.onCanvasKey
#@-node:ekr.20061002064543:Make outline navigation cumulative
#@-node:ekr.20060929141921:Features
#@+node:ekr.20060929141921.1:Tests
#@+node:ekr.20060929100150:Tested Python 2.5 exception reporting
Used brief traceback in g.handleScriptException
#@nonl
#@+node:ekr.20031218072017.3111:es_event_exception
def es_event_exception (eventName,full=False):

    g.es("exception handling ", eventName, " event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es(i)
        
    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()
#@-node:ekr.20031218072017.3111:es_event_exception
#@+node:ekr.20040731204831:getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ in (exceptions.SyntaxError,exceptions.IndentationError):
        # Syntax and indentation errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            # g.es_print(repr(val))
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        # g.es_print(repr(data))
        item = data[-1]
        filename = item[0]
        n = item[1]
        return filename,n
#@-node:ekr.20040731204831:getLastTracebackFileAndLineNumber
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@+node:ekr.20060624085200:g.handleScriptException
def handleScriptException (c,p,script,script1):

    g.es("exception executing script",color='blue')

    fileName, n = g.es_exception(full=False)

    if p and not script1 and fileName == "<string>":
        c.goToScriptLineNumber(p,script,n)

    << dump the lines near the error >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

# Print surrounding lines.
i = max(0,n-2)
j = min(n+2,len(lines))
while i < j:
    ch = g.choose(i==n-1,'*',' ')
    s = "%s line %d: %s" % (ch,i+1,lines[i])
    g.es(s,newline=False)
    i += 1
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20060624085200:g.handleScriptException
#@-node:ekr.20060929100150:Tested Python 2.5 exception reporting
#@+node:ekr.20061001094334:Added unit tests for uA's
# The tests are in unitTest.leo.
# Important: test_ methods do not get an accurate value of p!

# Fixed several bugs relating to different signatures for pickle.dumps.
#@nonl
#@+node:EKR.20040526202501:putUnknownAttributes & helper
def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        return ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
#@nonl
#@+node:ekr.20050418161620.2:putUaHelper
def putUaHelper (self,torv,key,val):
    
    '''Put attribute whose name is key and value is val to the output stream.'''
    
    # g.trace(key,repr(val))
    
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,xml.sax.saxutils.escape(val))
            return attr
        else:
            g.es("ignoring non-string attribute %s in %s" % (
                key,torv),color="blue")
            return ''
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
        python23 = g.CheckVersion(version,'2.3')
        try:
            if python23:
                # Protocol argument is new in Python 2.3
                # Use protocol 1 for compatibility with bin.
                s = pickle.dumps(val,protocol=1)
            else:
                s = pickle.dumps(val,bin=True)
            attr = ' %s="%s"' % (key,binascii.hexlify(s))
            return attr
        except Exception:
            g.es('putUaHelper: unexpected pickling exception',color='red')
            g.es_exception()
            return ''
    except pickle.PicklingError:
        # New in 4.2 beta 1: keep going after error.
        g.es("ignoring non-pickleable attribute %s in %s" % (
            key,torv),color="blue")
        return ''
#@-node:ekr.20050418161620.2:putUaHelper
#@-node:EKR.20040526202501:putUnknownAttributes & helper
#@+node:ekr.20040701065235.2:putDescendentAttributes
def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    if 1: # New in Leo 4.4.2 b2.
        # Put each tnode in the list only once.
        # This should have been done long ago.
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            t = p.v.t
            if p.isMarked() and p.v.t not in marks:
                marks.append(t)
            if p.hasChildren() and p.isExpanded() and t not in expanded:
                expanded.append(t)
    
        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for t in theList:
                    gnx = t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))
    else:
        marks = [] ; expanded = []
        for p in p.subtree_iter():
            if p.isMarked() and not p in marks:
                marks.append(p.copy())
            if p.hasChildren() and p.isExpanded() and not p in expanded:
                expanded.append(p.copy())
    
        result = []
        for theList,tag in ((marks,"marks"),(expanded,"expanded")):
            if theList:
                sList = []
                for p in theList:
                    gnx = p.v.t.fileIndex
                    sList.append("%s," % nodeIndices.toString(gnx))
                s = string.join(sList,'')
                # g.trace(tag,[str(p.headString()) for p in theList])
                result.append('\n%s="%s"' % (tag,s))
            
    return ''.join(result)
#@nonl
#@-node:ekr.20040701065235.2:putDescendentAttributes
#@+node:EKR.20040627113418:putDescendentUnknownAttributes
def putDescendentUnknownAttributes (self,p):
    
    # The bin param doesn't exist in Python 2.3;
    # the protocol param doesn't exist in earlier versions of Python.
    version = '.'.join([str(sys.version_info[i]) for i in (0,1)])
    python23 = g.CheckVersion(version,'2.3')

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    tnodesData = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                # g.trace(p2.headString(),t)
                tnodes.append(t) # Bug fix: 10/4/06.
                tnodesData.append((p2,t),)
    
    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodesData:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.
            
            for key in d.keys():
                try:
                    # We don't actually save the pickled values here.
                    if python23:
                        pickle.dumps(d[key],protocol=1) # Requires Python 2.3
                    else:
                        pickle.dumps(d[key],bin=True) # Requires earlier versions of Python.
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
                except Exception:
                    del d[key]
                    g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
                    g.es_exception()
            data.append((t,d),)
            
    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d
    
    if 0:
        print "resultDict..."
        for key in resultDict:
            print repr(key),repr(resultDict.get(key))

    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            if python23:
                s = pickle.dumps(resultDict,protocol=1) # Requires Python 2.3
                # g.trace('protocol=1')
            else:
                s = pickle.dumps(resultDict,bin=True) # Requires Earlier version of Python.
                # g.trace('bin=True')
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            return field
        except pickle.PicklingError:
            g.trace("putDescendentUnknownAttributes can't happen 1",color="red")
        except Exception:
            g.es("putDescendentUnknownAttributes can't happen 2",color='red')
            g.es_exception()
    return ''
#@-node:EKR.20040627113418:putDescendentUnknownAttributes
#@-node:ekr.20061001094334:Added unit tests for uA's
#@-node:ekr.20060929141921.1:Tests
#@-node:ekr.20060929090247:4.4.2 b2
#@-node:ekr.20060904165452:4.4.2 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
