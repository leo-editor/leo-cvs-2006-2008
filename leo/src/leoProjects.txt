#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20050924073836:4.4 projects
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20051029070945:Pychecker report
# None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found
#@nonl
#@-node:ekr.20051029070945:Pychecker report
#@+node:ekr.20060203112912.1:Initing
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.
    << set the leoTkinterFrame ivars >>
#@nonl
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    self.trace_status_line = c.config.getBool('trace_status_line')
    # f.enableTclTraces()
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("<Activate>",f.OnActivateLeoEvent)
        f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
        f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
        f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@nonl
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):

    # pageName is not used here: it is used for compatibility with the Chapters plugin.

    c = self.c

    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    trace = self.c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace(canvas)
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 0:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@+node:ekr.20041221071131:createPmwTreeCanvas (not used)
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
 
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas (not used)
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf (tkFrame)
def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf (tkFrame)
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20050920085536.1: Birth (keyHandler)
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter')
    self.enable_calltips                = c.config.getBool('enable_calltips')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
    
    self.autoCompleter = autoCompleterClass(self)
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()
#@nonl
#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20060115195302:setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)
#@nonl
#@-node:ekr.20060115195302:setDefaultUnboundKeyAction
#@-node:ekr.20050920085536.1: Birth (keyHandler)
#@-node:ekr.20060203112912.1:Initing
#@+node:ekr.20060306070425:4.4 b3 projects
#@+node:ekr.20060323131536:New features
#@+node:ekr.20060307234849:Addded outline-scroll commands
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(1,"unit")
    
def scrollOutlineDownPage (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(-1,"page")


#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@-node:ekr.20060307234849:Addded outline-scroll commands
#@+node:ekr.20060307080642.1:Added some balloons to the tree pane
#@+node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@nonl
#@-node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k

    found = len(self.freeText) > 0
    if found:
        t,theId = self.freeText.pop()
        if self.trace_alloc: g.trace('%4d' % (theId),self.textAddr(t),'recycled')
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.

    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        t.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
        if self.trace_alloc:
            g.trace('%4d' % (theId),self.textAddr(t),'** new')
            
    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')
            
    self.ids[theId] = p # Add the id of the *window*
    self.setText(theId,t,p.headString())
    t.configure(width=self.headWidth(p=p))
    t.leo_position = p # This p never changes.
        # *Required*: onHeadlineClick uses w.leo_position to get p.

    # Keys are p.key().  Entries are (t,theId)
    self.visibleText [p.key()] = t,theId
    
    return t
#@nonl
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

instance_tag = t.bindtags()[0]
t.bind_class(instance_tag, "<Button-4>", PropagateButton4)
t.bind_class(instance_tag, "<Button-5>", PropagateButton5)
t.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
#@nonl
#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@+node:ekr.20040803072955.8:newClickBox
def newClickBox (self,p,x1,y1,x2,y2):
    
    canvas = self.canvas ; defaultColor = ""
    tag = g.choose(p.hasChildren(),'clickBox','selectBox')

    if self.freeClickBoxes:
        theId = self.freeClickBoxes.pop(0)
        canvas.coords(theId,x1,y1,x2,y2)
        canvas.itemconfig(theId,tag=tag)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        
    if self.trace_alloc:
        g.trace("%3d %3d %3d %3d %3d" % (theId,x1,y1,x2,y2),p.headString(),align=-20)

    assert(theId not in self.visibleClickBoxes)
    self.visibleClickBoxes.append(theId)
    
    # assert(p)
    # assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    return theId
#@nonl
#@-node:ekr.20040803072955.8:newClickBox
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        self.redrawCount += 1
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())
        
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)

    if self.trace_stats: self.showStats()
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@-node:ekr.20060307080642.1:Added some balloons to the tree pane
#@+node:ekr.20060306200304.1:Added scroll outline pane commands
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3608246

Added the following commands:

scroll-outline-down-line       
scroll-outline-down-page       
scroll-outline-up-line       
scroll-outline-up-page
#@nonl
#@-node:ekr.20060306200304.1:Added scroll outline pane commands
#@+node:ekr.20060325093414:Improved registerCommand
# It now properly creates bindings.
#@nonl
#@+node:ekr.20051008134059:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)
#@nonl
#@-node:ekr.20051008134059:makeBindingsFromCommandsDict
#@+node:ekr.20051015110547:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
        ok = k.bindKey (pane,stroke,func,commandName)
        k.registerBinding(shortcut)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    else:
        # New in 4.4b3: try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        found = False
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                found = True
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,func,commandName)
                k.registerBinding(accel)
                if verbose:
                    g.es_print('Registered %s bound to %s' % (
                        commandName,k.prettyPrintKey(shortcut)),color='blue')
        if verbose and not found:
            g.es_print('Registered %s' % (commandName),color='blue')
#@+node:ekr.20060325110412:registerBinding
def registerBinding (self,shortcut):
    
    k = self ; f = k.c.frame

    # Duplicate the logic k.completeAllBindings to set the actual bindings.
    stroke = k.shortcutFromSetting(shortcut)
    # g.trace(stroke)
        
    def bindKeyCallback (event,k=k,stroke=stroke):
        return k.masterKeyHandler(event,stroke=stroke)
    
    for w in (f.body.bodyCtrl,f.tree.canvas,f.tree.bindingWidget):
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)
#@nonl
#@-node:ekr.20060325110412:registerBinding
#@-node:ekr.20051015110547:k.registerCommand
#@-node:ekr.20060325093414:Improved registerCommand
#@+node:ekr.20060228071700:Suppressed autocompletion after numbers
#@-node:ekr.20060228071700:Suppressed autocompletion after numbers
#@+node:ekr.20060227120635:Added Lua patch
#@+node:ekr.20060328110802.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3572598
By: davidmcnab

I have added support to Leo for the Lua programming language (www.lua.org).

A patch, against Leo 4.4 beta 1, build  1.375, is up at:
http://www.freenet.org.nz/misc/leo-with-lua.patch.gz

Patch should be executed with '-p1' inside the leo 'src' directory.

Summary: support for importing Lua files; support for Lua comments and keywords;
no auto-detect of Lua function definitions or classes (because Lua function/class
idioms vary); no support for Lua v5+ metamethods.

Implementation method - I loaded LeoPy.leo, searched the whole outline for 'java',
and added lua counterparts throughout, including a Lua comment scanner.
#@nonl
#@-node:ekr.20060328110802.1:Report
#@+node:ekr.20031218072017.367:How to add support for a new language
@nocolor

- Add a new entries in << define global data structures >> app

- Add a new Tk.Radiobutton in <<create the Target Language frame>>

- Add an entry to the languages list in <<configure language-specific settings>>

- Add a list of the keywords of the language to << define colorizer keywords >>

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.
  
- If the language is case insensitive, add it to the list of
case_insensitiveLanguages found in  << define global colorizer data >>

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the <preferences> tag (near the top) contains an entry like this:

<preferences allow_rich_text="0" defaultTargetLanguage="Python">
</preferences>

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color
#@nonl
#@+node:EKR.20040623090054:<< define global colorizer data >>
case_insensitiveLanguages = ['plsql',]
#@nonl
#@-node:EKR.20040623090054:<< define global colorizer data >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex","lua",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords
#@nonl
#@+node:ekr.20031218072017.372:actionscript keywords
actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
#@nonl
#@-node:ekr.20031218072017.372:actionscript keywords
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@nonl
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20040206072057:c# keywords
csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]
#@nonl
#@-node:ekr.20040206072057:c# keywords
#@+node:ekr.20031218072017.373:c/c++ keywords
c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]
#@nonl
#@-node:ekr.20031218072017.373:c/c++ keywords
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@nonl
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.374:elisp keywords
# EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]
#@nonl
#@-node:ekr.20031218072017.374:elisp keywords
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@nonl
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20031218072017.375:html keywords
# No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "<%","%>" ]
#@nonl
#@-node:ekr.20031218072017.375:html keywords
#@+node:ekr.20031218072017.376:java keywords
java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]
#@nonl
#@-node:ekr.20031218072017.376:java keywords
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx", "\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap",
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus",
    "\\bigvee", "\\bigwedge", "\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter",
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage",
    "\\cline", "\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh",
    "\\cot", "\\coth", "csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl",
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj",
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath",
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote",
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing",
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright", "\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill", "\\hspace", "\\huge", "\\Huge", "\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota", "\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", "\\linebreak", 
    "\\linethickness", "\\linewidth", "\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow", "longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength", "\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox", "\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", "\\phi", "\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi", "\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", "\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow", "\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow", "\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone", "\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark", "\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title", "\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow", "\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", "\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]
#@nonl
#@-node:ekr.20031218072017.377:latex keywords
#@+node:ekr.20060328110802:lua keywords
# ddm 13/02/06
lua_keywords = [
    "and", "break", "do", "else", "elseif", "end",
    "false", "for", "function", "if", "in", "local",
    "nil", "not", "or", "repeat", "return", "then",
    "true", "until", "while",
]
#@-node:ekr.20060328110802:lua keywords
#@+node:ekr.20031218072017.378:pascal keywords
pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]
#@nonl
#@-node:ekr.20031218072017.378:pascal keywords
#@+node:ekr.20031218072017.379:perl keywords
perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 & FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 & f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]
#@nonl
#@-node:ekr.20031218072017.379:perl keywords
#@+node:ekr.20031218072017.380:php keywords
php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "<?php", "?>"
#@-node:ekr.20031218072017.380:php keywords
#@+node:ekr.20050618052653:plsql keywords
plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
#@-node:ekr.20050618052653:plsql keywords
#@+node:ekr.20031218072017.381:python keywords
python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]
#@nonl
#@-node:ekr.20031218072017.381:python keywords
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@nonl
#@-node:ekr.20040331145826:rapidq keywords
#@+node:ekr.20031218072017.382:rebol keywords
rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
#@nonl
#@-node:ekr.20031218072017.382:rebol keywords
#@+node:ekr.20040401111125:shell keywords
shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]
#@nonl
#@-node:ekr.20040401111125:shell keywords
#@+node:ekr.20031218072017.383:tcl/tk keywords
tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]
#@nonl
#@-node:ekr.20031218072017.383:tcl/tk keywords
#@-node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
#@+node:ekr.20050618052621:Add the language name to @language default_target_language entry in leoSettings.leo
#@-node:ekr.20050618052621:Add the language name to @language default_target_language entry in leoSettings.leo
#@-node:ekr.20031218072017.367:How to add support for a new language
#@+node:ekr.20031218072017.1809:importDerivedFile
def importDerivedFile (self,event=None):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(parent=p,paths=names)
#@nonl
#@-node:ekr.20031218072017.1809:importDerivedFile
#@-node:ekr.20060227120635:Added Lua patch
#@+node:ekr.20060328121145.1:Added run-unit-test command
#@+node:ekr.20060328121145:runUnitTest
def runUnitTests (self,event=None):
    
    '''Run all unit tests contained in the presently selected outline.'''
    
    c = self.c

    leoTest.doTests(c,all=False)
#@nonl
#@-node:ekr.20060328121145:runUnitTest
#@-node:ekr.20060328121145.1:Added run-unit-test command
#@-node:ekr.20060323131536:New features
#@+node:ekr.20060323131536.1:Bugs
#@+node:ekr.20060309022225:Fixed problem with left & right arrows in outline mode
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3619340
By: nobody

Just tried out CVS today, and on Linux left/right and L/R in outline mode
(Ctrl-Shift-O) seem to do nothing, whereas they should expand/contract parent
nodes. Do I need to do something special to enable these keys, or is this a bug?

@color
#@nonl
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event,stroke):
    
    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    << handle per-pane bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(repr(stroke),'state',state)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        g.trace('No state dictionary for %s' % state)
    return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@-node:ekr.20060309022225:Fixed problem with left & right arrows in outline mode
#@+node:ekr.20060321094013:Made Control-v work again in find command
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event,stroke):
    
    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    << handle per-pane bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(repr(stroke),'state',state)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        g.trace('No state dictionary for %s' % state)
    return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@-node:ekr.20060321094013:Made Control-v work again in find command
#@+node:ekr.20060320113137:Fixed undo problem with clones
# The dirty bits were not updated properly in several undo/redo operations.
#@nonl
#@+node:ekr.20060320113137.2:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3639193
By: nobody

I'm using Leo 4.3.1, build 1.266 , June 20, 2005. 

I have a document of a few @thin nodes that in some hundred subnodes contain
many nodes so that the same node is cloned in more than one file. This works
mgaically greatly in Leo. Whatever I change in one cloned node is neatly distributed
to all the files.

But I've found a situation, that can be a bit dangerous. I changed the body
(actually I did Ctrl-x to cut a part of it) of one of these cloned nodes and
saved the whole document with Ctrl-s. Then I undid from the Edit menu with the
"Undo Cut" and saved whole document with Ctrl-s again.

After undo and before second saving I already noticed that the icons before
changed clones did not get different, more black, colour that signifies changed
nodes.

But, more seriously, I've noticed in the log, that only the top .leo file was
saved. I looked into other files containing the cloned node and really, there
was still the old contents.

There is a simple workaround. I simply type and delete one space into the body
of the changed node and then the colour of the icons is OK and Ctrl-s saves
oall the clones.

May be it's not important that I have @thin nodes. May be the same situation
would show in one self contained .leo document with a few clones. I didn't try.

I hope I explained well enough. If anybody is interested to anylse and cannot
reproduce the situation, I would try to prepare a simplified document to show
the problem.

maksr@snt.si
#@nonl
#@-node:ekr.20060320113137.2:Report
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding) # New in 4.4b3.
    newText = g.app.gui.getAllText(bodyCtrl) # New in 4.4b3: converts to unicode.
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        # g.trace('removeTrailing:',removeTrailing)
        g.trace('newText:',repr(newText))
        #g.trace('oldText:',repr(oldText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        << recolor the body >>
        if not c.changed: c.setChanged(True)
        << redraw the screen if necessary >>
#@nonl
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    ### elif g.safeStringCompare(old,new[-1]):
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone(p)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
#@nonl
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty() # New in 4.4b3.
    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    
    # g.trace('oldSel',u.oldSel)

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.oldSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):
    
    u = self ; c = u.c
    
    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()

    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412083057:redoCloneNode
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
        
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()
    
    if u.newSel:
        c.bodyWantsFocus()
        c.frame.body.setTextSelection(u.newSel)
    if u.yview:
        c.bodyWantsFocus()
        c.frame.body.setYScrollPosition(u.yview)
#@nonl
#@-node:EKR.20040526075238.5:redoTyping
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    dirtyVnodeList = []
    
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    c.beginUpdate()
    try:
        for v in dirtyVnodeList:
            v.t.setDirty() # Do not call v.setDirty here!
    finally:
        c.endUpdate(changed)

    return dirtyVnodeList
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s=g.app.gui.getAllText(w)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    # g.trace(wname,s,i,j)
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    << return if there is nothing to do >>
    # g.trace(undo_type,g.callers(7))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
if not p.isDirty():
    bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@nonl
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@nonl
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@nonl
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20060320113137:Fixed undo problem with clones
#@+node:ekr.20060321140706:Investigated setting descendant @file nodes dirty when changing body text
#@+node:ekr.20060323085310:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3642892
By: thyrsus

An unimportant bug presented when I tried this: the logic to interpret
the @file didn't notice the change to the parent node, and I had to taint the
@file node itself (I'm sure a child node would also have worked) to get Leo
to notice that the @file needed to be rewritten.


EKR: The present code is probably the best compromise between strict accuracy and marking too many nodes dirty.
#@nonl
#@-node:ekr.20060323085310:Report
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding) # New in 4.4b3.
    newText = g.app.gui.getAllText(bodyCtrl) # New in 4.4b3: converts to unicode.
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        # g.trace('removeTrailing:',removeTrailing)
        g.trace('newText:',repr(newText))
        #g.trace('oldText:',repr(oldText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        << recolor the body >>
        if not c.changed: c.setChanged(True)
        << redraw the screen if necessary >>
#@nonl
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    ### elif g.safeStringCompare(old,new[-1]):
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    dirtyVnodeList = []
    
    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    c.beginUpdate()
    try:
        for v in dirtyVnodeList:
            v.t.setDirty() # Do not call v.setDirty here!
    finally:
        c.endUpdate(changed)

    return dirtyVnodeList
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    << return if there is nothing to do >>
    # g.trace(undo_type,g.callers(7))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
if not p.isDirty():
    bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@nonl
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@nonl
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@nonl
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20060321140706:Investigated setting descendant @file nodes dirty when changing body text
#@+node:ekr.20060321111639:Got rid of settings messages
Apparently g.app.unitTesting isn't set properly for the new-window test.

### It's a button in some .leo file.

Warning: ignoring bool:tracegc not shortcut
There may be conflicting settings!
#@nonl
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        if not g.app.unitTesting and not not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@nonl
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):
    
    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            s = (
                'Warning: ignoring %s:%s not %s\n' +
                'There may be conflicting settings!')
            g.es_print(s % (bunch.kind,setting,requestedType),color='red')
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20060321111639:Got rid of settings messages
#@+node:ekr.20060323110223:Clicks outside minibuffer no longer rip focus
# Hit control-f, then select the text that doesn't have focus.
#@nonl
#@+node:ekr.20060129052538.2:masterClickHandler
def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol <= xcol <= jcol)
        if icol <= xcol <= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else: return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
#@nonl
#@-node:ekr.20060129052538.2:masterClickHandler
#@+node:ekr.20050920085536.63:keyboardQuit
def keyboardQuit (self,event,hideTabs=True):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return

    if hideTabs:
        k.autoCompleter.exit()
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    
    # Completely clear the mode.
    if k.inputModeName:
        k.endMode(event)

    # Complete clear the state.
    k.state.kind = None
    k.state.n = None

    k.clearState()
    k.resetLabel()
    
    k.setDefaultUnboundKeyAction()
    k.showStateAndMode()
    c.endEditing()
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20050920085536.63:keyboardQuit
#@-node:ekr.20060323110223:Clicks outside minibuffer no longer rip focus
#@+node:ekr.20060321080150.6:Handled missing leoSettings.leo files more gracefully
#@+node:ekr.20060323132048:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3641107
By: thyrsus

Running the entitled version of Leo from CVS on Fedora Core 4, python 2.4.1

Bug: attempting to save the outline:

+ top
(contents)
@delims dnl 
...@file foo.mc
(contents)
@first divert(-1)dnl
test
dnl test
more test

With no @settings nodes anywhere (there is no leSettings.leo file, contrary
to the generated message below), "python ~/leo/src/leo.py" makes a large number
of comments about

leoID = sps (in /home/sps)
Plugins disabled: use_plugins is 0 in a leoSettings.leo file.
initSpecialIvars: no setting for full-command
initSpecialIvars: no setting for keyboard-quit
initSpecialIvars: no setting for universal-argument
checkBindings: No shortcut for abbrev-mode = abbrevmode
checkBindings: No shortcut for abort-edit-headline = aborteditheadline
checkBindings: No shortcut for about-leo = aboutleo

(goes on for many lines)

The menu save results in python exceptions:

Leo Log Window...
Leo 4.4 a7, build  1.418 , February 28, 2006
Python 2.4.1, Tk 8.4.9, Pmw 1.2
linux2

leoID = sps (in /home/sps)
global config dir: /home/sps/leo/config
home dir: /home/sps
Plugins disabled: use_plugins is 0 in a leoSettings.leo file.
exception writing:divert(-1)dnl
Traceback (most recent call last):
  File "/home/sps/leo/src/leoAtFile.py", line 4138, in os
    s = g.toEncodedString(s,at.encoding,reportErrors=True)
  File "/home/sps/leo/src/leoGlobals.py", line 3842, in toEncodedString
    s = s.encode(encoding,"strict")
TypeError: encode() argument 1 must be string, not None
exception writing:/home/sps/foo.mc
Traceback (most recent call last):
  File "/home/sps/leo/src/leoAtFile.py", line 2912, in write
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
  File "/home/sps/leo/src/leoAtFile.py", line 3180, in writeOpenFile
    at.putOpenLeoSentinel("@+leo-ver=4")
  File "/home/sps/leo/src/leoAtFile.py", line 3894, in putOpenLeoSentinel
    encoding = at.encoding.lower()
AttributeError: 'NoneType' object has no attribute 'lower'
exception writing: /home/sps/foo.leo
TypeError: encode() argument 1 must be string, not None

#@-node:ekr.20060323132048:Report
#@+node:ekr.20060323134459:What I did
ConfigSettings.initEncoding now uses the g.app.config settings if no other settings are available.

In particular, this causes at.encoding to be inited to a reasonable value.
#@nonl
#@-node:ekr.20060323134459:What I did
#@+node:ekr.20051011103654:checkBindings
def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    if not c.config.getBool('warn_about_missing_settings'): return
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@nonl
#@-node:ekr.20051011103654:checkBindings
#@+node:ekr.20051008152134:initSpecialIvars
def initSpecialIvars (self):
    
    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = c.config.getBool('trace_bindings')
    warn  = c.config.getBool('warn_about_missing_settings')
    
    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@nonl
#@-node:ekr.20051008152134:initSpecialIvars
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')
    
    # New in 4.4b3: use the global setting as a last resort.
    if encoding:
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@-node:ekr.20060321080150.6:Handled missing leoSettings.leo files more gracefully
#@+node:ekr.20060309132452:Converted all shortcuts to unicode
#@+node:ekr.20060324065958:What I did
@nocolor

- onBodyChanged now converts everything to unicode, either directly or by calling g.app.gui.getAllText.

- Replaced all calls to g.safeStringCompare by g.app.gui.getAllText which calls g.toUnicode.

- Converted all shortcuts to unicode in shortcutFromSetting (a.k.a strokeFromSetting)

- Removed g.safeStringCompare.  This function was a bad idea.

Important: Leo is supposed to convert all characters to unicode, so there should
never be a need for safeStringCompare. The proper way to avoid UnicodeError's is
to call g.toUnicode(s,g.app.tkEncoding).
#@nonl
#@-node:ekr.20060324065958:What I did
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding) # New in 4.4b3.
    newText = g.app.gui.getAllText(bodyCtrl) # New in 4.4b3: converts to unicode.
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        # g.trace('removeTrailing:',removeTrailing)
        g.trace('newText:',repr(newText))
        #g.trace('oldText:',repr(oldText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        << recolor the body >>
        if not c.changed: c.setChanged(True)
        << redraw the screen if necessary >>
#@nonl
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    ### elif g.safeStringCompare(old,new[-1]):
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@+node:ekr.20031218072017.4091:g.app.gui.getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text widget t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:g.app.gui.getAllText
#@+node:ekr.20060323194410:Found: g.safeStringCompare
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    ### elif g.safeStringCompare(old,new[-1]):
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    # g.trace('event',event,g.callers())
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name,repr(ch))
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
        # g.trace(removeTrailing)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20050920085536.65:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    special = keysym in (
        'Caps_Lock','Num_Lock','Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None

    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction (not used)
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@-node:ekr.20050920085536.65:masterCommand & helpers
#@-node:ekr.20060323194410:Found: g.safeStringCompare
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&','') # Allow '&' in names.
    
    bunchList = self.get(c,key,"shortcut")
    if bunchList:
        bunchList = [bunch for bunch in bunchList
            if bunch.val and bunch.val.lower() != 'none']
        return key,bunchList
    else:
        return key,[]
#@nonl
#@-node:ekr.20041117062717.14:getShortcut (config)
#@+node:ekr.20060128081317:shortcutFromSetting
def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip()
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting
#@nonl
#@+node:ekr.20060201065809:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
#@nonl
#@-node:ekr.20060201065809:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20060215104239:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@nonl
#@-node:ekr.20060215104239:<< swap cmd and ctrl keys >>
#@+node:ekr.20060128103640.1:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@nonl
#@-node:ekr.20060128103640.1:<< convert minus signs to plus signs >>
#@+node:ekr.20060128103640.2:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)
#@nonl
#@-node:ekr.20060128103640.2:<< compute the last field >>
#@+node:ekr.20060128103640.4:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)
    
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@nonl
#@-node:ekr.20060128103640.4:<< compute shortcut >>
#@-node:ekr.20060128081317:shortcutFromSetting
#@-node:ekr.20060309132452:Converted all shortcuts to unicode
#@+node:ekr.20060306193910:Made Open With shortcuts work again
#@+node:ekr.20060324080104:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3607355
By: vpe

Alt-Ctrl-T shortcut for Open With external editor does not work in a7. Is it
possible to assign shortcuts to Open With items? I see that there is open-with
minibuffer command, but do not understand how to use it.
#@-node:ekr.20060324080104:Report
#@+node:ekr.20060216074643:k.completeAllBindings & helpers
def completeAllBindings (self):
    
    '''New in 4.4b3: make an actual binding in *all* the standard places.
    
    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    
    k = self ; c = k.c ; f = c.frame
    bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
    canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
    bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
    if not bodyCtrl or not canvas: return
    
    for w in (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget):
    
        self.completeAllBindingsForWidget(w)
#@+node:ekr.20060221141535:completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):
    
    k = self
    
    # g.trace('Return','Return' in k.bindingsDict.keys())
    
    for stroke in k.bindingsDict.keys():
        
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
            
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)
#@nonl
#@-node:ekr.20060221141535:completeAllBindingsForWidget
#@+node:ekr.20060324092758:completeOneBindingForWidget
def completeOneBindingForWidget (self,w,stroke,callback):

    k = self ; c = k.c

    try:
        bindStroke = k.tkbindingFromStroke(stroke)
        # g.trace(bindStroke,c.widget_name(w))
        w.bind(bindStroke,callback)

    except Exception:
        g.es_print('exception binding %s to %s' % (
            bindStroke, c.widget_name(w)), color = 'blue')
#@nonl
#@-node:ekr.20060324092758:completeOneBindingForWidget
#@-node:ekr.20060216074643:k.completeAllBindings & helpers
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        if not g.app.unitTesting and not not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@nonl
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20031218072017.4116:createOpenWithMenuFromTable & helper
@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
#@+node:ekr.20051022043608.1:createOpenWithMenuItemsFromTable
def createOpenWithMenuItemsFromTable (self,menu,table):
    
    '''Create an entry in the Open with Menu from the table.
    
    Each entry should be a sequence with 2 or 3 elements.'''
    
    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for data in table:
        << get label, accelerator & command or continue >>
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&")
        realLabel = realLabel.replace("&","")
        callback = self.defineOpenWithMenuCallback(openWithData)
    
        self.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
#@+node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
#@nonl
#@-node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
#@-node:ekr.20051022043608.1:createOpenWithMenuItemsFromTable
#@-node:ekr.20031218072017.4116:createOpenWithMenuFromTable & helper
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event,stroke):
    
    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    << handle per-pane bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(repr(stroke),'state',state)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        g.trace('No state dictionary for %s' % state)
    return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20051015110547:k.registerCommand
def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    # g.trace('leoCommands %24s = %s' % (func.__name__,commandName))
    
    if shortcut:
        stroke = k.shortcutFromSetting(shortcut)
        ok = k.bindKey (pane,stroke,func,commandName)
        k.registerBinding(shortcut)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(stroke)),color='blue')
    else:
        # New in 4.4b3: try to get a shortcut from leoSettings.leo.
        junk,bunchList = c.config.getShortcut(commandName)
        found = False
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                found = True
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,func,commandName)
                k.registerBinding(accel)
                if verbose:
                    g.es_print('Registered %s bound to %s' % (
                        commandName,k.prettyPrintKey(shortcut)),color='blue')
        if verbose and not found:
            g.es_print('Registered %s' % (commandName),color='blue')
#@+node:ekr.20060325110412:registerBinding
def registerBinding (self,shortcut):
    
    k = self ; f = k.c.frame

    # Duplicate the logic k.completeAllBindings to set the actual bindings.
    stroke = k.shortcutFromSetting(shortcut)
    # g.trace(stroke)
        
    def bindKeyCallback (event,k=k,stroke=stroke):
        return k.masterKeyHandler(event,stroke=stroke)
    
    for w in (f.body.bodyCtrl,f.tree.canvas,f.tree.bindingWidget):
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)
#@nonl
#@-node:ekr.20060325110412:registerBinding
#@-node:ekr.20051015110547:k.registerCommand
#@+node:ekr.20051006125633:Binding (keyHandler)
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    << give warning and return if there is a serious redefinition >>
    << trace bindings if enabled in leoSettings.leo >>
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = g.stripBrackets(shortcut.strip())
        # if shortcut.startswith('<Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility
#@nonl
#@+node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return
#@nonl
#@-node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
#@+node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)
#@nonl
#@-node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20060130093055:bindKeyToDict
def bindKeyToDict (self,pane,stroke,func,commandName):
    
    k = self
    d =  k.masterBindingsDict.get(pane,{})
    
    stroke = g.stripBrackets(stroke)
    
    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__)) # ,len(d.keys()))

    if d.get(stroke):
        g.es('ignoring duplicate definition of %s to %s in %s' % (
            stroke,commandName,pane), color='blue')
    else:
        d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
        k.masterBindingsDict [pane] = d
#@nonl
#@-node:ekr.20060130093055:bindKeyToDict
#@+node:ekr.20051008135051.1:bindOpenWith
def bindOpenWith (self,shortcut,name,data):
    
    '''Register an open-with command.'''
    
    k = self ; c = k.c
    
    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,data=data):
        return c.openWith(data=data)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='text',verbose=False)
#@nonl
#@-node:ekr.20051008135051.1:bindOpenWith
#@+node:ekr.20051011103654:checkBindings
def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    if not c.config.getBool('warn_about_missing_settings'): return
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -> %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
#@nonl
#@-node:ekr.20051011103654:checkBindings
#@+node:ekr.20060216074643:k.completeAllBindings & helpers
def completeAllBindings (self):
    
    '''New in 4.4b3: make an actual binding in *all* the standard places.
    
    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    
    k = self ; c = k.c ; f = c.frame
    bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
    canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
    bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
    if not bodyCtrl or not canvas: return
    
    for w in (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget):
    
        self.completeAllBindingsForWidget(w)
#@+node:ekr.20060221141535:completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):
    
    k = self
    
    # g.trace('Return','Return' in k.bindingsDict.keys())
    
    for stroke in k.bindingsDict.keys():
        
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
            
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)
#@nonl
#@-node:ekr.20060221141535:completeAllBindingsForWidget
#@+node:ekr.20060324092758:completeOneBindingForWidget
def completeOneBindingForWidget (self,w,stroke,callback):

    k = self ; c = k.c

    try:
        bindStroke = k.tkbindingFromStroke(stroke)
        # g.trace(bindStroke,c.widget_name(w))
        w.bind(bindStroke,callback)

    except Exception:
        g.es_print('exception binding %s to %s' % (
            bindStroke, c.widget_name(w)), color = 'blue')
#@nonl
#@-node:ekr.20060324092758:completeOneBindingForWidget
#@-node:ekr.20060216074643:k.completeAllBindings & helpers
#@+node:ekr.20051007080058:k.makeAllBindings
def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()
#@nonl
#@-node:ekr.20051007080058:k.makeAllBindings
#@+node:ekr.20060104154937:addModeCommands
def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))
#@nonl
#@-node:ekr.20060104154937:addModeCommands
#@+node:ekr.20051008152134:initSpecialIvars
def initSpecialIvars (self):
    
    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = c.config.getBool('trace_bindings')
    warn  = c.config.getBool('warn_about_missing_settings')
    
    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
#@nonl
#@-node:ekr.20051008152134:initSpecialIvars
#@+node:ekr.20051008134059:makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)
#@nonl
#@-node:ekr.20051008134059:makeBindingsFromCommandsDict
#@-node:ekr.20051006125633:Binding (keyHandler)
#@-node:ekr.20060306193910:Made Open With shortcuts work again
#@+node:ekr.20060305110016:Made sure autocompleter and calltip text stick
g.
#@nonl
#@-node:ekr.20060305110016:Made sure autocompleter and calltip text stick
#@+node:ekr.20060213094300:Added call to g.enableIdleTimeHook to c.openWith
#@+node:ekr.20060213145539:The causes
@nocolor

1.  Both the vim and xemacs plugins require that open_with plugin be enabled.
    I changed the docstrings for each.

2.  The open_with plugin now explicitly calls g.enableIdleTimeHook.
    That is, the idle time hook is no longer enabled by default.
   
These were easy fixes to make.  A similar fix should be done for files opened from the Open With menu, but it's too late to do that for b2.
#@nonl
#@-node:ekr.20060213145539:The causes
#@+node:ekr.20060213144352:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3573148
By: yarkot

With the "latest" CVS snapshot. Do this:

[] Open LeoDocs.leo from the latest workspace;
[] Expand node "What's new in Leo 4.4" (I'll refer to this as the "parent");
[] Dbl-click parent (VIM opens text; text is single line: "@nocolor");
[] Add a second "@nocolor" line; write and save from VIM;
[] Leo view does not show line;
[] re-open w/ vim - vim shows new line;

[] Save;  add more text;  shows w/ vim, not in Leo; Apparently doesn't get save.
You can add a line in Leo, "This is a test", modify it in vim - "This was a
test", save vim, save Leo - close leo, re-open leo - the vim changes never got
saved.

Ok  - that's one.

Here's the second (same file, node, fresh session):

[] Open parent w/ vim (dbl-clk); opens ok;
[] open child "New commands not in legacy Leo" w/ vim; opens ok.
[] FAILS:  try to open first child: "Minibuffer-oriented find commands" - vim
doesn't open, status line flashes node name (once for each click it looks like),
and console window shows this:

open_in_vim: {'p': <pos 20987888 lvl: 1 [0] New commands not in legacy Leo>,
'c'
: Commander 25144936: u'C:\\Workspace\\Leo\\leo\\doc\\LeoDocs.leo', 'event':
<Tk
inter.Event instance at 0x0132BE90>, 'v': <pos 20987888 lvl: 1 [0] New commands
not in legacy Leo>}
#@nonl
#@-node:ekr.20060213144352:Report
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@nonl
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20060213094300:Added call to g.enableIdleTimeHook to c.openWith
#@+node:ekr.20060328150113.1:Set g.app.globalOpenDir in import/export commands
#@+node:ekr.20060328150113:setGlobalOpenDir
def setGlobalOpenDir (fileName):
    
    if fileName:
        g.app.globalOpenDir = g.os_path_dirname(fileName)
        # g.es('current directory: %s' %  g.app.globalOpenDir)
#@nonl
#@-node:ekr.20060328150113:setGlobalOpenDir
#@+node:ekr.20060328150113.2:Found: globalOpenDir 
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.globalOpenDir = None # The directory last used to open a file.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scanErrors = 0 # The number of errors seen by g.scanError.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.statsDict = {} # Statistics dict used by g.stat, g.clear_stats, g.print_stats.
    self.trace = False # True: enable debugging traces.
    self.trace_gc = False # defined in run()
    self.trace_gc_calls = False # defined in run()
    self.trace_gc_verbose = False # defined in run()
    self.trace_gc_inited = False
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")

    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.bodyWantsFocus()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@nonl
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20060212061804:runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    
    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)
#@nonl
#@-node:ekr.20060212061804:runOpenFileDialog
#@+node:ekr.20060212061804.1:runSaveFileDialog
def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir=g.app.globalOpenDir or g.os_path_abspath(os.getcwd()),

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)
#@nonl
#@-node:ekr.20060212061804.1:runSaveFileDialog
#@-node:ekr.20060328150113.2:Found: globalOpenDir 
#@+node:ekr.20031218072017.2849:Import&Export submenu
#@+node:ekr.20031218072017.2850:exportHeadlines
def exportHeadlines (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.exportHeadlines(fileName)

#@-node:ekr.20031218072017.2850:exportHeadlines
#@+node:ekr.20031218072017.2851:flattenOutline
def flattenOutline (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.flattenOutline(fileName)

#@-node:ekr.20031218072017.2851:flattenOutline
#@+node:ekr.20031218072017.2852:importAtRoot
def importAtRoot (self,event=None):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@root")
#@-node:ekr.20031218072017.2852:importAtRoot
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self,event=None):
    
    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand(names,"@file")
#@nonl
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.2854:importCWEBFiles
def importCWEBFiles (self,event=None):
    
    c = self
    
    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"cweb")
#@-node:ekr.20031218072017.2854:importCWEBFiles
#@+node:ekr.20031218072017.2855:importFlattenedOutline
def importFlattenedOutline (self,event=None):
    
    c = self
    
    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFlattenedOutline(names)
#@-node:ekr.20031218072017.2855:importFlattenedOutline
#@+node:ekr.20031218072017.2856:importNowebFiles
def importNowebFiles (self,event=None):
    
    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"noweb")
#@-node:ekr.20031218072017.2856:importNowebFiles
#@+node:ekr.20031218072017.2857:outlineToCWEB
def outlineToCWEB (self,event=None):
    
    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.outlineToWeb(fileName,"cweb")

#@-node:ekr.20031218072017.2857:outlineToCWEB
#@+node:ekr.20031218072017.2858:outlineToNoweb
def outlineToNoweb (self,event=None):
    
    c = self
    
    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName

#@-node:ekr.20031218072017.2858:outlineToNoweb
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self,event=None):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)
#@nonl
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.2860:weave
def weave (self,event=None):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        g.setGlobalOpenDir(fileName)
        c.importCommands.weave(fileName)
#@-node:ekr.20031218072017.2860:weave
#@-node:ekr.20031218072017.2849:Import&Export submenu
#@-node:ekr.20060328150113.1:Set g.app.globalOpenDir in import/export commands
#@+node:ekr.20060227125713:Investigated colorizer problems: can not reproduce
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3585710
By: e

sometimes it seems to happen no matter what.
here are two (I hope) repeatable cases.

happens if the previous line has a comment or string
@language python
some=expr #trailing comment
another line
copy then paste 'another line' line
it colorized like a comment, or all one color.
a sure way to fix it is goto another node then back.
it won't naturally resynch by itself 
even if you goto end of body and back.

after that,
cut something inside next line after a comment same thing.
similar problem if previous line ends in a string.
same if cut/paste and trailing comment is on the same line.
undo restores the previous coloring, correct or not.
its been this way since early 4.4alpha I think.
still using 4.4b1

the final color was comment color as I write this,
as I open a fresh Leo and repeat, its text color.
there may be more than one trigger to the problem.

I know its a tradeoff of constant colorizing runs vrs incremental update, its
not technically a new problem, but this seems way buggier.

@color
#@nonl
#@-node:ekr.20060227125713:Investigated colorizer problems: can not reproduce
#@+node:ekr.20060325073234:Removed support for @ifgui: it doesn't and can't work
@nocolor

Alas, @if-gui can't be made to work. The problem is that plugins can set
g.app.gui, but plugins need settings so the leoSettings.leo files must be parsed
before g.app.gui.guiName() is known.
#@nonl
#@-node:ekr.20060325073234:Removed support for @ifgui: it doesn't and can't work
#@+node:ekr.20060325122134.1:Removed autocompletion for self
# It's not ready for prime time.
#@nonl
#@-node:ekr.20060325122134.1:Removed autocompletion for self
#@+node:ekr.20060414065810:Fixed minor problems reported by Pychecker
# No change for now
C:\prog\tigris-cvs\leo\src\leoKeys.py:1050: Parameter (thread) not used

# Fixed
C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py:1428: Function returns a value and also implicitly returns None
C:\prog\tigris-cvs\leo\src\leoTkinterTree.py:1222: Local variable (delta) not used
C:\prog\tigris-cvs\leo\src\leoKeys.py:1931: Local variable (f) not used
C:\prog\tigris-cvs\leo\src\leoGlobals.py:5246: Local variable (buttonList) not used
C:\prog\tigris-cvs\leo\src\leoCommands.py:493: No global (enableIdleTimeHook) found
#@nonl
#@-node:ekr.20060414065810:Fixed minor problems reported by Pychecker
#@+node:ekr.20060411101844:Fixed failed unit tests
leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\unitTest.leo
rst3 plugin: SilverCity not loaded
Registered unit-test-command1
found  3 doctests for leoGlobals
found  1 doctests for leoTest
found  5 test routines for leoAtFile
found  4 test routines for leoEditCommands
found  1 test routine for leoFileCommands
found 14 test routines for leoGlobals
EKR: reportlab.__init__
found  5 test routines for multifile
..F.
End of doctests
..........OSError: [Errno 2] No such file or directory: 'xyzzy'

......
test of es_print: 
.es_trace:
test of es_trace: 
........
End of test routines
..leoID = ekr (in c:\Documents and Settings\Ed)
leoID = ekr (in c:\Documents and Settings\Ed)
...............................................Registered test-registerCommand bound to <Alt+Ctrl+Shift+Z>
...............................
End of new find tests
.............................................
End of tests of @file nodes
.................................
End of general unit tests
....
End of commands tests
.............................F..........................................................................................
..................
opening a new window to test more plugin logic

.........................................................................................................
======================================================================
FAIL: Doctest: leoGlobals.mulderUpdateAlgorithm.stripWhitespaceFromBlankLines
----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\python24\lib\doctest.py", line 2152, in runTest
    raise self.failureException(self.format_failure(new.getvalue()))
AssertionError: Failed doctest test for leoGlobals.mulderUpdateAlgorithm.stripWhitespaceFromBlankLines
  File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 4774, in stripWhitespaceFromBlankLines

----------------------------------------------------------------------
File "c:\prog\tigris-cvs\leo\src\leoGlobals.py", line 4782, in leoGlobals.mulderUpdateAlgorithm.stripWhitespaceFromBlank
Lines
Failed example:
    g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
Expected:
    ['a\n', '\n', '\n', 'b']
Got:
    ['a\n', '', '', 'b']


======================================================================
FAIL: @test line endings of Linux scripts

----------------------------------------------------------------------
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoTest.py", line 155, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "<string>", line 20, in ?
  File "<string>", line 14, in checkLinuxLineEndings
AssertionError: Bad Linux line ending in C:\prog\tigris-cvs\leo\src\..\install: cr: 156, nl: 156

----------------------------------------------------------------------
Ran 434 tests in 179.829s

FAILED (failures=2)
>>>
#@nonl
#@+node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
def stripWhitespaceFromBlankLines (self,lines):
    
    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.
    
    >>> import leoGlobals as g
    >>> s = "a\\n \\t\\n\\t\\t \\t\\nb"
    >>> theLines = g.splitLines(s)
    >>> theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    >>> g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        # stripped_line = lines[i].lstrip(" \t") # lstrip does not exist in python 2.2.1.
        stripped_line = lines[i]
        while stripped_line and stripped_line[0] in (' ','\t'):
            stripped_line = stripped_line [1:]
        if stripped_line in ('\n',''):
            lines[i] = stripped_line
            
    return lines
#@nonl
#@-node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
#@-node:ekr.20060411101844:Fixed failed unit tests
#@+node:ekr.20060408065447:newline problem on MacOS
#@+node:ekr.20050920084036.138:insertNewLine
def insertNewLine (self,event):

    w = event.widget
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('head'):
        self.beginCommand(undoType='insert-newline')
        w.insert('insert','\n')
        self.endCommand(changed=True,setLabel=False)

insertNewline = insertNewLine
#@nonl
#@-node:ekr.20050920084036.138:insertNewLine
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    # g.trace('event',event,g.callers())
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name,repr(ch))
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
        # g.trace(removeTrailing)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20060415075830:Found: selfInsertCommand
#@+node:ekr.20051026083544:handleDefaultChar
def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@nonl
#@-node:ekr.20051026083544:handleDefaultChar
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c ; k = self.k

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from lines':              self.removeSpaceFromLines,
        'remove-tab-from lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    # g.trace('event',event,g.callers())
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name,repr(ch))
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
        # g.trace(removeTrailing)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@+node:ekr.20060415080442:Creating events
#@+node:ekr.20051106040126:c.executeMinibufferCommand
def executeMinibufferCommand (self,commandName):
    
    c = self ; k = c.k
    
    func = c.commandsDict.get(commandName)
    
    if func:
        event = g.Bunch(char='',keysym=None,widget=c.frame.body.bodyCtrl)
        stroke = None
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.trace('no such command: %s' % (commandName),color='red')
        return None
#@nonl
#@-node:ekr.20051106040126:c.executeMinibufferCommand
#@+node:ekr.20031218072017.4117:defineMenuCallback
def defineMenuCallback(self,command,name,minibufferCommand):
    
    if minibufferCommand:
        
        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')
        
        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label,event)
    
        return minibufferMenuCallback
        
    else:
    
        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label)
    
        return legacyMenuCallback
#@nonl
#@-node:ekr.20031218072017.4117:defineMenuCallback
#@+node:ekr.20051105155441:simulateCommand
def simulateCommand (self,commandName):
    
    k = self ; c = k.c
    
    func = c.commandsDict.get(commandName)
    
    if func:
        # g.trace(commandName,func.__name__)
        stroke = None
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.bunch(keysym = '',char = '',widget = None)
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.trace('no command for %s' % (commandName),color='red')
        if g.app.unitTesting:
            raise AttributeError
        else:
            return None
#@nonl
#@-node:ekr.20051105155441:simulateCommand
#@+node:ekr.20060128090219:masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    # g.trace(c.widget_name(w))
    
    if stroke: # New in 4.4a6:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
#@nonl
#@-node:ekr.20060128090219:masterMenuHandler
#@-node:ekr.20060415080442:Creating events
#@+node:ekr.20060221141535:completeAllBindingsForWidget
def completeAllBindingsForWidget (self,w):
    
    k = self
    
    # g.trace('Return','Return' in k.bindingsDict.keys())
    
    for stroke in k.bindingsDict.keys():
        
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
            
        k.completeOneBindingForWidget(w,stroke,bindKeyCallback)
#@nonl
#@-node:ekr.20060221141535:completeAllBindingsForWidget
#@-node:ekr.20060415075830:Found: selfInsertCommand
#@-node:ekr.20060408065447:newline problem on MacOS
#@+node:ekr.20060408093907:Fixed Crash after undoing clearRecentFiles command
#@+node:ekr.20060411135857:Trace
exception executing command
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 884, in clearRecentFiles
    u.afterClearRecentFiles(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 621, in afterClearRecentFiles
    u.pushBead(bunch)
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 192, in pushBead
    u.setUndoTypes()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 341, in setUndoTypes
    u.cutStack()
  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 136, in cutStack
    if bunch.kind == 'beforeGroup':
AttributeError: 'Bunch' object has no attribute 'kind'
#@-node:ekr.20060411135857:Trace
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):
    
    u = self ; n = u.max_undo_stack_size

    if n > 0 and u.bead >= n and not g.app.unitTesting:
        
        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i >= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))
#@nonl
#@-node:ekr.20060127052111.1:cutStack
#@-node:ekr.20060408093907:Fixed Crash after undoing clearRecentFiles command
#@+node:ekr.20060410112600.1:Fixed crash in string.startswith and string.endswith
leoID = ekr (in c:\Documents and Settings\Ed)
reading settings in C:\prog\leoCVS\leo\config\leoSettings.leo
reading settings in C:\prog\leoCVS\leo\src\LeoPy.leo
rst3 plugin: SilverCity not loaded
AttributeError Exception in Tk callback
  Function: <function bindKeyCallback at 0x016F2E70> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x03510288>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2002, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2928, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2992, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2219, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 348, in autoCompleterStateHandler
    self.insertNormalChar(ch,keysym)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 856, in insertNormalChar
    self.calltip(obj)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 455, in calltip
    obj = getattr(string,obj.__name__)
AttributeError: 'module' object has no attribute 'startswith'

================================================
  Event contents:
    char: (
    delta: 57
    height: ??
    keycode: 57
    keysym: parenleft
    keysym_num: 40
    num: ??
    serial: 120644
    state: 1
    time: 16118166
    type: 2
    widget: .20658096.20658616.23344872.23344992.body-pane
    width: ??
    x: 562
    x_root: 740
    y: 38
    y_root: 732

selfInsertCommand: '\n'
selfInsertCommand: '\n'
AttributeError Exception in Tk callback
  Function: <function bindKeyCallback at 0x016F2E70> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x03289C88>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2002, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2928, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2992, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 2219, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 348, in autoCompleterStateHandler
    self.insertNormalChar(ch,keysym)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 856, in insertNormalChar
    self.calltip(obj)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 455, in calltip
    obj = getattr(string,obj.__name__)
AttributeError: 'module' object has no attribute 'endswith'

================================================
  Event contents:
    char: (
    delta: 57
    height: ??
    keycode: 57
    keysym: parenleft
    keysym_num: 40
    num: ??
    serial: 123470
    state: 1
    time: 16173496
    type: 2
    widget: .20658096.20658616.23344872.23344992.body-pane
    width: ??
    x: 324
    x_root: 502
    y: 95
    y_root: 789

#@+node:ekr.20060220110302:calltip
def calltip (self,obj=None):
    
    c = self.c ; w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>
        
    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    s = s.rstrip(')') # Convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, restoring the selection.
    self.finish()
    c.widgetWantsFocusNow(w)
    g.app.gui.setSelectionRange(w,j1,j2,insert=j2)
    << put the status line >>
#@+node:ekr.20060224103829:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    s = s and s.strip() or ''
#@nonl
#@-node:ekr.20060224103829:<< try to set s from a Python global function >>
#@+node:ekr.20060224103829.1:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@nonl
#@-node:ekr.20060224103829.1:<< get s using inspect >>
#@+node:ekr.20060224103829.2:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@nonl
#@-node:ekr.20060224103829.2:<< remove 'self' from s, but not from args >>
#@+node:ekr.20060224103829.3:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@nonl
#@-node:ekr.20060224103829.3:<< remove 's' from s *and* args >>
#@+node:ekr.20060224103829.4:<< insert the text and set j1 and j2 >>
if g.app.gui.hasSelection(w):
    i,j = g.app.gui.getSelectionRange(w)
else:
    i = j = g.app.gui.getInsertPoint(w)
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')

if 1:
    j1 = w.index('%s + 1c' % j)
    j2 = w.index('%s + %sc' % (j,len(s)))
else:
    j1 = j2 = w.index('%s + 2c' % j)
#@nonl
#@-node:ekr.20060224103829.4:<< insert the text and set j1 and j2 >>
#@+node:ekr.20060224103829.5:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@nonl
#@-node:ekr.20060224103829.5:<< put the status line >>
#@-node:ekr.20060220110302:calltip
#@-node:ekr.20060410112600.1:Fixed crash in string.startswith and string.endswith
#@+node:ekr.20060410091659:Removed lstrip and rstrip for compatibility with Python 2.2.1
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3671350

Change aString.lstrip and aString.rstrip to the aString.replace.
@color
#@nonl
#@+node:ekr.20060410112600:g.stripBrackets
def stripBrackets (s):
    
    '''Same as s.lstrip('<').rstrip('>') except it works for Python 2.2.1.'''
    
    if s.startswith('<'):
        s = s[1:]
    if s.endswith('>'):
        s = s[:-1]
    return s
#@nonl
#@-node:ekr.20060410112600:g.stripBrackets
#@+node:ekr.20060410104419:Found: lstrip
#@+node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
def stripWhitespaceFromBlankLines (self,lines):
    
    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.
    
    >>> import leoGlobals as g
    >>> s = "a\\n \\t\\n\\t\\t \\t\\nb"
    >>> theLines = g.splitLines(s)
    >>> theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    >>> g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        # stripped_line = lines[i].lstrip(" \t") # lstrip does not exist in python 2.2.1.
        stripped_line = lines[i]
        while stripped_line and stripped_line[0] in (' ','\t'):
            stripped_line = stripped_line [1:]
        if stripped_line in ('\n',''):
            lines[i] = stripped_line
            
    return lines
#@nonl
#@-node:ekr.20040718101315:stripWhitespaceFromBlankLines(before_lines)
#@+node:ekr.20031218072017.3315:skipLeadingComments
def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        << scan for C-style comments >>
    elif self.fileType == ".lua":
        << scan for Lua comments >>
    elif self.fileType == ".pas":
        << scan for Pascal comments >>
    elif self.fileType == ".py":
        << scan for Python comments >>
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
#@nonl
#@+node:ekr.20031218072017.3316:<< scan for C-style comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@nonl
#@-node:ekr.20031218072017.3316:<< scan for C-style comments >>
#@+node:ekr.20060328112327.1:<< scan for Lua comments >>
while i < len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@nonl
#@-node:ekr.20060328112327.1:<< scan for Lua comments >>
#@+node:ekr.20031218072017.3317:<< scan for Pascal comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@nonl
#@-node:ekr.20031218072017.3317:<< scan for Pascal comments >>
#@+node:ekr.20031218072017.3318:<< scan for Python comments >>
while i < len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
#@nonl
#@-node:ekr.20031218072017.3318:<< scan for Python comments >>
#@-node:ekr.20031218072017.3315:skipLeadingComments
#@+node:ekr.20031218072017.3637:compare_lines
def compare_lines (self,s1,s2):
    
    if self.ignoreLeadingWhitespace:
        s1 = s1.lstrip()
        s2 = s2.lstrip()

    if self.ignoreInteriorWhitespace:
        k1 = g.skip_ws(s1,0)
        k2 = g.skip_ws(s2,0)
        ws1 = s1[:k1]
        ws2 = s2[:k2]
        tail1 = s1[k1:]
        tail2 = s2[k2:]
        tail1 = string.replace(tail1," ","")
        tail1 = string.replace(tail1,"\t","")
        tail2 = string.replace(tail2," ","")
        tail2 = string.replace(tail2,"\t","")
        s1 = ws1 + tail1
        s2 = ws2 + tail2

    return s1 == s2
#@nonl
#@-node:ekr.20031218072017.3637:compare_lines
#@+node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
#@nonl
#@-node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        if not g.app.unitTesting and not not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@nonl
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    << give warning and return if there is a serious redefinition >>
    << trace bindings if enabled in leoSettings.leo >>
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = g.stripBrackets(shortcut.strip())
        # if shortcut.startswith('<Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility
#@nonl
#@+node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return
#@nonl
#@-node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
#@+node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)
#@nonl
#@-node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20060130093055:bindKeyToDict
def bindKeyToDict (self,pane,stroke,func,commandName):
    
    k = self
    d =  k.masterBindingsDict.get(pane,{})
    
    stroke = g.stripBrackets(stroke)
    
    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__)) # ,len(d.keys()))

    if d.get(stroke):
        g.es('ignoring duplicate definition of %s to %s in %s' % (
            stroke,commandName,pane), color='blue')
    else:
        d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
        k.masterBindingsDict [pane] = d
#@nonl
#@-node:ekr.20060130093055:bindKeyToDict
#@+node:ekr.20060131075440:k.tkbindingFromStroke
def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    return '<%s>' % stroke
#@nonl
#@-node:ekr.20060131075440:k.tkbindingFromStroke
#@+node:ekr.20060201083154:k.prettyPrintKey
def prettyPrintKey (self,stroke):
    
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '<%s>' % s
#@nonl
#@-node:ekr.20060201083154:k.prettyPrintKey
#@+node:ekr.20050920085536.75:executeNTimes
def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'<%s>' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('<Key>',keycode=event.keycode,keysym=event.keysym)
#@nonl
#@-node:ekr.20050920085536.75:executeNTimes
#@+node:ekr.20050920085536.76:doControlU
def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@nonl
#@-node:ekr.20050920085536.76:doControlU
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.strip()
    if txt:
        self.beginCommand(undoType='fill-paragraph')
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.strip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.strip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )
        self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.98:killParagraph (Test)
def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')
    
    self.beginCommand(undoType='kill-paragraph')

    if not txt.strip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')
    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.98:killParagraph (Test)
#@+node:ekr.20050920084036.96:selectParagraph & helper
def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break
#@nonl
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.strip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)
#@nonl
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:selectParagraph & helper
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.strip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)
#@nonl
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@+node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) > 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('<Key>')
        ### w.update_idletasks()
    self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
#@+node:ekr.20050920084036.203:_executeMacro (revise)
def _executeMacro (self,macro,w):

    k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('<Key>',keycode=z[0],keysym=z[1])
        else:
            meth = g.stripBrackets(z [0])
            bunchList = k.bindingsDict.get(meth,[])  ### Probably should not strip < and >
            if bunchList:
                b = bunchList[0]
                ev = Tk.Event()
                ev.widget = w
                ev.keycode = z [1]
                ev.keysym = z [2]
                ev.char = z [3]
                k.masterCommand(ev,b.f,'<%s>' % meth)
#@nonl
#@-node:ekr.20050920084036.203:_executeMacro (revise)
#@-node:ekr.20060410104419:Found: lstrip
#@+node:ekr.20060410112600.2:Found: rstrip
#@+node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        accelerator = k.shortcutFromSetting(accelerator)
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data
#@nonl
#@-node:ekr.20051022043713.1:<< get label, accelerator & command or continue >>
#@+node:ekr.20031218072017.1723:createMenuEntries
def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        << get label & command or continue >>
        << compute commandName & accel from label & command >>
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and g.stripBrackets(k.prettyPrintKey(accelerator))
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        if sys.platform == 'darwin':
            << clear accelerator if it is a plain key >>
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)
#@nonl
#@+node:ekr.20051021091958:<< get label & command or continue >>
ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.
#@nonl
#@-node:ekr.20051021091958:<< get label & command or continue >>
#@+node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
# New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        if not g.app.unitTesting and not not dynamicMenu:
            # Don't warn during unit testing.
            # This may come from a plugin that normally isn't enabled.
            g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        << compute emacs_name >>
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
#@nonl
#@+node:ekr.20051021100806.1:<< compute emacs_name >>
@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None
#@nonl
#@-node:ekr.20051021100806.1:<< compute emacs_name >>
#@-node:ekr.20031218072017.1725:<< compute commandName & accel from label & command >>
#@+node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''
#@nonl
#@-node:ekr.20060216110502:<< clear accelerator if it is a plain key >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    << give warning and return if there is a serious redefinition >>
    << trace bindings if enabled in leoSettings.leo >>
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = g.stripBrackets(shortcut.strip())
        # if shortcut.startswith('<Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility
#@nonl
#@+node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return
#@nonl
#@-node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
#@+node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)
#@nonl
#@-node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20060130093055:bindKeyToDict
def bindKeyToDict (self,pane,stroke,func,commandName):
    
    k = self
    d =  k.masterBindingsDict.get(pane,{})
    
    stroke = g.stripBrackets(stroke)
    
    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__)) # ,len(d.keys()))

    if d.get(stroke):
        g.es('ignoring duplicate definition of %s to %s in %s' % (
            stroke,commandName,pane), color='blue')
    else:
        d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
        k.masterBindingsDict [pane] = d
#@nonl
#@-node:ekr.20060130093055:bindKeyToDict
#@+node:ekr.20060131075440:k.tkbindingFromStroke
def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    return '<%s>' % stroke
#@nonl
#@-node:ekr.20060131075440:k.tkbindingFromStroke
#@+node:ekr.20060201083154:k.prettyPrintKey
def prettyPrintKey (self,stroke):
    
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '<%s>' % s
#@nonl
#@-node:ekr.20060201083154:k.prettyPrintKey
#@+node:ekr.20050920085536.75:executeNTimes
def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'<%s>' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('<Key>',keycode=event.keycode,keysym=event.keysym)
#@nonl
#@-node:ekr.20050920085536.75:executeNTimes
#@+node:ekr.20050920085536.76:doControlU
def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@nonl
#@-node:ekr.20050920085536.76:doControlU
#@+node:ekr.20050920084036.203:_executeMacro (revise)
def _executeMacro (self,macro,w):

    k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('<Key>',keycode=z[0],keysym=z[1])
        else:
            meth = g.stripBrackets(z [0])
            bunchList = k.bindingsDict.get(meth,[])  ### Probably should not strip < and >
            if bunchList:
                b = bunchList[0]
                ev = Tk.Event()
                ev.widget = w
                ev.keycode = z [1]
                ev.keysym = z [2]
                ev.char = z [3]
                k.masterCommand(ev,b.f,'<%s>' % meth)
#@nonl
#@-node:ekr.20050920084036.203:_executeMacro (revise)
#@-node:ekr.20060410112600.2:Found: rstrip
#@-node:ekr.20060410091659:Removed lstrip and rstrip for compatibility with Python 2.2.1
#@+node:ekr.20060329090924:Rewrote g.importExtension to simplify startup logic
#@+node:ekr.20041219071407:g.importExtension & helpers
def importExtension (moduleName,pluginName=None,verbose=False,required=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)
            
        if not module and required:
            g.cantImportDialog(pluginName,moduleName)
            try: # Avoid raising SystemExit if possible.
                import os ; os._exit(1) # May not be available on all platforms.
            except Exception:
                import sys ; sys.exit(1)

    return module
#@nonl
#@+node:ekr.20060329083657:cantImportDialog & helpers
def cantImportDialog (pluginName,moduleName):
    
    message = '''
%s requires the %s module.
Official distributions contain this module in Leo's extensions folder,
but this module may be missing if you get Leo from cvs.
''' % (pluginName,moduleName)

    if 1: # Requires minimal further imports.
        try:
            import Tkinter as Tk
            root = g.app.root or Tk.Tk()
            title = 'Can not import %s' % moduleName
            top = createDialogFrame(Tk,root,title,message)
            root.wait_window(top)
        except ImportError:
            print 'Can not import %s' % moduleName
            print 'Can not import Tkinter'
            print 'Leo must now exit'
        
    else: # Can cause import problems during startup.
        import leoTkinterDialog
        
        d = leoTkinterDialog.tkinterAskOk(
            c=None,title='Can not import %s' %(moduleName),
            message=message)
        d.run(modal=True)
#@nonl
#@+node:ekr.20060329083310.1:createDialogFrame
def createDialogFrame(Tk,root,title,message):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    top = Tk.Toplevel(root)
    top.title(title)

    def onKey(event,top=top):
        if event.char.lower() in ('\n','\r'):
            top.destroy()
    top.bind("<Key>",onKey)

    f = Tk.Frame(top)
    f.pack(side="top",expand=1,fill="both")
    
    label = Tk.Label(f,text=message)
    label.pack(pady=10)
    
    def okButton(top=top):
        top.destroy()
    
    buttons = {"text":'OK',"command":okButton,"default":True}, # Singleton tuple.
    createDialogButtons(Tk,top,buttons)
    
    center(top)
    top.lift()
    top.focus_force()
    
    # Attach the icon at idle time.
    def attachIconCallback(top=top):
        g.app.gui.attachLeoIcon(top)
    top.after_idle(attachIconCallback)

    return top
#@nonl
#@-node:ekr.20060329083310.1:createDialogFrame
#@+node:ekr.20060329083310.2:createDialogButtons
def createDialogButtons (Tk,top,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    f = Tk.Frame(top)
    f.pack(side="top",padx=30)

    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
#@nonl
#@-node:ekr.20060329083310.2:createDialogButtons
#@+node:ekr.20060329085417.1:center
def center(top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20060329085417.1:center
#@+node:ekr.20060329085612:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20060329085612:get_window_info
#@-node:ekr.20060329083657:cantImportDialog & helpers
#@-node:ekr.20041219071407:g.importExtension & helpers
#@-node:ekr.20060329090924:Rewrote g.importExtension to simplify startup logic
#@-node:ekr.20060323131536.1:Bugs
#@+node:ekr.20060323140748:Plugins
#@+node:ekr.20060301182319:Support for chapters plugin
#@+node:ekr.20060306030946.1:Event handling for multiple editors
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding) # New in 4.4b3.
    newText = g.app.gui.getAllText(bodyCtrl) # New in 4.4b3: converts to unicode.
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        # g.trace('removeTrailing:',removeTrailing)
        g.trace('newText:',repr(newText))
        #g.trace('oldText:',repr(oldText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        << recolor the body >>
        if not c.changed: c.setChanged(True)
        << redraw the screen if necessary >>
#@nonl
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@+node:ekr.20051026143009:removeTrailingNewlines
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    ### elif g.safeStringCompare(old,new[-1]):
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True
#@nonl
#@-node:ekr.20051026143009:removeTrailingNewlines
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody) & removeTrailingNewlines
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event,stroke):
    
    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    << handle per-pane bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace(repr(stroke),'state',state)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        g.trace('No state dictionary for %s' % state)
    return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20060129052538.2:masterClickHandler
def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol <= xcol <= jcol)
        if icol <= xcol <= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else: return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
#@nonl
#@-node:ekr.20060129052538.2:masterClickHandler
#@-node:ekr.20060306030946.1:Event handling for multiple editors
#@+node:ekr.20060306070502:Find
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    # g.trace(id(t),pos,newpos)
    c.widgetWantsFocusNow(t)
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    # c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20060306070502:Find
#@+node:ekr.20060306103239:Problems with unit testing
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):

    # pageName is not used here: it is used for compatibility with the Chapters plugin.

    c = self.c

    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    trace = self.c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace(canvas)
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 0:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@+node:ekr.20041221071131:createPmwTreeCanvas (not used)
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
 
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas (not used)
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20051104075904.42:leoTest.runLeoTest
def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    try:
        g.app.unitTesting = True
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            g.app.closeLeoWindow(frame.c.frame)
        c.frame.top.update()
        g.app.unitTesting = False

    if not ok: raise
#@nonl
#@-node:ekr.20051104075904.42:leoTest.runLeoTest
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.4121:setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    try:
        if type(name) == type(0):
            # "name" is actually an index into the menu.
            menu.entryconfig(name,label=label,underline=underline)
        else:
            # Bug fix: 2/16/03: use translated name.
            realName = self.getRealMenuName(name)
            realName = realName.replace("&","")
            # Bug fix: 3/25/03" use tranlasted label.
            label = self.getRealMenuName(label)
            label = label.replace("&","")
            menu.entryconfig(realName,label=label,underline=underline)
    except:
        if not g.app.unitTesting:
            print "setMenuLabel menu,name,label:",menu,name,label
            g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4121:setMenuLabel
#@-node:ekr.20060306103239:Problems with unit testing
#@+node:ekr.20060306030946:Drawing
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        self.redrawCount += 1
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())
        
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)

    if self.trace_stats: self.showStats()
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    # g.trace(x,y,p,id(self.canvas))
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        theActualFile = None
        if not toString:
            << create backup file >>
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        if not toString:
            theActualFile = open(fileName, 'wb')
        << put the .leo file >>
        s = self.outputFile.getvalue()
        if toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            << delete backup file >>
        self.outputFile = None
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        << delete fileName >>
        << rename backupName to fileName >>
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@nonl
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
#@nonl
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20031218072017.2950:c.begin/endUpdate
@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
#@-node:ekr.20031218072017.2950:c.begin/endUpdate
#@+node:ekr.20031218072017.2954:c.redraw and c.redraw_now
def redraw (self):
    c = self
    c.beginUpdate()
    c.endUpdate()

def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw and c.redraw_now
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())
    
def endUpdate (self,flag,scroll=False):
    
    self.updateCount -= 1
    # g.trace('  tree',id(self),self.updateCount,g.callers())
    
    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount",g.callers())
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:redraw_now & helper
#@-node:ekr.20060306030946:Drawing
#@+node:ekr.20060306130654:Selecting
#@+node:ekr.20040803072955.128:tree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('does not exist',p.headString())
        return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20040803140033.1:setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position."""
    
    c = self
    
    if p:
        if p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
    else:
        c._currentPosition = None
    
# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:setCurrentPosition
#@+node:ekr.20040803072955.136:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, disabled

    # g.trace(p.headString(),g.callers())

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.136:setSelectedLabelState
#@+node:ekr.20040803072955.85:configureTextState
def configureTextState (self,p):
    
    if not p: return
    
    # g.trace(p.headString(),self.c._currentPosition)
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20040803072955.85:configureTextState
#@+node:ekr.20040803112450:c.isCurrentPosition
def isCurrentPosition (self,p):
    
    c = self
    
    if p is None or c._currentPosition is None:
        return False
    else:
        return p.isEqual(c._currentPosition)
#@nonl
#@-node:ekr.20040803112450:c.isCurrentPosition
#@-node:ekr.20060306130654:Selecting
#@+node:ekr.20040307104131.3:p.exists
def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p.headString(),'parent',p.parent(),'back',p.back())
        if p.equal(root):
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    # g.trace('does not exist in root:',root.headString())
    return False
#@nonl
#@-node:ekr.20040307104131.3:p.exists
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight (self,event=None):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasBack: return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True): return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # g.trace(p,p.parent())
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20040303175026.11:p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        if not parent.equal(c.rootPosition()):
            # g.trace('old root',c.rootPosition(),'new root',parent())
            c.setRootPosition(parent)

    return p
#@-node:ekr.20040303175026.11:p.moveToNthChildOf
#@+node:ekr.20040803140033.3:setRootPosition
def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    if p:
        if p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
    
# For compatibiility with old scripts.
setRootVnode = setRootPosition
#@nonl
#@-node:ekr.20040803140033.3:setRootPosition
#@+node:ekr.20040310062332.3:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n,parent.v)

    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.3:p.linkAsNthChild
#@-node:ekr.20060301182319:Support for chapters plugin
#@+node:ekr.20060319155125:Changed path to stylesheet in the rst3 plugin
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3637393
By: nobody

Leo 4.4 a7, build  1.417 (under Linux)

Using rst3 to generate LaTex

Hi,

I'm trying to set up a default stylesheet for a project and want this to be
held relative to the project directory (where the .leo file is). The default
is to place it in the same directory as the output, which is a couple of levels
down.

setting stylesheet_path = . or empty does not work. I seem to have to specify
an absolute path, which is not helpful when sharing developmnent through cvs.

Am I missing something?

Mike S.
#@nonl
#@+node:ekr.20060320071608:proposed revision
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3639216
By: nobody

I looked at the code myself. I have changed rst3.py line 1213 to replace
g.os_path_dirname(self.outputFileName) with self.c.frame.openDirectory. This
makes the path relative to the project. Not 100% as the stylesheet filename
would need a path embedded in it to move the location down the tree. However,
it is consistent with the way the output file is named.
#@-node:ekr.20060320071608:proposed revision
#@-node:ekr.20060319155125:Changed path to stylesheet in the rst3 plugin
#@+node:ekr.20060319103111:Fixed problems with chapters plugin
#@+node:ekr.20060319103111.1:Report 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3626542

v .203 EKR:
- Chapter.makeCurrent now calls self.rp.v.linkAsRoot to properly anchor the root node.
  This was the cause of the move-outline-right problems.
By: tfer

Just playing with the chapters plug-in under a CVS download and ran into odd
behavior.  I was playing with putting Dive into Python" into chapters.  inserted
a new chapter (2), named the node "Your first Python Program", cntrl-i for insert
new node, cntrl-r  to move right.
(1st odd thing:), node collapsed under chapter title.
(2nd odd thing:) I can't select the "NewHeading" via mouse (chapter name  node remains selected)
trying same by keyboard (alt-dwnArrow, cntrl-h),
changes the body pane "location line" to "NewHeading", but in outline pane chapter
title node reamains selected,  and I can't edit the NewHeading node name.

Only thing I'm leaving out is alt-tabbing to scintila to cut and paste teaxt to nodes/body.

Tom
#@-node:ekr.20060319103111.1:Report 1
#@+node:ekr.20060319103111.2:Report 2
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3629055
By: tfer

Saved out the troubled outline, did a update via CVS, adn the outline seems
to be behaving itself now.  Need to test more to be sure.  The problem seems
to start when you move a node via cntrl-r.

There seems to be a problem with @button w/chapters, opening a chpters doc with
an one does not add a button to button bar.

tom
#@-node:ekr.20060319103111.2:Report 2
#@+node:ekr.20060319103111.3:Report 3
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3632004
By: tfer

Darn, bug still seems to be present.

1) Add & name new chapter
2) Insert a node (cntrl-i)
3) Move "NewNode" right (cntrl-r)

"NewNode" collapses into chapter name and selection box will not leave it.

Tom
#@-node:ekr.20060319103111.3:Report 3
#@-node:ekr.20060319103111:Fixed problems with chapters plugin
#@+node:ekr.20060310093345:Improved groupoperations plugin
@nocolor

Cleaned up the code and added support minibuffer commands:

group-operations-clear-marked       = Alt-Ctrl-Shift-l
group-operations-mark-for-copy      = Alt-Ctrl-Shift-c
group-operations-mark-for-move      = Alt-Ctrl-Shift-m
group-operations-mark-for-clone     = Alt-Ctrl-`
group-operations-mark-target        = Alt-Ctrl-Shift-t
group-operations-operate-on-marked  = Alt-Ctrl-Shift-o
group-operations-transfer           = Alt-Ctrl-Shift-d

This code has not been tested with the chapters2 plugin.
#@nonl
#@-node:ekr.20060310093345:Improved groupoperations plugin
#@+node:ekr.20060308103043:Fixed crasher in Word (and other) plugins
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3617936
By: nobody

I did a clean install of A7. I have the export to word plugin enabled. When
I try to export my outline to word I get the following:

Leo Log Window...
Leo 4.4 a7, build  1.417 , February 28, 2006
Python 2.3.5, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 2

reading: C:\Development\VL4\VL4 outline.leo
Trying to connect to Word
Writing tree to Word
Exception writing Word
Traceback (most recent call last):
  File "C:\Program Files\Leo\plugins\word_export.py", line 163, in cmd_Export
    "")
  File "C:\Program Files\Leo\plugins\word_export.py", line 122, in
writeNodeAndTree
    vnode = c.currentVnode()
AttributeError: 'Bunch' object has no attribute 'currentVnode'

The fix was to plugins_menu.py: the cmd_callback must have an event argument.
#@-node:ekr.20060308103043:Fixed crasher in Word (and other) plugins
#@+node:ekr.20060307142612:Fixed problem with labels plugin
@nocolor

I tried the Labels plugin, and got:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
TypeError: menu_add_label() takes exactly 1 argument (2 given)

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
TypeError: marks_to_label() takes exactly 1 argument (2 given)

--Rich

The fix: all menu commands now have event=None in their argument list.
#@nonl
#@-node:ekr.20060307142612:Fixed problem with labels plugin
#@-node:ekr.20060323140748:Plugins
#@-node:ekr.20060306070425:4.4 b3 projects
#@+node:ekr.20060414090519:4.4 b4 projects
#@+node:ekr.20060417092153:Bugs
#@+node:ekr.20060416104711.1:Investigated problems with legacy bindings
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3688804
By: paulpaterson

It seems that copying and pasting nodes with CTRL-SHIFT-C, V is not working.
- (legacy bindings)
- select a node
- CTRL-SHIFT-C
- CTRL-SHIFT-V
- Vim opens up! I expect to paste the node. The clipboard doesn't seem to contain
any XML
- The menu items show that these keys are bound to the copy and paste node
commands

*** Also on legacy bindings the arrow keys don't seem to move the cursor in the
body.
#@nonl
#@-node:ekr.20060416104711.1:Investigated problems with legacy bindings
#@+node:ekr.20060418120328:Fixed bug when cutting text in headline
#@+node:ekr.20060419075847:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3692247
By: vpe

After cutting selection in the headline, headline area shrinks too much.  Example:
headline is 'NewHeadline', select last 'e', ctrl-x, it shrinks to 'Ne'

To fix by hand: add

s=g.app.gui.getAllText(w)

Just before

w.configure(width=f.tree.headWidth(s=s))

in cutText in leoTkFrame.py
#@nonl
#@-node:ekr.20060419075847:Report
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@nonl
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s=g.app.gui.getAllText(w)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    # g.trace(wname,s,i,j)
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20060418120328:Fixed bug when cutting text in headline
#@+node:ekr.20060419080626:Fixed crasher in open-find-dialog
#@+node:ekr.20060419080626.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3692247

Find panel cannot be re-opened. Run open-find-dialog. Close it. Run open-find-dialog
again -- crash.

The fix was to move the line:

self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)

from createBindings to createFrame in the leoTkinterFind class.
#@nonl
#@-node:ekr.20060419080626.1:Report
#@+node:ekr.20060419080626.2:Traceback
TclError Exception in Tk callback
  Function: <function bindKeyCallback at 0x0169B170> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x01865EB8>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 1991, in bindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2931, in masterKeyHandler
    val = self.masterKeyHandlerHelper(event,stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2990, in masterKeyHandlerHelper
    val = k.callStateFunction(event) # Calls end-command.
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2208, in callStateFunction
    val = k.state.handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2289, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2327, in callAltXFunction
    func(event)
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 2801, in showFindPanel
    c.frame.findPanel.bringToFront()
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFind.py", line 469, in bringToFront
    self.top.withdraw() # Helps bring the window to the front.
  File "c:\python24\lib\lib-tk\Tkinter.py", line 1562, in wm_withdraw
    return self.tk.call('wm', 'withdraw', self._w)
TclError: bad window path name ".25637872"

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 1486
    state: 0
    time: 1717970
    type: 2
    widget: .17570752.17571352.19882152.minibuffer
    width: ??
    x: 183
    x_root: 576
    y: -62
    y_root: 859

#@-node:ekr.20060419080626.2:Traceback
#@+node:ekr.20041025152343.1:class leoTkinterFind
class leoTkinterFind (leoFind.leoFind,leoTkinterDialog.leoTkinterDialog):

    """A class that implements Leo's tkinter find dialog."""

    @others
#@nonl
#@+node:ekr.20031218072017.3898:Birth & death
#@+node:ekr.20031218072017.3899:__init__
def __init__(self,c,resizeable=False,title=None,show=True):

    # g.trace("leoTkinterFind",c)
    
    # Init the base classes...
    leoFind.leoFind.__init__(self,c,title=title)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,self.title,resizeable,show=show)

    << create the tkinter intVars >>
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    
    self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    if self.top and not show:
        self.top.withdraw()
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20031218072017.3900:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20031218072017.3900:<< create the tkinter intVars >>
#@-node:ekr.20031218072017.3899:__init__
#@+node:ekr.20031218072017.3901:destroySelf
def destroySelf (self):
    
    self.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3901:destroySelf
#@+node:ekr.20031218072017.3902:find.createFrame
def createFrame (self):
    
    # g.trace('legacy')

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    << Create the Find and Change panes >>
    << Create four columns of radio and checkboxes >>
    << Create two rows of buttons >>

    if self.top: # self.top may not exist during unit testing.
        self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
#@nonl
#@+node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_ctrl = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)

<< Bind Tab and control-tab >>

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")
#@nonl
#@+node:ekr.20041026092141:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)

def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20041026092141:<< Bind Tab and control-tab >>
#@-node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.dict["radio-find-type"],"P&Lain Search","plain-search"),  
    (self.dict["radio-find-type"],"&Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"&Script Search","script-search")]
checkLists[0] = [
    ("Scrip&t Change",self.dict["script_change"])]
checkLists[1] = [
    ("&Whole Word",  self.dict["whole_word"]),
    ("&Ignore Case", self.dict["ignore_case"]),
    ("Wrap &Around", self.dict["wrap"]),
    ("&Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"Suboutline &Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &Headline Text", self.dict["search_headline"]),
    ("Search &Body Text",     self.dict["search_body"]),
    ("&Mark Finds",           self.dict["mark_finds"]),
    ("Mark &Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
#@+node:ekr.20031218072017.3905:<< Create two rows of buttons >>
# Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# In 4.4 it's dubious to define these keys.  For example, Alt-x must be reserved!
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

def findButtonCallback(event=None,self=self):
    self.findButton()
    return 'break'

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=findButtonCallback) # The default.

findButton.pack(pady="1p",padx="25p",side="left")

contextBox = underlinedTkButton("check",buttons,
    anchor="w",text="Show Conte&xt",variable=self.dict["batch"])
contextBox.button.pack(pady="1p",side="left",expand=1)
contextBox.bindHotKey(ftxt)
contextBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Fin&d All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Chan&Ge",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, &Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)
    
changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)
#@nonl
#@-node:ekr.20031218072017.3905:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.3902:find.createFrame
#@+node:ekr.20060207080537:find.createBindings
def createBindings (self):
    
    # Legacy bindings.  Can be overwritten in subclasses.
    
    # g.trace('legacy')
    
    def findButtonCallback2(event,self=self):
        self.findButton()
        return 'break'

    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("<Button-1>",  self.resetWrap)
        widget.bind("<Key>",        self.resetWrap)
        widget.bind("<Control-a>",  self.selectAllFindText)
    
    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind("<Key-Return>", findButtonCallback2)
        widget.bind("<Key-Escape>", self.onCloseWindow)
#@nonl
#@-node:ekr.20060207080537:find.createBindings
#@+node:ekr.20031218072017.2059:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only"),
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")
#@nonl
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:find.init
#@-node:ekr.20031218072017.3898:Birth & death
#@+node:ekr.20031218072017.1460:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    if 0: ###
        find_type = self.dict["radio-find-type"].get()
        self.pattern_match = g.choose(find_type == "pattern-search",1,0)
        self.script_search = g.choose(find_type == "script-search",1,0)
    
    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20031218072017.1460:find.update_ivars
#@+node:ekr.20050204090259:tkFind.adjust_find_text
def adjust_find_text(self,s):
    
    w = self.find_ctrl
    
    w.delete("1.0","end")
    w.insert("end",s)
#@nonl
#@-node:ekr.20050204090259:tkFind.adjust_find_text
#@+node:ekr.20031218072017.3906:onCloseWindow
def onCloseWindow(self,event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    self.top.withdraw()
#@nonl
#@-node:ekr.20031218072017.3906:onCloseWindow
#@+node:ekr.20051013084256:dismiss
def dismiss (self):
    
    self.top.withdraw()
#@nonl
#@-node:ekr.20051013084256:dismiss
#@+node:ekr.20031218072017.3907:bringToFront
def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()
    c.widgetWantsFocusNow(t)
    
    # Apparently, the text can not be adjusted unless the widget has focus...
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # New in 4.3: don't highlight the stupid added trailing newline!
    gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
#@nonl
#@-node:ekr.20031218072017.3907:bringToFront
#@+node:EKR.20040603221140:selectAllFindText
def selectAllFindText (self,event=None):

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.
#@nonl
#@-node:EKR.20040603221140:selectAllFindText
#@+node:ekr.20031218072017.3908:Tkinter wrappers (leoTkinterFind)
def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t
#@nonl
#@-node:ekr.20031218072017.3908:Tkinter wrappers (leoTkinterFind)
#@-node:ekr.20041025152343.1:class leoTkinterFind
#@-node:ekr.20060419080626:Fixed crasher in open-find-dialog
#@+node:ekr.20060418085407:Don't do typing completion for numbers
# getLeadinWord must clear self.membersList to disable completion.
#@nonl
#@+node:ekr.20060220062710:start
def start (self,event=None,w=None):
    
    if w: self.widget = w
    else: w = self.widget
    
    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = g.app.gui.getTextSelection(w)
    self.selectedText = g.app.gui.getSelectedText(w)
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = g.app.gui.getInsertPoint(w)
            if w.get(i+'-1c') == '.':
                w.delete(i+'-1c')
                
        self.autoCompleterStateHandler(event)
    else:
        self.abort()
#@nonl
#@-node:ekr.20060220062710:start
#@+node:ekr.20060219111416:getLeadinWord
def getLeadinWord (self,w):
    
    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = g.app.gui.getInsertPoint(w)
    start = w.index(start+'-1c')
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    
    # g.trace(word,self.object,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.object:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while w.compare(i,'<',start):
            if w.get(i) != '.':
                g.trace('oops: %s' % (repr(w.get(i))))
                return False
            i = w.index(i+'+1c')
            j = w.index(i+' wordend')
            word = w.get(i,j)
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.object:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@nonl
#@-node:ekr.20060219111416:getLeadinWord
#@-node:ekr.20060418085407:Don't do typing completion for numbers
#@-node:ekr.20060417092153:Bugs
#@+node:ekr.20060414090519.1:New features
#@+node:ekr.20060123095316:Added clear-selection command
Useful, e.g., after a find.
#@nonl
#@+node:ekr.20060414085834:clearSelectedText
def clearSelectedText (self,event):
    
    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    i,j = g.app.gui.getTextSelection(w)
    if i == j: return

    self.beginCommand(undoType='clear-selected-text')
    g.app.gui.replaceSelectionRangeWithText (w,i,j,'')
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060414085834:clearSelectedText
#@-node:ekr.20060123095316:Added clear-selection command
#@+node:ekr.20060415101441:Made all edit command undoable
self.beginCommand(undoType='xxx')
...
self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060415101441:Made all edit command undoable
#@+node:ekr.20060414092733:Added new commands
#@+node:ekr.20060418080701:What I did
@nocolor

New commands:

add-space-to-lines
add-tab-to-lines
clean-lines
clear-selected-text
goto-global-line
help-for-command
remove-space-from-lines
remove-tab-from-lines

Fixed commands

rename-buffer
#@nonl
#@-node:ekr.20060418080701:What I did
#@+node:ekr.20060418080920:Reference
#@+node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.
#@nonl
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@nonl
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@nonl
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:get_focus
def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()
#@nonl
#@-node:ekr.20031218072017.4065:get_focus
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None
#@nonl
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("<Visibility>",visibilityCallback)

if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@nonl
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4082:getInsertPoint
def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'
#@nonl
#@-node:ekr.20031218072017.4082:getInsertPoint
#@+node:ekr.20031218072017.4083:setInsertPoint
def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass
#@nonl
#@-node:ekr.20031218072017.4083:setInsertPoint
#@-node:ekr.20031218072017.4081:Insert Point
#@+node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4085:getSelectionRange
def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0
#@nonl
#@-node:ekr.20031218072017.4085:getSelectionRange
#@+node:ekr.20051126125950:getSelectedText
def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@nonl
#@-node:ekr.20051126125950:getSelectedText
#@+node:ekr.20031218072017.4086:getTextSelection
def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, ">", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert
#@nonl
#@-node:ekr.20031218072017.4086:getTextSelection
#@+node:ekr.20051126171929:hasSelection
def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j
#@nonl
#@-node:ekr.20051126171929:hasSelection
#@+node:ekr.20031218072017.4088:setSelectionRangeWithLength
def setSelectionRangeWithLength(self,t,start,length,insert='sel.end'):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length),insert=insert)
#@nonl
#@-node:ekr.20031218072017.4088:setSelectionRangeWithLength
#@+node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, ">", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection
#@nonl
#@-node:ekr.20031218072017.4089:setTextSelection & setSelectionRange
#@-node:ekr.20031218072017.4084:Selection
#@+node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4091:g.app.gui.getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text widget t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:g.app.gui.getAllText
#@+node:ekr.20031218072017.4092:getCharAfterIndex
def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c",">=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4092:getCharAfterIndex
#@+node:ekr.20031218072017.4093:getCharAtIndex
def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4093:getCharAtIndex
#@+node:ekr.20031218072017.4094:getCharBeforeIndex
def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4094:getCharBeforeIndex
#@+node:ekr.20031218072017.4095:getLineContainingIndex
def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4095:getLineContainingIndex
#@+node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)
#@nonl
#@-node:ekr.20031218072017.4096:replaceSelectionRangeWithText (leoTkinterGui)
#@-node:ekr.20031218072017.4090:Text
#@+node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20031218072017.4098:makeIndexVisible
def makeIndexVisible(self,t,index):

    return t.see(index)
#@nonl
#@-node:ekr.20031218072017.4098:makeIndexVisible
#@-node:ekr.20031218072017.4097:Visibility
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) 
#@nonl
#@-node:ekr.20051220144507:isTextWidget
#@-node:ekr.20031218072017.4059:app.gui.Tkinter.utils
#@+node:ekr.20051214132256:begin/endCommand
#@+node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
#@nonl
#@+node:ekr.20051215102349:beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None
        
    return w
#@nonl
#@-node:ekr.20051215102349:beingCommandHelper
#@-node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
#@+node:ekr.20051214133130.1:endCommand
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but does handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@nonl
#@-node:ekr.20051214133130.1:endCommand
#@-node:ekr.20051214132256:begin/endCommand
#@+node:ekr.20050920084036.53:class editCommandsClass
class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others
#@nonl
#@+node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.widget = None # For use by state handlers.
#@nonl
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c ; k = self.k

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from lines':              self.removeSpaceFromLines,
        'remove-tab-from lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@-node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051015114221:capitalizeWord & up/downCaseWord
def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up','upcase-word')
#@nonl
#@-node:ekr.20051015114221:capitalizeWord & up/downCaseWord
#@+node:ekr.20050920084036.145:changePreviousWord (not used)
def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')
    
    self.beginCommand(undoType='change-previous-word')

    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '<Alt-c>':
        self.capitalizeWord(event)
    elif stroke == '<Alt-u>':
         self.upCaseWord(event)
    elif stroke == '<Alt-l>':
        self.downCaseWord(event)

    w.mark_set('insert',i)
    
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.145:changePreviousWord (not used)
#@+node:ekr.20051015114221.1:capitalizeHelper
def capitalizeHelper (self,event,which,undoType):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    
    self.beginCommand(undoType=undoType)
    
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20051015114221.1:capitalizeHelper
#@-node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
def activateCmdsMenu    (self,event=None): self.activateMenu('Cmds')
def activateEditMenu    (self,event=None): self.activateMenu('Edit')
def activateFileMenu    (self,event=None): self.activateMenu('File')
def activateHelpMenu    (self,event=None): self.activateMenu('Help')
def activateOutlineMenu (self,event=None): self.activateMenu('Outline')
def activatePluginsMenu (self,event=None): self.activateMenu('Plugins')
def activateWindowMenu  (self,event=None): self.activateMenu('Window')

def activateMenu (self,menuName):
    c = self.c
    c.frame.menu.activateMenu(menuName)
#@nonl
#@-node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):

    c = self.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i >= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    c.set_focus(pane)
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@+node:ekr.20051022144825:focusTo...
def focusToBody (self,event):
    
    self.c.bodyWantsFocus()

def focusToLog (self,event):

    self.c.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.treeWantsFocus()
#@nonl
#@-node:ekr.20051022144825:focusTo...
#@+node:ekr.20060211063744.1:clicks in the headline
# These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineClick(event,p=p)
    
def doubleClickHeadline (self,event=None):
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineRightClick(event,p=p)
#@nonl
#@-node:ekr.20060211063744.1:clicks in the headline
#@+node:ekr.20060211055455:clicks in the icon box
# These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):

    '''Simulate a click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):

    '''Simulate a double-click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxRightClick(event,p=p)
#@nonl
#@-node:ekr.20060211055455:clicks in the icon box
#@+node:ekr.20060211062025:clickClickBox
# Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected headline.'''

    c = self.c ; p = c.currentPosition()
    c.frame.tree.onClickBoxClick(event,p=p)
#@nonl
#@-node:ekr.20060211062025:clickClickBox
#@+node:ekr.20060211063744.2:simulate...Drag
# These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected headline.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected headline.'''
    c = self.c
    
    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
#@nonl
#@-node:ekr.20060211063744.2:simulate...Drag
#@-node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20051019183105:color & font
#@+node:ekr.20051019183105.1:show-colors
def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    << define colors >>
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
#@+node:ekr.20051019183105.2:<< define colors >>
colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@nonl
#@-node:ekr.20051019183105.2:<< define colors >>
#@+node:ekr.20051019183105.3:createColorPicker
def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    << create optionMenu and callback >>
    << create picker button and callback >>
#@nonl
#@+node:ekr.20051019183105.4:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@nonl
#@-node:ekr.20051019183105.4:<< create optionMenu and callback >>
#@+node:ekr.20051019183105.5:<< create picker button and callback >>
def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
#@nonl
#@-node:ekr.20051019183105.5:<< create picker button and callback >>
#@-node:ekr.20051019183105.3:createColorPicker
#@-node:ekr.20051019183105.1:show-colors
#@+node:ekr.20051019201809:show-fonts & helpers
def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)
#@nonl
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
#@nonl
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@nonl
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['<None>','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['<None>','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@nonl
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)
#@nonl
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('<Return>',fontCallback)
#@nonl
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@nonl
#@-node:ekr.20051019201809.7:setFont
#@-node:ekr.20051019201809:show-fonts & helpers
#@-node:ekr.20051019183105:color & font
#@+node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.133:setCommentColumn
def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2
#@nonl
#@-node:ekr.20050920084036.133:setCommentColumn
#@+node:ekr.20050920084036.134:indentToCommentColumn
def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget
    
    self.beginCommand(undoType='indent-to-comment-column')

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 < c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 >= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')
    
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.134:indentToCommentColumn
#@-node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.59:dynamicExpansion
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion
#@+node:ekr.20050920084036.60:dynamicExpansion2
def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)
#@nonl
#@-node:ekr.20050920084036.60:dynamicExpansion2
#@+node:ekr.20050920084036.61:getDynamicList (helper)
def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)
#@nonl
#@-node:ekr.20050920084036.61:getDynamicList (helper)
#@-node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.63:watchEscape (Revise)
def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)
#@nonl
#@-node:ekr.20050920084036.63:watchEscape (Revise)
#@+node:ekr.20050920084036.64:escEvaluate (Revise)
def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
#@nonl
#@-node:ekr.20050920084036.64:escEvaluate (Revise)
#@-node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.65:evalExpression
def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
#@nonl
#@-node:ekr.20050920084036.65:evalExpression
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event):
    
    w = event.widget
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
    else:
        i = g.app.gui.getInsertPoint(w)
    g.app.gui.setSelectionRange(w, i+' wordstart', i+' wordend')
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20050920084036.66:fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others
#@nonl
#@+node:ekr.20050920084036.67:centerLine
def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) >= self.fillColumn: return
    
    self.beginCommand(undoType='center-line')

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)
        
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.67:centerLine
#@+node:ekr.20050920084036.68:setFillColumn
def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@nonl
#@-node:ekr.20050920084036.68:setFillColumn
#@+node:ekr.20050920084036.69:centerRegion
def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    
    self.beginCommand(undoType='center-region')

    while sindex <= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) >= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1
        
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.69:centerRegion
#@+node:ekr.20050920084036.70:setFillPrefix
def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt
#@nonl
#@-node:ekr.20050920084036.70:setFillPrefix
#@+node:ekr.20050920084036.71:_addPrefix
def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@nonl
#@-node:ekr.20050920084036.71:_addPrefix
#@-node:ekr.20050920084036.66:fill column and centering
#@+node:ekr.20060417194232:find (quick) To do: extend selection
#@+node:ekr.20060417194232.1:findCharacter
def findCharacter (self,event):
    
    '''Put the cursor at the next occurance of a character on a line.'''

    k = self.k ; tag = 'find-char' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Find character: ')
        k.getArg(event,tag,1,self.findCharacterOnLine,oneCharacter=True)
    else:
        w = self.widget
        ch = k.arg
        g.trace(repr(ch))
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacter
#@+node:ekr.20060417194232.2:findWord
def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findCharacterOnLine,oneCharacter=True)
    else:
        w = self.widget
        ch = k.arg
        g.trace(repr(ch))
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.2:findWord
#@-node:ekr.20060417194232:find (quick) To do: extend selection
#@+node:ekr.20050920084036.72:goto...
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):
    
    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20050929115226:gotoCharacter
#@+node:ekr.20060417181052:gotoGlobalLine
def gotoGlobalLine (self,event):
    
    '''Put the cursor at the n'th line of a file or script.

    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg ;  w = self.widget
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            self.c.goToLineNumber (n=int(n))
#@nonl
#@-node:ekr.20060417181052:gotoGlobalLine
#@+node:ekr.20050929124234:gotoLine
def gotoLine (self,event):
    
    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()
#@nonl
#@-node:ekr.20050929124234:gotoLine
#@-node:ekr.20050920084036.72:goto...
#@+node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    self.beginCommand(undoType='back-to-indentation')

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20050920084036.76:deleteIndentation
def deleteIndentation (self,event):

    k = self.k ; w = event.widget
    
    self.beginCommand(undoType='delete-indentation')

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.76:deleteIndentation
#@+node:ekr.20050920084036.77:splitLine
def splitLine (self,event):

    w = event.widget
    s = w.get('insert linestart','insert lineend')
    
    self.beginCommand(undoType='split-line')
    s = self.getWSString(s)
    i = w.index('insert')
    w.insert(i,s + '\n')
    # w.mark_set('insert',i)
    # w.insert('insert','\n')
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.77:splitLine
#@+node:ekr.20050920084036.78:indentRelative
def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'indent-relative'
    
    k = self.k ; w = event.widget
    self.beginCommand(undoType=undoType)
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 < 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) <= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.78:indentRelative
#@-node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')
    
def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')
    
def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')
    
def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@nonl
#@+node:ekr.20060417172056:addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = event.widget
    if g.app.gui.hasSelection(w):
        s = g.app.gui.getSelectedText(w)
    else:
        s = g.app.gui.getAllText(w)
    if not s: return
    
    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = g.scanDirectives(c) ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)
    self.beginCommand(undoType=undoType)
    if add:
        result = [ch + line for line in g.splitLines(s)]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in g.splitLines(s)]
    result = ''.join(result)
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
        w.insert(i,result)
        g.app.gui.setSelectionRange(w, i, j + '%dc' %(len(result)))
    else:
        w.delete('1.0','end')
        w.insert('1.0',result)
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060417172056:addRemoveHelper
#@-node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget
    if not g.app.gui.isTextWidget(w):
        g.trace('*'*40,'Not a text widget',c.widget_name(w))
        return
    
    wname = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(wname,i,j)

    if wname.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width > 0:
            w.delete('insert-1c')
        else:
            << backspace with negative tab_width >>
        self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')
#@nonl
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")
#@nonl
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20060415112257:clean-lines
def cleanLines (self,event):
    
    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = event.widget
    
    if g.app.gui.hasSelection(w):
        s = g.app.gui.getSelectedText(w)
    else:
        s = g.app.gui.getAllText(w)

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if g.app.gui.hasSelection(w):
            i,j = g.app.gui.getSelectionRange(w)
            w.delete(i,j)
            w.insert(i,result)
            g.app.gui.setSelectionRange(w, i, j + '%dc' %(len(result)))
        else:
            w.delete('1.0','end')
            w.insert('1.0',result)
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060415112257:clean-lines
#@+node:ekr.20060414085834:clearSelectedText
def clearSelectedText (self,event):
    
    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    i,j = g.app.gui.getTextSelection(w)
    if i == j: return

    self.beginCommand(undoType='clear-selected-text')
    g.app.gui.replaceSelectionRangeWithText (w,i,j,'')
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060414085834:clearSelectedText
#@+node:ekr.20050920084036.87:deleteNextChar
def deleteNextChar (self,event):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    self.beginCommand(undoType='delete-char')

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    self.endCommand(changed=changed,setLabel=False)
#@nonl
#@-node:ekr.20050920084036.87:deleteNextChar
#@+node:ekr.20050920084036.135:deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    c = self.c ; w = event and event.widget
    if not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    self.beginCommand(undoType=undoType)
    
    i = w.index('insert')
    wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
    if '' not in (wf,wb):
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.135:deleteSpaces
#@+node:ekr.20050920084036.138:insertNewLine
def insertNewLine (self,event):

    w = event.widget
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('head'):
        self.beginCommand(undoType='insert-newline')
        w.insert('insert','\n')
        self.endCommand(changed=True,setLabel=False)

insertNewline = insertNewLine
#@nonl
#@-node:ekr.20050920084036.138:insertNewLine
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    w = event.widget
    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('head'):
        self.beginCommand(undoType='insert-newline-and-indent')
        w.insert('insert','\n\t')
        self.endCommand(changed=True,setLabel=False)
#@nonl
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):

    w = event.widget
    
    self.beginCommand(undoType='insert-parenthesis')
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')
    self.endCommand(changed=True,setLabel=False)
#@nonl
#@-node:ekr.20050920084036.139:insertParentheses
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'remove-blank-lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20051125080855:selfInsertCommand
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    # g.trace('event',event,g.callers())
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name,repr(ch))
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)
        # g.trace(removeTrailing)
#@nonl
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing
#@nonl
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@nonl
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20050920084036.81:lineNumber
def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))
#@nonl
#@-node:ekr.20050920084036.81:lineNumber
#@+node:ekr.20050920084036.83:viewLossage
def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)
#@nonl
#@-node:ekr.20050920084036.83:viewLossage
#@+node:ekr.20050920084036.84:whatLine
def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)
#@nonl
#@-node:ekr.20050920084036.84:whatLine
#@-node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.90:flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
#@nonl
#@-node:ekr.20050920084036.90:flushLines
#@+node:ekr.20051002095724:keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
#@nonl
#@-node:ekr.20051002095724:keepLines
#@+node:ekr.20050920084036.92:linesHelper
def linesHelper (self,event,pattern,which,undoType):

    k = self.k ; w = event.widget
   
    self.beginCommand(undoType=which+'-lines')
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.92:linesHelper
#@-node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.147:measure
def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart < 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom
#@nonl
#@-node:ekr.20050920084036.147:measure
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,ins1,spot,setSpot=True):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'<',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        # Don't change the moveCol while extending: that would mess up the selection.
        if setSpot or not moveSpot:
            self.setMoveCol(spot)
        g.app.gui.setTextSelection(w,spot,spot,insert=None)
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y <= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y >= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x > newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col >= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'<',i):
            spot = i
        elif w.compare(spot,'>',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'<',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'>',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    ins = w.index('insert')
    # sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)
#@nonl
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,spot):
    
    self.moveSpot = spot
    self.moveCol = int(spot.split('.')[1])

    # g.trace('spot',self.moveSpot,'col',self.moveCol)
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)
#@nonl
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20051218174113:extendMode
def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20051218174113:extendMode
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    self.moveUpOrDownHelper(event,'up',extend=True)
#@nonl
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose (test)
def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.140:movePastClose (test)
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)
#@nonl
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20050920084036.95:paragraph...
@others
#@nonl
#@+node:ekr.20050920084036.99:backwardKillParagraph
def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    
    self.beginCommand(undoType='backward-kill-paragraph')

    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.99:backwardKillParagraph
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.strip()
    if txt:
        self.beginCommand(undoType='fill-paragraph')
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.strip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.strip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )
        self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region')

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','>',s2):
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region-as-paragraph')

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20050920084036.98:killParagraph (Test)
def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')
    
    self.beginCommand(undoType='kill-paragraph')

    if not txt.strip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')
    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.98:killParagraph (Test)
#@+node:ekr.20050920084036.96:selectParagraph & helper
def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break
#@nonl
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.strip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)
#@nonl
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:selectParagraph & helper
#@-node:ekr.20050920084036.95:paragraph...
#@+node:ekr.20050920084036.105:region...
@others
#@nonl
#@+node:ekr.20050920084036.106:setRegion
def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('<Right>',extend,'+')
    w.bind('<Left>',truncate,'+')
    w.bind('<Up>',up,'+')
    w.bind('<Down>',down,'+')

    return 'break'
#@nonl
#@+node:ekr.20051002102410:down
def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'
#@nonl
#@-node:ekr.20051002102410:down
#@+node:ekr.20051002102410.1:extend
def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

#@-node:ekr.20051002102410.1:extend
#@+node:ekr.20051002102410.2:truncate
def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'
#@nonl
#@-node:ekr.20051002102410.2:truncate
#@+node:ekr.20051002102410.3:up
def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'
#@nonl
#@-node:ekr.20051002102410.3:up
#@-node:ekr.20050920084036.106:setRegion
#@+node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) > 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('<Key>')
        ### w.update_idletasks()
    self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
#@+node:ekr.20050920084036.108:tabIndentRegion
def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return
    
    self.beginCommand(undoType='indent-rigidly')

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)
#@nonl
#@-node:ekr.20050920084036.108:tabIndentRegion
#@+node:ekr.20050920084036.109:countRegion
def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))
#@nonl
#@-node:ekr.20050920084036.109:countRegion
#@+node:ekr.20060417183606:moveLinesDown
def moveLinesDown (self,event):

    c = self.c ; w = event.widget
    
    if not g.app.gui.hasSelection(w): return

    self.beginCommand(undoType='move-lines-down')

    i,j = g.app.gui.getSelectionRange(w)
    i = w.index(i+' linestart')
    j = w.index(j+' lineend+1c')
    j2 = w.index(j+ ' lineend+1c')
    selected = w.get(i,j) # g.trace('selected',repr(selected))
    moved = w.get(j,j2)  # g.trace('moved',repr(moved))
    if moved:
        if not moved.endswith('\n'): moved = moved + '\n'
        w.mark_set('i',i)
        w.mark_set('j',j)
        w.delete(j,j2)
        w.insert(i,moved)
        w.mark_set('sel.start','i')
        w.mark_set('sel.end','j')
        w.mark_unset('i')
        w.mark_unset('j')
    else: # Move the text to the top of the next node.
        p = c.currentPosition()
        if not p.hasThreadNext(): return
        if not moved.endswith('\n'): moved = moved + '\n'
        w.delete(i,j) # Deleted the old selection.
        p.setBodyString(w.get('1.0','end')) # Doesn't really work: undo doesn't work.
        p = p.threadNext()
        c.beginUpdate()
        c.selectPosition(p)
        c.endUpdate()
        w.focus_force()
        w.insert('1.0',selected)
        g.app.gui.setSelectionRangeWithLength(w,'1.0',len(selected)-1)

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060417183606:moveLinesDown
#@+node:ekr.20060417183606.1:moveLinesUp
def moveLinesUp (self,event):

    c = self.c ; w = event.widget

    if not g.app.gui.hasSelection(w): return
    
    self.beginCommand(undoType='move-lines-up')
    
    i,j = g.app.gui.getSelectionRange(w)
    i = w.index(i+' linestart')
    j = w.index(j+' lineend+1c')
    i2 = w.index(i+'-1c linestart')
    selected = w.get(i,j) # g.trace('selected',repr(selected))
    moved = w.get(i2,i)   # g.trace('moved',repr(moved))
    
    if moved:
        w.mark_set('i',i)
        w.mark_set('j',j)
        w.delete(i2,i)
        if w.compare('j','==','end'):
            w.insert('j','\n' + moved)
        else:
            w.insert('j',moved)
        w.mark_set('sel.start','i')
        w.mark_set('sel.end','j')
        w.mark_unset('i')
        w.mark_unset('j')
    else: # Move the text to the bottom of the previous node.
        p = c.currentPosition()
        if not p.hasThreadBack(): return
        w.delete(i,j+'+1c')
        p.setBodyString(w.get('1.0','end'))
        p = p.threadBack()
        c.beginUpdate()
        c.selectPosition(p)
        c.endUpdate()
        w.focus_force()
        w.insert('end','\n'+selected)
        g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-2c')

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060417183606.1:moveLinesUp
#@+node:ekr.20050920084036.110:reverseRegion
def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()
    
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.110:reverseRegion
#@+node:ekr.20050920084036.111:up/downCaseRegion & helper
def downCaseRegion (self,event):
    self.caseHelper(event,'low','downcase-region')
    
def upCaseRegion (self,event):
    self.caseHelper(event,'up','upcase-region')
    
def caseHelper (self,event,way,undoType):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        self.beginCommand(undoType=undoType)
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)
        self.endCommand(changed=True,setLabel=True)

    self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.111:up/downCaseRegion & helper
#@-node:ekr.20050920084036.105:region...
#@+node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    self.scrollHelper(event,'up',extend=True)
#@nonl
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocus(w)

    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    row, col = ins1.split('.') ; row = int(row) ; col = int(col)

    # Compute the spot.
    chng = self.measure(w) ; delta = chng [0]
    row1 = g.choose(direction=='down',row+delta,row-delta)
    spot = w.index('%d.%d' % (row1,col))
    w.mark_set('insert',spot)

    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
    w.see('insert')
#@nonl
#@-node:ekr.20060113082917:scrollHelper
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(1,"unit")
    
def scrollOutlineDownPage (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    self.c.frame.tree.canvas.yview_scroll(-1,"page")


#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@-node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.117:sort...
'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
#@+node:ekr.20050920084036.118:sortLines
def sortLines (self,event,which=None):

    c = self.c ; k = c.k ; w = event.widget
    g.trace(c.widget_name(w))
    if not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.118:sortLines
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    self.beginCommand(undoType='sort-columns')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i <= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.120:sortFields
#@-node:ekr.20050920084036.117:sort...
#@+node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.122:transposeLines
def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    self.beginCommand(undoType='transpose-lines')
    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.122:transposeLines
#@+node:ekr.20050920084036.123:swapWords & transposeWords
def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    
    self.beginCommand(undoType='swap-words')
    if len(swapspots) != 0:
        if w.compare(i,'>',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'<',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)
    self.endCommand(changed=True,setLabel=True)

def transposeWords (self,event):
    self.beginCommand(undoType='transpose-words')
    self.swapWords(event,self.swapSpots)
    self.endCommand(changed=True,setLabel=True)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20050920084036.123:swapWords & transposeWords
#@+node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    
    self.beginCommand(undoType='swap-characters')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)
    self.endCommand(changed=True,setLabel=True)

transposeCharacters = swapCharacters
#@nonl
#@-node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
#@-node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.126:tabify & untabify
def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        self.beginCommand(undoType=which)
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)
        self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20050920084036.126:tabify & untabify
#@-node:ekr.20050920084036.53:class editCommandsClass
#@+node:ekr.20050920085536.62:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return' or k.oneCharacterArg:
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@nonl
#@+node:ekr.20050928092516:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@nonl
#@-node:ekr.20050928092516:<< init altX vars >>
#@-node:ekr.20050920085536.62:getArg
#@+node:ekr.20050920085536.41:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt ### k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@nonl
#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@-node:ekr.20050920085536.41:fullCommand (alt-x) & helper
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,event=None,root=None,lines=None,n=None,scriptFind=False):
    
    __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@nonl
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@nonl
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@nonl
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    g.es_print(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
            
if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    g.es_print(s, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
try:
    c.frame.tree.expandAllAncestors(p)
    c.selectVnode(p)
finally:
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.bodyWantsFocus()
c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@nonl
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@-node:ekr.20060418080920:Reference
#@+node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self,event=None):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs(event)
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self,event=None):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self,event=None):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False,None

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20031218072017.1823:createLastChildNode
def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) > 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
#@nonl
#@-node:ekr.20031218072017.1823:createLastChildNode
#@+node:ekr.20031218072017.1824:dedentBody
def dedentBody (self,event=None):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1824:dedentBody
#@+node:ekr.20031218072017.1706:extract
def extract (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1706:extract
#@+node:ekr.20031218072017.1708:extractSection
def extractSection (self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@+node:ekr.20031218072017.1710:extractSectionNames
def extractSectionNames(self,event=None):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
#@nonl
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)
        
if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@nonl
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames
#@+node:ekr.20031218072017.1825:findBoundParagraph
def findBoundParagraph (self,event=None):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i < len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#   para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
#@nonl
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:findBoundParagraph
#@+node:ekr.20031218072017.1827:findMatchingBracket
def findMatchingBracket (self,event=None):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"<=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
#@nonl
#@+node:ekr.20031218072017.1828:findMatchingBracket
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,">=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level <= 0:
                return index
        if not forward and body.compareIndices(index,"<=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@nonl
#@-node:ekr.20031218072017.1828:findMatchingBracket
#@-node:ekr.20031218072017.1827:findMatchingBracket
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):
    
    """Return head,lines,tail where:
        
    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use g.splitLines.

    return head,lines,tail,oldSel,oldVview
#@nonl
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.1830:indentBody
def indentBody (self,event=None):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; undoType = 'Indent Region' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1830:indentBody
#@+node:ekr.20031218072017.1831:insertBodyTime & allies
def insertBodyTime (self,event=None):
    
    c = self ; undoType = 'Insert Body Time'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)
#@nonl
#@+node:ekr.20031218072017.1832:getTime & test
def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
#@-node:ekr.20031218072017.1832:getTime & test
#@-node:ekr.20031218072017.1831:insertBodyTime & allies
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self,event=None):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self,event=None):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
#@nonl
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
# Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
#@nonl
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@-node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20060418080920.1:New or fixed commands
#@+node:ekr.20060116084526.1:Added add-space/tab-to-lines and remove-space/tab-from-lines
#@+node:ekr.20060417171501:Request
@

http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space to start of all selected lines.

add-tab-to-lines        Adds tab (or equivalent spaces) to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a tab (or equivalent spaces) from start of all selected lines.
#@nonl
#@-node:ekr.20060417171501:Request
#@+node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')
    
def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')
    
def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')
    
def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@nonl
#@+node:ekr.20060417172056:addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = event.widget
    if g.app.gui.hasSelection(w):
        s = g.app.gui.getSelectedText(w)
    else:
        s = g.app.gui.getAllText(w)
    if not s: return
    
    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = g.scanDirectives(c) ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)
    self.beginCommand(undoType=undoType)
    if add:
        result = [ch + line for line in g.splitLines(s)]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in g.splitLines(s)]
    result = ''.join(result)
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
        w.insert(i,result)
        g.app.gui.setSelectionRange(w, i, j + '%dc' %(len(result)))
    else:
        w.delete('1.0','end')
        w.insert('1.0',result)
    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060417172056:addRemoveHelper
#@-node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
#@-node:ekr.20060116084526.1:Added add-space/tab-to-lines and remove-space/tab-from-lines
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event):
    
    w = event.widget
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
    else:
        i = g.app.gui.getInsertPoint(w)
    g.app.gui.setSelectionRange(w, i+' wordstart', i+' wordend')
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20060417181052:gotoGlobalLine
def gotoGlobalLine (self,event):
    
    '''Put the cursor at the n'th line of a file or script.

    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg ;  w = self.widget
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            self.c.goToLineNumber (n=int(n))
#@nonl
#@-node:ekr.20060417181052:gotoGlobalLine
#@+node:ekr.20050920084036.43:renameBuffer
def renameBuffer (self,event):
    
    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)
    
def renameBufferFinisher1 (self,name):
    
    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)
    
def renameBufferFinisher2 (self,name):
    
    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        c.beginUpdate()
        p.setHeadStringOrHeadline(name)
        c.endUpdate()
#@nonl
#@-node:ekr.20050920084036.43:renameBuffer
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):
    
    '''Return the docstring for a user-specified command.'''
    
    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)
    
def helpForCommandFinisher (self,commandName):

    c = self.c
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        g.es('%s:\n%s\n' % (commandName,func.__doc__),color='blue')
    else:
        g.es('No help available for %s' % (commandName),color='blue')
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@+node:ekr.20060104083551:move-lines-up/down
# Undo doesn't work when multiple bodies change.
#@nonl
#@+node:ekr.20060418080701.1:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3488030

move-lines-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-lines-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.
#@nonl
#@-node:ekr.20060418080701.1:Request
#@+node:ekr.20060417183606:moveLinesDown
def moveLinesDown (self,event):

    c = self.c ; w = event.widget
    
    if not g.app.gui.hasSelection(w): return

    self.beginCommand(undoType='move-lines-down')

    i,j = g.app.gui.getSelectionRange(w)
    i = w.index(i+' linestart')
    j = w.index(j+' lineend+1c')
    j2 = w.index(j+ ' lineend+1c')
    selected = w.get(i,j) # g.trace('selected',repr(selected))
    moved = w.get(j,j2)  # g.trace('moved',repr(moved))
    if moved:
        if not moved.endswith('\n'): moved = moved + '\n'
        w.mark_set('i',i)
        w.mark_set('j',j)
        w.delete(j,j2)
        w.insert(i,moved)
        w.mark_set('sel.start','i')
        w.mark_set('sel.end','j')
        w.mark_unset('i')
        w.mark_unset('j')
    else: # Move the text to the top of the next node.
        p = c.currentPosition()
        if not p.hasThreadNext(): return
        if not moved.endswith('\n'): moved = moved + '\n'
        w.delete(i,j) # Deleted the old selection.
        p.setBodyString(w.get('1.0','end')) # Doesn't really work: undo doesn't work.
        p = p.threadNext()
        c.beginUpdate()
        c.selectPosition(p)
        c.endUpdate()
        w.focus_force()
        w.insert('1.0',selected)
        g.app.gui.setSelectionRangeWithLength(w,'1.0',len(selected)-1)

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060417183606:moveLinesDown
#@+node:ekr.20060417183606.1:moveLinesUp
def moveLinesUp (self,event):

    c = self.c ; w = event.widget

    if not g.app.gui.hasSelection(w): return
    
    self.beginCommand(undoType='move-lines-up')
    
    i,j = g.app.gui.getSelectionRange(w)
    i = w.index(i+' linestart')
    j = w.index(j+' lineend+1c')
    i2 = w.index(i+'-1c linestart')
    selected = w.get(i,j) # g.trace('selected',repr(selected))
    moved = w.get(i2,i)   # g.trace('moved',repr(moved))
    
    if moved:
        w.mark_set('i',i)
        w.mark_set('j',j)
        w.delete(i2,i)
        if w.compare('j','==','end'):
            w.insert('j','\n' + moved)
        else:
            w.insert('j',moved)
        w.mark_set('sel.start','i')
        w.mark_set('sel.end','j')
        w.mark_unset('i')
        w.mark_unset('j')
    else: # Move the text to the bottom of the previous node.
        p = c.currentPosition()
        if not p.hasThreadBack(): return
        w.delete(i,j+'+1c')
        p.setBodyString(w.get('1.0','end'))
        p = p.threadBack()
        c.beginUpdate()
        c.selectPosition(p)
        c.endUpdate()
        w.focus_force()
        w.insert('end','\n'+selected)
        g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-2c')

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060417183606.1:moveLinesUp
#@-node:ekr.20060104083551:move-lines-up/down
#@-node:ekr.20060418080920.1:New or fixed commands
#@-node:ekr.20060414092733:Added new commands
#@-node:ekr.20060414090519.1:New features
#@-node:ekr.20060414090519:4.4 b4 projects
#@-node:ekr.20050924073836:4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
