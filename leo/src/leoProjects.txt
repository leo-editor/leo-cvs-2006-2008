#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20061029091751:Leo 4.4.3 alpha 1 projects
#@+node:ekr.20061029091904:Bugs
#@+node:ekr.20061030054124:Fixed an escape bug in new colorizer
Example:

print "\\" + " this is a test"

The escape mechanism must treat an even number of trailing escapes as not an escape.
#@nonl
#@-node:ekr.20061030054124:Fixed an escape bug in new colorizer
#@+node:ekr.20061101124419:Fixed new autocompletion bugs
@nocolor

- (fixed) Backspace not handled correcly.
- (fixed) Autocompletion eats one too many characters

@color
#@nonl
#@-node:ekr.20061101124419:Fixed new autocompletion bugs
#@+node:ekr.20061204120501.1:Treat escaped characters in find patterns as a single character
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):
    
    if swapij and backwards: i,j = j,i
        
    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1
        
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
#@+node:ekr.20061207172210:patternLen
#@-node:ekr.20061207172210:patternLen
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    
    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):
    
    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):
    
    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'
    
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    
    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))
    
    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):
    
    '''Carefully replace backslashes in a search pattern.'''
    
    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.
    
    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible()
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20061204120501.1:Treat escaped characters in find patterns as a single character
#@+node:ekr.20061009152210.1:Fixed undo problems with yank/kill
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3924236

Added unit tests for yank and all kill commands.

@color
#@nonl
#@+node:ekr.20061020155051.1:Notes
@nocolor

Several things became clearer after a short walk in the woods:

- It's a little late in the release cycle to mess with undo, so I'm going to put
off work until Leo 4.4.3. The present code is complex, and should be simplified
if possible. However, the potential for harm is too great to make substantial
change now. Given the complexity of the code, *any* change is a substantial
change :-)

- Some problems with undo may actually be just unexpected results. In
particular, undo typing should 'coalesce', only for actual typing: all other
commands that affect body text (cut, copy, yank and kill in particular) should
be independently undoable regardless of undo granularity. Thus, if you cut,
copy, yank or kill text an immediate undo command should restore the text to
what it was before those commands. This probably doesn't happen now, and that
could be the source of some (all??) undo problems.

Edward

P.S. I recently uncovered some more hard bindings in the yank command. Such
bindings must somehow be removed, and certainly are a symptom that yank does not
yet work as in Emacs. This is a separate issue from undo, so discovering this
problem actually simplifies the undo task to come.
#@-node:ekr.20061020155051.1:Notes
#@+node:ekr.20061020080610:How to reproduce undo bug
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3972170
By: oculog

Step 1 - add some lines...
line 1
line 2
line 3

Step 2 - cut and paste first line to the end
line 2
line 3
line 1

Step 3 - *Copy* and paste first line to the end x2
line 2
line 3
line 1
line 2
line 2

That's it!  The fourth undo doesn't work right.
#@-node:ekr.20061020080610:How to reproduce undo bug
#@+node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
class killBufferCommandsClass (baseEditCommandsClass):
    
    '''A class to manage the kill buffer.'''

    @others
#@+node:ekr.20050920084036.175: ctor & finishCreate
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):
    
    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
    
    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
#@-node:ekr.20050920084036.175: ctor & finishCreate
#@+node:ekr.20050920084036.176: getPublicCommands
def getPublicCommands (self):
    
    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
#@-node:ekr.20050920084036.176: getPublicCommands
#@+node:ekr.20050920084036.183:addToKillBuffer
def addToKillBuffer (self,text):
    
    killKeys =(
        '<Control-k>', '<Control-w>',
        '<Alt-d>', '<Alt-Delete', '<Alt-z>', '<Delete>',
        '<Control-Alt-w>')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
#@-node:ekr.20050920084036.183:addToKillBuffer
#@+node:ekr.20050920084036.181:backwardKillSentence
def backwardKillSentence (self,event):
    
    '''Kill the previous sentence.'''
    
    w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)
    
    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.181:backwardKillSentence
#@+node:ekr.20050920084036.180:backwardKillWord & killWord
def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20050920084036.180:backwardKillWord & killWord
#@+node:ekr.20051216151811:clearKillRing
def clearKillRing (self,event=None):
    
    '''Clear the kill ring.'''
    
    self.killBuffer = []
#@-node:ekr.20051216151811:clearKillRing
#@+node:ekr.20050920084036.185:getClipboard
def getClipboard (self,w):

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except: pass

    return None
#@-node:ekr.20050920084036.185:getClipboard
#@+node:ekr.20050920084036.184:iterateKillBuffer
def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
#@-node:ekr.20050920084036.184:iterateKillBuffer
#@+node:ekr.20050920084036.178:kill, killLine
def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins >= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j > i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
#@-node:ekr.20050920084036.178:kill, killLine
#@+node:ekr.20050920084036.182:killRegion & killRegionSave & helper
def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return
    
    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
#@-node:ekr.20050920084036.182:killRegion & killRegionSave & helper
#@+node:ekr.20050930095323.1:killSentence
def killSentence (self,event):
    
    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)
    
    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930095323.1:killSentence
#@+node:ekr.20050930100733:killWs
def killWs (self,event,undoType=None):
    
    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break
   
    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930100733:killWs
#@+node:ekr.20050930091642.1:yank
def yank (self,event):
    
    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        w.insert(i,s) # Insert the text, marked with the 'kb' tag.
        w.tag_add('kb',w.toGuiIndex(i),w.toGuiIndex(i+len(s)))
        w.setInsertPoint(i+len(s))
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930091642.1:yank
#@+node:ekr.20050930091642.2:yankPop
def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    ins = w.getInsertPoint()
    t,t1 = g.convertPythonIndexToRowCol(s,ins)
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        s = clip_text or self.kbiterator.next()
        r = w.tag_ranges('kb') ###
        if r:
            r1,r2 = r
            r1,r2 = w.toPythonIndex(r1),w.toPythonIndex(r2)
            if r1 == ins:
                w.delete(r1,r2)
        w.tag_delete('kb') ###
        w.insert('insert',s,('kb')) ###
        w.setInsertPoint(ins)
#@-node:ekr.20050930091642.2:yankPop
#@+node:ekr.20050920084036.128:zapToCharacter
def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return
    
    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        if ch.isspace(): return
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.128:zapToCharacter
#@-node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
        
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@+node:ekr.20031218072017.1493:undoRedoText (passed)
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.
    
    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl
    
    << Compute the result using p's body text >>
    p.setTnodeText(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText (passed)
#@-node:ekr.20061009152210.1:Fixed undo problems with yank/kill
#@+node:ekr.20061101174435:Fixed clone-drag problem
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991369

The bindings to f.f.OnControlKeyDown/Up were mistakenly deleted in createOuterFrames.

@color
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # f.top.bind("<Activate>",f.OnActivateLeoEvent)
    # f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        << set vdrag, childFlag >>
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            << drag p to vdrag >>
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    
    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging (tkTree)
#@-node:ekr.20061101174435:Fixed clone-drag problem
#@+node:ekr.20061110214440:Made sure all ancestors expanded when select a body editor with multiple body editors
#@+node:ekr.20061017083312:selectEditor (tkBody)
def selectEditor(self,w):
    
    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.app.gui.widget_name(w),id(w),g.callers())
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    # Inactivate the previously active editor.
    # Don't capture ivars here! selectMainEditor keeps them up-to-date.
    for key in d.keys():
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            break
    else:
        if trace: g.trace('no active editor!')
    
    # Careful, leo_p may not exist.
    if not c.positionExists(w.leo_p):
        if trace: g.trace('does not exist',w.leo_name)
        for p2 in c.allNodes_iter():
            if p2.v == w.leo_v:
                w.leo_p = p2.copy()
                break
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            if trace: g.trace('previously deleted node')
            return 'break'

    self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
    w.leo_active = True
    c.frame.tree.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocusNow()
    return 'break'
#@nonl
#@+node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)
    
if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
#@-node:ekr.20061017083312.1:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20061017083312:selectEditor (tkBody)
#@-node:ekr.20061110214440:Made sure all ancestors expanded when select a body editor with multiple body editors
#@+node:ekr.20070120073419:Fixed bug in CheckVersion
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4112347
By: niccl

I've just found two places where Tk 8.5 breaks Leo:
Two calls to CheckVersion, with tk_patchlevel as a parameter, in leoTkInterGui.py.

Since Tk 8.5 isn't formally released, the patch level is 8.5a5 (at least in
the version I'm using). CheckVersion expects everything to be a digit, and so
barfs on the 5a5. I solved it very crudely by scanning the string returned when
getting the tk_patchlevel and stopping if there's any non-digit and non '.'.
That way I end up with '8.5' as the string to go to check version, and it works
fine.

@color
#@nonl
#@+node:ekr.20060921100435:CheckVersion (EKR) & helper
# Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition=">=",stringCompare=None,delimiter='.',trace=False):
    
    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 < n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 < n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('<',  vals1 <  vals2), ('<=', vals1 <= vals2),
        ('>',  vals1 >  vals2), ('>=', vals1 >= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
    
    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result
#@nonl
#@+node:ekr.20070120123930:CheckVersionToInt
def CheckVersionToInt (s):
    
    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit(): aList.append(ch)
            else: break
        if aList:
            s = string.join(aList)
            return int(s)
        else:
            return 0
#@nonl
#@-node:ekr.20070120123930:CheckVersionToInt
#@+node:ekr.20070120125007:test_CheckVersionToInt
def test_CheckVersionToInt (*args):
    
    assert g.CheckVersionToInt('12') == 12,'fail 1'
    assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
    assert g.CheckVersionToInt('b2') == 0, 'fail 3'
#@nonl
#@-node:ekr.20070120125007:test_CheckVersionToInt
#@-node:ekr.20060921100435:CheckVersion (EKR) & helper
#@-node:ekr.20070120073419:Fixed bug in CheckVersion
#@+node:ekr.20061128083024:Fixed bugs arising from new reorg
#@+node:ekr.20061114165911:Fixed several unit tests that failed with bad selection
# The problem was that the unit test code must now specify the initial insert point.
#@nonl
#@+node:ekr.20050920084036.75:backToIndentation
def backToIndentation (self,event):
    
    '''Position the point at the first non-blank character on the line.'''
    
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i < j and s[i] in (' \t'):
        i += 1
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.75:backToIndentation
#@+node:ekr.20061008140603:runEditCommandTest
def runEditCommandTest (c,p):
    
    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)
    
    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))
    
    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        #g.trace(repr(sel1[0]),repr(sel1[1]))
        w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s2),repr(s1))
        sel3 = w.getSelectionRange()
        ins = w.toGuiIndex(w.getInsertPoint())
        #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
        # Convert both selection ranges to gui indices.
        sel2_orig = sel2
        # g.trace(w)
        i,j = sel2 ; sel2 = w.toGuiIndex(i),w.toGuiIndex(j)
        i,j = sel3 ; sel3 = w.toGuiIndex(i),w.toGuiIndex(j)
        assert sel2 == sel3, 'mismatch in sel\nexpected: %s = %s, got: %s' % (sel2_orig,sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate(False) # Don't redraw.
#@nonl
#@-node:ekr.20061008140603:runEditCommandTest
#@+node:ekr.20061113151148.21:setInsertPoint
def setInsertPoint (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    # g.trace(i,g.callers())
    Tk.Text.mark_set(w,'insert',i)
#@-node:ekr.20061113151148.21:setInsertPoint
#@+node:ekr.20061113151148.22:setSelectionRange
def setSelectionRange (self,i,j,insert=None): # tkTextWidget
    
    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    
    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())
    
    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, ">", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
#@-node:ekr.20061113151148.22:setSelectionRange
#@+node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117085824:w.toGuiIndex
def toGuiIndex (self,i):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # This *must* be 'end-1c', even if other code must change.
        s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i
#@nonl
#@-node:ekr.20061117085824:w.toGuiIndex
#@+node:ekr.20061117085824.1:w.toPythonIndex
def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
#@-node:ekr.20061117085824.1:w.toPythonIndex
#@+node:ekr.20061117085824.2:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):
    
    return '%s.%s' % (row+1,col)
#@nonl
#@-node:ekr.20061117085824.2:w.rowColToGuiIndex
#@-node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@-node:ekr.20061114165911:Fixed several unit tests that failed with bad selection
#@+node:ekr.20061114074335:Fixed change bugs
@nocolor

- There was a call to t.setSelectionRanget(t,...)
- No progress is being made in change, then find.

@color
#@nonl
#@+node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117085824:w.toGuiIndex
def toGuiIndex (self,i):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # This *must* be 'end-1c', even if other code must change.
        s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i
#@nonl
#@-node:ekr.20061117085824:w.toGuiIndex
#@+node:ekr.20061117085824.1:w.toPythonIndex
def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
#@-node:ekr.20061117085824.1:w.toPythonIndex
#@+node:ekr.20061117085824.2:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):
    
    return '%s.%s' % (row+1,col)
#@nonl
#@-node:ekr.20061117085824.2:w.rowColToGuiIndex
#@-node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.
    
    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    
    s = w.getAllText()
    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        # g.trace("wrap done")
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        return None, None
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):
    
    if swapij and backwards: i,j = j,i
        
    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1
        
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
#@+node:ekr.20061207172210:patternLen
#@-node:ekr.20061207172210:patternLen
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    
    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):
    
    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):
    
    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'
    
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    
    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))
    
    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):
    
    '''Carefully replace backslashes in a search pattern.'''
    
    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.
    
    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@-node:ekr.20031218072017.3077:search & helpers
#@+node:ekr.20061113151148.22:setSelectionRange
def setSelectionRange (self,i,j,insert=None): # tkTextWidget
    
    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    
    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())
    
    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, ">", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
#@-node:ekr.20061113151148.22:setSelectionRange
#@+node:ekr.20061113151148.21:setInsertPoint
def setInsertPoint (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    # g.trace(i,g.callers())
    Tk.Text.mark_set(w,'insert',i)
#@-node:ekr.20061113151148.21:setInsertPoint
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):
    
    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start > end: start,end = end,start
    if start == end:
        g.es("No text selected") ; return False
        
    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text
    
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
#@+node:ekr.20060526201951:makeRegexSubs
def makeRegexSubs(self,s,groups):
    
    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''
    
    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\',j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
#@-node:ekr.20060526201951:makeRegexSubs
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible()
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20061114074335:Fixed change bugs
#@+node:ekr.20061114092244:(Fixed match-brackets command)
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    # g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace(changed)
    if changed:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)
    
    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75
    
    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
                                                            
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s[i:j]))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]
        
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@+node:ekr.20061113151148.12:flashCharacter
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toGuiIndex(index),w.toGuiIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count > 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass ; g.es_exception()
#@nonl
#@-node:ekr.20061113151148.12:flashCharacter
#@+node:ekr.20031218072017.1827:c.findMatchingBracket & helper
def findMatchingBracket (self,event=None):
    
    '''Select the text between matching brackets.'''
    
    c = self ; w = c.frame.body.bodyCtrl
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    s = w.getAllText()
    ins = w.getInsertPoint()
    ch1 = 0 <= ins-1 < len(s) and s[ins-1] or ''
    ch2 = 0 <= ins   < len(s) and s[ins] or ''
    # g.trace(repr(ch1),repr(ch2))

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = max(0,ins-1)
    elif ch2 in brackets:
        ch = ch2 ; index = ins
    else:
        return
    
    index2 = self.findMatchingBracketHelper(s,ch,index)
    # g.trace('index,index2',index,index2)
    if index2 is not None:
        if index2 < index:
            w.setSelectionRange(index2,index+1,insert=index2+1)
        else:
            w.setSelectionRange(index,index2+1,insert=index2+1)
        w.see(index2)
    else:
        g.es("unmatched '%s'",ch)
#@nonl
#@+node:ekr.20061113221414:findMatchingBracketHelper
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findMatchingBracketHelper(self,s,ch,index):
    
    c = self
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    # g.trace(repr(ch),repr(match_ch))
    level = 0
    while 1:
        if forward and index >= len(s):
            # g.trace("not found")
            return None
        ch2 = 0 <= index < len(s) and s[index] or ''
        # g.trace('forward',forward,'ch2',repr(ch2),'index',index)
        if ch2 == ch:
            level += 1
        if ch2 == match_ch:
            level -= 1
            if level <= 0:
                return index
        if not forward and index <= 0:
            # g.trace("not found")
            return None
        index += g.choose(forward,1,-1)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@-node:ekr.20061113221414:findMatchingBracketHelper
#@-node:ekr.20031218072017.1827:c.findMatchingBracket & helper
#@-node:ekr.20061114092244:(Fixed match-brackets command)
#@+node:ekr.20061114224545:Fixed off-by-one error in go-to-line-number command
#@-node:ekr.20061114224545:Fixed off-by-one error in go-to-line-number command
#@+node:ekr.20061115153601:Fixed crash in backwardDeleteCharacters
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):
    
    '''Delete the character to the left of the cursor.'''
    
    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return
    
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    #g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@-node:ekr.20061115153601:Fixed crash in backwardDeleteCharacters
#@+node:ekr.20061103101545:(Fix autocompletion problems)
@nocolor

- Typing return in calltips should work as in autocompletion:
  Don't wipe out the suggested text.

- (done) Suppress scrolling of body pane!
  The problem was the call to c.setBodyString().

- (done) Make sure to recolor text at end.

@color
#@-node:ekr.20061103101545:(Fix autocompletion problems)
#@+node:ekr.20061117071250:(Fixed index problems due to changing w.toGuiIndex)
# The problem was in a special case (for only one line) in g.convertPythonIndexToRowCol
# This special case is now covered in the unit test.
#@nonl
#@+node:ekr.20061117084407.1:Removed no-longer needed tests for newlines
#@+node:ekr.20061031170011.13:getEditableTextRange
def getEditableTextRange (self):
    
    k = self ; w = self.widget
    s = w.getAllText()
    # g.trace(len(s),repr(s))

    i = len(k.mb_prefix)
    j = len(s)
    return i,j
#@nonl
#@-node:ekr.20061031170011.13:getEditableTextRange
#@-node:ekr.20061117084407.1:Removed no-longer needed tests for newlines
#@+node:ekr.20050315073003: Index utilities... (leoGlobals) (passed)
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol
def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i <= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex
def convertRowColToPythonIndex (s,row,col):
    
    '''Convert zero-based row/col indices into a python index into string s.'''
    
    if row < 0: return 0
    
    lines = g.splitLines(s)

    if row >= len(lines):
        return len(s)
        
    col = min(col, len(lines[row]))

    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex
#@-node:ekr.20050315073003: Index utilities... (leoGlobals) (passed)
#@+node:ekr.20061113151148.22:setSelectionRange
def setSelectionRange (self,i,j,insert=None): # tkTextWidget
    
    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)
    
    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())
    
    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, ">", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
#@-node:ekr.20061113151148.22:setSelectionRange
#@+node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117085824:w.toGuiIndex
def toGuiIndex (self,i):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # This *must* be 'end-1c', even if other code must change.
        s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i
#@nonl
#@-node:ekr.20061117085824:w.toGuiIndex
#@+node:ekr.20061117085824.1:w.toPythonIndex
def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0
    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print(i)
    return i
#@-node:ekr.20061117085824.1:w.toPythonIndex
#@+node:ekr.20061117085824.2:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):
    
    return '%s.%s' % (row+1,col)
#@nonl
#@-node:ekr.20061117085824.2:w.rowColToGuiIndex
#@-node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@-node:ekr.20061117071250:(Fixed index problems due to changing w.toGuiIndex)
#@+node:ekr.20061117093914.1:Fixed problems in new headlines
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        selectAll = selectAll or c.config.getBool('select_all_text_when_editing_headlines')
        if selectAll:
            w.setSelectionRange(0,'end',insert='end')
        else:
            w.setInsertPoint('end') # Clears insert point.
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.32:tree.setHeadlineText
def setHeadlineText (self,theId,w,s):
    
    """All changes to text widgets should come here."""

    if self.trace_alloc: g.trace('%4d' % (theId), self.textAddr(w),s)
            
    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
#@-node:ekr.20040803072955.32:tree.setHeadlineText
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i
    
    # g.trace('ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i,i,insert=i)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@-node:ekr.20061117093914.1:Fixed problems in new headlines
#@+node:ekr.20061106073414:(Suppressed initial scroll on drag)
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event,p=None):
    
    c = self.c ; tree = self
    
    if not p: p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p,scroll=False)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        << set vdrag, childFlag >>
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            << drag p to vdrag >>
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    
    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging (tkTree)
#@-node:ekr.20061106073414:(Suppressed initial scroll on drag)
#@+node:ekr.20061111084841:(Made sure word search for w. works)
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.
    
    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    
    s = w.getAllText()
    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        # g.trace("wrap done")
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        return None, None
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):
    
    if swapij and backwards: i,j = j,i
        
    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1
        
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
#@+node:ekr.20061207172210:patternLen
#@-node:ekr.20061207172210:patternLen
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    
    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):
    
    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):
    
    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'
    
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    
    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))
    
    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):
    
    '''Carefully replace backslashes in a search pattern.'''
    
    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.
    
    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@-node:ekr.20031218072017.3077:search & helpers
#@-node:ekr.20061111084841:(Made sure word search for w. works)
#@+node:ekr.20061116054917.1:Restore selection in undo/redo
@nocolor
@

What I did:
    
- u.undo and u.redo call c.setCurrentPosition(c.currentPosition()) instead of c.selectPosition(c.currentPosition())
    This accomplishes what is wanted without interfering with selection range.
    
- u.undoTyping and u.redoTyping now call w.setSelectionRange, i.e., they act directly on w.

@color
#@nonl
#@+node:ekr.20031218072017.3605:class undoer
class baseUndoer:
    """The base class of the undoer class."""
    @others
    
class undoer (baseUndoer):
    """A class that implements unlimited undo and redo."""
    pass
#@+node:ekr.20031218072017.3606:undo.__init__ & clearIvars
def __init__ (self,c):

    self.c = c
    self.debug = False # True: enable debugging code in new undo scheme.
    self.debug_print = False # True: enable print statements in debug code.

    self.granularity = c.config.getString('undo_granularity')
    if self.granularity: self.granularity = self.granularity.lower()
    if self.granularity not in ('node','line','word','char'):
        self.granularity = 'line'
    # g.trace('undoer',self.granularity)
    
    self.max_undo_stack_size = c.config.getInt('max_undo_stack_size') or 0

    # Statistics comparing old and new ways (only if self.debug is on).
    self.new_mem = 0
    self.old_mem = 0

    # State ivars...
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False # True if executing an Undo command.
    self.redoing = False # True if executing a Redo command.
    
    # New in 4.2...
    self.optionalIvars = []
#@+node:ekr.20031218072017.3607:clearIvars
def clearIvars (self):
    
    u = self
    
    u.p = None # The position/node being operated upon for undo and redo.

    for ivar in u.optionalIvars:
        setattr(u,ivar,None)
#@-node:ekr.20031218072017.3607:clearIvars
#@-node:ekr.20031218072017.3606:undo.__init__ & clearIvars
#@+node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20060127052111.1:cutStack
def cutStack (self):
    
    u = self ; n = u.max_undo_stack_size

    if n > 0 and u.bead >= n and not g.app.unitTesting:
        
        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads)-1
        while i >= 0:
            bunch = u.beads[i]
            if hasattr(bunch,'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1

        # This work regardless of how many items appear after bead n.
        # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n:]
        u.bead = n-1
        # g.trace('bead:',u.bead,'len(u.beads)',len(u.beads))
#@-node:ekr.20060127052111.1:cutStack
#@+node:EKR.20040526150818:getBead
def getBead (self,n):
    
    '''Set undoer ivars from the bunch at the top of the undo stack.'''
    
    u = self
    if n < 0 or n >= len(u.beads):
        return None

    bunch = u.beads[n]

    self.setIvarsFromBunch(bunch)
    
    return bunch
#@-node:EKR.20040526150818:getBead
#@+node:EKR.20040526150818.1:peekBead
def peekBead (self,n):
    
    u = self
    if n < 0 or n >= len(u.beads):
        return None
    bunch = u.beads[n]
    # g.trace(n,len(u.beads),bunch)
    return bunch
#@-node:EKR.20040526150818.1:peekBead
#@+node:ekr.20060127113243:pushBead
def pushBead (self,bunch):
    
    u = self
    
    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead >= 0 and u.bead < len(u.beads) and u.beads[u.bead]

    if bunch2 and hasattr(bunch2,'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

        # Recalculate the menu labels.
        u.setUndoTypes()
#@-node:ekr.20060127113243:pushBead
#@+node:ekr.20060127070008:setIvarsFromBunch
def setIvarsFromBunch (self,bunch):
    
    u = self

    u.clearIvars()

    if 0: # Debugging.
        print '-' * 40
        keys = bunch.keys()
        keys.sort()
        for key in keys:
            g.trace(key,bunch.get(key))
        print '-' * 20

    for key in bunch.keys():
        val = bunch.get(key)
        # g.trace(key,val)
        setattr(u,key,val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
#@-node:ekr.20060127070008:setIvarsFromBunch
#@+node:ekr.20050126081529:recognizeStartOfTypingWord
def recognizeStartOfTypingWord (self,
    old_lines,old_row,old_col,old_ch, 
    new_lines,new_row,new_col,new_ch):

    __pychecker__ = '--no-argsused' # Ignore all unused arguments here.
        
    ''' A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.
    
    u.setUndoTypingParams calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.
    
    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.
    
    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.'''
    
    # Start a word if new_ch begins whitespace + word
    return not old_ch.isspace() and new_ch.isspace()
#@-node:ekr.20050126081529:recognizeStartOfTypingWord
#@+node:ekr.20031218072017.3613:redoMenuName, undoMenuName
def redoMenuName (self,name):

    if name=="Can't Redo":
        return name
    else:
        return "Redo " + name

def undoMenuName (self,name):

    if name=="Can't Undo":
        return name
    else:
        return "Undo " + name
#@-node:ekr.20031218072017.3613:redoMenuName, undoMenuName
#@+node:ekr.20031218072017.3614:setRedoType, setUndoType
# These routines update both the ivar and the menu label.
def setRedoType (self,theType):
    # g.trace(theType,g.callers(7))
    u = self ; frame = u.c.frame
    
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    
    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel

def setUndoType (self,theType):
    # g.trace(theType,g.callers(7))
    u = self ; frame = u.c.frame
    if type(theType) != type(''):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '<unknown>'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline=g.choose(g.match(name,0,"Can't"),-1,0)
        else:
            underline = realLabel.find("&")
        realLabel = realLabel.replace("&","")
        frame.menu.setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
#@-node:ekr.20031218072017.3614:setRedoType, setUndoType
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):
    
    u = self
    
    # g.trace(g.callers(7))

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")
    
    u.cutStack()
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:EKR.20040530121329:u.restoreTree & helpers
def restoreTree (self,treeInfo):
    
    """Use the tree info to restore all vnode and tnode data,
    including all links."""
    
    u = self
    
    # This effectively relinks all vnodes.
    for v,vInfo,tInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
        u.restoreTnodeUndoInfo(tInfo)
#@+node:ekr.20050415170737.2:restoreVnodeUndoInfo
def restoreVnodeUndoInfo (self,bunch):
    
    """Restore all ivars saved in the bunch."""
    
    v = bunch.v

    v.statusBits = bunch.statusBits
    v._parent    = bunch.parent
    v._next      = bunch.next
    v._back      = bunch.back
    
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = 1
#@-node:ekr.20050415170737.2:restoreVnodeUndoInfo
#@+node:ekr.20050415170812.2:restoreTnodeUndoInfo
def restoreTnodeUndoInfo (self,bunch):
    
    t = bunch.t

    t.headString  = bunch.headString
    t.bodyString  = bunch.bodyString
    t.vnodeList   = bunch.vnodeList
    t.statusBits  = bunch.statusBits
    t._firstChild = bunch.firstChild
    
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        t.unknownAttributes = uA
        t._p_changed = 1
#@-node:ekr.20050415170812.2:restoreTnodeUndoInfo
#@-node:EKR.20040530121329:u.restoreTree & helpers
#@+node:EKR.20040528075307:u.saveTree & helpers
def saveTree (self,p,treeInfo=None):
    
    """Return a list of tuples with all info needed to handle a general undo operation."""

    # WARNING: read this before doing anything "clever"
    << about u.saveTree >>
    
    u = self ; topLevel = (treeInfo == None)
    if topLevel: treeInfo = []

    # Add info for p.v and p.v.t.  Duplicate tnode info is harmless.
    data = (p.v,u.createVnodeUndoInfo(p.v),u.createTnodeUndoInfo(p.v.t))
    treeInfo.append(data)

    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child,treeInfo)
        child = child.next()

    # if topLevel: g.trace(treeInfo)
    return treeInfo
#@+node:EKR.20040530114124:<< about u.saveTree >>
@ 
The old code made a free-standing copy of the tree using v.copy and t.copy.  This looks "elegant" and is WRONG.  The problem is that it can not handle clones properly, especially when some clones were in the "undo" tree and some were not.   Moreover, it required complex adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed to properly restore the vnodes and tnodes.  It creates a list of tuples, on tuple for each vnode in the tree.  Each tuple has the form,

(vnodeInfo, tnodeInfo)

where vnodeInfo and tnodeInfo are dicts contain all info needed to recreate the nodes.  The v.createUndoInfoDict and t.createUndoInfoDict methods correspond to the old v.copy and t.copy methods.

Aside:  Prior to 4.2 Leo used a scheme that was equivalent to the createUndoInfoDict info, but quite a bit uglier.
#@-node:EKR.20040530114124:<< about u.saveTree >>
#@+node:ekr.20050415170737.1:createVnodeUndoInfo
def createVnodeUndoInfo (self,v):
    
    """Create a bunch containing all info needed to recreate a vnode for undo."""
    
    bunch = g.Bunch(
        v = v,
        statusBits = v.statusBits,
        parent     = v._parent,
        next       = v._next,
        back       = v._back,
        # The tnode never changes so there is no need to save it here.
    )
    
    if hasattr(v,'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes

    return bunch
#@-node:ekr.20050415170737.1:createVnodeUndoInfo
#@+node:ekr.20050415170812.1:createTnodeUndoInfo
def createTnodeUndoInfo (self,t):
    
    """Create a bunch containing all info needed to recreate a vnode."""

    bunch = g.Bunch(
        t = t,
        headString = t.headString,
        bodyString = t.bodyString,
        vnodeList  = t.vnodeList[:],
        statusBits = t.statusBits,
        firstChild = t._firstChild,
    )
    
    if hasattr(t,'unknownAttributes'):
        bunch.unknownAttributes = t.unknownAttributes

    return bunch
#@-node:ekr.20050415170812.1:createTnodeUndoInfo
#@-node:EKR.20040528075307:u.saveTree & helpers
#@+node:ekr.20050525151449:u.trace
def trace (self):
    
    ivars = ('kind','undoType')
    
    for ivar in ivars:
        print ivar, getattr(self,ivar)
#@-node:ekr.20050525151449:u.trace
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):
    
    '''Update dirty and marked bits.'''
    
    u = self ; c = u.c
    
    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    dirty   = g.choose(isOld,u.oldDirty,  u.newDirty)
    marked  = g.choose(isOld,u.oldMarked, u.newMarked)
    changed = g.choose(isOld,u.oldChanged,u.newChanged)

    if dirty:   u.p.setDirty(setDescendentsDirty=False)
    else:       u.p.clearDirty()
        
    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    u.c.setChanged(changed)
#@-node:ekr.20050410095424:updateMarks
#@-node:ekr.20050416092908.1:Internal helpers
#@+node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050315134017.4:afterChangeGroup
def afterChangeGroup (self,p,undoType,reportFlag=False,dirtyVnodeList=[]):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''
    
    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return
    
    # g.trace('u.bead',u.bead,'len u.beads',len(u.beads))

    bunch = u.beads[u.bead]
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:
        g.trace('oops: expecting beforeGroup, got %s' % bunch.kind)

    # Set the types & helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType
    
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()
    
    # Tells whether to report the number of separate changes undone/redone.
    bunch.reportFlag = reportFlag
    
    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
    
    # g.trace(u.undoMenuLabel,u.redoMenuLabel)
#@-node:ekr.20050315134017.4:afterChangeGroup
#@+node:ekr.20050315134017.2:afterChangeNodeContents
def afterChangeNodeContents (self,p,command,bunch,dirtyVnodeList=[]):

    '''Create an undo node using d created by beforeChangeNode.'''
    
    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents
    
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBody = p.bodyString()
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newHead = p.headString()
    bunch.newMarked = p.isMarked()
    bunch.newSel = w.getSelectionRange()
    
    u.pushBead(bunch)
#@-node:ekr.20050315134017.2:afterChangeNodeContents
#@+node:ekr.20050315134017.3:afterChangeTree
def afterChangeTree (self,p,command,bunch):

    '''Create an undo node for general tree operations using d created by beforeChangeTree'''
    
    u = self ; c = self.c ; w = c.frame.body.bodyCtrl
    if u.redoing or u.undoing: return
    
    # Set the types & helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree

    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)
    
    u.pushBead(bunch)
#@-node:ekr.20050315134017.3:afterChangeTree
#@+node:ekr.20050424161505:afterClearRecentFiles
def afterClearRecentFiles (self,bunch):
    
    u = self

    bunch.newRecentFiles = g.app.config.recentFiles[:]
    
    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles
    
    u.pushBead(bunch)

    return bunch
#@-node:ekr.20050424161505:afterClearRecentFiles
#@+node:ekr.20050411193627.5:afterCloneNode
def afterCloneNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set types & helpers
    bunch.kind = 'clone'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode

    bunch.newBack = p.back() # 6/15/05
    bunch.newParent = p.parent() # 6/15/05
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.5:afterCloneNode
#@+node:ekr.20050411193627.6:afterDehoist
def afterDehoist (self,p,command):

    u = self
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
    # Set types & helpers
    bunch.kind = 'dehoist'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoDehoistNode
    bunch.redoHelper = u.redoDehoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.6:afterDehoist
#@+node:ekr.20050411193627.8:afterDeleteNode
def afterDeleteNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set types & helpers
    bunch.kind = 'delete'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050411193627.8:afterDeleteNode
#@+node:ekr.20050411193627.7:afterHoist
def afterHoist (self,p,command):
    
    u = self
    if u.redoing or u.undoing: return
    
    bunch = u.createCommonBunch(p)
    
    # Set types & helpers
    bunch.kind = 'hoist'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoHoistNode
    bunch.redoHelper = u.redoHoistNode

    u.pushBead(bunch)
#@-node:ekr.20050411193627.7:afterHoist
#@+node:ekr.20050411193627.9:afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # g.trace(repr(command),g.callers())
    
    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()
    
    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            t = bunch2.t
            afterTree.append(
                g.Bunch(t=t,head=t.headString[:],body=t.bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    u.pushBead(bunch)
#@-node:ekr.20050411193627.9:afterInsertNode
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    
    '''Create an undo node for mark and unmark commands.'''
    
    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.
    
    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    
    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050410110343:afterMoveNode
def afterMoveNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set the types & helpers.
    bunch.kind = 'move'
    bunch.undoType = command
    
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove
    
    bunch.dirtyVnodeList = dirtyVnodeList
    
    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    bunch.newBack   = p.back()
    bunch.newN = p.childIndex()
    bunch.newParent = p.parent()
    
    u.pushBead(bunch)
#@-node:ekr.20050410110343:afterMoveNode
#@-node:ekr.20050318085432.4:afterX...
#@+node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20050315134017.7:beforeChangeGroup
def beforeChangeGroup (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)
    
    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command
    
    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
#@-node:ekr.20050315134017.7:beforeChangeGroup
#@+node:ekr.20050315133212.2:beforeChangeNodeContents
def beforeChangeNodeContents (self,p,oldBody=None,oldHead=None):
    
    '''Return data that gets passed to afterChangeNode'''
    
    u = self
    
    bunch = u.createCommonBunch(p)
    
    bunch.oldBody = oldBody or p.bodyString()
    bunch.oldHead = oldHead or p.headString()

    return bunch
#@-node:ekr.20050315133212.2:beforeChangeNodeContents
#@+node:ekr.20050315134017.6:beforeChangeTree
def beforeChangeTree (self,p):
    
    # g.trace(p.headString())
    
    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)
    
    return bunch
#@-node:ekr.20050315134017.6:beforeChangeTree
#@+node:ekr.20050424161505.1:beforeClearRecentFiles
def beforeClearRecentFiles (self):
    
    u = self ; p = u.c.currentPosition()
    
    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]

    return bunch
#@-node:ekr.20050424161505.1:beforeClearRecentFiles
#@+node:ekr.20050412080354:beforeCloneNode
def beforeCloneNode (self,p):
    
    u = self

    bunch = u.createCommonBunch(p)

    return bunch
#@-node:ekr.20050412080354:beforeCloneNode
#@+node:ekr.20050411193627.3:beforeDeleteNode
def beforeDeleteNode (self,p):
    
    u = self

    bunch = u.createCommonBunch(p)
    
    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()
    
    return bunch
#@-node:ekr.20050411193627.3:beforeDeleteNode
#@+node:ekr.20050411193627.4:beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):
    
    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone
    
    if pasteAsClone:
        # Save the list of bunches created by fc.createVnode.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@-node:ekr.20050411193627.4:beforeInsertNode
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command
    
    return bunch
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050410110215:beforeMoveNode
def beforeMoveNode (self,p):
    
    u = self
    
    bunch = u.createCommonBunch(p)
    
    bunch.oldBack = p.back()
    bunch.oldN = p.childIndex()
    bunch.oldParent = p.parent()

    return bunch
#@-node:ekr.20050410110215:beforeMoveNode
#@+node:ekr.20050318085432.2:createCommonBunch
def createCommonBunch (self,p):
    
    '''Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p.'''
    
    u = self ; c = u.c ; w = c.frame.body.bodyCtrl
    
    return g.Bunch(
        oldChanged = c.isChanged(),
        oldDirty = p.isDirty(),
        oldMarked = p.isMarked(),
        oldSel = w.getSelectionRange(),
        p = p.copy(),
    )
#@-node:ekr.20050318085432.2:createCommonBunch
#@-node:ekr.20050318085432.3:beforeX...
#@+node:ekr.20031218072017.3610:canRedo & canUndo
# Translation does not affect these routines.

def canRedo (self):

    u = self
    return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

    u = self
    return u.undoMenuLabel != "Can't Undo"
#@-node:ekr.20031218072017.3610:canRedo & canUndo
#@+node:ekr.20031218072017.3609:clearUndoState
def clearUndoState (self):

    """Clears then entire Undo state.
    
    All non-undoable commands should call this method."""
    
    u = self
    u.setRedoType("Can't Redo")
    u.setUndoType("Can't Undo")
    u.beads = [] # List of undo nodes.
    u.bead = -1 # Index of the present bead: -1:len(beads)
    u.clearIvars()
#@-node:ekr.20031218072017.3609:clearUndoState
#@+node:ekr.20031218072017.3611:enableMenuItems
def enableMenuItems (self):

    u = self ; frame = u.c.frame
    
    menu = frame.menu.getMenu("Edit")
    frame.menu.enableMenu(menu,u.redoMenuLabel,u.canRedo())
    frame.menu.enableMenu(menu,u.undoMenuLabel,u.canUndo())
#@-node:ekr.20031218072017.3611:enableMenuItems
#@+node:ekr.20050525151217:getMark & rollbackToMark (no longer used)
if 0:
    def getMark (self):
    
        __pychecker__ = '--no-classattr' # self.bead does, in fact, exist.
        
        return self.bead
        
    def rollbackToMark (self,n):
        
        u = self
    
        u.bead = n
        u.beads = u.beads[:n+1]
        u.setUndoTypes()
        
    rollBackToMark = rollbackToMark
#@-node:ekr.20050525151217:getMark & rollbackToMark (no longer used)
#@+node:ekr.20031218072017.1490:setUndoTypingParams
def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    '''Save enough information so a typing operation can be undone and redone.

    Do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.'''

    u = self ; c = u.c
    trace = False # Can cause unit tests to fail.
    << return if there is nothing to do >>
    # g.trace(undo_type,g.callers(7))
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    return bunch
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@
Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if trace:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d

bunch.dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
if not p.isDirty():
    bunch.dirtyVnodeList.append(p.copy())
bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@-node:ekr.20031218072017.3608:Externally visible entries
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):
    
    '''Redo the operation undone by the last undo.'''

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.redoHelper: u.redoHelper()
        else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.redoing = False
        u.bead += 1
        u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):
    
    u = self ; c = u.c
    
    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.hoist()
    
def redoDehoistNode (self):
    
    u = self ; c = u.c
    
    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()
    
    u.groupCount += 1

    
    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        c.beginUpdate()
        try:
            for z in bunch.items:
                self.setIvarsFromBunch(z)
                if z.redoHelper:
                    # g.trace(z.redoHelper)
                    z.redoHelper() ; count += 1
                else:
                    g.trace('oops: no redo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1
    
    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)
        
    c.selectPosition(p)
    newSel and c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):
    
    u = self ; c = u.c ; w = c.frame.body.bodyCtrl
    
    # Restore the body.
    u.p.setTnodeText(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)
    
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.
    
    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20050526125801:redoMark
def redoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('new')
    
    if u.groupCount == 0:
    
        for v in u.dirtyVnodeList:
            v.t.setDirty()
        
        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot=oldRoot)
        
    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
        
    c.selectPosition(u.p)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
        
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""
    
    u = self ; c = u.c
    # g.trace(g.callers(7))
    
    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return
        
    # g.trace(u.undoType)
    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.undoHelper: u.undoHelper()
        else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.undoing = False
        u.bead -= 1
        u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty() # New in 4.4b3.
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
    
def undoDehoistNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('old')
    
    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.clearDirty()
        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        u.p.moveToRoot(oldRoot=c.rootPosition())

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
        
    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl
    
    u.p.setTnodeText(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead) # New in 4.4b2.

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):
    
    '''Redo replacement of an entire tree.'''
    
    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):
    
    '''Replace p and its subtree using old_data during undo.'''
    
    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c
    
    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.bodyString())
    
    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20031218072017.1493:undoRedoText (passed)
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.
    
    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl
    
    << Compute the result using p's body text >>
    p.setTnodeText(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText (passed)
#@-node:ekr.20031218072017.2039:undo & helpers...
#@-node:ekr.20031218072017.3605:class undoer
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p,updateBeadList=True):
    
    """Select a new position."""

    c = self
    
    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)
    
    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20040803072955.128:leoTree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True,scroll=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame
    body = w = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not c.positionExists(p):
        # g.trace('does not exist',p.headString())
        return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll:
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    c.frame.body.selectMainEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview = body.getYScrollPosition()
insertSpot = c.frame.body.getInsertPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if c.edit_widget(old_p):
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing newlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
w.setAllText(s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    w.setYScrollPosition(first)

if p.v and p.v.t.insertSpot != None:
    spot = p.v.t.insertSpot
    w.setInsertPoint(spot)
    w.see(spot)
else:
    w.setInsertPoint(0)
        
# g.trace("select:",p.headString())
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:leoTree.select
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position. For internal use only.
    
    Client code should use c.selectPosition instead."""
    
    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
            
        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        c.setRootPosition(c.findRootPosition(c._currentPosition))
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
        
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@-node:ekr.20061116054917.1:Restore selection in undo/redo
#@+node:ekr.20061116054917.2:Improved selection in several commands and undo
# Indent and Undent did not set selection properly.
# Improved setSelectionAreas & getBodyLines: these required subtle changes in several methods.
#@nonl
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph (self,event=None):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = w.getAllText()
oldSel =  w.getSelectionRange()
oldYview = body.getYScrollPosition()

head,lines,tail = c.findBoundParagraph()
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
trailingNL = lines and lines[-1].endswith('\n')
lines = [g.choose(z.endswith('\n'),z[:-1],z) for z in lines]

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult)
if trailingNL: result = result + '\n'
#@nonl
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
junk, ins = body.setSelectionAreas(head,result,tail)

# Advance to the next paragraph.
s = w.getAllText()
ins += 1 # Move past the selection.
while ins < len(s):
    i,j = g.getLine(s,ins)
    line = s[i:j]
    if line.startswith('@') or line.isspace():
        ins = j+1
    else:
        ins = i ; break

changed = original != head + result + tail
if changed:
    undoType = g.choose(changed,"Reformat Paragraph",None)
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

w.setSelectionRange(ins,ins,insert=ins)
w.see(ins)
if changed:
    c.recolor()
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)
    
    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    i = len(head)
    j = max(i,len(head)+len(middle)-1)
    newSel = i,j
    body.setSelectionRange(newSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel or newSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.seeInsertPoint()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@+node:ekr.20031218072017.4037:setSelectionAreas (leoBody)
def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    w = self.bodyCtrl
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    return i,j
#@-node:ekr.20031218072017.4037:setSelectionAreas (leoBody)
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):
    
    """Return head,lines,tail where:
        
    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection)
    lines is a list of lines containing the selected text (or the line containing the insert point if no selection)
    after is a string all lines after the selected text
    (or the text after the insert point if no selection)"""

    c = self ; body = c.frame.body ; w = body.bodyCtrl
    oldVview = body.getYScrollPosition()

    if expandSelection:
        s = w.getAllText()
        head = tail = ''
        oldSel = 0,len(s)
        lines = g.splitLines(s) # Retain the newlines of each line.
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,s,tail = body.getSelectionLines()
        lines = g.splitLines(s) # Retain the newlines of each line.
    
        # Expand the selection.
        i = len(head)
        j = max(i,len(head)+len(s)-1)
        oldSel = i,j
    
    return head,lines,tail,oldSel,oldVview # string,list,string,tuple.
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.2377:getSelectionLines (leoBody)
def getSelectionLines (self):
    
    """Return before,sel,after where:
        
    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)"""
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return '','',''
    
    # At present, called only by c.getBodyLines.
    w = self.bodyCtrl
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if i == j:
        i,j = g.getLine(s,i)
    else:
        i,junk = g.getLine(s,i)
        junk,j = g.getLine(s,j)
   
    
    before = g.toUnicode(s[0:i],g.app.tkEncoding)
    sel    = g.toUnicode(s[i:j],g.app.tkEncoding)
    after  = g.toUnicode(s[j:len(s)],g.app.tkEncoding)
    
    # g.trace(i,j,'sel',repr(s[i:j]),'after',repr(after))
    return before,sel,after # 3 strings.
#@-node:ekr.20031218072017.2377:getSelectionLines (leoBody)
#@+node:ekr.20031218072017.4030:getInsertLines (passed)
def getInsertLines (self):
    
    """Return before,after where:
        
    before is all the lines before the line containing the insert point.
    sel is the line containing the insert point.
    after is all the lines after the line containing the insert point.
    
    All lines end in a newline, except possibly the last line."""
    
    w = self.bodyCtrl
    s = w.getAllText()
    insert = w.getInsertPoint()
    i,j = g.getLine(s,insert)
    before = s[0:i]
    ins = s[i:j]
    after = s[j:]

    before = g.toUnicode(before,g.app.tkEncoding)
    ins    = g.toUnicode(ins,   g.app.tkEncoding)
    after  = g.toUnicode(after ,g.app.tkEncoding)

    return before,ins,after
#@-node:ekr.20031218072017.4030:getInsertLines (passed)
#@+node:ekr.20061127102233:Found: .getBodyLines
#@+node:ekr.20050920084036.141:removeBlankLines
def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20050920084036.141:removeBlankLines
#@+node:ekr.20031218072017.1821:convertBlanks (test)
def convertBlanks (self,event=None):
    
    '''Convert all blanks to tabs in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Blanks'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    
    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1821:convertBlanks (test)
#@+node:ekr.20031218072017.1822:convertTabs (test)
def convertTabs (self,event=None):
    
    '''Convert all tabs to blanks in the selected node.'''

    c = self ; changed = False ; dirtyVnodeList = []
    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if tabWidth:
        result = []
        for line in lines:
            i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
            s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
            if s != line: changed = True
            result.append(s)
        if changed:
            undoType = 'Convert Tabs'
            result = ''.join(result)
            oldSel = None
            dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo

    return changed,dirtyVnodeList
#@-node:ekr.20031218072017.1822:convertTabs (test)
#@+node:ekr.20031218072017.1824:dedentBody (test)
def dedentBody (self,event=None):
    
    '''Remove one tab's worth of indentation from all presently selected lines.'''
    
    c = self ; current = c.currentPosition() ; undoType='Unindent'
    
    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20031218072017.1824:dedentBody (test)
#@+node:ekr.20031218072017.1706:extract (test)
def extract (self,event=None):
    
    '''Create child node from the elected body text, deleting all selected text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if lines:
        headline = lines[0].strip()
        del lines[0]
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+'\n',None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.1706:extract (test)
#@+node:ekr.20031218072017.1708:extractSection (test)
def extractSection (self,event=None):
    
    '''Create a section definition node from the selected body text.
    The text must start with a section reference.  This becomes the new child's headline.
    The body text of the new child node contains all selected lines that follow the section reference line.'''

    c = self ; u = c.undoer ; undoType='Extract Section'
    current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = ''.join(strippedLines)
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType=undoType,oldSel=None,oldYview=oldYview)
        u.afterChangeGroup(current,undoType=undoType)
    finally:
        c.endUpdate()
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection (test)
#@+node:ekr.20031218072017.1710:extractSectionNames (test)
def extractSectionNames(self,event=None):
    
    '''Create child nodes for every section reference in the selected text.
    The headline of each new child node is the section reference.
    The body of each child node is empty.'''

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setSelectionRange(oldSel)
    body.setFocus()
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)
        
if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames (test)
#@+node:ekr.20031218072017.1830:indentBody (test)
def indentBody (self,event=None):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; current = c.currentPosition() ; undoType='Indent Region'
    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20031218072017.1830:indentBody (test)
#@+node:ekr.20050312114529.1:addComments (test)
def addComments (self,event=None):
    
    '''Convert all selected lines in the body text to comment lines.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    d1,d2,d3 = d.get('delims') # d1 is the line delim.
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    d2 = d2 or '' ; d3 = d3 or ''
    if d1: openDelim,closeDelim = d1+' ',''
    else:  openDelim,closeDelim = d2+' ',d3+' '

    # Comment out non-blank lines.
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line,0)
            result.append(line[0:i]+openDelim+line[i:]+closeDelim)
        else:
            result.append(line)

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Add Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.1:addComments (test)
#@+node:ekr.20050312114529.2:deleteComments (test)
def deleteComments (self,event=None):
    
    '''Remove one level of comment delimiters from all selected lines in the body text.'''

    c = self ; p = c.currentPosition()
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = ''.join(result)
    c.updateBodyPane(head,result,tail,undoType='Delete Comments',oldSel=None,oldYview=oldYview)
#@-node:ekr.20050312114529.2:deleteComments (test)
#@-node:ekr.20061127102233:Found: .getBodyLines
#@-node:ekr.20061116054917.2:Improved selection in several commands and undo
#@+node:ekr.20061119060008:Fixed bug in end-of-line commands
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.
    
    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)
        
    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    
    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j+1)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20051218171457:movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i >= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j >= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i < j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 < len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 < len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 > j2: return

    self.moveToHelper(event,i2+1,extend)
#@-node:ekr.20051218171457:movePastCloseHelper
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()
    
    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1
    
    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051213094517:backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()
    
    while i >= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j >= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0
    
    while j < i and s[j].isspace():
        j += 1
        
    if j < i:
        self.moveToHelper(event,j,extend)
#@-node:ekr.20051213094517:backSentenceHelper
#@+node:ekr.20050920084036.137:forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
#@-node:ekr.20050920084036.137:forwardSentenceHelper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1
        
    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):
    
    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.148:buffers
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)
    
def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
#@-node:ekr.20050920084036.148:buffers
#@+node:ekr.20051213080533:characters
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)
    
def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
#@-node:ekr.20051213080533:characters
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocusNow(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20050920084036.136:exchangePointMark
def exchangePointMark (self,event):
    
    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''
    
    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return
    
    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
#@-node:ekr.20050920084036.136:exchangePointMark
#@+node:ekr.20061007082956:extend-to-line
def extendToLine (self,event):
    
    '''Select the line at the cursor.'''
    
    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@-node:ekr.20061007082956:extend-to-line
#@+node:ekr.20061007214835.4:extend-to-sentence
def extendToSentence (self,event):
    
    '''Select the line at the cursor.'''
    
    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@nonl
#@-node:ekr.20061007214835.4:extend-to-sentence
#@+node:ekr.20060116074839.2:extend-to-word
def extendToWord (self,event):
    
    '''Select the word at the cursor.'''
    
    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not g.isWordChar(s[i]):
        i -= 1
    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word
#@+node:ekr.20051218141237:lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)
    
def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)
    
def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)
    
def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:lines
#@+node:ekr.20050920084036.140:movePastClose
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@-node:ekr.20050920084036.140:movePastClose
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)
    
def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)
        
def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@-node:ekr.20061119060008:Fixed bug in end-of-line commands
#@+node:ekr.20061127170820:Fixed new bug in kill-line
#@+node:ekr.20050920084036.178:kill, killLine
def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins >= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j > i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
#@-node:ekr.20050920084036.178:kill, killLine
#@-node:ekr.20061127170820:Fixed new bug in kill-line
#@+node:ekr.20061127161813:Replacing selection not done properly in headline
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if not w: return
    
    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # if self.trace_edit and not g.app.unitTesting:
            # if changed:
                # g.trace('changed: old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(scroll=False) # New in 4.4.1
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i
    
    # g.trace('ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i,i,insert=i)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@-node:ekr.20040803072955.90:head key handlers
#@-node:ekr.20061127161813:Replacing selection not done properly in headline
#@+node:ekr.20061127150919:Fixed paragraph commands
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20061113151148.8:tag_add
# The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):
    
    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_add(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_add(w,tagName,i,j,*args)
        
#@-node:ekr.20061113151148.8:tag_add
#@+node:ekr.20050920084036.96:extend-to-paragraph & helper
def extendToParagraph (self,event):
    
    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i > 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j < len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):
    
    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j < len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break
        
    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:extend-to-paragraph & helper
#@+node:ekr.20051218133207.1:forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1
        
    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper
#@+node:ekr.20051218133207:backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):
    
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper
#@+node:ekr.20050920084036.99:backwardKillParagraph
def backwardKillParagraph (self,event):
    
    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i > 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.99:backwardKillParagraph
#@+node:ekr.20050920084036.98:killParagraph
def killParagraph (self,event):
    
    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.98:killParagraph
#@-node:ekr.20061127150919:Fixed paragraph commands
#@+node:ekr.20061130092144:UNL's are not being shown
# The text frame somehow was not being packed as usual.
#@nonl
#@+node:ekr.20041223105114.1:Status line convenience methods
def createStatusLine (self):
    if not self.statusLine:
        self.statusLine  = self.statusLineClass(self.c,self.outerFrame)
    return self.statusLine

def clearStatusLine (self):
    self.statusLine and self.statusLine.clear()
    
def disableStatusLine (self,background=None):
    self.statusLine and self.statusLine.disable(background)

def enableStatusLine (self,background="white"):
    self.statusLine and self.statusLine.enable(background)

def getStatusLine (self):
    return self.statusLine
    
getStatusObject = getStatusLine
    
def putStatusLine (self,s,color=None):
    self.statusLine and self.statusLine.put(s,color)
    
def setFocusStatusLine (self):
    self.statusLine and self.statusLine.setFocus()

def statusLineIsEnabled(self):
    return self.statusLine and self.statusLine.isEnabled()
    
def updateStatusLine(self):
    self.statusLine and self.statusLine.update()
#@nonl
#@-node:ekr.20041223105114.1:Status line convenience methods
#@+node:ekr.20041223104933:class tkStatusLineClass
class tkStatusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = w = g.app.gui.bodyTextWidget(
        self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    w.bind("<Button-1>", self.onActivate)
    self.show()
    
    c.frame.statusFrame = self.statusFrame
    c.frame.statusLabel = self.labelWidget
    c.frame.statusText  = self.textWidget
    
#@nonl
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    w = self.textWidget
    if not w: return
    
    w.configure(state="normal")
    w.delete(0,"end")
    w.configure(state="disabled")
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    c = self.c ; w = self.textWidget
    if w:
        if not background:
            background = self.statusFrame.cget("background")
        w.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; w = self.textWidget
    if w:
        w.configure(state="normal",background=background)
        c.widgetWantsFocus(w)
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    w = self.textWidget
    if w:
        return w.getAllText()
    else:
        return ""
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)
        
show = pack
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
def put(self,s,color=None):
    
    w = self.textWidget
    if not w: return
    
    w.configure(state="normal")
    w.insert("end",s)

    if color:
        if color not in self.colorTags:
            self.colorTags.append(color)
            w.tag_config(color,foreground=color)
        w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        w.tag_config("black",foreground="black")
        w.tag_add("black","end")
    
    w.configure(state="disabled")
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update (statusLine)
def update (self):
    
    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if g.app.killed or not self.isVisible:
        return

    s = bodyCtrl.getAllText()    
    index = bodyCtrl.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,index)
    if col > 0:
        s2 = s[index-col:index]
        s2 = g.toUnicode(s2,g.app.tkEncoding)
        col = g.computeWidth (s2,c.tab_width)

    # Important: this does not change the focus because labels never get focus.
    self.labelWidget.configure(text="line %d, col %d" % (row,col))
    self.lastRow = row
    self.lastCol = col
#@-node:ekr.20031218072017.1733:update (statusLine)
#@-node:ekr.20041223104933:class tkStatusLineClass
#@-node:ekr.20061130092144:UNL's are not being shown
#@+node:ekr.20061129104116:Select-all and delete shows too much in body pane
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    # g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace(changed)
    if changed:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)
    
    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75
    
    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
                                                            
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s[i:j]))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]
        
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):
    
    '''Delete the character to the left of the cursor.'''
    
    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return
    
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    #g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20061113151148.19:selectAllText
def selectAllText (self,insert=None): # tkTextWidget
    
    '''Select all text of the widget, *not* including the extra newline.'''
    
    w = self ; s = w.getAllText()
    if insert is None: insert = len(s)
    w.setSelectionRange(0,len(s),insert=insert)
#@-node:ekr.20061113151148.19:selectAllText
#@-node:ekr.20061129104116:Select-all and delete shows too much in body pane
#@+node:ekr.20061206103433:Fixed colorizer bug: section references not colored properly
#@+node:ekr.20031218072017.1914:doNowebSecRef (colorizer)
def doNowebSecRef (self,s,i):

    c = self.c
    self.tag("nameBrackets",i,i+2)
    
    # See if the line contains the right name bracket.
    j = s.find(self.rb+"=",i+2)
    k = g.choose(j==-1,2,3)
    if j == -1:
        j = s.find(self.rb,i+2)
    if j == -1:
        return i + 2
    else:
        # includes brackets
        searchName = s[i:j]
        ref = g.findReference(c,searchName,self.p)
        if ref:
            self.tag("link",i+2,j)
            if self.use_hyperlinks:
                << set the hyperlink >>
        elif k == 3: # a section definition
            self.tag("link",i+2,j)
        else:
            self.tag("name",i+2,j)
        self.tag("nameBrackets",j,j+k)
        return j + k
#@nonl
#@+node:ekr.20031218072017.1915:<< set the hyperlink >>
# Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
self.body.tag_delete(tagName)
self.tag(tagName,i+2,j)

ref.tagName = tagName
self.body.tag_bind(tagName,"<Control-1>",ref.OnHyperLinkControlClick)
self.body.tag_bind(tagName,"<Any-Enter>",ref.OnHyperLinkEnter)
self.body.tag_bind(tagName,"<Any-Leave>",ref.OnHyperLinkLeave)
#@-node:ekr.20031218072017.1915:<< set the hyperlink >>
#@-node:ekr.20031218072017.1914:doNowebSecRef (colorizer)
#@-node:ekr.20061206103433:Fixed colorizer bug: section references not colored properly
#@+node:ekr.20061208073322:Fixed cursor up/down bug
#@+node:ekr.20061208073208:Found: moveSpot
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    
    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j+1)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.
    
    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)
        
    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):
    
    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        delta = self.measure(w)
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        self.extendHelper(w,extend,spot)
        w.seeInsertPoint()
    elif gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@-node:ekr.20060113082917:scrollHelper
#@-node:ekr.20061208073208:Found: moveSpot
#@+node:ekr.20061208073208.1:Found: moveCol
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    
    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j+1)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.
    
    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)
        
    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):
    
    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    # g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace(changed)
    if changed:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)
    
    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75
    
    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
                                                            
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s[i:j]))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]
        
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@+node:ekr.20061109095450.8:onClick (passed)
def onClick (self,event):
    
    c = self.c ; k = c.k ; w = event and event.widget
    wname = c.widget_name(w)
    
    if wname.startswith('body'):
        # A hack to support middle-button pastes: remember the previous selection.
        k.previousSelection = w.getSelectionRange()
        x,y = g.app.gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        # g.trace(x,y,repr(i))
        w.setSelectionRange(i,i,insert=i)
        c.editCommands.setMoveCol(w,i)
        c.frame.updateStatusLine()
        self.selectEditor(w)
    else:
        g.trace('can not happen')
#@-node:ekr.20061109095450.8:onClick (passed)
#@-node:ekr.20061208073208.1:Found: moveCol
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    
    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j+1)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@nonl
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.
    
    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)
        
    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@+node:ekr.20060209095101:setMoveCol
def setMoveCol (self,w,spot):
    
    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.currentPosition()
    s = w.getAllText()
    i = w.toPythonIndex(spot)
    junk,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i,col',spot,i,col)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
#@nonl
#@-node:ekr.20060209095101:setMoveCol
#@+node:ekr.20060113082917:scrollHelper
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        delta = self.measure(w)
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        self.extendHelper(w,extend,spot)
        w.seeInsertPoint()
    elif gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@-node:ekr.20060113082917:scrollHelper
#@-node:ekr.20061208073322:Fixed cursor up/down bug
#@+node:ekr.20061209135859:Fix recent crasher in about-leo command
Traceback (most recent call last):
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 264, in doCommand
    val = command(event)
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 5194, in about
    g.app.gui.runAboutLeoDialog(c,version,theCopyright,url,email)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 197, in runAboutLeoDialog
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterDialog.py", line 203, in __init__
    self.createFrame()
  File "c:\prog\tigris-cvs\leo\src\leoTkinterDialog.py", line 238, in createFrame
    text.insert("end",version,"version")
TypeError: insert() takes exactly 3 arguments (4 given)
#@nonl
#@+node:ekr.20031218072017.3869:tkinterAboutLeo.createFrame
def createFrame (self):
    
    """Create the frame for an About Leo dialog."""
    
    if g.app.unitTesting: return
    
    frame = self.frame
    theCopyright = self.copyright ; email = self.email
    url = self.url ; version = self.version
    
    # Calculate the approximate height & width. (There are bugs in Tk here.)
    lines = string.split(theCopyright,'\n')
    height = len(lines) + 8 # Add lines for version,url,email,spacing.
    width = 0
    for line in lines:
        width = max(width,len(line))
    width = max(width,len(url))
    width += 10 # 9/9/02

    frame.pack(padx=6,pady=4)
    
    self.text = w = g.app.gui.plainTextWidget(
        frame,height=height,width=width,bd=0,bg=frame.cget("background"))
    w.pack(pady=10)
    
    try:
        bitmap_name = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF") # 5/12/03
        image = Tk.PhotoImage(file=bitmap_name)
        w.image_create("1.0",image=image,padx=10)
    except Exception:
        pass # This can sometimes happen for mysterious reasons.

    w.insert("end",version) #,tag="version")
    w.tag_add('version','end-%dc' %(len(version)+1),'end-1c')
    w.insert("end",theCopyright) #,tag="copyright")
    w.tag_add('copyright','end-%dc' %(len(theCopyright)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",url)
    w.tag_add('url','end-%dc' %(len(url)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",email)
    w.tag_add('url','end-%dc' %(len(email)+1),'end-1c')
    
    w.tag_config("version",justify="center")
    w.tag_config("copyright",justify="center",spacing1="3")
    w.tag_config("url",underline=1,justify="center",spacing1="10")
    
    w.tag_bind("url","<Button-1>",self.onAboutLeoUrl)
    w.tag_bind("url","<Enter>",self.setArrowCursor)
    w.tag_bind("url","<Leave>",self.setDefaultCursor)

    w.tag_config("email",underline=1,justify="center",spacing1="10")
    w.tag_bind("email","<Button-1>",self.onAboutLeoEmail)
    w.tag_bind("email","<Enter>",self.setArrowCursor)
    w.tag_bind("email","<Leave>",self.setDefaultCursor)

    w.configure(state="disabled")
#@-node:ekr.20031218072017.3869:tkinterAboutLeo.createFrame
#@-node:ekr.20061209135859:Fix recent crasher in about-leo command
#@+node:ekr.20061118044529:Fixed bugs in headline
@nocolor

1. Backspace does not work when there is an end selection

- Edit headline: cursor at end of last character.
- Drag right: apparent whitespace is selected.
- Now can not use backspace key.

The problem was a special case in backwardDeleteCharacter.

2. Select-all does not work properly in headlines.

@color
#@nonl
#@+node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if not w: return
    
    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # if self.trace_edit and not g.app.unitTesting:
            # if changed:
                # g.trace('changed: old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(scroll=False) # New in 4.4.1
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20040803072955.88:onHeadlineKey
def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(repr(ch),g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
#@-node:ekr.20040803072955.88:onHeadlineKey
#@+node:ekr.20051026083544.2:updateHead
def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; k = c.k
    ch = event and event.char or ''
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if i != j: ins = i
    
    # g.trace('ch',repr(ch),g.callers())

    if ch == '\b':
        if i != j:  w.delete(i,j)
        else:       w.delete(ins-1)
        w.setSelectionRange(i,i,insert=i)
    elif ch and ch not in ('\n','\r'):
        if i != j:                              w.delete(i,j)
        elif k.unboundKeyAction == 'overwrite': w.delete(i,i+1)
        w.insert(ins,ch)
        w.setSelectionRange(ins+1,ins+1,insert=ins+1)

    s = w.getAllText()
    if s.endswith('\n'):
        # g.trace('can not happen: trailing newline')
        s = s[:-1]
    w.setWidth(self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
#@-node:ekr.20051026083544.2:updateHead
#@-node:ekr.20040803072955.90:head key handlers
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):
    
    '''Delete the character to the left of the cursor.'''
    
    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return
    
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    #g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20061113151148.19:selectAllText
def selectAllText (self,insert=None): # tkTextWidget
    
    '''Select all text of the widget, *not* including the extra newline.'''
    
    w = self ; s = w.getAllText()
    if insert is None: insert = len(s)
    w.setSelectionRange(0,len(s),insert=insert)
#@-node:ekr.20061113151148.19:selectAllText
#@-node:ekr.20061118044529:Fixed bugs in headline
#@-node:ekr.20061128083024:Fixed bugs arising from new reorg
#@-node:ekr.20061029091904:Bugs
#@+node:ekr.20061029091904.1:Features
#@+node:ekr.20061030054124.1:Added handleUrlInUrlNode helper for OnIconDoubleClick
#@+node:ekr.20061030054934:Request
@nocolor

Email from Terry Brown.

I've written a simple plugin such that double clicking any 
headline in a tree with '@bookmarks' as its root will grab the 
url from the first line of the body text.

My problem is that I had to duplicate a lot of code from here:

Code-->Gui Base classes-->@thin leoFrame.py-->class 
leoTree-->tree.OnIconDoubleClick (@url)

specifically this whole piece:

@color
     if not g.doHook("@url1",c=c,p=p,v=p,url=url):
         # Note: the UNL plugin has its own notion of what a good url is.
         << check the url; return if bad >>
         << pass the url to the web browser >>
     g.doHook("@url2",c=c,p=p,v=p)
@nocolor

So I'm wondering if that could be split of to a different function, 
i.e. the first part of leoTree.OnIconDoubleClick gets the url, and 
the second part handles the url, and I want to be able to call just 
the second part.

It's important that this solution will trigger UNL if it's loaded, 
and similar animals.

So, if it's not too tricky, could the handle url part of 
leoTree.OnIconDoubleClick be split out for calling?
#@nonl
#@-node:ekr.20061030054934:Request
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            << stop the url after any whitespace >>
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            self.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20061030161842:handleUrlInUrlNode
def handleUrlInUrlNode(self,url):
    
    # Note: the UNL plugin has its own notion of what a good url is.
    
    c = self.c
    # g.trace(url)
    << check the url; return if bad >>
    << pass the url to the web browser >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url or len(url) == 0:
    g.es("no url following @url")
    return

# Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@nonl
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20061030161842:handleUrlInUrlNode
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper
#@-node:ekr.20061030054124.1:Added handleUrlInUrlNode helper for OnIconDoubleClick
#@+node:ekr.20061111131741:Only do one message re writing recent files
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
recentFileMessageWritten = False

def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    if g.app.unitTesting:
        return
    
    localFileName = c.fileName()
    if localFileName:
        localPath,junk = g.os_path_split(localFileName)
    else:
        localPath = None
        
    for path in (localPath,g.app.globalConfigDir,g.app.homeDir):
        if path:
            fileName = g.os_path_join(path,tag)
            if g.os_path_exists(fileName):
                if not self.recentFileMessageWritten:
                    self.recentFileMessageWritten = True
                    print ('wrote %s' % fileName)
                self.writeRecentFilesFileHelper(fileName)
                return
    else:
        # g.trace('----- not found: %s' % g.os_path_join(localPath,tag))
        return
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            lines = [g.toEncodedString(line,'utf-8') for line in self.recentFiles]
            theFile.write('\n'.join(lines))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@-node:ekr.20061111131741:Only do one message re writing recent files
#@+node:ekr.20061111153909:Made escape in the minibuffer work like ctrl-g
#@+node:ekr.20061031131434.146:masterKeyHandler
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    << define vars >>
    if keysym in special_keys: return None
    trace = False or c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    if trace:
        g.trace('stroke:',stroke,'keysym:',event.keysym,'ch:',repr(event.char),
            'state.kind:',k.state.kind,g.callers(4))
        # if (self.master_key_count % 100) == 0: g.printGcSummary(trace=True)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        g.trace('special case')
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>
        
    << handle per-pane bindings >>
    << handle keys without bindings >>
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event: event = gui.leoKeyEvent(event,c)

w = event.widget
char = event.char
keysym = event.keysym
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

# g.trace('w_name',w_name,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))
# g.trace('button',k.masterBindingsDict.get('button'))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d.keys())
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.151:<< handle keys without bindings >>
if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  <Return> is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    # g.trace(stroke,char,keysym)
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20061031131434.151:<< handle keys without bindings >>
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = False or c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@-node:ekr.20061031131434.146:masterKeyHandler
#@+node:ekr.20061031131434.128:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20061031131434.129:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20061031131434.129:<< init altX vars >>
#@-node:ekr.20061031131434.128:getArg
#@+node:ekr.20061031131434.111:fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@+node:ekr.20061031131434.112:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    
    # print 'callAltXFunc',func

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
#@-node:ekr.20061031131434.112:callAltXFunction
#@-node:ekr.20061031131434.111:fullCommand (alt-x) & helper
#@-node:ekr.20061111153909:Made escape in the minibuffer work like ctrl-g
#@+node:ekr.20061129193001:Clear status line in repeat-complex-command
# This is much less confusing.
#@nonl
#@-node:ekr.20061129193001:Clear status line in repeat-complex-command
#@+node:ekr.20061209131102:Added shortcuts for goto-first/last-sibling
#@-node:ekr.20061209131102:Added shortcuts for goto-first/last-sibling
#@+node:ekr.20061116064523:Made copied nodes valid Leo files
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4014079
By: ktenney

I've been looking at the Leo file format and discovered that a copied node is
nearly a valid Leo file, just add;

<globals/>
<preferences/>
<find_panel_settings/>

Would it be possible to drop the requirement for these tags or
add them when copying a node?

I think it would be nice if copied nodes were valid Leo files.

@color
#@nonl
#@-node:ekr.20061116064523:Made copied nodes valid Leo files
#@+node:ekr.20061127171616:Added support for chdir_to_relative_path setting
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4005750
By: ktenney

I like the option @string relative_path_base_directory = .

which puts @file nodes in the same directory as the current Leo file.

I would like it if 
open('file.txt','w').close()

put file.txt in the same directory as the current Leo file.

in g.getBaseDirectory I changed::
    if base and len(base) > 0 and g.os_path_isabs(base):
        return base # base need not exist yet.

to::
    if base and len(base) > 0 and g.os_path_isabs(base):
        os.chdir(base)
        return base # base need not exist yet.

it should probably be configurable::

    if base and len(base) > 0 and g.os_path_isabs(base):
        if app.config.python_cwd_is_leo_base:
            os.chdir(base)
        return base # base need not exist yet.
        
@color
#@+node:ekr.20031218072017.1264:getBaseDirectory
# Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) > 0 and g.os_path_isabs(base):
        # Set c.chdir_to_relative_path as needed.
        if not hasattr(c,'chdir_to_relative_path'):
            c.chdir_to_relative_path = c.config.getBool('chdir_to_relative_path')
        # Call os.chdir if requested.
        if c.chdir_to_relative_path:
            os.chdir(base)
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
#@-node:ekr.20031218072017.1264:getBaseDirectory
#@-node:ekr.20061127171616:Added support for chdir_to_relative_path setting
#@+node:ekr.20070105122833:changeAll now works like findAll
#@+node:ekr.20051023094009:Search classes
#@+node:ekr.20060123125256:class minibufferFind( (the findHandler)
class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):
    
    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []
    
    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
# This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
#@-node:ekr.20060124122844:get/set/toggleOption (minibufferFind)
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):
    
    h = self.finder ; w = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    w.delete(0,'end')
    w.insert(0,s)
    
    h.update_ivars()
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):
    
    h = self.finder ; w = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    w.delete(0,'end')
    w.insert(0,s)
    
    h.update_ivars()
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options (minibufferFind)
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()
    
    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20070105123800:changeAll
def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)

#@-node:ekr.20070105123800:changeAll
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060205105950.1:generalChangeHelper
def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):
    
    # g.trace(repr(change_pattern))
    
    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()

    if changeAll:
         self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060205105950.1:generalChangeHelper
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    c = self.c
    
    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124134356:setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@-node:ekr.20060124134356:setupArgs
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)
    
    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060224171851:updateChange/FindList
def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)
        
def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
#@-node:ekr.20060224171851:updateChange/FindList
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind( (the findHandler)
#@+node:ekr.20050920084036.257:class searchCommandsClass
class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others
#@+node:ekr.20050920084036.258: ctor (searchCommandsClass)
def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.inited = False
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None
        
    # For isearch commands.
    self.ifinder = leoFind.leoFind(c,title='ifinder')
    self.isearch_v = None # vnode of last isearch.
    self.isearch_stack = [] # A stack of previous matches: entries are: (sel,insert)
    self.ignoreCase = None
    self.forward = None
    self.regexp = None
#@-node:ekr.20050920084036.258: ctor (searchCommandsClass)
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        
        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,
        
        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@+node:ekr.20060123131421:Top-level methods
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None,show=True):
    
    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = self.inited
        
    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)
        
    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051022212004:Find Tab commands
# Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
#@-node:ekr.20051022212004:Find Tab commands
#@+node:ekr.20060124115801:getHandler
def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
#@-node:ekr.20060124115801:getHandler
#@+node:ekr.20060123115459:Find options wrappers
def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')
    
def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')
    
def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
#@-node:ekr.20060123115459:Find options wrappers
#@+node:ekr.20060124093828:Find wrappers
def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type <Return> to end the search string. The
    command will then prompt for the replacement string. Typing a second
    <Return> key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the <Return> key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
#@-node:ekr.20060124093828:Find wrappers
#@+node:ekr.20060204120158.2:findAgain
def findAgain (self,event):

    '''The find-again command is the same as the find-next command
    if the search pattern in the Find tab is not '<find pattern here>'
    Otherwise, the find-again is the same as the search-with-present-options command.'''
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to search-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
#@-node:ekr.20060204120158.2:findAgain
#@-node:ekr.20060123131421:Top-level methods
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)
    
def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)
    
def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)
    
def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
#@+node:ekr.20060420144640:iSearchBackspace
def iSearchBackspace (self):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w
    
    if not self.isearch_stack:
        ins = w.getInsertPoint()
        self.endSearch(ins,ins)
        return 
    
    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()
    
    if sel:
        i,j = sel
        w.setSelectionRange(i,j,insert=ins)
    else:
        w.setInsertPoint(ins)

    w.seeInsertPoint()
    
    if not self.isearch_stack:
        self.endSearch(ins,ins)
#@-node:ekr.20060420144640:iSearchBackspace
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w
    
    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!
    
    self.ins1 = ins = w.getInsertPoint()
    sel = w.getSelectionRange() or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20050920084036.264:iSearchStateHandler
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w ; gui = g.app.gui
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocusNow()
    if keysym == 'Return':
        i,j = w.getSelectionRange()
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
#@-node:ekr.20050920084036.264:iSearchStateHandler
#@+node:ekr.20050920084036.265:scolorizer LATER
def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = 0
    index = w.getInsertPoint()
    index2 = index + len(s)
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@-node:ekr.20050920084036.265:scolorizer LATER
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''
    
    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition() ;
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = w.getAllText()

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = w.getSelectionRange()
    startindex = insert = w.getInsertPoint()
    
    if self.forward:
        i1 = startindex
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),startindex + len(pattern))
    
    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        w.setSelectionRange(i,j,insert=i)
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')
    
    insert = g.choose(self.forward,'sel.end','sel.start')
    w.setSelectionRange(i,j,insert=insert)

    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20050920084036.257:class searchCommandsClass
#@-node:ekr.20051023094009:Search classes
#@+node:ekr.20061212084717:class leoFind
class leoFind:

    """The base class for Leo's Find commands."""

    @others
#@+node:ekr.20031218072017.3053:leoFind.__init__ & helpers
def __init__ (self,c,title=None):
    
    # g.trace('leoFind',c)

    self.c = c
    
    # Spell checkers use this class, so we can't always compute a title.
    if title:
        self.title = title
    else:
        << compute self.title >>

    << init the gui-independent ivars >>
    
def init (self,c):
    self.oops()
#@+node:ekr.20041121145452:<< compute self.title >>
if not c.mFileName:
    s = "untitled"
else:
    path,s = g.os_path_split(c.mFileName)
    
self.title = "Find/Change for %s" %  s
#@-node:ekr.20041121145452:<< compute self.title >>
#@+node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
self.wrapPosition = None
self.onlyPosition = None
self.find_text = ""
self.change_text = ""
self.unstick = False

@
New in 4.3:
- These are the names of leoFind ivars. (no more _flag hack).
- There are no corresponding commander ivars to keep in synch (hurray!)
- These ivars are inited (in the subclass by init) when this class is created.
- These ivars are updated by update_ivars just before doing any find.
@c

<< do dummy initialization to keep Pychecker happy >>

self.intKeys = [
    "batch","ignore_case", "node_only",
    "pattern_match", "search_headline", "search_body",
    "suboutline_only", "mark_changes", "mark_finds", "reverse",
    "script_search","script_change","selection_only",
    "wrap", "whole_word",
]

self.newStringKeys = ["radio-find-type", "radio-search-scope"]

# Ivars containing internal state...
self.c = None # The commander for this search.
self.clone_find_all = False
self.p = None # The position being searched.  Never saved between searches!
self.in_headline = False # True: searching headline text.
self.s_ctrl = searchWidget() # The search text for this search.
self.wrapping = False # True: wrapping is enabled.
    # This is _not_ the same as self.wrap for batch searches.

@ Initializing a wrapped search is tricky.  The search() method will fail if p==wrapPosition and pos >= wrapPos.  selectNextPosition() will fail if p == wrapPosition.  We set wrapPos on entry, before the first search.  We set wrapPosition in selectNextPosition after the first search fails.  We also set wrapPosition on exit if the first search suceeds.
@c

self.wrapPosition = None # The start of wrapped searches: persists between calls.
self.onlyPosition = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.
self.errors = 0
self.selStart = self.selEnd = None # For selection-only searches.
#@+node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
if 1:
    self.batch = None
    self.clone_find_all = None
    self.ignore_case = None
    self.node_only = None
    self.pattern_match = None
    self.search_headline = None
    self.search_body = None
    self.suboutline_only = None
    self.mark_changes = None
    self.mark_finds = None
    self.reverse = None
    self.script_search = None
    self.script_change = None
    self.selection_only = None
    self.wrap = None
    self.whole_word = None
#@-node:ekr.20050123164539:<< do dummy initialization to keep Pychecker happy >>
#@-node:ekr.20031218072017.3054:<< init the gui-independent ivars >>
#@-node:ekr.20031218072017.3053:leoFind.__init__ & helpers
#@+node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3057:changeAllButton
# The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_change:
        self.doChangeAllScript()
    elif self.selection_only:
        self.change()
    else:
        self.changeAll()
#@-node:ekr.20031218072017.3057:changeAllButton
#@+node:ekr.20031218072017.3056:changeButton
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3056:changeButton
#@+node:ekr.20031218072017.3058:changeThenFindButton
# The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

    self.setup_button()

    if self.script_change:
        self.doChangeScript()
        if self.script_search:
            self.doFindScript()
        else:
            self.findNext()
    else:
        if self.script_search:
            self.change()
            self.doFindScript()
        else:
            self.changeThenFind()
#@-node:ekr.20031218072017.3058:changeThenFindButton
#@+node:ekr.20031218072017.3060:findAllButton
# The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.c
    self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()
#@-node:ekr.20031218072017.3060:findAllButton
#@+node:ekr.20031218072017.3059:findButton
# The user has pushed the "Find" button from the find panel.

def findButton(self):

    self.setup_button()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3059:findButton
#@+node:ekr.20031218072017.3065:setup_button
# Initializes a search when a button is pressed in the Find panel.

def setup_button(self):
    
    c = self.c
    self.p = c.currentPosition()

    c.bringToFront()
    if 0: # We _must_ retain the editing status for incremental searches!
        c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3065:setup_button
#@-node:ekr.20060123065756.1:Top Level Buttons
#@+node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3061:changeCommand
# The user has selected the "Replace" menu item.

def changeCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
    else:
        self.change()
#@-node:ekr.20031218072017.3061:changeCommand
#@+node:ekr.20031218072017.3062:changeThenFindCommand
# The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doChangeScript()
        self.doFindScript()
    else:
        self.changeThenFind()
#@-node:ekr.20031218072017.3062:changeThenFindCommand
#@+node:ekr.20051013084200.1:dismiss: defined in subclass class
def dismiss (self):
    pass
#@-node:ekr.20051013084200.1:dismiss: defined in subclass class
#@+node:ekr.20031218072017.3063:findNextCommand
# The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

    self.setup_command()

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()
#@-node:ekr.20031218072017.3063:findNextCommand
#@+node:ekr.20031218072017.3064:findPreviousCommand
# The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

    self.setup_command()

    self.reverse = not self.reverse

    if self.script_search:
        self.doFindScript()
    else:
        self.findNext()

    self.reverse = not self.reverse
#@-node:ekr.20031218072017.3064:findPreviousCommand
#@+node:EKR.20040503070514:handleUserClick
def handleUserClick (self,p):
    
    """Reset suboutline-only search when the user clicks a headline."""
    
    try:
        if self.c and self.suboutline_only:
            # g.trace(p)
            self.onlyPosition = p.copy()
    except: pass
#@-node:EKR.20040503070514:handleUserClick
#@+node:ekr.20031218072017.3066:setup_command
# Initializes a search when a command is invoked from the menu.

def setup_command(self):
    
    # g.trace('leoFind')

    if 0: # We _must_ retain the editing status for incremental searches!
        self.c.endEditing()

    self.update_ivars()
#@-node:ekr.20031218072017.3066:setup_command
#@-node:ekr.20031218072017.3055:Top Level Commands
#@+node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; w = self.s_ctrl
    # Replace the selection with self.change_text
    if pos1 > pos2: pos1,pos2=pos2,pos1
    s = w.getAllText()
    if pos1 != pos2: w.delete(pos1,pos2)
    w.insert(pos1,self.change_text)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+len(self.change_text))
    w.setSelectionRange(insert,insert)
    w.setInsertPoint(insert)
    # Update the node
    s = w.getAllText() # Used below.
    if self.in_headline:
        << change headline >>
    else:
        << change body >>
#@+node:ekr.20031218072017.2294:<< change headline >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():
    
    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
    
    u.afterChangeNodeContents(p,'Change Headline',undoData)
#@-node:ekr.20031218072017.2294:<< change headline >>
#@+node:ekr.20031218072017.2295:<< change body >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():
    
    undoData = u.beforeChangeNodeContents(p)

    c.setBodyString(p,s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
     
    u.afterChangeNodeContents(p,'Change Body',undoData)
#@-node:ekr.20031218072017.2295:<< change body >>
#@-node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
#@+node:ekr.20031218072017.3068:change
def change(self,event=None):

    if self.checkArgs():
        self.initInHeadline()
        self.changeSelection()
#@-node:ekr.20031218072017.3068:change
#@+node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
def changeAll(self):
    
    # g.trace(g.callers())

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    w = self.s_ctrl
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if pos1 is None: break
            count += 1
            self.batchChange(pos1,pos2)
            s = w.getAllText()
            i,j = g.getLine(s,pos1)
            line = s[i:j]
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
    finally:
        c.endUpdate()
        self.restore(saveData)
#@-node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):
    
    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start > end: start,end = end,start
    if start == end:
        g.es("No text selected") ; return False
        
    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text
    
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
#@+node:ekr.20060526201951:makeRegexSubs
def makeRegexSubs(self,s,groups):
    
    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''
    
    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\',j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
#@-node:ekr.20060526201951:makeRegexSubs
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20031218072017.3071:changeThenFind
def changeThenFind(self):

    if not self.checkArgs():
        return

    self.initInHeadline()
    if self.changeSelection():
        self.findNext(False) # don't reinitialize
#@-node:ekr.20031218072017.3071:changeThenFind
#@+node:ekr.20031218072017.2417:doChange...Script
def doChangeScript (self):

    g.app.searchDict["type"] = "change"
    self.runChangeScript()

def doChangeAllScript (self):

    """The user has just pressed the Change All button with script-change box checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "changeAll"
    while 1:
        self.runChangeScript()
        if not g.app.searchDict.get("continue"):
            break

def runChangeScript (self):

    try:
        assert(self.script_change)
        exec self.change_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing change script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.2417:doChange...Script
#@+node:ekr.20031218072017.3072:doFind...Script
def doFindScript (self):

    g.app.searchDict["type"] = "find"
    self.runFindScript()

def doFindAllScript (self):

    """The user has just pressed the Find All button with script-find radio button checked.

    N.B. Only this code is executed."""

    g.app.searchDict["type"] = "findAll"
    while 1:
        self.runFindScript()
        if not g.app.searchDict.get("continue"):
            break

def runFindScript (self):

    try:
        exec self.find_text in {} # Use {} to get a pristine environment.
    except:
        g.es("exception executing find script")
        g.es_exception(full=False)
        g.app.searchDict["continue"] = False # 2/1/04
#@-node:ekr.20031218072017.3072:doFind...Script
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.headString())
            if not clones:
                << create the found node and begin the undo group >>
            clones.append(self.p.v.t)
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)
          
    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@+node:ekr.20051113110735:<< create the found node and begin the undo group >>
u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110735:<< create the found node and begin the undo group >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.3074:findNext
def findNext(self,initFlag=True):

    c = self.c
    if not self.checkArgs():
        return

    if initFlag:
        self.initInHeadline()
        data = self.save()
        self.initInteractiveCommands()
    else:
        data = self.save()

    pos, newpos = self.findNextMatch()

    if pos is not None:
        self.showSuccess(pos,newpos)
    else:
        if self.wrapping:
            g.es("end of wrapped search")
        else:
            g.es("not found: " + "'" + self.find_text + "'")
        self.restore(data)
#@-node:ekr.20031218072017.3074:findNext
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p
    while p:
        pos, newpos = self.search()
        # g.trace('pos',pos,'p',p.headString(),g.callers())
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            p = self.p = self.selectNextPosition()
    return None, None
#@-node:ekr.20031218072017.3075:findNextMatch
#@+node:ekr.20031218072017.3076:resetWrap
def resetWrap (self,event=None):

    self.wrapPosition = None
    self.onlyPosition = None
#@-node:ekr.20031218072017.3076:resetWrap
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.
    
    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl
    index = w.getInsertPoint()
    
    s = w.getAllText()
    # g.trace(index,repr(s[index:index+20]))
    stopindex = g.choose(self.reverse,0,len(s)) # 'end' doesn't work here.
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
        backwards=self.reverse,nocase=self.ignore_case,
        regexp=self.pattern_match,word=self.whole_word)
    # g.trace('pos,newpos',pos,newpos)
    if pos == -1: return None,None
    << fail if we are passed the wrap point >>
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    w.setSelectionRange(pos,newpos,insert=insert)
    return pos,newpos
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos and self.wrapPosition and p == self.wrapPosition:

    if self.reverse and pos < self.wrapPos:
        # g.trace("wrap done")
        return None, None

    if not self.reverse and newpos > self.wrapPos:
        return None, None
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:searchHelper & allies
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word,swapij=True):
    
    if swapij and backwards: i,j = j,i
        
    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1
        
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)

    return pos,newpos
#@+node:ekr.20061207172210:patternLen
#@-node:ekr.20061207172210:patternLen
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        self.errors += 1 # Abort the search.
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        if k == k2:
            return -1, -1 # A non-empty pattern can match an empty string.  Move on!
        else:
            return k, k2
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
def backwardsHelper (self,s,i,j,pattern,nocase,word):

    if nocase:
        s = s.lower() ; pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    
    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        # g.trace(i,j,k)
        if k == -1:
            return -1, -1
        else:
            return k,k+n
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
@tabwidth 4

def plainHelper (self,s,i,j,pattern,nocase,word):
    
    # g.trace(i,j,repr(s[i:i+20]),'pattern',repr(pattern),'word',repr(word))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
	pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):
    
    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        return False

    pat1,pat2 = pattern[0],pattern[-1]
    # n = self.patternLen(pattern)
    n = len(pattern)
    ch1 = 0 <= i-1 < len(s) and s[i-1] or '.'
    ch2 = 0 <= i+n < len(s) and s[i+n] or '.'
    
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    
    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))
    
    if isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2:
        return False
    else:
        return True
#@-node:ekr.20060526140744.1:matchWord
#@+node:ekr.20070105165924:replaceBackSlashes
def replaceBackSlashes (self,s):
    
    '''Carefully replace backslashes in a search pattern.'''
    
    # This is NOT the same as s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.
    
    i = 0
    while i + 1 < len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                 s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
#@-node:ekr.20070105165924:replaceBackSlashes
#@-node:ekr.20060526081931:searchHelper & allies
#@-node:ekr.20031218072017.3077:search & helpers
#@+node:ekr.20031218072017.3081:selectNextPosition
# Selects the next node to be searched.

def selectNextPosition(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace('switching to body',g.callers(5))
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()
    
    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@-node:ekr.20031218072017.3081:selectNextPosition
#@-node:ekr.20031218072017.3067:Find/change utils
#@+node:ekr.20061212095134.1:General utils
#@+node:ekr.20051020120306.26:bringToFront (leoFind)
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; w = self.find_ctrl
        
    c.widgetWantsFocusNow(w)
    g.app.gui.selectAllText(w)
    c.widgetWantsFocus(w)
#@-node:ekr.20051020120306.26:bringToFront (leoFind)
#@+node:ekr.20061111084423.1:oops (leoFind)
def oops(self):
    print ("leoFind oops:",
        g.callers(10),"should be overridden in subclass")
#@-node:ekr.20061111084423.1:oops (leoFind)
#@+node:ekr.20051020120306.27:selectAllFindText (leoFind)
def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event
    
    # This is called only when the user presses ctrl-a in the find panel.

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        w.selectAllText()

    return "break"
#@-node:ekr.20051020120306.27:selectAllFindText (leoFind)
#@-node:ekr.20061212095134.1:General utils
#@+node:ekr.20031218072017.3082:Initing & finalizing
#@+node:ekr.20031218072017.3083:checkArgs
def checkArgs (self):

    val = True
    if not self.search_headline and not self.search_body:
        g.es("not searching headline or body")
        val = False
    if len(self.find_text) == 0:
        g.es("empty find patttern")
        val = False
    return val
#@-node:ekr.20031218072017.3083:checkArgs
#@+node:ekr.20051020120306.28:init_s_ctrl
def init_s_ctrl (self,s):
    
    w = self.s_ctrl
    w.setAllText(s)
    i = g.choose(self.reverse,len(s),0)
    w.setInsertPoint(i)
    return w
#@-node:ekr.20051020120306.28:init_s_ctrl
#@+node:ekr.20031218072017.3084:initBatchCommands
# Initializes for the Find All and Change All commands.

def initBatchCommands (self):

    c = self.c ; w = c.frame.body.bodyCtrl
    self.in_headline = self.search_headline # Search headlines first.
    self.errors = 0

    # Select the first node.
    if self.suboutline_only or self.node_only or self.selection_only:
        self.p = c.currentPosition()
        if self.selection_only: self.selStart,self.selEnd = w.getSelectionRange()
        else:                   self.selStart,self.selEnd = None,None
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p

    # Set the insert point.
    self.initBatchText()
#@-node:ekr.20031218072017.3084:initBatchCommands
#@+node:ekr.20031218072017.3085:initBatchText & initNextText
# Returns s_ctrl with "insert" point set properly for batch searches.
def initBatchText(self):
    p = self.p
    self.wrapping = False # Only interactive commands allow wrapping.
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
    p = self.p
    s = g.choose(self.in_headline,p.headString(), p.bodyString())
    return self.init_s_ctrl(s)
#@-node:ekr.20031218072017.3085:initBatchText & initNextText
#@+node:ekr.20031218072017.3086:initInHeadline
# Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

    c = self.c ; p = self.p

    # Do not change this without careful thought and extensive testing!
    if self.search_headline and self.search_body:
        # A temporary expedient.
        if self.reverse:
            self.in_headline = False
        else:
            # Search headline first.
            self.in_headline = (
                p == c.frame.tree.editPosition() and
                c.get_focus() != c.frame.body.bodyCtrl)
    else:
        self.in_headline = self.search_headline
#@-node:ekr.20031218072017.3086:initInHeadline
#@+node:ekr.20031218072017.3087:initInteractiveCommands
# For incremental searches

def initInteractiveCommands(self):

    c = self.c ; p = self.p

    self.errors = 0
    if self.in_headline:
        c.frame.tree.setEditPosition(p)
        w = c.edit_widget(p)
        sel = None
    else:
        w = c.frame.bodyCtrl
        sel = w.getSelectionRange()
    pos = w.getInsertPoint()
    st = self.initNextText()
    c.widgetWantsFocus(w)
    st.setInsertPoint(pos)
    if sel:
        self.selStart,self.selEnd = sel
    else:
        self.selStart,self.selEnd = None,None
    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = pos
        # Do not set self.wrapPosition here: that must be done after the first search.
#@-node:ekr.20031218072017.3087:initInteractiveCommands
#@+node:ekr.20031218072017.3088:printLine
def printLine (self,line,allFlag=False):

    both = self.search_body and self.search_headline
    context = self.batch # "batch" now indicates context

    if allFlag and both and context:
        g.es('-' * 20,self.p.headString())
        theType = g.choose(self.in_headline,"head: ","body: ")
        g.es(theType + line)
    elif allFlag and context and not self.p.isVisited():
        # We only need to print the context once.
        g.es('-' * 20,self.p.headString())
        g.es(line)
        self.p.setVisited()
    else:
        g.es(line)
#@-node:ekr.20031218072017.3088:printLine
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

    c = self.c
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    
    if not in_headline:
        # Looks good and provides clear indication of failure or termination.
        t.setSelectionRange(insert,insert)
        t.setInsertPoint(insert)
        t.seeInsertPoint()
    
    #g.trace(c.widget_name(t))
    
    if 1: # I prefer always putting the focus in the body.
        c.invalidateFocus()
        c.bodyWantsFocusNow()
    else:
        c.widgetWantsFocusNow(t)
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20031218072017.3090:save
def save (self):

    c = self.c ; p = self.p
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.bodyCtrl)
    insert = w.getInsertPoint()
    sel = w.getSelectionRange()
    if len(sel) == 2:
        start,end = sel
    else:
        start,end = None,None
    return (self.in_headline,p,w,insert,start,end)
#@-node:ekr.20031218072017.3090:save
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, c.edit_widget(p) or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac
    redraw = not p.isVisible()
    c.beginUpdate()
    try:
        if sparseFind:
            # New in Leo 4.4.2: show only the 'sparse' tree when redrawing.
            for p in c.allNodes_iter():
                if not p.isAncestorOf(self.p):
                    p.contract()
                    redraw = True
            for p in self.p.parents_iter():
                if not p.isExpanded():
                    p.expand()
                    redraw = True
        p = self.p
        c.selectPosition(p)
    finally:
        c.endUpdate(redraw)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)
    c.widgetWantsFocusNow(w)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    #g.trace('reverse,pos,newpos,insert',self.reverse,pos,newpos,insert)
    w.setSelectionRange(pos,newpos,insert=insert)
    w.seeInsertPoint()
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@+node:ekr.20031218072017.1460:update_ivars (leoFind)
# New in Leo 4.4.3: This is now gui-independent code.

def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""
    
    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        # g.trace(self.svarDict.get(key))
        val = self.svarDict[key].get()
        setattr(self, key, val) # No more _flag hack.

    # Set ivars from radio buttons. Convert these to 1 or 0.
    search_scope = self.svarDict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0)

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.getAllText()
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.getAllText()
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@-node:ekr.20031218072017.1460:update_ivars (leoFind)
#@-node:ekr.20031218072017.3082:Initing & finalizing
#@-node:ekr.20061212084717:class leoFind
#@+node:ekr.20051020120306.6:class findTab (leoFind)
class findTab (leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others
#@+node:ekr.20051020120306.11:findTab.__init__
def __init__(self,c,parentFrame):
    
    # g.trace('findTab',c)

    # Init the base class...
    leoFind.__init__(self,c,title='Find Tab')

    self.c = c
    self.parentFrame = parentFrame
    self.frame = self.outerFrame = self.top = None
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.initGui()
    self.createFrame(parentFrame)
    self.createBindings()
    self.init(c) # New in 4.3: init only once.
    
#@nonl
#@-node:ekr.20051020120306.11:findTab.__init__
#@+node:ekr.20061212092124:Must be defined in subclasses
def createBindings (self):          self.oops()
def createFrame (self):             self.oops()
def getOption (self,ivar):          self.oops()
def init (self):                    self.oops()
def initGui (self):                 pass # Optional method.
def setOption (self,ivar,val):      self.oops()
def toggleOption (self,ivar):       self.oops()

# self.oops is defined in the leoFind class.
#@-node:ekr.20061212092124:Must be defined in subclasses
#@+node:ekr.20060221074900:Callbacks
#@+node:ekr.20060221074900.1:findButtonCallback
def findButtonCallback(self,event=None):
    
    self.findButton()
    return 'break'
#@-node:ekr.20060221074900.1:findButtonCallback
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@-node:ekr.20051020120306.25:hideTab
#@-node:ekr.20060221074900:Callbacks
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@+node:ekr.20070105123638:changeAllCommand
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
#@-node:ekr.20070105123638:changeAllCommand
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):
    
    s = self.find_ctrl.getAllText()
    
    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20060209064832:findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@-node:ekr.20060209064832:findAllCommand
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@-node:ekr.20051024192602: Top level
#@-node:ekr.20051020120306.6:class findTab (leoFind)
#@-node:ekr.20070105122833:changeAll now works like findAll
#@+node:ekr.20070105121752:Added Find & Spell tabs to log pane on startup
@ Notes:
    
- The spell tab is only shown if Aspell was properly imported.
- Added leoLog.finishCreate and tkLog.finishCreate, called from c.finishCreate.
- Added force option to deleteTab.
- Handled errors better in the aspell init logic.
#@nonl
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None,show=True):
    
    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = self.inited
        
    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)
        
    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051025080633:openSpellTab
def openSpellTab (self,event=None):
    
    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        self.handler = spellTabHandler(c,tabName)
        if not self.handler.loaded:
            log.deleteTab(tabName,force=True)
#@+node:ekr.20051025080420.1:commands...
# Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):
    '''Simulate pressing the 'Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@-node:ekr.20051025080420.1:commands...
#@-node:ekr.20051025080633:openSpellTab
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}
        
    c.frame.log.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBar()
    f.createSplitterComponents()
    f.createStatusLine()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    self.trace_status_line = c.config.getBool('trace_status_line')
    # f.enableTclTraces()
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # f.top.bind("<Activate>",f.OnActivateLeoEvent)
    # f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot(oldRoot=None)
    c.setRootPosition(p) # New in 4.4.2.
    c.editPosition(p)
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20070114070939:tkLog.finishCreate
def finishCreate (self):
    
    # g.trace('tkLog')
    
    c = self.c ; log = self
    
    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
    log.selectTab('Log')
#@-node:ekr.20070114070939:tkLog.finishCreate
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        # g.trace(tabName,force)
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@-node:ekr.20051018102027:deleteTab
#@-node:ekr.20070105121752:Added Find & Spell tabs to log pane on startup
#@+node:ekr.20061030074731:Created standard pluginsManager.txt only if it does not exist
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3987635
By: rogererens

At present I have to go through the list in the Plugin Manager again, trying to
remember which plugins I had enabled in the previous version.

Possibly the .leoRecentFiles.txt construct analogue may be used?

@color

#@+node:ekr.20031218072017.3440:loadHandlers & helper
def loadHandlers(tag):

    """Load all enabled plugins from the plugins directory"""

    fileName = "pluginsManager.txt"
    plugins_path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]
    s = g.app.config.getEnabledPlugins()
    theConfigFile = g.app.config.enabledPluginsFileName
    # g.trace('len(s)',s and len(s) or 0)
    if s:
        g.es('@enabled-plugins found in %s' % (theConfigFile),color='blue')
        enabled_files = getEnabledFiles(s,plugins_path)
    else:
        for theDir,place in (
            (g.app.homeDir,'HOME'),
            (plugins_path,'leo/config')
        ):
            manager_path = g.os_path_join(theDir,fileName)
            if g.os_path_exists(manager_path):
                g.es('%s: %s' % (fileName,theDir),color='blue')
                break
        else: g.es('%s not found. No plugins will be loaded' % fileName)
        if g.os_path_exists(manager_path):
            << set enabled_files from pluginsManager.txt >>
        else:  return
    
    # Load plugins in the order they appear in the enabled_files list.
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                loadOnePlugin(theFile)
                
    # Note: g.plugin_signon adds module names to g.app.loadedPlugins 
    if g.app.loadedPlugins:
        g.es("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
#@+node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
try:
    # New in 4.3: The first reference to a plugin in pluginsManager.txt controls.
    theFile = open(manager_path)
    ###lines = theFile.readlines()
    s = theFile.read()
    enabled_files = getEnabledFiles(s,plugins_path)
    theFile.close()
except IOError:
    g.es("Can not open: " + manager_path)
    # Don't import leoTest initially.  It causes problems.
    import leoTest ; leoTest.fail()
    return
#@-node:ekr.20031218072017.3441:<< set enabled_files from pluginsManager.txt >>
#@+node:ekr.20070224082131:getEnabledFiles
def getEnabledFiles (s,plugins_path):

    enabled_files = []
    disabled_files = []
    for s in g.splitLines(s):
        s = s.strip()
        if s:
            if g.match(s,0,"#"):
                s = s[1:].strip()
                # Kludge: ignore comment lines containing a blank or not ending in '.py'.
                if s and s.find(' ') == -1 and s[-3:] == '.py':
                    path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                    if path not in enabled_files and path not in disabled_files:
                        # print 'disabled',path
                        disabled_files.append(path)
            else:
                path = g.os_path_abspath(g.os_path_join(plugins_path,s))
                if path not in enabled_files and path not in disabled_files:
                    # print 'enabled',path
                    enabled_files.append(path)

    return enabled_files
#@nonl
#@-node:ekr.20070224082131:getEnabledFiles
#@-node:ekr.20031218072017.3440:loadHandlers & helper
#@-node:ekr.20061030074731:Created standard pluginsManager.txt only if it does not exist
#@+node:ekr.20070115105245:Executing Leo-specific scripts from winpdb
#@+node:ekr.20070115151643:Preliminary docs
@nocolor
@

It is now possible to debug both Leo-specific and non-Leo-specific scripts easily with winpdb.

Preliminaries: New settings

The following two new settings now control whether the execute-script and debug commands write the script to an external file.

- @bool write_script_file = True

True: The execute script command writes the script to be executed to a file, then executes the script using Python's execFile function. The script_file_path setting specifies the path to this file.
      
False (legacy): The execute script command uses Python's exec command to execute the script. 

- @string script_file_path = ../test/scriptFile.py

The path to the file to be written by the execute-script command.

Notes:
    
- This setting has effect only if the write_script_file setting is True.
- Use / to as the path delimiter, regardless of platform.
- The default path is ../test/scriptFile.py if no path is given.
- The path starts at g.app.loadDir, so for example ../test/scriptFile.py is equivalent to leo/test/scriptFile.py
- The filename should end in .py.

From here on, let us assume the settings are as shown above.  There are at least three ways of debugging scripts, depending on your preferences and whether the script contains leo-specific code (g, c or p) or not.

First way:  The debug command

The debug command now works almost exactly like Kent's original @button node. This way of debugging can only be used for general scripts, not leo-specific scripts.  

The debug command writes the script to scriptFile.py and invokes the debugger as specified by the existing @string debugger_kind option.  winpdb opens and is already 'attached' to the script to be debugged.  You can single-step as you like.  Leo continues to run, but killing the debugger will also kill Leo.  When started this way, winpdb is really 'attached' to *all* of Leo, which means you can single step past the end of the script into Leo's executeScript code and from there into all of Leo(!)

As I write this I realize that the code uses arguments specific to winpdb.  That may have to be generalized, though I am not sure why anyone would want to use another debugger...

Second way: @button winpdb

This is almost exactly equivalent to the debug command, except that the script file must be *different* from the script file specified by the  script_file_path setting (The @button code *itself* uses the execute-script command, so we have to pass the script code, not the @button code to the debugger).

Third way: The execute-script command with explicit debugger breaks

The third way of debugging scripts allows winpdb to debug scripts that use c, g and p.  I'm actually not sure of exactly how and why it works, but it certainly does work.

In contrast to the previous two ways, a little more work is needed because winpdb does not start automatically.  But I am getting ahead of myself.

To use this way, insert the following two lines of code at the start of the script to be debugged::

import rpdb2
rpdb2.start_embedded_debugger('go',fAllowUnencrypted=True)

Now just execute the execute-script command (*not* the debug command)  Leo will appear to hang.  Indeed, the  start_embedded_debugger command is waiting for *another* copy of winpdb to 'attach' to the script's process.  This process is all of Leo!  The default timeout is 5 minutes: I'm not sure what happens when the timeout happens: probably an exception gets thrown.

So you must start winpdb explicitly.  On XP just do something like

python c:\python25\Scripts\_winpdb.py -t

The -t option tells winpdb that no encoding of password is necessary.  The password is specified in the call to rpdb2.start_embedded_debugger in your script.  In this example, the password is 'go'.  Use the File:Attach command in winpdb to attach winpdb to Leo.  Specify the password as 'go' and you will see the scriptFile.py containing your entire script.  You can execute or single-step through the script. 

To repeat, the big difference is that c, g and p are defined, so you can debug any script this way.  As before, killing winpdb also kills Leo.

P.S.  winpdb and its documentation has been improved recently.  See

http://www.digitalpeers.com/pythondebugger/  and especially

http://www.digitalpeers.com/pythondebugger/embedded.htm

The discussion of embedded debugging may have been written specifically with Leo in mind.  It certainly could have been.
#@-node:ekr.20070115151643:Preliminary docs
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):
    
    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):
    
    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):
    
    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))
        
    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None
    
    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@+node:ekr.20060519003651:debug & helper
def debug (self,event=None):
    
    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213:findDebugger
def findDebugger (self):
    
    '''Find the debugger using settings.'''
    
    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'scripts','_winpdb.py'),
    )
    
    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
#@-node:ekr.20060521140213:findDebugger
#@-node:ekr.20060519003651:debug & helper
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands ; w = c.frame.body.bodyCtrl
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and w.hasSelection():
                s = w.getSelectedText()
            else:
                s = w.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    # g.trace(type(script),repr(script))
    return script
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():
    
    # __pychecker__ = '--limit=0' # Suppress warnings about c & p.

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20060624085200:g.handleScriptException
def handleScriptException (c,p,script,script1):

    g.es("exception executing script",color='blue')
    
    full = c.config.getBool('show_full_tracebacks_in_scripts')

    fileName, n = g.es_exception(full=full)

    if p and not script1 and fileName == "<string>":
        c.goToScriptLineNumber(p,script,n)

    << dump the lines near the error >>
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

# Print surrounding lines.
i = max(0,n-2)
j = min(n+2,len(lines))
while i < j:
    ch = g.choose(i==n-1,'*',' ')
    s = "%s line %d: %s" % (ch,i+1,lines[i])
    g.es(s,newline=False)
    i += 1
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20060624085200:g.handleScriptException
#@-node:ekr.20070115105245:Executing Leo-specific scripts from winpdb
#@+node:ekr.20070122100746:Added \runAskOkCancelStringDialog
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4113315

> def runAskOkCancelNumberDialog(self,c,title,message): 
> """Create and run askOkCancelNumber dialog .""" 

Can I appeal for a runAskOkCancelStringDialog(self,c,title,message)

and that perhaps both the Number and String forms have an optional 'default'
parameter?

As it happens I wanted to use it for an 'encryptNode' plug-in.  So some people
might want a runAskOkCancelPasswordDialog version, displaying asterisks... personally
I don't mind having the password visible when I type it, and for AES encryption
with 16 char keys it's probably appropriate.

@color
#@nonl
#@+node:ekr.20031218072017.3730:app.gui dialogs
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()
#@-node:ekr.20031218072017.3730:app.gui dialogs
#@+node:ekr.20031218072017.3744:dialogs (unitTestGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")
    
def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)
    
def runAskOkCancelStringDialog(self,c,title,message):
    return self.simulateDialog("stringDialog",'')
    
def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')
    
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
#@-node:ekr.20031218072017.3744:dialogs (unitTestGui)
#@+node:ekr.20031218072017.4056:tkGui dialogs & panels
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run a Tkinter About Leo dialog."""
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
    return d.run(modal=False)
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    d = leoTkinterDialog.tkinterAskLeoID()
    return d.run(modal=True)

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run a Tkinter an askOK dialog ."""
    d = leoTkinterDialog.tkinterAskOk(c,title,message,text)
    return d.run(modal=True)

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelNumber(c,title,message)
    return d.run(modal=True)
    
def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelString(c,title,message)
    return d.run(modal=True)

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    d = leoTkinterDialog.tkinterAskYesNo(c,title,message)
    return d.run(modal=True)

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    d = leoTkinterDialog.tkinterAskYesNoCancel(
        c,title,message,yesMessage,noMessage,defaultButton)
    return d.run(modal=True)
    
def runCompareDialog(self,c):
    """Create and run an askYesNo dialog."""
    if not g.app.unitTesting:
        leoTkinterCompareDialog(c)
#@+node:ekr.20070212132230:tkGui.createSpellTab
def createSpellTab(self,c,spellHandler,tabName):
    
    return leoTkinterFind.tkSpellTab(c,spellHandler,tabName)
#@-node:ekr.20070212132230:tkGui.createSpellTab
#@+node:ekr.20031218072017.4057:tkGui file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.
#@+node:ekr.20060212061804:runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    
    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        if (
            g.CheckVersion(version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)
#@-node:ekr.20060212061804:runOpenFileDialog
#@+node:ekr.20060212061804.1:runSaveFileDialog
def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir=g.app.globalOpenDir or g.os_path_abspath(os.getcwd()),

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)
#@-node:ekr.20060212061804.1:runSaveFileDialog
#@-node:ekr.20031218072017.4057:tkGui file dialogs
#@+node:ekr.20031218072017.4058:tkGui panels
def createComparePanel(self,c):
    """Create a Tkinter color picker panel."""
    return leoTkinterComparePanel.leoTkinterComparePanel(c)

def createFindPanel(self,c):
    """Create a hidden Tkinter find panel."""
    panel = leoTkinterFind.leoTkinterFind(c)
    panel.top.withdraw()
    return panel
    
def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    return leoTkinterFind.tkFindTab(c,parentFrame)
    
def createLeoFrame(self,title):
    """Create a new Leo frame."""
    # print 'tkGui.createLeoFrame'
    gui = self
    return leoTkinterFrame.leoTkinterFrame(title,gui)
#@-node:ekr.20031218072017.4058:tkGui panels
#@-node:ekr.20031218072017.4056:tkGui dialogs & panels
#@+node:ekr.20070122103505:class tkinterAskOkCancelString
class  tkinterAskOkCancelString (leoTkinterDialog):
    
    """Create and run a modal Tkinter dialog to get a string."""
    
    @others
#@+node:ekr.20070122103505.1:tkinterAskOKCancelString.__init__
def __init__ (self,c,title,message):
    
    """Create a number dialog"""

    leoTkinterDialog.__init__(self,c,title,resizeable=False) # Initialize the base class.
    
    if g.app.unitTesting: return

    self.answer = -1
    self.number_entry = None

    self.createTopFrame()
    self.top.bind("<Key>", self.onKey)

    self.createFrame(message)
    self.focus_widget = self.number_entry

    buttons = (
            {"text":"Ok",    "command":self.okButton,     "default":True},
            {"text":"Cancel","command":self.cancelButton} )
    buttonList = self.createButtons(buttons)
    self.ok_button = buttonList[0] # Override the default kind of Ok button.
#@-node:ekr.20070122103505.1:tkinterAskOKCancelString.__init__
#@+node:ekr.20070122103505.2:tkinterAskOkCancelString.createFrame
def createFrame (self,message):
    
    """Create the frame for a number dialog."""
    
    if g.app.unitTesting: return
    
    c = self.c
    
    lab = Tk.Label(self.frame,text=message)
    lab.pack(pady=10,side="left")
    
    self.number_entry = w = Tk.Entry(self.frame,width=20)
    w.pack(side="left")
    
    c.set_focus(w)
#@-node:ekr.20070122103505.2:tkinterAskOkCancelString.createFrame
#@+node:ekr.20070122103505.3:tkinterAskOkCancelString.okButton, cancelButton
def okButton(self):
    
    """Handle clicks in the ok button of a string dialog."""

    self.answer = self.number_entry.get().strip()
    self.top.destroy()
    
def cancelButton(self):
    
    """Handle clicks in the cancel button of a string dialog."""

    self.answer=''
    self.top.destroy()
#@-node:ekr.20070122103505.3:tkinterAskOkCancelString.okButton, cancelButton
#@+node:ekr.20070122103505.4:tkinterAskOkCancelString.onKey
def onKey (self,event):

    ch = event.char.lower()

    if ch in ('o','\n','\r'):
        self.okButton()
    elif ch == 'c':
        self.cancelButton()

    return "break"
#@-node:ekr.20070122103505.4:tkinterAskOkCancelString.onKey
#@-node:ekr.20070122103505:class tkinterAskOkCancelString
#@-node:ekr.20070122100746:Added \runAskOkCancelStringDialog
#@+node:ekr.20070123160127:Use plain ascii characters instead of special Tk symbols
# This is another step toward making Leo's core gui-independent
#@nonl
#@+node:ekr.20070124070019:To do: define special_keys in base class
#@-node:ekr.20070124070019:To do: define special_keys in base class
#@+node:ekr.20070123201540:Found: .bind
#@+node:ekr.20051020120306.4:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@-node:ekr.20051020120306.4:bindHotKey
#@+node:ekr.20061031131434.103:makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):
    
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    
    k = self ; c = k.c ; f = c.frame
   
    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)
    
    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        widgets=(c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)
    
    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
#@-node:ekr.20061031131434.103:makeMasterGuiBinding
#@+node:ekr.20031218072017.3113:printBindings
def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b
#@-node:ekr.20031218072017.3113:printBindings
#@+node:ekr.20041026080125:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@-node:ekr.20041026080125:bindHotKey
#@+node:ekr.20060203114017:f.setMinibufferBindings
def setMinibufferBindings (self):
    
    '''Create bindings for the minibuffer..'''
    
    f = self ; c = f.c ; k = c.k ; w = f.miniBufferWidget
    
    if not c.useTextMinibuffer: return
    
    for kind,callback in (
        ('<Key>',           k.masterKeyHandler),
        ('<Button-1>',      k.masterClickHandler),
        ('<Button-3>',      k.masterClick3Handler),
        ('<Double-1>',      k.masterDoubleClickHandler),
        ('<Double-3>',      k.masterDoubleClick3Handler),
    ):
        w.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            w.bind("<Button-2>",frame.OnPaste)
#@-node:ekr.20060203114017:f.setMinibufferBindings
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl
    
    w.bind('<Key>', k.masterKeyHandler)

    for kind,func,handler in (
        ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
        ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        w.bind(kind,bodyClickCallback)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.4017:Menus
def bind (self,*args,**keys):
    
    return self.bodyCtrl.bind(*args,**keys)
#@-node:ekr.20031218072017.4017:Menus
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('<Key>',       k.masterKeyHandler),
        ('<Button-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)
    
    tab.bind('<Button-1>',tabMenuClickCallback)
    tab.bind('<Button-3>',tabMenuRightClickCallback)
    
    k.completeAllBindingsForWidget(w)
#@-node:ekr.20051022162730:setTabBindings
#@+node:ekr.20051024102724:tkTtree.setBindings
def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    << make bindings for a common binding widget >>

    self.canvas.bind('<Key>',k.masterKeyHandler)
    self.canvas.bind('<Button-1>',self.onTreeClick)

    << make bindings for tagged items on the canvas >>
    << create baloon bindings for tagged items on the canvas >>
#@+node:ekr.20060131173440:<< make bindings for a common binding widget >>
self.bindingWidget = w = g.app.gui.plainTextWidget(
    self.canvas,name='bindingWidget')

w.bind('<Key>',k.masterKeyHandler)

table = (
    ('<Button-1>',       k.masterClickHandler,          tree.onHeadlineClick),
    ('<Button-3>',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('<Double-Button-1>',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('<Double-Button-3>',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    w.bind(a,treeBindingCallback)
    
self.textBindings = w.bindtags()
#@-node:ekr.20060131173440:<< make bindings for a common binding widget >>
#@+node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)
#@-node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
#@+node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@-node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
#@-node:ekr.20051024102724:tkTtree.setBindings
#@-node:ekr.20070123201540:Found: .bind
#@+node:ekr.20061031131434.181:Shortcuts (keyHandler)
#@+node:ekr.20061031131434.182:isPlainKey & test
def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''
    
    for s in ('Alt','Ctrl','Command'):
        if shortcut.find(s) != -1:
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut == 'Tab'
        )
        
        # g.trace(isPlain,repr(shortcut))
        return isPlain
#@+node:ekr.20061031131434.183:test_isPlainKey
def test_isPlainKey (self):
    
    import string
    
    k = c.k # self is a dummy argument
    
    for ch in (string.printable):
        if ch == '\n': continue # A special case.
        assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)
        
    special = (
        'Return', # A special case.
        'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
        'KP_F1','KP_F2','KP_F3','KP_F4',
        'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
        'Home','Left','Linefeed','Next','Num_Lock',
        'PageDn','PageUp','Pause','Prior','Right','Up',
        'Sys_Req',
    )

    for ch in special:
        assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
#@-node:ekr.20061031131434.183:test_isPlainKey
#@-node:ekr.20061031131434.182:isPlainKey & test
#@+node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    # g.trace(setting,shortcut)
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting
#@+node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
#@-node:ekr.20061031131434.185:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@-node:ekr.20061031131434.186:<< swap cmd and ctrl keys >>
#@+node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@-node:ekr.20061031131434.187:<< convert minus signs to plus signs >>
#@+node:ekr.20061031131434.188:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
            
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
#@-node:ekr.20061031131434.188:<< compute the last field >>
#@+node:ekr.20061031131434.189:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)
    
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@-node:ekr.20061031131434.189:<< compute shortcut >>
#@-node:ekr.20061031131434.184:shortcutFromSetting (uses k.guiBindNamesDict)
#@+node:ekr.20061031131434.190:k.tkbindingFromStroke
def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = g.stripBrackets(stroke)
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    # g.trace('<%s>' % stroke)
    return '<%s>' % stroke
#@-node:ekr.20061031131434.190:k.tkbindingFromStroke
#@+node:ekr.20061031131434.191:k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):
    
    k = self
    s = stroke and g.stripBrackets(stroke.strip())
    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev and not brief:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    return g.choose(brief,s,'<%s>' % s)
#@-node:ekr.20061031131434.191:k.prettyPrintKey
#@-node:ekr.20061031131434.181:Shortcuts (keyHandler)
#@+node:ekr.20061031131434.103:makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):
    
    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''
    
    k = self ; c = k.c ; f = c.frame
   
    bindStroke = k.tkbindingFromStroke(stroke)
    # g.trace('stroke',stroke,'bindStroke',bindStroke)
    
    if w:
        widgets = [w]
    else:
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        widgets=(c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)
    
    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke)
        return k.masterKeyHandler(event,stroke=stroke)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                w.bind(bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding %s to %s' % (
                    bindStroke, c.widget_name(w)), color = 'blue')
                if g.app.unitTesting: raise
#@-node:ekr.20061031131434.103:makeMasterGuiBinding
#@+node:ekr.20061031131434.105:masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    c.setLog()
    trace = False or c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        return val
#@nonl
#@+node:ekr.20061031131434.106:<< define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
#@nonl
#@-node:ekr.20061031131434.106:<< define specialKeysyms >>
#@+node:ekr.20061031131434.107:<< add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
#@-node:ekr.20061031131434.107:<< add character to history >>
#@+node:ekr.20061031131434.108:callStateFunction
def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val
#@-node:ekr.20061031131434.108:callStateFunction
#@+node:ekr.20061031131434.109:callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func
#@-node:ekr.20061031131434.109:callKeystrokeFunction (not used)
#@+node:ekr.20061031131434.110:handleDefaultChar
def handleDefaultChar(self,event,stroke):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: pass # Ignore the key.
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
#@-node:ekr.20061031131434.110:handleDefaultChar
#@-node:ekr.20061031131434.105:masterCommand & helpers
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    # g.trace('ch',repr(ch))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace(changed)
    if changed:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)
    
    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75
    
    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
                                                            
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s[i:j]))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]
        
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        # g.trace('n',n)
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@nonl
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@+node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
class leoKeyEvent:
    
    '''A gui-independent wrapper for gui events.'''
    
    def __init__ (self,event,c):
        
        # g.trace('leoKeyEvent(tkGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        
        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)
        
        self.widget = self.w
#@nonl
#@-node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
#@+node:ekr.20070123085931: tkKeys.defineSpecialKeys
def defineSpecialKeys (self):
    
    k = self
    
    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        ">" : "greater",
        "<" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }
    
    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s
        
    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict.keys():
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key
    
#@-node:ekr.20070123085931: tkKeys.defineSpecialKeys
#@+node:ekr.20061031131434.146:masterKeyHandler
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''

    << define vars >>
    if keysym in special_keys: return None
    trace = False or c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    if trace:
        g.trace('stroke:',stroke,'keysym:',event.keysym,'ch:',repr(event.char),
            'state.kind:',k.state.kind,g.callers(4))
        # if (self.master_key_count % 100) == 0: g.printGcSummary(trace=True)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        g.trace('special case')
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>
        
    << handle per-pane bindings >>
    << handle keys without bindings >>
#@+node:ekr.20061031131434.147:<< define vars >>
k = self ; c = k.c ; gui = g.app.gui

if event: event = gui.leoKeyEvent(event,c)

w = event.widget
char = event.char
keysym = event.keysym
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1
#@nonl
#@-node:ekr.20061031131434.147:<< define vars >>
#@+node:ekr.20061031131434.149:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            ok = k.handleMiniBindings(event,state,stroke)
            if ok:
                return 'break'
            elif stroke and len(stroke) == 1:
                # if trace: g.trace('calling modeHelp')
                k.modeHelp(event)
                return 'break'
            else:
                # End the mode and fall through to the pane bindings!
                k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
#@-node:ekr.20061031131434.149:<< handle mode bindings >>
#@+node:ekr.20061031131434.150:<< handle per-pane bindings >>
key_states = ('command','insert','overwrite')
isPlain =  k.isPlainKey(stroke)

# g.trace('w_name',w_name,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))
# g.trace('button',k.masterBindingsDict.get('button'))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        key in key_states and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d.keys())
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
#@-node:ekr.20061031131434.150:<< handle per-pane bindings >>
#@+node:ekr.20061031131434.151:<< handle keys without bindings >>
if stroke and k.isPlainKey(stroke) and k.unboundKeyAction in ('insert','overwrite'):
    # insert/overwrite normal character.  <Return> is *not* a normal character.
    if trace: g.trace('plain key in insert mode',stroke)
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
    
elif keysym.find('Escape') != -1:
    # Never insert escape characters.
    return 'break'

else:
    # g.trace(stroke,char,keysym)
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@-node:ekr.20061031131434.151:<< handle keys without bindings >>
#@+node:ekr.20061031131434.152:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = False or c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                if not k.silentMode:
                    c.minibufferWantsFocus()
                return True

    return False
#@-node:ekr.20061031131434.152:handleMiniBindings
#@-node:ekr.20061031131434.146:masterKeyHandler
#@-node:ekr.20070123160127:Use plain ascii characters instead of special Tk symbols
#@+node:ekr.20070124094705:Removed all calls to Tk.Text.bbox
# One call to Tk.Canvas.bbox remains, but that is in leoTkinterTree so it has no effect on portability.
#@nonl
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    
    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j+1)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@+node:ekr.20060113130510:extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.
    
    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)
        
    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@nonl
#@-node:ekr.20060113130510:extendHelper
#@-node:ekr.20070124094705:Removed all calls to Tk.Text.bbox
#@-node:ekr.20061029091904.1:Features
#@+node:ekr.20061127100022.1:Menu reorgs
#@+node:ekr.20031218072017.3785:createMenusFromTables & helpers
def createMenusFromTables (self):
    
    c = self.c
    
    self.defineMenuTables()
    
    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()
    
    g.doHook("create-optional-menus",c=c)
    
    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()
#@+node:ekr.20031218072017.3790:createFileMenuFromTable
def createFileMenuFromTable (self):
    
    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("Tan&gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:createFileMenuFromTable
#@+node:ekr.20031218072017.3786:createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>
    
    self.createMenuEntries(editMenu,self.editMenuTop2Table)
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:createEditMenuFromTable
#@+node:ekr.20031218072017.3797:createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")
    
    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)
    
    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:createOutlineMenuFromTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&Cmds')
    
    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Cursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('M&inibuffer',         self.cmdsMenuMinibufferTable),
        #('&Panes...',           self.cmdsMenuPanesTable),
        ('&Pickers...',         self.cmdsMenuPickersTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('R&un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',    self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,t,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &To...',                self.cursorMenuExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.3802:createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")
    
    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
#@-node:ekr.20031218072017.3802:createWindowMenuFromTable
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        self.getMacHelpMenu()
    else:
        helpMenu = self.createNewMenu("&Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@-node:ekr.20031218072017.3785:createMenusFromTables & helpers
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()

#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    self.editMenuTopTable = [
        # &: u,r reserved for undo/redo: a,d,p,t,y.
        # & (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&t','cut-text'),
        ('Cop&y','copy-text'),
        ('&Paste','paste-text'),
        ('&Delete','backward-delete-char'),
        ('Select &All','select-all'),
        '-',
    ]
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):
    
    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&section',
        '*extract-&names',
        '*&extract',
        '-',
        '*convert-all-b&lanks',
        '*convert-all-t&abs',
        '*convert-&blanks',
        '*convert-&tabs',
        '*insert-body-&time',
        '*&reformat-paragraph',
        '-',
        '*&indent-region',
        '*&unindent-region',
        '*&match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):
    
    self.editMenuEditHeadlineTable = [
        '*edit-&headline',
        '*&end-edit-headline',
        '*&abort-edit-headline',
        '*insert-headline-&time',
        '*toggle-&angle-brackets',
    ]
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&open-find-tab',
        '*&hide-find-tab',
        '*search-&with-present-options',
        '-',
        '*find-&next',
        '*find-&prev',
        '*&change',
        '*find-&all',
        '*clone-fi&nd-all',
        '*change-a&ll',
        '-',
        '*&find-character',
        '*find-character-extend-&selection',
        '*&backward-find-character',
        '*backward-find-character-&extend-selection',
        '-',
        '*&isearch-forward',
        '*isea&rch-backward',
        '*isearch-forward-rege&xp',
        '*isearch-backward-regex&p',
        '-',
        '*&query-replace',
        '*q&uery-replace-regex',
    ]
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):
    
    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")
        
    self.editMenuTop2Table = [
        '*&goto-global-line',
        '*&execute-script',
        (label,'toggle-invisibles'),
        ("Setti&ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):
    
    self.fileMenuTopTable = [
        '*&new',
        ('&Open...','open-outline'),
    ]
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):
    
    self.fileMenuTop2Table = [
        '-',
        ('&Close','close-window'),
        ('&Save','save-file'),
        ('Save &As','save-file-as'),
        ('Save &To','save-file-to'),
        ('Re&vert To Saved','revert'),
    ]
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):
    
    self.fileMenuReadWriteMenuTable = [
        '*&read-outline-only',
        ('Read @file &Nodes','read-at-file-nodes'),
        ('Write &Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &Missing @file Nodes','write-missing-at-file-nodes'),
        '*write-&outline-only',
        ('&Write @file Nodes','write-at-file-nodes'),
    ]
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):
    
    self.fileMenuTangleMenuTable = [
        '*tangle-&all',
        '*tangle-&marked',
        '*&tangle',
    ]
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):
    
    self.fileMenuUntangleMenuTable = [
        '*untangle-&all',
        '*untangle-&marked',
        '*&untangle',
    ]
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):
    
    self.fileMenuImportMenuTable = [
        #&: c,d,f,n,o,r,
        '*import-&derived-file',
        ('Import To @&file','import-at-file'),
        ('Import To @&root','import-at-root'),
        '*import-&cweb-files',
        '*import-&noweb-files',
        '*import-flattened-&outline',
    ]
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):
    
    self.fileMenuExportMenuTable = [
        '*export-&headlines',
        '*outline-to-&cweb',
        '*outline-to-&noweb',
        '*&flatten-outline',
        '*&remove-sentinels',
        '*&weave',
    ]
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):
    
    self.fileMenuTop3MenuTable = [
        ('E&xit','exit-leo'),
    ]
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&ut-node',
        '*c&opy-node',
        '*&paste-node',
        ('Pas&te Node As Clone','paste-retaining-clones'),
        '*&delete-node',
        '-',
        '*&insert-node',
        '*&clone-node',
        '*sort-childre&n',
        '*&sort-siblings',
        '-',
        '*&hoist',
        ('D&e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    self.outlineMenuCheckOutlineMenuTable = [
        # &: a,c,d,o
        '*check-&outline',
        '*&dump-outline',
        '-',
        '*check-&all-python-code',
        '*&check-python-code',
    ]
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    self.outlineMenuExpandContractMenuTable = [
        '*&contract-all',
        '*contract-&node',
        '*contract-&parent',
        '*contract-or-go-&left',
        '-',
        '*expand-p&rev-level',
        '*expand-n&ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&1',
        '*expand-to-level-&2',
        '*expand-to-level-&3',
        '*expand-to-level-&4',
        '*expand-to-level-&5',
        '*expand-to-level-&6',
        '*expand-to-level-&7',
        '*expand-to-level-&8',
        '-',
        '*expand-&all',
        '*expand-n&ode',
    ]
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    self.outlineMenuMoveMenuTable = [
        ('Move &Down','move-outline-down'),
        ('Move &Left','move-outline-left'),
        ('Move &Right','move-outline-right'),
        ('Move &Up','move-outline-up'),
        '-',
        '*&promote',
        '*&demote',
    ]
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    self.outlineMenuMarkMenuTable = [
        '*&mark',
        '*mark-&subheads',
        '*mark-changed-&items',
        '*mark-changed-&roots',
        '*mark-&clones',
        '*&unmark-all',
    ]
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &: a,c,d,e,g,i,l,m,n,o,p,r,s,t,v,x
        ('Go Prev Visite&d','go-back'),
        ('Go Next Visited','go-forward'),
        ('Go To P&rev Node','goto-prev-node'),
        ('Go To N&ext Node','goto-next-node'),
        '-',
        ('Go To Next &Marked','goto-next-marked'),
        ('Go To Next &Changed','goto-next-changed'),
        ('Go To Next &Clone','goto-next-clone'),
        '-',
        ('&Go To First Node','goto-first-node'),
        ('G&o To Prev Visible','goto-prev-visible'),
        ('Go To Ne&xt Visible','goto-next-visible'),
        ('Go To L&ast Node','goto-last-node'),
        ('Go To Last &Visible','goto-last-visible'),
        '-',
        ('Go To &Parent','goto-parent'),
        ('Go To First &Sibling','goto-first-sibling'),
        ('Go To Last S&ibling','goto-last-sibling'),
        ('Go To Prev Sibli&ng','goto-prev-sibling'),
        ('Go To Next Siblin&g','goto-next-sibling'),
    ]
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    if 0: # Replaced by minibuffer submenu.
        self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()
#@nonl
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
def defineCmdsMenuAbbrevTable (self):
    
    self.cmdsMenuAbbrevTable = [
        # &: a,e,i,k,l,r,w,v
        'abbre&v-mode',
        '-',
        '&list-abbrevs',
        '&read-abbrev-file',
        '&write-abbrev-file',
        '-',
        '&add-global-abbrev',
        '&inverse-add-global-abbrev',
        '&kill-all-abbrevs',
        '-',
        # 'expand-abbrev', # Not a command
        '&expand-region-abbrevs',
    ]
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
#@+node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &: a,c,d
        '&add-editor',
        '&cycle-editor-focus',
        '&delete-editor',
    ]
#@nonl
#@-node:ekr.20060912093104:defineCmdsMenuBodyEditorsTable
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&append-to-buffer',
        '&kill-buffer',
        'list-&buffers',
        '&list-buffers-alphabetically',
        '&prepend-to-buffer',
        '&rename-buffer',
        '&switch-to-buffer',
    ]
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]
    
    self.cursorMenuExtendTable = [
        # &: l,p,s,w
        'extend-to-&line',
        'extend-to-&paragraph',
        'extend-to-&sentence',
        'extend-to-&word',
    ]
    
    self.cursorMenuForwardTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&end-word',
        'forward-&word',
        '-',
        '&next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&end-word-extend-selection',
        'forward-&word-extend-selection',#
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20060923060822:defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
#@-node:ekr.20060923060822:defineCmdsMenuFocusTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable
def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&load-file',
        '-',
        '&start-kbd-macro',
        '&end-kbd-macro',
        '&name-last-kbd-macro',
        '-',
        '&call-last-keyboard-macro',
        '&insert-keyboard-macro',
    ]
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable
#@+node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
def defineCmdsMenuMinibufferTable (self):
    
    self.cmdsMenuMinibufferTable = [
        # &: f,h,i,q,r,s,v
        '&full-command',
        'keyboard-&quit',
        '&repeat-complex-command',
        '&view-lossage',
        '-',
        '&show-mini-buffer',
        'h&ide-mini-buffer',
        '-',
        '&help-for-minibuffer',
    ]
#@-node:ekr.20061011084101.1:defineCmdsMenuMinibufferTable
#@+node:ekr.20061011085641:defineCmdsMenuPickersTable
def defineCmdsMenuPickersTable (self):
    
    self. cmdsMenuPickersTable = [
        'show-&colors',
        'show-find-&options',
        'show-&fonts',
    ]
#@nonl
#@-node:ekr.20061011085641:defineCmdsMenuPickersTable
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&clear-rectangle',
        'c&lose-rectangle',
        '&delete-rectangle',
        '&kill-rectangle',
        '&open-rectangle',
        '&string-rectangle',
        '&yank-rectangle',
    ]
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &: a,c,e,i,j,n,p,r,v
        '&append-to-register',
        'copy-r&ectangle-to-register',
        '&copy-to-register',
        'i&ncrement-register',
        '&insert-register',
        '&jump-to-register',
        # 'number-to-register',
        '&point-to-register',
        'p&repend-to-register',
        '&view-register',
    ]
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
#@+node:ekr.20061119061958:defineCmdsMenuRunTable
def defineCmdsMenuRunTable (self):
    
    self.cmdsMenuRunTable = [
    # &: e,r
    '&execute-script',
    '&run-unit-tests',
    ]
#@-node:ekr.20061119061958:defineCmdsMenuRunTable
#@+node:ekr.20060923060822.1:defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-&down',
        'scroll-&up',
        '-',
        'scroll-down-&extend-selection',
        'scroll-up-e&xtend-selection',
    ]
#@nonl
#@-node:ekr.20060923060822.1:defineCmdsMenuScrollTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&open-spell-tab',
        'spell-&change',
        'spell-change-&then-find',
        'spell-&find',
        'spell-&ignore',
    ]
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@+node:ekr.20060924161901:defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&beautify',
        'beautify-&all',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
#@nonl
#@-node:ekr.20060924161901:defineCmdsMenuTextTable
#@+node:ekr.20060926161940:defineCmdsMenuToggleTable
def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &: d,e,m,s,t,u,v
        'toggle-a&utocompleter',
        'toggle-call&tips',
        'toggle-&extend-mode',
        'toggle-input-&state',
        'toggle-in&visibles',
        'toggle-&mini-buffer',
        'toggle-split-&direction',
        '-',
        # &: a,b,c,f,h,i,r,w,x
        'toggle-find-&ignore-case-option',
        'toggle-find-in-&body-option',
        'toggle-find-in-&headline-option',
        'toggle-find-mark-&changes-option',
        'toggle-find-mark-&finds-option',
        'toggle-find-rege&x-option',
        'toggle-find-&reverse-option',
        'toggle-find-&word-option',
        'toggle-find-wrap-&around-option',
    ]
#@-node:ekr.20060926161940:defineCmdsMenuToggleTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):
    
    self.windowMenuTopTable = [
        # &: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&equal-sized-panes',
        '*&toggle-active-pane',
        '*toggle-&split-direction',
        '-',
        '*contract-&body-pane',
        '*contract-&log-pane',
        '*contract-&outline-pane',
        '*contract-&pane',
        '-',
        '*expand-bo&dy-pane',
        '*expand-lo&g-pane',
        '*expand-o&utline-pane',
        '*expand-pa&ne',
        '-',
        '*&fully-expand-body-pane',
        '*full&y-expand-log-pane',
        '*fully-e&xpand-outline-pane',
        '*fully-exp&and-pane',
        '-',
        '*&resize-to-screen',
        '*&cascade-windows',
        '*&minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&window',
    ]
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        # ('Open t&est.leo',          'open-test-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@-node:ekr.20061127100022.1:Menu reorgs
#@+node:ekr.20061101091734:Plugins
#@+node:ekr.20061101091443:Changed bindings in UniversalScrolling pluing
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991223

I assigned both Control and Shift modifiers to do scrolling: this is so my
finger can hit a key in the lower left corner of the keyboard, and I don't have
to worry too much about my aim (I have LARGE fingers). Also, I stop the
scrolling on the JUST button release -- less worry about my finger slipping off
the key.
#@nonl
#@-node:ekr.20061101091443:Changed bindings in UniversalScrolling pluing
#@+node:ekr.20061108095736:Registered write-restructured-text command in rst3 plugin
#@-node:ekr.20061108095736:Registered write-restructured-text command in rst3 plugin
#@-node:ekr.20061101091734:Plugins
#@+node:ekr.20061030105954:Settings
#@+node:ekr.20060915175024:Added @bool center_selected_tree_node
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3916155

When a node is among several other nodes at the same level of hierarchy, which
are all children of a node, and the "MOVE LFET" command is executed, the node
does move left in the outline hierarchy, but it also move down to just before
the next node at the higher hierarchy level - the level to which it is moving
left.

EKR: I love this new option: how did we ever live without it?

@color
#@nonl
#@-node:ekr.20060915175024:Added @bool center_selected_tree_node
#@+node:ekr.20061030101258:Added @bool invisible_outline_navigation = False
@nocolor

This option tells how to treat an uppercase letter typed when the outline pane
is active but no headline is being edited. In such situations Leo searchs for an
node whose headline starts with the present prefix, ignoring case The prefix
starts with the first letter typed and other letters are added if they are typed
within a 'short' period of time, as specified by the outline_nav_extend_delay

True: Look in invisible nodes.
False: Look only in visible nodes.

I set this option to False because it is too easy form me to type Shift-whatever
when I meant Ctrl-whatever.

@color
#@nonl
#@-node:ekr.20061030101258:Added @bool invisible_outline_navigation = False
#@+node:ekr.20061028211323:Added @bool show_full_tracebacks_in_scripts
http://sourceforge.net/forum/message.php?msg_id=3985382

#@-node:ekr.20061028211323:Added @bool show_full_tracebacks_in_scripts
#@-node:ekr.20061030105954:Settings
#@-node:ekr.20061029091751:Leo 4.4.3 alpha 1 projects
#@+node:ekr.20070129082731:Leo 4.4.3 alpha 2 porjects
#@+node:ekr.20070129082731.1:Bugs
#@+node:ekr.20070129081218:Fixed bugs in undo/redoNodeContents
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
#@-node:ekr.20040305223522:c.setBodyString
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl
    
    u.p.setTnodeText(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead) # New in 4.4b2.

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):
    
    u = self ; c = u.c ; w = c.frame.body.bodyCtrl
    
    # Restore the body.
    u.p.setTnodeText(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)
    
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.
    
    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@-node:ekr.20070129081218:Fixed bugs in undo/redoNodeContents
#@+node:ekr.20070202082032:Fixed minor xml problem
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4132529

I'm generating Leo files with ElementTree and ran into a minor issue.

ElementTree generates an empty tag with a space before the closing slash:
    
<globals />

in Leo's code for dummy elements to allow copied nodes to be valid Leo files,
the empty tags are generated without the space

leoFileCommands.py 2917
        self.put('<globals/>\n')
        self.put('<preferences/>\n')
        self.put('<find_panel_settings/>\n')
        
it then checks for these tags in getDummyElements() leoFileCommands.py 1298

Since ElementTree has the space before the slash, 
it's XML is considered invalid by Leo according to
this test.

I would like it if the space could be added in Leo's
self.put(...) and the check in getDummyElements()

The XML specs show the space as optional.

@color
#@nonl
#@+node:ekr.20031218072017.1971:putClipboardHeader
def putClipboardHeader (self):

    c = self.c ; tnodes = 0
    << count the number of tnodes >>
    self.put('<leo_header file_format="1" tnodes=')
    self.put_in_dquotes(str(tnodes))
    self.put(" max_tnode_index=")
    self.put_in_dquotes(str(tnodes))
    self.put("/>") ; self.put_nl()
    
    # New in Leo 4.4.3: Add dummy elements so copied nodes form a valid .leo file.
    self.put('<globals/>\n')
    self.put('<preferences/>\n')
    self.put('<find_panel_settings/>\n')
#@+node:ekr.20031218072017.1972:<< count the number of tnodes >>
c.clearAllVisited()

for p in c.currentPosition().self_and_subtree_iter():
    t = p.v.t
    if t and not t.isWriteBit():
        t.setWriteBit()
        tnodes += 1
#@-node:ekr.20031218072017.1972:<< count the number of tnodes >>
#@-node:ekr.20031218072017.1971:putClipboardHeader
#@+node:ekr.20061209141653:getDummyElements
def getDummyElements (self):
    
    # New in Leo 4.4.3: Ignore the dummy elements that allow
    # Pasted Leo outlines to be valid .leo files.
    while 1:
        for tag in ('<globals','<preferences','<find_panel_settings'):
            if self.matchTag(tag) and self.matchTag('/>'):
                break
        else:
            break
#@-node:ekr.20061209141653:getDummyElements
#@-node:ekr.20070202082032:Fixed minor xml problem
#@+node:ekr.20070201172535:Fixed C++ import bug
#@+node:ekr.20070202093833:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4134384
By: rshanley

A C++ sourcefile that opens and closes multiple namespace blocks messes up the
import. I noticed this for a source file that would 1) open a namespace block
to define a class, 2) close the namespace block and provide the constructor
for the class just defined, and 3) repeat 1) and 2) many times. When this first
occured I thought leo was hung, the word "namepace" appeared in the log pane
13 times where the actual number of namespace blocks was 10, and the .leo file
grew by 24 Mb. When the offending @file node was deleted, the size of the file
shrunk from about 33 Mb to about 9 Mb.

The following small test file causes Import To @File to produce a corrupt
outline.

On a positive note, I have been using leo profitably in navigating unfamiliar
C++ source code for about two months in concert with other tools. This is the
first problem I've had, other than cockpit error.

@color
@language c++

namespace arb
{
    class a: public dbm::X
    {
    public:
        a(int c);
    private:
        int m_a;
    };
}

arb::a::a
(
    int c
)
{
    m_a = c**2;
}


namespace arb
{
    class b: public dbm::X
    {
    public:
    b(int c);
    private:
    int m_a;
    };
}

arb::a::b
(
int c
)
{
m_b = c**2;
}


namespace arb
{

class c: public dbm::X
{
public:
c(int c);
private:
int m_a;
};
}

arb::a::c
(
int c
)
{
m_a = c**2;
}

namespace arb
{

class d: public dbm::X
{
public:
d(int c);
private:
int m_a;
};
}

arb::a::d
(
int c
)
{
m_a = c**2;
}
#@-node:ekr.20070202093833:Report
#@+node:ekr.20031218072017.3250:scanCText
# Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):
    
    scanner = self.cScanner(self)
    scanner.scan(s,parent)
    
#@nonl
#@-node:ekr.20031218072017.3250:scanCText
#@+node:ekr.20070202105339.1:class cScanner
@
The C scanner uses an internal class as an organizational aid. This is far
superior, imo, to using a single huge scanCText function organized with noweb
section references. Indeed, the helper class creates a separate namespace for
use by the various helper functions.

At present only the C scanner uses this organization, and the utilities of the
cScanner class are identical to the utilites of the leoImportCommands class.
This duplication would go away if all the scanners derived from a baseScanner
class, but that is not likely any time soon, if ever.
@c

class cScanner:
    @others
#@nonl
#@+node:ekr.20070202105914:cScanner.ctor
def __init__ (self,importer):

    # Copy ivars.
    self.c = importer.c
    self.encoding = importer.encoding
    self.methodKind = g.choose(importer.fileType==".c","functions","methods")
    self.methodName = importer.methodName
    self.rootLine = importer.rootLine
    self.treeType = importer.treeType
    
    # Other ivars.
    self.function_start = 0
    self.name = None
    self.scan_start = 0
#@-node:ekr.20070202105914:cScanner.ctor
#@+node:ekr.20070203074709:Utilities (should be in base class)
#@+node:ekr.20070203074709.1:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace("parent,headline:",parent,headline)
    # Create the vnode.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)
    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070203074709.1:createHeadline
#@+node:ekr.20070203074709.2:error
def error (self,s): g.es(s)
#@-node:ekr.20070203074709.2:error
#@+node:ekr.20070203074709.3:getLeadingIndent
def getLeadingIndent (self,s,i):

    """Return the leading whitespace of a line, ignoring blank and comment lines."""

    i = g.find_line_start(s,i)
    while i < len(s):
        # g.trace(g.get_line(s,i))
        j = g.skip_ws(s,i) # Bug fix: 2/14/03
        if g.is_nl(s,j) or g.match(s,j,"#"): # Bug fix: 2/14/03
            i = g.skip_line(s,i) # ignore blank lines and comment lines.
        else:
            i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
            # g.trace("returns:",width)
            return width
    # g.trace("returns:0")
    return 0
#@-node:ekr.20070203074709.3:getLeadingIndent
#@+node:ekr.20070203074709.4:isDocStart and isModuleStart
# The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):
    
    if not g.match(s,i,"@"):
        return False

    j = g.skip_ws(s,i+1)
    if g.match(s,j,"%defs"):
        return False
    elif self.webType == "cweb" and g.match(s,i,"@*"):
        return True
    else:
        return g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n")

def isModuleStart (self,s,i):

    if self.isDocStart(s,i):
        return True
    else:
        return self.webType == "cweb" and (
            g.match(s,i,"@c") or g.match(s,i,"@p") or
            g.match(s,i,"@d") or g.match(s,i,"@f"))
#@-node:ekr.20070203074709.4:isDocStart and isModuleStart
#@+node:ekr.20070203074709.5:massageBody
def massageBody (self,s,methodKind):
    
    # g.trace(s)
    # g.trace(g.get_line(s,0))
    c = self.c
    if self.treeType == "@file":
        if self.fileType == ".py": # 7/31/02: was "py"
            return self.undentBody(s)
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) > 0:
                return comment + "\n@c" + newLine + newBody
            else:
                return newBody
    else:
        # Inserts < < self.methodName methodKind > > =
        cweb = self.fileType == "c" and not c.use_noweb_flag
        lb = g.choose(cweb,"@<","<<")
        rb = g.choose(cweb,"@>=",">>=")
        intro = lb + " " + self.methodName + " " + methodKind + " " + rb
        if self.fileType == ".py": # 7/31/02: was "py"
            newBody = self.undentBody(s)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            return intro + newLine + newBody
        else:
            newBody, comment = self.skipLeadingComments(s)
            newBody = self.undentBody(newBody)
            newLine = g.choose(g.is_nl(newBody,0),"\n","\n\n")
            if len(comment) > 0:
                return comment + "\n" + intro + newLine + newBody
            else:
                return intro + newLine + newBody
#@-node:ekr.20070203074709.5:massageBody
#@+node:ekr.20070203074709.6:massageComment
def massageComment (self,s):

    """Returns s with all runs of whitespace and newlines converted to a single blank.
    
    Also removes leading and trailing whitespace."""

    s = s.strip()
    s = s.replace("\n"," ")
    s = s.replace("\r"," ")
    s = s.replace("\t"," ")
    s = s.replace("  "," ")
    s = s.strip()
    return s
#@-node:ekr.20070203074709.6:massageComment
#@+node:ekr.20070203074709.7:massageWebBody
def massageWebBody (self,s):

    theType = self.webType
    lb = g.choose(theType=="cweb","@<","<<")
    rb = g.choose(theType=="cweb","@>",">>")
    << Remove most newlines from @space and @* sections >>
    << Replace abbreviated names with full names >>
    s = string.rstrip(s)
    return s
#@+node:ekr.20070203074709.8:<< Remove most newlines from @space and @* sections >>
i = 0
while i < len(s):
    i = g.skip_ws_and_nl(s,i)
    if self.isDocStart(s,i):
        # Scan to end of the doc part.
        if g.match(s,i,"@ %def"):
            # Don't remove the newline following %def
            i = g.skip_line(s,i) ; start = end = i
        else:
            start = end = i ; i += 2
        while i < len(s):
            i = g.skip_ws_and_nl(s,i)
            if self.isModuleStart(s,i) or g.match(s,i,lb):
                end = i ; break
            elif theType == "cweb": i += 1
            else: i = g.skip_to_end_of_line(s,i)
        # Remove newlines from start to end.
        doc = s[start:end]
        doc = string.replace(doc,"\n"," ")
        doc = string.replace(doc,"\r","")
        doc = string.strip(doc)
        if doc and len(doc) > 0:
            if doc == "@":
                doc = g.choose(self.webType=="cweb", "@ ","@\n")
            else:
                doc += "\n\n"
            # g.trace("new doc:",doc)
            s = s[:start] + doc + s[end:]
            i = start + len(doc)
    else: i = g.skip_line(s,i)
#@-node:ekr.20070203074709.8:<< Remove most newlines from @space and @* sections >>
#@+node:ekr.20070203074709.9:<< Replace abbreviated names with full names >>
i = 0
while i < len(s):
    # g.trace(g.get_line(s,i))
    if g.match(s,i,lb):
        i += 2 ; j = i ; k = g.find_on_line(s,j,rb)
        if k > -1:
            name = s[j:k]
            name2 = self.cstLookup(name)
            if name != name2:
                # Replace name by name2 in s.
                # g.trace("replacing %s by %s" % (name,name2))
                s = s[:j] + name2 + s[k:]
                i = j + len(name2)
    i = g.skip_line(s,i)
#@-node:ekr.20070203074709.9:<< Replace abbreviated names with full names >>
#@-node:ekr.20070203074709.7:massageWebBody
#@+node:ekr.20070203074709.10:setEncoding
def setEncoding (self):
    
    # scanDirectives checks the encoding: may return None.
    theDict = g.scanDirectives(self.c)
    encoding = theDict.get("encoding")
    if encoding and g.isValidEncoding(encoding):
        self.encoding = encoding
    else:
        self.encoding = g.app.tkEncoding # 2/25/03

    # print self.encoding
#@-node:ekr.20070203074709.10:setEncoding
#@+node:ekr.20070203074709.11:skipLeadingComments
def skipLeadingComments (self,s):

    """Skips all leading comments in s, returning the remaining body text and the massaged comment text.

    Returns (body, comment)"""

    # g.trace(g.get_line(s,0))
    s_original = s
    s = s.lstrip()
    i = 0 ; comment = ""
    if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
        << scan for C-style comments >>
    elif self.fileType == ".lua":
        << scan for Lua comments >>
    elif self.fileType == ".pas":
        << scan for Pascal comments >>
    elif self.fileType == ".py":
        << scan for Python comments >>
    comment = string.strip(comment)
    if len(comment) == 0:
        return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
    elif self.treeType == "@file":
        return s[i:], "@ " + comment
    else:
        return s[i:], "@ " + comment + "\n"
#@+node:ekr.20070203074709.12:<< scan for C-style comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a C++ comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,"/*"): # Handle a block C comment.
        j = i + 2 ; i = g.skip_block_comment (s,i)
        k = g.choose(g.match(s,i-2,"*/"),i-2,i)
        if self.fileType == ".java":
            # 8/2/02: a hack: add leading whitespace then remove it.
            comment = self.undentBody(comment)
            comment2 = ' ' * 2 + s[j:k]
            comment2 = self.undentBody(comment2)
            comment = comment + comment2 + "\n"
        else:
            comment = comment + self.massageComment(s[j:k]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.12:<< scan for C-style comments >>
#@+node:ekr.20070203074709.13:<< scan for Lua comments >>
while i < len(s):
    if g.match(s,i,"--"): # Handle a Lua line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.13:<< scan for Lua comments >>
#@+node:ekr.20070203074709.14:<< scan for Pascal comments >>
while i < len(s):
    if g.match(s,i,"//"): # Handle a Pascal line comment.
        while g.match(s,i,'/'):
            i += 1
        j = i ; i = g.skip_line(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    elif g.match(s,i,'(*'):
        j = i + 1 ; i = g.skip_pascal_block_comment(s,i)
        comment = comment + self.massageComment(s[j:i]) + "\n"
        # 8/2/02: Preserve leading whitespace for undentBody
        i = g.skip_ws(s,i)
        i = g.skip_blank_lines(s,i)
    else: break
#@-node:ekr.20070203074709.14:<< scan for Pascal comments >>
#@+node:ekr.20070203074709.15:<< scan for Python comments >>
while i < len(s) and g.match(s,i,'#'):
    j = i + 1 ; i = g.skip_line(s,i)
    comment = self.undentBody(comment)
    comment = comment + self.massageComment(s[j:i]) + "\n"
    # 8/2/02: Preserve leading whitespace for undentBody
    i = g.skip_ws(s,i)
    i = g.skip_blank_lines(s,i)
#@-node:ekr.20070203074709.15:<< scan for Python comments >>
#@-node:ekr.20070203074709.11:skipLeadingComments
#@+node:ekr.20070203074709.16:undentBody
# We look at the first line to determine how much leading whitespace to delete.

def undentBody (self,s):

    """Removes extra leading indentation from all lines."""

    # g.trace(s)
    i = 0 ; result = ""
    # Copy an @code line as is.
    if g.match(s,i,"@code"):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]
    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i)
    if undent == 0: return s
    while i < len(s):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        line = s[j:i]
        # g.trace(line)
        line = g.removeLeadingWhitespace(line,undent,self.tab_width)
        result += line
    return result
#@-node:ekr.20070203074709.16:undentBody
#@-node:ekr.20070203074709:Utilities (should be in base class)
#@+node:ekr.20070202105914.1:scan & helpers
def scan (self,s,parent,init=True):
    
    c = self.c
    if init:
        c.appendStringToBody(parent,"@ignore\n" + self.rootLine + "@language c\n")
    else:
        saveData = self.name,self.function_start,self.scan_start

    self.name,self.function_start,self.scan_start = '',0,0
    i = 0
    while i < len(s):
        progress = i
        ch = s[i]
        # if i == 0 or ch == '\n': g.trace('line',repr(g.get_line(s,i)))
        # g.trace('ch',repr(ch))
        if ch == '/':         i = self.skipComments(s,i)
        elif ch in ('"',"'"): i = g.skip_string(s,i)
        elif ch == '(':     i = self.doOuterParen(s,i,parent) # Possible function/method definition.
        elif ch == ';':     i = self.doSemicolon(s,i) # Signals a possible start of a function.
        elif g.is_c_id(ch): i = self.doId(s,i,parent) # Possible class/namespace definition.
        else: i += 1
        assert i > progress
    self.appendUnusedText(s,i,parent)
    if init:
        if parent.hasChildren(): c.appendStringToBody(parent,'@others')
    else:
        self.name,self.function_start,self.scan_start = saveData
#@nonl
#@+node:ekr.20070202111549:appendUnusedText
def appendUnusedText (self,s,i,parent):
    
    c = self.c
    
    i = g.skip_ws_and_nl(s,self.scan_start)
    if i < len(s):
        s2 = s[self.scan_start:]
        # g.trace(repr(s2))
        c.appendStringToBody(parent,s2)
#@-node:ekr.20070202111549:appendUnusedText
#@+node:ekr.20031218072017.3257:doId
def doId (self,s,i,parent):
    
    j = i ; i = g.skip_c_id(s,i)
    name = s[j:i]
    if name in ('class','namespace'):
        i = self.doInner(s,j,parent,name)
    else:
        self.name = name
        while g.match(s,i,'::'):
            self.name = self.name + '::'
            i = g.skip_ws_and_nl(s,i+2)
            if g.match(s,i,'~'):
                i += 1
                self.name = self.name + '~'
            i = g.skip_ws_and_nl(s,i)
            j = i ; i = g.skip_c_id(s,i)
            name2 = s[j:i]
            self.name = self.name + name2
    return i
#@-node:ekr.20031218072017.3257:doId
#@+node:ekr.20070203153208:doInner
def doInner (self,s,i,parent,kind):
    
    '''Handle a namespace or class definition.'''

    c = self.c
    start = i
    i += len(kind)
    j = g.skip_ws_and_nl(s,i)
    i = g.skip_c_id(s,j)
    name = s[j:i].strip()
    if not name: return i
    i = g.skip_ws_and_nl(s,i)
    bracket = i
    if not g.match(s,i,'{'): return i
    i = g.skip_braces(s,i)
    if g.match(s,i,'}'):
        end = i
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,';'): i += 1
        # Append previous text.
        prev = s[self.scan_start:start]
        c.appendStringToBody(parent,prev)
        self.scan_start = self.function_start = i
        preamble = s[start:bracket+1]
        # Create children.
        p = self.createHeadline(parent,headline='%s %s' % (kind,name),body=preamble)
        body = s[bracket+1:end]
        self.scan(body,p.copy(),init=False)
        # Finish the text.
        if p.hasChildren(): c.appendStringToBody(p,'\n\t@others')
        c.appendStringToBody(p,s[end:i])    
    else:
        g.trace('missing "}" following %s' % kind)
    return i
#@-node:ekr.20070203153208:doInner
#@+node:ekr.20031218072017.3262:doOuterParen
def doOuterParen (self,s,i,parent):
    
    '''Handle '(' at the top level.
    This begins a function/method if and only if the character after the matching ')' is '{'.'''
    
    # Skip the param list.  It may not be properly matched if there are #if's involved.
    c = self.c
    i = g.skip_parens(s,i)
    if not g.match(s,i,')'): return i
    i = g.skip_ws_and_nl(s,i+1)
    if g.match(s,i,';'):
        return self.doSemicolon(s,i)
    elif g.match(s,i,'='):
        # An initializer ends a declaration.
        i = g.skip_ws_and_nl(s,i+1)
        if g.match(s,i,'{'):
            i = g.skip_braces(s,i)
        self.function_start = i
        return i
    elif g.match(s,i,'{'):
        i = g.skip_braces(s,i)
        if g.match(s,i,'}'):
            i += 1
            # g.trace('function %s' % self.name)
            c.appendStringToBody(parent,s[self.scan_start:self.function_start])
            body = s[self.function_start:i]
            p = self.createHeadline(parent,headline=self.name,body=body)
        else:
            g.trace('no matching "}" in function/method definition')
        self.scan_start = self.function_start = i
        return i
    else:
        return i
#@-node:ekr.20031218072017.3262:doOuterParen
#@+node:ekr.20031218072017.3263:doSemicolon
def doSemicolon (self,s,i):

    self.function_start = i+1 # The semicolon ends the declaration.
    return i+1
#@-node:ekr.20031218072017.3263:doSemicolon
#@+node:ekr.20031218072017.3260:skipComments
def skipComments (self,s,i):

    if g.match(s,i,"//"):
        i = g.skip_line(s,i)
    elif g.match(s,i,"/*"):
        i = g.skip_block_comment(s,i)
    else:
        i += 1

    return i
#@-node:ekr.20031218072017.3260:skipComments
#@-node:ekr.20070202105914.1:scan & helpers
#@-node:ekr.20070202105339.1:class cScanner
#@-node:ekr.20070201172535:Fixed C++ import bug
#@+node:ekr.20070204123507:Fixed recent bug in next-line command
Down arrow wasn't handled properly.
#@nonl
#@+node:ekr.20060113105246.1:moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    
    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j+1)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    col2 = max(0,min(col,j2-i2-1))
    spot = i2 + col2
    # g.trace('spot',spot,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)
#@nonl
#@-node:ekr.20060113105246.1:moveUpOrDownHelper
#@-node:ekr.20070204123507:Fixed recent bug in next-line command
#@+node:ekr.20070212160231:Made standalone plugins manager work again
#@-node:ekr.20070212160231:Made standalone plugins manager work again
#@+node:ekr.20061127171128:Fixed wiki markup bug
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3994218
By: rich_ries

Leo 4.4.2.1 (also seen in 4.4 final)

I was commenting some code, using the markup marks for various emphases. When
I went back and moved the cursor over the first two characters (the hidden markup
characters) of the line, I got the following error message:

===========================================================
exception executing command
Traceback (most recent call last):

  File "...leoCommands.py",line 264, in doCommand
    val = command(event)

  File "...leoEditCommands.py", line 3703, in nextLine
    g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-1c') # works

  File "...leoEditCommands.py", line 3314, in moveUpOrDownHelper
    txt = w.get( 'insert linestart', 'insert lineend' )

TypeError: unpack non-sequence
===========================================================

I did not get this when moving the cursor over the visible characters.

@color
#@nonl
#@-node:ekr.20061127171128:Fixed wiki markup bug
#@-node:ekr.20070129082731.1:Bugs
#@+node:ekr.20070217114542:Features
#@+node:ekr.20070216105848:Warn on dubious section brackets
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4162357

@color
#@nonl
#@+node:ekr.20041005105605.199:hasSectionName
def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("<<",i)
        n2 = s.find(">>",i)
    else:
        n1 = s.find("<<",i,end)
        n2 = s.find(">>",i,end)
        
    ok = -1 < n1 < n2
    
    # New in Leo 4.4.3: warn on extra brackets.
    if ok:
        for ch,j in (('<',n1+2),('>',n2+2)):
            if g.match(s,j,ch):
                line = g.get_line(s,i)
                g.es('dubious brackets in %s' % line)
                break

    return ok, n1, n2
#@-node:ekr.20041005105605.199:hasSectionName
#@-node:ekr.20070216105848:Warn on dubious section brackets
#@-node:ekr.20070217114542:Features
#@+node:ekr.20070221095637:Eliminating flash
#@+node:ekr.20040803072955.91:onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = c.edit_widget(p)
    if not w: return
    
    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    << truncate s if it has multiple lines >>
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # if self.trace_edit and not g.app.unitTesting:
            # if changed:
                # g.trace('changed: old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(scroll=False) # New in 4.4.1
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
#@+node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
# Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) > 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) > limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
#@-node:ekr.20040803072955.94:<< truncate s if it has multiple lines >>
#@-node:ekr.20040803072955.91:onHeadChanged
#@+node:ekr.20031218072017.1720:save
def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)
    # redraw_flag = g.app.gui.guiName() == 'tkinter'
    if ok is None:
        c.beginUpdate()
        try:
            c.endEditing()# Set the current headline text.
            self.setDefaultDirectoryForNewFiles(fileName)
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
            if ok:
                c.setChanged(False) # Clears all dirty bits.
                g.es("saved: " + g.shortFileName(fileName))
                if c.config.save_clears_undo_buffer:
                    g.es("clearing undo")
                    c.undoer.clearUndoState()
        finally:
            c.endUpdate()
    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
#@-node:ekr.20031218072017.1720:save
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild (self,event=None):
    
    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeWantsFocusNow()
        return
        
    c.beginUpdate()
    try:
        # Bug fix: 2/22/07: put this inside the begin/endUpdate so only one redraw happens.
        if not p.isExpanded():
            c.expandNode()
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        c.treeWantsFocusNow()
        
def expandNodeOrGoToFirstChild (self,event=None):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        c.treeWantsFocusNow()
        return

    if not p.isExpanded():
        c.expandNode()
    else:
        c.beginUpdate()
        try:
            c.selectVnode(p.firstChild())
        finally:
            c.endUpdate()
    c.treeWantsFocusNow()
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
 
    if p.hasChildren() and p.isExpanded():
        c.contractNode()
    elif p.hasParent():
        c.goToParent()
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
        for p in p.parents_iter():
            if not p.isExpanded():
                p.expand()
                redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag
#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20070221095637:Eliminating flash
#@-node:ekr.20070129082731:Leo 4.4.3 alpha 2 porjects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
