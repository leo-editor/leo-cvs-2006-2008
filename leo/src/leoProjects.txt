#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20060901085739:4.4.1.1 projects
#@+node:ekr.20060831211210:Fixed unicode problems
@

http://sourceforge.net/forum/message.php?msg_id=3893628
#@nonl
#@+node:ekr.20051125080855:selfInsertCommand & helpers
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    if event and event.keysym == 'Return': ch = '\n' # This fixes the MacOS return bug.
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w) or (None,None)
    oldText = name.startswith('body') and p.bodyString() or ''
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    brackets = self.openBracketsList + self.closeBracketsList
    inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
    
    if trace: g.trace(name,repr(ch),ch in brackets)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        << handle newline >>
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)
        if inBrackets and self.flashMatchingBrackets: # New in 4.4.1.
           self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'
        
    # New in 4.4.1: Set the column for up and down keys.
    spot = w.index('insert')
    c.editCommands.setMoveCol(spot)

    # Update the text and handle undo.
    newText = g.app.gui.getAllText(w) # New in 4.4b3: converts to unicode.
    # g.trace(repr(newText))
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20060831163241:test_selfInsertCommand
def test_selfInsertCommand(self):
    
    self = c.editCommands
    import Tkinter as Tk

    event = g.Bunch(char='Ã‰',keysym=None,widget=c.frame.body.bodyCtrl)
    self.selfInsertCommand(event)
#@nonl
#@-node:ekr.20060831163241:test_selfInsertCommand
#@+node:ekr.20051026171121:<< handle newline >>
i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
    if (
        (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
        undoType != "Change"
    ):
        # No auto-indent if in @nocolor mode or after a Change command.
        self.updateAutoIndent(p,w)
#@-node:ekr.20051026171121:<< handle newline >>
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,index,ch):

    s = g.app.gui.getAllText(w)
    i = g.app.gui.toPythonIndex(s,w,index)
    
    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        j = g.app.gui.toGuiIndex(s,w,j)
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75

    def addFlashCallback(w,count,index):
        w.tag_add('flash',index,'%s+1c' % (index))
        w.after(delay,removeFlashCallback,w,count-1,index)
    
    def removeFlashCallback(w,count,index):
        w.tag_remove('flash','1.0','end')
        if count > 0:
            w.after(delay,addFlashCallback,w,count,index)

    try:
        w.tag_configure('flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)
#@-node:ekr.20051027172949:updateAutomatchBracket
#@+node:ekr.20051026171121.1:udpateAutoIndent
# By David McNab:
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = w.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        w.insert("insert",ws)
#@-node:ekr.20051026171121.1:udpateAutoIndent
#@+node:ekr.20051026092433:updateTab
def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width > 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)
#@-node:ekr.20051026092433:updateTab
#@-node:ekr.20051125080855:selfInsertCommand & helpers
#@-node:ekr.20060831211210:Fixed unicode problems
#@-node:ekr.20060901085739:4.4.1.1 projects
#@+node:ekr.20060824095221:4.4.1 final projects
#@+node:ekr.20060826062302:Removed warning about changed nodes
# Possibly a less intrusive warning should be used.
#@nonl
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just setting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # print "***",at.t,at.root.t
            g.es("Warning: updating changed text in %s" %
                (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20060824130443:Found: tempBodyString
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            c.setBodyString(p,s) # Sets c and p dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@+node:ekr.20041005105605.50:<< scan @+body >> 3.x
assert(g.match(s,i,"+body"))

child_out = [] ; child = p.copy() # Do not change out or p!
oldIndent = at.indent ; at.indent = lineIndent
at.scanText3(theFile,child,child_out,at.endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = g.toUnicode(body,g.app.tkEncoding) # 9/28/03

if at.importing:
    child.t.bodyString = body
else:
    child.t.tempBodyString = body

at.indent = oldIndent
#@-node:ekr.20041005105605.50:<< scan @+body >> 3.x
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just setting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # print "***",at.t,at.root.t
            g.es("Warning: updating changed text in %s" %
                (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just setting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if 0: # New in 4.4.1 final.  This warning can be very confusing.
        if not at.updateWarningGiven:
            at.updateWarningGiven = True
            # print "***",at.t,at.root.t
            g.es("Warning: updating changed text in %s" %
                (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
def  copyAllTempBodyStringsToTnodes (self,root,thinFile):
    
    c = self.c
    for p in root.self_and_subtree_iter():
        try: s = p.v.t.tempBodyString
        except: s = ""
        old_body = p.bodyString()
        if s != old_body:
            if 0: # For debugging.
                print ; print "changed: " + p.headString()
                print ; print "new:",s
                print ; print "old:",p.bodyString()
            if thinFile:
                p.v.setTnodeText(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                c.setBodyString(p,s) # Sets c and p dirty.

            if not thinFile or (thinFile and p.v.isDirty()):
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                g.es("changed: " + p.headString(),color="blue")
                p.setMarked()
#@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
#@-node:ekr.20060824130443:Found: tempBodyString
#@-node:ekr.20060826062302:Removed warning about changed nodes
#@+node:ekr.20060830064138:Bugs fixed
#@+node:ekr.20060825181348.1:Fixed serious bug in Paste Node as Clone
#@+node:ekr.20060825181348.2:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3885494
By: mikecrowe

OK, I found out how to duplicate this one.  This caused me a lot of grief until
I found out what is causing it.

NodeA:
...Child1
...Child2
...Child3

NodeB:
...CloneChild1
...CloneChild2
...CloneChild3

Now, put cursor on NodaA.  Ctrl-Shift-C (copy node).
Next, put cursor on CloneChild3.  Paste Node as Clone
You should get an invalid paste clone message.

Now, first cursor move (for me) puts NodeB as top node, ERASING all other nodes.
Warning:  DO NOT SAVE NOW.  It will erase all other nodes.
#@-node:ekr.20060825181348.2:Report
#@+node:ekr.20060826061456:What I did
@nocolor

- Created getLeoOutlineHelper.  This simplifies the code.
- Init self.checking in getLeoFile and getLeoOutline.
- Use self.checking in getVnodes, getVnode and createVnode.
  Using self.checking in getVnode complicates an already way-too-complex method, but it can't be helped.
#@nonl
#@-node:ekr.20060826061456:What I did
#@+node:ekr.20060826061038:Changed:
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    << warn on read-only files >>
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed
    
    try:
        ok = True
        if use_sax:
            v = self.readSaxFile(theFile,fileName,silent)
            c.setRootVnode(v)
            self.rootVnode = v
            # readAtFileNodesFlag = False ### testing
        else:
            self.getAllLeoElements(fileName,silent)
    except BadLeoFile, message:
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw_now()
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
    
    # New in 4.3.1: do this after reading derived files.
    if use_sax:
        self.resolveTnodeLists()
        self.restoreDescendentAttributes()
        self.setPositionsFromVnodes()
    else:
        if not self.usingClipboard:
            self.setPositionsFromStacks()
        if not c.currentPosition():
            c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    if not use_sax:
        self.restoreDescendentAttributes()
    self.initReadIvars()
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
def getLeoOutlineFromClipboard (self,s,reassignIndices=True):
    
    '''Read a Leo outline from string s in clipboard format.'''

    try:
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=True)
        v = self.getLeoOutlineHelper(s,reassignIndices,checking=False)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    return v
    
getLeoOutline = getLeoOutlineFromClipboard # for compatibility
#@nonl
#@+node:ekr.20031218072017.1557:finishPaste
def finishPaste(self,reassignIndices=True):
    
    """Finish pasting an outline from the clipboard.
    
    Retain clone links if reassignIndices is False."""

    c = self.c
    current = c.currentPosition()
    if reassignIndices:
        << reassign tnode indices >>
    c.selectPosition(current)
    return current
#@+node:ekr.20031218072017.1558:<< reassign tnode indices >>
@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "False clones" are created.
@c

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
    t = p.v.t
    if not t.isVisited():
        t.setVisited()
        self.maxTnodeIndex += 1
        t.setFileIndex(self.maxTnodeIndex)
#@-node:ekr.20031218072017.1558:<< reassign tnode indices >>
#@-node:ekr.20031218072017.1557:finishPaste
#@+node:ekr.20060826052453.1:getLeoOutlineHelper
def getLeoOutlineHelper (self,s,reassignIndices,checking):
    
    self.checking = checking
    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.descendentUnknownAttributesDictList = []
    v = None

    self.tnodesDict = {}
    if not reassignIndices:
        << recreate tnodesDict >>
    try:
        self.getXmlVersionTag()
        self.getXmlStylesheetTag()
        self.getTag("<leo_file>")
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        if not checking:
            v = self.finishPaste(reassignIndices)
    finally:
        self.fileBuffer = None ; self.fileIndex = 0
        self.usingClipboard = False
        self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20060826052453.1:getLeoOutlineHelper
#@+node:ekr.20031218072017.3022:getClipboardHeader
def getClipboardHeader (self):

    if self.getOpenTag("<leo_header"):
        return # <leo_header> or <leo_header/> has been seen.

    while 1:
        if self.matchTag("file_format="):
            self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
        elif self.matchTag("tnodes="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("max_tnode_index="):
            self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
        elif self.matchTag("></leo_header>"): # new in 4.2: allow this form.
            break
        else:
            self.getTag("/>")
            break
#@-node:ekr.20031218072017.3022:getClipboardHeader
#@-node:ekr.20031218072017.1559:getLeoOutlineFromClipboard & helpers
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard and not self.checking:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("</vnodes>")
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode & helpers
# changed for 4.2 & 4.4
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched <v.
    
    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if self.checking: return None
        else: return v
    
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        if not self.checking:
            skip = skip or skip2
            if tnodeList:
                v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    if not self.checking:
        << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
    
    if not self.checking:
        << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@+node:ekr.20031218072017.1860:createVnode
# (changed for 4.2) sets skip

def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
            
    if self.checking: return None,False
    
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(t)
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict
    v._p_changed = 1

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        g.es_print(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode
#@+node:ekr.20040701065235.1:getDescendentAttributes
def getDescendentAttributes (self,s,tag=""):
    
    '''s is a list of gnx's, separated by commas from a <v> or <t> element.
    Parses s into a list.
    
    This is used to record marked and expanded nodes.
    '''
    
    __pychecker__ = '--no-argsused' # tag used only for debugging.

    gnxs = s.split(',')
    result = [gnx for gnx in gnxs if len(gnx) > 0]
    # g.trace(tag,result)
    return result
#@-node:ekr.20040701065235.1:getDescendentAttributes
#@+node:EKR.20040627114602:getDescendentUnknownAttributes
# Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        g.trace('oops: getDescendentUnknownAttributes')
        return None
#@-node:EKR.20040627114602:getDescendentUnknownAttributes
#@+node:ekr.20040326063413:getExistingVnode
def getExistingVnode (self,tref,headline):

    assert(tref > -1)
    tref = self.canonicalTnodeIndex(tref)
    t = self.tnodesDict.get(tref)
    try:
        return t.vnodeList[0]
    except (IndexError,AttributeError):
        g.es("Missing vnode:",headline,color="red")
        g.es("Probably an outline topology error.")
        return None
#@-node:ekr.20040326063413:getExistingVnode
#@-node:ekr.20031218072017.1566:getVnode & helpers
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame
    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.maxTnodeIndex = 0
    self.numberOfTnodes = 0
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.fileFormatNumber = 0
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.topVnode = None
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20031218072017.1860:createVnode
# (changed for 4.2) sets skip

def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
            
    if self.checking: return None,False
    
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(t)
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict
    v._p_changed = 1

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        g.es_print(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode
#@-node:ekr.20060826061038:Changed:
#@-node:ekr.20060825181348.1:Fixed serious bug in Paste Node as Clone
#@+node:ekr.20060829091456:Fixed minor .leoID.txt bug
#@+node:ekr.20060829113741:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3886250
By: znafets

A .leoID.txt with a \n behind the idstring creates a problem. 
It will be read in g.app.leoID and being used as is when writing the Leo file.

The fix is in app.setLeoID -> << return if we can set leoID from "leoID.txt" >>
#@nonl
#@-node:ekr.20060829113741:Report
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir
    
    verbose = not g.app.unitTesting
    << return if we can set leoID from sys.leoID >>
    << return if we can set leoID from "leoID.txt" >>
    << return if we can set leoID from os.getenv('USER') >>
    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@+node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es_print("leoID = " + g.app.leoID, color='red')
    return
else:
    g.app.leoID = None
#@-node:ekr.20031218072017.1979:<< return if we can set leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s.strip()
                if verbose:
                    g.es_print("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es_print("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es_print('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@-node:ekr.20031218072017.1980:<< return if we can set leoID from "leoID.txt" >>
#@+node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId
        return
        
except Exception:
    pass
#@-node:ekr.20060211140947.1:<< return if we can set leoID from os.getenv('USER') >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# g.trace(g.app.leoID)
g.es_print("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                g.es_print(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@-node:ekr.20060829091456:Fixed minor .leoID.txt bug
#@+node:ekr.20060830063143:Improved speed of unmark-all and corresponding undo/redo
#@+node:ekr.20060830065450:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3890031
By: terry_n_brown

I have a tree of some 2500 nodes, run a script that marks
probably 1500-2000 of them, and that's quick (2-3 seconds max.).

I can clear all the marks with:

for p in c.allNodes_iter():
    p.v.clearMarked()

and that also is quick (2-3 seconds max.).  But when I use the menu option Unmark
All, that takes forever (1-2 minutes :-) running 100% CPU all the while.
#@nonl
#@-node:ekr.20060830065450:Report
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll (self,event=None):
    
    '''Unmark all nodes in the entire outline.'''

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        changed = False
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                c.clearMarked(p)
                p.v.t.setDirty()
                u.afterMark(p,undoType,bunch)
        dirtyVnodeList = [p.v for p in c.allNodes_iter() if p.v.isDirty()]
        if changed: c.setChanged(True)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2930:unmarkAll
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050410095424:updateMarks
def updateMarks (self,oldOrNew):
    
    '''Update dirty and marked bits.'''
    
    u = self ; c = u.c
    
    if oldOrNew not in ('new','old'):
        g.trace("can't happen")
        return

    isOld = oldOrNew=='old'
    dirty   = g.choose(isOld,u.oldDirty,  u.newDirty)
    marked  = g.choose(isOld,u.oldMarked, u.newMarked)
    changed = g.choose(isOld,u.oldChanged,u.newChanged)

    if dirty:   u.p.setDirty(setDescendentsDirty=False)
    else:       u.p.clearDirty()
        
    if marked:  c.setMarked(u.p)
    else:       c.clearMarked(u.p)

    u.c.setChanged(changed)
#@-node:ekr.20050410095424:updateMarks
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    
    '''Create an undo node for mark and unmark commands.'''
    
    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.
    
    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    
    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    u.pushBead(bunch)
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20050526124906:undoMark
def undoMark (self):
    
    u = self ; c = u.c

    u.updateMarks('old')
    
    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.clearDirty()
        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@-node:ekr.20060830063143:Improved speed of unmark-all and corresponding undo/redo
#@-node:ekr.20060830064138:Bugs fixed
#@-node:ekr.20060824095221:4.4.1 final projects
#@+node:ekr.20060904165452:4.4.2 projects
#@+node:ekr.20060908092306:Bugs
#@+node:ekr.20060906220124:Clone-find-all doesn't put focus in minibuffer
# getArg now has:
    
if k.useTextWidget: c.minibufferWantsFocusNow() # 9/8/06

instead of:
    
if k.useTextWidget: c.minibufferWantsFocus()
#@nonl
#@+node:ekr.20050920085536.62:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer and k.useTextWidget: c.minibufferWantsFocusNow()
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@+node:ekr.20050928092516:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@-node:ekr.20050928092516:<< init altX vars >>
#@-node:ekr.20050920085536.62:getArg
#@-node:ekr.20060906220124:Clone-find-all doesn't put focus in minibuffer
#@+node:ekr.20060908091132:Fixed undo clone-find-all 
#@+node:ekr.20060908095225:Notes
@nocolor

Undo crashed or didn't work.  Redo clone-find-all could hang.
#@-node:ekr.20060908095225:Notes
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; t = self.s_ctrl ; u = c.undoer
    gui = g.app.gui ; undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if not pos: break
        count += 1
        line = gui.getLineContainingIndex(t,pos)
        self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            if not clones:
                << create the found node and begin the undo group >>
            << create a clone of p under the find node >>
    if self.clone_find_all and clones:
        c.setRootPosition(c.findRootPosition(found)) # New in 4.4.2.
        u.afterChangeGroup(found,undoType,reportFlag=True) 
        c.selectPosition(found) # Recomputes root.
        c.setChanged(True)
          
    c.redraw_now()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@+node:ekr.20051113110735:<< create the found node and begin the undo group >>
u.beforeChangeGroup(c.currentPosition(),undoType)

undoData = u.beforeInsertNode(c.currentPosition())

oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)

u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110735:<< create the found node and begin the undo group >>
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
clones.append(self.p.v.t)
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20040803140033.3:c.setRootPosition
def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
#@nonl
#@-node:ekr.20040803140033.3:c.setRootPosition
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position. For internal use only.
    
    Client code should use c.selectPosition instead."""
    
    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
            
        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        c.setRootPosition(c.findRootPosition(c._currentPosition))
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):
    
    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self
    
    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1
    
    bunch = u.beads[u.bead] ; count = 0
    
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)
        
    u.groupCount -= 1
               
    for v in dirtyVnodeList:
        v.t.clearDirty()

    g.es("undo %d instances" % count)
    
    c.selectPosition(p)
    oldSel and c.frame.body.setTextSelection(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):
    
    '''Process beads until the matching 'afterGroup' bead is seen.'''
    
    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()
    
    u.groupCount += 1

    
    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        c.beginUpdate()
        try:
            for z in bunch.items:
                self.setIvarsFromBunch(z)
                if z.redoHelper:
                    # g.trace(z.redoHelper)
                    z.redoHelper() ; count += 1
                else:
                    g.trace('oops: no redo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1
    
    for v in dirtyVnodeList:
        v.t.setDirty()

    g.es("redo %d instances" % count)
        
    c.selectPosition(p)
    newSel and c.frame.body.setTextSelection(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,event=None,op_name="Delete Node"):
    
    """Deletes the selected outline."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try:
       c.endEditing() # Make sure we capture the headline for Undo.
       undoData = u.beforeDeleteNode(p)
       dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
       p.doDelete()
       c.selectPosition(newNode)
       c.setChanged(True)
       u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()

    c.validateOutline()
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20040409203454.1:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@+node:ekr.20040410170806:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20040410170806:p.deleteLinksInSubtree
#@+node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
#@-node:ekr.20040409203454.1:p.deleteLinksInTree & allies
#@-node:ekr.20060908091132:Fixed undo clone-find-all 
#@+node:ekr.20060908104646:Fixed several bugs in UNL plugin
#@-node:ekr.20060908104646:Fixed several bugs in UNL plugin
#@+node:ekr.20060912073120:Fixed crasher with multiple editors
#@+node:ekr.20060912073340:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3910237
Kam-Yung
Python 2.4.3, Tk 8.4.12, Pmw 1.2

I'm getting "TclError Exception in Tk" callback with the new multi-editor
feature.

Steps to reproduce:

* start up Leo with no files
* execute "add-editor"
* make sure the left-most body pane is selected
* execute "delete-editor"

Up comes a TK error box.
#@nonl
#@-node:ekr.20060912073340:Report
#@+node:ekr.20060912073340.1:Traceback
TclError Exception in Tk callback
  Function: <function masterBindKeyCallback at 0x0164DBB0> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x01840FD0>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2117, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 3096, in masterKeyHandler
    val = k.callStateFunction(event) # Calls end-command.
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2241, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2318, in fullCommand
    k.callAltXFunction(k.mb_event)
  File "C:\prog\tigris-cvs\leo\src\leoKeys.py", line 2355, in callAltXFunction
    func(event)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 2124, in deleteEditor
    self.onFocusIn(w)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 2173, in onFocusIn
    c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
  File "C:\prog\tigris-cvs\leo\src\leoCommands.py", line 6381, in selectPosition
    c.frame.tree.select(p,updateBeadList)
  File "C:\prog\tigris-cvs\leo\src\leoTkinterTree.py", line 2548, in select
    c.frame.updateStatusLine() # New in Leo 4.4.1.
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 1002, in updateStatusLine
    if self.statusLine: self.statusLine.update()
  File "C:\prog\tigris-cvs\leo\src\leoTkinterFrame.py", line 727, in update
    index = w.index("insert")
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2938, in index
    return self.tk.call(self._w, 'index', index)
TclError: invalid command name ".20195728.20196288.22611848.22611928.23069560.23069920.body-pane"

================================================
  Event contents:
    char:
    delta: 13
    height: ??
    keycode: 13
    keysym: Return
    keysym_num: 65293
    num: ??
    serial: 1356
    state: 8
    time: 3053230
    type: 2
    widget: .20195728.20196288.22412264.minibuffer
    width: ??
    x: 244
    x_root: 678
    y: -164
    y_root: 518

#@-node:ekr.20060912073340.1:Traceback
#@+node:ekr.20060912083415:What I did
@nocolor

- in statusLine.update:
    
replace self.bodyCtrl with c.frame.bodyCtrl.

- Removed bodyCtrl ivar from statusLine class.  This value can not be cached!

- in deleteEditor: add:

self.bodyCtrl = self.frame.bodyCtrl = w

just before the call to self.onFocusIn(w).
#@nonl
#@-node:ekr.20060912083415:What I did
#@+node:ekr.20060528113806:deleteEditor
def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w # Bug fix: 9/12/06
    self.onFocusIn(w)
#@-node:ekr.20060528113806:deleteEditor
#@+node:ekr.20031218072017.1733:update (statusLine)
def update (self):
    
    c = self.c ; w = c.frame.bodyCtrl ; lab = self.labelWidget

    if g.app.killed or not self.isVisible:
        return

    index = w.index("insert")
    row,col = g.app.gui.getindex(w,index)

    if col > 0:
        s = w.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)
    
    s = "line %d, col %d " % (row,col)
    # Important: this does not change the focus because labels never get focus.
    lab.configure(text=s)
    self.lastRow = row
    self.lastCol = col
#@-node:ekr.20031218072017.1733:update (statusLine)
#@+node:ekr.20060528100747:Editors
@ **Important**: body.bodyCtrl and body.frame.bodyCtrl must always be the same.
#@+node:ekr.20060530204135:recolorWidget
def recolorWidget (self,w):

    c = self.c ; old_w = self.bodyCtrl
    
    # g.trace(id(w),c.currentPosition().headString())
    
    # Save.
    self.bodyCtrl = self.frame.bodyCtrl = w
    
    c.recolor_now(interruptable=False) # Force a complete recoloring.
    
    # Restore.
    self.bodyCtrl = self.frame.bodyCtrl = old_w
#@nonl
#@-node:ekr.20060530204135:recolorWidget
#@+node:ekr.20060530210057:create/select/unselect/Label
def unselectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='LightSteelBlue1')
        
def selectLabel (self,w):
    
    # g.trace(w.leo_name,w.leo_label_s)
    if not w.leo_label: self.createLabel(w)
    w.leo_label.configure(text=w.leo_label_s,bg='white')
        
def createLabel (self,w):

    w.leo_label = Tk.Label(w.leo_frame)
    w.pack_forget()
    w.leo_label.pack(side='top')
    w.pack(expand=1,fill='both')
#@-node:ekr.20060530210057:create/select/unselect/Label
#@+node:ekr.20060528100747.1:addEditor
def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
     
    if self.numberOfEditors == 1:
        # Inject the ivars into the first editor.
        w = self.editorWidgets.get('1')
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v
        w.leo_label_s = p.headString()

    self.numberOfEditors += 1
    name = '%d' % self.numberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    << create label and text widgets >>
    self.editorWidgets[name] = w

    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()
    self.bodyCtrl = self.frame.bodyCtrl = w
    self.updateEditors()
    # self.onFocusIn(w,setFocus=True)
    c.bodyWantsFocusNow()
#@+node:ekr.20060528110922:<< create label and text widgets >>
f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,f,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
w.see('1.0')
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

self.recolorWidget(w)
#@-node:ekr.20060528110922:<< create label and text widgets >>
#@-node:ekr.20060528100747.1:addEditor
#@+node:ekr.20060606090542:setEditorColors
def setEditorColors (self,bg,fg):
    
    c = self.c ; d = self.editorWidgets

    for key in d.keys():
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
            pass
#@-node:ekr.20060606090542:setEditorColors
#@+node:ekr.20060528170438:cycleEditorFocus
def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets ; w = self.bodyCtrl
    values = d.values()
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values): i = 0
        w2 = d.values()[i]
        assert(w!=w2)
        self.onFocusIn(w2,setFocus=True)
        self.bodyCtrl = self.frame.bodyCtrl = w2
        # g.trace('***',g.app.gui.widget_name(w2),id(w2))

    return 'break'
#@-node:ekr.20060528170438:cycleEditorFocus
#@+node:ekr.20060528113806:deleteEditor
def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    w = self.bodyCtrl ; d = self.editorWidgets
    
    if len(d.keys()) == 1: return
    
    name = w.leo_name
    
    del d [name] 
    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    # Select another editor.
    w = d.values()[0]
    self.bodyCtrl = self.frame.bodyCtrl = w # Bug fix: 9/12/06
    self.onFocusIn(w)
#@-node:ekr.20060528113806:deleteEditor
#@+node:ekr.20060528104554:onFocusIn
lockout_onFocusIn = False

def onFocusIn(self,w,setFocus=False):

    c = self.c ; d = self.editorWidgets
    trace = False
    if trace: g.trace(g.callers())
    if self.lockout_onFocusIn:
        if trace: g.trace('lockout')
        return 'break'
    if w.leo_p is None:
        if trace: g.trace('no w.leo_p') 
        return 'break'
    
    # Disable recursive calls: some of the calls below generate OnFocusInEvents.
    self.lockout_onFocusIn = True
    try:
        if trace: g.trace(w)
    
        # Inactivate the previously active editor.
        # Don't capture ivars here! selectMainEditor keeps them up-to-date.
        for key in d.keys():
            w2 = d.get(key)
            if w2 != w and w2.leo_active:
                w2.leo_active = False
                self.unselectLabel(w2)
                w2.leo_scrollBarSpot = w2.yview()
                w2.leo_insertSpot = g.app.gui.getInsertPoint(w2)
                w2.leo_selection = g.app.gui.getSelectionRange(w2)
                break
        else:
            if trace: g.trace('no active editor!')
    
        # Careful, leo_p may not exist.
        if not c.positionExists(w.leo_p):
            g.trace('does not exist',w.leo_name)
            for p2 in c.allNodes_iter():
                if p2.v == w.leo_v:
                    w.leo_p = p2.copy()
                    break
            else:
                if trace: g.trace("Can't happen")
                return 'break'

        self.frame.bodyCtrl = self.bodyCtrl = w # Must change both ivars!
        w.leo_active = True
        c.selectPosition(w.leo_p,updateBeadList=True) # Calls selectMainEditor.
        c.recolor_now()
        << restore the selection, insertion point and the scrollbar >>
        w3 = g.app.gui.get_focus(c)
        if setFocus or w3 and not g.app.gui.widget_name(w3).startswith('body'):
            if trace: g.trace(g.app.gui.widget_name(w),id(w))
            c.bodyWantsFocusNow()
    finally:
        self.lockout_onFocusIn = False

    return 'break'
#@+node:ekr.20060605190146:<< restore the selection, insertion point and the scrollbar >>
if w.leo_insertSpot:
    g.app.gui.setInsertPoint(w,w.leo_insertSpot)
    w.see(w.leo_insertSpot)
else:
    g.app.gui.setInsertPoint(w,'1.0')
    
if w.leo_scrollBarSpot:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)

if w.leo_selection:
    try:
        start,end = w.leo_selection
        g.app.gui.setSelectionRange(w,start,end)
    except Exception:
        pass
#@-node:ekr.20060605190146:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20060528104554:onFocusIn
#@+node:ekr.20060528132829:selectMainEditor
def selectMainEditor (self,p):

    c = self.c ; p = c.currentPosition() ; w = self.bodyCtrl

    # Don't inject ivars if there is only one editor.
    if w.leo_p is not None:
        # Keep w's ivars up-to-date.
        w.leo_p = p.copy()
        w.leo_v = p.v
        w.leo_label_s = p.headString()
        self.selectLabel(w)
        # g.trace(w.leo_name,p.headString())
#@-node:ekr.20060528132829:selectMainEditor
#@+node:ekr.20060528131618:updateEditors
def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) < 2: return # There is only the main widget.

    for key in d.keys():
        w = d.get(key)
        v = w.leo_v
        if v and v == p.v and w != self.bodyCtrl:
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            # g.trace('update',w,v)
            self.recolorWidget(w)
    c.frame.bodyWantsFocus()
#@-node:ekr.20060528131618:updateEditors
#@-node:ekr.20060528100747:Editors
#@+node:ekr.20041223104933:class statusLineClass
class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("<Button-1>", self.onActivate)
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(g.callers())
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.widgetWantsFocus(t)
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)
        
show = pack
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(s,g.callers())
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update (statusLine)
def update (self):
    
    c = self.c ; w = c.frame.bodyCtrl ; lab = self.labelWidget

    if g.app.killed or not self.isVisible:
        return

    index = w.index("insert")
    row,col = g.app.gui.getindex(w,index)

    if col > 0:
        s = w.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)
    
    s = "line %d, col %d " % (row,col)
    # Important: this does not change the focus because labels never get focus.
    lab.configure(text=s)
    self.lastRow = row
    self.lastCol = col
#@-node:ekr.20031218072017.1733:update (statusLine)
#@-node:ekr.20041223104933:class statusLineClass
#@-node:ekr.20060912073120:Fixed crasher with multiple editors
#@+node:ekr.20060915113237:Fixed problem with body/outline ratio
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3914969

This body-outline ratio in the .leo file is not used, regardless of orientation.

The problem that tkFrame.resizePanesToRatio got deleted sometime after 4.4 final,
so the do-nothing base class method was executed instead.
@color
#@nonl
#@+node:ekr.20031218072017.2306:getGlobals
def getGlobals (self):

    if self.getOpenTag("<globals"):
        # <globals/> seen: set reasonable defaults:
        self.ratio = 0.5
        y,x,h,w = 50,50,500,700
    else:
        self.getTag("body_outline_ratio=\"")
        self.ratio = self.getDouble() ; self.getDquote() ; self.getTag(">")

        self.getTag("<global_window_position")
        y,x,h,w = self.getPosition()
        self.getTag("/>")

        self.getTag("<global_log_window_position")
        self.getPosition()
        self.getTag("/>") # no longer used.

        self.getTag("</globals>")

    # Redraw the window before writing into it.
    self.frame.setTopGeometry(w,h,x,y)
    self.frame.deiconify()
    self.frame.lift()
    self.frame.update()
#@-node:ekr.20031218072017.2306:getGlobals
#@+node:ekr.20060915124834:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    self.divideLeoSplitter(self.splitVerticalFlag,ratio)
    self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@-node:ekr.20060915124834:resizePanesToRatio
#@-node:ekr.20060915113237:Fixed problem with body/outline ratio
#@+node:ekr.20060918091042:Guarded against strange crasher
#@+node:ekr.20031218072017.1999:toString
def toString (self,index,removeDefaultId=False):
    
    """Convert a gnx (a tuple) to its string representation"""

    try:
        theId,t,n = index
        if removeDefaultId and theId == self.defaultId:
            theId = ""
        if not n: # None or ""
            return "%s.%s" % (theId,t)
        else:
            return "%s.%s.%d" % (theId,t,n)
    except TypeError:
        g.trace('unusual gnx',repr(index))
        return repr(index)
#@nonl
#@-node:ekr.20031218072017.1999:toString
#@-node:ekr.20060918091042:Guarded against strange crasher
#@+node:ekr.20060920145332:Fixed compare bug
#@+node:ekr.20060920151334:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3924236

Comparing directory A, with files A1 and A2, and directory B, with files B1 and B2
(A1, A2, B1, B2 all being different) shows up in the log as A1 and A2 not being founnd.

I think also B1 and B2 should be mentioned somewhere (e.g. using headings like 'Only present in A' and 'Only present in B').

#@-node:ekr.20060920151334:Report
#@+node:ekr.20031218072017.3635:compare_directories (entry)
# We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
    
    # Ignore everything except the directory name.
    dir1 = g.os_path_dirname(path1)
    dir2 = g.os_path_dirname(path2)
    dir1 = g.os_path_normpath(dir1)
    dir2 = g.os_path_normpath(dir2)
    
    if dir1 == dir2:
        return self.show("Please pick distinct directories.")
    try:
        list1 = os.listdir(dir1)
    except:
        return self.show("invalid directory:" + dir1)
    try:
        list2 = os.listdir(dir2)
    except:
        return self.show("invalid directory:" + dir2)
        
    if self.outputFileName:
        self.openOutputFile()
    ok = self.outputFileName == None or self.outputFile
    if not ok: return

    # Create files and files2, the lists of files to be compared.
    files1 = []
    files2 = []
    for f in list1:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files1.append(f)
        else:
            files1.append(f)
    for f in list2:
        junk, ext = g.os_path_splitext(f)
        if self.limitToExtension:
            if ext == self.limitToExtension:
                files2.append(f)
        else:
            files2.append(f)

    # Compare the files and set the yes, no and missing lists.
    yes = [] ; no = [] ; missing1 = [] ; missing2 = []
    for f1 in files1:
        head,f2 = g.os_path_split(f1)
        if f2 in files2:
            try:
                name1 = g.os_path_join(dir1,f1)
                name2 = g.os_path_join(dir2,f2)
                val = filecmp.cmp(name1,name2,0)
                if val: yes.append(f1)
                else:    no.append(f1)
            except:
                self.show("exception in filecmp.cmp")
                g.es_exception()
                missing1.append(f1)
        else:
            missing1.append(f1)
    for f2 in files2:
        head,f1 = g.os_path_split(f2)
        if f1 not in files1:
            missing2.append(f1)
    
    # Print the results.
    for kind, files in (
        ("----- matches --------",yes),
        ("----- mismatches -----",no),
        ("----- not found 1 ------",missing1),
        ("----- not found 2 ------",missing2),
    ):
        self.show(kind)
        for f in files:
            self.show(f)
    
    if self.outputFile:
        self.outputFile.close()
        self.outputFile = None
#@-node:ekr.20031218072017.3635:compare_directories (entry)
#@-node:ekr.20060920145332:Fixed compare bug
#@+node:ekr.20060921113950:Fixed problem with g.CheckVersion
# The new version of g.CheckVersion is simpler, and works more often, but is perhaps less general.
#@nonl
#@+node:ekr.20031218072017.3097:CheckVersion 
#@+node:ekr.20060921100435:checkVersion (EKR)
# Simplified version by EKR: stringCompare not used.

def CheckVersion (s1,s2,condition=">=",stringCompare=None,delimiter='.',trace=False):

    vals1 = [int(s) for s in s1.split(delimiter)] ; n1 = len(vals1)
    vals2 = [int(s) for s in s2.split(delimiter)] ; n2 = len(vals2)
    n = max(n1,n2)
    if n1 < n: vals1.extend([0 for i in xrange(n - n1)])
    if n2 < n: vals2.extend([0 for i in xrange(n - n2)])
    for cond,val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('<',  vals1 <  vals2), ('<=', vals1 <= vals2),
        ('>',  vals1 >  vals2), ('>=', vals1 >= vals2),
    ):
        if condition == cond:
            result = val ; break
    else:
        raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
    
    if trace:
        # print '%10s' % (repr(vals1)),'%2s' % (condition),'%10s' % (repr(vals2)),result
        print '%7s' % (s1),'%2s' % (condition),'%7s' % (s2),result
    return result
#@nonl
#@-node:ekr.20060921100435:checkVersion (EKR)
#@+node:ekr.20060921100435.1:oldCheckVersion (Dave Hein)
@
g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", ">=", "<=", ">", or "<"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def oldCheckVersion( version, againstVersion, condition=">=", stringCompare="0.0.0.0", delimiter='.' ):

    __pychecker__ = 'maxreturns=20'
    
    # g.pdb()

    # tokenize the stringCompare flags
    compareFlag = string.split( stringCompare, '.' )

    # tokenize the version strings
    testVersion = string.split( version, delimiter )
    testAgainst = string.split( againstVersion, delimiter )

    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount > len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount > len(testVersion):
        tokenCount = len(testVersion)

    # Apply the stringCompare flags
    justInteger = re.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError,errMsg

    # Compare the versions
    if condition == ">=":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == ">":
        for i in range(tokenCount):
            if testVersion[i] < testAgainst[i]:
                return 0
            if testVersion[i] > testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "<":
        for i in range(tokenCount):
            if testVersion[i] >= testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "<=":
        for i in range(tokenCount):
            if testVersion[i] > testAgainst[i]:
                return 0
            if testVersion[i] < testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal

    # didn't find a condition that we expected.
    raise EnvironmentError,"condition must be one of '>=', '>', '==', '!=', '<', or '<='."
#@nonl
#@-node:ekr.20060921100435.1:oldCheckVersion (Dave Hein)
#@-node:ekr.20031218072017.3097:CheckVersion 
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        # g.trace(repr(version),g.CheckVersion(version,"8.4.3"))
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32":
            
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # g.trace(version)
        ok = g.CheckVersion(version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@-node:ekr.20060921113950:Fixed problem with g.CheckVersion
#@+node:ekr.20060925080505:Added force argument to c.set_focus
@
This should *finally* fix the problems with focus going to limbo.
All xWantsFocusNow methods set the force arg.
#@nonl
#@+node:ekr.20060210102201:c.xWantsFocusNow
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    #g.trace(body and body.bodyCtrl)
    c.set_focus(body and body.bodyCtrl,force=True)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and c.edit_widget(p),force=True)
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl,force=True)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas,force=True)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w,force=True)
#@-node:ekr.20060210102201:c.xWantsFocusNow
#@+node:ekr.20060205103842:c.get/request/set_focus
def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w,force=False):
    
    c = self
    
    if force: # New in Leo 4.4.2: safer.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)
    else: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
#@-node:ekr.20060205103842:c.get/request/set_focus
#@+node:ekr.20050120092028:c.xWantsFocus
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and c.edit_widget(p))
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
#@-node:ekr.20050120092028:c.xWantsFocus
#@-node:ekr.20060925080505:Added force argument to c.set_focus
#@-node:ekr.20060908092306:Bugs
#@+node:ekr.20060905091234:Code level
#@+node:ekr.20060904114302:Added OPML support to fileCommands
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag or toOPML:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        theActualFile = None
        if not toString:
            << create backup file >>
        self.mFileName = fileName
        if toOPML:
            << ensure that filename ends with .opml >>
        self.outputFile = cStringIO.StringIO()
        if not toString:
            theActualFile = open(fileName, 'wb')
        if toOPML:
            self.putToOPML()
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        if toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            << delete backup file >>
        self.outputFile = None
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        << delete fileName >>
        << rename backupName to fileName >>
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20060919070145:<< ensure that filename ends with .opml >>
if not self.mFileName.endswith('opml'):
    self.mFileName = self.mFileName + '.opml'
fileName = self.mFileName
#@nonl
#@-node:ekr.20060919070145:<< ensure that filename ends with .opml >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@-node:ekr.20060904114302:Added OPML support to fileCommands
#@+node:ekr.20060905092512.2:Eliminated v.c and p.c
@nocolor

To do:
    
- Eliminate most calls to c.setRootPosition(c.findRootPosition(p))
    ** Just have c.rootPosition call c.findRootPosition(c.currentPosition())
    
What I did:

- Removed c argument from t, v and p ctors.
- Removed c argument from most position methods.
    - In particular, p.link, p.unlink, v.link and v.unlink no longer update c.currentPosition()
    - Moved all position methods that still had a c argument to the Commands class.
- Removed p.allNodes_iter.
- Added c.findRootPosition and c.findRootVnode.
- c.rootPosition now returns c.findRootPosition(c.currentPosition())

As a result:
    
- The tnode, vnode and position classes are *completely* independent of Leo.
  In particular, no tnode, vnode or position method gets a c argument.
- The p.link, p.unlink, v.link and v.unlink are significantly simpler.
- The machinery for keeping the root position up-to-date is
  simple and confined to one place in the Commands class.
  
@color
#@nonl
#@+node:ekr.20060905181927:Added new methods
#@+node:ekr.20060906134053:c.findRootPosition New in 4.4.2
@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):
    
    '''Return the root position of the outline containing p.'''
    
    c = self ; p = p.copy()
    
    while p and p.hasParent():
        p.moveToParent()
        
    while p and p.hasBack():
        p.moveToBack()
        
    # g.trace(p and p.headString())

    return p
#@nonl
#@-node:ekr.20060906134053:c.findRootPosition New in 4.4.2
#@+node:ekr.20060906131836:c.setRootVnode New in 4.4.2
def setRootVnode (self, v):
    
    c = self
    newRoot = leoNodes.position(v,[])
    c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20060906131836:c.setRootVnode New in 4.4.2
#@-node:ekr.20060905181927:Added new methods
#@+node:ekr.20060905165341.1:Unchanged signatures (just removed v.c or other minor changes)
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self.stack,trace=False)
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040303175026.3:p.insertAfter
def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2
#@-node:ekr.20040303175026.3:p.insertAfter
#@+node:ekr.20040303175026.5:p.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2
#@-node:ekr.20040303175026.5:p.insertAsNthChild
#@+node:ekr.20051104075904.30:u.findNodeInTree
def findNodeInTree(self,p,headline):

    """Search for a node in p's tree matching the given headline."""

    c = self.c
    for p in p.subtree_iter():
        h = headline.strip().lower()
        if p.headString().strip().lower() == h:
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20051104075904.30:u.findNodeInTree
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
                
    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) > 0

    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!

    return dirtyVnodeList
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []
    
    # g.trace(p.headString(),g.callers())

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList
#@-node:ekr.20040303163330:p.setDirty
#@+node:EKR.20040506075328.2:perfectImport
def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    __pychecker__ = 'maxlines=500'
    
    << about this algorithm >>
    c = self.c
    root = p.copy()
    at = c.atFileCommands
    if testing:
        << clear all dirty bits >>
    << Assign file indices >>
    << Write root's tree to to string s >>

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 1: # For testing.
            << put the corrected fat lines in a new node >>
        << correct root's tree using write_lines >>
    if verify:
        << verify that writing the tree would produce the original file >>
#@+node:ekr.20040717112739:<< about this algorithm >>
@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.
#@-node:ekr.20040717112739:<< about this algorithm >>
#@+node:ekr.20040716065356:<< clear all dirty bits >>
for p2 in p.self_and_subtree_iter():
    p2.clearDirty()
#@-node:ekr.20040716065356:<< clear all dirty bits >>
#@+node:ekr.20040716064333:<< Assign file indices  >>
nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        theId,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()
#@-node:ekr.20040716064333:<< Assign file indices  >>
#@+node:ekr.20040716064333.1:<< Write root's tree to to string s >>
at.write(root,thinFile=True,toString=True)
s = at.stringOutput
if not s: return
#@-node:ekr.20040716064333.1:<< Write root's tree to to string s >>
#@+node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)
#@-node:ekr.20040717132539:<< put the corrected fat lines in a new node >>
#@+node:ekr.20040717113036:<< correct root's tree using write_lines >>
@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    at.correctedLines = 0
    at.targetFileName = "<perfectImport string-file>"
    at.inputFile = fo = g.fileLikeObject()
    at.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk,junk = c.atFileCommands.scanHeader(fo,at.targetFileName)
    # To do: pass params to readEndNode.
    at.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = at.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None
#@-node:ekr.20040717113036:<< correct root's tree using write_lines >>
#@+node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    at.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(at.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            << dump the files >>
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()
#@+node:ekr.20040718045423:<< dump the files >>
print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j < i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k < i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break
#@-node:ekr.20040718045423:<< dump the files >>
#@-node:ekr.20040718035658:<< verify that writing the tree would produce the original file >>
#@-node:EKR.20040506075328.2:perfectImport
#@+node:ekr.20040803072955.21:tkTree.injectCallbacks
def injectCallbacks(self):
    
    c = self.c
    
    << define tkinter callbacks to be injected in the position class >>

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):
        
        g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20040803072955.22:<< define tkinter callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event=None,c=c):
    
    """Callback injected into position class."""
    
    p = self
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@+node:ekr.20040803072955.24:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None,c=c):
    
    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")
#@-node:ekr.20040803072955.24:OnHyperLinkEnter
#@+node:ekr.20040803072955.25:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None,c=c):
    
    """Callback injected into position class."""

    try:
        p = self
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")
#@-node:ekr.20040803072955.25:OnHyperLinkLeave
#@-node:ekr.20040803072955.22:<< define tkinter callbacks to be injected in the position class >>
#@-node:ekr.20040803072955.21:tkTree.injectCallbacks
#@-node:ekr.20060905165341.1:Unchanged signatures (just removed v.c or other minor changes)
#@+node:ekr.20060907085253:Removed p.allNodes_iter
#@+node:ekr.20040305171133:p.allNodes_iter
class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,c,copy=False):
    
    return self.allNodes_iter_class(self,c,copy)
#@+node:ekr.20040305171133.1:__init__ & __iter__ (p.allNodesIter)
def __init__(self,p,c,copy):
    
    # g.trace('p.allNodes_iter.__init','p',p,'c',c)

    self.first = c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305171133.1:__init__ & __iter__ (p.allNodesIter)
#@+node:ekr.20040305171133.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:p.allNodes_iter
#@+node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
# New in Leo 4.4.2 (It used to be defined in terms of p.allNodes_iter.)

class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    c = self
    return self.allNodes_iter_class(c,copy)

all_positions_iter = allNodes_iter
#@nonl
#@+node:ekr.20060907085906.1:__init__ & __iter__ (p.allNodesIter)
def __init__(self,c,copy):
    
    # g.trace('c.allNodes_iter.__init','p',p,'c',c)

    self.c = c
    self.first = c.rootPosition()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20060907085906.1:__init__ & __iter__ (p.allNodesIter)
#@+node:ekr.20060907085906.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@-node:ekr.20060907085906.2:next
#@-node:EKR.20040529091232:c.all_positions_iter == allNodes_iter
#@-node:ekr.20060907085253:Removed p.allNodes_iter
#@+node:ekr.20060906130502:Removed p arg
#@+node:ekr.20040303175026.8:p.clone (does not need any args)
def clone (self):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self

    p2 = p.copy()
    p2.v = vnode(p.v.t)
    p2.linkAfter(p)

    return p2
#@nonl
#@-node:ekr.20040303175026.8:p.clone (does not need any args)
#@+node:ekr.20060905104612:Found: .clone
#@+node:ekr.20031218072017.1762:c.clone
def clone (self,event=None):
    
    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone()
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels and chapters plugins.
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    
    c.beginUpdate()
    try: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone() # Creates clone & dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete() # Destroys clone and makes p the current node.
            c.selectPosition(p) # Also sets root position.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.selectPosition(clone) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@-node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
#@+node:ekr.20031218072017.2948:c.dragCloneAfter
def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    try: # In update...
        clone = p.clone() # Creates clone.  Does not set undo.
        if c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            inAtIgnoreRange = clone.inAtIgnoreRange()
            c.endEditing()
            undoData = u.beforeInsertNode(current)
            dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
            clone.moveAfter(after)
            if inAtIgnoreRange and not clone.inAtIgnoreRange():
                # The moved node have just become newly unignored.
                dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
                dirtyVnodeList.extend(dirtyVnodeList2)
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
            p = clone
        else:
            # g.trace("invalid clone drag")
            clone.doDelete()
    finally:
        c.selectPosition(p) # Also sets root position.
        c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2948:c.dragCloneAfter
#@+node:ekr.20051113110851:<< create a clone of p under the find node >>
clones.append(self.p.v.t)
undoData = u.beforeCloneNode(self.p)
q = self.p.clone()
q.moveToLastChildOf(found)
u.afterCloneNode(q,undoType,undoData,dirtyVnodeList=[])
#@-node:ekr.20051113110851:<< create a clone of p under the find node >>
#@-node:ekr.20060905104612:Found: .clone
#@-node:ekr.20060906130502:Removed p arg
#@+node:ekr.20060905165341.2:Removed c arg
#@+node:ekr.20031218072017.892:p.__init__
# New in Leo 4.4.2: make stack default to None.

def __init__ (self,v,stack=None,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    # assert(v is None or v.t)
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # if g.app.tracePositions and trace: g.trace(g.callers())
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20031218072017.892:p.__init__
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v
    
    # p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)

    return p
#@nonl
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20040306060312:p.moveToLastChildOf
def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = parent.numberOfChildren()
    p.linkAsNthChild(parent,n)
        
    return p
#@nonl
#@-node:ekr.20040306060312:p.moveToLastChildOf
#@+node:ekr.20040303175026.11:p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsNthChild(parent,n)

    return p
#@nonl
#@-node:ekr.20040303175026.11:p.moveToNthChildOf
#@+node:ekr.20040303175026.6:p.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a position to the root position.
    
    Important: oldRoot must the previous root position if it exists.'''

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p
#@-node:ekr.20040303175026.6:p.moveToRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        if 0: # This can fail.  I have no idea why it was present.
            assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            if 0: # This can fail.  I have no idea why it was present.
                assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.5:p.unlink
#@+node:ekr.20051104075904.35:replaceOutline (leoTest)
def replaceOutline (self,outline1,outline2):

    """Replace outline1 by a copy of outline 2,

    retaining the headline of outline1."""

    c = outline1.c
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete()
    c.setRootPosition(c.findRootPosition(copy)) # New in 4.4.2.
    c.selectPosition(copy)
#@-node:ekr.20051104075904.35:replaceOutline (leoTest)
#@+node:ekr.20031218072017.3344:v.__init__
def __init__ (self,t):

    assert(t)
    
    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits
    
    # Structure links.
    self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20031218072017.3344:v.__init__
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.
    
    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20060905165341.2:Removed c arg
#@+node:ekr.20060905114409:Added c arg
#@+node:ekr.20031218072017.1385:g.findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
#@-node:ekr.20031218072017.1385:g.findReference
#@-node:ekr.20060905114409:Added c arg
#@+node:ekr.20060905172505.1:Converted p.x(c) to c.x(p)
#@+node:ekr.20040315032503:c.appendStringToBody
def appendStringToBody (self,p,s,encoding="utf-8"):
    
    c = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    c.setBodyString(p,body + s,encoding)
#@-node:ekr.20040315032503:c.appendStringToBody
#@+node:ekr.20060906211138:c.clearMarked
def clearMarked  (self,p):
    
    c = self
    p.v.clearMarked()
    g.doHook("clear-mark",c=c,p=p,v=p)
#@nonl
#@-node:ekr.20060906211138:c.clearMarked
#@+node:ekr.20040306220230.1:c.edit_widget
def edit_widget (self,p):
    
    c = self
    
    return p and c.frame.tree.edit_widget(p)
#@nonl
#@-node:ekr.20040306220230.1:c.edit_widget
#@+node:ekr.20031218072017.4146:c.lastVisible
def lastVisible(self):
    
    """Move to the last visible node of the entire tree."""

    c = self ; p = c.rootPosition()
    
    # Move to the last top-level node.
    while p.hasNext():
        p.moveToNext()
    assert(p.isVisible())

    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        p.moveToLastChild()
    
    return p
#@-node:ekr.20031218072017.4146:c.lastVisible
#@+node:ekr.20040307104131.3:c.positionExists
def positionExists(self,p):
    
    """Return True if a position exists in c's tree"""
    
    c = self ; p = p.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p.headString(),'parent',p.parent(),'back',p.back())
        if p.equal(root):
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    # g.trace('does not exist in root:',root.headString())
    return False
#@-node:ekr.20040307104131.3:c.positionExists
#@+node:ekr.20040305223522:c.setBodyString
def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.currentPosition()
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
#@-node:ekr.20040305223522:c.setBodyString
#@+node:ekr.20060906211138.1:c.setMarked
def setMarked (self,p):
    
    c = self
    p.v.setMarked()
    g.doHook("set-mark",c=c,p=p,v=p)
#@nonl
#@-node:ekr.20060906211138.1:c.setMarked
#@+node:ekr.20031218072017.3404:c.trimTrailingLines
def trimTrailingLines (self,p):

    """Trims trailing blank lines from a node.
    
    It is surprising difficult to do this during Untangle."""

    c = self
    body = p.bodyString()
    lines = string.split(body,'\n')
    i = len(lines) - 1 ; changed = False
    while i >= 0:
        line = lines[i]
        j = g.skip_ws(line,0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1 ; changed = True
        else: break
    if changed:
        body = string.join(body,'') + '\n' # Add back one last newline.
        # g.trace(body)
        c.setBodyString(p,body)
        # Don't set the dirty bit: it would just be annoying.
#@nonl
#@-node:ekr.20031218072017.3404:c.trimTrailingLines
#@+node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
#@-node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
#@-node:ekr.20060905172505.1:Converted p.x(c) to c.x(p)
#@+node:ekr.20060905103748:Removed p and v methods using v.c or p.c
#@+node:ekr.20040312015705:p.clearAllVisited
# Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()
#@-node:ekr.20040312015705:p.clearAllVisited
#@+node:ekr.20040803140033.4:p.isCurrentPosition
def isCurrentPosition (self,c):
    
    p = self
    
    return c.isCurrentPosition(p)
#@-node:ekr.20040803140033.4:p.isCurrentPosition
#@+node:ekr.20040803140033.5:p.isRootPosition
def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)
#@-node:ekr.20040803140033.5:p.isRootPosition
#@+node:ekr.20060905090957:removed findRoot methods
# A step towards removing c ivars from vnode and position classes.
#@nonl
#@+node:ekr.20031218072017.3381:v.findRoot (4.2)
def findRoot (self):
    
    return self.c.rootPosition()
#@-node:ekr.20031218072017.3381:v.findRoot (4.2)
#@+node:ekr.20040306215548:p.findRoot
def findRoot (self):
    
    return self.c.frame.rootPosition()
#@-node:ekr.20040306215548:p.findRoot
#@-node:ekr.20060905090957:removed findRoot methods
#@+node:ekr.20060905121515:v.clearDirtyJoined
def clearDirtyJoined (self,c):

    v = self
    c.beginUpdate()
    try:
        v.t.clearDirty()
    finally:
        c.endUpdate() # recomputes all icons
#@-node:ekr.20060905121515:v.clearDirtyJoined
#@+node:ekr.20031218072017.3379:v.currentVnode (and c.currentPosition 4.2)
if 0:
    def currentPosition (self):
        return self.c.currentPosition()
            
    def currentVnode (self):
        return self.c.currentVnode()
#@nonl
#@-node:ekr.20031218072017.3379:v.currentVnode (and c.currentPosition 4.2)
#@-node:ekr.20060905103748:Removed p and v methods using v.c or p.c
#@-node:ekr.20060905092512.2:Eliminated v.c and p.c
#@+node:ekr.20060907101636:Call c.findRootPosition in c.setCurrentPosition
# Very important: it guarantees that c.rootPosition always returns the proper value.
#@nonl
#@+node:ekr.20060906134053:c.findRootPosition New in 4.4.2
@ Aha! The Commands class can easily recompute the root position::

    c.setRootPosition(c.findRootPosition(p))

Any command that changes the outline should call this code.

As a result, the fundamental p and v methods that alter trees need never
convern themselves about reporting the changed root.  A big improvement.
@c

def findRootPosition (self,p):
    
    '''Return the root position of the outline containing p.'''
    
    c = self ; p = p.copy()
    
    while p and p.hasParent():
        p.moveToParent()
        
    while p and p.hasBack():
        p.moveToBack()
        
    # g.trace(p and p.headString())

    return p
#@nonl
#@-node:ekr.20060906134053:c.findRootPosition New in 4.4.2
#@+node:ekr.20040803140033:c.currentPosition
def currentPosition (self,copy=True):
    
    """Return the presently selected position."""
    
    c = self

    if c._currentPosition:
        # New in Leo 4.4.2: *always* return a copy.
        return c._currentPosition.copy()
    else:
        return c.nullPosition()
    
# For compatibiility with old scripts.
currentVnode = currentPosition
#@-node:ekr.20040803140033:c.currentPosition
#@+node:ekr.20040803140033.3:c.setRootPosition
def setRootPosition(self,p):
    
    """Set the root positioin."""

    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._rootPosition to be non-None.
        if c._rootPosition and p.equal(c._rootPosition):
            pass # We have already made a copy.
        else:
            # We must make a copy _now_.
            c._rootPosition = p.copy()
    else:
        c._rootPosition = None
#@nonl
#@-node:ekr.20040803140033.3:c.setRootPosition
#@+node:ekr.20031218072017.2997:c.selectPosition
def selectPosition(self,p,updateBeadList=True):
    
    """Select a new position."""

    c = self
    
    # g.trace(p.headString(),g.callers())

    c.frame.tree.select(p,updateBeadList)
    
    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
#@-node:ekr.20031218072017.2997:c.selectPosition
#@+node:ekr.20040803140033.2:c.rootPosition
def rootPosition(self):
    
    """Return the root position."""
    
    c = self
    
    if self._rootPosition:
        return self._rootPosition.copy()
    else:
        return  c.nullPosition()

# For compatibiility with old scripts.
rootVnode = rootPosition
#@nonl
#@-node:ekr.20040803140033.2:c.rootPosition
#@+node:ekr.20040803140033.1:c.setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position. For internal use only.
    
    Client code should use c.selectPosition instead."""
    
    c = self
    
    # g.trace(p.headString(),g.callers())
    
    if p:
        # Important: p.equal requires c._currentPosition to be non-None.
        if c._currentPosition and p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
            
        # New in Leo 4.4.2: always recompute the root position here.
        # This *guarantees* that c.rootPosition always returns the proper value.
        c.setRootPosition(c.findRootPosition(c._currentPosition))
    else:
        c._currentPosition = None

# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:c.setCurrentPosition
#@-node:ekr.20060907101636:Call c.findRootPosition in c.setCurrentPosition
#@+node:ekr.20060908075800.1:Removed redundant calls to c.findRootPosition
#@-node:ekr.20060908075800.1:Removed redundant calls to c.findRootPosition
#@+node:ekr.20060908115325:Reviewed p.deleteLinksInTree
# In fact, p.deleteLinksInTree is needed: as unit tests show that some adjustments are made.
#@nonl
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040409203454.1:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@+node:ekr.20040410170806:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20040410170806:p.deleteLinksInSubtree
#@+node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
#@-node:ekr.20040409203454.1:p.deleteLinksInTree & allies
#@-node:ekr.20060908115325:Reviewed p.deleteLinksInTree
#@+node:ekr.20060913082305:Fixed problem with t.hash
#@+node:ekr.20060908205857:t.__hash__ (only for zodb)
if use_zodb and ZODB:
    
    # The only required property is that objects
    # which compare equal have the same hash value.
    
    def __hash__(self):

        return hash(g.app.nodeIndices.toString(self.fileIndex))
        
        # return sum([ord(ch) for ch in g.app.nodeIndices.toString(self.fileIndex)])
#@nonl
#@-node:ekr.20060908205857:t.__hash__ (only for zodb)
#@+node:ekr.20060910100316:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20060910100316:v.__hash__ (only for zodb)
#@-node:ekr.20060913082305:Fixed problem with t.hash
#@+node:ekr.20060920180657:Investigated removing t.vnodeList (not a good idea)
@nocolor
@

It's tempting to try to remove t.vnodeList, but it would not be wise:
    
1. The present code works, and is not actually inefficient.
2. Whan a clone is deleted, we need to update the parent if the tnode that the clone shared.
   Other ways of doing so are conceivable, but they won't be significantly simpler.
3. The markAllAncestorAtFileNodesDirty algorithm is usually *much* faster than searching the entire tree.
4. Although mostly the code tests whether len(vnodeList) > 1, there *are* other uses.

The actual usages of vnodeList:
    
- In createVnode: skip = len(vnodeList) > 1.
- getExistingVnode uses vnodeList[0].
- adjustParentLinksInSubtree uses vnodeList[0]
- isCloned: returns len(vnodeList) > 1.
- directParents: returns vnodeList (but directParents only used by setAllAncestorAtFileNodesDirty.
- findAllPotentiallyDirtyNodes: uses vnodeList.
- moveToParent: use len(vnodeList)
- vParentWithStack: uses len(vnodeList)
** moveOutlineUp: if back2 and p.v in back2.v.t.vnodeList:
* findChild4: uses vnodeList[0], but it's a weird use.
#@nonl
#@-node:ekr.20060920180657:Investigated removing t.vnodeList (not a good idea)
#@-node:ekr.20060905091234:Code level
#@+node:ekr.20060912093334:New features
#@+node:ekr.20060911160213:Added multiple editor commands to Cmds menu
#@+node:ekr.20060912093334.1:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3909651

Could the multiple editor activation be added to the standard Leo menus?
#@nonl
#@-node:ekr.20060912093334.1:Request
#@-node:ekr.20060911160213:Added multiple editor commands to Cmds menu
#@+node:ekr.20060913090832:Created convenience methods for zodb scripts
# Also, the 'stack' arg to the position ctor now defaults to None.
#@nonl
#@+node:ekr.20060913090832.1:g.init_zodb
init_zodb_import_failed = False
init_zodb_failed = {} # Keys are paths, values are True.
init_zodb_db = {} # Keys are paths, values are ZODB.DB instances.

def init_zodb (pathToZodbStorage,verbose=True):
    
    '''Return an ZODB.DB instance from ZODB.FileStorage.FileStorage(pathToZodbStorage)
    return None on any error.'''
    
    global init_zodb_db, init_zodb_failed, init_zodb_import_failed
    
    db = init_zodb_db.get(pathToZodbStorage)
    if db: return db
    
    if init_zodb_import_failed: return None

    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed: return None

    try:
        import ZODB
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None
    
    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db [pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed [pathToZodbStorage] = True
        return None
#@nonl
#@-node:ekr.20060913090832.1:g.init_zodb
#@+node:ekr.20031218072017.892:p.__init__
# New in Leo 4.4.2: make stack default to None.

def __init__ (self,v,stack=None,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    # assert(v is None or v.t)
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # if g.app.tracePositions and trace: g.trace(g.callers())
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20031218072017.892:p.__init__
#@+node:ekr.20060913091805.1:v.detach
def detach (self):
    
    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''
    
    v = self
    
    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())
    
    return vnode(t2)
#@nonl
#@-node:ekr.20060913091805.1:v.detach
#@-node:ekr.20060913090832:Created convenience methods for zodb scripts
#@+node:ekr.20060923043120:Improved help-for-command
# It now prints the binding for the command.
#@nonl
#@-node:ekr.20060923043120:Improved help-for-command
#@+node:ekr.20060923065819:Put cursor/focus/pane/scroll/selection commands in Cmds menu
#@+node:ekr.20060924124119:defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    c = self.c
    
    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]
    
    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]
    
    self.cursorMenuForwardTable = [
        # &: b,c,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&word',
        '-',
        '&next-line',
    ]
    
    self.cursorMenuForwardExtendTable = [
        # &: e,b,c,l,n,p,s,w
        '&extend-to-word',
        '-',
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&word-extend-selection',
        '-',
        '&next-line-extend-selection',    
    ]
#@nonl
#@-node:ekr.20060924124119:defineCmdsMenuCursorTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('&Cmds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # Used in top table: q,u,x
        # &: a,b,c,d,f,g,h,m,n,o,p,r,s,t
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Cursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('&Panes...',           self.cmdsMenuPanesTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',     self.cmdsMenuToggleTable),
    ):
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20060924161901:defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    c = self.c

    self.cmdsMenuTextTable = [
        # &: b,c,d,e,f,g,i,l,m,n,o,p,r,s,u,y
        '&beautify-python-code',
        'beautify-all-p&ython-code',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
#@nonl
#@-node:ekr.20060924161901:defineCmdsMenuTextTable
#@+node:ekr.20060923060822:defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    c = self.c

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
#@-node:ekr.20060923060822:defineCmdsMenuFocusTable
#@+node:ekr.20060924120752:defineCmdsMenuPanesTable
def defineCmdsMenuPanesTable (self):

    c = self.c

    self.cmdsMenuPanesTable = [
        # &: a,b,d,f,l,n,o,p,u,x,y
        'contract-&body-pane',
        'contract-&log-pane',
        'contract-&outline-pane',
        'contract-&pane',
        '-',
        'expand-bo&dy-pane',
        'expand-lo&g-pane',
        'expand-o&utline-pane',
        'expand-pa&ne',
        '-',
        '&fully-expand-body-pane',
        'full&y-expand-log-pane',
        'fully-e&xpand-outline-pane',
        'fully-exp&and-pane',
    ]
    
#@nonl
#@-node:ekr.20060924120752:defineCmdsMenuPanesTable
#@+node:ekr.20060923060822.1:defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    c = self.c

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-&down',
        'scroll-&up',
        '-',
        'scroll-down-&extend-selection',
        'scroll-up-e&xtend-selection',
    ]
#@nonl
#@-node:ekr.20060923060822.1:defineCmdsMenuScrollTable
#@-node:ekr.20060923065819:Put cursor/focus/pane/scroll/selection commands in Cmds menu
#@+node:ekr.20060926085352:Improved  quick-find commands
# Rewrote moveWordHelper. It now avoids Tk and regexes.  *Much* simpler.
#@nonl
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    self.editMenuFindMenuTable = [
        # &: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,t,u,w,x
        '&open-find-tab',
        '&hide-find-tab',
        'search-&with-present-options',
        '-',
        'find-tab-find-&next',
        'find-tab-find-&prev',
        'find-tab-&change',
        'find-with-present-op&tions',
        'find-tab-find-&all',
        'clone-fi&nd-all',
        'find-tab-change-a&ll',
        '-',
        '&find-character',
        'find-character-extend-&selection',
        '&backward-find-character',
        'backward-find-character-&extend-selection',
        '-',
        '&isearch-forward',
        'isea&rch-backward',
        'isearch-forward-rege&xp',
        'isearch-backward-regex&p',
        '-',
        '&query-replace',
        'q&uery-replace-regex',
    ]

# find-character-reverse            = Alt-P
# isearch-with-present-options      = None
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20051218122116:moveToHelper
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.widgetWantsFocusNow(w)

    wname = c.widget_name(w)
    if wname.startswith('mini'):
        # Put the request in the proper range.
        i, j = k.getEditableTextRange()
        ins1 = w.index('insert')
        spot = w.index(spot)
        if w.compare(spot,'<',i):
            spot = i
        elif w.compare(spot,'>',j):
            spot = j
        w.mark_set('insert',spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.see(spot)
    else:
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.index('insert')

        # Move to the spot.
        w.mark_set('insert',spot)
        spot = w.index('insert')

        # Handle the selection.
        self.extendHelper(w,extend,ins1,spot,setSpot=True)
        w.see(spot)
#@-node:ekr.20051218122116:moveToHelper
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)
    
def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)
    
def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)
    
def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        self.event = event ; self.widget = w = event.widget
        self.backward = backward ; self.extend = extend ;
        self.insert = w.index('insert')
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.widget
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = g.app.gui.getAllText(w)
        def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
        def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
        ins = toPython(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1:
                spot = toGui(j)
                self.moveToHelper(event,spot,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1:
                spot = toGui(j)
                self.moveToHelper(event,spot,extend)
        c.frame.clearStatusLine()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord
def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.widget ; c = k.c
        if word:
            i = w.index('insert')
            s = g.app.gui.getAllText(w)
            i = g.app.gui.toPythonIndex(s,w,i)
            j = s.find('\n',i) # Limit to this line.
            s = s[:j]
            word_chars = string.letters + string.digits + '_'
            while i < len(s):
                if i == -1: break
                ok = g.match_word(s,i,word) and (i == 0 or s[i-1] not in word_chars)
                # g.trace(ok,repr(word),i,repr(s))
                if ok:
                    i1 = g.app.gui.toGuiIndex(s,w,i)
                    i2 = g.app.gui.toGuiIndex(s,w,i+len(word))
                    g.app.gui.setSelectionRange(w,i1,i2)
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()
#@-node:ekr.20060417194232.2:findWord
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.widgetWantsFocus(w)
    s = w.get('1.0','end') ; n = len(s)

    def toGui (i): return g.app.gui.toGuiIndex(s,w,i)
    def toPython (i): return g.app.gui.toPythonIndex(s,w,i)
    def isWordChar(ch): return ch in (string.letters + string.digits + '_')

    i = toPython(w.index('insert'))
    delta = g.choose(forward,1,-1)
    
    if not forward: i -= 1
    while 0 <= i < n and isWordChar(s[i]):
        i += delta
    while 0 <= i < n and not isWordChar(s[i]):
        i += delta
    if not forward: i += 1

    self.moveToHelper(event,toGui(i),extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=False)
    
def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,ignoreCase=False,regexp=True)
    
def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,ignoreCase=False,regexp=True)
    
def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using the regexp and reverse options from the find panel.'''
    self.startIncremental(event,forward=None,ignoreCase=None,regexp=None)
#@+node:ekr.20060420144640:iSearchBackspace
def iSearchBackspace (self):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.w
    
    if not self.isearch_stack:
        ins = gui.getInsertPoint(w)
        self.endSearch(ins,ins)
        return 
    
    gui.set_focus(c,w)
    pattern = k.getLabel(ignorePrompt=True)
    self.scolorizer(event=None,pattern=pattern)

    sel,ins = self.isearch_stack.pop()
    
    if sel:
        i,j = sel
        gui.setTextSelection(w,i,j,insert=ins)
    else:
        gui.setInsertPoint(w,ins)

    w.see('insert')
    
    if not self.isearch_stack:
        self.endSearch(ins,ins)
#@-node:ekr.20060420144640:iSearchBackspace
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,ignoreCase,regexp):

    c = self.c ; k = self.k ; w = self.w
    
    # None is a signal to get the option from the find tab.
    if forward is None or regexp is None:
        self.openFindTab(show=False)
        if not self.minibufferFindHandler:
            self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)
        getOption = self.minibufferFindHandler.getOption
        # g.trace('reverse',getOption('reverse'))
        # g.trace('pattern',getOption('pattern_match'))
    else:
        getOption = lambda a: False # The value isn't used.

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!
    
    self.ins1 = ins = g.app.gui.getInsertPoint(w)
    sel = g.app.gui.getSelectionRange(w) or (ins,ins),
    self.isearch_stack = [(sel,ins),]

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20050920084036.264:iSearchStateHandler
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocusNow()
    if keysym == 'Return':
        sel = g.app.gui.getSelectionRange(w)
        if sel: i,j = sel
        else:   i = j = g.app.gui.getInsertPoint(w)
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
#@-node:ekr.20050920084036.264:iSearchStateHandler
#@+node:ekr.20050920084036.265:scolorizer
def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = '1.0'
    index = w.index('insert')
    index2 = w.index('%s+%dc' % (index,len(s)))
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@-node:ekr.20050920084036.265:scolorizer
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event):

    '''Move the cursor to position that matches the pattern in the miniBuffer.
    isearches do not cross node boundaries.'''
    
    c = self.c ; gui = g.app.gui ; k = self.k ; w = self.w
    p = c.currentPosition() ;
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    s = gui.getAllText(w)

    if self.isearch_v != p.v:
        self.isearch_v = p.v
        self.isearch_stack = []

    sel = gui.getSelectionRange(w)
    startindex = insert = gui.getInsertPoint(w)
    
    if self.forward:
        i1 = gui.toPythonIndex(s,w,startindex)
        j1 = len(s)
    else:
        i1 = 0
        j1 = min(len(s),gui.toPythonIndex(s,w,startindex) + len(pattern))
    
    i,j = self.ifinder.searchHelper(s,i1,j1,pattern,
        backwards=not self.forward,
        nocase=self.ignoreCase,
        regexp=self.regexp,
        word=False, # Incremental word-matches are not possible!
        swapij=False)

    if i != -1:
        self.isearch_stack.append((sel,insert),)
        pos    = gui.toGuiIndex(s,w,i)
        newpos = gui.toGuiIndex(s,w,j)
        # g.trace(i1,j1,i,j,pos,newpos)
        gui.set_focus(c,w)
        gui.setTextSelection(w,pos,newpos,insert=pos)
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')
    
    insert = g.choose(self.forward,'sel.end','sel.start')
    g.app.gui.setTextSelection (self.w,i,j,insert=insert)

    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20060926085352:Improved  quick-find commands
#@+node:ekr.20041228084018.5:Finished/retired zodb plugin
@nocolor

My present thinking is that scripts should be able to store/retrieve persistent
objects to/from the zodb. That is, the zodb plugin is likely to be retired.

Leo's vnode and tnode classes now derive from ZODB.Persistence.Persistent if
leoNodes.use_zodb is True. It remains to be seen whether having use_zodb = True
will cause any serious problems.

See the posting below (Scripting using zodb) for latest details.

See the node 'zodb get/put buttons' in test.leo for examples of how scripts can access zodb easily.
#@nonl
#@+node:ekr.20060913084832:@ulr http://www.zope.org/Wikis/ZODB/guide/zodb.html
#@-node:ekr.20060913084832:@ulr http://www.zope.org/Wikis/ZODB/guide/zodb.html
#@+node:ekr.20060913085557:Scripting using zodb
> Do you see zodb as persisting Leo files or Leo nodes?

Interesting question.  I now see the zodb plugin as a proof-of-concept for *user-defined* scripts.  The zodb plugin is probably going to go away.

Let us suppose that db is a ZODB.DB instance. (To see how to create such an instance, see the init_zodb method in the zodb plugin.  Perhaps I'll defines something like g.openZodb to make this easier.)  Then the statements:

connection = db.open()
root = connection.root()
root[aKey] = v
get_transaction().commit()
connection.close()

will write all of v's data (all vnodes and tnodes) to the zodb.  This is true whatever v is: it can be the root of an entire outline, or any suboutline.  If you want to write a single node, you would have to 'detach' that node from the outline.  You can do this by copying the node and then unlinking the node from its descendents. Perhaps I could add a convenience method to the vnode class to make this easier.

>Do you see zodb work as providing enhanced access to nodes across multiple files?

Scripts could do so easily.  Happily, the distinction between 'long-lived' and 'short-lived' connections is not important for scripts: a script should hold a connection open only for as long as needed.  So it would be easy to write any number of vnode trees to the zodb.  Later, another script could access any of the data in the zodb by zodb key.  Like this:

connection = db.open()
root = connection.root()
v = root.get(aKey)
p = leoNodes.position(v,[])

After running this script, p is a position representing the root of the tree of 'imported' vnodes.  The script above does not 'connect' the imported trees to an outline, nor should it do so.  As I write this, I realize that the position ctor should make the second argument optional, so that leoNodes.position(v) would be equivalent to leoNodes.position(v,[]).

Each script should open at most connection at a time and be sure to close any zodb connection it creates.  The proper way to do this is in a finally statement, like this:

try:
....connection = db.open()
....root = connection.root()
....v = root.get(aKey)
....p = leoNodes.position(v,[])
....<< do something with the nodes in p's tree>>
finally:
....get_transaction().commit()
....connection.close()

In short, the recent changes to Leo's vnode and tnode classes give scripts the ability to save/retrieve Leo data to/from the zodb in any way a script wants, without any further support from Leo, or from me.

I shall spend an hour or two more with the zodb plugin, but it looks to me that the plugin has served its purpose.  Rather than trying to guess how people will want to use the zodb, it will be simpler and more general to have people write scripts that do exactly what they want.  In particular, such scripts can easily sidestep the problems with multiple open connections.

Edward

P.S. Please note that the scripts shown above could not have been written without all the recent work with the zodb plugin and the big code reorg.

P.P.S. A couple of unit tests involving the new v/t.__hash__ methods just failed, so it may be just a little bit longer before the code on cvs is truly zodb ready.  I'll also be working on example scripts and the convenience methods described above.

EKR
#@-node:ekr.20060913085557:Scripting using zodb
#@-node:ekr.20041228084018.5:Finished/retired zodb plugin
#@-node:ekr.20060912093334:New features
#@-node:ekr.20060904165452:4.4.2 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
