#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20071128100845:Pylint
#@+node:ekr.20071128095109:pylint: leoEditCommands.py
# These errors are not correct.
E1101:108:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'name' member
E1101:109:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'undoType' member
E1101:110:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldSel' member
E1101:110:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldText' member
#@-node:ekr.20071128095109:pylint: leoEditCommands.py
#@+node:ekr.20071130094930:pylint: leoGlobals.py
************* Module leoGlobals

# Fixed: E0602:550:scanAtPagewidthDirective: Undefined variable 'k'
# Fixed: E0602:609:scanAtTabwidthDirective: Undefined variable 'k'
# Fixed: E0602:1056:es_exception: Undefined variable 's'
# Fixed: E0102:5098:getLine: function already defined line 1335

# Bad warnings:
# E1101:137:computeGlobalConfigDir: Module 'sys' has no 'leo_config_directory' member
# W0631:2956:scanAtFileOptions: Using possibly undefined loop variable 'option'
# W0104:3869: Statement seems to have no effect
# E0602:3885:getpreferredencoding: Undefined variable 'LC_CTYPE'
# E0602:3886:getpreferredencoding: Undefined variable 'LC_CTYPE'
# E1101:3887:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
# E0602:3887:getpreferredencoding: Undefined variable 'CODESET'
# E0602:3888:getpreferredencoding: Undefined variable 'LC_CTYPE'
# E1101:3891:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
# E0602:3891:getpreferredencoding: Undefined variable 'CODESET'
# E1101:4386:mulderUpdateAlgorithm.copy_time: Module 'os' has no 'mtime' member
# W0631:4415:mulderUpdateAlgorithm.create_mapping: Using possibly undefined loop variable 'i'
# R0903:4815:nullObject: Too few public methods (0/1)
# W0631:5393:adjustTripleString: Using possibly undefined loop variable 's'
#@-node:ekr.20071130094930:pylint: leoGlobals.py
#@-node:ekr.20071128100845:Pylint
#@+node:ekr.20071211113202:Leo 5.0 a1
#@+node:ekr.20071211113202.1:Bugs fixed
#@-node:ekr.20071211113202.1:Bugs fixed
#@+node:ekr.20071211113202.2:New features
#@+node:ekr.20071210054816:Applied Terry Brown's config patch
@nocolor
The patch attached against leoConfig.py (current CVS) adds a machine
specific config file to the config files Leo loads.

I synchronize files between multiple (3) machines. This means I can't
use different myLeoSettings files on each.

Tk fonts are screen dpi sensitive.  But (in Linux at least)
Tk's attempts to switch a font you picked to something equivalent at a
different dpi always result in a font that looks terrible.

So every time I switch machines I edit ~/myLeoSettings.leo to move the
font defs I picked for the current machine to the bottom of the body
text for the appropriate settings node, and then restart Leo.

This patch means I don't have to do that any more.  I'm sure there are
other uses for it.  Python doesn't seem to have a generic machine name
finding function, hence the sequence of alternatives.

Cheers -Terry


-----Inline Attachment Follows-----

Index: leo/src/leoConfig.py
===================================================================
RCS file: /cvs/leo/src/leoConfig.py,v
retrieving revision 1.54
diff -r1.54 leoConfig.py
1159a1160,1177
>        machineSettingsFile = None
>        #@    << determine machine settings file name >>
>        #@+node:tbrown.20071208101033:<< determine machine settings file name >>
>        try:
>            import os
>            machineSettingsFile = os.getenv('HOSTNAME')
>            if not machineSettingsFile:
>                machineSettingsFile = os.getenv('COMPUTERNAME')
>            if not machineSettingsFile:
>                import socket
>                machineSettingsFile = socket.gethostname()
>        except:
>            machineSettingsFile = None
>        if machineSettingsFile:
>            machineSettingsFile+='LeoSettings.leo'
>        #@nonl
>        #@-node:tbrown.20071208101033:<< determine machine settings file name >>
>        #@nl
1165a1184
>            ('machineConfigFile',    g.app.homeDir,          machineSettingsFile),
1168a1188,1190
>
>            if not fileName: continue
>
1638a1661
>            (self.machineConfigFile,False),

@color
#@nonl
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print()
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.machineConfigFile and self.myConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = self.getMachineName()

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
        ('machineConfigFile',   g.app.homeDir,          machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@+node:ekr.20071211112804:getMachineName
def getMachineName (self):

    try:
        import os
        name = os.getenv('HOSTNAME')
        if not name:
            name = os.getenv('COMPUTERNAME')
        if not name:
            import socket
            name = socket.gethostname()
    except Exception:
        name = ''

    if name:
        name +='LeoSettings.leo'

    # g.trace(name)

    return name
#@-node:ekr.20071211112804:getMachineName
#@-node:ekr.20041117083857:initSettingsFiles
#@-node:ekr.20071210054816:Applied Terry Brown's config patch
#@+node:ekr.20071210090623:Applied plumloco's patch to plugins_menu.py
@nocolor

The version of plugins_menu.py at http://leo.zwiki.org/Plumloco separates out
the gui dependent dialogs (the menus are already gui indepandant) and made them
general purpose dialogs available to all plugins.

I have also slightly enhanced the dialogs to provide user defined buttons. 
#@nonl
#@-node:ekr.20071210090623:Applied plumloco's patch to plugins_menu.py
#@-node:ekr.20071211113202.2:New features
#@-node:ekr.20071211113202:Leo 5.0 a1
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
