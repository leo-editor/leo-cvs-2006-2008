#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20070703172548:Leo 4.4.4 projects
#@+node:ekr.20070703182412:Bugs
#@+node:ekr.20070725155607:removed leoKeywords from colorizer
# This was a fairly big bit of cruft.
#@nonl
#@-node:ekr.20070725155607:removed leoKeywords from colorizer
#@+node:ekr.20070724072345:Fixed UNL bug1
@nocolor

Email from Terry Brown

A softish bug, but the use of findNodeInTree() in the UNL code can 
take you to the wrong place if more than one node in the tree has 
the same headString.  Patch below - can still go wrong if more than 
one sibling has the same name, but the UNL system doesn't have a 
solution for that.

An observation - the UNL jumping code will drop you as far down the 
path as it gets, i.e. you're moved to the last node that was one the 
path, even if the path ends before the last part of the UNL is 
reached.  This is ok, i.e. "this is as far as I could follow the 
UNL", the alternative would be to not move at all if the whole UNL 
can't be followed.

Cheers -Terry

anon_cvs> cvs diff leo/plugins/UNL.py
Index: leo/plugins/UNL.py
===================================================================
RCS file: /cvs/leo/plugins/UNL.py,v
retrieving revision 1.14
diff -r1.14 UNL.py
183c183,186
<                             p = g.findNodeInTree(c2,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break
206c209,212
<                             p = g.findNodeInTree(c,p,headline)
---
>                             for tmpp in p.copy().children_iter():
>                                 if tmpp.headString() == headline:
>                                     p = tmpp
>                                     break


@color
#@nonl
#@+node:ekr.20040321065415:g.findNode... &,findTopLevelNode
def findNodeInChildren(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.children_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""

    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):

    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findTopLevelNode(c,headline):

    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
#@-node:ekr.20040321065415:g.findNode... &,findTopLevelNode
#@-node:ekr.20070724072345:Fixed UNL bug1
#@+node:ekr.20070803081457:Fixed how @auto handles paths
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4444579
By: terry_n_brown

Sure it's what I'd expect, but I don't think it's what it does?

in the directory 'misc_py', where del.leo and addWhitelist.py live:

  python /path/to/leo/src/leo.py del.leo

works, and indeed addWhitelist.py is now correctly imported
in the node '@auto addWhitelist.py' (very cool :-)

but if I cd .. and

  python /path/to/leo/src/leo.py misc_py/del.leo

I get

reading: /media/hda7/misc_py/del.leo
can not open addWhitelist.py

and an empty node '@auto addWhitelist.py'

Makes me think it's trying to load addWhitelist.py relative to the dir from
which leo was run, not the dir of the .leo file.

@color
#@nonl
#@+node:ekr.20041005105605.236:atFile.scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):

    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@+node:ekr.20041005105605.237:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() or p.atAutoNodeName()

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@-node:ekr.20041005105605.237:<< Set path from @file node >>
#@+node:ekr.20041005105605.238:<< handle @path >>
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = g.os_path_join(base,path)

    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")
#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path,c=c)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >>
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:atFile.scanDefaultDirectory
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        p.setTnodeText('')
        # It is too dangerous not to write @auto trees to the .leo file,
        # so we must delete all children here.
        try:
            while p.hasChildren():
                # g.trace('deleting',p.headString())
                p.firstChild().doDelete()
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    # Duplicate the @file directory logic in leoAtFile.py
    if atAuto:
        at = c.atFileCommands
        at.scanDefaultDirectory(parent,importing=True)
        fileName = g.os_path_join(at.default_directory,fileName)

    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@-node:ekr.20070803081457:Fixed how @auto handles paths
#@-node:ekr.20070703182412:Bugs
#@+node:ekr.20070703182412.1:Features
#@+node:ekr.20070703172130:Added support for @mark-for-unit-tests node
# The run-unit-tests command now includes **all** @mark-for-unit-test trees.
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@nonl
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.copyRoot = None # The root of copied tree.
    self.fileName = 'dynamicUnitTest.leo'
    self.root = None # The root of the tree to copy when self.all is False.
    self.tags = ('@test','@suite','@unittests','@unit-tests')
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline & helpers
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c ; markTag = '@mark-for-unit-tests'
    self.copyRoot = c2.rootPosition()
    self.copyRoot.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    self.seen = []
    << set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
    c2.beginUpdate()
    try:
        self.copyRoot.expand()
        for p,limit,lookForMark,lookForNodes in (
            (p1,limit1,lookForMark1,lookForNodes1),
            (p2,limit2,lookForMark2,lookForNodes2),
        ):
            while p and p != limit:
                h = p.headString()
                if p.v.t in self.seen:
                    p.moveToNodeAfterTree()
                elif lookForMark and h.startswith(markTag):
                    self.addMarkTree(p)
                    p.moveToNodeAfterTree()
                elif lookForNodes and self.isUnitTestNode(p):
                    self.addNode(p)
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@nonl
#@+node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
if self.all:
    # A single pass looks for all tags everywhere.
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,True
    p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
else:
    # The first pass looks everywhere for only for @mark-for-unit-tests,
    p1,limit1,lookForMark1,lookForNodes1 = c.rootPosition(),None,True,False
    # The second pass looks in the selected tree for everything except @mark-for-unit-tests.
    # There is no second pass if the present node is an @mark-for-unit-test node.
    p = c.currentPosition()
    if p.headString().startswith(markTag):
        p2,limit2,lookForMark2,lookForNodes2 = None,None,False,False
    else:
        p2,limit2,lookForMark2,lookForNodes2 = p,p.nodeAfterTree(),False,True
#@nonl
#@-node:ekr.20070705065154:<< set p1/2,limit1/2,lookForMark1/2,lookForNodes1/2 >>
#@+node:ekr.20070705080413:addMarkTree
def addMarkTree (self,p):

    # g.trace(len(self.seen),p.headString())

    self.seen.append(p.v.t)

    for p in p.subtree_iter():
        if self.isUnitTestNode(p) and not p.v.t in self.seen:
            self.addNode(p)
#@-node:ekr.20070705080413:addMarkTree
#@+node:ekr.20070705065154.1:addNode
def addNode(self,p):

    '''
    Add an @test, @suite or an @unit-test tree as the last child of self.copyRoot.
    '''

    # g.trace(len(self.seen),p.headString())

    p2 = p.copyTreeAfter()
    p2.unlink()
    p2.moveToLastChildOf(self.copyRoot)

    self.seen.append(p.v.t)
#@-node:ekr.20070705065154.1:addNode
#@+node:ekr.20070705075604.3:isUnitTestNode
def isUnitTestNode (self,p):

    h = p.headString()
    for tag in self.tags:
        if h.startswith(tag):
            return True
    else:
        return False
#@-node:ekr.20070705075604.3:isUnitTestNode
#@-node:ekr.20070627135336.9:createOutline & helpers
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    args = [sys.executable, path, '--silent']

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                self.root = c.currentPosition()
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    self.root = p.copy()
                    return True

    # Finally, look for all @mark-for-unit-test nodes.
    for p in c.allNodes_iter():
        if p.headString().startswith('@mark-for-unit-test'):
            return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20070703172130:Added support for @mark-for-unit-tests node
#@+node:ekr.20070725165751:Created threading_colorizer
@nocolor

> Can anyone point me to a discussion of what is, and is not, guanteed about how
Python schedules threads? In particular, I want the colorizing thread to
relinquish control to the gui thread quite often (for good response), but I
don't want the relinquishing itself to slow down the colorizer much. It seems a
hard problem.

From what I understand, there are perhaps only a few "guarantees" with Python
threads. One guarantee is that when Python source is executing, threads will
swap after sys.getcheckinterval() bytecodes have been processed for that thread.
You can set the delay with sys.setcheckinterval(count). It seems to be 100
bytecodes in Python 2.3-2.5, but I could have sworn it was 1000. In any case,
setting the check interval higher will result in higher speed, but lower
responsiveness.

When making certain C-level calls, Python will also allow the "active" Python
thread to switch. Which really means that the only way you can use those all of
those 4-core processors with Python in a single process is to do all of your
work in C code with carefully crafted GIL acquire and release calls.

If your code is crafted in such a way that there are "convenient" places to
yield control, you can use a technique known as 'cooperative multithreading with
generators'. It gives you the total speed, more or less, of a single thread, but
*you* choose where the context switches occur, for the cost of a bit of extra
complication.
#@nonl
#@-node:ekr.20070725165751:Created threading_colorizer
#@+node:ekr.20070729093951:Added support for @auto
#@+node:ekr.20070611173545.1:Design
@nocolor

I have just started the process of 'priming the pump' for work on @auto.

Here are the key factors that drive the design:

0. [Terminology] Alice uses Leo and doesn't mind having sentinels in derived files. Bob doesn't use Leo, and *does not want sentinels* (at least until Bob gets turned on to Leo), and Mike is Alice's and Bob's manager.  Mike probably doesn't care about sentinels, but would side with Bob if Bob objected to using sentinels.

1. [No sentinels] There was a *lot* of discussion about this.  The initial implementation of @auto will use *absolutely no* sentinels. This might be relaxed later, but the *essential* idea is that @auto is a feature primarily for newbies who DO NOT WANT sentinels in their files.  As Kent has clearly pointed out, within @auto trees, Alice can live without clones, section references and @others, etc.

2. [Perfect import] I designed an algorithm that guarantees that files imported with @auto can be rewritten from the @auto tree with *no* changes to the original file.  This is the 'round-tripping' requirement.

See: Huge aha: design of the parser (perfect import)
http://sourceforge.net/forum/message.php?msg_id=4224283

3. [Resolve cvs conflicts] Leo can let the user resolve cvs conflicts.

See: Huge aha: resolving conflicts
http://sourceforge.net/forum/message.php?msg_id=4224589

The following are references to extended discussions in Leo's forums:

1. From the Open Forum, March, 2007:

auto: a new vision
http://sourceforge.net/forum/forum.php?thread_id=1700873&forum_id=10226

Huge aha: parsing replaces sentinels
http://sourceforge.net/forum/forum.php?thread_id=1699679&forum_id=10226

@auto nodes
http://sourceforge.net/forum/forum.php?thread_id=1699599&forum_id=10226

2. The original motivation was in the 'Discurssion of wxPython issues' thread in
the Developers Forum in March 2007:
http://sourceforge.net/forum/forum.php?thread_id=1695549&forum_id=10228

And especially:
http://sourceforge.net/forum/message.php?msg_id=4217121
#@nonl
#@+node:ekr.20070703172130.1:Aha: perfect import *can* correct whitespace
@nocolor

Aha: the perfect import code *can* correct whitespace (tab, underindented lines)
problems that exists in the original files. When such errors are found, Leo will
issue the message:

    'whitepace error: remove the @ignore statement to correct these problems.'

This is the best possible solution:

- It alerts the user that there are problems with the original file.
- It does *not* change them unless the user takes specific action.
- It *does* correct the problems if desired.
#@-node:ekr.20070703172130.1:Aha: perfect import *can* correct whitespace
#@+node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@-node:ekr.20070512162750:@url http://simpleparse.sourceforge.net/
#@+node:ekr.20040721094203:Probably not: Make sure Leo uses "verbatim" whitespace
http://sourceforge.net/forum/message.php?msg_id=3578166

I think these issues are not really relevant.
#@nonl
#@+node:ekr.20060808103849:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2674828
By: bwmulder

If I understand correctly, there are two different problems:

- Trailing whitespaces
- Left indented comments

1. Before commenting on these, a question:

If I write something like
    a=b
    if a:
        @others

[four spaces indentation]

I sometimes see tab characters before the lines inserted for '@others'.

It seems that Leo remembers 'two levels of indentation', and then
fabricates this indentation using tab characters.

I think it might be more robust if Leo remembered the actual
characters in front of @others and would use them for indentation.

I suspect that many indentation errors I had with Leo could have been
avoided had not Leo had its own ideas on how to do indentation.

Maybe Leo could use the exact sequence of characters in front of
@others for all inserted lines?

2. I do not care much about trailing whitespaces. Most of the time
they are invisible, but sometimes they are very misleading (trailing in python or C).

As far as I am concerned, Leo need never produce trailing whitespaces.

Maybe we need special machinery if sources have trailing whitespaces
and the sources are not under our control. 

Not sure if everybody would be happy if we essentially ban all trailing
whitespaces.

3. Unindented commentlines could be dealt with by using indentation to
indicate structure.

Of course, this might break the correspondance Leo structure / Python
structure, which is very ugly.

4. One possible alternative might be a new directive which indicates outindent:

@outindent <number>.

This would apply to the next comment block.

To me, 4. looks a little bit less ugly than 3.

5. As indicated in a different post, I suspect that Leo has a problem
if almost every node in an outline is changed. Profiling should point
to the culprit.

> 2. Have Leo strip whitespace from otherwise blank lines, and hope
that that solves all problems in Perfect Import. This is solving the
problem in the atFile code. The problem is that if we apply settings
in general we will get massive changes to derived files. In most
programming settings these changes might be welcome, but the problem
is actually making these changes. My first few attempts met with
abject failure.

Are you saying that you could not remove trailing blanks? What kind of
problems did you run into?

Summary:
- Use actual characters in front of @others or <<>> for indentation.
- Don't write trailing whitespaces
- Introduce directive for left-indendet comments.
- Profile to find out what slows Leo down if many nodes change.
#@nonl
#@-node:ekr.20060808103849:Report
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):

    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@-node:ekr.20041005105605.210:putIndent
#@-node:ekr.20040721094203:Probably not: Make sure Leo uses "verbatim" whitespace
#@-node:ekr.20070611173545.1:Design
#@+node:ekr.20070731070208:Recent
@nocolor
@
To do:

- Document @auto.
    - @bool full_import_checks = True
    - Imported commands now create @nosent trees.

- Can leo determine the proper kind of import to do?  Should it?
- Can @auto handle files containing Leo sentinels?

@color
#@nonl
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) < 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    c.beginUpdate()
    try: # range of update...
        if len(files) == 2:
            << Create a parent for two files having a common prefix >>
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                if not g.unitTesting:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    finally:
        c.endUpdate()
    c.selectVnode(current)
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            g.setGlobalOpenDir(fileName)
            << set isThin if fileName is a thin derived file >>
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@+node:ekr.20051208100903.1:forceGnxOnPosition
def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)
#@-node:ekr.20051208100903.1:forceGnxOnPosition
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        p.setTnodeText('')
        # It is too dangerous not to write @auto trees to the .leo file,
        # so we must delete all children here.
        try:
            while p.hasChildren():
                # g.trace('deleting',p.headString())
                p.firstChild().doDelete()
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    # Duplicate the @file directory logic in leoAtFile.py
    if atAuto:
        at = c.atFileCommands
        at.scanDefaultDirectory(parent,importing=True)
        fileName = g.os_path_join(at.default_directory,fileName)

    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigID = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = ic.getTabWidth() # The tab width in effect in the c.currentPosition.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',]
        # tags that start a tag.
    self.functionTags = []
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.sigTailFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070703122141.102:check & helpers
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks:
        result = self.checkWhitespace(s,parent) and self.checkTrialWrite()
        g.app.unitTestDict ['result'] = result
        return result
    else:
        return True
#@+node:ekr.20070703122141.103:checkWhitespace
def checkWhitespace(self,s,parent):

    '''Check and normalize the leading whitespace of all nodes.

    - The original sources may fail Python's tabNanny checks.  

    - Leading whitespace in the original sources may be inconsistent with the
      @tabwidth setting in effect in the @auto tree.

    - The original sources may contain underindented comments. 

    If an indentation problem is found, issue a warning and return False.
    Otherwise, normalize the indentation of all pieces so that it is indeed
    consistent with the indentation specified by the present @tabwidth setting.
    Normalizing underindented comments means shifting the comments right.
    '''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0
    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    ok = blanks == 0 or tabs == 0
    if not ok:
        self.error('File contains intermixed blanks and tabs')
    return ok
#@nonl
#@-node:ekr.20070703122141.103:checkWhitespace
#@+node:ekr.20070703122141.104:checkTrialWrite & helper
def checkTrialWrite (self):

    '''Return True if a trial write produces the original file.'''

    c = self.c ; at = c.atFileCommands
    at.write(self.root,
        nosentinels=True,thinFile=False,
        scriptWrite=False,toString=True,
        write_strips_blank_lines=False,
    )

    ignoreBlankLines = True
    s1,s2 = self.file_s, at.stringOutput
    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    ok = True
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok: break

    d = g.app.unitTestDict
    expectedMismatch =  d.get('expectedMismatchLine')
    actualMismatch = d.get('actualMismatchLine')
    ok = ok or (g.app.unitTesting and expectedMismatch == actualMismatch)
    if not ok:
        if g.app.unitTesting:
            g.trace('expected mismatch line',expectedMismatch,'actualMismatch',actualMismatch)
        else:
            if self.atAuto:
                g.es_print('@auto did not import the file perfectly.',color='red')
        if len(lines1) < 30:
            print 'input...'
            for i in xrange(len(lines1)):
                print '%3d' % (i),lines1[i],
            print 'output...'
            for i in xrange(len(lines2)):
                print '%3d' % (i),lines2[i],
    return ok
#@+node:ekr.20070730093735:compareHelper
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.app.unitTesting:
            print 'extra lines'
            for line in lines2[i:]:
                print repr(line)
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.app.unitTesting:
            print 'missing lines'
            for line in lines2[i:]:
                print repr(line)
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # All blank lines compare equal.
    elif not strict and line1.lstrip() == line2.lstrip():
        return True # A match excluding leading whitespace.
    else:
        if i+1 != expectedMismatch or not g.app.unitTesting:
            print '*** first mismatch at line %d' % (i+1)
            print 'original line: ', repr(line1)
            print 'generated line:', repr(line2)
        d ['actualMismatchLine'] = i+1
        return False
#@-node:ekr.20070730093735:compareHelper
#@-node:ekr.20070703122141.104:checkTrialWrite & helper
#@-node:ekr.20070703122141.102:check & helpers
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')
    g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and children of c for each def in the class.'''

    prefix = self.createClassNodePrefix()
    if not self.sigID:
        g.trace('Can not happen: no sigID')
        sigID = 'Unknown class name'
    class_name = self.sigID
    headline = 'class ' + class_name
    body = s[start:sigEnd]
    body = self.undentBody(body)
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        extend = self.undentBody(extend)
        extend = self.indentBody(extend)
        body = body + extend

    class_node = self.createHeadline(parent,prefix + body,headline)
    savedMethodName = self.methodName
    self.methodName = headline
    self.putClassHelper(s,i,codeEnd,class_name,class_node)
    self.methodName = savedMethodName
#@+node:ekr.20070703122141.106:appendRefToClassNode
def appendRefToClassNode (self,class_name,class_node):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    self.appendTextToClassNode(class_node,'%s%s\n' % (self.tab_ws,s))
#@-node:ekr.20070703122141.106:appendRefToClassNode
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Put any leading decls in the class node.
    trace = False
    start = i
    i = self.skipDecls(s,i,end)
    decls = s[start:i]
    if decls:
        # We must regularize the indentation to match the @others
        decls = self.undentBody(decls)
        decls = self.indentBody(decls)
        if self.trace: g.trace('decls\n%s' % decls)
        # g.trace(class_name,'decls',repr(decls))
        self.appendTextToClassNode(class_node,decls)
    start = i ; putRef = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,self.outerBlockDelim1):
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,class_node)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            self.putFunction(s,self.sigStart,self.codeEnd,start,class_node)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    if putRef:
        self.appendRefToClassNode(class_name,class_node)

    if start < end:
        trailing = s[start:end]
        if trace or self.trace: g.trace('trailing\n%s' % trailing)
        self.appendTextToClassNode(class_node,trailing)
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    if self.sigID:
        headline = self.sigID
    else:
        g.trace('Can not happen: no sigID')
        headline = 'unknown function'

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if self.trace:
        g.trace('body\n%s' % repr(body))
        g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error('function does not end with a newline.  A newline will be added.')
        g.es(g.get_line(s,codeEnd),color='blue')

    self.createFunctionNode(headline,body,parent)
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    #g.trace('before',repr(s))

    # Copy an @code line as is.
    i = 0
    if g.match(s,i,'@code'):
        j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        result += s[j:i]

    # Calculate the amount to be removed from each line.
    undent = self.getLeadingIndent(s,i,ignoreComments=ignoreComments)
    if undent == 0:
        return s
    else:
        result = ''.join([
            g.removeLeadingWhitespace(line,undent,self.tab_width)
                for line in g.splitLines(s)])
        #g.trace('after',repr(result))
        return result
#@-node:ekr.20070703122141.88:undentBody
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error('underindented python comments.\nExtra leading whitespace will be added')
    g.es(line,color='blue')

def underindentedLine (self,line):

    self.error('underindented line.\nExtra leading whitespace will be added')
    g.es(line,color='blue')

#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error & oops
def error (self,s):
    g.es_print(s,color='red')
    self.errors += 1
    g.app.unitTestDict['actualErrors'] = self.errors

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()
#@-node:ekr.20070703122141.78:error & oops
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20070706101600:scan
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''
    self.putRootText(parent)
    i = start = self.skipDecls(s,0,len(s))
    decls = s[:i]
    if decls: self.createDeclsNode(parent,decls)
    while i < len(s):
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,self.outerBlockDelim1):
            # k = i
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # g.trace('\n',s[k:i])
        elif self.startsClass(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@-node:ekr.20070706101600:scan
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline:
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 0 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0: break
        else: i += 1
        assert progress < i

    if trace: g.trace('returns\n',s[start:i])
    return i
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    i = self.skipBlock(s,i,delim1=None,delim2=None)
    i = self.skipNewline(s,i,kind)

    return i
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls & helper
def skipDecls (self,s,i,end):

    '''Skip everything until the start of the next class or function.'''

    trace = False
    start = i
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,self.outerBlockDelim1):
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        elif self.startsClass(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'class')
            break
        elif self.startsFunction(s,i,quick=True):
            # Important: do not include leading ws in the decls.
            i = self.adjustClassOrFunctionStart(s,i,'function')
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert(progress < i)

    # Ignore empty decls.
    if s[start:i].strip():
        if trace or self.trace: g.trace('\n'+s[start:i])
        return i
    else:
        return start
#@+node:ekr.20070709084313:adjustClassOrFunctionStart
def adjustClassOrFunctionStart(self,s,i,tag):

    '''
    s[i:] starts a class or function.
    Adjust i so it points at the start of the line.

    Issue a warning if anything except whitespace appears.
    '''

    j = g.find_line_start(s,i)
    if s[j:i].strip():
        message = '%s definition does not start a line. Leo must insert a newline.' % tag
        self.error(message)
        return i
    else:
        return j
#@-node:ekr.20070709084313:adjustClassOrFunctionStart
#@-node:ekr.20070707080042:skipDecls & helper
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while 1:
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error('%s does not end in a newline.  A newline will be added.' % kind)
        g.es(g.get_line(s,i),color='blue')

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''

    trace = False
    self.codeEnd = self.sigEnd = self.sigID = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    if tags:
        j = g.skip_ws_and_nl(s,i)
        i = self.skipId(s,j)
        theId = s[j:i]
        if theId not in tags:
            return False
        if trace: g.trace('tags',tags,'theId',theId)
        if quick: return True

    if trace: g.trace('kind',kind)

    # Get the class/function id.
    i, ids = self.skipSigStart(s,i,tags)
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace: g.trace('no sigId',g.get_line(s,i))
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace: g.trace('no block',g.get_line(s,i))
            return False

    i = self.skipCodeBlock(s,i,kind)
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigID = sigId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if s[self.sigStart:k].strip():
        self.error('%s definition does not start a line' % kind)
        g.es(g.get_line(s,k),color='blue')

    if trace or self.trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    __pychecker__ = '--no-argsused' # tags not used in the base class.

    ids = []
    while 1:
        j = g.skip_ws_and_nl(s,i)
        i = self.skipId(s,j)
        theId = s[j:i]
        if theId: ids.append(theId)
        else: break

    return i, ids
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s) and not g.match(s,i,self.blockDelim1):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.sigTailFailTokens:
            for z in self.sigTailFailTokens:
                if g.match(s,i,z):
                    return i,False
            else:
                i += 1
        else:
            i += 1

    return i,True
#@-node:ekr.20070712082913:skipSigTail
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run
def run (self,s,parent):

    scanner = self ; c = self.c
    scanner.root = parent
    scanner.file_s = s

    # Step 1: generate the nodes,
    # including all directive and section references.
    self.errors = 0
    self.errorLines = []
    changed = c.isChanged()
    scanner.scan(s,parent)

    # Step 2: check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and scanner.check(s,parent)
    # g.trace('ok',ok,'parent',parent)

    # Step 3: insert an @ignore directive if there are any problems.
    if ok:
        if self.atAuto:
            for p in parent.self_and_subtree_iter():
                p.clearDirty()
            if not changed:
                c.setChanged(False)
    else:
        scanner.insertIgnoreDirective(parent)
        c.setChanged(True)
#@-node:ekr.20070707072749:run
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070703122141.99:scanPythonText
def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070703122141.99:scanPythonText
#@+node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
class pythonScanner (baseScannerClass):

    @others
#@+node:ekr.20070703122141.101: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.blockDelim2 = None
    self.strict = True

#@-node:ekr.20070703122141.101: __init__
#@+node:ekr.20070707073723:Overrides
#@+node:ekr.20070707113839:extendSignature
def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j < len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
#@-node:ekr.20070707113839:extendSignature
#@+node:ekr.20070707073627.4:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
#@-node:ekr.20070707073627.4:skipString
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False
    if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if trace: g.trace(g.get_line(s,i))
            if not backslashNewline:
                i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                    s,i,parenCount,startIndent,underIndentedStart)
                if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
    if (trace or self.trace) and s[start:i].strip():
        g.trace('returns\n'+s[start:i])
    return i
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@+node:ekr.20070803101619:skipSigTail
# This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
#@-node:ekr.20070803101619:skipSigTail
#@-node:ekr.20070707073723:Overrides
#@-node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
#@-node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Put any leading decls in the class node.
    trace = False
    start = i
    i = self.skipDecls(s,i,end)
    decls = s[start:i]
    if decls:
        # We must regularize the indentation to match the @others
        decls = self.undentBody(decls)
        decls = self.indentBody(decls)
        if self.trace: g.trace('decls\n%s' % decls)
        # g.trace(class_name,'decls',repr(decls))
        self.appendTextToClassNode(class_node,decls)
    start = i ; putRef = False
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,self.outerBlockDelim1):
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,self.sigStart,self.sigEnd,self.codeEnd,start,class_node)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            self.putFunction(s,self.sigStart,self.codeEnd,start,class_node)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    if putRef:
        self.appendRefToClassNode(class_name,class_node)

    if start < end:
        trailing = s[start:end]
        if trace or self.trace: g.trace('trailing\n%s' % trailing)
        self.appendTextToClassNode(class_node,trailing)
#@-node:ekr.20070707171329:putClassHelper
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False
    if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if trace: g.trace(g.get_line(s,i))
            if not backslashNewline:
                i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                    s,i,parenCount,startIndent,underIndentedStart)
                if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
    if (trace or self.trace) and s[start:i].strip():
        g.trace('returns\n'+s[start:i])
    return i
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i,quick=False):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='class',quick=quick,tags=self.classTags)
    return i

def startsFunction (self,s,i,quick=False):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''
    i = self.startsHelper(s,i,kind='function',quick=quick,tags=self.functionTags)
    return i
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,quick,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigID and codeEnd ivars.'''

    trace = False
    self.codeEnd = self.sigEnd = self.sigID = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Run a quick check first.
    # Get the tag that starts the class or function.
    if tags:
        j = g.skip_ws_and_nl(s,i)
        i = self.skipId(s,j)
        theId = s[j:i]
        if theId not in tags:
            return False
        if trace: g.trace('tags',tags,'theId',theId)
        if quick: return True

    if trace: g.trace('kind',kind)

    # Get the class/function id.
    i, ids = self.skipSigStart(s,i,tags)
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace: g.trace('no sigId',g.get_line(s,i))
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace: g.trace('no block',g.get_line(s,i))
            return False

    i = self.skipCodeBlock(s,i,kind)
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigID = sigId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if s[self.sigStart:k].strip():
        self.error('%s definition does not start a line' % kind)
        g.es(g.get_line(s,k),color='blue')

    if trace or self.trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    __pychecker__ = '--no-argsused' # tags not used in the base class.

    ids = []
    while 1:
        j = g.skip_ws_and_nl(s,i)
        i = self.skipId(s,j)
        theId = s[j:i]
        if theId: ids.append(theId)
        else: break

    return i, ids
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s) and not g.match(s,i,self.blockDelim1):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.sigTailFailTokens:
            for z in self.sigTailFailTokens:
                if g.match(s,i,z):
                    return i,False
            else:
                i += 1
        else:
            i += 1

    return i,True
#@-node:ekr.20070712082913:skipSigTail
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@-node:ekr.20070731070208:Recent
#@-node:ekr.20070729093951:Added support for @auto
#@-node:ekr.20070703182412.1:Features
#@-node:ekr.20070703172548:Leo 4.4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
