#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20050924073836:4.4 projects
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20051029070945:Pychecker report
# None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found
#@nonl
#@-node:ekr.20051029070945:Pychecker report
#@+node:ekr.20060203112912.1:Initing
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >> (commands)
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.
    << set the leoTkinterFrame ivars >>
#@nonl
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    self.trace_status_line = c.config.getBool('trace_status_line')
    # f.enableTclTraces()
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("<Activate>",f.OnActivateLeoEvent)
        f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
        f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
        f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@nonl
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):

    # pageName is not used here: it is used for compatibility with the Chapters plugin.

    c = self.c

    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    trace = self.c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace(canvas)
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 0:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@+node:ekr.20041221071131:createPmwTreeCanvas (not used)
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
 
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas (not used)
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf (tkFrame)
def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf (tkFrame)
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20050920085536.1: Birth (keyHandler)
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter')
    self.enable_calltips                = c.config.getBool('enable_calltips')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
    
    self.autoCompleter = autoCompleterClass(self)
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()
#@nonl
#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}
self.getArgEscapes = []
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20060115195302:setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)
#@nonl
#@-node:ekr.20060115195302:setDefaultUnboundKeyAction
#@-node:ekr.20050920085536.1: Birth (keyHandler)
#@-node:ekr.20060203112912.1:Initing
#@+node:ekr.20060514170725:4.4.1 projects
#@+node:ekr.20060514170854:Fixed bugs
#@+node:ekr.20060514164817:Fixed crasher in searchbox plugin
0.7 EKR: Fixed crasher in Leo 4.4 by initing self.p in Quickfind ctor.
#@nonl
#@+node:ekr.20060514164817.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3729858
By: ejoy

Hi,
  I got the following error message when trying search using the searchbox plugin
with 4.4 final:

Error: 4
AttributeError Exception in Tk callback
  Function: <function callit at 0x013011F0> (type: <type 'function'>)
  Args: ()
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line
1752, in __call__
    None
  File "C:\Python24\lib\lib-tk\Tkinter.py", line 456, in callit
    func(*args)
  File "C:\Program Files\Leo\plugins\searchbox.py", line 173, in doSearch
    c.findNext()
  File "C:\Program Files\Leo\src\leoCommands.py", line 2812, in findNext
    c.frame.findPanel.findNextCommand(c)
  File "C:\Program Files\Leo\src\leoFind.py", line 311, in findNextCommand
    self.findNext()
  File "C:\Program Files\Leo\src\leoFind.py", line 661, in findNext
    data = self.save()
  File "C:\Program Files\Leo\src\leoFind.py", line 1020, in save
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
AttributeError: 'NoneType' object has no attribute 'edit_widget'

Hope this will be fixed soon.
Cheers,
ejoy
#@-node:ekr.20060514164817.1:Report
#@-node:ekr.20060514164817:Fixed crasher in searchbox plugin
#@+node:ekr.20060529083409:Fixed bug in toGuiIndex
#@+node:ekr.20060528172956:toGuiIndex & toPythonIndex
def toGuiIndex (self,s,w,index):
    
    '''Convert a python index in string s into a Tk index in Tk.Text widget w.'''
    
    # A subtle point: s typically does not have Tk's trailing newline, so add it.

    row,col = g.convertPythonIndexToRowCol (s+'\n',index)
    index = w.index('%s.%s' % (row+1,col))
    return index
    
def toPythonIndex (self,s,w,index):
    
    '''Convert a Tk index in Tk.Text widget w into a python index in string s.'''
    
    index = w.index(index)
    row, col = index.split('.') ; row, col = int(row), int(col)
    index = g.convertRowColToPythonIndex (s,row-1,col)
    return index
#@nonl
#@-node:ekr.20060528172956:toGuiIndex & toPythonIndex
#@-node:ekr.20060529083409:Fixed bug in toGuiIndex
#@+node:ekr.20060522101202:Fixed problems reported by Check bindings script.
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3737879

The "Check Bindings" button gave the following report.

-------------------------------------------------
No bindings is missing run-unit-test                       = None
Undefined command name: add-spaces-to-lines
Undefined command name: clean-line
Undefined command name: remove-spaces-from-lines
Undefined command name: remove-tab-from-lines
Undefined command name: run-unit-test
Check Bindings done
-------------------------------------------------
#@nonl
#@-node:ekr.20060522101202:Fixed problems reported by Check bindings script.
#@-node:ekr.20060514170854:Fixed bugs
#@+node:ekr.20060522103446:New features
#@+node:ekr.20060512101324:(Support for new colorizer)
#@+node:ekr.20060512101324.1:What I did
@nocolor

** Removed calls to update_idletasks in node selection logic.

update_idletasks interfere with the logic in the new colorizer that re-queues
the colorizer. What happens is that update_idletasks causes the queued
colorizerOneChunk method to be executed immediately, without looking to see if
any events are pending!  This can not, I think, be called a Tk bug.

- (in the colorizer) Used after instead of after_idle.

This can, I think, be called a Tk bug. It seems to me that any function queued
with after-idle should only be called a) as the result of update_idletasks (or
update) or when *no* events are pending.

In any event, the contrast between the slow colorizing code and scite's fast colorizer is breathtaking.
#@nonl
#@-node:ekr.20060512101324.1:What I did
#@+node:ekr.20060129052538.1:Master event handlers (keyHandler)
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    # g.trace(stroke,g.callers())
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting

    val = self.masterKeyHandlerHelper(event,stroke,trace)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    if trace: g.trace('done:',repr(val))
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event,stroke,trace):
    
    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    << handle per-pane bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace('keysym',repr(event.keysym or ''),'state',state)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
    return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20060129052538.2:masterClickHandler
def masterClickHandler (self,event,func=None):

    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = c.config.getBool('trace_masterClickHandler') and not g.app.unitTesting

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1
        
    # A click outside the minibuffer terminates any state.
    if k.inState() and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        i = w.index('@%s,%s' % (event.x,event.y))
        g.app.gui.setTextSelection(w,i,i,insert=i)
        c.editCommands.setMoveCol(i)
        c.frame.updateStatusLine()
    elif wname.startswith('mini'):
        x = w.index('@%s,%s' % (event.x,event.y))
        i, j = k.getEditableTextRange()
        xcol = int(x.split('.')[1])
        icol = int(i.split('.')[1])
        jcol = int(j.split('.')[1])
        # g.trace(xcol,icol,jcol,icol <= xcol <= jcol)
        if icol <= xcol <= jcol:
            g.app.gui.setTextSelection(w,x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        if trace: g.trace('val:',val)
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
#@nonl
#@-node:ekr.20060129052538.2:masterClickHandler
#@+node:ekr.20060131084938:masterDoubleClickHandler
def masterDoubleClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        i = w.index("@%d,%d" % (event.x,event.y))
        g.app.gui.setTextSelection(w,i+' wordstart',i+' wordend')
        return 'break'
#@nonl
#@-node:ekr.20060131084938:masterDoubleClickHandler
#@+node:ekr.20060128090219:masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    # g.trace(c.widget_name(w))
    
    if stroke: # New in 4.4a6:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
#@nonl
#@-node:ekr.20060128090219:masterMenuHandler
#@-node:ekr.20060129052538.1:Master event handlers (keyHandler)
#@+node:ekr.20040803072955.128:tree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('does not exist',p.headString())
        return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                else:
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.after(100,scrollCallback)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

c.frame.body.selectMainEditor() # New in Leo 4.4.1.

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.2954:c.redraw and c.redraw_now
def redraw (self):
    c = self
    c.beginUpdate()
    c.endUpdate()

def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    if 0: # Interferes with new colorizer.
        c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
force_redraw = redraw_now
#@nonl
#@-node:ekr.20031218072017.2954:c.redraw and c.redraw_now
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(s,g.callers())
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    ##### t.update_idletasks() # interferes with coloring.
#@nonl
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@-node:ekr.20060512101324:(Support for new colorizer)
#@+node:ekr.20060519003651.1:Added debug command
#@+node:ekr.20060519003651:debug
def debug (self,event=None,target = None):
    
    '''Start an external debugger in another process.'''

    c = self.c ; p = c.currentPosition()
    pythonDir = g.os_path_dirname(sys.executable)
    
    << find a debugger or return >>
    << find the target file >>
    
    if target:
        args = [sys.executable, debugger, '-t', target]
    else:
        args = [sys.executable, debugger, '-t']
    
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, sys.executable, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
#@nonl
#@+node:ekr.20060521140213:<< find a debugger or return >>
debuggers = (
    c.config.getString('debugger_path'),
    g.os_path_join(pythonDir,'scripts','_winpdb.py'),
)

for debugger in debuggers:
    if debugger:
        debugger = g.os_path_abspath(debugger)
        if g.os_path_exists(debugger):
            break
        else:
            g.es('Debugger does not exist: %s' % (debugger),color='blue')
else:
    return g.es('No debugger found.')
#@nonl
#@-node:ekr.20060521140213:<< find a debugger or return >>
#@+node:ekr.20060521140213.1:<< find the target file >>
targets = (
    target,
    c.config.getString('debugger_force_taget'),
    p.copy().anyAtFileNodeName(),
    c.config.getString('debugger_default_target'),
)

for target in targets:
    if target:
        target = g.os_path_abspath(target)
        if g.os_path_exists(target):
            break
        else:
            g.es('Debug target does not exist: %s' % (target),color='blue')
#@nonl
#@-node:ekr.20060521140213.1:<< find the target file >>
#@-node:ekr.20060519003651:debug
#@-node:ekr.20060519003651.1:Added debug command
#@+node:ekr.20060522083716:Run Idle in a separate process
#@+node:ekr.20031218072017.2932:openPythonWindow (Dave Hein)
def openPythonWindow (self,event=None):
    
    '''Open Python's Idle debugger in a separate process.'''
    
    if 1:
        << open idle in a separate process >>
    else:
        if sys.platform == "linux2":
            << open idle in Linux >>
        else:
            << open idle in Windows >>
#@nonl
#@+node:ekr.20060522102610:<< open idle in a separate process >>
pythonDir = g.os_path_dirname(sys.executable)
idle = g.os_path_join(pythonDir,'Lib','idlelib','idle.py')
args = [sys.executable, idle ]

if 1: # Use present environment.
    os.spawnv(os.P_NOWAIT, sys.executable, args)
else: # Use a pristine environment.
    os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
#@-node:ekr.20060522102610:<< open idle in a separate process >>
#@+node:ekr.20031218072017.2933:<< open idle in Linux >>
# 09-SEP-2002 DHEIN: Open Python window under linux

try:
    pathToLeo = g.os_path_join(g.app.loadDir,"leo.py")
    sys.argv = [pathToLeo]
    from idlelib import idle
    if g.app.idle_imported:
        reload(idle)
    g.app.idle_imported = True
except:
    try:
        g.es("idlelib could not be imported.")
        g.es("Probably IDLE is not installed.")
        g.es("Run Tools/idle/setup.py to build idlelib.")
        g.es("Can not import idle")
        g.es_exception() # This can fail!!
    except: pass
#@-node:ekr.20031218072017.2933:<< open idle in Linux >>
#@+node:ekr.20031218072017.2934:<< open idle in Windows >>
# Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo"] # ,"-t","Leo"]

ok = False
if g.CheckVersion(sys.version,"2.3"):
    << Try to open idle in Python 2.3 systems >>
else:
    << Try to open idle in Python 2.2 systems >>

if not ok:
    g.es("Can not import idle")
    if idle_dir and idle_dir not in sys.path:
        g.es("Please add '%s' to sys.path" % idle_dir)
#@nonl
#@+node:ekr.20031218072017.2936:<< Try to open idle in Python 2.3 systems >>
try:
    idle_dir = None
    
    import idlelib.PyShell

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    idlelib.PyShell.main()
    ok = True

except:
    ok = False
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2936:<< Try to open idle in Python 2.3 systems >>
#@+node:ekr.20031218072017.2935:<< Try to open idle in Python 2.2 systems>>
try:
    executable_dir = g.os_path_dirname(sys.executable)
    idle_dir = g.os_path_join(executable_dir,"Tools","idle")

    # 1/29/04: sys.path doesn't handle unicode in 2.2.
    idle_dir = str(idle_dir) # May throw an exception.

    # 1/29/04: must add idle_dir to sys.path even when using importFromPath.
    if idle_dir not in sys.path:
        sys.path.insert(0,idle_dir)

    if 1:
        import PyShell
    else: # Works, but is not better than import.
        PyShell = g.importFromPath("PyShell",idle_dir)

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    if 1: # Mostly works, but causes problems when opening other .leo files.
        PyShell.main()
    else: # Doesn't work: destroys all of Leo when Idle closes.
        self.leoPyShellMain()
    ok = True
except ImportError:
    ok = False
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2935:<< Try to open idle in Python 2.2 systems>>
#@-node:ekr.20031218072017.2934:<< open idle in Windows >>
#@+node:ekr.20031218072017.2937:leoPyShellMain
@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work well.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

if 0:

    def leoPyShellMain(self):
        
        import PyShell
        root = g.app.root
        PyShell.fixwordbreaks(root)
        flist = PyShell.PyShellFileList(root)
        shell = PyShell.PyShell(flist)
        flist.pyshell = shell
        shell.begin()
#@nonl
#@-node:ekr.20031218072017.2937:leoPyShellMain
#@-node:ekr.20031218072017.2932:openPythonWindow (Dave Hein)
#@-node:ekr.20060522083716:Run Idle in a separate process
#@+node:ekr.20060522082833:Added Debug button to scripting plugin
#@+node:ekr.20060519003651:debug
def debug (self,event=None,target = None):
    
    '''Start an external debugger in another process.'''

    c = self.c ; p = c.currentPosition()
    pythonDir = g.os_path_dirname(sys.executable)
    
    << find a debugger or return >>
    << find the target file >>
    
    if target:
        args = [sys.executable, debugger, '-t', target]
    else:
        args = [sys.executable, debugger, '-t']
    
    if 1: # Use present environment.
        os.spawnv(os.P_NOWAIT, sys.executable, args)
    else: # Use a pristine environment.
        os.spawnve(os.P_NOWAIT, sys.executable, args, os.environ)
#@nonl
#@+node:ekr.20060521140213:<< find a debugger or return >>
debuggers = (
    c.config.getString('debugger_path'),
    g.os_path_join(pythonDir,'scripts','_winpdb.py'),
)

for debugger in debuggers:
    if debugger:
        debugger = g.os_path_abspath(debugger)
        if g.os_path_exists(debugger):
            break
        else:
            g.es('Debugger does not exist: %s' % (debugger),color='blue')
else:
    return g.es('No debugger found.')
#@nonl
#@-node:ekr.20060521140213:<< find a debugger or return >>
#@+node:ekr.20060521140213.1:<< find the target file >>
targets = (
    target,
    c.config.getString('debugger_force_taget'),
    p.copy().anyAtFileNodeName(),
    c.config.getString('debugger_default_target'),
)

for target in targets:
    if target:
        target = g.os_path_abspath(target)
        if g.os_path_exists(target):
            break
        else:
            g.es('Debug target does not exist: %s' % (target),color='blue')
#@nonl
#@-node:ekr.20060521140213.1:<< find the target file >>
#@-node:ekr.20060519003651:debug
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # g.trace(script)
                exec script in d
                if not script1 and not silent:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.exists and c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True,useSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels,
                useSentinels=useSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20050506084734:writeFromString
# This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True,useSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline, but don't change the focus!

    at.initWriteIvars(root,"<string-file>",
        nosentinels=not useSentinels,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=not useSentinels,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput
#@nonl
#@-node:ekr.20050506084734:writeFromString
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    << init ivars for writing >>
    
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)
    
    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)
    
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'
    
    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""
    
    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20060522082833:Added Debug button to scripting plugin
#@+node:ekr.20060224104109:Improved searches
@nocolor

What I did:
    
- Used Python search code instead of Tkinter search.
- Allow \1, \2, etc. replacements in re searches.
- Allow \n and \t in plain searches.
- The shortcut for the replace-string command now changes from the find command to the replace command.


@color
#@nonl
#@+node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20060528172956:toGuiIndex & toPythonIndex
def toGuiIndex (self,s,w,index):
    
    '''Convert a python index in string s into a Tk index in Tk.Text widget w.'''
    
    # A subtle point: s typically does not have Tk's trailing newline, so add it.

    row,col = g.convertPythonIndexToRowCol (s+'\n',index)
    index = w.index('%s.%s' % (row+1,col))
    return index
    
def toPythonIndex (self,s,w,index):
    
    '''Convert a Tk index in Tk.Text widget w into a python index in string s.'''
    
    index = w.index(index)
    row, col = index.split('.') ; row, col = int(row), int(col)
    index = g.convertRowColToPythonIndex (s,row-1,col)
    return index
#@nonl
#@-node:ekr.20060528172956:toGuiIndex & toPythonIndex
#@+node:ekr.20031218072017.4075:firstIndex
def firstIndex (self):

    return "1.0"
#@nonl
#@-node:ekr.20031218072017.4075:firstIndex
#@+node:ekr.20031218072017.4076:lastIndex
def lastIndex (self):

    return "end"
#@nonl
#@-node:ekr.20031218072017.4076:lastIndex
#@+node:ekr.20031218072017.4077:moveIndexBackward
def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
#@-node:ekr.20031218072017.4077:moveIndexBackward
#@+node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
#@nonl
#@-node:ekr.20031218072017.4078:moveIndexForward & moveIndexToNextLine
#@+node:ekr.20031218072017.4079:compareIndices
def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False
#@nonl
#@-node:ekr.20031218072017.4079:compareIndices
#@+node:ekr.20031218072017.4080:getindex
def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))
#@nonl
#@-node:ekr.20031218072017.4080:getindex
#@-node:ekr.20031218072017.4074:Indices (Tk)
#@+node:ekr.20050315073003: Index utilities...
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl > -1
            return row,i-prevNl-1
#@nonl
#@+node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i < total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total
#@nonl
#@-node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
#@+node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'

    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = g.convertPythonIndexToRowCol(s,i)
        rowCol_2 = g.bruteForceConvertPythonIndexToRowCol(s,i)
        if g.app.unitTesting:
            assert i == len(s) or rowCol_1 == rowCol_2
        else:
            print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
            print rowCol_1,rowCol_2
#@nonl
#@-node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex & test
def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row >= len(lines):
        return len(s)
        
    col = min(col, len(lines[row]))

    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col
#@nonl
#@+node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = g.convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1
#@nonl
#@-node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex & test
#@-node:ekr.20050315073003: Index utilities...
#@+node:ekr.20031218072017.3070:changeSelection
# Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text
    
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    change_text = change_text.replace('\\n','\n').replace('\\t','\t')
                
    gui.replaceSelectionRangeWithText(t,          start,end,change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
        if self.mark_changes:
            p.setMarked()
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
#@+node:ekr.20060526201951:makeRegexSubs
def makeRegexSubs(self,s,groups):
    
    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''
    
    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j < n:
        k = s.find('\\',j)
        if k == -1 or k + 1 >= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn < len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
#@nonl
#@-node:ekr.20060526201951:makeRegexSubs
#@-node:ekr.20031218072017.3070:changeSelection
#@+node:ekr.20051023094009:Search classes
#@+node:ekr.20060123125256:class minibufferFind (the findHandler)
class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
#@nonl
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []
    
    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
#@nonl
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124140114: Options
#@+node:ekr.20060124123133:setFindScope
def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
#@nonl
#@-node:ekr.20060124123133:setFindScope
#@+node:ekr.20060124122844:setOption
def setOption (self, ivar, val):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124122844:setOption
#@+node:ekr.20060125082510:getOption
def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        verbose and g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@nonl
#@-node:ekr.20060125082510:getOption
#@+node:ekr.20060125074939:showFindOptions
def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
#@nonl
#@-node:ekr.20060125074939:showFindOptions
#@+node:ekr.20060124135401:toggleOption
def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@nonl
#@-node:ekr.20060124135401:toggleOption
#@+node:ekr.20060205105950:setupChangePattern
def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060205105950:setupChangePattern
#@+node:ekr.20060125091234:setupSearchPattern
def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()
#@nonl
#@-node:ekr.20060125091234:setupSearchPattern
#@-node:ekr.20060124140114: Options
#@+node:ekr.20060210180352:addChangeStringToLabel
def addChangeStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.change_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()
    
    s = t.get('1.0','end')

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210180352:addChangeStringToLabel
#@+node:ekr.20060210164421:addFindStringToLabel
def addFindStringToLabel (self,protect=True):
    
    c = self.c ; k = c.k ; h = self.finder ; t = h.find_ctrl
    
    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = t.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
#@-node:ekr.20060210164421:addFindStringToLabel
#@+node:ekr.20060128080201:cloneFindAll
def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
#@nonl
#@-node:ekr.20060128080201:cloneFindAll
#@+node:ekr.20060204120158:findAgain
def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        
#@nonl
#@-node:ekr.20060204120158:findAgain
#@+node:ekr.20060209064140:findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
#@nonl
#@-node:ekr.20060209064140:findAll
#@+node:ekr.20060205105950.1:generalChangeHelper
def generalChangeHelper (self,find_pattern,change_pattern):
    
    # g.trace(repr(change_pattern))
    
    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060205105950.1:generalChangeHelper
#@+node:ekr.20060124181213.4:generalSearchHelper
def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):
    
    c = self.c
    
    self.setupSearchPattern(pattern)
    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if findAll:
         self.finder.findAllCommand()
    elif cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
#@nonl
#@-node:ekr.20060124181213.4:generalSearchHelper
#@+node:ekr.20060210174441:lastStateHelper
def lastStateHelper (self):
    
    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
#@nonl
#@-node:ekr.20060210174441:lastStateHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@-node:ekr.20050920084036.113:replaceString
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060124134356:setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@nonl
#@-node:ekr.20060124134356:setupArgs
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)
    
    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@nonl
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20060224171851:updateChange/FindList
def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)
        
def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
#@nonl
#@-node:ekr.20060224171851:updateChange/FindList
#@+node:ekr.20060124140224.2:wordSearchBackward/Forward
def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.2:wordSearchBackward/Forward
#@-node:ekr.20060123125256:class minibufferFind (the findHandler)
#@+node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others
#@nonl
#@+node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.11:__init__
def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    << create the tkinter intVars >>
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20051020120306.12:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20051020120306.12:<< create the tkinter intVars >>
#@-node:ekr.20051020120306.11:__init__
#@+node:ekr.20051023181449:createBindings (findTab)
def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)
        
    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'
        
    if 0: # No longer needed.
        def findTabClickCallback(event,self=self):
            c = self.c ; k = c.k ; w = event.widget
            k.keyboardQuit(event)
            w and c.widgetWantsFocusNow(w)
            return k.masterClickHandler(event)

    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       resetWrapCallback),
        ('<Return>',    findButtonBindingCallback),
        ("<Escape>",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)
#@nonl
#@-node:ekr.20051023181449:createBindings (findTab)
#@+node:ekr.20051020120306.13:createFrame (findTab)
def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>
    
    if  self.optionsOnly:
        buttons = []
    else:
        << Create two columns of buttons >>
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)
#@nonl
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
#@nonl
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")
#@nonl
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&t Change",self.dict["script_change"]),
    ("Whole &Word", self.dict["whole_word"]),
    ("&Ignore Case",self.dict["ignore_case"]),
    ("Wrap &Around",self.dict["wrap"]),
    ("&Reverse",    self.dict["reverse"]),
    ('Rege&xp',     self.dict['pattern_match']),
    ("Mark &Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
]

checkLists[1] = [
    ("Search &Headline", self.dict["search_headline"]),
    ("Search &Body",     self.dict["search_body"]),
    ("Mark &Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("<Button-1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@nonl
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:createFrame (findTab)
#@+node:ekr.20051020120306.19:find.init
def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20051020120306.20:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20051020120306.20:<< set find/change widgets >>
#@+node:ekr.20051020120306.21:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")
#@nonl
#@-node:ekr.20051020120306.21:<< set radio buttons from ivars >>
#@-node:ekr.20051020120306.19:find.init
#@-node:ekr.20051020120306.10:Birth & death
#@+node:ekr.20051020120306.22:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20051020120306.22:find.update_ivars
#@+node:ekr.20060221074900:Callbacks
#@+node:ekr.20060221074900.1:findButtonCallback
def findButtonCallback(self,event=None):
    
    self.findButton()
    return 'break'
#@nonl
#@-node:ekr.20060221074900.1:findButtonCallback
#@+node:ekr.20051020120306.25:hideTab
def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20051020120306.25:hideTab
#@-node:ekr.20060221074900:Callbacks
#@+node:ekr.20051024192602: Top level
#@+node:ekr.20060209064832:findAllCommand
def findAllCommand (self,event=None):

    self.setup_command()
    self.findAll()
#@nonl
#@-node:ekr.20060209064832:findAllCommand
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):
    
    s = g.app.gui.getAllText(self.find_ctrl)
    
    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@nonl
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20060128075225:cloneFindAllCommand
def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
#@-node:ekr.20060128075225:cloneFindAllCommand
#@+node:ekr.20051024192642.2:findNext/PrefCommand
def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse
#@nonl
#@-node:ekr.20051024192642.2:findNext/PrefCommand
#@+node:ekr.20051024192642.3:change/ThenFindCommand
def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()
#@nonl
#@-node:ekr.20051024192642.3:change/ThenFindCommand
#@-node:ekr.20051024192602: Top level
#@+node:ekr.20051020120306.26:bringToFront
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    c.widgetWantsFocus(t)
    g.app.gui.selectAllText(t)
    c.widgetWantsFocus(t)
#@nonl
#@-node:ekr.20051020120306.26:bringToFront
#@+node:ekr.20051020120306.27:selectAllFindText
def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"
#@nonl
#@-node:ekr.20051020120306.27:selectAllFindText
#@+node:ekr.20051020120306.28:Tkinter wrappers
def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t
#@nonl
#@-node:ekr.20051020120306.28:Tkinter wrappers
#@+node:ekr.20051020120306.1:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20051020120306.2:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20051020120306.3:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20051020120306.2:__init__
#@+node:ekr.20051020120306.4:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@nonl
#@-node:ekr.20051020120306.4:bindHotKey
#@+node:ekr.20051020120306.5:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20051020120306.5:buttonCallback
#@-node:ekr.20051020120306.1:class underlinedTkButton
#@-node:ekr.20051020120306.6:class findTab (leoFind.leoFind)
#@+node:ekr.20050920084036.257:class searchCommandsClass
class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others
#@nonl
#@+node:ekr.20050920084036.258: ctor
def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.stack = [] # A stack of previous matches.
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None
#@nonl
#@-node:ekr.20050920084036.258: ctor
#@+node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        'find-tab-find-all':                    self.findAll,
        
        # Thin wrappers on Find tab
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
#@nonl
#@-node:ekr.20050920084036.259:getPublicCommands (searchCommandsClass)
#@+node:ekr.20060123131421:Top-level methods
#@+node:ekr.20051020120306:openFindTab
def openFindTab (self,event=None,show=True):
    
    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
#@nonl
#@-node:ekr.20051020120306:openFindTab
#@+node:ekr.20051022212004:Find Tab commands
# Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()
        
def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
#@nonl
#@-node:ekr.20051022212004:Find Tab commands
#@+node:ekr.20060124115801:getHandler
def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
#@nonl
#@-node:ekr.20060124115801:getHandler
#@+node:ekr.20060123115459:Find options wrappers
def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')
    
def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')
    
def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
#@nonl
#@-node:ekr.20060123115459:Find options wrappers
#@+node:ekr.20060124093828:Find wrappers
def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type <Return> to end the search string. The
    command will then prompt for the replacement string. Typing a second
    <Return> key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the <Return> key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060124093828:Find wrappers
#@+node:ekr.20060204120158.2:findAgain
def findAgain (self,event):

    '''The find-again command is the same as the find-tab-find command
    if the search pattern in the Find tab is not '<find pattern here>'
    Otherwise, the find-again is the same as the search-with-present-options command.'''
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
#@nonl
#@-node:ekr.20060204120158.2:findAgain
#@-node:ekr.20060123131421:Top-level methods
#@+node:ekr.20050920084036.261:incremental search...
def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,forward=False,regexp=True)
#@nonl
#@+node:ekr.20050920084036.262:startIncremental
def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k ; w = self.w
    
    self.forward = forward
    self.regexp = regexp
    
    old_i = w.index('insert')
    old_p = c.currentPosition()
    self.stack = [g.Bunch(insert=old_i,p=old_p)]

    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
#@nonl
#@-node:ekr.20050920084036.262:startIncremental
#@+node:ekr.20060420144640:iSearchBackspace
def iSearchBackspace (self):
    
    c = self.c ; k = self.k ; w = self.w
    
    b = self.stack.pop()
    g.trace(b.insert)

    c.selectPosition(b.p)
    w.mark_set('insert',b.insert)
    w.see('insert')
    w.update_idletasks()
    
    if self.stack:
        self.scolorizer(event=None,pattern=b.pattern)
    else:
        self.stack.append(b)
        w.tag_delete('color','color1')
#@nonl
#@-node:ekr.20060420144640:iSearchBackspace
#@+node:ekr.20050920084036.264:iSearchStateHandler
# Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '<Control-s>':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '<Control-r>':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
    elif keysym == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif ch:
        k.updateLabel(event)
        self.iSearchHelper(event)
        self.scolorizer(event)
#@nonl
#@-node:ekr.20050920084036.264:iSearchStateHandler
#@+node:ekr.20050920084036.265:scolorizer
def scolorizer (self,event,pattern=None):
    
    '''Colorizer for incremental searches.'''

    k = self.k ; w = self.w
    s = pattern or k.getLabel(ignorePrompt=True)
    # g.trace(repr(s))
    w.tag_delete('color','color1')
    if not s: return
    ind = '1.0'
    index = w.index('insert')
    index2 = w.index('%s+%dc' % (index,len(s)))
    # g.trace(index,index2)
    # Colorize in the forward direction, regardless of the kind of search.
    while ind:
        try:
            ind = w.search(s,ind,stopindex='end',regexp=self.regexp)
        except: break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(s))
            # g.trace(ind)
            if ind in (index,index2):
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')
#@nonl
#@-node:ekr.20050920084036.265:scolorizer
#@+node:ekr.20050920084036.263:iSearchHelper
def iSearchHelper (self,event):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    c = self.c ; k = self.k ; w = self.w
    self.searchString = pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    stopindex = g.choose(self.forward,'end','1.0')
    startindex = g.choose(self.forward,'1.0','end')
    p1 = c.currentPosition() ; p = p1.copy() ; old_p = p.copy()
    old_ins = w.index('insert') # This must *not* be changed in the loop.
    w.mark_set('insert',startindex)
    while 1:
        try:
            i = w.search(pattern,old_ins,backwards=not self.forward,stopindex=stopindex,regexp=self.regexp)
            # Don't call endSearch here.  We'll do that when the user hits return.
            g.trace(repr(i))
            if not i.isspace():
                w.mark_set('insert',i)
                # if self.forward:
                    # w.mark_set('insert',i)
                # else:
                    # w.mark_set('insert',i+'-%dc'%(len(pattern)))
                w.see('insert')
                self.stack.append(g.Bunch(insert=old_ins,p=old_p,pattern=pattern[:-1]))
                # g.trace('found',old_ins,i)
                return   
        except: pass # g.es_exception()
        # old_p = p.copy()
        if self.forward: p.moveToThreadNext()
        else:            p.moveToThreadBack()
        if not p: break
        g.trace('searching',p.headString())
        c.selectPosition(p)
        w.mark_set('insert','1.0')
        w.update_idletasks()
        # if not self.forward:
            # w.mark_set('insert','end')
    c.selectPosition(p1)
#@nonl
#@-node:ekr.20050920084036.263:iSearchHelper
#@+node:ekr.20060203072636:endSearch
def endSearch (self,i,j):

    w = self.w
    w.tag_delete('color','color1')
    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)
#@nonl
#@-node:ekr.20060203072636:endSearch
#@-node:ekr.20050920084036.261:incremental search...
#@-node:ekr.20050920084036.257:class searchCommandsClass
#@-node:ekr.20051023094009:Search classes
#@+node:ekr.20060527065935:Switching finds to changes
#@+node:ekr.20060527065935.1:From minibuffer find handler
#@+node:ekr.20060123125317.2: ctor (minibufferFind)
def __init__(self,c,finder):

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []
    
    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    self.replaceStringShortcut = s
#@nonl
#@-node:ekr.20060123125317.2: ctor (minibufferFind)
#@+node:ekr.20060124134356:setupArgs
def setupArgs (self,forward=False,regexp=False,word=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
#@nonl
#@-node:ekr.20060124134356:setupArgs
#@+node:ekr.20060124140224.1:seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.1:seachForward/Backward
#@+node:ekr.20060124140224.3:reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)
    
    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060124140224.3:reSearchBackward/Forward
#@+node:ekr.20060125093807:searchWithPresentOptions
def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
#@nonl
#@-node:ekr.20060125093807:searchWithPresentOptions
#@+node:ekr.20060210173041:stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=[]):

    k = self.k
    self.w = event and event.widget
    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)
    
    # g.trace(escapes,g.callers())
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
#@nonl
#@-node:ekr.20060210173041:stateZeroHelper
#@+node:ekr.20050920084036.113:replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
#@-node:ekr.20050920084036.113:replaceString
#@-node:ekr.20060527065935.1:From minibuffer find handler
#@+node:ekr.20050920085536.62:getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = 0 or c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return' or k.oneCharacterArg or stroke in k.getArgEscapes:
        if stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
#@nonl
#@+node:ekr.20050928092516:<< init altX vars >>
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
#@nonl
#@-node:ekr.20050928092516:<< init altX vars >>
#@-node:ekr.20050920085536.62:getArg
#@+node:ekr.20060127183752:masterKeyHandler & helper
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''This is the handler for almost all key bindings.'''
    
    # g.trace(stroke,g.callers())
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting

    val = self.masterKeyHandlerHelper(event,stroke,trace)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    if trace: g.trace('done:',repr(val))
    return val
#@nonl
#@+node:ekr.20060205221734:masterKeyHandlerHelper
def masterKeyHandlerHelper (self,event,stroke,trace):
    
    << define vars >>

    if keysym in special_keys:
        return None

    << do key traces >>

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        << handle mode bindings >>

    << handle per-pane bindings >>
#@+node:ekr.20060321105403:<< define vars >>
k = self ; c = k.c
w = event and event.widget
w_name = c.widget_name(w)
keysym = event.keysym or ''
state = k.state.kind
special_keys = (
    'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
    'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R')
#@nonl
#@-node:ekr.20060321105403:<< define vars >>
#@+node:ekr.20060321105403.1:<< do key traces >>
self.master_key_count += 1

if trace:
    if (self.master_key_count % 100) == 0:
        g.printGcSummary(trace=True)
    g.trace('keysym',repr(event.keysym or ''),'state',state)
#@nonl
#@-node:ekr.20060321105403.1:<< do key traces >>
#@+node:ekr.20060321105403.2:<< handle mode bindings >>
# First, honor minibuffer bindings for all except user modes.
if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function')
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'
        
# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler')
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
        elif not k.handleMiniBindings(event,state,stroke):
            if trace: g.trace('calling modeHelp')
            k.modeHelp(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
    return 'break'
#@nonl
#@-node:ekr.20060321105403.2:<< handle mode bindings >>
#@+node:ekr.20060321105403.3:<< handle per-pane bindings >>
for key,name in (
    # Order here is similar to bindtags order.
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None), ('all',None),
):
    if (
        name and w_name.startswith(name) or
        key == 'text' and g.app.gui.isTextWidget(w) or
        key == 'all'
    ):
        d = k.masterBindingsDict.get(key)
        # g.trace(key,name,d and len(d.keys()))
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                return k.masterCommand(event,b.func,b.stroke,b.commandName)

if k.ignore_unbound_non_ascii_keys and len(event.char) > 1:
    # (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)):
    if trace: g.trace('ignoring unbound non-ascii key')
    return 'break'
else:
    if trace: g.trace(repr(stroke),'no func')
    return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
#@nonl
#@-node:ekr.20060321105403.3:<< handle per-pane bindings >>
#@-node:ekr.20060205221734:masterKeyHandlerHelper
#@+node:ekr.20060309065445:handleMiniBindings
def handleMiniBindings (self,event,state,stroke):
    
    k = self ; c = k.c
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    
    if not state.startswith('auto-'):
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return True
        
    return False
#@nonl
#@-node:ekr.20060309065445:handleMiniBindings
#@-node:ekr.20060127183752:masterKeyHandler & helper
#@+node:ekr.20060128081317:shortcutFromSetting
def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip().lstrip('<').rstrip('>')
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>
    # g.trace(setting,shortcut)
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting
#@nonl
#@+node:ekr.20060201065809:<< define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
#@nonl
#@-node:ekr.20060201065809:<< define cmd, ctrl, alt, shift >>
#@+node:ekr.20060215104239:<< swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
#@nonl
#@-node:ekr.20060215104239:<< swap cmd and ctrl keys >>
#@+node:ekr.20060128103640.1:<< convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
#@nonl
#@-node:ekr.20060128103640.1:<< convert minus signs to plus signs >>
#@+node:ekr.20060128103640.2:<< compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    # g.trace(last,last2)
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)
#@nonl
#@-node:ekr.20060128103640.2:<< compute the last field >>
#@+node:ekr.20060128103640.4:<< compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True, last),
)
    
# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val,g.app.tkEncoding) for flag,val in table if flag])
#@nonl
#@-node:ekr.20060128103640.4:<< compute shortcut >>
#@-node:ekr.20060128081317:shortcutFromSetting
#@-node:ekr.20060527065935:Switching finds to changes
#@+node:ekr.20031218072017.3077:search & helpers
def search (self):

    """Search s_ctrl for self.find_text under the control of the
    whole_word, ignore_case, and pattern_match ivars.
    
    Returns (pos, newpos) or (None,None)."""

    c = self.c ; p = self.p ; w = self.s_ctrl ; gui = g.app.gui
    index = gui.getInsertPoint(w)
    s = gui.getAllText(w)
    index = gui.toPythonIndex(s,w,index)
    stopindex = g.choose(self.reverse,0,len(s))
    while 1:
        pos,newpos = self.searchHelper(s,index,stopindex,self.find_text,
            backwards=self.reverse,nocase=self.ignore_case,
            regexp=self.pattern_match,word=self.whole_word)
        if pos == -1: return None,None
        pos    = gui.toGuiIndex(s,w,pos)
        newpos = gui.toGuiIndex(s,w,newpos)
        << fail if we are passed the wrap point >>
        gui.setTextSelection(w,pos,newpos,insert=newpos)
        return pos, newpos
#@nonl
#@+node:ekr.20060526140328:<< fail if we are passed the wrap point >>
if self.wrapping and self.wrapPos and self.wrapPosition and self.p == self.wrapPosition:

    if self.reverse and gui.compareIndices(w,pos, "<", self.wrapPos):
        # g.trace("wrap done")
        return None, None

    if not self.reverse and gui.compareIndices(w,newpos, ">", self.wrapPos):
        return None, None
#@nonl
#@-node:ekr.20060526140328:<< fail if we are passed the wrap point >>
#@+node:ekr.20060526081931:Search helpers...
def searchHelper (self,s,i,j,pattern,backwards,nocase,regexp,word):
    
    if backwards: i,j = j,i
        
    # g.trace(backwards,i,j,repr(s[i:i+20]))

    if not s[i:j] or not pattern:
        # g.trace('empty',i,j)
        return -1,-1
        
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,backwards,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,backwards,nocase,word)

    return pos,newpos
#@+node:ekr.20060526092203:regexHelper
def regexHelper (self,s,i,j,pattern,backwards,nocase):
   
    try:
        flags = re.MULTILINE
        if nocase: flags |= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        g.es('Invalid regular expression: %s' % (pattern),color='blue')
        return -1, -1
        
    if backwards: # Scan to the last match.
        last_mo = None
        while 1:
            mo = re_obj.search(s,i,j)
            if mo is None: break
            i = mo.end()
            last_mo = mo
        self.match_obj = mo = last_mo
    else:
        self.match_obj = mo = re_obj.search(s,i,j)
        
    if mo is None:
        return -1, -1
    else:
        k  = mo.start()
        k2 = mo.end()
        if 0:
            g.trace('i: %d, j: %d k: %d, k2: %d, s[k:k2]: %s, len(s): %d, s[-1]: %s,' % (
                i,j,k,k2,repr(s[k:k2]),len(s),repr(s[-1])))
        # g.trace('groups',mo.groups())
        return k, k2
#@nonl
#@-node:ekr.20060526092203:regexHelper
#@+node:ekr.20060526140744:backwardsHelper
def backwardsHelper (self,s,i,j,pattern,backwards,nocase,word):

    # g.trace(repr(s[i-20: i]))

    if nocase:
        s = s.lower() ; pattern.lower()

    if word:
        n = len(pattern)
        while 1:
            k = s.rfind(pattern,i,j)
            # g.trace(i,j,k)
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return max(0,k-n+1),k+1, 
            else:
                j = max(0,k-n)
    else:
        k = s.rfind(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return max(0,k-n+1),k+1, 
#@nonl
#@-node:ekr.20060526140744:backwardsHelper
#@+node:ekr.20060526093531:plainHelper
def plainHelper (self,s,i,j,pattern,backwards,nocase,word):
    
    # g.trace(repr(s[i:i+20]))
    
    n = len(pattern)
    if nocase:
        s = s.lower() ; pattern.lower()
        pattern = pattern.replace('\\n','\n').replace('\\t','\t')

    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1: return -1, -1
            elif self.matchWord(s,k,pattern):
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            return -1, -1
        else:
            return k, k + n
#@nonl
#@-node:ekr.20060526093531:plainHelper
#@+node:ekr.20060526140744.1:matchWord
def matchWord(self,s,i,pattern):
    
    return g.match_word(s,i,pattern) and (i == 0 or s[i-1] not in self.word_chars)
#@nonl
#@-node:ekr.20060526140744.1:matchWord
#@-node:ekr.20060526081931:Search helpers...
#@-node:ekr.20031218072017.3077:search & helpers
#@-node:ekr.20060224104109:Improved searches
#@+node:ekr.20060214072931:Added run-unit-test command
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3575014

Actually, the run-unit-tests command first appeared in Leo 4.4, but it never got
properly announced.
#@nonl
#@-node:ekr.20060214072931:Added run-unit-test command
#@+node:ekr.20060527182907:Support multiple editors in the body pane
@nocolor

The add-editor command adds a new editor, the delete-editor command deletes the presently selected editor, and the cycle-editor-focus command cycles focus between editors in the body text.

The leftmost editor has no label: it always shows the body text of the presently selected node.  All other editors have a label showing the node to which it applies.

All editors are 'live' at all times: changing an editor changes the corresponding node. All editors are syntax colored properly at all times.

A small quirk.  Selecting an editor will not show the corresponding node if the node is not visible in a hoist.  This is probably different from how the chapters plugin worked.  It would be easy enough to change the code to de-hoist as necessary, but I'm not sure that is really what is desired.  Tell me if you care one way or another.

@color
#@nonl
#@+node:ekr.20031218072017.2182:tkBody. __init__
def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterBody")
    
    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)
    
    c = self.c
    self.editor_name = None
    self.editor_v = None
    self.editorWidgets = {} # keys are pane names, values are Tk.Text widgets

    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.bodyCtrl = self.createControl(frame,parentFrame)
    self.colorizer = leoColor.colorizer(c)
#@nonl
#@-node:ekr.20031218072017.2182:tkBody. __init__
#@+node:ekr.20031218072017.3998:tkBody.createControl
def createControl (self,frame,parentFrame):
    
    c = self.c
    
    # New in 4.4.1: make the parent frame a Pmw.PanedWidget.
    self.numberOfEditors = 1
   
    self.pb = pb = Pmw.PanedWidget(parentFrame,orient='horizontal')
    parentFrame = pb.add('1')
    pb.pack(expand=1,fill='both') # Must be done after the first page created.
   
    w = self.createTextWidget(frame,parentFrame,name=None,p=None)
    self.editorWidgets[None] = w
    return w
#@nonl
#@-node:ekr.20031218072017.3998:tkBody.createControl
#@+node:ekr.20060528100747.3:tkBody.createTextWidget
def createTextWidget (self,frame,parentFrame,name,p):
    
    c = self.c

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    # Inject ivars
    body.leo_pane_name = name
    body.leo_v = p and p.v
        
    def focusInCallback(event,self=self,w=body):
        self.onFocusIn(w)
    body.bind('<FocusIn>',focusInCallback)

    return body
#@nonl
#@-node:ekr.20060528100747.3:tkBody.createTextWidget
#@+node:ekr.20060528100747:Editors
#@+node:ekr.20060528100747.1:addEditor
def addEditor (self,event=None):
    
    '''Add another editor to the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    self.numberOfEditors += 1
    name = '%d' % self.numberOfEditors
    pane = self.pb.add(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    << create label and text widgets >>
    
    self.editorWidgets[name] = w
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
    
    self.pb.updatelayout()
#@nonl
#@+node:ekr.20060528110922:<< create label and text widgets >>
f = Tk.Frame(pane)
f.pack(side='top',expand=1,fill='both')

label = Tk.Label(f,text= p.headString(),bg='LightSteelBlue1')
label.pack(side='top')

text = Tk.Frame(f)
text.pack(side='top',expand=1,fill='both')

w = self.createTextWidget(self.frame,text,name=name,p=p)

w.delete('1.0','end')
w.insert('end',p.bodyString())
self.setFontFromConfig(w=w)
self.setColorFromConfig(w=w)
self.createBindings(w=w)
c.k.completeAllBindingsForWidget(w)

# Temporarily make this the 'real' text widget so we can color it.
old_w = self.bodyCtrl
self.bodyCtrl = w
c.recolor_now()
self.bodyCtrl = old_w

# Disable this editor.
# Eventually, we should allow edits here.
# w.configure(state='disabled')
#@nonl
#@-node:ekr.20060528110922:<< create label and text widgets >>
#@-node:ekr.20060528100747.1:addEditor
#@+node:ekr.20060528170438:cycleEditorFocus
def cycleEditorFocus (self,event=None):
    
    '''Cycle keyboard focus between the body text editors.'''
    
    c = self.c ; d = self.editorWidgets
    keys = d.keys() ; n = len(keys)
    if n < 2: return # There is only the main widget. 

    i = 0
    for key in d.keys():
        i += 1
        w = d.get(key)
        if w == self.bodyCtrl:
            if i >= n: i = 0
            self.bodyCtrl = w = d.get(keys[i])
            g.app.gui.set_focus(c, w)
            return
#@nonl
#@-node:ekr.20060528170438:cycleEditorFocus
#@+node:ekr.20060528113806:deleteEditor
def deleteEditor (self,event=None):
    
    '''Delete the presently selected body text editor.'''
    
    name = self.editor_name

    if not name:
        g.es('Can not delete the main body editor',color='blue')
        return
        
    del self.editorWidgets [name]

    self.pb.delete(name)
    panes = self.pb.panes()
    minSize = float(1.0/float(len(panes)))
    
    for pane in panes:
        self.pb.configurepane(pane,size=minSize)
        
    self.selectMainEditor()
#@nonl
#@-node:ekr.20060528113806:deleteEditor
#@+node:ekr.20060528104554:onFocusIn
def onFocusIn(self,w):
    
    c = self.c ; p = None

    # Get the ivars from the ivars injected into w.
    self.editor_name = hasattr(w,'leo_pane_name') and w.leo_pane_name or None
    self.editor_v = v = hasattr(w,'leo_v')         and w.leo_v         or None
    # g.trace(w,v)
    
    if not v:
        # We are selecting the main editor, so nothing actually changes.
        self.bodyCtrl = w
        c.frame.bodyWantsFocus()
        return
    
    for p in c.allNodes_iter():
        if p.v == v:
            c.selectPosition(p, updateBeadList=True)
            self.bodyCtrl = w # This may be changed by c.selectPosition
            c.frame.bodyWantsFocus()
            break
    else:
        g.trace("Can't happen",p)
#@nonl
#@-node:ekr.20060528104554:onFocusIn
#@+node:ekr.20060528132829:selectMainEditor
def selectMainEditor (self):
    
    c = self.c

    w = self.editorWidgets.get(None)
    self.bodyCtrl = w
    c.recolor_now()
#@nonl
#@-node:ekr.20060528132829:selectMainEditor
#@+node:ekr.20060528131618:updateEditors
def updateEditors (self):
    
    c = self.c ; p = c.currentPosition()
    d = self.editorWidgets
    if len(d.keys()) < 2: return # There is only the main widget.
    w_main = d.get(None)

    for key in d.keys():
        w = d.get(key)
        if w == self.bodyCtrl: continue
        v = w.leo_v
        if v == p.v or w == w_main:
            # g.trace('update',v,w)
            # Temporarily make this the 'real' text widget so we can color it.
            old_w = self.bodyCtrl
            self.bodyCtrl = w
            w.delete('1.0','end')
            w.insert('end',p.bodyString())
            c.recolor_now()
            self.bodyCtrl = old_w
    c.frame.bodyWantsFocus()
#@nonl
#@-node:ekr.20060528131618:updateEditors
#@-node:ekr.20060528100747:Editors
#@+node:ekr.20040803072955.128:tree.select
#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('does not exist',p.headString())
        return # Not an error.
    
    if self.trace_select and not g.app.unitTesting: g.trace(g.callers())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                else:
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.after(100,scrollCallback)
            except Exception: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    c.setCurrentPosition(p)
    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    return 'break' # Supresses unwanted selection.
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >>
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >>
#@+node:ekr.20040803072955.130:<< select the new node >>
# Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(0,body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
# c.beadList is the list of nodes for the back and forward commands.

if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by p and make p the present node.
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
        # New in Leo 4.4: limit this list to 100 items.
        if 0: # Doesn't work yet.
            c.beadList = c.beadList [-100:]
            g.trace('len(c.beadList)',len(c.beadList))
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# The test 'p in c.visitedList' calls p.__cmp__, so this code *is* valid.

# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())

# g.trace('len(c.visitedList)',len(c.visitedList))
# g.trace([z.headString()[:10] for z in c.visitedList]) # don't assign to p!
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

c.frame.body.selectMainEditor() # New in Leo 4.4.1.

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.1329:onBodyChanged (tkBody)
# This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    trace = self.trace_onBodyChanged
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = g.app.gui.getAllText(bodyCtrl) # Note: getAllText converts to unicode.
    # g.trace('newText',repr(newText))
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    changed = oldText != newText
    if trace:
        g.trace(repr(ch),'changed:',changed)
        g.trace('newText:',repr(newText))
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        << recolor the body >>
        if not c.changed: c.setChanged(True)
        self.updateEditors()
        << redraw the screen if necessary >>
#@nonl
#@+node:ekr.20051026083733.6:<< recolor the body >>
body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20051026083733.6:<< recolor the body >>
#@+node:ekr.20051026083733.7:<< redraw the screen if necessary >>
c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)
#@nonl
#@-node:ekr.20051026083733.7:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1329:onBodyChanged (tkBody)
#@-node:ekr.20060527182907:Support multiple editors in the body pane
#@+node:ekr.20060528173539:Created gui.toPythonIndex & gui.toGuiIndex
#@-node:ekr.20060528173539:Created gui.toPythonIndex & gui.toGuiIndex
#@+node:ekr.20060515060803:Allow idle-time redraw
# Added support for @bool idle_redraw setting.
#@nonl
#@+node:ekr.20060515060803.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3729823
By: nobody

I am running Ubuntu 5.10 and have the same (I think) problem - this is with
the 4.4 final release.

When I move through nodes using the alt-XXX short cuts, there is a lot of flicker
as nodes are redrawn etc. I had no problem with this in 4.3.
#@nonl
#@-node:ekr.20060515060803.1:Report
#@+node:ekr.20040803072955.16:__init__ (tkTree)
def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    trace = c.config.getBool('trace_chapters') and not g.app.unitTesting
    if trace: g.trace('tkTree')
    
    # Configuration and debugging settings.
    self.expanded_click_area    = c.config.getBool('expanded_click_area')
    self.gc_before_redraw       = c.config.getBool('gc_before_redraw')
    self.idle_redraw            = c.config.getBool('idle_redraw')
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')

    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')
    self.trace_select           = c.config.getBool('trace_select')
    self.trace_stats            = c.config.getBool('show_tree_stats')
 
    # Objects associated with this tree.
    self.canvas = canvas
    
    << define drawing constants >>
    << old ivars >>
    << inject callbacks into the position class >>
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount <= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []
#@nonl
#@+node:ekr.20040803072955.17:<< define drawing constants >>
self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
#@nonl
#@-node:ekr.20040803072955.17:<< define drawing constants >>
#@+node:ekr.20040803072955.18:<< old ivars >>
# Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw_now)
#@nonl
#@-node:ekr.20040803072955.18:<< old ivars >>
#@+node:ekr.20040803072955.19:<< inject callbacks into the position class >>
# The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
#@nonl
#@-node:ekr.20040803072955.19:<< inject callbacks into the position class >>
#@-node:ekr.20040803072955.16:__init__ (tkTree)
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):
    
    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())
    
def endUpdate (self,flag,scroll=False):
    
    self.updateCount -= 1
    # g.trace('  tree',id(self),self.updateCount,g.callers())
    
    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount",g.callers())
#@nonl
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility
#@nonl
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        g.trace(self.redrawCount)
#@nonl
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId
#@nonl
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
#@nonl
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    << compute x,y and iconVal >>

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width
#@nonl
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 <= val <= 15)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    # g.trace(x,y,p,id(self.canvas))
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)
   
    self.configureTextState(p)

    return self.line_height
#@nonl
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p
    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        self.redrawCount += 1
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())
        
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)

    if self.trace_stats: self.showStats()
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@nonl
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n
#@nonl
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c):
        # g.trace('does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20040803072955.62:Helpers...
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@-node:ekr.20060515060803:Allow idle-time redraw
#@+node:ekr.20060419101401:Completed transition to 'end-1c'
#@+node:ekr.20060529091202.1:Changes
#@+node:ekr.20031218072017.4028:tkBody.getAllText
def getAllText (self):
    
    """Return all the body text, converted to unicode."""
    
    s = self.bodyCtrl.get("1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4028:tkBody.getAllText
#@+node:ekr.20031218072017.4091:g.app.gui.getAllText
def getAllText (self,t):
    
    """Return all the text of Tk.Text widget t converted to unicode."""

    s = t.get("1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@nonl
#@-node:ekr.20031218072017.4091:g.app.gui.getAllText
#@+node:ekr.20051023132350:getLabel
def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    
    if self.useTextWidget:
        w.update_idletasks()
        s = g.app.gui.getAllText(w)
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
#@nonl
#@-node:ekr.20051023132350:getLabel
#@+node:ekr.20050920085536.38:updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    
    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            if ch == '\b':
                s = g.app.gui.getAllText(w)
                if len(s) > len(k.mb_prefix):
                    w.delete(i+'-1c')
            else:
                w.insert('insert',ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
#@nonl
#@-node:ekr.20050920085536.38:updateLabel
#@+node:ekr.20060417183606.1:moveLinesUp (works, except for selection point when last line selected)
def moveLinesUp (self,event):
    
    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = event.widget

    if not g.app.gui.hasSelection(w): return
    
    self.beginCommand(undoType='move-lines-up')
    
    i,j = g.app.gui.getSelectionRange(w)
    i = w.index(i+' linestart')
    j = w.index(j+' lineend+1c')
    i2 = w.index(i+'-1c linestart')
    selected = w.get(i,j) # ; g.trace('selected',repr(selected))
    moved = w.get(i2,i)   # ; g.trace('moved',repr(moved))

    if moved:
        w.mark_set('i',i)
        w.mark_set('j',j)
        w.delete(i2,i)
        if w.compare('j','==','end'):
            if moved.endswith('\n'): moved = moved[:-1]
            w.insert('j','\n' + moved)
        else:
            w.insert('j',moved)
        w.mark_unset('sel')
        w.mark_set('sel.start','i')
        w.mark_set('sel.end','j')
        w.mark_unset('i')
        w.mark_unset('j')
    elif g.app.gui.widget_name(w).startswith('body'):
        p = c.currentPosition()
        if not p.hasThreadBack(): return
        w.delete(i,j+'+1c')
        p.setBodyString(w.get('1.0','end'))
        p = p.threadBack()
        c.beginUpdate()
        c.selectPosition(p)
        c.endUpdate()
        w.focus_force()
        s = g.app.gui.getAllText(w)
        if s.endswith('\n'):
            w.insert('end',selected)
        else:
            if selected.endswith('\n'): selected = selected[:-1]
            w.insert('end','\n'+selected)
        g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-1c') # works

    self.endCommand(changed=True,setLabel=True)
#@nonl
#@-node:ekr.20060417183606.1:moveLinesUp (works, except for selection point when last line selected)
#@+node:ekr.20060204120158.1:findAgainCommand
def findAgainCommand (self):
    
    s = g.app.gui.getAllText(self.find_ctrl)
    
    if s and s != '<find pattern here>':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
#@nonl
#@-node:ekr.20060204120158.1:findAgainCommand
#@+node:ekr.20051020120306.26:bringToFront
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    c.widgetWantsFocus(t)
    g.app.gui.selectAllText(t)
    c.widgetWantsFocus(t)
#@nonl
#@-node:ekr.20051020120306.26:bringToFront
#@-node:ekr.20060529091202.1:Changes
#@+node:ekr.20060529091202:Replaced gui.setTextSelection (t,"1.0","end-1c") by gui.selectAllText
#@+node:ekr.20060529092645:selectAllText (new in 4.4.1)
def selectAllText (self,w,insert='end-1c'):
    
    '''Select all text of the widget, *not* including the extra newline.'''
    
    self.setTextSelection(w,'1.0','end-1c',insert=insert)
#@nonl
#@-node:ekr.20060529092645:selectAllText (new in 4.4.1)
#@+node:ekr.20031218072017.3907:bringToFront
def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()

    c.widgetWantsFocusNow(t)
    gui.selectAllText(t)
#@nonl
#@-node:ekr.20031218072017.3907:bringToFront
#@+node:ekr.20051020120306.26:bringToFront
def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    c.widgetWantsFocus(t)
    g.app.gui.selectAllText(t)
    c.widgetWantsFocus(t)
#@nonl
#@-node:ekr.20051020120306.26:bringToFront
#@-node:ekr.20060529091202:Replaced gui.setTextSelection (t,"1.0","end-1c") by gui.selectAllText
#@-node:ekr.20060419101401:Completed transition to 'end-1c'
#@+node:ekr.20051121070552:Finished Cmds menu
#@+node:ekr.20060529161541:regex patterns
('.*'):(.*)(self.*),
(\1,\2\3),


 '
('xxx',    '

':.*
'),
#@nonl
#@-node:ekr.20060529161541:regex patterns
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Center...',          self.cmdsMenuCenterTable),
        ('C&hange Case...',     self.cmdsMenuChangeCaseTable),
        ('&Help For Commands...',self.cmdsMenuHelpTable),
        ('&Indent...',          self.cmdsMenuIndentTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('&Sort...',            self.cmdsMenuSortTable),
        ('S&pell Check...',     self.cmdsMenuSpellCheckTable),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20050921103230:defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuHelpTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
#@+node:ekr.20060117094955: defineCmdsMenuTopTable
def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat &Last Complex Command',    'repeat-complex-command'),
        ('&Execute Named Command',          'full-command'),
        ('Keyboard &Quit',                  'keyboard-quit'),
        ('-', None),
    ]
#@-node:ekr.20060117094955: defineCmdsMenuTopTable
#@+node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ('&Toggle Abbreviation Mode',    'abbrev-mode'),
        ('-', None),
        ('&List Abbrevs',                'list-abbrevs'),
        ('&Read Abbrevs',                'read-abbrev-file'),
        ('&Write Abbrevs',               'write-abbrev-file'),
        ('-', None),
        ('&Add Global Abbrev',           'add-global-abbrev'),
        ('&Inverse Add Global Abbrev',   'inverse-add-global-abbrev'),
        ('&Kill All Abbrevs',            'kill-all-abbrevs'),
        ('-', None),
        # ('&Expand Abbrev',             'expand-abbrev'), # Not a command
        ('&Expand Abbrev in Region',     'expand-region-abbrevs'),
    ]
#@nonl
#@-node:ekr.20060117094955.1:defineCmdsMenuAbbrevTable
#@+node:ekr.20060117095212:defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('&Append To Buffer',             'append-to-buffer'),
        ('&Kill Buffer',                  'kill-buffer'),
        ('List &Buffers',                 'list-buffers'),
        ('&List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('&Prepend To Buffer',            'prepend-to-buffer'),
        ('&Rename Buffer',                'rename-buffer'),
        ('&Switch To Buffer',             'switch-to-buffer'),
    ]
#@nonl
#@-node:ekr.20060117095212:defineCmdsMenuBufferTable
#@+node:ekr.20060117095212.5:defineCmdsMenuCenterTable
def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center &Line',     'center-line'),
        ('Center &Region',   'center-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.5:defineCmdsMenuCenterTable
#@+node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('&Capitalize Word', 'capitalize-word'),
        ('&Downcase Word',   'downcase-word'),
        ('&Upcase Word',     'upcase-word'),
        ('-', None),
        ('D&owncase Region', 'downcase-region'),
        ('U&pcase Region',   'upcase-region'),
    ]
#@-node:ekr.20060117095212.4:defineCmdsMenuChangeCaseTable
#@+node:ekr.20060529170949:defineCmdsMenuHelpTable
def defineCmdsMenuHelpTable (self):

    c = self.c

    self.cmdsMenuHelpTable = [
        ('&Getting Started',         'help'),
        ('&Help For Command',        'help-for-command'),
        ('-', None),
        ('Apropos &Autocompletion',  'apropos-autocompletion'),
        ('Apropos &Bindings',        'apropos-bindings'),
        ('Apropos &Find Commands',   'apropos-find-commands'),
    ]
#@nonl
#@-node:ekr.20060529170949:defineCmdsMenuHelpTable
#@+node:ekr.20060117095212.6:defineCmdsMenuIndentTable
def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('&Indent Region',   'indent-region'),
        ('Indent R&elative', 'indent-relative'),
        ('Indent Ri&gidly',  'indent-rigidly'),
        ('&Unindent Region', 'unindent-region'),
    ]
#@nonl
#@-node:ekr.20060117095212.6:defineCmdsMenuIndentTable
#@+node:ekr.20060117114315:defineCmdsMenuMacroTable
def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ('&Load Macro File',     'load-file'),
        ("-", None),
        ('&Start Macro',         'start-kbd-macro'),
        ('&End Macro',           'end-kbd-macro'),
        ('&Name Last Macro',     'name-last-kbd-macro'),
        ("-", None),
        ('&Call Last Macro',     'call-last-keyboard-macro'),
        ('&Insert Macro',        'insert-keyboard-macro'),
    ]
#@nonl
#@-node:ekr.20060117114315:defineCmdsMenuMacroTable
#@+node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ('&Clear Rect',  'clear-rectangle'),
        ('C&lose Rect',  'close-rectangle'),
        ('&Delete Rect', 'delete-rectangle'),
        ('&Kill Rect',   'kill-rectangle'),
        ('&Open Rect',   'open-rectangle'),
        ('&String Rect', 'string-rectangle'),
        ('&Yank Rect',   'yank-rectangle'),
    ]
#@nonl
#@-node:ekr.20060117095212.2:defineCmdsMenuRectanglesTable
#@+node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ('&Append To Reg',   'append-to-register'),
        ('Copy R&ect To Reg','copy-rectangle-to-register'),
        ('&Copy To Reg',     'copy-to-register'),
        ('I&nc Reg',         'increment-register'),
        ('&Insert Reg',      'insert-register'),
        ('&Jump To Reg',     'jump-to-register'),
        # ('xxx',           'number-to-register'),
        ('&Point to Reg',    'point-to-register'),
        ('P&repend To Reg',  'prepend-to-register'),
        ('&View Reg',        'view-register'),
    ]
#@nonl
#@-node:ekr.20060117095212.1:defineCmdsMenuRegistersTable
#@+node:ekr.20060117095212.3:defineCmdsMenuSortTable
def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort &Columns',    'sort-columns'),
        ('Sort &Fields',     'sort-fields'),
        ('Sort &Lines',      'sort-lines'),
    ]
#@nonl
#@-node:ekr.20060117095212.3:defineCmdsMenuSortTable
#@+node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check &Spelling',      'open-spell-tab'),
        ('&Change',              'spell-change'),
        ('Change, &Then Find',   'spell-change-then-find'),
        ('&Find',                'spell-find'),
        ('&Ignore',              'spell-ignore'),
    ]
#@nonl
#@-node:ekr.20060117095212.7:defineCmdsMenuSpellCheckTable
#@-node:ekr.20050921103230:defineCmdsMenuTables & helpers
#@-node:ekr.20051121070552:Finished Cmds menu
#@+node:ekr.20060529195042:Added docstrings for all commands
# No docstring yet...
            dabbrev-completion dynamicExpansion2
               dabbrev-expands dynamicExpansion
                        escape watchEscape
                number-command numberCommand
              set-mark-command setRegion
#@nonl
#@-node:ekr.20060529195042:Added docstrings for all commands
#@+node:ekr.20060529175453:Improved show-fonts command
It is now clearer what the selected values are.
#@nonl
#@-node:ekr.20060529175453:Improved show-fonts command
#@+node:ekr.20060529230636:Improved formatting of output of the help-for-command command
#@+node:ekr.20060417203717:helpForCommand
def helpForCommand (self,event):
    
    '''Prompts for a command name and prints the help message for that command.'''
    
    k = self.k
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)
    
def helpForCommandFinisher (self,commandName):

    c = self.c
    func = c.commandsDict.get(commandName)
    if func and func.__doc__:
        s = ''.join([
            g.choose(line.strip(),line.lstrip(),'\n')
                for line in g.splitLines(func.__doc__)])
        g.es('%s:\n%s\n' % (commandName,s),color='blue')
    else:
        g.es('No help available for %s' % (commandName),color='blue')
#@nonl
#@-node:ekr.20060417203717:helpForCommand
#@-node:ekr.20060529230636:Improved formatting of output of the help-for-command command
#@+node:ekr.20051012062458.1:Strip quotes from color, font settings.
#@-node:ekr.20051012062458.1:Strip quotes from color, font settings.
#@+node:ekr.20060202235215.1:Warn about invalid Enter and Leave key bindings
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    << give warning and return if we try to bind to Enter or Leave >>
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    << give warning and return if there is a serious redefinition >>
    << trace bindings if enabled in leoSettings.leo >>
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = g.stripBrackets(shortcut.strip())
        # if shortcut.startswith('<Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility
#@nonl
#@+node:ekr.20060530084936:<< give warning and return if we try to bind to Enter or Leave >>
if shortcut:
    for s in ('enter','leave'):
        if -1 != shortcut.lower().find(s):
            g.es_print('Ignoring invalid key binding: %s = %s' % (
                commandName,shortcut),color='blue')
            return
#@nonl
#@-node:ekr.20060530084936:<< give warning and return if we try to bind to Enter or Leave >>
#@+node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
for bunch in bunchList:

    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return
#@nonl
#@-node:ekr.20060114115648:<< give warning and return if there is a serious redefinition >>
#@+node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)
#@nonl
#@-node:ekr.20060114110141:<< trace bindings if enabled in leoSettings.leo >>
#@-node:ekr.20050920085536.16:bindKey
#@-node:ekr.20060202235215.1:Warn about invalid Enter and Leave key bindings
#@-node:ekr.20060522103446:New features
#@-node:ekr.20060514170725:4.4.1 projects
#@-node:ekr.20050924073836:4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
