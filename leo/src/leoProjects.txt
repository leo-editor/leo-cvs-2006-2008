#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20071128100845:Pylint
#@+node:ekr.20071128095109:pylint: leoEditCommands.py
# These errors are not correct.
E1101:108:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'name' member
E1101:109:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'undoType' member
E1101:110:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldSel' member
E1101:110:baseEditCommandsClass.endCommand: Instance of 'Bunch' has no 'oldText' member
#@-node:ekr.20071128095109:pylint: leoEditCommands.py
#@+node:ekr.20071130094930:pylint: leoGlobals.py
************* Module leoGlobals

# Fixed: E0602:550:scanAtPagewidthDirective: Undefined variable 'k'
# Fixed: E0602:609:scanAtTabwidthDirective: Undefined variable 'k'
# Fixed: E0602:1056:es_exception: Undefined variable 's'
# Fixed: E0102:5098:getLine: function already defined line 1335

# Bad warnings:
# E1101:137:computeGlobalConfigDir: Module 'sys' has no 'leo_config_directory' member
# W0631:2956:scanAtFileOptions: Using possibly undefined loop variable 'option'
# W0104:3869: Statement seems to have no effect
# E0602:3885:getpreferredencoding: Undefined variable 'LC_CTYPE'
# E0602:3886:getpreferredencoding: Undefined variable 'LC_CTYPE'
# E1101:3887:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
# E0602:3887:getpreferredencoding: Undefined variable 'CODESET'
# E0602:3888:getpreferredencoding: Undefined variable 'LC_CTYPE'
# E1101:3891:getpreferredencoding: Module 'locale' has no 'nl_langinfo' member
# E0602:3891:getpreferredencoding: Undefined variable 'CODESET'
# E1101:4386:mulderUpdateAlgorithm.copy_time: Module 'os' has no 'mtime' member
# W0631:4415:mulderUpdateAlgorithm.create_mapping: Using possibly undefined loop variable 'i'
# R0903:4815:nullObject: Too few public methods (0/1)
# W0631:5393:adjustTripleString: Using possibly undefined loop variable 's'
#@-node:ekr.20071130094930:pylint: leoGlobals.py
#@-node:ekr.20071128100845:Pylint
#@+node:ekr.20071211113202:4.4.6
#@+node:ekr.20071211113202.1:Bugs fixed
#@+node:ekr.20071211082951:Fixed undo (dirty bit) problem)
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4668960
By: terry_n_brown

It seems in derived files you can delete some text and save, causing the derived
file to be written and all dirty flags cleared.  But then undo makes the text
come back, as expected, but save only saves the outline, because the dirty flag
wasn't set on the node in which the text was restored by undo.

@color
#@nonl
#@+node:ekr.20031218072017.2039:undo & helpers...
def undo (self,event=None):

    """Undo the operation described by the undo parameters."""

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canUndo():
        # g.trace('cant undo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    # g.trace(u.undoType)
    # g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
    u.undoing = True
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.undoHelper: u.undoHelper()
        else: g.trace('no undo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.undoing = False
        u.bead -= 1
        u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@+node:ekr.20050412083057.1:undoCloneNode
def undoCloneNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 5.0

    c.selectPosition(u.p)
#@-node:ekr.20050412083057.1:undoCloneNode
#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):

    u = self ; c = u.c

    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
#@-node:ekr.20050412084055:undoDeleteNode
#@+node:ekr.20050318085713:undoGroup
def undoGroup (self):

    '''Process beads until the matching 'beforeGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    oldSel = u.oldSel
    p = u.p.copy()

    u.groupCount += 1

    bunch = u.beads[u.bead] ; count = 0

    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        c.beginUpdate()
        try:
            for z in reversedItems:
                self.setIvarsFromBunch(z)
                # g.trace(z.undoHelper)
                if z.undoHelper:
                    z.undoHelper() ; count += 1
                else:
                    g.trace('oops: no undo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1

    for v in dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 5.0.

    if not g.unitTesting:
        g.es("undo %d instances" % count)

    c.selectPosition(p)
    oldSel and c.frame.body.setSelectionRange(oldSel)
#@nonl
#@-node:ekr.20050318085713:undoGroup
#@+node:ekr.20050412083244:undoHoistNode & undoDehoistNode
def undoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()
#@-node:ekr.20050412083244:undoHoistNode & undoDehoistNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):

    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()

    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                c.setBodyString(u.p,bunch.body)
                c.setHeadString(u.p,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)

    c.selectPosition(u.p)
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050526124906:undoMark
def undoMark (self):

    u = self ; c = u.c

    u.updateMarks('old')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty() # Bug fix: Leo 5.0.

        c.selectPosition(u.p)
#@-node:ekr.20050526124906:undoMark
#@+node:ekr.20050411112033:undoMove
def undoMove (self):

    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        u.p.moveToRoot(oldRoot=c.rootPosition())

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 5.0.

    c.selectPosition(u.p)
#@-node:ekr.20050411112033:undoMove
#@+node:ekr.20050318085713.1:undoNodeContents
def undoNodeContents (self):

    '''Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    '''

    u = self ; c = u.c ;  w = c.frame.body.bodyCtrl

    u.p.setTnodeText(u.oldBody)
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p,incremental=False)

    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead)

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setSelectionRange(u.oldSel)

    u.updateMarks('old')

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 5.0.
#@-node:ekr.20050318085713.1:undoNodeContents
#@+node:ekr.20050318085713.2:undoTree
def undoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.newTree,u.oldTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.oldSel:
        c.frame.body.setSelectionRange(u.oldSel)
#@-node:ekr.20050318085713.2:undoTree
#@+node:ekr.20050408100042:undoRedoTree
def undoRedoTree (self,p,new_data,old_data):

    '''Replace p and its subtree using old_data during undo.'''

    # Same as undoReplace except uses g.Bunch.

    u = self ; c = u.c

    if new_data == None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch

    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p,p.bodyString())

    return p # Nothing really changes.
#@-node:ekr.20050408100042:undoRedoTree
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList:
        v.t.setDirty() # Bug fix: Leo 5.0.

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@+node:ekr.20031218072017.1493:undoRedoText (passed)
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    # __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    << Compute the result using p's body text >>
    p.setTnodeText(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText (passed)
#@-node:ekr.20031218072017.2039:undo & helpers...
#@+node:ekr.20031218072017.2030:redo & helpers...
def redo (self,event=None):

    '''Redo the operation undone by the last undo.'''

    u = self ; c = u.c
    # g.trace(g.callers(7))

    if not u.canRedo():
        # g.trace('cant redo',u.undoMenuLabel,u.redoMenuLabel)
        return
    if not u.getBead(u.bead+1):
        g.trace('no bead') ; return
    if not c.currentPosition():
        g.trace('no current position') ; return

    # g.trace(u.undoType)
    # g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
    u.redoing = True 
    u.groupCount = 0

    c.beginUpdate()
    try:
        c.endEditing()
        if u.redoHelper: u.redoHelper()
        else: g.trace('no redo helper for %s %s' % (u.kind,u.undoType))
    finally:
        if 0: # Don't do this: it interferes with selection ranges.
            # This strange code forces a recomputation of the root position.
            c.selectPosition(c.currentPosition())
        else:
            c.setCurrentPosition(c.currentPosition())
        c.setChanged(True)
        c.endUpdate()
        c.recolor_now()
        c.bodyWantsFocusNow()
        u.redoing = False
        u.bead += 1
        u.setUndoTypes()
#@nonl
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):

    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050412083057:redoCloneNode
def redoCloneNode (self):

    u = self ; c = u.c

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.newP)
#@-node:ekr.20050412083057:redoCloneNode
#@+node:EKR.20040526072519.2:redoDeleteNode
def redoDeleteNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
#@-node:EKR.20040526072519.2:redoDeleteNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c

    # g.trace('newP',u.newP.v,'back',u.newBack,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()

    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                c.setBodyString(u.newP,bunch.body)
                c.setHeadString(u.newP,bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@-node:ekr.20050412084532:redoInsertNode
#@+node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
def redoHoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode (self):

    u = self ; c = u.c

    c.selectPosition(u.p)
    c.dehoist()
#@-node:ekr.20050412085138.1:redoHoistNode & redoDehoistNode
#@+node:ekr.20050318085432.6:redoGroup
def redoGroup (self):

    '''Process beads until the matching 'afterGroup' bead is seen.'''

    u = self

    # Remember these values.
    c = u.c
    dirtyVnodeList = u.dirtyVnodeList or []
    newSel = u.newSel
    p = u.p.copy()

    u.groupCount += 1


    bunch = u.beads[u.bead] ; count = 0
    if not hasattr(bunch,'items'):
        g.trace('oops: expecting bunch.items.  bunch.kind = %s' % bunch.kind)
    else:
        c.beginUpdate()
        try:
            for z in bunch.items:
                self.setIvarsFromBunch(z)
                if z.redoHelper:
                    # g.trace(z.redoHelper)
                    z.redoHelper() ; count += 1
                else:
                    g.trace('oops: no redo helper for %s' % u.undoType)
        finally:
            c.endUpdate(False)

    u.groupCount -= 1

    for v in dirtyVnodeList:
        v.t.setDirty()

    if not g.unitTesting:
        g.es("redo %d instances" % count)

    c.selectPosition(p)
    newSel and c.frame.body.setSelectionRange(newSel)
#@nonl
#@-node:ekr.20050318085432.6:redoGroup
#@+node:ekr.20050318085432.7:redoNodeContents
def redoNodeContents (self):

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl

    # Restore the body.
    u.p.setTnodeText(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p,incremental=False)

    # Restore the headline.
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.

    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)

    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setSelectionRange(u.newSel)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()
#@-node:ekr.20050318085432.7:redoNodeContents
#@+node:ekr.20050526125801:redoMark
def redoMark (self):

    u = self ; c = u.c

    u.updateMarks('new')

    if u.groupCount == 0:

        for v in u.dirtyVnodeList:
            v.t.setDirty()

        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050526125801:redoMark
#@+node:ekr.20050411111847:redoMove
def redoMove (self):

    u = self ; c = u.c

    # g.trace(u.p)

    if u.newParent:
        u.p.moveToNthChildOf(u.newParent,u.newN)
    elif u.newBack:
        u.p.moveAfter(u.newBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot=oldRoot)

    u.updateMarks('new')

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    c.selectPosition(u.p)
#@-node:ekr.20050411111847:redoMove
#@+node:ekr.20050318085432.8:redoTree
def redoTree (self):

    '''Redo replacement of an entire tree.'''

    u = self ; c = u.c

    u.p = self.undoRedoTree(u.p,u.oldTree,u.newTree)
    c.selectPosition(u.p) # Does full recolor.
    if u.newSel:
        c.frame.body.setSelectionRange(u.newSel)
#@-node:ekr.20050318085432.8:redoTree
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)

    for v in u.dirtyVnodeList:
        v.t.setDirty()

    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@-node:ekr.20031218072017.2030:redo & helpers...
#@-node:ekr.20071211082951:Fixed undo (dirty bit) problem)
#@+node:ekr.20071026052111:Fixed cursesGui  plugin
#@-node:ekr.20071026052111:Fixed cursesGui  plugin
#@+node:ekr.20071105155631.2:Fixed script_io_to_body plugin
@
Added k.overrideCommand.
#@nonl
#@+node:ekr.20031218072017.2140:c.executeScript & helpers
def executeScript(self,event=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # print '*** script\n',script
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                # g.trace('**** before')
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec script in d
                # g.trace('**** after')
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
#@+node:ekr.20031218072017.2143:redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
#@-node:ekr.20031218072017.2143:redirectScriptOutput
#@+node:EKR.20040627100424:unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
#@-node:EKR.20040627100424:unredirectScriptOutput
#@+node:ekr.20070115135502:writeScriptFile
def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        parts = path.split('/')
        path = g.app.loadDir
        for part in parts:
            path = g.os_path_abspath(g.os_path_join(path,part))
    else:
        path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','scriptFile.py'))

    # Write the file.
    try:
        f = file(path,'w')
        f.write(script)
        f.close()
    except Exception:
        path = None

    return path
#@nonl
#@-node:ekr.20070115135502:writeScriptFile
#@-node:ekr.20031218072017.2140:c.executeScript & helpers
#@+node:ekr.20071212104050:k.overrideCommand
def overrideCommand (self,commandName,func):

    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d.keys():
        d2 = d.get(key)
        for key2 in d2.keys():
            b = d2.get(key2)
            if b.commandName == commandName:
                b.func=func
                d2[key2] = b
#@-node:ekr.20071212104050:k.overrideCommand
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c ; w = self.logCtrl

    # print 'tkLog.put',s
    # print 'tkLog.put',len(s),g.callers()

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)

    if w:
        << put s to log control >>
        self.logCtrl.update_idletasks()
    else:
        << put s to logWaiting and print s >>
#@+node:EKR.20040423082910:<< put s to log control >>
if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        w.tag_config(color,foreground=color)
    w.insert("end",s)
    w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    w.tag_add("black","end")
else:
    w.insert("end",s)

w.see('end')
self.forceLogUpdate(s)
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return

    # print 'tkLog.putnl' # ,g.callers()

    if tabName:
        self.selectTab(tabName)

    w = self.logCtrl

    if w:
        w.insert("end",'\n')
        w.see('end')
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20031218072017.1474:enl, ecnl & ecnls
def ecnl(tabName='Log'):
    g.ecnls(1,tabName)

def ecnls(n,tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)
#@-node:ekr.20031218072017.1474:enl, ecnl & ecnls
#@+node:ekr.20070626132332:es & minitest
def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    # print 'es',repr(s)
    log = app.log
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@+node:ekr.20071024101611:mini test of es
@nocolor
@first
@

This doesn't work as an external unit test.
To test, select all following lines and do execute-script.

@first # -*- coding: utf-8 -*-
s1 = 'line1 Ä, ڱ,  궯, 奠 end'
s2 = g.toUnicode(s1,'utf-8')

for s in (s1,s2):
    g.es(s)
    g.es_print(s)
#@-node:ekr.20071024101611:mini test of es
#@-node:ekr.20070626132332:es & minitest
#@-node:ekr.20071105155631.2:Fixed script_io_to_body plugin
#@-node:ekr.20071211113202.1:Bugs fixed
#@+node:ekr.20071211113202.2:New features
#@+node:ekr.20071210054816:Applied Terry Brown's config patch
@nocolor
The patch attached against leoConfig.py (current CVS) adds a machine
specific config file to the config files Leo loads.

I synchronize files between multiple (3) machines. This means I can't
use different myLeoSettings files on each.

Tk fonts are screen dpi sensitive.  But (in Linux at least)
Tk's attempts to switch a font you picked to something equivalent at a
different dpi always result in a font that looks terrible.

So every time I switch machines I edit ~/myLeoSettings.leo to move the
font defs I picked for the current machine to the bottom of the body
text for the appropriate settings node, and then restart Leo.

This patch means I don't have to do that any more.  I'm sure there are
other uses for it.  Python doesn't seem to have a generic machine name
finding function, hence the sequence of alternatives.

Cheers -Terry


-----Inline Attachment Follows-----

Index: leo/src/leoConfig.py
===================================================================
RCS file: /cvs/leo/src/leoConfig.py,v
retrieving revision 1.54
diff -r1.54 leoConfig.py
1159a1160,1177
>        machineSettingsFile = None
>        #@    << determine machine settings file name >>
>        #@+node:tbrown.20071208101033:<< determine machine settings file name >>
>        try:
>            import os
>            machineSettingsFile = os.getenv('HOSTNAME')
>            if not machineSettingsFile:
>                machineSettingsFile = os.getenv('COMPUTERNAME')
>            if not machineSettingsFile:
>                import socket
>                machineSettingsFile = socket.gethostname()
>        except:
>            machineSettingsFile = None
>        if machineSettingsFile:
>            machineSettingsFile+='LeoSettings.leo'
>        #@nonl
>        #@-node:tbrown.20071208101033:<< determine machine settings file name >>
>        #@nl
1165a1184
>            ('machineConfigFile',    g.app.homeDir,          machineSettingsFile),
1168a1188,1190
>
>            if not fileName: continue
>
1638a1661
>            (self.machineConfigFile,False),

@color
#@nonl
#@+node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    << define localDirectory, localConfigFile & myLocalConfigFile >>

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print()
                s = g.toEncodedString(s,'ascii')
                print s
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
#@+node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
# This can't be done in initSettingsFiles because the local directory does not exits.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None
#@nonl
#@-node:ekr.20061028082834:<< define localDirectory, localConfigFile & myLocalConfigFile >>
#@+node:ekr.20041117085625:g.app.config.openSettingsFile
def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@-node:ekr.20041117085625:g.app.config.openSettingsFile
#@+node:ekr.20051013161232:g.app.config.updateSettings
def updateSettings (self,c,localFlag):

    d = self.readSettings(c)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
#@-node:ekr.20051013161232:g.app.config.updateSettings
#@-node:ekr.20041120064303:g.app.config.readSettingsFiles & helpers
#@+node:ekr.20041117083857:initSettingsFiles
def initSettingsFiles (self):

    """Set self.globalConfigFile, self.homeFile, self.machineConfigFile and self.myConfigFile."""

    settingsFile = 'leoSettings.leo'
    mySettingsFile = 'myLeoSettings.leo'
    machineConfigFile = self.getMachineName()

    for ivar,theDir,fileName in (
        ('globalConfigFile',    g.app.globalConfigDir,  settingsFile),
        ('homeFile',            g.app.homeDir,          settingsFile),
        ('myGlobalConfigFile',  g.app.globalConfigDir,  mySettingsFile),
        ('myHomeConfigFile',    g.app.homeDir,          mySettingsFile),
        ('machineConfigFile',   g.app.homeDir,          machineConfigFile),
    ):
        # The same file may be assigned to multiple ivars:
        # readSettingsFiles checks for such duplications.
        path = g.os_path_join(theDir,fileName)
        if g.os_path_exists(path):
            setattr(self,ivar,path)
        else:
            setattr(self,ivar,None)
    if 0:
        g.trace('global file:',self.globalConfigFile)
        g.trace('home file:',self.homeFile)
        g.trace('myGlobal file:',self.myGlobalConfigFile)
        g.trace('myHome file:',self.myHomeConfigFile)
#@nonl
#@+node:ekr.20071211112804:getMachineName
def getMachineName (self):

    try:
        import os
        name = os.getenv('HOSTNAME')
        if not name:
            name = os.getenv('COMPUTERNAME')
        if not name:
            import socket
            name = socket.gethostname()
    except Exception:
        name = ''

    if name:
        name +='LeoSettings.leo'

    # g.trace(name)

    return name
#@-node:ekr.20071211112804:getMachineName
#@-node:ekr.20041117083857:initSettingsFiles
#@-node:ekr.20071210054816:Applied Terry Brown's config patch
#@+node:ekr.20071210090623:Applied plumloco's patch to plugins_menu.py
@nocolor

The version of plugins_menu.py at http://leo.zwiki.org/Plumloco separates out
the gui dependent dialogs (the menus are already gui indepandant) and made them
general purpose dialogs available to all plugins.

I have also slightly enhanced the dialogs to provide user defined buttons. 
#@nonl
#@-node:ekr.20071210090623:Applied plumloco's patch to plugins_menu.py
#@-node:ekr.20071211113202.2:New features
#@-node:ekr.20071211113202:4.4.6
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
