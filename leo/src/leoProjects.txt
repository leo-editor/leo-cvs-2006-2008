#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20070626112754.1:Leo 4.4.3 beta 1 projects
#@+node:ekr.20070626112849:Bugs
#@+node:ekr.20070626111306:Fixed improper can not open myLeoSettings message
# can not open: C:\prog\tigris-cvs\leo\config\myLeoSettings.leo
#@+node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
def openLeoSettings (self,event=None):
    '''Open leoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('leoSettings.leo')

def openMyLeoSettings (self,event=None):
    '''Open myLeoSettings.leo in a new Leo window.'''
    self.openSettingsHelper('myLeoSettings.leo')

def openSettingsHelper(self,name):
    c = self
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)
    ok = g.os_path_exists(fileName)
    if ok:
        ok, frame = g.openWithFileName(fileName,c)
        if ok: return

    # Look in homeDir second.
    if configDir == loadDir:
        g.es("%s not found in %s" % (name,configDir))
    else:
        fileName = g.os_path_join(homeDir,name)
        ok = g.os_path_exists(fileName)
        if ok:
            ok, frame = g.openWithFileName(fileName,c)
        if not ok:
            g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@-node:ekr.20031218072017.2943:openLeoSettings and openMyLeoSettings
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20070626111306:Fixed improper can not open myLeoSettings message
#@+node:ekr.20070629092233:Fixed import problem in leoDynamicTest.py
@

It's a bit tricky to ensure that leo/src is in sys.path
The code now changes the working directory to leo/src,
and leoDynamicTest.py adds os.getcwd() to sys.path if it is not there.
This is a dubious plan.

# import os,sys
# print 'cwd', os.getcwd()
# for s in sys.path: print s
#@+node:ekr.20060127162818.1:debugCommandsClass
class debugCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20060127162921: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@-node:ekr.20060127162921: ctor
#@+node:ekr.20060127163325: getPublicCommands
def getPublicCommands (self):

    k = self

    return {
        'collect-garbage':              self.collectGarbage,
        'debug':                        self.debug,
        'disable-gc-trace':             self.disableGcTrace,
        'dump-all-objects':             self.dumpAllObjects,
        'dump-new-objects':             self.dumpNewObjects,
        'enable-gc-trace':              self.enableGcTrace,
        'free-tree-widgets':            self.freeTreeWidgets,
        'print-focus':                  self.printFocus,
        'print-stats':                  self.printStats,
        'print-gc-summary':             self.printGcSummary,
        'run-all-unit-tests':           self.runAllUnitTests, # The new way...
        'run-unit-tests':               self.runUnitTests,
        'run-all-unit-tests-locally':   self.runAllUnitTestsLocally, # The old way...
        'run-unit-tests-locally':       self.runUnitTestsLocally,
        'verbose-dump-objects':         self.verboseDumpObjects,
    }
#@-node:ekr.20060127163325: getPublicCommands
#@+node:ekr.20060205050659:collectGarbage
def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
#@-node:ekr.20060205050659:collectGarbage
#@+node:ekr.20060519003651:debug & helper
def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213:findDebugger
def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
#@-node:ekr.20060521140213:findDebugger
#@-node:ekr.20060519003651:debug & helper
#@+node:ekr.20060202160523:dumpAll/New/VerboseObjects
def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
#@-node:ekr.20060202160523:dumpAll/New/VerboseObjects
#@+node:ekr.20060127163325.1:enable/disableGcTrace
def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = True
    g.enable_gc_debug()

    if g.app.trace_gc_verbose:
        g.es('enabled verbose gc stats',color='blue')
    else:
        g.es('enabled brief gc stats',color='blue')
#@-node:ekr.20060127163325.1:enable/disableGcTrace
#@+node:ekr.20060202154734:freeTreeWidgets
def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
#@-node:ekr.20060202154734:freeTreeWidgets
#@+node:ekr.20060210100432:printFocus
# Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
#@-node:ekr.20060210100432:printFocus
#@+node:ekr.20060205043324.3:printGcSummary
def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
#@-node:ekr.20060205043324.3:printGcSummary
#@+node:ekr.20060202133313:printStats
def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
#@-node:ekr.20060202133313:printStats
#@+node:ekr.20060328121145:runUnitTest commands
def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=True)

def runUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=False)

def runAllUnitTests (self,event=None):
    '''Run all unit tests contained in the entire outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True)

def runUnitTests(self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False)
#@-node:ekr.20060328121145:runUnitTest commands
#@-node:ekr.20060127162818.1:debugCommandsClass
#@+node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():

    # Suppresses warning about sys.leo_config_directory
    #__pychecker__ = '--limit = 0'
    #__pychecker__ = '--no-classattr --no-objattrs'

    import leoGlobals as g

    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")

    if theDir:
        theDir = g.os_path_abspath(theDir)

    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None

    return theDir
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():

    """Returns the user's home directory."""

    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20060416113431:computeLeoDir
def computeLeoDir ():

    loadDir = g.app.loadDir

    g.app.leoDir = theDir = g.os_path_dirname(loadDir)

    if theDir not in sys.path:
        sys.path.append(theDir)

    if 0: # This is required so we can do import leo (as a package)
        theParentDir = g.os_path_dirname(theDir)
        if theParentDir not in sys.path:
            sys.path.append(theParentDir)
#@-node:ekr.20060416113431:computeLeoDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():

    """Returns the directory containing leo.py."""

    import leoGlobals as g
    import sys

    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__ # was leo.__file__
        if sys.platform=='win32':
            if len(path) > 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None

        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        raise
        #import traceback ; traceback.print_exc()
        #return None
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20050328133444:computeStandardDirectories
def computeStandardDirectories():

    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''

    if 0:
        import sys
        for s in sys.path: g.trace(s)

    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.

    g.app.leoDir = g.computeLeoDir()

    g.app.homeDir = g.computeHomeDir()

    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))

    g.app.globalConfigDir = g.computeGlobalConfigDir()

    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))

    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
#@-node:ekr.20050328133444:computeStandardDirectories
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():

    import leoGlobals as g
    import sys

    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding

    return encoding
#@-node:ekr.20041117151301.1:startupEncoding
#@-node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@nonl
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.fileName = 'dynamicUnitTest.leo'

    self.tags = ('@test','@suite','@unittests','@unit-tests') # '@testcase','test-case'
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c
    c2root = c2.rootPosition()
    c2root.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    c2.beginUpdate()
    if self.all:
        p = c.rootPosition() ; limit_p = None
    else:
        p = c.currentPosition() ; limit_p = p.nodeAfterTree()
    try:
        c2root.expand()
        while p and p != limit_p:
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    # print h
                    p2 = p.copyTreeAfter()
                    p2.unlink()
                    p2.moveToLastChildOf(c2root)
                    p.moveToNodeAfterTree()
                    break
            else:
                p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@-node:ekr.20070627135336.9:createOutline
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    args = [sys.executable, path, '--silent']

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    #c.redraw()
                    return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20070629092233:Fixed import problem in leoDynamicTest.py
#@+node:ekr.20070628102649:Fixed cleo crasher
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4385604
By: rich_ries

From: Rich

Coupla problems:

(1) I pressed Alt+9 (just fooling around -- err, experimenting!) and got the
following error window:

====================================================================
Error: 1
AttributeError Exception in Tk callback
  Function: <function masterBindKeyCallback at 0x01461F30> (type: <type
'function'>)
  Args: (<Tkinter.Event instance at 0x00F85260>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line
1747, in __call__
    return apply(self.func, args)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
2150, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
3086, in masterKeyHandler
    return k.masterCommand(event,b.func,b.stroke,b.commandName)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoKeys.py", line
2272, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 283, in doCommand
    c.redraw_now()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 5720, in redraw_now
    c.frame.tree.redraw_now()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 822, in redraw_now
    self.redrawHelper(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 838, in redrawHelper
    self.drawTopTree()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1185, in drawTopTree
    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1213, in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 976, in drawNode
    return self.force_draw_node(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1004, in force_draw_node
    h2 = self.drawText(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1031, in drawText
    self.configureTextState(p)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1890, in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 2349, in setUnselectedLabelState
    self.setUnselectedHeadlineColors(p)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
818, in setUnselectedHeadlineColors
    fg, bg = self.custom_colours(p.v,node_is_selected=False)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
520, in custom_colours
    MeSelf = self.c.currentPosition().headString()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoNodes.py", line
1330, in headString
    return self.v.headString()
AttributeError: 'NoneType' object has no attribute 'headString'

================================================
  Event contents:
    char: 9
    delta: 57
    height: ??
    keycode: 57
    keysym: 9
    keysym_num: 57
    num: ??
    serial: 1993
    state: 131072
    time: 91071250
    type: 2
    widget: .21028576.21057624.21057784.21057824.21057944.21058024.canvas
    width: ??
    x: 318
    x_root: 352
    y: 87
    y_root: 191
--------------------------------------------------------------------
and the following in the Log Pane:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 270, in doCommand
    val = command(event)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 4228, in expandAllHeadlines
    c.endUpdate()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoCommands.py",
line 5597, in endUpdate
    c.frame.tree.endUpdate(flag,scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 777, in endUpdate
    self.redraw_now(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 822, in redraw_now
    self.redrawHelper(scroll=scroll)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 838, in redrawHelper
    self.drawTopTree()
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1185, in drawTopTree
    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1213, in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 976, in drawNode
    return self.force_draw_node(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1004, in force_draw_node
    h2 = self.drawText(p,x,y)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1031, in drawText
    self.configureTextState(p)
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 1890, in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "C:\Software Engineering\Literate Programming\Leo\src\leoTkinterTree.py",
line 2349, in setUnselectedLabelState
    self.setUnselectedHeadlineColors(p)
  File "C:\Software Engineering\Literate Programming\Leo\plugins\cleo.py", line
818, in setUnselectedHeadlineColors
    fg, bg = self.custom_colours(p.v,node_is_selected=False)
====================================================================

(2) Looking through the key bindings, I saw
"@shortcuts Gui operations focus-to-body = Alt-D"
but when I tried it, it actually moves to a headline that starts with "D"


--Rich
#@-node:ekr.20070628102649:Fixed cleo crasher
#@+node:ekr.20070626153304:Fixed spell-check bug
# Misspelled words not selected properly on Linux.
#@nonl
#@+node:ekr.20051025071455.40:find & helpers
def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; w = body.bodyCtrl

    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocusNow()
#@+node:ekr.20051025071455.45:findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""

    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None

    try:
        while 1:
            # g.trace('p',p and p.headString())
            p, word = self.findNextWord(p)
            if not p or not word:
                alts = None
                break
            << Skip word if ignored or in local dictionary >>
            alts = aspell.processWord(word)
            if alts:
                w = c.frame.body.bodyCtrl
                i,j = w.getSelectionRange()
                c.beginUpdate()
                try:
                    c.frame.tree.expandAllAncestors(p)
                    c.selectPosition(p)
                finally:
                    c.endUpdate()
                    w.setSelectionRange(i,j,insert=j)
                break
    except:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue
#@-node:ekr.20051025071455.46:<< Skip word if ignored or in local dictionary >>
#@-node:ekr.20051025071455.45:findNextMisspelledWord
#@+node:ekr.20051025071455.47:findNextWord
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.headString(),'i',i,'len(s)',len(s))
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.bodyString())
            for w in (self.workCtrl,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
    return None,None
#@nonl
#@-node:ekr.20051025071455.47:findNextWord
#@-node:ekr.20051025071455.40:find & helpers
#@-node:ekr.20070626153304:Fixed spell-check bug
#@-node:ekr.20070626112849:Bugs
#@+node:ekr.20070626150414:Features
#@+node:ekr.20070626150414.1:g.es and g.es_print print only to console during unit tests
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):

    print g.toEncodedString(s,'ascii')

    if g.app.gui and not g.app.gui.isNullGui and not g.unitTesting:
        g.es(s,*args,**keys)
#@+node:ekr.20070621092938:@test g.es_print
if g.unitTesting:
    if 0: # Not usually enabled.
        g.es_print('\ntest of es_print: Ä‚',color='red')
#@-node:ekr.20070621092938:@test g.es_print
#@-node:ekr.20050707064040:es_print & test
#@+node:ekr.20070626132332:es
def es(s,*args,**keys):
    # print 'es','app.log',repr(app.log),'log.isNull',not app.log or app.log.isNull,repr(s)
    log = app.log
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get('color')
    tabName = keys.get('tabName','Log')
        # Default goes to log pane *Not* the presently active pane.
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            s = g.toEncodedString(s,'ascii')
            if newline: print s
            else: print s,
    else:
        if log and log.isNull:
            pass
        elif log:
            # print 'g.es',s
            log.put(s,color=color,tabName=tabName)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl(tabName=tabName) # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@-node:ekr.20070626132332:es
#@-node:ekr.20070626150414.1:g.es and g.es_print print only to console during unit tests
#@+node:ekr.20070626150545:Suppressed status messages during unit testing
#@-node:ekr.20070626150545:Suppressed status messages during unit testing
#@+node:ekr.20070627171855:Run unit tests in a separate process
@nocolor

For full details, see: http://sourceforge.net/forum/forum.php?thread_id=1765685&forum_id=10226

What I did:

- Added support for @unit-tests: the entire tree is copied to the dynamic.leo file
- Put most unit tests in @thin unitTests.txt (with @all).
- Added support for -silent command-line option.  It suppresses most startup messages.
- Modified run-unit-test command so it runs dynamically.
    - The new commands are run-unit-tests, run-all-unit-tests,
      run-unit-tests-locally and run-all-unit-tests-locally.
- Created unit test buttons with Alt-4 and Alt-5 bindings.
- Tell how long it took to create .leo file.
- @testcase not needed: @suite is good enough

@color
#@nonl
#@+node:ekr.20060127162818.1:debugCommandsClass
class debugCommandsClass (baseEditCommandsClass):

    @others
#@+node:ekr.20060127162921: ctor
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
#@-node:ekr.20060127162921: ctor
#@+node:ekr.20060127163325: getPublicCommands
def getPublicCommands (self):

    k = self

    return {
        'collect-garbage':              self.collectGarbage,
        'debug':                        self.debug,
        'disable-gc-trace':             self.disableGcTrace,
        'dump-all-objects':             self.dumpAllObjects,
        'dump-new-objects':             self.dumpNewObjects,
        'enable-gc-trace':              self.enableGcTrace,
        'free-tree-widgets':            self.freeTreeWidgets,
        'print-focus':                  self.printFocus,
        'print-stats':                  self.printStats,
        'print-gc-summary':             self.printGcSummary,
        'run-all-unit-tests':           self.runAllUnitTests, # The new way...
        'run-unit-tests':               self.runUnitTests,
        'run-all-unit-tests-locally':   self.runAllUnitTestsLocally, # The old way...
        'run-unit-tests-locally':       self.runUnitTestsLocally,
        'verbose-dump-objects':         self.verboseDumpObjects,
    }
#@-node:ekr.20060127163325: getPublicCommands
#@+node:ekr.20060205050659:collectGarbage
def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
#@-node:ekr.20060205050659:collectGarbage
#@+node:ekr.20060519003651:debug & helper
def debug (self,event=None):

    '''Start an external debugger in another process to debug the presently selected text.'''

    c = self.c ; p = c.currentPosition()
    python = sys.executable
    # pythonDir = g.os_path_dirname(python)
    script = p.bodyString()
    winpdb = self.findDebugger()
    if not winpdb: return

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    args = [sys.executable, winpdb, '-t', filename]
    os.chdir(g.app.loadDir)
    try:
        import subprocess
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    except ImportError:
        os.chdir(g.app.loadDir)
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213:findDebugger
def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = g.os_path_abspath(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.es('Debugger does not exist: %s' % (debugger),color='blue')
    else:
        g.es('No debugger found.')
        return None
#@-node:ekr.20060521140213:findDebugger
#@-node:ekr.20060519003651:debug & helper
#@+node:ekr.20060202160523:dumpAll/New/VerboseObjects
def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcAll()
    g.app.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcObjects()
    g.app.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.app.trace_gc
    g.app.trace_gc = True
    g.printGcVerbose()
    g.app.trace_gc = old
#@-node:ekr.20060202160523:dumpAll/New/VerboseObjects
#@+node:ekr.20060127163325.1:enable/disableGcTrace
def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.app.trace_gc = True
    g.enable_gc_debug()

    if g.app.trace_gc_verbose:
        g.es('enabled verbose gc stats',color='blue')
    else:
        g.es('enabled brief gc stats',color='blue')
#@-node:ekr.20060127163325.1:enable/disableGcTrace
#@+node:ekr.20060202154734:freeTreeWidgets
def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw_now()
#@-node:ekr.20060202154734:freeTreeWidgets
#@+node:ekr.20060210100432:printFocus
# Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
#@-node:ekr.20060210100432:printFocus
#@+node:ekr.20060205043324.3:printGcSummary
def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
#@-node:ekr.20060205043324.3:printGcSummary
#@+node:ekr.20060202133313:printStats
def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
#@-node:ekr.20060202133313:printStats
#@+node:ekr.20060328121145:runUnitTest commands
def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=True)

def runUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.doTests(c,all=False)

def runAllUnitTests (self,event=None):
    '''Run all unit tests contained in the entire outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=True)

def runUnitTests(self,event=None):
    '''Run all unit tests contained in the presently selected outline.'''
    c = self.c
    leoTest.runTestsExternally(c,all=False)
#@-node:ekr.20060328121145:runUnitTest commands
#@-node:ekr.20060127162818.1:debugCommandsClass
#@+node:ekr.20051104075904.4:doTests...
def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    try:
        g.unitTesting = g.app.unitTesting = True
        g.app.unitTestDict["fail"] = False
        g.app.unitTestDict['c'] = c
        g.app.unitTestDict['g'] = g
        g.app.unitTestDict['p'] = p and p.copy()
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()

        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
        for p in theIter:
            if isTestNode(p): # @test
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p): # @suite
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
            # elif isTestCaseNode(p): # @testcase or @test-case
                # test = makeTestClass(c,p)
                # if test: suite.addTest(test)

        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
    finally:
        c.setChanged(changed) # Restore changed state.
        c.selectPosition(p1)
        g.unitTesting = g.app.unitTesting = False
#@+node:ekr.20051104075904.5:class generalTestCase
class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@+node:ekr.20051104075904.6:__init__
def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
#@-node:ekr.20051104075904.6:__init__
#@+node:ekr.20051104075904.7: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
#@-node:ekr.20051104075904.7: fail
#@+node:ekr.20051104075904.8:setUp
def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
#@-node:ekr.20051104075904.8:setUp
#@+node:ekr.20051104075904.9:tearDown
def tearDown (self):

    pass

    # To do: restore the outline.
#@-node:ekr.20051104075904.9:tearDown
#@+node:ekr.20051104075904.10:runTest
def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p}
    else:
        d = {}

    # Execute the script. Let unit test handle any errors!
    if 0: # debug
        import pdb
        pdb.run(script+'\n',d)
    else:
        exec script + '\n' in d
#@-node:ekr.20051104075904.10:runTest
#@+node:ekr.20051104075904.11:shortDescription
def shortDescription (self):

    return self.p.headString() + '\n'
#@-node:ekr.20051104075904.11:shortDescription
#@-node:ekr.20051104075904.5:class generalTestCase
#@+node:ekr.20051104075904.12:makeTestSuite
@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""

    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None
#@-node:ekr.20051104075904.12:makeTestSuite
#@+node:ekr.20051104075904.13:makeTestCase
def makeTestCase (c,p):

    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None
#@-node:ekr.20051104075904.13:makeTestCase
#@-node:ekr.20051104075904.4:doTests...
#@+node:ekr.20070627135407:runTestsExternally & helper class
def runTestsExternally (c,all):

    @others

    runner = runTestHelperClass(c,all)
    runner.runTests()
#@nonl
#@+node:ekr.20070627140344:class runTestHelperClass
class runTestHelperClass:

    '''A helper class to run tests externally.'''

    @others
#@+node:ekr.20070627140344.1: ctor: runTestHelperClass
def __init__(self,c,all):

    self.c = c
    self.all = all

    self.fileName = 'dynamicUnitTest.leo'

    self.tags = ('@test','@suite','@unittests','@unit-tests') # '@testcase','test-case'
#@-node:ekr.20070627140344.1: ctor: runTestHelperClass
#@+node:ekr.20070627135336.10:createFileFromOutline
def createFileFromOutline (self,c2):

    '''Write c's outline to test/dynamicUnitTest.leo.'''

    path = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test', self.fileName))

    c2.selectPosition(c2.rootPosition())
    c2.mFileName = path
    c2.fileCommands.save(path)
    c2.close()
#@-node:ekr.20070627135336.10:createFileFromOutline
#@+node:ekr.20070627135336.9:createOutline
def createOutline (self,c2):

    '''Create a unit test ouline containing all @test and @suite nodes in p's outline.'''

    c = self.c
    c2root = c2.rootPosition()
    c2root.initHeadString('All unit tests')
    c2.suppressHeadChanged = True # Suppress all onHeadChanged logic.
    c2.beginUpdate()
    if self.all:
        p = c.rootPosition() ; limit_p = None
    else:
        p = c.currentPosition() ; limit_p = p.nodeAfterTree()
    try:
        c2root.expand()
        while p and p != limit_p:
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    # print h
                    p2 = p.copyTreeAfter()
                    p2.unlink()
                    p2.moveToLastChildOf(c2root)
                    p.moveToNodeAfterTree()
                    break
            else:
                p.moveToThreadNext()
    finally:
        c2.endUpdate(False)
#@-node:ekr.20070627135336.9:createOutline
#@+node:ekr.20070627140344.2:runTests
def runTests (self):

    '''
    Create dynamicUnitTest.leo, then run all tests from dynamicUnitTest.leo in a separate process.
    '''

    trace = False
    if trace: import time
    g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
    print 'creating: %s' % (self.fileName)
    c = self.c ; p = c.currentPosition()
    if trace: t1 = time.time()
    found = self.searchOutline(p.copy())
    if trace:
         t2 = time.time() ; print 'find:  %0.2f' % (t2-t1)
    if found:
        gui = leoGui.nullGui("nullGui")
        c2 = c.new(gui=gui)
        if trace:
            t3 = time.time() ; print 'gui:   %0.2f' % (t3-t2)
        found = self.createOutline(c2)
        if trace:
            t4 = time.time() ; print 'copy:  %0.2f' % (t4-t3)
        self.createFileFromOutline(c2)
        if trace:
            t5 = time.time() ; print 'write: %0.2f' % (t5-t4)
        self.runLeoDynamicTest()
        if trace:
            t6 = time.time() ; print 'run:   %0.2f' % (t6-t5)
        c.selectPosition(p.copy())
    else:
        g.es_print('no @test or @suite nodes in selected outline')
#@-node:ekr.20070627140344.2:runTests
#@+node:ekr.20070627135336.11:runLeoDynamicTest
def runLeoDynamicTest (self):

    '''Run test/leoDynamicTest.py in a pristine environment.'''

    path = g.os_path_abspath(g.os_path_join(
        g.app.loadDir, '..', 'test', 'leoDynamicTest.py'))

    args = [sys.executable, path, '--silent']

    srcDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','src'))
    os.chdir(srcDir)

    os.spawnve(os.P_NOWAIT,sys.executable,args,os.environ)
#@-node:ekr.20070627135336.11:runLeoDynamicTest
#@+node:ekr.20070627135336.8:searchOutline
def searchOutline (self,p):

    c = self.c ; p = c.currentPosition()
    iter = g.choose(self.all,c.allNodes_iter,p.self_and_subtree_iter)

    # First, look down the tree.
    for p in iter():
        h = p.headString()
        for s in self.tags:
            if h.startswith(s):
                return True

    # Next, look up the tree.
    if not self.all:   
        for p in c.currentPosition().parents_iter():
            h = p.headString()
            for s in self.tags:
                if h.startswith(s):
                    c.selectPosition(p)
                    #c.redraw()
                    return True

    return False
#@-node:ekr.20070627135336.8:searchOutline
#@-node:ekr.20070627140344:class runTestHelperClass
#@-node:ekr.20070627135407:runTestsExternally & helper class
#@-node:ekr.20070627171855:Run unit tests in a separate process
#@+node:ekr.20070627211053:Move most unit tests into derived files
@
It is essential to rotect them with::

     if g.unitTesting:

A new unit test ensures that this is so.
#@nonl
#@-node:ekr.20070627211053:Move most unit tests into derived files
#@+node:ekr.20070628104735:Send can not import aspell message only to the log
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4382336
By: rich_ries

>> Offhand, I don't have a great solution to this.
>> Anyone have an idea?

The rst3 plugin sends its error message solely to the console; can not
the spell-check do the same?
#@-node:ekr.20070628104735:Send can not import aspell message only to the log
#@-node:ekr.20070626150414:Features
#@-node:ekr.20070626112754.1:Leo 4.4.3 beta 1 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
