#@+leo-ver=4-thin
#@+node:ekr.20070627083814.1:@thin unitTests.txt
#@+all
#@+node:ekr.20070627082507:Not used
#@+node:ekr.20070627112721:Annoying
#@+node:ekr.20070627082044.909:Tests of script buttons
#@+node:ekr.20070627082044.910:@@button test-at-button-node
# Do not delete this button.  It is needed for unit tests.

# Careful: the command gets truncated as well as the button text.
#@-node:ekr.20070627082044.910:@@button test-at-button-node
#@+node:ekr.20070627082044.911:@@test script buttons create commands
# Only the button text gets truncated.

assert c.commandsDict.get('test-at-button-node'), 'no test-at-button-node command'
assert c.commandsDict.get('delete-test-at-button-node-button'), 'no delete-test-at-button-node-button command'

# print c.commandsDict.get('test-at-button')
#@-node:ekr.20070627082044.911:@@test script buttons create commands
#@-node:ekr.20070627082044.909:Tests of script buttons
#@+node:ekr.20070627082044.146:@@command unit-test-command1
g.es_print('Test of @command')
g.app.unitTestDict ['unit-test-command1'] = True
#@nonl
#@-node:ekr.20070627082044.146:@@command unit-test-command1
#@+node:ekr.20070627082044.905:@xx test checkAllPythonCode
result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result
#@nonl
#@-node:ekr.20070627082044.905:@xx test checkAllPythonCode
#@-node:ekr.20070627112721:Annoying
#@+node:ekr.20070627103358:Fail
#@+node:ekr.20070627084952.1:Does not work when copied
#@clone 2
#@+node:ekr.20070627082044.677:@@test markClones
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markClones()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20070627082044.677:@@test markClones
#@-node:ekr.20070627084952.1:Does not work when copied
#@+node:ekr.20070627084952:Contains @thin nodes
#@+node:ekr.20070627082044.126:@@test read from string
@color
@language python
@tabwidth -4

import sys
if sys.platform.startswith('win'):

    input = p.firstChild()
    assert input, 'no Input node'
    result = input.next()
    assert result,'no Result node'
    expected = result.next()
    assert expected,'no Expected node'
    s = input.bodyString()

    c.atFileCommands.read(result,thinFile=True,fromString=s)

    try:
        p1 = result.firstChild()
        p2 = expected.firstChild()
        for p in p1.self_and_subtree_iter():
            assert p.headString() == p2.headString(),p.headString()
            assert p.bodyString() == p2.bodyString(),'body failed'
            p2.moveToThreadNext()
        c.selectVnode(result.firstChild(),updateBeadList=False)
        c.deleteOutline()
    except AssertionError:
        c.selectVnode(result.firstChild(),updateBeadList=False)
        raise
#@nonl
#@+node:ekr.20070627082044.127:Input
#@verbatim
#@+leo-ver=4-thin
#@verbatim
#@+node:ekr.20041001111106:@thin c:\prog\test\at-file-thin-test2.txt
# root line 1

#@verbatim
#@+others
#@verbatim
#@+node:ekr.20041001111106.1:node 1
# node 1 line 1

#@verbatim
#@<< node 1 ref >>
#@verbatim
#@+node:ekr.20041001111106.2:<< node 1 ref >>
# node 1 ref line 1

#@verbatim
#@+others
#@verbatim
#@+node:ekr.20041001111106.3:child node 1
#@verbatim
#@-node:ekr.20041001111106.3:child node 1
#@verbatim
#@+node:ekr.20041001111106.4:child node 2
#@verbatim
#@-node:ekr.20041001111106.4:child node 2
#@verbatim
#@-others
#@verbatim
#@nonl
#@verbatim
#@-node:ekr.20041001111106.2:<< node 1 ref >>
#@verbatim
#@nl

# node 1 last line
#@verbatim
#@nonl
#@verbatim
#@-node:ekr.20041001111106.1:node 1
#@verbatim
#@-others

# root after at-others

#@verbatim
#@<< ref >>
#@verbatim
#@+node:ekr.20041001111106.5:<< ref >>
# ref line 1

#@verbatim
#@+others
#@verbatim
#@+node:ekr.20041001111106.6:organizer node
# text of organizer node
#@verbatim
#@nonl
#@verbatim
#@+node:ekr.20041001111106.7:ref child 1
#@verbatim
#@-node:ekr.20041001111106.7:ref child 1
#@verbatim
#@+node:ekr.20041001111106.8:ref child 2
#@verbatim
#@-node:ekr.20041001111106.8:ref child 2
#@verbatim
#@-node:ekr.20041001111106.6:organizer node
#@verbatim
#@-others
#@verbatim
#@nonl
#@verbatim
#@-node:ekr.20041001111106.5:<< ref >>
#@verbatim
#@nl
#@verbatim
#@-node:ekr.20041001111106:@thin c:\prog\test\at-file-thin-test2.txt
#@verbatim
#@-leo
#@-node:ekr.20070627082044.127:Input
#@+node:ekr.20070627082044.128:Result
#@-node:ekr.20070627082044.128:Result
#@+node:ekr.20070627082044.129:Expected
#@+node:ekr.20070627082044.130:@@@thin c:\prog\test\at-file-thin-test2.txt
# root line 1

@others

# root after at-others

<< ref >>
#@+node:ekr.20070627082044.131:node 1
# node 1 line 1

<< node 1 ref >>

# node 1 last line
#@nonl
#@+node:ekr.20070627082044.132:<< node 1 ref >>
# node 1 ref line 1

@others
#@nonl
#@+node:ekr.20070627082044.133:child node 1
#@-node:ekr.20070627082044.133:child node 1
#@+node:ekr.20070627082044.134:child node 2
#@-node:ekr.20070627082044.134:child node 2
#@-node:ekr.20070627082044.132:<< node 1 ref >>
#@-node:ekr.20070627082044.131:node 1
#@+node:ekr.20070627082044.135:<< ref >>
# ref line 1

@others
#@nonl
#@+node:ekr.20070627082044.136:organizer node
# text of organizer node
#@nonl
#@+node:ekr.20070627082044.137:ref child 1
#@-node:ekr.20070627082044.137:ref child 1
#@+node:ekr.20070627082044.138:ref child 2
#@-node:ekr.20070627082044.138:ref child 2
#@-node:ekr.20070627082044.136:organizer node
#@-node:ekr.20070627082044.135:<< ref >>
#@-node:ekr.20070627082044.130:@@@thin c:\prog\test\at-file-thin-test2.txt
#@-node:ekr.20070627082044.129:Expected
#@-node:ekr.20070627082044.126:@@test read from string
#@+node:ekr.20070627082044.807:@@thin ../test/unittest/errorTest.py
#@+node:ekr.20070627082044.808:@thin ../test/unittest/errorTest.py
# A file that contains functions with errors in them.
# This is used to test error reporting in scripts

@language python
@tabwidth -4

def testIndexError():

    a = []
    b = a[2]
#@nonl
#@-node:ekr.20070627082044.808:@thin ../test/unittest/errorTest.py
#@-node:ekr.20070627082044.807:@@thin ../test/unittest/errorTest.py
#@+node:ekr.20070627082044.809:Batch mode tests...
#@+node:ekr.20070627082044.810:@@thin ../test/unittest/batchTest.py
#@+node:ekr.20070627082044.811:@thin ../test/unittest/batchTest.py
# A file to be executed in batch mode as part of unit testing.

@language python
@tabwidth -4

path = g.os_path_join(g.app.loadDir,"..","test","unittest","createdFile.txt")

if 0:
    print "creating", path

f = None
try:
    try:
        f = open(path,"w")
        f.write("This is a test")
    except IOError:
        g.es("Can not create", path)
finally:
    if f:
        f.close()
#@nonl
#@-node:ekr.20070627082044.811:@thin ../test/unittest/batchTest.py
#@-node:ekr.20070627082044.810:@@thin ../test/unittest/batchTest.py
#@+node:ekr.20070627082044.812:@@test batch mode
import os
import sys

verbose = False

python_interp = sys.executable
test_path = g.os_path_join(g.app.loadDir,"..","test","unittest")
src_path  = g.os_path_join(g.app.loadDir,"..","src")

leo_file   = g.os_path_join(src_path,"leo.py")
batch_file = g.os_path_join(test_path,"batchTest.py")
test_file  = g.os_path_join(test_path,"createdFile.txt")

# Execute this command: python leo.py -script test\unittest\batchTest.py

command = r"%s %s -script %s" % (python_interp,leo_file,batch_file)

@others

removeFile(test_file,verbose)
os.system(command)

try:
    g.redirectStdout()
    removeFile(test_file,verbose)
    os.system(command)
finally:
    g.restoreStdout()

assert(g.os_path_exists(test_file))
#@nonl
#@+node:ekr.20070627082044.813:removeFile
def removeFile(path,verbose):

    if os.path.exists(test_file):
        if verbose:
            print "@test batch mode: deleting",test_file
        os.remove(test_file)
    else:
        if verbose:
            print "@test batch mode: not found:",test_file
#@-node:ekr.20070627082044.813:removeFile
#@-node:ekr.20070627082044.812:@@test batch mode
#@-node:ekr.20070627082044.809:Batch mode tests...
#@+node:ekr.20070627082044.108:@@test @thin
import leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20070627082044.109:#@thin
Line 1

@last last line 1: no newline
#@nonl
#@-node:ekr.20070627082044.109:#@thin
#@+node:ekr.20070627082044.110:Output
#@verbatim
#@+leo-ver=4-thin
#@verbatim
#@+node:ekr.20040707141957.13:#@thin
Line 1

#@verbatim
#@@last
#@verbatim
#@nonl
#@verbatim
#@-node:ekr.20040707141957.13:#@thin
#@verbatim
#@-leo
last line 1: no newline
#@nonl
#@-node:ekr.20070627082044.110:Output
#@-node:ekr.20070627082044.108:@@test @thin
#@-node:ekr.20070627084952:Contains @thin nodes
#@+node:ekr.20070627082044.561:@@test newline-and-indent
import leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20070627082044.562:work
#@-node:ekr.20070627082044.562:work
#@+node:ekr.20070627082044.563:before sel=2.6,2.6
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20070627082044.563:before sel=2.6,2.6
#@+node:ekr.20070627082044.564:after sel=3.1,3.1
first line
line 1

    line a
        line b
line c
last line
#@-node:ekr.20070627082044.564:after sel=3.1,3.1
#@-node:ekr.20070627082044.561:@@test newline-and-indent
#@+node:ekr.20070627082044.934:@@test visback
p1 = p.copy()
a = p.firstChild()
b = a.firstChild()
c2 = b.firstChild()
limit = a.next()
d = limit.firstChild()
e = limit.next()
assert e.headString() == 'e'
for p2,h in ((a,'a'),(b,'b'),(c2,'c2'),(d,'d'),(limit,'limit')):
    p2.expand()
    assert p2.headString()==h,'headString mismatch'

try: # Tests without hoist...
    p1.expand()
    assert not c.hoistStack
    c.selectPosition(limit)
    result = limit.copy().moveToVisBack(c)
    assert result==c2,'visBack != c2: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'visNext != d: %s' % result
finally:
    p1.contract()

try: # Tests with hoist.
    p1.expand()
    c.selectPosition(limit)
    c.hoist()
    result = limit.copy().moveToVisBack(c)
    assert not result,'limited visBack: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'limited visNext !=d: %s' % result
finally:
    c.dehoist()
    c.selectPosition(p1)
    p1.contract()
    c.redraw_now()
#@+node:ekr.20070627082044.935:a
#@+node:ekr.20070627082044.936:b
#@+node:ekr.20070627082044.937:c2
#@-node:ekr.20070627082044.937:c2
#@-node:ekr.20070627082044.936:b
#@-node:ekr.20070627082044.935:a
#@+node:ekr.20070627082044.938:limit
#@+node:ekr.20070627082044.939:d
#@-node:ekr.20070627082044.939:d
#@-node:ekr.20070627082044.938:limit
#@+node:ekr.20070627082044.940:e
#@-node:ekr.20070627082044.940:e
#@-node:ekr.20070627082044.934:@@test visback
#@+node:ekr.20070627082044.841:@@test bogus tnodeList doesn't corrupt @thin nodes
import leoTest

u = leoTest.testUtils(c)
h = "@thin leoTest.py"
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h

p.v.t.tnodeList = ["bogus tnodeList"]

if 0: # This causes p to be written, thereby clearing the tnodeList.
    p.setDirty()

if 0: # This actually saves this file, so it is a bit dangerous.
    g.app.unitTestDict = {}
    # c.save()
    ok = g.app.unitTestDict.get("warning")
    assert ok, "putVnode failed to give warning"
#@nonl
#@-node:ekr.20070627082044.841:@@test bogus tnodeList doesn't corrupt @thin nodes
#@-node:ekr.20070627103358:Fail
#@+node:ekr.20070627082044.922:@@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.
import leoTest
u = leoTest.testUtils(c)

c.beginUpdate()
try:
    c.contractParent()
    c.selectPosition(p.parent())
    g.app.unitTestDict['restoreSelectedNode']=False
finally:
    c.endUpdate()

print ; print 'End of general unit tests'
#@nonl
#@-node:ekr.20070627082044.922:@@test zz restore the screen
#@-node:ekr.20070627082507:Not used
#@+node:ekr.20070628110656:@unit-tests Can not be in derived files
#@+node:ekr.20070629065730:Contain clones
#@+node:ekr.20070627082044.861:inner @test: Test consistency between parents iter and v.parents
# The actual test is in a child node.
#@nonl
#@clone 2
#@+node:ekr.20070627082044.862:parent
#@-node:ekr.20070627082044.862:parent
#@-node:ekr.20070627082044.861:inner @test: Test consistency between parents iter and v.parents
#@-node:ekr.20070629065730:Contain clones
#@+node:ekr.20070629065730.1:Contain non-python code
#@+node:ekr.20070630070931:leoNodes (2 fail)
#@-node:ekr.20070630070931:leoNodes (2 fail)
#@+node:ekr.20070630070931.1:commands (8 fail)
#@+node:ekr.20070627082044.684:@suite Edit body tests
# Create unit tests in g.app.scriptDict["suite"]

import leoTest

g.app.enableUnitTest = True

suite = leoTest.makeEditBodySuite(c)

g.app.scriptDict['suite'] = suite
#@nonl
#@+node:ekr.20070627082044.685:editBodyTests
@language plain

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:

- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
#@nonl
#@+node:ekr.20070627082044.686:tempNode
#@-node:ekr.20070627082044.686:tempNode
#@+node:ekr.20070627082044.687:addComments
#@+node:ekr.20070627082044.688:before
@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@nonl
#@-node:ekr.20070627082044.688:before
#@+node:ekr.20070627082044.689:after
@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
#@nonl
#@-node:ekr.20070627082044.689:after
#@+node:ekr.20070627082044.690:selection
5.0
7.8
#@nonl
#@-node:ekr.20070627082044.690:selection
#@-node:ekr.20070627082044.687:addComments
#@+node:ekr.20070627082044.691:convertAllBlanks
#@+node:ekr.20070627082044.692:before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20070627082044.692:before
#@+node:ekr.20070627082044.693:after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20070627082044.693:after
#@+node:ekr.20070627082044.694:selection
1.0
6.5
#@nonl
#@-node:ekr.20070627082044.694:selection
#@-node:ekr.20070627082044.691:convertAllBlanks
#@+node:ekr.20070627082044.695:convertAllTabs
#@+node:ekr.20070627082044.696:before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20070627082044.696:before
#@+node:ekr.20070627082044.697:after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20070627082044.697:after
#@+node:ekr.20070627082044.698:selection
1.0
6.5
#@nonl
#@-node:ekr.20070627082044.698:selection
#@-node:ekr.20070627082044.695:convertAllTabs
#@+node:ekr.20070627082044.699:convertBlanks
#@+node:ekr.20070627082044.700:before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20070627082044.700:before
#@+node:ekr.20070627082044.701:after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20070627082044.701:after
#@+node:ekr.20070627082044.702:selection
1.0
6.5
#@nonl
#@-node:ekr.20070627082044.702:selection
#@-node:ekr.20070627082044.699:convertBlanks
#@+node:ekr.20070627082044.703:convertTabs
#@+node:ekr.20070627082044.704:before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20070627082044.704:before
#@+node:ekr.20070627082044.705:after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20070627082044.705:after
#@+node:ekr.20070627082044.706:selection
1.0
6.5
#@nonl
#@-node:ekr.20070627082044.706:selection
#@-node:ekr.20070627082044.703:convertTabs
#@+node:ekr.20070627082044.707:dedentBody
#@+node:ekr.20070627082044.708:before
line 1
    line 2
    line 3
line 4
#@nonl
#@-node:ekr.20070627082044.708:before
#@+node:ekr.20070627082044.709:after
line 1
line 2
line 3
line 4
#@nonl
#@-node:ekr.20070627082044.709:after
#@+node:ekr.20070627082044.710:selection
2.0
3.5
#@nonl
#@-node:ekr.20070627082044.710:selection
#@-node:ekr.20070627082044.707:dedentBody
#@+node:ekr.20070627082044.711:deleteComments
#@+node:ekr.20070627082044.712:before
@language python

def deleteCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
#@nonl
#@-node:ekr.20070627082044.712:before
#@+node:ekr.20070627082044.713:after
@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@nonl
#@-node:ekr.20070627082044.713:after
#@+node:ekr.20070627082044.714:selection
5.0
7.8
#@nonl
#@-node:ekr.20070627082044.714:selection
#@-node:ekr.20070627082044.711:deleteComments
#@+node:ekr.20070627082044.715:extract test1
#@+node:ekr.20070627082044.716:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20070627082044.716:before
#@+node:ekr.20070627082044.717:after
before
after
#@nonl
#@+node:ekr.20070627082044.718:<< section >>
sec line 1
    sec line 2 indented
sec line 3
#@nonl
#@-node:ekr.20070627082044.718:<< section >>
#@-node:ekr.20070627082044.717:after
#@+node:ekr.20070627082044.719:selection
2.0
5.10
#@nonl
#@-node:ekr.20070627082044.719:selection
#@-node:ekr.20070627082044.715:extract test1
#@+node:ekr.20070627082044.720:extract test2
#@+node:ekr.20070627082044.721:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20070627082044.721:before
#@+node:ekr.20070627082044.722:after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20070627082044.722:after
#@+node:ekr.20070627082044.723:selection
2.0
2.16
#@nonl
#@-node:ekr.20070627082044.723:selection
#@-node:ekr.20070627082044.720:extract test2
#@+node:ekr.20070627082044.724:extractSection test1
#@+node:ekr.20070627082044.725:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20070627082044.725:before
#@+node:ekr.20070627082044.726:after
before
    << section >>
after
#@nonl
#@+node:ekr.20070627082044.727:<< section >>
sec line 1
    sec line 2 indented
sec line 3
#@nonl
#@-node:ekr.20070627082044.727:<< section >>
#@-node:ekr.20070627082044.726:after
#@+node:ekr.20070627082044.728:selection
2.0
5.10
#@nonl
#@-node:ekr.20070627082044.728:selection
#@-node:ekr.20070627082044.724:extractSection test1
#@+node:ekr.20070627082044.729:extractSection test2
#@+node:ekr.20070627082044.730:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20070627082044.730:before
#@+node:ekr.20070627082044.731:after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20070627082044.731:after
#@+node:ekr.20070627082044.732:selection
2.0
2.16
#@nonl
#@-node:ekr.20070627082044.732:selection
#@-node:ekr.20070627082044.729:extractSection test2
#@-node:ekr.20070627082044.685:editBodyTests
#@-node:ekr.20070627082044.684:@suite Edit body tests
#@+node:ekr.20070627082044.266:@unit-tests Edit commands
#@+node:ekr.20070627082044.279:A-E
#@-node:ekr.20070627082044.279:A-E
#@+node:ekr.20070627082044.444:F-L
#@-node:ekr.20070627082044.444:F-L
#@+node:ekr.20070627082044.538:M-Z
#@+node:ekr.20070627082044.539:@@test zap-to-chararacter
#@+node:ekr.20070627082044.540:work
first line
line 1
    line a
        line b
line c
last line
#@nonl
#@-node:ekr.20070627082044.540:work
#@-node:ekr.20070627082044.539:@@test zap-to-chararacter
#@-node:ekr.20070627082044.538:M-Z
#@-node:ekr.20070627082044.266:@unit-tests Edit commands
#@+node:ekr.20070627082044.639:@unit-tests Import/Export tests...
#@+node:ekr.20070627082044.640:@suite Import tests
# Create unit tests in g.app.scriptDict["suite"]

import unittest
import leoTest

@others

suite = leoTest.makeImportExportSuite(c,"importTests",doImport=True)

g.app.scriptDict['suite'] = suite
#@nonl
#@-node:ekr.20070627082044.640:@suite Import tests
#@+node:ekr.20070627082044.641:@suite Export tests
# Create unit tests in g.app.scriptDict["suite"]

import unittest
import leoTest

@others

suite = leoTest.makeImportExportSuite(c,"exportTests",doImport=False)

g.app.scriptDict['suite'] = suite
#@nonl
#@-node:ekr.20070627082044.641:@suite Export tests
#@+node:ekr.20070627082044.642:importTests
@language plain
#@nonl
#@+node:ekr.20070627082044.643:tempNode
#@-node:ekr.20070627082044.643:tempNode
#@+node:ekr.20070627082044.644:importAtRoot
#@+node:ekr.20070627082044.645:dialog
openFileDialog
test\\unittest\\perfectImport\\formatter.py
#@nonl
#@-node:ekr.20070627082044.645:dialog
#@-node:ekr.20070627082044.644:importAtRoot
#@+node:ekr.20070627082044.646:importDerivedFile
#@+node:ekr.20070627082044.647:dialog
openFileDialog
src\\leo.py
#@nonl
#@-node:ekr.20070627082044.647:dialog
#@-node:ekr.20070627082044.646:importDerivedFile
#@+node:ekr.20070627082044.648:importNowebFiles
#@+node:ekr.20070627082044.649:dialog
openFileDialog
test\\unittest\\input\\noweave.nw.txt
#@nonl
#@-node:ekr.20070627082044.649:dialog
#@-node:ekr.20070627082044.648:importNowebFiles
#@+node:ekr.20070627082044.650:importFlattenedOutline
#@+node:ekr.20070627082044.651:dialog
openFileDialog
test\\unittest\\input\\flat.txt
#@nonl
#@-node:ekr.20070627082044.651:dialog
#@-node:ekr.20070627082044.650:importFlattenedOutline
#@+node:ekr.20070627082044.652:importCWEBFiles
#@+node:ekr.20070627082044.653:dialog
openFileDialog
test\\unittest\\input\\cweave.w
#@nonl
#@-node:ekr.20070627082044.653:dialog
#@-node:ekr.20070627082044.652:importCWEBFiles
#@+node:ekr.20070627082044.654:removeSentinels
#@+node:ekr.20070627082044.655:dialog
openFileDialog
test\\unittest\\input\\testLeoAtFile.py
#@nonl
#@-node:ekr.20070627082044.655:dialog
#@-node:ekr.20070627082044.654:removeSentinels
#@+node:ekr.20070627082044.656:importAtFile
#@+node:ekr.20070627082044.657:dialog
openFileDialog
test\\unittest\\perfectImport\\formatter.py
#@nonl
#@-node:ekr.20070627082044.657:dialog
#@-node:ekr.20070627082044.656:importAtFile
#@-node:ekr.20070627082044.642:importTests
#@+node:ekr.20070627082044.658:exportTests
@language plain
#@nonl
#@+node:ekr.20070627082044.659:tempNode
#@-node:ekr.20070627082044.659:tempNode
#@+node:ekr.20070627082044.660:exportHeadlines
#@+node:ekr.20070627082044.661:dialog
saveFileDialog
test\\unittest\\output\\exportHeadlines.txt
#@nonl
#@-node:ekr.20070627082044.661:dialog
#@-node:ekr.20070627082044.660:exportHeadlines
#@+node:ekr.20070627082044.662:flattenOutline
#@+node:ekr.20070627082044.663:dialog
saveFileDialog
test\\unittest\\output\\flattenOutline.txt
#@nonl
#@-node:ekr.20070627082044.663:dialog
#@-node:ekr.20070627082044.662:flattenOutline
#@+node:ekr.20070627082044.664:weave
#@+node:ekr.20070627082044.665:dialog
saveFileDialog
test\\unittest\\output\\weave.txt
#@nonl
#@-node:ekr.20070627082044.665:dialog
#@-node:ekr.20070627082044.664:weave
#@+node:ekr.20070627082044.666:outlineToNoweb
#@+node:ekr.20070627082044.667:dialog
saveFileDialog
test\\unittest\\output\\outlineToNoweb.txt
#@nonl
#@-node:ekr.20070627082044.667:dialog
#@-node:ekr.20070627082044.666:outlineToNoweb
#@+node:ekr.20070627082044.668:outlineToCWEB
#@+node:ekr.20070627082044.669:dialog
saveFileDialog
test\\unittest\\output\\outlineToCweb.txt
#@nonl
#@-node:ekr.20070627082044.669:dialog
#@-node:ekr.20070627082044.668:outlineToCWEB
#@-node:ekr.20070627082044.658:exportTests
#@-node:ekr.20070627082044.639:@unit-tests Import/Export tests...
#@+node:ekr.20070627082044.144:@unit-tests typing...
# These are mysteriously fragile tests, so they go first
#@+node:ekr.20070627082044.147:Test headline abc
#@-node:ekr.20070627082044.147:Test headline abc
#@+node:ekr.20070627082044.148:Typing and undo tests
#@+node:ekr.20070627082044.168:print end of typing and undo tests
print ; print 'End of typing and undo tests'
#@nonl
#@-node:ekr.20070627082044.168:print end of typing and undo tests
#@-node:ekr.20070627082044.148:Typing and undo tests
#@+node:ekr.20070627082044.169:Not ready yet
#@+node:ekr.20070627082044.170:@@test typing and undo in headline - with selection
# Totally weird.

import leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.redraw_now() # To make node visible
tree.editLabel(p) # Sets focus.
w = c.edit_widget(p)
try:
    assert w
    w.update()
    w.setSelectionRange('1.1','1.2',insert='1.1')
    w.event_generate('X')
    w.event_generate('Y')
    w.event_generate('Z')
    w.event_generate('<Return>')
    print 'after',repr(w.get('1.0','end'))
    print 'end edit'
    expected = h[0] + 'XYZ' + h[2:]
    assert p.headString() == expected,'fail 1: expected "%s" got "%s"' % (
        expected,repr(p.headString()))
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.headString() == h,'fail 2'
finally:
    if 1:
        p.initHeadString(h)
        c.redraw_now()
#@-node:ekr.20070627082044.170:@@test typing and undo in headline - with selection
#@+node:ekr.20070627082044.171:@@test plugins manager stays in front
# Not so easy to do.
import plugin_manager
n = g.app.dialogs
pm = plugin_manager.ManagerDialog()
try:
    assert g.app.dialogs == n
finally:
    if 1:
        pass
#@nonl
#@-node:ekr.20070627082044.171:@@test plugins manager stays in front
#@+node:ekr.20070627082044.172:@@test deleting the last body character text redraws the screen (and icon)
# Not ready yet: generating a backspace seems impossible!

import leoTest ; u = leoTest.testUtils(c)

h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.setBodyString(p,'a')
c.redraw_now() # To make node visible and to set the icon.
try:
    c.bodyWantsFocusNow()
    n = c.frame.tree.redrawCount
    w = c.frame.body.bodyCtrl
    w.setInsertPoint('end')
    w.event_generate('<BackSpace>')
    n2 = c.frame.tree.redrawCount
    assert n2 == n + 1,'too many or too few redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw_now()
#@nonl
#@-node:ekr.20070627082044.172:@@test deleting the last body character text redraws the screen (and icon)
#@+node:ekr.20070627082044.180:@@test paste in headline recomputes width
import leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.redraw_now() # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
try:
    assert w, 'no w'
    w.setSelectionRange('end','end')
    g.app.unitTestDict = {}
    k.manufactureKeyPressForCommandName(w,'paste-text')
    assert g.app.unitTestDict.get('headWidth') == True
finally:
    if 1:
        p.initHeadString(h)
        c.redraw_now()
#@nonl
#@-node:ekr.20070627082044.180:@@test paste in headline recomputes width
#@-node:ekr.20070627082044.169:Not ready yet
#@-node:ekr.20070627082044.144:@unit-tests typing...
#@+node:ekr.20070627082044.733:Reformat Paragraph tests
@ Rewritten by EKR.  April 17, 2005.

Each data node must have three children:

- a "before" node
- an "after" node
- a "tempNode" node

A parent to before and after nodes will contain pagewidth and language formatting directives.
#@-node:ekr.20070627082044.733:Reformat Paragraph tests
#@-node:ekr.20070630070931.1:commands (8 fail)
#@+node:ekr.20070627082044.191:Colorizer
#@-node:ekr.20070627082044.191:Colorizer
#@-node:ekr.20070629065730.1:Contain non-python code
#@+node:ekr.20070703081205:Contain trees that would be inconvenient in a derived file
#@-node:ekr.20070703081205:Contain trees that would be inconvenient in a derived file
#@-node:ekr.20070628110656:@unit-tests Can not be in derived files
#@+node:ekr.20070628121120:@unit-tests General tests: no associated derived file
#@+node:ekr.20070627082044.32:Longer tests (opens windows)
#@+node:ekr.20070627082044.33:Unit tests for  .leo files
@language python
@tabwidth -4
#@nonl
#@-node:ekr.20070627082044.33:Unit tests for  .leo files
#@+node:ekr.20070627082044.39:Unit tests for plugins
# These are now compatible with the other unit tests.
# It may be a bit off-putting to run the two sets together, however...
#@nonl
#@+node:ekr.20070627082044.40:print all loaded plugins
import leoPlugins

print
print 'loaded plugins...'
for p in g.app.loadedPlugins:
    print p

leoPlugins.printHandlers()
#@nonl
#@-node:ekr.20070627082044.40:print all loaded plugins
#@+node:ekr.20070627082044.41:@suite run all plugin test routines
import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.currentPosition()
<< class testRoutineTestCase >>
@others

plugins = getAllPlugins()

# g.printList(plugins)

# print '@suite run all plugin test routines'

if 1:
    g.app.unitTestDict["fail"] = False
    suite = unittest.makeSuite(unittest.TestCase)
    for plugin in plugins:
        n = addTestRoutinesInPluginToSuite(c,g,plugin,suite)
        if n:
            plural = g.choose(n==1,'','s')
            s = 'found %2d test routine%s for %s' % (n,plural,plugin)
            print s ; g.es(s)

    if 1: # For @suite nodes.  Better for unit testing.
        g.app.scriptDict['suite'] = suite
    else: # For script button nodes.  Good for testing.
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=1).run(suite)
        c.setChanged(changed) # Restore changed state.
        c.selectVnode(p1) # N.B. Restore the selected node.
#@nonl
#@+node:ekr.20070627082044.42:<< class testRoutineTestCase >>
class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@nonl
#@+node:ekr.20070627082044.43:__init__
def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.currentPosition().copy()
    self.verbose = verbose
#@-node:ekr.20070627082044.43:__init__
#@+node:ekr.20070627082044.44: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
#@nonl
#@-node:ekr.20070627082044.44: fail
#@+node:ekr.20070627082044.45:runTest
def runTest (self):

    f = self.f ; name = f.__name__ ; theClass = self.theClass

    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)

        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec s in d # Execute s in a environment containing c, g and p.

    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)
#@nonl
#@-node:ekr.20070627082044.45:runTest
#@+node:ekr.20070627082044.46:shortDescription
def shortDescription (self):

    return 'test function',repr(self.f)
#@nonl
#@-node:ekr.20070627082044.46:shortDescription
#@-node:ekr.20070627082044.42:<< class testRoutineTestCase >>
#@+node:ekr.20070627082044.47:addTestRoutinesInPluginToSuite
def addTestRoutinesInPluginToSuite (c,g,pluginName,suite):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))

    plugin = g.importFromPath(pluginName,path,verbose=True)
    if not plugin:
        return len([])

    tests = findTestsInModule(plugin,pluginName)

    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,pluginName,theClass,f,code,verbose=False)
        suite.addTest(testCase)

    return len(tests)
#@-node:ekr.20070627082044.47:addTestRoutinesInPluginToSuite
#@+node:ekr.20070627082044.48:findTestsInModule
def findTestsInModule (module,moduleName):

    # g.trace(moduleName)

    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]

    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            # This looks like a bug in inspect: The zodb classes have no methods.
            # g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # print '\nmethods of class %s...\n\n%s' % (theClass,toString(methods))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    # Hack: remove duplicate tests from leoGlobals.py.
    functions = [(None,f) for name,f in functions
        if name.startswith('test_') and not name.startswith('test_g_')]

    if 0:
        << print classes, methods & functions >>

    result = functions
    result.extend(allMethods)
    return result
#@nonl
#@+node:ekr.20070627082044.49:<< print classes, methods & functions >>
print '=' * 40

if classes:
    print 'classes in %s...\n%s' % (moduleName,toString(classes))
else:
    print 'no classes in %s' % (moduleName)
if allMethods:
    print 'test methods in %s...\n%s'   % (moduleName,toString(allMethods))
else:
    print 'no test methods in %s' % (moduleName)
if functions:
    print 'test functions in %s...\n%s' % (moduleName,toString(functions))
else:
    print 'no test functions in %s' % (moduleName)
#@nonl
#@-node:ekr.20070627082044.49:<< print classes, methods & functions >>
#@-node:ekr.20070627082044.48:findTestsInModule
#@+node:ekr.20070627082044.50:getAllPlugins
def getAllPlugins ():

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    # g.trace(path)

    files = glob.glob(g.os_path_join(path,"*.py"))
    files = [g.os_path_abspath(f) for f in files]
    files = [str(g.shortFileName(f)) for f in files]
    files.sort()
    plugins = [g.os_path_splitext(f)[0] for f in files]

    # g.trace(g.listToString(plugins))
    return plugins
#@nonl
#@-node:ekr.20070627082044.50:getAllPlugins
#@+node:ekr.20070627082044.51:removeLeadingWs
def removeLeadingWs (code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            print 'unitTest.leo:underindented line:%s' % repr(line)
            result.append(line)

    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result
#@-node:ekr.20070627082044.51:removeLeadingWs
#@-node:ekr.20070627082044.41:@suite run all plugin test routines
#@+node:ekr.20070627082044.52:@@suite plugins tests
# Create unit tests in g.app.scriptDict["suite"]
import leoPlugins
import leoTest
import glob
import sys
import unittest

@others

suite = makePluginsTestSuite(c)

g.app.scriptDict['suite'] = suite
#@nonl
#@+node:ekr.20070627082044.53:makePluginsTestSuite
def makePluginsTestSuite(c):

    '''Create a plugin test for .py file in the plugins directory'''

    # Create the suite.
    suite = unittest.makeSuite(unittest.TestCase)

    # Add a test case for every plugin.
    plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
    plugins = g.os_path_abspath(plugins)
    files = glob.glob(plugins)
    files = [g.os_path_abspath(f) for f in files]
    files.sort()

    for f in files:
        test = pluginTestCase(c,f)
        # g.trace(test.shortDescription())
        suite.addTest(test)

    if 1:
        # Open a new window after all tests are completed.  Tests many plugins.
        lastTest = lastTestCase(c,openFlag=True)
        suite.addTest(lastTest)

    return suite
#@nonl
#@-node:ekr.20070627082044.53:makePluginsTestSuite
#@+node:ekr.20070627082044.54:class pluginTestCase
class pluginTestCase(unittest.TestCase):

    '''A test case to test a single Leo plugin.'''

    @others
#@nonl
#@+node:ekr.20070627082044.55:__init__
def __init__ (self,c,path):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
#@nonl
#@-node:ekr.20070627082044.55:__init__
#@+node:ekr.20070627082044.56:fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
#@nonl
#@-node:ekr.20070627082044.56:fail
#@+node:ekr.20070627082044.57:runTest
def runTest(self):

    c = self.c ; path = self.path

    path,file = g.os_path_split(path)
    moduleName,ext  = g.os_path_splitext(file)
    module = sys.modules.get(moduleName)

    if not module:
        module = leoPlugins.loadOnePlugin(moduleName,verbose=False)
        assert module, 'can not import %s' % moduleName
#@nonl
#@-node:ekr.20070627082044.57:runTest
#@+node:ekr.20070627082044.58:setUp
def setUp(self):

    g.app.unitTestDict = {}
#@nonl
#@-node:ekr.20070627082044.58:setUp
#@+node:ekr.20070627082044.59:shortDescription
def shortDescription (self):

    return "pluginTestCase: %s" % g.shortFileName(self.path)
#@nonl
#@-node:ekr.20070627082044.59:shortDescription
#@-node:ekr.20070627082044.54:class pluginTestCase
#@+node:ekr.20070627082044.60:class lastTestCase
class lastTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''

    def __init__ (self,c,openFlag):
        # Init the base class.
        unittest.TestCase.__init__(self)
        self.c = c
        self.openFlag = openFlag

    def runTest(self):
        c = self.c
        print
        print '%s a new window to test more plugin logic' % g.choose(
            self.openFlag,'opening','open')
        print
        if self.openFlag:
            self.new_c = new_c = c.new() # Create the new window.
            new_c.frame.setTitle("unit test for 'new' hook")

    if 0: # Doesn't work
        def shutDown(self):
            c = self.new_c
            c.close()
#@nonl
#@-node:ekr.20070627082044.60:class lastTestCase
#@-node:ekr.20070627082044.52:@@suite plugins tests
#@+node:ekr.20070627082044.61:@suite test syntax of all plugins
# N.B.  We don't import the files: multiple imports might cause problems.
import unittest
import leoTest

@others

# print '@suite test syntax of all plugins'

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():

    f = file(path)
    assert f, "File not found: %s" % path
    s = f.read() ; f.close()
    test = parseFileTestCase(c,path,checkCompile=True,checkTabs=True)
    suite.addTest(test)

if suite:
    g.app.scriptDict['suite'] = suite
#@nonl
#@+node:ekr.20070627082044.62:class parseFileTestCase
class parseFileTestCase (unittest.TestCase):

    @others
#@nonl
#@+node:ekr.20070627082044.63:__init__
def __init__ (self,c,path,checkCompile,checkTabs):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.checkCompile = checkCompile
    self.checkTabs = checkTabs
    assert self.checkCompile or self.checkTabs, "not checking anything"
#@nonl
#@-node:ekr.20070627082044.63:__init__
#@+node:ekr.20070627082044.64:runTest
def runTest(self):

    c = self.c ; path = self.path

    s = file(path).read()

    if self.checkCompile:
        leoTest.checkFileSyntax(path,s)

    if self.checkTabs:
        leoTest.checkFileTabs(path,s)
#@nonl
#@-node:ekr.20070627082044.64:runTest
#@+node:ekr.20070627082044.65:shortDescription
def shortDescription (self):

    fn = str(g.shortFileName(self.path))

    if self.checkCompile and self.checkTabs:
        return "Test syntax and tabbing of %s plugin" % fn
    elif self.checkCompile:
        return "Test syntax of %s plugin" % fn
    else:
        return "Test tabbing of %s plugin" % fn
#@nonl
#@-node:ekr.20070627082044.65:shortDescription
#@-node:ekr.20070627082044.62:class parseFileTestCase
#@-node:ekr.20070627082044.61:@suite test syntax of all plugins
#@+node:ekr.20070627082044.66:@@test print All plugins tests complete
print '\nAll plugins tests complete.'
#@nonl
#@-node:ekr.20070627082044.66:@@test print All plugins tests complete
#@-node:ekr.20070627082044.39:Unit tests for plugins
#@+node:ekr.20070627082044.68:Tests of minimal .leo files
#@-node:ekr.20070627082044.68:Tests of minimal .leo files
#@-node:ekr.20070627082044.32:Longer tests (opens windows)
#@+node:ekr.20070627082044.141:Doctests
#@+node:ekr.20070627082044.142:@suite run all doctests
import unittest
import leoTest

import sys

# DocTestSuite exists in Python 2.3 and above.

version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
if g.CheckVersion(version, "2.3"):

    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)

    suite = leoTest.createUnitTestsFromDoctests(modules)

    if suite:
        g.app.scriptDict['suite'] = suite

else:
    # Create an empty suite to suppress a warning.
    g.app.scriptDict['suite'] = unittest.TestSuite()
    print
    print "Can't create unit tests from doctests"
    print "doctest.DocTestSuite requires Python 2.3 or above."
    print
#@nonl
#@-node:ekr.20070627082044.142:@suite run all doctests
#@-node:ekr.20070627082044.141:Doctests
#@+node:ekr.20070627082044.182:Check base classes & ivars
#@-node:ekr.20070627082044.182:Check base classes & ivars
#@+node:ekr.20070627082044.912:Unicode tests...
#@-node:ekr.20070627082044.912:Unicode tests...
#@+node:ekr.20070627082044.923:Shorter Unit tests for plugins
#@+node:ekr.20070627082044.925:detect_urls.py
#@-node:ekr.20070627082044.925:detect_urls.py
#@-node:ekr.20070627082044.923:Shorter Unit tests for plugins
#@+node:ekr.20070627082044.73:File read/write tests...
#@+node:ekr.20070627082044.88:leoFileCommands.py tests...
#@-node:ekr.20070627082044.88:leoFileCommands.py tests...
#@+node:ekr.20070627082044.98:Tests of @file nodes...
@color
#@nonl
#@-node:ekr.20070627082044.98:Tests of @file nodes...
#@-node:ekr.20070627082044.73:File read/write tests...
#@-node:ekr.20070628121120:@unit-tests General tests: no associated derived file
#@-all
#@nonl
#@-node:ekr.20070627083814.1:@thin unitTests.txt
#@-leo
