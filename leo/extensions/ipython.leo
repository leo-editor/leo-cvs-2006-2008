<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="1937" clone_windows="0"/>
<globals body_outline_ratio="0.584988962472">
	<global_window_position top="34" left="262" height="906" width="970"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20050708080801"><vh>Read Me or suffer</vh>
<v t="ekr.20050708080512.1"><vh>Copywrite</vh></v>
</v>
<v t="ekr.20050704164036"><vh>Original sources</vh>
<v t="ekr.20050704170205.2"><vh>ctypes: c:/Python24/Lib/site-packages/ctypes/</vh>
<v t="ekr.20050704170205.3"><vh>wintypes.py</vh>
<v t="ekr.20050704170205.4"><vh>&lt;&lt; wintypes declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.5"><vh>class RECT</vh>
<v t="ekr.20050704170205.6"><vh>&lt;&lt; class RECT declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.7"><vh>class POINT</vh>
<v t="ekr.20050704170205.8"><vh>&lt;&lt; class POINT declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.9"><vh>class SIZE</vh>
<v t="ekr.20050704170205.10"><vh>&lt;&lt; class SIZE declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.11"><vh>RGB</vh></v>
<v t="ekr.20050704170205.12"><vh>class FILETIME</vh>
<v t="ekr.20050704170205.13"><vh>&lt;&lt; class FILETIME declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.14"><vh>class MSG</vh>
<v t="ekr.20050704170205.15"><vh>&lt;&lt; class MSG declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.16"><vh>class WIN32_FIND_DATAA</vh>
<v t="ekr.20050704170205.17"><vh>&lt;&lt; class WIN32_FIND_DATAA declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.18"><vh>__init__.py</vh>
<v t="ekr.20050704170205.19"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.20"><vh>create_string_buffer</vh></v>
<v t="ekr.20050704170205.21"><vh>c_buffer</vh></v>
<v t="ekr.20050704170205.22"><vh>CFUNCTYPE</vh></v>
<v t="ekr.20050704170205.23"><vh>WINFUNCTYPE</vh></v>
<v t="ekr.20050704170205.24"><vh>class py_object</vh>
<v t="ekr.20050704170205.25"><vh>&lt;&lt; class py_object declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.26"><vh>class c_short</vh>
<v t="ekr.20050704170205.27"><vh>&lt;&lt; class c_short declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.28"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.29"><vh>class c_ushort</vh>
<v t="ekr.20050704170205.30"><vh>&lt;&lt; class c_ushort declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.31"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.32"><vh>class c_long</vh>
<v t="ekr.20050704170205.33"><vh>&lt;&lt; class c_long declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.34"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.35"><vh>class c_ulong</vh>
<v t="ekr.20050704170205.36"><vh>&lt;&lt; class c_ulong declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.37"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.38"><vh>class c_int</vh>
<v t="ekr.20050704170205.39"><vh>&lt;&lt; class c_int declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.40"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.41"><vh>class c_uint</vh>
<v t="ekr.20050704170205.42"><vh>&lt;&lt; class c_uint declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.43"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.44"><vh>class c_float</vh>
<v t="ekr.20050704170205.45"><vh>&lt;&lt; class c_float declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.46"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.47"><vh>class c_double</vh>
<v t="ekr.20050704170205.48"><vh>&lt;&lt; class c_double declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.49"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.50"><vh>class c_longlong</vh>
<v t="ekr.20050704170205.51"><vh>&lt;&lt; class c_longlong declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.52"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.53"><vh>class c_ulonglong</vh>
<v t="ekr.20050704170205.54"><vh>&lt;&lt; class c_ulonglong declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.55"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.56"><vh>class c_ubyte</vh>
<v t="ekr.20050704170205.57"><vh>&lt;&lt; class c_ubyte declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.58"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.59"><vh>class c_byte</vh>
<v t="ekr.20050704170205.60"><vh>&lt;&lt; class c_byte declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.61"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.62"><vh>class c_char</vh>
<v t="ekr.20050704170205.63"><vh>&lt;&lt; class c_char declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.64"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.65"><vh>class c_char_p</vh>
<v t="ekr.20050704170205.66"><vh>&lt;&lt; class c_char_p declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.67"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.68"><vh>class c_void_p</vh>
<v t="ekr.20050704170205.69"><vh>&lt;&lt; class c_void_p declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.70"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.71"><vh>POINTER</vh></v>
<v t="ekr.20050704170205.72"><vh>class c_wchar_p</vh>
<v t="ekr.20050704170205.73"><vh>&lt;&lt; class c_wchar_p declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.74"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.75"><vh>class c_wchar</vh>
<v t="ekr.20050704170205.76"><vh>&lt;&lt; class c_wchar declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.77"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.78"><vh>create_unicode_buffer</vh></v>
<v t="ekr.20050704170205.79"><vh>SetPointerType</vh></v>
<v t="ekr.20050704170205.80"><vh>pointer</vh></v>
<v t="ekr.20050704170205.81"><vh>ARRAY</vh></v>
<v t="ekr.20050704170205.82"><vh>class CDLL</vh>
<v t="ekr.20050704170205.83"><vh>class _CdeclFuncPtr</vh>
<v t="ekr.20050704170205.84"><vh>&lt;&lt; class _CdeclFuncPtr declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.85"><vh>__init__</vh></v>
<v t="ekr.20050704170205.86"><vh>__repr__</vh></v>
<v t="ekr.20050704170205.87"><vh>__getattr__</vh></v>
<v t="ekr.20050704170205.88"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20050704170205.89"><vh>class PyDLL</vh>
<v t="ekr.20050704170205.90"><vh>class _CdeclFuncPtr</vh>
<v t="ekr.20050704170205.91"><vh>&lt;&lt; class _CdeclFuncPtr declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.92"><vh>class WinDLL</vh>
<v t="ekr.20050704170205.93"><vh>class _StdcallFuncPtr</vh>
<v t="ekr.20050704170205.94"><vh>&lt;&lt; class _StdcallFuncPtr declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.95"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20050704170205.96"><vh>class HRESULT</vh>
<v t="ekr.20050704170205.97"><vh>&lt;&lt; class HRESULT declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.98"><vh>class OleDLL</vh>
<v t="ekr.20050704170205.99"><vh>class _OlecallFuncPtr</vh>
<v t="ekr.20050704170205.100"><vh>&lt;&lt; class _OlecallFuncPtr declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.101"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20050704170205.102"><vh>class _DLLS</vh>
<v t="ekr.20050704170205.103"><vh>__init__</vh></v>
<v t="ekr.20050704170205.104"><vh>__getattr__</vh></v>
<v t="ekr.20050704170205.105"><vh>__getitem__</vh></v>
<v t="ekr.20050704170205.106"><vh>LoadLibrary</vh></v>
</v>
<v t="ekr.20050704170205.107"><vh>WinError</vh></v>
</v>
<v t="ekr.20050704170205.108"><vh>decorators.py</vh>
<v t="ekr.20050704170205.109"><vh>&lt;&lt; decorators declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.110"><vh>stdcall</vh></v>
<v t="ekr.20050704170205.111"><vh>cdecl</vh></v>
</v>
<v t="ekr.20050704170205.112"><vh>c:/Python24/Lib/site-packages/ctypes/com/</vh>
<v t="ekr.20050704170205.113"><vh>w_getopt.py</vh>
<v t="ekr.20050704170205.114"><vh>class GetoptError</vh>
<v t="ekr.20050704170205.115"><vh>&lt;&lt; class GetoptError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.116"><vh>w_getopt</vh></v>
<v t="ekr.20050704170205.117"><vh>class TestCase</vh>
<v t="ekr.20050704170205.118"><vh>test_1</vh></v>
<v t="ekr.20050704170205.119"><vh>test_2</vh></v>
<v t="ekr.20050704170205.120"><vh>test_3</vh></v>
<v t="ekr.20050704170205.121"><vh>test_4</vh></v>
</v>
</v>
<v t="ekr.20050704170205.122"><vh>__init__.py</vh>
<v t="ekr.20050704170205.123"><vh>&lt;&lt; __init__ declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.124"><vh>class _Cleaner</vh>
<v t="ekr.20050704170205.125"><vh>__del__</vh></v>
</v>
<v t="ekr.20050704170205.126"><vh>_clean_exc_info</vh></v>
<v t="ekr.20050704170205.127"><vh>class GUID</vh>
<v t="ekr.20050704170205.128"><vh>&lt;&lt; class GUID declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.129"><vh>__init__</vh></v>
<v t="ekr.20050704170205.130"><vh>__repr__</vh></v>
<v t="ekr.20050704170205.131"><vh>__str__</vh></v>
<v t="ekr.20050704170205.132"><vh>__cmp__</vh></v>
<v t="ekr.20050704170205.133"><vh>__nonzero__</vh></v>
<v t="ekr.20050704170205.134"><vh>__eq__</vh></v>
<v t="ekr.20050704170205.135"><vh>copy</vh></v>
<v t="ekr.20050704170205.136"><vh>from_progid</vh></v>
</v>
<v t="ekr.20050704170205.137"><vh>STDMETHOD</vh></v>
<v t="ekr.20050704170205.138"><vh>COMPointer__del__</vh></v>
<v t="ekr.20050704170205.139"><vh>class _interface_meta</vh>
<v t="ekr.20050704170205.140"><vh>__new__</vh></v>
<v t="ekr.20050704170205.141"><vh>__make_vtable</vh></v>
<v t="ekr.20050704170205.142"><vh>_init_class</vh></v>
<v t="ekr.20050704170205.143"><vh>__setattr__</vh></v>
<v t="ekr.20050704170205.144"><vh>__make_methods</vh></v>
</v>
<v t="ekr.20050704170205.145"><vh>class IUnknown</vh>
<v t="ekr.20050704170205.146"><vh>&lt;&lt; class IUnknown declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.147"><vh>from_param</vh></v>
<v t="ekr.20050704170205.148"><vh>interface_name</vh></v>
<v t="ekr.20050704170205.149"><vh>_wrap</vh></v>
<v t="ekr.20050704170205.150"><vh>class COMObject</vh>
<v t="ekr.20050704170205.151"><vh>&lt;&lt; class COMObject declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.152"><vh>_get_registrar</vh></v>
<v t="ekr.20050704170205.153"><vh>__init__</vh></v>
<v t="ekr.20050704170205.154"><vh>_get_funcimpl</vh></v>
<v t="ekr.20050704170205.155"><vh>_make_interface_pointer</vh></v>
<v t="ekr.20050704170205.156"><vh>QueryInterface</vh></v>
<v t="ekr.20050704170205.157"><vh>AddRef</vh></v>
<v t="ekr.20050704170205.158"><vh>Release</vh></v>
</v>
<v t="ekr.20050704170205.159"><vh>CreateInstance</vh></v>
<v t="ekr.20050704170205.160"><vh>CreateGuid</vh></v>
</v>
<v t="ekr.20050704170205.161"><vh>automation.py</vh>
<v t="ekr.20050704170205.162"><vh>&lt;&lt; automation declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.163"><vh>class BSTR</vh>
<v t="ekr.20050704170205.164"><vh>&lt;&lt; class BSTR declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.165"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704170205.166"><vh>class ITypeComp</vh>
<v t="ekr.20050704170205.167"><vh>&lt;&lt; class ITypeComp declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.168"><vh>class ITypeInfo</vh>
<v t="ekr.20050704170205.169"><vh>&lt;&lt; class ITypeInfo declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.170"><vh>class ITypeLib</vh>
<v t="ekr.20050704170205.171"><vh>&lt;&lt; class ITypeLib declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.172"><vh>class IDispatch</vh>
<v t="ekr.20050704170205.173"><vh>&lt;&lt; class IDispatch declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.174"><vh>class SAFEARRAYBOUND</vh>
<v t="ekr.20050704170205.175"><vh>&lt;&lt; class SAFEARRAYBOUND declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.176"><vh>class VARIANT</vh>
<v t="ekr.20050704170205.177"><vh>class U</vh>
<v t="ekr.20050704170205.178"><vh>&lt;&lt; class U declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.179"><vh>__init__</vh></v>
<v t="ekr.20050704170205.180"><vh>_set_value</vh></v>
<v t="ekr.20050704170205.181"><vh>_get_value</vh></v>
<v t="ekr.20050704170205.182"><vh>__repr__</vh></v>
<v t="ekr.20050704170205.183"><vh>optional</vh></v>
</v>
<v t="ekr.20050704170205.184"><vh>class DISPPARAMS</vh>
<v t="ekr.20050704170205.185"><vh>&lt;&lt; class DISPPARAMS declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.186"><vh>class EXCEPINFO</vh>
<v t="ekr.20050704170205.187"><vh>&lt;&lt; class EXCEPINFO declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.188"><vh>as_tuple</vh></v>
</v>
<v t="ekr.20050704170205.189"><vh>class TLIBATTR</vh>
<v t="ekr.20050704170205.190"><vh>&lt;&lt; class TLIBATTR declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.191"><vh>class PARAMDESCEX</vh>
<v t="ekr.20050704170205.192"><vh>&lt;&lt; class PARAMDESCEX declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.193"><vh>class PARAMDESC</vh>
<v t="ekr.20050704170205.194"><vh>&lt;&lt; class PARAMDESC declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.195"><vh>class TYPEDESC</vh>
<v t="ekr.20050704170205.196"><vh>class U</vh>
<v t="ekr.20050704170205.197"><vh>&lt;&lt; class U declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.198"><vh>class ARRAYDESC</vh>
<v t="ekr.20050704170205.199"><vh>&lt;&lt; class ARRAYDESC declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.200"><vh>class IDLDESC</vh>
<v t="ekr.20050704170205.201"><vh>&lt;&lt; class IDLDESC declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.202"><vh>class TYPEATTR</vh>
<v t="ekr.20050704170205.203"><vh>&lt;&lt; class TYPEATTR declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.204"><vh>class ELEMDESC</vh>
<v t="ekr.20050704170205.205"><vh>&lt;&lt; class ELEMDESC declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.206"><vh>class VARDESC</vh>
<v t="ekr.20050704170205.207"><vh>class U</vh>
<v t="ekr.20050704170205.208"><vh>&lt;&lt; class U declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.209"><vh>class FUNCDESC</vh>
<v t="ekr.20050704170205.210"><vh>&lt;&lt; class FUNCDESC declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.211"><vh>class BINDPTR</vh>
<v t="ekr.20050704170205.212"><vh>&lt;&lt; class BINDPTR declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.213"><vh>class IProvideClassInfo</vh>
<v t="ekr.20050704170205.214"><vh>&lt;&lt; class IProvideClassInfo declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.215"><vh>class IProvideClassInfo2</vh>
<v t="ekr.20050704170205.216"><vh>&lt;&lt; class IProvideClassInfo2 declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.217"><vh>LoadTypeLib</vh></v>
<v t="ekr.20050704170205.218"><vh>LoadTypeLibEx</vh></v>
<v t="ekr.20050704170205.219"><vh>LoadRegTypeLib</vh></v>
<v t="ekr.20050704170205.220"><vh>class DualObjImpl</vh>
<v t="ekr.20050704170205.221"><vh>__init__</vh></v>
<v t="ekr.20050704170205.222"><vh>LoadTypeInfo</vh></v>
<v t="ekr.20050704170205.223"><vh>GetIDsOfNames</vh></v>
<v t="ekr.20050704170205.224"><vh>Invoke</vh></v>
<v t="ekr.20050704170205.225"><vh>GetTypeInfoCount</vh></v>
<v t="ekr.20050704170205.226"><vh>GetTypeInfo</vh></v>
</v>
<v t="ekr.20050704170205.227"><vh>class dispinterface</vh>
<v t="ekr.20050704170205.228"><vh>class __metaclass__</vh>
<v t="ekr.20050704170205.229"><vh>__setattr__</vh></v>
</v>
</v>
<v t="ekr.20050704170205.230"><vh>DISPMETHOD</vh></v>
<v t="ekr.20050704170205.231"><vh>class IEnumVARIANT</vh>
<v t="ekr.20050704170205.232"><vh>&lt;&lt; class IEnumVARIANT declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.233"><vh>class IErrorLog</vh>
<v t="ekr.20050704170205.234"><vh>&lt;&lt; class IErrorLog declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.235"><vh>client.py</vh>
<v t="ekr.20050704170205.236"><vh>&lt;&lt; client declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.237"><vh>_wrap</vh></v>
<v t="ekr.20050704170205.238"><vh>_unwrap</vh></v>
<v t="ekr.20050704170205.239"><vh>class _funcdesc</vh>
<v t="ekr.20050704170205.240"><vh>&lt;&lt; class _funcdesc declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.241"><vh>__init__</vh></v>
<v t="ekr.20050704170205.242"><vh>__getattr__</vh></v>
<v t="ekr.20050704170205.243"><vh>__del__</vh></v>
</v>
<v t="ekr.20050704170205.244"><vh>class _typeattr</vh>
<v t="ekr.20050704170205.245"><vh>&lt;&lt; class _typeattr declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.246"><vh>__init__</vh></v>
<v t="ekr.20050704170205.247"><vh>__getattr__</vh></v>
<v t="ekr.20050704170205.248"><vh>__del__</vh></v>
</v>
<v t="ekr.20050704170205.249"><vh>GetTypeInfo</vh></v>
<v t="ekr.20050704170205.250"><vh>GetContainingTypeLib</vh></v>
<v t="ekr.20050704170205.251"><vh>GetTypeInfoOfGuid</vh></v>
<v t="ekr.20050704170205.252"><vh>GetTypeAttr</vh></v>
<v t="ekr.20050704170205.253"><vh>GetImplTypeFlags</vh></v>
<v t="ekr.20050704170205.254"><vh>GetRefTypeInfo</vh></v>
<v t="ekr.20050704170205.255"><vh>QueryInterface</vh></v>
<v t="ekr.20050704170205.256"><vh>EnumConnectionPoints</vh></v>
<v t="ekr.20050704170205.257"><vh>GetConnectionInterface</vh></v>
<v t="ekr.20050704170205.258"><vh>Next</vh></v>
<v t="ekr.20050704170205.259"><vh>GetTypeComp</vh></v>
<v t="ekr.20050704170205.260"><vh>class COMError</vh>
<v t="ekr.20050704170205.261"><vh>__init__</vh></v>
<v t="ekr.20050704170205.262"><vh>__str__</vh></v>
</v>
<v t="ekr.20050704170205.263"><vh>class _Constants</vh>
<v t="ekr.20050704170205.264"><vh>__init__</vh></v>
<v t="ekr.20050704170205.265"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20050704170205.266"><vh>class _InvokeMixin</vh>
<v t="ekr.20050704170205.267"><vh>_do_invoke</vh></v>
</v>
<v t="ekr.20050704170205.268"><vh>class _Dispatch</vh>
<v t="ekr.20050704170205.269"><vh>&lt;&lt; class _Dispatch declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.270"><vh>__init__</vh></v>
<v t="ekr.20050704170205.271"><vh>_get_funcdesc</vh></v>
<v t="ekr.20050704170205.272"><vh>__prop_get</vh></v>
<v t="ekr.20050704170205.273"><vh>__prop_put</vh></v>
<v t="ekr.20050704170205.274"><vh>__setattr__</vh></v>
<v t="ekr.20050704170205.275"><vh>__getattr__</vh></v>
<v t="ekr.20050704170205.276"><vh>__call__</vh></v>
<v t="ekr.20050704170205.277"><vh>__nonzero__</vh></v>
<v t="ekr.20050704170205.278"><vh>__len__</vh></v>
<v t="ekr.20050704170205.279"><vh>__getitem__</vh></v>
<v t="ekr.20050704170205.280"><vh>__iter__</vh></v>
</v>
<v t="ekr.20050704170205.281"><vh>class _NewEnum</vh>
<v t="ekr.20050704170205.282"><vh>__init__</vh></v>
<v t="ekr.20050704170205.283"><vh>__iter__</vh></v>
<v t="ekr.20050704170205.284"><vh>next</vh></v>
</v>
<v t="ekr.20050704170205.285"><vh>class _DispMethod</vh>
<v t="ekr.20050704170205.286"><vh>__init__</vh></v>
<v t="ekr.20050704170205.287"><vh>_get_dispid_dict</vh></v>
<v t="ekr.20050704170205.288"><vh>_build_parms</vh></v>
<v t="ekr.20050704170205.289"><vh>__call__</vh></v>
</v>
<v t="ekr.20050704170205.290"><vh>Dispatch</vh></v>
<v t="ekr.20050704170205.291"><vh>_GetOutgoingInterfaceGuid</vh></v>
<v t="ekr.20050704170205.292"><vh>_CreateOutgoingInterface</vh></v>
<v t="ekr.20050704170205.293"><vh>class _EventReceiver</vh>
<v t="ekr.20050704170205.294"><vh>&lt;&lt; class _EventReceiver declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.295"><vh>__init__</vh></v>
<v t="ekr.20050704170205.296"><vh>AddRef</vh></v>
<v t="ekr.20050704170205.297"><vh>Release</vh></v>
<v t="ekr.20050704170205.298"><vh>Invoke</vh></v>
<v t="ekr.20050704170205.299"><vh>connect</vh></v>
<v t="ekr.20050704170205.300"><vh>disconnect</vh></v>
</v>
<v t="ekr.20050704170205.301"><vh>DispatchWithEvents</vh></v>
<v t="ekr.20050704170205.302"><vh>WithEvents</vh></v>
<v t="ekr.20050704170205.303"><vh>GetObject</vh></v>
</v>
<v t="ekr.20050704170205.304"><vh>connectionpoints.py</vh>
<v t="ekr.20050704170205.305"><vh>&lt;&lt; connectionpoints declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.306"><vh>class CONNECTDATA</vh>
<v t="ekr.20050704170205.307"><vh>&lt;&lt; class CONNECTDATA declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.308"><vh>class IEnumConnections</vh>
<v t="ekr.20050704170205.309"><vh>&lt;&lt; class IEnumConnections declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.310"><vh>class IEnumConnectionPoints</vh>
<v t="ekr.20050704170205.311"><vh>&lt;&lt; class IEnumConnectionPoints declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.312"><vh>class IConnectionPointContainer</vh>
<v t="ekr.20050704170205.313"><vh>&lt;&lt; class IConnectionPointContainer declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.314"><vh>class IConnectionPoint</vh>
<v t="ekr.20050704170205.315"><vh>&lt;&lt; class IConnectionPoint declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.316"><vh>GetConnectionPoint</vh></v>
<v t="ekr.20050704170205.317"><vh>class dispinterface_EventReceiver</vh>
<v t="ekr.20050704170205.318"><vh>&lt;&lt; class dispinterface_EventReceiver declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.319"><vh>AddRef</vh></v>
<v t="ekr.20050704170205.320"><vh>Release</vh></v>
<v t="ekr.20050704170205.321"><vh>_get_args</vh></v>
<v t="ekr.20050704170205.322"><vh>Invoke</vh></v>
<v t="ekr.20050704170205.323"><vh>connect</vh></v>
<v t="ekr.20050704170205.324"><vh>disconnect</vh></v>
</v>
</v>
<v t="ekr.20050704170205.325"><vh>errorinfo.py</vh>
<v t="ekr.20050704170205.326"><vh>&lt;&lt; errorinfo declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.327"><vh>class ICreateErrorInfo</vh>
<v t="ekr.20050704170205.328"><vh>&lt;&lt; class ICreateErrorInfo declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.329"><vh>class IErrorInfo</vh>
<v t="ekr.20050704170205.330"><vh>&lt;&lt; class IErrorInfo declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.331"><vh>CreateErrorInfo</vh></v>
<v t="ekr.20050704170205.332"><vh>GetErrorInfo</vh></v>
<v t="ekr.20050704170205.333"><vh>SetErrorInfo</vh></v>
<v t="ekr.20050704170205.334"><vh>doit</vh></v>
</v>
<v t="ekr.20050704170205.335"><vh>hresult.py</vh></v>
<v t="ekr.20050704170205.336"><vh>mallocspy.py</vh>
<v t="ekr.20050704170205.337"><vh>&lt;&lt; mallocspy declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.338"><vh>class IMalloc</vh>
<v t="ekr.20050704170205.339"><vh>&lt;&lt; class IMalloc declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.340"><vh>class IMallocSpy</vh>
<v t="ekr.20050704170205.341"><vh>&lt;&lt; class IMallocSpy declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.342"><vh>class MallocSpy</vh>
<v t="ekr.20050704170205.343"><vh>&lt;&lt; class MallocSpy declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.344"><vh>__init__</vh></v>
<v t="ekr.20050704170205.345"><vh>AddRef</vh></v>
<v t="ekr.20050704170205.346"><vh>Release</vh></v>
<v t="ekr.20050704170205.347"><vh>PreAlloc</vh></v>
<v t="ekr.20050704170205.348"><vh>PostAlloc</vh></v>
<v t="ekr.20050704170205.349"><vh>PreFree</vh></v>
<v t="ekr.20050704170205.350"><vh>PostFree</vh></v>
<v t="ekr.20050704170205.351"><vh>PreGetSize</vh></v>
<v t="ekr.20050704170205.352"><vh>PostGetSize</vh></v>
<v t="ekr.20050704170205.353"><vh>PreRealloc</vh></v>
<v t="ekr.20050704170205.354"><vh>PostRealloc</vh></v>
<v t="ekr.20050704170205.355"><vh>PreDidAlloc</vh></v>
<v t="ekr.20050704170205.356"><vh>PostDidAlloc</vh></v>
<v t="ekr.20050704170205.357"><vh>PreHeapMinimize</vh></v>
<v t="ekr.20050704170205.358"><vh>PostHeapMinimize</vh></v>
<v t="ekr.20050704170205.359"><vh>active_blocks</vh></v>
<v t="ekr.20050704170205.360"><vh>register</vh></v>
<v t="ekr.20050704170205.361"><vh>revoke</vh></v>
<v t="ekr.20050704170205.362"><vh>release_all</vh></v>
</v>
<v t="ekr.20050704170205.363"><vh>CoGetMalloc</vh></v>
<v t="ekr.20050704170205.364"><vh>doit</vh></v>
</v>
<v t="ekr.20050704170205.365"><vh>moniker.py</vh>
<v t="ekr.20050704170205.366"><vh>&lt;&lt; moniker declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.367"><vh>class BIND_OPTS</vh>
<v t="ekr.20050704170205.368"><vh>&lt;&lt; class BIND_OPTS declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.369"><vh>class IRunningObjectTable</vh>
<v t="ekr.20050704170205.370"><vh>&lt;&lt; class IRunningObjectTable declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.371"><vh>class IEnumString</vh>
<v t="ekr.20050704170205.372"><vh>&lt;&lt; class IEnumString declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.373"><vh>class IEnumMoniker</vh>
<v t="ekr.20050704170205.374"><vh>&lt;&lt; class IEnumMoniker declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.375"><vh>class IBindCtx</vh>
<v t="ekr.20050704170205.376"><vh>&lt;&lt; class IBindCtx declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.377"><vh>class IMoniker</vh>
<v t="ekr.20050704170205.378"><vh>&lt;&lt; class IMoniker declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.379"><vh>CreateBindContext</vh></v>
<v t="ekr.20050704170205.380"><vh>MkParseDisplayName</vh></v>
</v>
<v t="ekr.20050704170205.381"><vh>ole.py</vh>
<v t="ekr.20050704170205.382"><vh>&lt;&lt; ole declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.383"><vh>class DVTARGETDEVICE</vh>
<v t="ekr.20050704170205.384"><vh>&lt;&lt; class DVTARGETDEVICE declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.385"><vh>class FORMATETC</vh>
<v t="ekr.20050704170205.386"><vh>&lt;&lt; class FORMATETC declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.387"><vh>class STGMEDIUM</vh>
<v t="ekr.20050704170205.388"><vh>class _u</vh>
<v t="ekr.20050704170205.389"><vh>&lt;&lt; class _u declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.390"><vh>class PALETTEENTRY</vh>
<v t="ekr.20050704170205.391"><vh>&lt;&lt; class PALETTEENTRY declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.392"><vh>class LOGPALETTE</vh>
<v t="ekr.20050704170205.393"><vh>&lt;&lt; class LOGPALETTE declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.394"><vh>class OLEINPLACEFRAMEINFO</vh>
<v t="ekr.20050704170205.395"><vh>&lt;&lt; class OLEINPLACEFRAMEINFO declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.396"><vh>class IOleWindow</vh>
<v t="ekr.20050704170205.397"><vh>&lt;&lt; class IOleWindow declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.398"><vh>class IOleInPlaceUIWindow</vh>
<v t="ekr.20050704170205.399"><vh>&lt;&lt; class IOleInPlaceUIWindow declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.400"><vh>class IOleInPlaceActiveObject</vh>
<v t="ekr.20050704170205.401"><vh>&lt;&lt; class IOleInPlaceActiveObject declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.402"><vh>class OLEMENUGROUPWIDTHS</vh>
<v t="ekr.20050704170205.403"><vh>&lt;&lt; class OLEMENUGROUPWIDTHS declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.404"><vh>class IOleInPlaceFrame</vh>
<v t="ekr.20050704170205.405"><vh>&lt;&lt; class IOleInPlaceFrame declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.406"><vh>class IOleInPlaceObject</vh>
<v t="ekr.20050704170205.407"><vh>&lt;&lt; class IOleInPlaceObject declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.408"><vh>class IOleInPlaceSite</vh>
<v t="ekr.20050704170205.409"><vh>&lt;&lt; class IOleInPlaceSite declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.410"><vh>class IAdviseSink</vh>
<v t="ekr.20050704170205.411"><vh>&lt;&lt; class IAdviseSink declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.412"><vh>class IViewObject</vh>
<v t="ekr.20050704170205.413"><vh>&lt;&lt; class IViewObject declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.414"><vh>class IViewObject2</vh>
<v t="ekr.20050704170205.415"><vh>&lt;&lt; class IViewObject2 declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.416"><vh>oleobject.py</vh>
<v t="ekr.20050704170205.417"><vh>&lt;&lt; oleobject declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.418"><vh>class IOleClientSite</vh>
<v t="ekr.20050704170205.419"><vh>&lt;&lt; class IOleClientSite declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.420"><vh>class IOleObject</vh>
<v t="ekr.20050704170205.421"><vh>&lt;&lt; class IOleObject declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.422"><vh>class IOleAdviseHolder</vh>
<v t="ekr.20050704170205.423"><vh>&lt;&lt; class IOleAdviseHolder declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.424"><vh>CreateOleAdviseHolder</vh></v>
</v>
<v t="ekr.20050704170205.425"><vh>persist.py</vh>
<v t="ekr.20050704170205.426"><vh>&lt;&lt; persist declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.427"><vh>class IPersist</vh>
<v t="ekr.20050704170205.428"><vh>&lt;&lt; class IPersist declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.429"><vh>class IPersistStream</vh>
<v t="ekr.20050704170205.430"><vh>&lt;&lt; class IPersistStream declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.431"><vh>class IPersistStreamInit</vh>
<v t="ekr.20050704170205.432"><vh>&lt;&lt; class IPersistStreamInit declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.433"><vh>class IPersistFile</vh>
<v t="ekr.20050704170205.434"><vh>&lt;&lt; class IPersistFile declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.435"><vh>class IPropertyBag</vh>
<v t="ekr.20050704170205.436"><vh>&lt;&lt; class IPropertyBag declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.437"><vh>class IPersistPropertyBag</vh>
<v t="ekr.20050704170205.438"><vh>&lt;&lt; class IPersistPropertyBag declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.439"><vh>register.py</vh>
<v t="ekr.20050704170205.440"><vh>&lt;&lt; register declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.441"><vh>main_is_frozen</vh></v>
<v t="ekr.20050704170205.442"><vh>class Registrar</vh>
<v t="ekr.20050704170205.443"><vh>&lt;&lt; class Registrar declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.444"><vh>__init__</vh></v>
<v t="ekr.20050704170205.445"><vh>build_table</vh></v>
<v t="ekr.20050704170205.446"><vh>unregister</vh></v>
<v t="ekr.20050704170205.447"><vh>register</vh></v>
</v>
<v t="ekr.20050704170205.448"><vh>register_typelib</vh></v>
<v t="ekr.20050704170205.449"><vh>unregister_typelib</vh></v>
<v t="ekr.20050704170205.450"><vh>register</vh></v>
<v t="ekr.20050704170205.451"><vh>unregister</vh></v>
</v>
<v t="ekr.20050704170205.452"><vh>server.py</vh>
<v t="ekr.20050704170205.453"><vh>&lt;&lt; server declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.454"><vh>class IClassFactory</vh>
<v t="ekr.20050704170205.455"><vh>&lt;&lt; class IClassFactory declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.456"><vh>class IExternalConnection</vh>
<v t="ekr.20050704170205.457"><vh>&lt;&lt; class IExternalConnection declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.458"><vh>dprint</vh></v>
<v t="ekr.20050704170205.459"><vh>class Logger</vh>
<v t="ekr.20050704170205.460"><vh>write</vh></v>
<v t="ekr.20050704170205.461"><vh>isatty</vh></v>
<v t="ekr.20050704170205.462"><vh>install</vh></v>
</v>
<v t="ekr.20050704170205.463"><vh>inproc_find_class</vh></v>
<v t="ekr.20050704170205.464"><vh>DllGetClassObject</vh></v>
<v t="ekr.20050704170205.465"><vh>DllCanUnloadNow</vh></v>
<v t="ekr.20050704170205.466"><vh>class _ClassFactory</vh>
<v t="ekr.20050704170205.467"><vh>&lt;&lt; class _ClassFactory declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.468"><vh>__init__</vh></v>
<v t="ekr.20050704170205.469"><vh>CreateInstance</vh></v>
</v>
<v t="ekr.20050704170205.470"><vh>class InprocClassFactory</vh>
<v t="ekr.20050704170205.471"><vh>AddRef</vh></v>
<v t="ekr.20050704170205.472"><vh>Release</vh></v>
<v t="ekr.20050704170205.473"><vh>LockServer</vh></v>
</v>
<v t="ekr.20050704170205.474"><vh>class LocalServerClassFactory</vh>
<v t="ekr.20050704170205.475"><vh>&lt;&lt; class LocalServerClassFactory declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.476"><vh>get_interface_pointer</vh></v>
<v t="ekr.20050704170205.477"><vh>_register_class</vh></v>
<v t="ekr.20050704170205.478"><vh>_revoke_class</vh></v>
<v t="ekr.20050704170205.479"><vh>AddRef</vh></v>
<v t="ekr.20050704170205.480"><vh>Release</vh></v>
<v t="ekr.20050704170205.481"><vh>LockServer</vh></v>
<v t="ekr.20050704170205.482"><vh>AddConnection</vh></v>
<v t="ekr.20050704170205.483"><vh>ReleaseConnection</vh></v>
</v>
<v t="ekr.20050704170205.484"><vh>pump_messages</vh></v>
<v t="ekr.20050704170205.485"><vh>localserver</vh></v>
<v t="ekr.20050704170205.486"><vh>UseCommandLine</vh></v>
</v>
<v t="ekr.20050704170205.487"><vh>shelllink.py</vh>
<v t="ekr.20050704170205.488"><vh>&lt;&lt; shelllink declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.489"><vh>class SHITEMID</vh>
<v t="ekr.20050704170205.490"><vh>&lt;&lt; class SHITEMID declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.491"><vh>class ITEMIDLIST</vh>
<v t="ekr.20050704170205.492"><vh>&lt;&lt; class ITEMIDLIST declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.493"><vh>class IShellLinkA</vh>
<v t="ekr.20050704170205.494"><vh>&lt;&lt; class IShellLinkA declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.495"><vh>class IShellLinkW</vh>
<v t="ekr.20050704170205.496"><vh>&lt;&lt; class IShellLinkW declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050704170205.497"><vh>storage.py</vh>
<v t="ekr.20050704170205.498"><vh>&lt;&lt; storage declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170205.499"><vh>class STATSTG</vh>
<v t="ekr.20050704170205.500"><vh>&lt;&lt; class STATSTG declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.501"><vh>class IEnumSTATSTG</vh>
<v t="ekr.20050704170205.502"><vh>&lt;&lt; class IEnumSTATSTG declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.503"><vh>class ISequentialStream</vh>
<v t="ekr.20050704170205.504"><vh>&lt;&lt; class ISequentialStream declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.505"><vh>class IStream</vh>
<v t="ekr.20050704170205.506"><vh>&lt;&lt; class IStream declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.507"><vh>CoMarshalInterThreadInterfaceInStream</vh></v>
<v t="ekr.20050704170205.508"><vh>CoGetInterfaceAndReleaseStream</vh></v>
<v t="ekr.20050704170205.509"><vh>class IStorage</vh>
<v t="ekr.20050704170205.510"><vh>&lt;&lt; class IStorage declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170205.511"><vh>run_in_thread</vh></v>
</v>
</v>
<v t="ekr.20050704170316"><vh>c:/Python24/Lib/site-packages/ctypes/wrap/</vh>
<v t="ekr.20050704170316.1"><vh>xml2py.py</vh>
<v t="ekr.20050704170316.2"><vh>&lt;&lt; xml2py declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.3"><vh>main</vh></v>
</v>
<v t="ekr.20050704170316.4"><vh>__init__.py</vh></v>
<v t="ekr.20050704170316.5"><vh>codegenerator.py</vh>
<v t="ekr.20050704170316.6"><vh>&lt;&lt; codegenerator declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.7"><vh>storage</vh></v>
<v t="ekr.20050704170316.8"><vh>class PackingError</vh>
<v t="ekr.20050704170316.9"><vh>&lt;&lt; class PackingError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170316.10"><vh>_calc_packing</vh></v>
<v t="ekr.20050704170316.11"><vh>calc_packing</vh></v>
<v t="ekr.20050704170316.12"><vh>decode_value</vh></v>
<v t="ekr.20050704170316.13"><vh>get_real_type</vh></v>
<v t="ekr.20050704170316.14"><vh>class Generator</vh>
<v t="ekr.20050704170316.15"><vh>__init__</vh></v>
<v t="ekr.20050704170316.16"><vh>init_value</vh></v>
<v t="ekr.20050704170316.17"><vh>type_name</vh></v>
<v t="ekr.20050704170316.18"><vh>Alias</vh></v>
<v t="ekr.20050704170316.19"><vh>Macro</vh></v>
<v t="ekr.20050704170316.20"><vh>StructureHead</vh></v>
<v t="ekr.20050704170316.21"><vh>Structure</vh></v>
<v t="ekr.20050704170316.22"><vh>Typedef</vh></v>
<v t="ekr.20050704170316.23"><vh>ArrayType</vh></v>
<v t="ekr.20050704170316.24"><vh>FunctionType</vh></v>
<v t="ekr.20050704170316.25"><vh>PointerType</vh></v>
<v t="ekr.20050704170316.26"><vh>CvQualifiedType</vh></v>
<v t="ekr.20050704170316.27"><vh>Variable</vh></v>
<v t="ekr.20050704170316.28"><vh>EnumValue</vh></v>
<v t="ekr.20050704170316.29"><vh>Enumeration</vh></v>
<v t="ekr.20050704170316.30"><vh>StructureBody</vh></v>
<v t="ekr.20050704170316.31"><vh>find_dllname</vh></v>
<v t="ekr.20050704170316.32"><vh>get_sharedlib</vh></v>
<v t="ekr.20050704170316.33"><vh>need_STDMETHOD</vh></v>
<v t="ekr.20050704170316.34"><vh>need_COMMETHOD</vh></v>
<v t="ekr.20050704170316.35"><vh>need_GUID</vh></v>
<v t="ekr.20050704170316.36"><vh>Function</vh></v>
<v t="ekr.20050704170316.37"><vh>FundamentalType</vh></v>
<v t="ekr.20050704170316.38"><vh>generate</vh></v>
<v t="ekr.20050704170316.39"><vh>generate_all</vh></v>
<v t="ekr.20050704170316.40"><vh>generate_code</vh></v>
<v t="ekr.20050704170316.41"><vh>print_stats</vh></v>
</v>
<v t="ekr.20050704170316.42"><vh>generate_code</vh></v>
</v>
<v t="ekr.20050704170316.43"><vh>cparser.py</vh>
<v t="ekr.20050704170316.44"><vh>&lt;&lt; cparser declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.45"><vh>_locate_gccxml</vh></v>
<v t="ekr.20050704170316.46"><vh>class CompilerError</vh>
<v t="ekr.20050704170316.47"><vh>&lt;&lt; class CompilerError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704170316.48"><vh>class IncludeParser</vh>
<v t="ekr.20050704170316.49"><vh>__init__</vh></v>
<v t="ekr.20050704170316.50"><vh>create_source_file</vh></v>
<v t="ekr.20050704170316.51"><vh>compile_and_dump</vh></v>
<v t="ekr.20050704170316.52"><vh>create_xml</vh></v>
<v t="ekr.20050704170316.53"><vh>display_compiler_errors</vh></v>
<v t="ekr.20050704170316.54"><vh>get_defines</vh></v>
<v t="ekr.20050704170316.55"><vh>is_excluded</vh></v>
<v t="ekr.20050704170316.56"><vh>filter_definitions</vh></v>
<v t="ekr.20050704170316.57"><vh>find_types</vh></v>
<v t="ekr.20050704170316.58"><vh>create_final_xml</vh></v>
<v t="ekr.20050704170316.59"><vh>c_type_name</vh></v>
<v t="ekr.20050704170316.60"><vh>dump_as_cdata</vh></v>
<v t="ekr.20050704170316.61"><vh>parse</vh></v>
</v>
</v>
<v t="ekr.20050704170316.62"><vh>cparser_config.py</vh></v>
<v t="ekr.20050704170316.63"><vh>gccxmlparser.py</vh>
<v t="ekr.20050704170316.64"><vh>&lt;&lt; gccxmlparser declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.65"><vh>MAKE_NAME</vh></v>
<v t="ekr.20050704170316.66"><vh>CHECK_NAME</vh></v>
<v t="ekr.20050704170316.67"><vh>class GCCXML_Handler</vh>
<v t="ekr.20050704170316.68"><vh>&lt;&lt; class GCCXML_Handler declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.69"><vh>__init__</vh></v>
<v t="ekr.20050704170316.70"><vh>startElement</vh></v>
<v t="ekr.20050704170316.71"><vh>endElement</vh></v>
<v t="ekr.20050704170316.72"><vh>Class</vh></v>
<v t="ekr.20050704170316.73"><vh>Destructor</vh></v>
<v t="ekr.20050704170316.74"><vh>GCC_XML</vh></v>
<v t="ekr.20050704170316.75"><vh>Namespace</vh></v>
<v t="ekr.20050704170316.76"><vh>Base</vh></v>
<v t="ekr.20050704170316.77"><vh>Ellipsis</vh></v>
<v t="ekr.20050704170316.78"><vh>OperatorMethod</vh></v>
<v t="ekr.20050704170316.79"><vh>CPP_DUMP</vh></v>
<v t="ekr.20050704170316.80"><vh>characters</vh></v>
<v t="ekr.20050704170316.81"><vh>File</vh></v>
<v t="ekr.20050704170316.82"><vh>_fixup_File</vh></v>
<v t="ekr.20050704170316.83"><vh>Variable</vh></v>
<v t="ekr.20050704170316.84"><vh>_fixup_Variable</vh></v>
<v t="ekr.20050704170316.85"><vh>Typedef</vh></v>
<v t="ekr.20050704170316.86"><vh>_fixup_Typedef</vh></v>
<v t="ekr.20050704170316.87"><vh>FundamentalType</vh></v>
<v t="ekr.20050704170316.88"><vh>_fixup_FundamentalType</vh></v>
<v t="ekr.20050704170316.89"><vh>PointerType</vh></v>
<v t="ekr.20050704170316.90"><vh>_fixup_PointerType</vh></v>
<v t="ekr.20050704170316.91"><vh>ArrayType</vh></v>
<v t="ekr.20050704170316.92"><vh>_fixup_ArrayType</vh></v>
<v t="ekr.20050704170316.93"><vh>CvQualifiedType</vh></v>
<v t="ekr.20050704170316.94"><vh>_fixup_CvQualifiedType</vh></v>
<v t="ekr.20050704170316.95"><vh>Function</vh></v>
<v t="ekr.20050704170316.96"><vh>_fixup_Function</vh></v>
<v t="ekr.20050704170316.97"><vh>FunctionType</vh></v>
<v t="ekr.20050704170316.98"><vh>_fixup_FunctionType</vh></v>
<v t="ekr.20050704170316.99"><vh>OperatorFunction</vh></v>
<v t="ekr.20050704170316.100"><vh>_fixup_OperatorFunction</vh></v>
<v t="ekr.20050704170316.101"><vh>Constructor</vh></v>
<v t="ekr.20050704170316.102"><vh>_fixup_Constructor</vh></v>
<v t="ekr.20050704170316.103"><vh>Method</vh></v>
<v t="ekr.20050704170316.104"><vh>_fixup_Method</vh></v>
<v t="ekr.20050704170316.105"><vh>Argument</vh></v>
<v t="ekr.20050704170316.106"><vh>Enumeration</vh></v>
<v t="ekr.20050704170316.107"><vh>_fixup_Enumeration</vh></v>
<v t="ekr.20050704170316.108"><vh>EnumValue</vh></v>
<v t="ekr.20050704170316.109"><vh>_fixup_EnumValue</vh></v>
<v t="ekr.20050704170316.110"><vh>Struct</vh></v>
<v t="ekr.20050704170316.111"><vh>_fixup_Structure</vh></v>
<v t="ekr.20050704170316.112"><vh>Union</vh></v>
<v t="ekr.20050704170316.113"><vh>Field</vh></v>
<v t="ekr.20050704170316.114"><vh>_fixup_Field</vh></v>
<v t="ekr.20050704170316.115"><vh>_fixup_Macro</vh></v>
<v t="ekr.20050704170316.116"><vh>get_macros</vh></v>
<v t="ekr.20050704170316.117"><vh>get_aliases</vh></v>
<v t="ekr.20050704170316.118"><vh>get_result</vh></v>
</v>
<v t="ekr.20050704170316.119"><vh>parse</vh></v>
</v>
<v t="ekr.20050704170316.120"><vh>h2xml.py</vh>
<v t="ekr.20050704170316.121"><vh>&lt;&lt; h2xml declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.122"><vh>_locate_gccxml</vh></v>
<v t="ekr.20050704170316.123"><vh>main</vh></v>
<v t="ekr.20050704170316.124"><vh>add_option</vh></v>
<v t="ekr.20050704170316.125"><vh>get_option</vh></v>
</v>
<v t="ekr.20050704170316.126"><vh>typedesc.py</vh>
<v t="ekr.20050704170316.127"><vh>&lt;&lt; typedesc declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.128"><vh>class _HasArgs</vh>
<v t="ekr.20050704170316.129"><vh>add_argument</vh></v>
</v>
<v t="ekr.20050704170316.130"><vh>class Alias</vh>
<v t="ekr.20050704170316.131"><vh>&lt;&lt; class Alias declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.132"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.133"><vh>class Macro</vh>
<v t="ekr.20050704170316.134"><vh>&lt;&lt; class Macro declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.135"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.136"><vh>class File</vh>
<v t="ekr.20050704170316.137"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.138"><vh>class Function</vh>
<v t="ekr.20050704170316.139"><vh>&lt;&lt; class Function declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.140"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.141"><vh>class Constructor</vh>
<v t="ekr.20050704170316.142"><vh>&lt;&lt; class Constructor declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.143"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.144"><vh>class OperatorFunction</vh>
<v t="ekr.20050704170316.145"><vh>&lt;&lt; class OperatorFunction declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.146"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.147"><vh>class FunctionType</vh>
<v t="ekr.20050704170316.148"><vh>&lt;&lt; class FunctionType declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.149"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.150"><vh>class Method</vh>
<v t="ekr.20050704170316.151"><vh>&lt;&lt; class Method declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.152"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.153"><vh>class FundamentalType</vh>
<v t="ekr.20050704170316.154"><vh>&lt;&lt; class FundamentalType declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.155"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.156"><vh>class PointerType</vh>
<v t="ekr.20050704170316.157"><vh>&lt;&lt; class PointerType declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.158"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.159"><vh>class Typedef</vh>
<v t="ekr.20050704170316.160"><vh>&lt;&lt; class Typedef declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.161"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.162"><vh>class ArrayType</vh>
<v t="ekr.20050704170316.163"><vh>&lt;&lt; class ArrayType declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.164"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.165"><vh>class StructureHead</vh>
<v t="ekr.20050704170316.166"><vh>&lt;&lt; class StructureHead declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.167"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.168"><vh>class StructureBody</vh>
<v t="ekr.20050704170316.169"><vh>&lt;&lt; class StructureBody declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.170"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.171"><vh>class _Struct_Union_Base</vh>
<v t="ekr.20050704170316.172"><vh>&lt;&lt; class _Struct_Union_Base declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.173"><vh>get_body</vh></v>
<v t="ekr.20050704170316.174"><vh>get_head</vh></v>
</v>
<v t="ekr.20050704170316.175"><vh>class Structure</vh>
<v t="ekr.20050704170316.176"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.177"><vh>class Union</vh>
<v t="ekr.20050704170316.178"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.179"><vh>class Field</vh>
<v t="ekr.20050704170316.180"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.181"><vh>class CvQualifiedType</vh>
<v t="ekr.20050704170316.182"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.183"><vh>class Enumeration</vh>
<v t="ekr.20050704170316.184"><vh>&lt;&lt; class Enumeration declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.185"><vh>__init__</vh></v>
<v t="ekr.20050704170316.186"><vh>add_value</vh></v>
</v>
<v t="ekr.20050704170316.187"><vh>class EnumValue</vh>
<v t="ekr.20050704170316.188"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704170316.189"><vh>class Variable</vh>
<v t="ekr.20050704170316.190"><vh>&lt;&lt; class Variable declarations &gt;&gt;</vh></v>
<v t="ekr.20050704170316.191"><vh>__init__</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050704164036.2"><vh>readline: c:/Python24/Lib/site-packages/readline/</vh>
<v t="ekr.20050704164036.3"><vh>wingdbstub.py</vh></v>
<v t="ekr.20050704164036.4"><vh>__init__.py</vh></v>
<v t="ekr.20050704164036.5"><vh>Console.py</vh>
<v t="ekr.20050704164036.7"><vh>log</vh></v>
<v t="ekr.20050704164036.9"><vh>class COORD</vh>
<v t="ekr.20050704164036.10"><vh>&lt;&lt; class COORD declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.11"><vh>class SMALL_RECT</vh>
<v t="ekr.20050704164036.12"><vh>&lt;&lt; class SMALL_RECT declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.13"><vh>class CONSOLE_SCREEN_BUFFER_INFO</vh>
<v t="ekr.20050704164036.14"><vh>&lt;&lt; class CONSOLE_SCREEN_BUFFER_INFO declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.15"><vh>class CHAR_UNION</vh>
<v t="ekr.20050704164036.16"><vh>&lt;&lt; class CHAR_UNION declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.17"><vh>class CHAR_INFO</vh>
<v t="ekr.20050704164036.18"><vh>&lt;&lt; class CHAR_INFO declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.19"><vh>class KEY_EVENT_RECORD</vh>
<v t="ekr.20050704164036.20"><vh>&lt;&lt; class KEY_EVENT_RECORD declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.21"><vh>class MOUSE_EVENT_RECORD</vh>
<v t="ekr.20050704164036.22"><vh>&lt;&lt; class MOUSE_EVENT_RECORD declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.23"><vh>class WINDOW_BUFFER_SIZE_RECORD</vh>
<v t="ekr.20050704164036.24"><vh>&lt;&lt; class WINDOW_BUFFER_SIZE_RECORD declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.25"><vh>class MENU_EVENT_RECORD</vh>
<v t="ekr.20050704164036.26"><vh>&lt;&lt; class MENU_EVENT_RECORD declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.27"><vh>class FOCUS_EVENT_RECORD</vh>
<v t="ekr.20050704164036.28"><vh>&lt;&lt; class FOCUS_EVENT_RECORD declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.29"><vh>class INPUT_UNION</vh>
<v t="ekr.20050704164036.30"><vh>&lt;&lt; class INPUT_UNION declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.31"><vh>class INPUT_RECORD</vh>
<v t="ekr.20050704164036.32"><vh>&lt;&lt; class INPUT_RECORD declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.33"><vh>class CONSOLE_CURSOR_INFO</vh>
<v t="ekr.20050704164036.34"><vh>&lt;&lt; class CONSOLE_CURSOR_INFO declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704164036.35"><vh>class Console</vh>
<v t="ekr.20050704164036.36"><vh>__init__</vh></v>
<v t="ekr.20050704164036.37"><vh>__del__</vh></v>
<v t="ekr.20050704164036.38"><vh>fixcoord</vh></v>
<v t="ekr.20050704164036.39"><vh>pos</vh></v>
<v t="ekr.20050704164036.40"><vh>home</vh></v>
<v t="ekr.20050704164036.41"><vh>write_scrolling</vh></v>
<v t="ekr.20050704164036.42"><vh>write_color</vh></v>
<v t="ekr.20050704164036.43"><vh>write_plain</vh></v>
<v t="ekr.20050704164036.44"><vh>write</vh></v>
<v t="ekr.20050704164036.45"><vh>isatty</vh></v>
<v t="ekr.20050704164036.46"><vh>flush</vh></v>
<v t="ekr.20050704164036.47"><vh>page</vh></v>
<v t="ekr.20050704164036.48"><vh>text</vh></v>
<v t="ekr.20050704164036.49"><vh>rectangle</vh></v>
<v t="ekr.20050704164036.50"><vh>scroll</vh></v>
<v t="ekr.20050704164036.51"><vh>scroll_window</vh></v>
<v t="ekr.20050704164036.52"><vh>get</vh></v>
<v t="ekr.20050704164036.53"><vh>getkeypress</vh></v>
<v t="ekr.20050704164036.54"><vh>getchar</vh></v>
<v t="ekr.20050704164036.55"><vh>peek</vh></v>
<v t="ekr.20050704164036.56"><vh>title</vh></v>
<v t="ekr.20050704164036.57"><vh>size</vh></v>
<v t="ekr.20050704164036.58"><vh>cursor</vh></v>
<v t="ekr.20050704164036.59"><vh>bell</vh></v>
<v t="ekr.20050704164036.60"><vh>next_serial</vh></v>
</v>
<v t="ekr.20050704164036.61"><vh>class event</vh>
<v t="ekr.20050704164036.62"><vh>__init__</vh></v>
<v t="ekr.20050704164036.63"><vh>__repr__</vh></v>
</v>
<v t="ekr.20050704164036.64"><vh>getconsole</vh></v>
<v t="ekr.20050704164036.65"><vh>hook_wrapper_23</vh></v>
<v t="ekr.20050704164036.66"><vh>hook_wrapper</vh></v>
<v t="ekr.20050704164036.67"><vh>install_readline</vh></v>
</v>
<v t="ekr.20050704164036.68"><vh>keysyms.py</vh>
<v t="ekr.20050704164036.69"><vh>&lt;&lt; define code2sym_map &gt;&gt;</vh></v>
<v t="ekr.20050704164036.70"><vh>make_keysym</vh></v>
<v t="ekr.20050704164036.71"><vh>key_text_to_keyinfo</vh></v>
<v t="ekr.20050704164036.72"><vh>char_to_keyinfo</vh></v>
<v t="ekr.20050704164036.73"><vh>keyname_to_keyinfo</vh></v>
<v t="ekr.20050704164036.74"><vh>keyseq_to_keyinfo</vh></v>
<v t="ekr.20050704164036.75"><vh>make_keyinfo</vh></v>
</v>
<v t="ekr.20050704164036.76"><vh>NPyReadline.py</vh>
<v t="ekr.20050704164036.77"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050704164036.78"><vh>quote_char</vh></v>
<v t="ekr.20050704164036.79"><vh>class Readline</vh>
<v t="ekr.20050704164036.80"><vh>__init__</vh></v>
<v t="ekr.20050704164036.81"><vh>_bell</vh></v>
<v t="ekr.20050704164036.82"><vh>_quoted_text</vh></v>
<v t="ekr.20050704164036.83"><vh>_line_text</vh></v>
<v t="ekr.20050704164036.84"><vh>_set_line</vh></v>
<v t="ekr.20050704164036.85"><vh>_reset_line</vh></v>
<v t="ekr.20050704164036.86"><vh>_clear_after</vh></v>
<v t="ekr.20050704164036.87"><vh>_set_cursor</vh></v>
<v t="ekr.20050704164036.88"><vh>_print_prompt</vh></v>
<v t="ekr.20050704164036.89"><vh>_update_prompt_pos</vh></v>
<v t="ekr.20050704164036.90"><vh>readline</vh></v>
<v t="ekr.20050704164036.91"><vh>parse_and_bind</vh></v>
<v t="ekr.20050704164036.92"><vh>get_line_buffer</vh></v>
<v t="ekr.20050704164036.93"><vh>insert_text</vh></v>
<v t="ekr.20050704164036.94"><vh>read_init_file</vh></v>
<v t="ekr.20050704164036.95"><vh>read_history_file</vh></v>
<v t="ekr.20050704164036.96"><vh>write_history_file</vh></v>
<v t="ekr.20050704164036.97"><vh>get_history_length</vh></v>
<v t="ekr.20050704164036.98"><vh>set_history_length</vh></v>
<v t="ekr.20050704164036.99"><vh>set_startup_hook</vh></v>
<v t="ekr.20050704164036.100"><vh>set_pre_input_hook</vh></v>
<v t="ekr.20050704164036.101"><vh>set_completer</vh></v>
<v t="ekr.20050704164036.102"><vh>get_begidx</vh></v>
<v t="ekr.20050704164036.103"><vh>get_endidx</vh></v>
<v t="ekr.20050704164036.104"><vh>set_completer_delims</vh></v>
<v t="ekr.20050704164036.105"><vh>get_completer_delims</vh></v>
<v t="ekr.20050704164036.106"><vh>add_history</vh></v>
<v t="ekr.20050704164036.107"><vh>beginning_of_line</vh></v>
<v t="ekr.20050704164036.108"><vh>end_of_line</vh></v>
<v t="ekr.20050704164036.109"><vh>forward_char</vh></v>
<v t="ekr.20050704164036.110"><vh>backward_char</vh></v>
<v t="ekr.20050704164036.111"><vh>forward_word</vh></v>
<v t="ekr.20050704164036.112"><vh>backward_word</vh></v>
<v t="ekr.20050704164036.113"><vh>clear_screen</vh></v>
<v t="ekr.20050704164036.114"><vh>redraw_current_line</vh></v>
<v t="ekr.20050704164036.115"><vh>accept_line</vh></v>
<v t="ekr.20050704164036.116"><vh>previous_history</vh></v>
<v t="ekr.20050704164036.117"><vh>next_history</vh></v>
<v t="ekr.20050704164036.118"><vh>beginning_of_history</vh></v>
<v t="ekr.20050704164036.119"><vh>end_of_history</vh></v>
<v t="ekr.20050704164036.120"><vh>_i_search</vh></v>
<v t="ekr.20050704164036.121"><vh>reverse_search_history</vh></v>
<v t="ekr.20050704164036.122"><vh>forward_search_history</vh></v>
<v t="ekr.20050704164036.123"><vh>_non_i_search</vh></v>
<v t="ekr.20050704164036.124"><vh>non_incremental_reverse_search_history</vh></v>
<v t="ekr.20050704164036.125"><vh>non_incremental_forward_search_history</vh></v>
<v t="ekr.20050704164036.126"><vh>_search</vh></v>
<v t="ekr.20050704164036.127"><vh>history_search_forward</vh></v>
<v t="ekr.20050704164036.128"><vh>history_search_backward</vh></v>
<v t="ekr.20050704164036.129"><vh>yank_nth_arg</vh></v>
<v t="ekr.20050704164036.130"><vh>yank_last_arg</vh></v>
<v t="ekr.20050704164036.131"><vh>delete_char</vh></v>
<v t="ekr.20050704164036.132"><vh>backward_delete_char</vh></v>
<v t="ekr.20050704164036.133"><vh>forward_backward_delete_char</vh></v>
<v t="ekr.20050704164036.134"><vh>quoted_insert</vh></v>
<v t="ekr.20050704164036.135"><vh>tab_insert</vh></v>
<v t="ekr.20050704164036.136"><vh>self_insert</vh></v>
<v t="ekr.20050704164036.137"><vh>transpose_chars</vh></v>
<v t="ekr.20050704164036.138"><vh>transpose_words</vh></v>
<v t="ekr.20050704164036.139"><vh>upcase_word</vh></v>
<v t="ekr.20050704164036.140"><vh>downcase_word</vh></v>
<v t="ekr.20050704164036.141"><vh>capitalize_word</vh></v>
<v t="ekr.20050704164036.142"><vh>overwrite_mode</vh></v>
<v t="ekr.20050704164036.143"><vh>kill_line</vh></v>
<v t="ekr.20050704164036.144"><vh>backward_kill_line</vh></v>
<v t="ekr.20050704164036.145"><vh>unix_line_discard</vh></v>
<v t="ekr.20050704164036.146"><vh>kill_whole_line</vh></v>
<v t="ekr.20050704164036.147"><vh>kill_word</vh></v>
<v t="ekr.20050704164036.148"><vh>backward_kill_word</vh></v>
<v t="ekr.20050704164036.149"><vh>unix_word_rubout</vh></v>
<v t="ekr.20050704164036.150"><vh>delete_horizontal_space</vh></v>
<v t="ekr.20050704164036.151"><vh>kill_region</vh></v>
<v t="ekr.20050704164036.152"><vh>copy_region_as_kill</vh></v>
<v t="ekr.20050704164036.153"><vh>copy_backward_word</vh></v>
<v t="ekr.20050704164036.154"><vh>copy_forward_word</vh></v>
<v t="ekr.20050704164036.155"><vh>yank</vh></v>
<v t="ekr.20050704164036.156"><vh>yank_pop</vh></v>
<v t="ekr.20050704164036.157"><vh>digit_argument</vh></v>
<v t="ekr.20050704164036.158"><vh>universal_argument</vh></v>
<v t="ekr.20050704164036.159"><vh>_get_completions</vh></v>
<v t="ekr.20050704164036.160"><vh>_display_completions</vh></v>
<v t="ekr.20050704164036.161"><vh>complete</vh></v>
<v t="ekr.20050704164036.162"><vh>possible_completions</vh></v>
<v t="ekr.20050704164036.163"><vh>insert_completions</vh></v>
<v t="ekr.20050704164036.164"><vh>menu_complete</vh></v>
<v t="ekr.20050704164036.165"><vh>delete_char_or_list</vh></v>
<v t="ekr.20050704164036.166"><vh>start_kbd_macro</vh></v>
<v t="ekr.20050704164036.167"><vh>end_kbd_macro</vh></v>
<v t="ekr.20050704164036.168"><vh>call_last_kbd_macro</vh></v>
<v t="ekr.20050704164036.169"><vh>re_read_init_file</vh></v>
<v t="ekr.20050704164036.170"><vh>abort</vh></v>
<v t="ekr.20050704164036.171"><vh>do_uppercase_version</vh></v>
<v t="ekr.20050704164036.172"><vh>prefix_meta</vh></v>
<v t="ekr.20050704164036.173"><vh>undo</vh></v>
<v t="ekr.20050704164036.174"><vh>revert_line</vh></v>
<v t="ekr.20050704164036.175"><vh>tilde_expand</vh></v>
<v t="ekr.20050704164036.176"><vh>set_mark</vh></v>
<v t="ekr.20050704164036.177"><vh>exchange_point_and_mark</vh></v>
<v t="ekr.20050704164036.178"><vh>character_search</vh></v>
<v t="ekr.20050704164036.179"><vh>character_search_backward</vh></v>
<v t="ekr.20050704164036.180"><vh>insert_comment</vh></v>
<v t="ekr.20050704164036.181"><vh>dump_functions</vh></v>
<v t="ekr.20050704164036.182"><vh>dump_variables</vh></v>
<v t="ekr.20050704164036.183"><vh>dump_macros</vh></v>
<v t="ekr.20050704164036.184"><vh>_bind_key</vh></v>
<v t="ekr.20050704164036.185"><vh>emacs_editing_mode</vh></v>
<v t="ekr.20050704164036.186"><vh>vi_editing_mode</vh></v>
</v>
<v t="ekr.20050704164036.187"><vh>CTRL</vh></v>
<v t="ekr.20050704164036.188"><vh>commonprefix</vh></v>
<v t="ekr.20050704164036.189"><vh>GetOutputFile</vh></v>
</v>
<v t="ekr.20050704164036.190"><vh>PyReadline.py</vh>
<v t="ekr.20050704164036.191"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050704164036.192"><vh>quote_char</vh></v>
<v t="ekr.20050704164036.193"><vh>class Readline</vh>
<v t="ekr.20050704164036.194"><vh>__init__</vh></v>
<v t="ekr.20050704164036.195"><vh>_bell</vh></v>
<v t="ekr.20050704164036.196"><vh>_quoted_text</vh></v>
<v t="ekr.20050704164036.197"><vh>_line_text</vh></v>
<v t="ekr.20050704164036.198"><vh>_set_line</vh></v>
<v t="ekr.20050704164036.199"><vh>_reset_line</vh></v>
<v t="ekr.20050704164036.200"><vh>_clear_after</vh></v>
<v t="ekr.20050704164036.201"><vh>_set_cursor</vh></v>
<v t="ekr.20050704164036.202"><vh>_print_prompt</vh></v>
<v t="ekr.20050704164036.203"><vh>_update_prompt_pos</vh></v>
<v t="ekr.20050704164036.204"><vh>readline</vh></v>
<v t="ekr.20050704164036.205"><vh>parse_and_bind</vh></v>
<v t="ekr.20050704164036.206"><vh>get_line_buffer</vh></v>
<v t="ekr.20050704164036.207"><vh>insert_text</vh></v>
<v t="ekr.20050704164036.208"><vh>read_init_file</vh></v>
<v t="ekr.20050704164036.209"><vh>read_history_file</vh></v>
<v t="ekr.20050704164036.210"><vh>write_history_file</vh></v>
<v t="ekr.20050704164036.211"><vh>get_history_length</vh></v>
<v t="ekr.20050704164036.212"><vh>set_history_length</vh></v>
<v t="ekr.20050704164036.213"><vh>set_startup_hook</vh></v>
<v t="ekr.20050704164036.214"><vh>set_pre_input_hook</vh></v>
<v t="ekr.20050704164036.215"><vh>set_completer</vh></v>
<v t="ekr.20050704164036.216"><vh>get_completer</vh></v>
<v t="ekr.20050704164036.217"><vh>get_begidx</vh></v>
<v t="ekr.20050704164036.218"><vh>get_endidx</vh></v>
<v t="ekr.20050704164036.219"><vh>set_completer_delims</vh></v>
<v t="ekr.20050704164036.220"><vh>get_completer_delims</vh></v>
<v t="ekr.20050704164036.221"><vh>add_history</vh></v>
<v t="ekr.20050704164036.222"><vh>beginning_of_line</vh></v>
<v t="ekr.20050704164036.223"><vh>end_of_line</vh></v>
<v t="ekr.20050704164036.224"><vh>forward_char</vh></v>
<v t="ekr.20050704164036.225"><vh>backward_char</vh></v>
<v t="ekr.20050704164036.226"><vh>forward_word</vh></v>
<v t="ekr.20050704164036.227"><vh>backward_word</vh></v>
<v t="ekr.20050704164036.228"><vh>clear_screen</vh></v>
<v t="ekr.20050704164036.229"><vh>redraw_current_line</vh></v>
<v t="ekr.20050704164036.230"><vh>accept_line</vh></v>
<v t="ekr.20050704164036.231"><vh>previous_history</vh></v>
<v t="ekr.20050704164036.232"><vh>next_history</vh></v>
<v t="ekr.20050704164036.233"><vh>beginning_of_history</vh></v>
<v t="ekr.20050704164036.234"><vh>end_of_history</vh></v>
<v t="ekr.20050704164036.235"><vh>_i_search</vh></v>
<v t="ekr.20050704164036.236"><vh>reverse_search_history</vh></v>
<v t="ekr.20050704164036.237"><vh>forward_search_history</vh></v>
<v t="ekr.20050704164036.238"><vh>_non_i_search</vh></v>
<v t="ekr.20050704164036.239"><vh>non_incremental_reverse_search_history</vh></v>
<v t="ekr.20050704164036.240"><vh>non_incremental_forward_search_history</vh></v>
<v t="ekr.20050704164036.241"><vh>_search</vh></v>
<v t="ekr.20050704164036.242"><vh>history_search_forward</vh></v>
<v t="ekr.20050704164036.243"><vh>history_search_backward</vh></v>
<v t="ekr.20050704164036.244"><vh>yank_nth_arg</vh></v>
<v t="ekr.20050704164036.245"><vh>yank_last_arg</vh></v>
<v t="ekr.20050704164036.246"><vh>delete_char</vh></v>
<v t="ekr.20050704164036.247"><vh>backward_delete_char</vh></v>
<v t="ekr.20050704164036.248"><vh>forward_backward_delete_char</vh></v>
<v t="ekr.20050704164036.249"><vh>quoted_insert</vh></v>
<v t="ekr.20050704164036.250"><vh>tab_insert</vh></v>
<v t="ekr.20050704164036.251"><vh>self_insert</vh></v>
<v t="ekr.20050704164036.252"><vh>transpose_chars</vh></v>
<v t="ekr.20050704164036.253"><vh>transpose_words</vh></v>
<v t="ekr.20050704164036.254"><vh>upcase_word</vh></v>
<v t="ekr.20050704164036.255"><vh>downcase_word</vh></v>
<v t="ekr.20050704164036.256"><vh>capitalize_word</vh></v>
<v t="ekr.20050704164036.257"><vh>overwrite_mode</vh></v>
<v t="ekr.20050704164036.258"><vh>kill_line</vh></v>
<v t="ekr.20050704164036.259"><vh>backward_kill_line</vh></v>
<v t="ekr.20050704164036.260"><vh>unix_line_discard</vh></v>
<v t="ekr.20050704164036.261"><vh>kill_whole_line</vh></v>
<v t="ekr.20050704164036.262"><vh>kill_word</vh></v>
<v t="ekr.20050704164036.263"><vh>backward_kill_word</vh></v>
<v t="ekr.20050704164036.264"><vh>unix_word_rubout</vh></v>
<v t="ekr.20050704164036.265"><vh>delete_horizontal_space</vh></v>
<v t="ekr.20050704164036.266"><vh>kill_region</vh></v>
<v t="ekr.20050704164036.267"><vh>copy_region_as_kill</vh></v>
<v t="ekr.20050704164036.268"><vh>copy_backward_word</vh></v>
<v t="ekr.20050704164036.269"><vh>copy_forward_word</vh></v>
<v t="ekr.20050704164036.270"><vh>yank</vh></v>
<v t="ekr.20050704164036.271"><vh>yank_pop</vh></v>
<v t="ekr.20050704164036.272"><vh>digit_argument</vh></v>
<v t="ekr.20050704164036.273"><vh>universal_argument</vh></v>
<v t="ekr.20050704164036.274"><vh>_get_completions</vh></v>
<v t="ekr.20050704164036.275"><vh>_display_completions</vh></v>
<v t="ekr.20050704164036.276"><vh>complete</vh></v>
<v t="ekr.20050704164036.277"><vh>possible_completions</vh></v>
<v t="ekr.20050704164036.278"><vh>insert_completions</vh></v>
<v t="ekr.20050704164036.279"><vh>menu_complete</vh></v>
<v t="ekr.20050704164036.280"><vh>delete_char_or_list</vh></v>
<v t="ekr.20050704164036.281"><vh>start_kbd_macro</vh></v>
<v t="ekr.20050704164036.282"><vh>end_kbd_macro</vh></v>
<v t="ekr.20050704164036.283"><vh>call_last_kbd_macro</vh></v>
<v t="ekr.20050704164036.284"><vh>re_read_init_file</vh></v>
<v t="ekr.20050704164036.285"><vh>abort</vh></v>
<v t="ekr.20050704164036.286"><vh>do_uppercase_version</vh></v>
<v t="ekr.20050704164036.287"><vh>prefix_meta</vh></v>
<v t="ekr.20050704164036.288"><vh>undo</vh></v>
<v t="ekr.20050704164036.289"><vh>revert_line</vh></v>
<v t="ekr.20050704164036.290"><vh>tilde_expand</vh></v>
<v t="ekr.20050704164036.291"><vh>set_mark</vh></v>
<v t="ekr.20050704164036.292"><vh>exchange_point_and_mark</vh></v>
<v t="ekr.20050704164036.293"><vh>character_search</vh></v>
<v t="ekr.20050704164036.294"><vh>character_search_backward</vh></v>
<v t="ekr.20050704164036.295"><vh>insert_comment</vh></v>
<v t="ekr.20050704164036.296"><vh>dump_functions</vh></v>
<v t="ekr.20050704164036.297"><vh>dump_variables</vh></v>
<v t="ekr.20050704164036.298"><vh>dump_macros</vh></v>
<v t="ekr.20050704164036.299"><vh>_bind_key</vh></v>
<v t="ekr.20050704164036.300"><vh>emacs_editing_mode</vh></v>
<v t="ekr.20050704164036.301"><vh>vi_editing_mode</vh></v>
</v>
<v t="ekr.20050704164036.302"><vh>CTRL</vh></v>
<v t="ekr.20050704164036.303"><vh>commonprefix</vh></v>
<v t="ekr.20050704164036.304"><vh>GetOutputFile</vh></v>
</v>
</v>
<v t="ekr.20050704164142"><vh>IPython: c/Python24/Lib/site-packages/IPython/</vh>
<v t="ekr.20050704165326"><vh>usage.py</vh></v>
<v t="ekr.20050704165326.1"><vh>__init__.py</vh></v>
<v t="ekr.20050704165326.2"><vh>background_jobs.py</vh>
<v t="ekr.20050704170205.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050704165326.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050704165326.4"><vh>class BackgroundJobManager</vh>
<v t="ekr.20050704165326.5"><vh>__init__</vh></v>
<v t="ekr.20050704165326.6"><vh>new</vh></v>
<v t="ekr.20050704165326.7"><vh>__getitem__</vh></v>
<v t="ekr.20050704165326.8"><vh>__call__</vh></v>
<v t="ekr.20050704165326.9"><vh>_update_status</vh></v>
<v t="ekr.20050704165326.10"><vh>_group_report</vh></v>
<v t="ekr.20050704165326.11"><vh>_group_flush</vh></v>
<v t="ekr.20050704165326.12"><vh>_status_new</vh></v>
<v t="ekr.20050704165326.13"><vh>status</vh></v>
<v t="ekr.20050704165326.14"><vh>remove</vh></v>
<v t="ekr.20050704165326.15"><vh>flush_finished</vh></v>
<v t="ekr.20050704165326.16"><vh>result</vh></v>
<v t="ekr.20050704165326.17"><vh>traceback</vh></v>
</v>
<v t="ekr.20050704165326.18"><vh>class BackgroundJobBase</vh>
<v t="ekr.20050704165326.19"><vh>&lt;&lt; class BackgroundJobBase declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.20"><vh>__init__</vh></v>
<v t="ekr.20050704165326.21"><vh>_init</vh></v>
<v t="ekr.20050704165326.22"><vh>__str__</vh></v>
<v t="ekr.20050704165326.23"><vh>__repr__</vh></v>
<v t="ekr.20050704165326.24"><vh>traceback</vh></v>
<v t="ekr.20050704165326.25"><vh>run</vh></v>
</v>
<v t="ekr.20050704165326.26"><vh>class BackgroundJobExpr</vh>
<v t="ekr.20050704165326.27"><vh>__init__</vh></v>
<v t="ekr.20050704165326.28"><vh>call</vh></v>
</v>
<v t="ekr.20050704165326.29"><vh>class BackgroundJobFunc</vh>
<v t="ekr.20050704165326.30"><vh>__init__</vh></v>
<v t="ekr.20050704165326.31"><vh>call</vh></v>
</v>
<v t="ekr.20050704165326.32"><vh>sleepfunc</vh></v>
</v>
<v t="ekr.20050704165326.33"><vh>ColorANSI.py</vh>
<v t="ekr.20050704170205"><vh>&lt;&lt; copywrite &gt;&gt;</vh></v>
<v t="ekr.20050704165326.34"><vh>&lt;&lt; ColorANSI declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.35"><vh>make_color_table</vh></v>
<v t="ekr.20050704165326.36"><vh>class TermColors</vh>
<v t="ekr.20050704165326.37"><vh>&lt;&lt; class TermColors declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.38"><vh>class InputTermColors</vh>
<v t="ekr.20050704165326.39"><vh>&lt;&lt; class InputTermColors declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.40"><vh>class ColorScheme</vh>
<v t="ekr.20050704165326.41"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.42"><vh>class ColorSchemeTable</vh>
<v t="ekr.20050704165326.43"><vh>__init__</vh></v>
<v t="ekr.20050704165326.44"><vh>add_scheme</vh></v>
<v t="ekr.20050704165326.45"><vh>set_active_scheme</vh></v>
</v>
</v>
<v t="ekr.20050704165326.46"><vh>ConfigLoader.py</vh>
<v t="ekr.20050704165326.47"><vh>&lt;&lt; ConfigLoader declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.48"><vh>class ConfigLoaderError</vh>
<v t="ekr.20050704165326.49"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.50"><vh>class ConfigLoader</vh>
<v t="ekr.20050704165326.51"><vh>__init__</vh></v>
<v t="ekr.20050704165326.52"><vh>reset</vh></v>
<v t="ekr.20050704165326.53"><vh>load</vh></v>
</v>
</v>
<v t="ekr.20050704165326.54"><vh>CrashHandler.py</vh>
<v t="ekr.20050704165326.55"><vh>&lt;&lt; CrashHandler declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.56"><vh>class CrashHandler</vh>
<v t="ekr.20050704165326.57"><vh>__init__</vh></v>
<v t="ekr.20050704165326.58"><vh>__call__</vh></v>
</v>
</v>
<v t="ekr.20050704165326.59"><vh>Debugger.py</vh>
<v t="ekr.20050704165326.60"><vh>&lt;&lt; Debugger declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.61"><vh>class Pdb</vh>
<v t="ekr.20050704165326.62"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20050704165326.63"><vh>deep_reload.py</vh>
<v t="ekr.20050704165326.64"><vh>&lt;&lt; deep_reload declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.65"><vh>deep_import_hook</vh></v>
<v t="ekr.20050704165326.66"><vh>determine_parent</vh></v>
<v t="ekr.20050704165326.67"><vh>find_head_package</vh></v>
<v t="ekr.20050704165326.68"><vh>load_tail</vh></v>
<v t="ekr.20050704165326.69"><vh>ensure_fromlist</vh></v>
<v t="ekr.20050704165326.70"><vh>import_module</vh></v>
<v t="ekr.20050704165326.71"><vh>deep_reload_hook</vh></v>
<v t="ekr.20050704165326.72"><vh>reload</vh></v>
</v>
<v t="ekr.20050704165326.73"><vh>DPyGetOpt.py</vh>
<v t="ekr.20050704165326.74"><vh>&lt;&lt; DPyGetOpt declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.75"><vh>class DPyGetOpt</vh>
<v t="ekr.20050704165326.76"><vh>__init__</vh></v>
<v t="ekr.20050704165326.77"><vh>setPosixCompliance</vh></v>
<v t="ekr.20050704165326.78"><vh>isPosixCompliant</vh></v>
<v t="ekr.20050704165326.79"><vh>setIgnoreCase</vh></v>
<v t="ekr.20050704165326.80"><vh>ignoreCase</vh></v>
<v t="ekr.20050704165326.81"><vh>setAllowAbbreviations</vh></v>
<v t="ekr.20050704165326.82"><vh>willAllowAbbreviations</vh></v>
<v t="ekr.20050704165326.83"><vh>addTerminator</vh></v>
<v t="ekr.20050704165326.84"><vh>_addOption</vh></v>
<v t="ekr.20050704165326.85"><vh>addOptionConfigurationTuple</vh></v>
<v t="ekr.20050704165326.86"><vh>addOptionConfigurationTuples</vh></v>
<v t="ekr.20050704165326.87"><vh>parseConfiguration</vh></v>
<v t="ekr.20050704165326.88"><vh>_getArgTuple</vh></v>
<v t="ekr.20050704165326.89"><vh>_isTerminator</vh></v>
<v t="ekr.20050704165326.90"><vh>processArguments</vh></v>
<v t="ekr.20050704165326.91"><vh>valueForOption</vh></v>
</v>
<v t="ekr.20050704165326.92"><vh>_test</vh></v>
</v>
<v t="ekr.20050704165326.93"><vh>FakeModule.py</vh>
<v t="ekr.20050704165326.94"><vh>&lt;&lt; FakeModule declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.95"><vh>class FakeModule</vh>
<v t="ekr.20050704165326.96"><vh>__init__</vh></v>
<v t="ekr.20050704165326.97"><vh>__getattr__</vh></v>
<v t="ekr.20050704165326.98"><vh>__str__</vh></v>
<v t="ekr.20050704165326.99"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20050704165326.100"><vh>FlexCompleter.py</vh>
<v t="ekr.20050704165326.101"><vh>&lt;&lt; FlexCompleter declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.102"><vh>class Completer</vh>
<v t="ekr.20050704165326.103"><vh>__init__</vh></v>
<v t="ekr.20050704165326.104"><vh>complete</vh></v>
<v t="ekr.20050704165326.105"><vh>global_matches</vh></v>
<v t="ekr.20050704165326.106"><vh>attr_matches</vh></v>
</v>
<v t="ekr.20050704165326.107"><vh>get_class_members</vh></v>
</v>
<v t="ekr.20050704165326.108"><vh>genutils.py</vh>
<v t="ekr.20050704165326.109"><vh>&lt;&lt; genutils declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.110"><vh>class Error</vh>
<v t="ekr.20050704165326.111"><vh>&lt;&lt; class Error declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.112"><vh>class Stream</vh>
<v t="ekr.20050704165326.113"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.114"><vh>class Term</vh>
<v t="ekr.20050704165326.115"><vh>&lt;&lt; class Term declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.116"><vh>reopen_all</vh></v>
<v t="ekr.20050704165326.117"><vh>set_stdout</vh></v>
<v t="ekr.20050704165326.118"><vh>set_stderr</vh></v>
</v>
<v t="ekr.20050704165326.119"><vh>warn</vh></v>
<v t="ekr.20050704165326.120"><vh>info</vh></v>
<v t="ekr.20050704165326.121"><vh>error</vh></v>
<v t="ekr.20050704165326.122"><vh>fatal</vh></v>
<v t="ekr.20050704165326.123"><vh>clock</vh></v>
<v t="ekr.20050704165326.124"><vh>clock2</vh></v>
<v t="ekr.20050704165326.125"><vh>timings_out</vh></v>
<v t="ekr.20050704165326.126"><vh>timings</vh></v>
<v t="ekr.20050704165326.127"><vh>timing</vh></v>
<v t="ekr.20050704165326.128"><vh>system</vh></v>
<v t="ekr.20050704165326.129"><vh>shell</vh></v>
<v t="ekr.20050704165326.130"><vh>getoutput</vh></v>
<v t="ekr.20050704165326.131"><vh>getoutputerror</vh></v>
<v t="ekr.20050704165326.132"><vh>class SystemExec</vh>
<v t="ekr.20050704165326.133"><vh>__init__</vh></v>
<v t="ekr.20050704165326.134"><vh>system</vh></v>
<v t="ekr.20050704165326.135"><vh>shell</vh></v>
<v t="ekr.20050704165326.136"><vh>getoutput</vh></v>
<v t="ekr.20050704165326.137"><vh>getoutputerror</vh></v>
</v>
<v t="ekr.20050704165326.138"><vh>mutex_opts</vh></v>
<v t="ekr.20050704165326.139"><vh>filefind</vh></v>
<v t="ekr.20050704165326.140"><vh>target_outdated</vh></v>
<v t="ekr.20050704165326.141"><vh>target_update</vh></v>
<v t="ekr.20050704165326.142"><vh>unquote_ends</vh></v>
<v t="ekr.20050704165326.143"><vh>process_cmdline</vh></v>
<v t="ekr.20050704165326.144"><vh>optstr2types</vh></v>
<v t="ekr.20050704165326.145"><vh>read_dict</vh></v>
<v t="ekr.20050704165326.146"><vh>flag_calls</vh></v>
<v t="ekr.20050704165326.147"><vh>class HomeDirError</vh>
<v t="ekr.20050704165326.148"><vh>&lt;&lt; class HomeDirError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.149"><vh>get_home_dir</vh></v>
<v t="ekr.20050704165326.150"><vh>class LSString</vh>
<v t="ekr.20050704165326.151"><vh>get_list</vh></v>
<v t="ekr.20050704165326.152"><vh>get_spstr</vh></v>
<v t="ekr.20050704165326.153"><vh>get_nlstr</vh></v>
</v>
<v t="ekr.20050704165326.154"><vh>class SList</vh>
<v t="ekr.20050704165326.155"><vh>get_list</vh></v>
<v t="ekr.20050704165326.156"><vh>get_spstr</vh></v>
<v t="ekr.20050704165326.157"><vh>get_nlstr</vh></v>
</v>
<v t="ekr.20050704165326.158"><vh>raw_input_multi</vh></v>
<v t="ekr.20050704165326.159"><vh>raw_input_ext</vh></v>
<v t="ekr.20050704165326.160"><vh>ask_yes_no</vh></v>
<v t="ekr.20050704165326.161"><vh>class EvalDict</vh>
<v t="ekr.20050704165326.162"><vh>&lt;&lt; class EvalDict declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.163"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20050704165326.164"><vh>qw</vh></v>
<v t="ekr.20050704165326.165"><vh>qwflat</vh></v>
<v t="ekr.20050704165326.166"><vh>list_strings</vh></v>
<v t="ekr.20050704165326.167"><vh>grep</vh></v>
<v t="ekr.20050704165326.168"><vh>dgrep</vh></v>
<v t="ekr.20050704165326.169"><vh>idgrep</vh></v>
<v t="ekr.20050704165326.170"><vh>igrep</vh></v>
<v t="ekr.20050704165326.171"><vh>indent</vh></v>
<v t="ekr.20050704165326.172"><vh>native_line_ends</vh></v>
<v t="ekr.20050704165326.173"><vh>get_pager_cmd</vh></v>
<v t="ekr.20050704165326.174"><vh>get_pager_start</vh></v>
<v t="ekr.20050704165326.175"><vh>page_dumb</vh></v>
<v t="ekr.20050704165326.176"><vh>page (genutils)</vh></v>
<v t="ekr.20050704165326.177"><vh>page_file</vh></v>
<v t="ekr.20050704165326.178"><vh>snip_print</vh></v>
<v t="ekr.20050704165326.179"><vh>belong</vh></v>
<v t="ekr.20050704165326.180"><vh>uniq_stable</vh></v>
<v t="ekr.20050704165326.181"><vh>class NLprinter</vh>
<v t="ekr.20050704165326.182"><vh>__init__</vh></v>
<v t="ekr.20050704165326.183"><vh>__call__</vh></v>
</v>
<v t="ekr.20050704165326.184"><vh>all_belong</vh></v>
<v t="ekr.20050704165326.185"><vh>sort_compare</vh></v>
<v t="ekr.20050704165326.186"><vh>mkdict</vh></v>
<v t="ekr.20050704165326.187"><vh>list2dict</vh></v>
<v t="ekr.20050704165326.188"><vh>list2dict2</vh></v>
<v t="ekr.20050704165326.189"><vh>flatten</vh></v>
<v t="ekr.20050704165326.190"><vh>get_slice</vh></v>
<v t="ekr.20050704165326.191"><vh>chop</vh></v>
<v t="ekr.20050704165326.192"><vh>with</vh></v>
<v t="ekr.20050704165326.193"><vh>setattr_list</vh></v>
<v t="ekr.20050704165326.194"><vh>getattr_list</vh></v>
<v t="ekr.20050704165326.195"><vh>map_method</vh></v>
<v t="ekr.20050704165326.196"><vh>class NotGiven</vh></v>
<v t="ekr.20050704165326.197"><vh>popkey</vh></v>
</v>
<v t="ekr.20050704165326.198"><vh>Gnuplot2.py</vh>
<v t="ekr.20050704165326.199"><vh>&lt;&lt; Gnuplot2 declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.200"><vh>class File</vh>
<v t="ekr.20050704165326.201"><vh>&lt;&lt; class File declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.202"><vh>__init__</vh></v>
<v t="ekr.20050704165326.203"><vh>set_option_index</vh></v>
</v>
<v t="ekr.20050704165326.204"><vh>eps_fix_bbox</vh></v>
<v t="ekr.20050704165326.205"><vh>is_list1d</vh></v>
<v t="ekr.20050704165326.206"><vh>zip_items</vh></v>
<v t="ekr.20050704165326.207"><vh>class StandaloneItem</vh></v>
<v t="ekr.20050704165326.208"><vh>get_titles</vh></v>
<v t="ekr.20050704165326.209"><vh>class String</vh>
<v t="ekr.20050704165326.210"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.211"><vh>class Gnuplot</vh>
<v t="ekr.20050704165326.212"><vh>xrange</vh></v>
<v t="ekr.20050704165326.213"><vh>yrange</vh></v>
<v t="ekr.20050704165326.214"><vh>zrange</vh></v>
<v t="ekr.20050704165326.215"><vh>x2range</vh></v>
<v t="ekr.20050704165326.216"><vh>y2range</vh></v>
<v t="ekr.20050704165326.217"><vh>z2range</vh></v>
<v t="ekr.20050704165326.218"><vh>rrange</vh></v>
<v t="ekr.20050704165326.219"><vh>trange</vh></v>
<v t="ekr.20050704165326.220"><vh>urange</vh></v>
<v t="ekr.20050704165326.221"><vh>vrange</vh></v>
<v t="ekr.20050704165326.222"><vh>set_ps</vh></v>
<v t="ekr.20050704165326.223"><vh>__plot_ps</vh></v>
<v t="ekr.20050704165326.224"><vh>plot</vh></v>
<v t="ekr.20050704165326.225"><vh>plot2</vh></v>
<v t="ekr.20050704165326.226"><vh>splot</vh></v>
<v t="ekr.20050704165326.227"><vh>replot</vh></v>
<v t="ekr.20050704165326.228"><vh>hardcopy</vh></v>
</v>
</v>
<v t="ekr.20050704165326.229"><vh>GnuplotInteractive.py</vh>
<v t="ekr.20050704165326.230"><vh>&lt;&lt; GnuplotInteractive declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.231"><vh>gphelp</vh></v>
<v t="ekr.20050704165326.232"><vh>magic_gpc</vh></v>
<v t="ekr.20050704165326.233"><vh>magic_gp_set_default</vh></v>
</v>
<v t="ekr.20050704165326.234"><vh>GnuplotRuntime.py</vh>
<v t="ekr.20050704165326.235"><vh>&lt;&lt; GnuplotRuntime declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.236"><vh>class NotGiven</vh></v>
<v t="ekr.20050704165326.237"><vh>gp_new</vh></v>
</v>
<v t="ekr.20050704165326.238"><vh>hooks.py</vh>
<v t="ekr.20050704165326.239"><vh>&lt;&lt; hooks declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.240"><vh>editor</vh></v>
</v>
<v t="ekr.20050704165326.241" a="M"><vh>iplib.py (contains InteractiveShell) CONTAINS ALL IPYTHON SPECIFIC STUFF</vh>
<v t="ekr.20050704165326.242"><vh>&lt;&lt; iplib declarations &gt;&gt;</vh></v>
<v t="ekr.20050708081540"><vh>Utilities</vh>
<v t="ekr.20050704165326.243"><vh>enumerate</vh></v>
<v t="ekr.20050704165326.244"><vh>class Bunch</vh></v>
<v t="ekr.20050704165326.245"><vh>esc_quotes</vh></v>
<v t="ekr.20050704165326.246"><vh>import_fail_info</vh></v>
<v t="ekr.20050704165326.247"><vh>qw_lol</vh></v>
</v>
<v t="ekr.20050704165326.248"><vh>ipmagic (in iplib.py)</vh></v>
<v t="ekr.20050704165326.249"><vh>ipalias</vh></v>
<v t="ekr.20050704165326.250"><vh>class MagicCompleter</vh>
<v t="ekr.20050704165326.251"><vh>__init__</vh></v>
<v t="ekr.20050704165326.252"><vh>all_completions</vh></v>
<v t="ekr.20050704165326.253"><vh>_clean_glob</vh></v>
<v t="ekr.20050704165326.254"><vh>_clean_glob_win32</vh></v>
<v t="ekr.20050704165326.255"><vh>file_matches</vh></v>
<v t="ekr.20050704165326.256"><vh>alias_matches</vh></v>
<v t="ekr.20050704165326.257"><vh>python_matches</vh></v>
<v t="ekr.20050704165326.258"><vh>_default_arguments</vh></v>
<v t="ekr.20050704165326.259"><vh>python_func_kw_matches</vh></v>
<v t="ekr.20050704165326.260"><vh>complete</vh></v>
</v>
<v t="ekr.20050704165326.261"><vh>class InputList</vh>
<v t="ekr.20050704165326.262"><vh>__getslice__</vh></v>
</v>
<v t="ekr.20050704165326.263"><vh>class SpaceInInput</vh>
<v t="ekr.20050704165326.264"><vh>&lt;&lt; class SpaceInInput declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.265" a="EM"><vh>class InteractiveShell (code.InteractiveConsole,Logger,Magic) (in iplib.py)</vh>
<v t="ekr.20050704165326.266"><vh>__init__</vh>
<v t="ekr.20050707212426"><vh>&lt;&lt; add stuff to builtins &gt;&gt;</vh></v>
<v t="ekr.20050707212426.1"><vh>&lt;&lt; Create the namespace where the user will operate &gt;&gt;</vh></v>
<v t="ekr.20050707212426.2"><vh>&lt;&lt; create ivars &gt;&gt;</vh></v>
<v t="ekr.20050707212426.3"><vh>&lt;&lt; handle escapes &gt;&gt;</vh></v>
<v t="ekr.20050708080420"><vh>&lt;&lt; create a job manager &gt;&gt;</vh></v>
<v t="ekr.20050708080420.1"><vh>&lt;&lt; init classes &gt;&gt;</vh></v>
<v t="ekr.20050708080420.2"><vh>&lt;&lt; set all default hooks, defined in the IPython.hooks module &gt;&gt;</vh></v>
<v t="ekr.20050708080420.3"><vh>&lt;&lt; define usage messages &gt;&gt;</vh></v>
<v t="ekr.20050708080420.4"><vh>&lt;&lt; define functions to call the underlying shell &gt;&gt;</vh></v>
<v t="ekr.20050708080420.5"><vh>&lt;&lt; define regular expressions &gt;&gt;</vh></v>
<v t="ekr.20050708080420.6"><vh>&lt;&lt; Attributes for Logger mixin class, make defaults here &gt;&gt;</vh></v>
<v t="ekr.20050708080420.7"><vh>&lt;&lt; various switches which can be set &gt;&gt;</vh></v>
<v t="ekr.20050708080420.8"><vh>&lt;&lt; traceBack handlers &gt;&gt;</vh></v>
<v t="ekr.20050708080420.9"><vh>&lt;&lt; object inspector &gt;&gt;</vh></v>
<v t="ekr.20050708080420.10"><vh>&lt;&lt; Make some aliases automatically &gt;&gt;</vh></v>
<v t="ekr.20050708080420.11"><vh>&lt;&lt; storage &gt;&gt;</vh></v>
<v t="ekr.20050708080420.12"><vh>&lt;&lt; for pushd/popd management &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708082932"><vh>Customization...</vh>
<v t="ekr.20050704165326.267"><vh>set_hook</vh></v>
<v t="ekr.20050707224615"><vh>set_custom_exc</vh></v>
<v t="ekr.20050707224710"><vh>set_custom_completer</vh></v>
</v>
<v t="ekr.20050708082932.1"><vh>Init...</vh>
<v t="ekr.20050707224710.1"><vh>post_config_initialization</vh></v>
<v t="ekr.20050707224710.2"><vh>init_auto_alias</vh></v>
<v t="ekr.20050707224710.3"><vh>alias_table_validate</vh></v>
<v t="ekr.20050707224710.6"><vh>user_setup</vh></v>
<v t="ekr.20050707224710.5"><vh>rc_set_toggle (not called from InteractiveShell)</vh></v>
</v>
<v t="ekr.20050708084235"><vh>Death...</vh>
<v t="ekr.20050707224710.7"><vh>atexit_operations</vh></v>
<v t="ekr.20050707230243.1"><vh>savehist</vh></v>
</v>
<v t="ekr.20050708084235.1"><vh>Interactives stuff (will not be used in Leo)</vh>
<v t="ekr.20050708082932.2"><vh>Readline...</vh>
<v t="ekr.20050707230243.2"><vh>pre_readline</vh></v>
<v t="ekr.20050707230243.3"><vh>init_readline</vh></v>
<v t="ekr.20050707224710.4"><vh>set_autoindent (called only from init_readline)</vh></v>
</v>
<v t="ekr.20050707230243.5"><vh>debugger</vh></v>
<v t="ekr.20050707230243.9"><vh>mainloop &amp; name_space_init</vh>
<v t="ekr.20050707230243.8"><vh>name_space_init</vh></v>
</v>
<v t="ekr.20050707230243.11"><vh>embed_mainloop</vh></v>
<v t="ekr.20050707230243.15"><vh>runlines</vh></v>
</v>
<v t="ekr.20050708084235.2"><vh>Calling system stuff</vh>
<v t="ekr.20050707230243.10"><vh>exec_init_cmd</vh></v>
<v t="ekr.20050707230243.14"><vh>call_alias</vh></v>
</v>
<v t="ekr.20050708072233.1"><vh>Overrides of code.InteractiveInterpreter</vh>
<v t="ekr.20050707230243.17"><vh>runcode</vh></v>
<v t="ekr.20050707230243.16"><vh>runsource</vh></v>
<v t="ekr.20050707230243.4"><vh>showsyntaxerror</vh></v>
<v t="ekr.20050707230243.6"><vh>showtraceback</vh></v>
<v t="ekr.20050708072233.2"><vh>write (use base class)  COULD OVERRIDE THIS</vh></v>
<v t="ekr.20050707230243.13"><vh>excepthook (helper)</vh></v>
</v>
<v t="ekr.20050708071222"><vh>Overrides of code.InteractiveConsole</vh>
<v t="ekr.20050707230243.12" a="M"><vh>interact</vh></v>
<v t="ekr.20050708072233.3"><vh>push (use base class)</vh></v>
<v t="ekr.20050707230243.18"><vh>raw_input</vh></v>
<v t="ekr.20050708072233.4"><vh>resetbuffer (use base class)</vh></v>
</v>
<v t="ekr.20050708074118.6" a="E"><vh>prefilter &amp; helpers</vh>
<v t="ekr.20050707230243.21"><vh>_prefilter_dumb</vh></v>
<v t="ekr.20050707230243.20" a="EM"><vh>_prefilter (Rewrite?)</vh>
<v t="ekr.20050708074118"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708074118.1"><vh>&lt;&lt; handle empty line &gt;&gt;</vh></v>
<v t="ekr.20050708074118.2"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708074118.3"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708074118.4"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708074118.5"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050707230243.22"><vh>handle_normal</vh></v>
<v t="ekr.20050707230243.23"><vh>handle_alias</vh></v>
<v t="ekr.20050707230243.24"><vh>handle_shell_escape</vh></v>
<v t="ekr.20050707230243.25"><vh>handle_magic</vh></v>
<v t="ekr.20050707230243.26"><vh>handle_auto</vh></v>
<v t="ekr.20050707230243.27"><vh>handle_help</vh></v>
<v t="ekr.20050707230243.28"><vh>handle_emacs</vh></v>
<v t="ekr.20050707230243.29"><vh>safe_execfile</vh></v>
<v t="ekr.20050707230243.19"><vh>split_user_input</vh></v>
<v t="ekr.20050707230243.7"><vh>update_cache</vh></v>
</v>
</v>
</v>
<v t="ekr.20050704165326.268" a="M"><vh>ipmaker.py</vh>
<v t="ekr.20050704165326.269"><vh>&lt;&lt; ipmaker declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.270"><vh>make_IPython</vh></v>
<v t="ekr.20050707185729.1"><vh>&lt;&lt; directory stuff &gt;&gt;</vh></v>
<v t="ekr.20050707185105"><vh>&lt;&lt; handle log replay &gt;&gt;</vh></v>
<v t="ekr.20050707185105.1"><vh>&lt;&lt; set output traps &gt;&gt;</vh></v>
<v t="ekr.20050707185105.2"><vh>&lt;&lt; process ipythonrc config files &gt;&gt;</vh></v>
<v t="ekr.20050707185105.3"><vh>&lt;&lt; execute user config &gt;&gt;</vh></v>
<v t="ekr.20050707185105.4" a="M"><vh>&lt;&lt; setup interactive session &gt;&gt;</vh></v>
<v t="ekr.20050707185105.5"><vh>&lt;&lt; command line handling &gt;&gt;</vh>
<v t="ekr.20050707185105.6"><vh>&lt;&lt; Set sensible command line defaults &gt;&gt;</vh></v>
</v>
<v t="ekr.20050707185729"><vh>&lt;&lt; set exception handlers in mode requested by user &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.271"><vh>Itpl.py</vh>
<v t="ekr.20050704165326.272"><vh>&lt;&lt; Itpl declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.273"><vh>class ItplError</vh>
<v t="ekr.20050704165326.274"><vh>__init__</vh></v>
<v t="ekr.20050704165326.275"><vh>__str__</vh></v>
</v>
<v t="ekr.20050704165326.276"><vh>matchorfail</vh></v>
<v t="ekr.20050704165326.277"><vh>class Itpl</vh>
<v t="ekr.20050704165326.278"><vh>__init__</vh></v>
<v t="ekr.20050704165326.279"><vh>__repr__</vh></v>
<v t="ekr.20050704165326.280"><vh>__str__</vh></v>
</v>
<v t="ekr.20050704165326.281"><vh>class ItplNS</vh>
<v t="ekr.20050704165326.282"><vh>__init__</vh></v>
<v t="ekr.20050704165326.283"><vh>__str__</vh></v>
</v>
<v t="ekr.20050704165326.284"><vh>itpl</vh></v>
<v t="ekr.20050704165326.285"><vh>printpl</vh></v>
<v t="ekr.20050704165326.286"><vh>itplns</vh></v>
<v t="ekr.20050704165326.287"><vh>printplns</vh></v>
<v t="ekr.20050704165326.288"><vh>class ItplFile</vh>
<v t="ekr.20050704165326.289"><vh>__init__</vh></v>
<v t="ekr.20050704165326.290"><vh>__repr__</vh></v>
<v t="ekr.20050704165326.291"><vh>__getattr__</vh></v>
<v t="ekr.20050704165326.292"><vh>write</vh></v>
</v>
<v t="ekr.20050704165326.293"><vh>filter</vh></v>
<v t="ekr.20050704165326.294"><vh>unfilter</vh></v>
</v>
<v t="ekr.20050704165326.295"><vh>Logger.py</vh>
<v t="ekr.20050704165326.296"><vh>&lt;&lt; Logger declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.297"><vh>class Logger</vh>
<v t="ekr.20050704165326.299"><vh>__init__</vh></v>
<v t="ekr.20050704165326.300"><vh>create_log</vh></v>
<v t="ekr.20050704165326.301"><vh>logstart</vh></v>
<v t="ekr.20050704165326.302"><vh>switch_log</vh></v>
<v t="ekr.20050704165326.303"><vh>logstate</vh></v>
<v t="ekr.20050704165326.304"><vh>log</vh></v>
<v t="ekr.20050704165326.305"><vh>close_log</vh></v>
</v>
</v>
<v t="ekr.20050704165326.306"><vh>Magic.py</vh>
<v t="ekr.20050704165326.307"><vh>&lt;&lt; Magic declarations &gt;&gt;</vh></v>
<v t="ekr.20050708080420.13"><vh>Utility functions</vh>
<v t="ekr.20050704165326.308"><vh>magic2python</vh></v>
<v t="ekr.20050704165326.309"><vh>on_off</vh></v>
<v t="ekr.20050704165326.310"><vh>get_py_filename</vh></v>
<v t="ekr.20050704165326.311"><vh>shlex_split</vh></v>
</v>
<v t="ekr.20050704165326.312"><vh>class Macro</vh>
<v t="ekr.20050704165326.313"><vh>__init__</vh></v>
<v t="ekr.20050704165326.314"><vh>__str__</vh></v>
</v>
<v t="ekr.20050704165326.315"><vh>class Magic</vh>
<v t="ekr.20050704165326.317"><vh>__init__</vh></v>
<v t="ekr.20050704165326.318"><vh>profile_missing_notice</vh></v>
<v t="ekr.20050704165326.319"><vh>default_option</vh></v>
<v t="ekr.20050704165326.320"><vh>lsmagic</vh></v>
<v t="ekr.20050704165326.321"><vh>set_shell</vh></v>
<v t="ekr.20050704165326.322"><vh>extract_input_slices</vh></v>
<v t="ekr.20050704165326.323"><vh>_ofind</vh></v>
<v t="ekr.20050704165326.324"><vh>arg_err</vh></v>
<v t="ekr.20050704165326.325"><vh>format_latex</vh></v>
<v t="ekr.20050704165326.326"><vh>format_screen</vh></v>
<v t="ekr.20050704165326.327"><vh>parse_options</vh></v>
<v t="ekr.20050704165326.328"><vh>magic_lsmagic</vh></v>
<v t="ekr.20050704165326.329"><vh>magic_magic</vh></v>
<v t="ekr.20050704165326.330"><vh>magic_automagic</vh></v>
<v t="ekr.20050704165326.331"><vh>magic_autocall</vh></v>
<v t="ekr.20050704165326.332"><vh>magic_autoindent</vh></v>
<v t="ekr.20050704165326.333"><vh>magic_system_verbose</vh></v>
<v t="ekr.20050704165326.334"><vh>magic_history</vh></v>
<v t="ekr.20050704165326.335"><vh>magic_hist</vh></v>
<v t="ekr.20050704165326.336"><vh>magic_p</vh></v>
<v t="ekr.20050704165326.337"><vh>magic_r</vh></v>
<v t="ekr.20050704165326.338"><vh>magic_page</vh></v>
<v t="ekr.20050704165326.339"><vh>magic_profile</vh></v>
<v t="ekr.20050704165326.340"><vh>_inspect</vh></v>
<v t="ekr.20050704165326.341"><vh>magic_pdef</vh></v>
<v t="ekr.20050704165326.342"><vh>magic_pdoc</vh></v>
<v t="ekr.20050704165326.343"><vh>magic_psource</vh></v>
<v t="ekr.20050704165326.344"><vh>magic_pfile</vh></v>
<v t="ekr.20050704165326.345"><vh>magic_pinfo</vh></v>
<v t="ekr.20050704165326.346"><vh>magic_who_ls</vh></v>
<v t="ekr.20050704165326.347"><vh>magic_who</vh></v>
<v t="ekr.20050704165326.348"><vh>magic_whos</vh></v>
<v t="ekr.20050704165326.349"><vh>magic_reset</vh></v>
<v t="ekr.20050704165326.350"><vh>magic_config</vh></v>
<v t="ekr.20050704165326.351"><vh>magic_logstart</vh></v>
<v t="ekr.20050704165326.352"><vh>magic_logoff</vh></v>
<v t="ekr.20050704165326.353"><vh>magic_logon</vh></v>
<v t="ekr.20050704165326.354"><vh>magic_logstate</vh></v>
<v t="ekr.20050704165326.355"><vh>magic_pdb</vh></v>
<v t="ekr.20050704165326.356"><vh>magic_prun</vh></v>
<v t="ekr.20050704165326.357"><vh>magic_run</vh></v>
<v t="ekr.20050704165326.358"><vh>magic_runlog</vh></v>
<v t="ekr.20050704165326.359"><vh>magic_time</vh></v>
<v t="ekr.20050704165326.360"><vh>magic_macro</vh></v>
<v t="ekr.20050704165326.361"><vh>magic_save</vh></v>
<v t="ekr.20050704165326.362"><vh>magic_ed</vh></v>
<v t="ekr.20050704165326.363"><vh>magic_edit</vh></v>
<v t="ekr.20050704165326.364"><vh>magic_xmode</vh></v>
<v t="ekr.20050704165326.365"><vh>magic_colors</vh></v>
<v t="ekr.20050704165326.366"><vh>magic_color_info</vh></v>
<v t="ekr.20050704165326.367"><vh>magic_Pprint</vh></v>
<v t="ekr.20050704165326.368"><vh>magic_Exit</vh></v>
<v t="ekr.20050704165326.369"><vh>magic_Quit</vh></v>
<v t="ekr.20050704165326.370"><vh>magic_alias</vh></v>
<v t="ekr.20050704165326.371"><vh>magic_unalias</vh></v>
<v t="ekr.20050704165326.372"><vh>magic_rehash</vh></v>
<v t="ekr.20050704165326.373"><vh>magic_rehashx</vh></v>
<v t="ekr.20050704165326.374"><vh>magic_pwd</vh></v>
<v t="ekr.20050704165326.375"><vh>magic_cd</vh></v>
<v t="ekr.20050704165326.376"><vh>magic_dhist</vh></v>
<v t="ekr.20050704165326.377"><vh>magic_env</vh></v>
<v t="ekr.20050704165326.378"><vh>magic_pushd</vh></v>
<v t="ekr.20050704165326.379"><vh>magic_popd</vh></v>
<v t="ekr.20050704165326.380"><vh>magic_dirs</vh></v>
<v t="ekr.20050704165326.381"><vh>magic_sc</vh></v>
<v t="ekr.20050704165326.382"><vh>magic_sx</vh></v>
<v t="ekr.20050704165326.383"><vh>magic_bg</vh></v>
<v t="ekr.20050704165326.384"><vh>magic_bookmark</vh></v>
</v>
</v>
<v t="ekr.20050704165326.385"><vh>numutils.py</vh>
<v t="ekr.20050704165326.386"><vh>&lt;&lt; numutils declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.387"><vh>exp_safe</vh></v>
<v t="ekr.20050704165326.388"><vh>amap</vh></v>
<v t="ekr.20050704165326.389"><vh>amin</vh></v>
<v t="ekr.20050704165326.390"><vh>amax</vh></v>
<v t="ekr.20050704165326.391"><vh>zeros_like</vh></v>
<v t="ekr.20050704165326.392"><vh>empty_like</vh></v>
<v t="ekr.20050704165326.393"><vh>sum_flat</vh></v>
<v t="ekr.20050704165326.394"><vh>mean_flat</vh></v>
<v t="ekr.20050704165326.395"><vh>rms_flat</vh></v>
<v t="ekr.20050704165326.396"><vh>l1norm</vh></v>
<v t="ekr.20050704165326.397"><vh>l2norm</vh></v>
<v t="ekr.20050704165326.398"><vh>norm</vh></v>
<v t="ekr.20050704165326.399"><vh>frange</vh></v>
<v t="ekr.20050704165326.400"><vh>diagonal_matrix</vh></v>
<v t="ekr.20050704165326.401"><vh>identity</vh></v>
<v t="ekr.20050704165326.402"><vh>base_repr</vh></v>
<v t="ekr.20050704165326.403"><vh>binary_repr</vh></v>
<v t="ekr.20050704165326.404"><vh>log2</vh></v>
<v t="ekr.20050704165326.405"><vh>ispower2</vh></v>
<v t="ekr.20050704165326.406"><vh>fromfunction_kw</vh></v>
</v>
<v t="ekr.20050704165326.407"><vh>OInspect.py</vh>
<v t="ekr.20050704165326.408"><vh>&lt;&lt; OInspect declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.409"><vh>getdoc</vh></v>
<v t="ekr.20050704165326.410"><vh>class myStringIO</vh>
<v t="ekr.20050704165326.411"><vh>writeln</vh></v>
</v>
<v t="ekr.20050704165326.412"><vh>class Inspector</vh>
<v t="ekr.20050704165326.413"><vh>__init__</vh></v>
<v t="ekr.20050704165326.414"><vh>__getargspec</vh></v>
<v t="ekr.20050704165326.415"><vh>__getdef</vh></v>
<v t="ekr.20050704165326.416"><vh>__head</vh></v>
<v t="ekr.20050704165326.417"><vh>set_active_scheme</vh></v>
<v t="ekr.20050704165326.418"><vh>noinfo</vh></v>
<v t="ekr.20050704165326.419"><vh>pdef</vh></v>
<v t="ekr.20050704165326.420"><vh>pdoc</vh></v>
<v t="ekr.20050704165326.421"><vh>psource</vh></v>
<v t="ekr.20050704165326.422"><vh>pfile</vh></v>
<v t="ekr.20050704165326.423"><vh>pinfo</vh></v>
</v>
</v>
<v t="ekr.20050704165326.424"><vh>OutputTrap.py</vh>
<v t="ekr.20050704165326.425"><vh>&lt;&lt; OutputTrap declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.426"><vh>class OutputTrapError</vh>
<v t="ekr.20050704165326.427"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.428"><vh>class OutputTrap</vh>
<v t="ekr.20050704165326.429"><vh>__init__</vh></v>
<v t="ekr.20050704165326.430"><vh>trap_out</vh></v>
<v t="ekr.20050704165326.431"><vh>release_out</vh></v>
<v t="ekr.20050704165326.432"><vh>summary_out</vh></v>
<v t="ekr.20050704165326.433"><vh>flush_out</vh></v>
<v t="ekr.20050704165326.434"><vh>trap_err</vh></v>
<v t="ekr.20050704165326.435"><vh>release_err</vh></v>
<v t="ekr.20050704165326.436"><vh>summary_err</vh></v>
<v t="ekr.20050704165326.437"><vh>flush_err</vh></v>
<v t="ekr.20050704165326.438"><vh>trap_all</vh></v>
<v t="ekr.20050704165326.439"><vh>release_all</vh></v>
<v t="ekr.20050704165326.440"><vh>summary_all</vh></v>
<v t="ekr.20050704165326.441"><vh>flush_all</vh></v>
</v>
<v t="ekr.20050704165326.442"><vh>_test_all</vh></v>
</v>
<v t="ekr.20050704165326.443"><vh>Prompts.py</vh>
<v t="ekr.20050704165326.444"><vh>&lt;&lt; Prompts declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.445"><vh>multiple_replace</vh></v>
<v t="ekr.20050704165326.446"><vh>str_safe</vh></v>
<v t="ekr.20050704165326.447"><vh>class BasePrompt</vh>
<v t="ekr.20050704165326.448"><vh>__init__</vh></v>
<v t="ekr.20050704165326.449"><vh>set_p_str</vh></v>
<v t="ekr.20050704165326.450"><vh>write</vh></v>
<v t="ekr.20050704165326.451"><vh>__str__</vh></v>
<v t="ekr.20050704165326.452"><vh>cwd_filt</vh></v>
<v t="ekr.20050704165326.453"><vh>cwd_filt2</vh></v>
</v>
<v t="ekr.20050704165326.454"><vh>class Prompt1</vh>
<v t="ekr.20050704165326.455"><vh>__init__</vh></v>
<v t="ekr.20050704165326.456"><vh>set_colors</vh></v>
<v t="ekr.20050704165326.457"><vh>__str__</vh></v>
<v t="ekr.20050704165326.458"><vh>auto_rewrite</vh></v>
</v>
<v t="ekr.20050704165326.459"><vh>class PromptOut</vh>
<v t="ekr.20050704165326.460"><vh>__init__</vh></v>
<v t="ekr.20050704165326.461"><vh>set_colors</vh></v>
</v>
<v t="ekr.20050704165326.462"><vh>class Prompt2</vh>
<v t="ekr.20050704165326.463"><vh>__init__</vh></v>
<v t="ekr.20050704165326.464"><vh>set_p_str</vh></v>
<v t="ekr.20050704165326.465"><vh>set_colors</vh></v>
</v>
<v t="ekr.20050704165326.466"><vh>class CachedOutput (in Prompts.py)</vh>
<v t="ekr.20050704165326.467"><vh>__init__</vh></v>
<v t="ekr.20050704165326.468"><vh>_set_prompt_str</vh></v>
<v t="ekr.20050704165326.469"><vh>set_colors</vh></v>
<v t="ekr.20050704165326.470"><vh>__call__</vh></v>
<v t="ekr.20050704165326.471"><vh>_display</vh></v>
<v t="ekr.20050704165326.472"><vh>update</vh></v>
<v t="ekr.20050704165326.473"><vh>flush</vh></v>
</v>
</v>
<v t="ekr.20050704165326.474"><vh>PyColorize.py</vh>
<v t="ekr.20050704165326.475"><vh>&lt;&lt; PyColorize declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.476"><vh>class Parser</vh>
<v t="ekr.20050704165326.477"><vh>__init__</vh></v>
<v t="ekr.20050704165326.478"><vh>format</vh></v>
<v t="ekr.20050704165326.479"><vh>__call__</vh></v>
</v>
<v t="ekr.20050704165326.480"><vh>main</vh></v>
</v>
<v t="ekr.20050704165326.481"><vh>Release.py</vh></v>
<v t="ekr.20050704165326.482"><vh>Shell.py</vh>
<v t="ekr.20050704165326.483"><vh>&lt;&lt; Shell declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.484"><vh>class IPShell</vh>
<v t="ekr.20050704165326.485"><vh>__init__</vh></v>
<v t="ekr.20050704165326.486"><vh>mainloop</vh></v>
</v>
<v t="ekr.20050704165326.487" a="M"><vh>class IPShellEmbed</vh>
<v t="ekr.20050704165326.488"><vh>__init__</vh></v>
<v t="ekr.20050704165326.489"><vh>restore_system_completer</vh></v>
<v t="ekr.20050704165326.490"><vh>__call__</vh></v>
<v t="ekr.20050704165326.491"><vh>set_dummy_mode</vh></v>
<v t="ekr.20050704165326.492"><vh>get_dummy_mode</vh></v>
<v t="ekr.20050704165326.493"><vh>set_banner</vh></v>
<v t="ekr.20050704165326.494"><vh>set_exit_msg</vh></v>
</v>
<v t="ekr.20050704165326.495"><vh>sigint_handler</vh></v>
<v t="ekr.20050704165326.496"><vh>class MTInteractiveShell</vh>
<v t="ekr.20050704165326.497"><vh>&lt;&lt; class MTInteractiveShell declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.498"><vh>__init__</vh></v>
<v t="ekr.20050704165326.499"><vh>runsource</vh></v>
<v t="ekr.20050704165326.500"><vh>runcode</vh></v>
<v t="ekr.20050704165326.501"><vh>kill</vh></v>
</v>
<v t="ekr.20050704165326.502"><vh>class MatplotlibShellBase</vh>
<v t="ekr.20050704165326.503"><vh>_matplotlib_config</vh></v>
<v t="ekr.20050704165326.504"><vh>mplot_exec</vh></v>
<v t="ekr.20050704165326.505"><vh>magic_run</vh></v>
</v>
<v t="ekr.20050704165326.506"><vh>class MatplotlibShell</vh>
<v t="ekr.20050704165326.507"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.508"><vh>class MatplotlibMTShell</vh>
<v t="ekr.20050704165326.509"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.510"><vh>get_tk</vh></v>
<v t="ekr.20050704165326.511"><vh>hijack_tk</vh></v>
<v t="ekr.20050704165326.512"><vh>update_tk</vh></v>
<v t="ekr.20050704165326.513"><vh>hijack_wx</vh></v>
<v t="ekr.20050704165326.514"><vh>hijack_gtk</vh></v>
<v t="ekr.20050704165326.515"><vh>class IPShellGTK</vh>
<v t="ekr.20050704165326.516"><vh>&lt;&lt; class IPShellGTK declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.517"><vh>__init__</vh></v>
<v t="ekr.20050704165326.518"><vh>run</vh></v>
<v t="ekr.20050704165326.519"><vh>mainloop</vh></v>
<v t="ekr.20050704165326.520"><vh>on_timer</vh></v>
</v>
<v t="ekr.20050704165326.521"><vh>class IPShellWX</vh>
<v t="ekr.20050704165326.522"><vh>&lt;&lt; class IPShellWX declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.523"><vh>__init__</vh></v>
<v t="ekr.20050704165326.524"><vh>wxexit</vh></v>
<v t="ekr.20050704165326.525"><vh>run</vh></v>
<v t="ekr.20050704165326.526"><vh>mainloop</vh></v>
</v>
<v t="ekr.20050704165326.527"><vh>class IPShellQt</vh>
<v t="ekr.20050704165326.528"><vh>&lt;&lt; class IPShellQt declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.529"><vh>__init__</vh></v>
<v t="ekr.20050704165326.530"><vh>run</vh></v>
<v t="ekr.20050704165326.531"><vh>mainloop</vh></v>
<v t="ekr.20050704165326.532"><vh>on_timer</vh></v>
</v>
<v t="ekr.20050704165326.533"><vh>class IPShellMatplotlib</vh>
<v t="ekr.20050704165326.534"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.535"><vh>class IPShellMatplotlibGTK</vh>
<v t="ekr.20050704165326.536"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.537"><vh>class IPShellMatplotlibWX</vh>
<v t="ekr.20050704165326.538"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.539"><vh>class IPShellMatplotlibQt</vh>
<v t="ekr.20050704165326.540"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.541"><vh>_matplotlib_shell_class</vh></v>
<v t="ekr.20050704165326.542"><vh>start</vh></v>
</v>
<v t="ekr.20050704165326.543"><vh>Struct.py</vh>
<v t="ekr.20050704165326.544"><vh>&lt;&lt; Struct declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.545"><vh>class Struct</vh>
<v t="ekr.20050704165326.546"><vh>&lt;&lt; class Struct declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.547"><vh>__init__</vh></v>
<v t="ekr.20050704165326.548"><vh>__setitem__</vh></v>
<v t="ekr.20050704165326.549"><vh>__setattr__</vh></v>
<v t="ekr.20050704165326.550"><vh>__str__</vh></v>
<v t="ekr.20050704165326.551"><vh>__repr__</vh></v>
<v t="ekr.20050704165326.552"><vh>__getitem__</vh></v>
<v t="ekr.20050704165326.553"><vh>__contains__</vh></v>
<v t="ekr.20050704165326.554"><vh>__iadd__</vh></v>
<v t="ekr.20050704165326.555"><vh>__add__</vh></v>
<v t="ekr.20050704165326.556"><vh>__sub__</vh></v>
<v t="ekr.20050704165326.557"><vh>__isub__</vh></v>
<v t="ekr.20050704165326.558"><vh>__make_dict</vh></v>
<v t="ekr.20050704165326.559"><vh>__dict_invert</vh></v>
<v t="ekr.20050704165326.560"><vh>clear</vh></v>
<v t="ekr.20050704165326.561"><vh>copy</vh></v>
<v t="ekr.20050704165326.562"><vh>dict</vh></v>
<v t="ekr.20050704165326.563"><vh>dictcopy</vh></v>
<v t="ekr.20050704165326.564"><vh>popitem</vh></v>
<v t="ekr.20050704165326.565"><vh>update</vh></v>
<v t="ekr.20050704165326.566"><vh>merge</vh></v>
<v t="ekr.20050704165326.567"><vh>has_key</vh></v>
<v t="ekr.20050704165326.568"><vh>hasattr</vh></v>
<v t="ekr.20050704165326.569"><vh>items</vh></v>
<v t="ekr.20050704165326.570"><vh>keys</vh></v>
<v t="ekr.20050704165326.571"><vh>values</vh></v>
<v t="ekr.20050704165326.572"><vh>get</vh></v>
<v t="ekr.20050704165326.573"><vh>setdefault</vh></v>
</v>
</v>
<v t="ekr.20050704165326.574"><vh>ultraTB.py</vh>
<v t="ekr.20050704165326.575"><vh>&lt;&lt; ultraTB declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.576"><vh>inspect_error</vh></v>
<v t="ekr.20050704165326.577"><vh>class TBTools</vh>
<v t="ekr.20050704165326.578"><vh>__init__</vh></v>
<v t="ekr.20050704165326.579"><vh>set_colors</vh></v>
<v t="ekr.20050704165326.580"><vh>color_toggle</vh></v>
</v>
<v t="ekr.20050704165326.581"><vh>class ListTB</vh>
<v t="ekr.20050704165326.582"><vh>__init__</vh></v>
<v t="ekr.20050704165326.583"><vh>__call__</vh></v>
<v t="ekr.20050704165326.584"><vh>text</vh></v>
<v t="ekr.20050704165326.585"><vh>_format_list</vh></v>
<v t="ekr.20050704165326.586"><vh>_format_exception_only</vh></v>
<v t="ekr.20050704165326.587"><vh>_some_str</vh></v>
</v>
<v t="ekr.20050704165326.588"><vh>class VerboseTB</vh>
<v t="ekr.20050704165326.589"><vh>__init__</vh></v>
<v t="ekr.20050704165326.590"><vh>text</vh></v>
<v t="ekr.20050704165326.591"><vh>debugger</vh></v>
<v t="ekr.20050704165326.592"><vh>handler</vh></v>
<v t="ekr.20050704165326.593"><vh>__call__</vh></v>
</v>
<v t="ekr.20050704165326.594"><vh>class FormattedTB</vh>
<v t="ekr.20050704165326.595"><vh>__init__</vh></v>
<v t="ekr.20050704165326.596"><vh>_extract_tb</vh></v>
<v t="ekr.20050704165326.597"><vh>text</vh></v>
<v t="ekr.20050704165326.598"><vh>set_mode</vh></v>
<v t="ekr.20050704165326.599"><vh>plain</vh></v>
<v t="ekr.20050704165326.600"><vh>context</vh></v>
<v t="ekr.20050704165326.601"><vh>verbose</vh></v>
</v>
<v t="ekr.20050704165326.602"><vh>class AutoFormattedTB</vh>
<v t="ekr.20050704165326.603"><vh>__call__</vh></v>
<v t="ekr.20050704165326.604"><vh>text</vh></v>
</v>
<v t="ekr.20050704165326.605"><vh>class ColorTB</vh>
<v t="ekr.20050704165326.606"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.607"><vh>spam</vh></v>
</v>
</v>
</v>
<v t="ekr.20050708082932.3" a="E"><vh>Files</vh>
<v t="ekr.20050704165326.2"><vh>background_jobs.py</vh>
<v t="ekr.20050704170205.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050704165326.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050704165326.4"><vh>class BackgroundJobManager</vh>
<v t="ekr.20050704165326.5"><vh>__init__</vh></v>
<v t="ekr.20050704165326.6"><vh>new</vh></v>
<v t="ekr.20050704165326.7"><vh>__getitem__</vh></v>
<v t="ekr.20050704165326.8"><vh>__call__</vh></v>
<v t="ekr.20050704165326.9"><vh>_update_status</vh></v>
<v t="ekr.20050704165326.10"><vh>_group_report</vh></v>
<v t="ekr.20050704165326.11"><vh>_group_flush</vh></v>
<v t="ekr.20050704165326.12"><vh>_status_new</vh></v>
<v t="ekr.20050704165326.13"><vh>status</vh></v>
<v t="ekr.20050704165326.14"><vh>remove</vh></v>
<v t="ekr.20050704165326.15"><vh>flush_finished</vh></v>
<v t="ekr.20050704165326.16"><vh>result</vh></v>
<v t="ekr.20050704165326.17"><vh>traceback</vh></v>
</v>
<v t="ekr.20050704165326.18"><vh>class BackgroundJobBase</vh>
<v t="ekr.20050704165326.19"><vh>&lt;&lt; class BackgroundJobBase declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.20"><vh>__init__</vh></v>
<v t="ekr.20050704165326.21"><vh>_init</vh></v>
<v t="ekr.20050704165326.22"><vh>__str__</vh></v>
<v t="ekr.20050704165326.23"><vh>__repr__</vh></v>
<v t="ekr.20050704165326.24"><vh>traceback</vh></v>
<v t="ekr.20050704165326.25"><vh>run</vh></v>
</v>
<v t="ekr.20050704165326.26"><vh>class BackgroundJobExpr</vh>
<v t="ekr.20050704165326.27"><vh>__init__</vh></v>
<v t="ekr.20050704165326.28"><vh>call</vh></v>
</v>
<v t="ekr.20050704165326.29"><vh>class BackgroundJobFunc</vh>
<v t="ekr.20050704165326.30"><vh>__init__</vh></v>
<v t="ekr.20050704165326.31"><vh>call</vh></v>
</v>
<v t="ekr.20050704165326.32"><vh>sleepfunc</vh></v>
</v>
<v t="ekr.20050704165326.241" a="M"><vh>iplib.py (contains InteractiveShell) CONTAINS ALL IPYTHON SPECIFIC STUFF</vh>
<v t="ekr.20050704165326.242"><vh>&lt;&lt; iplib declarations &gt;&gt;</vh></v>
<v t="ekr.20050708081540"><vh>Utilities</vh>
<v t="ekr.20050704165326.243"><vh>enumerate</vh></v>
<v t="ekr.20050704165326.244"><vh>class Bunch</vh></v>
<v t="ekr.20050704165326.245"><vh>esc_quotes</vh></v>
<v t="ekr.20050704165326.246"><vh>import_fail_info</vh></v>
<v t="ekr.20050704165326.247"><vh>qw_lol</vh></v>
</v>
<v t="ekr.20050704165326.248"><vh>ipmagic (in iplib.py)</vh></v>
<v t="ekr.20050704165326.249"><vh>ipalias</vh></v>
<v t="ekr.20050704165326.250"><vh>class MagicCompleter</vh>
<v t="ekr.20050704165326.251"><vh>__init__</vh></v>
<v t="ekr.20050704165326.252"><vh>all_completions</vh></v>
<v t="ekr.20050704165326.253"><vh>_clean_glob</vh></v>
<v t="ekr.20050704165326.254"><vh>_clean_glob_win32</vh></v>
<v t="ekr.20050704165326.255"><vh>file_matches</vh></v>
<v t="ekr.20050704165326.256"><vh>alias_matches</vh></v>
<v t="ekr.20050704165326.257"><vh>python_matches</vh></v>
<v t="ekr.20050704165326.258"><vh>_default_arguments</vh></v>
<v t="ekr.20050704165326.259"><vh>python_func_kw_matches</vh></v>
<v t="ekr.20050704165326.260"><vh>complete</vh></v>
</v>
<v t="ekr.20050704165326.261"><vh>class InputList</vh>
<v t="ekr.20050704165326.262"><vh>__getslice__</vh></v>
</v>
<v t="ekr.20050704165326.263"><vh>class SpaceInInput</vh>
<v t="ekr.20050704165326.264"><vh>&lt;&lt; class SpaceInInput declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.265" a="EM"><vh>class InteractiveShell (code.InteractiveConsole,Logger,Magic) (in iplib.py)</vh>
<v t="ekr.20050704165326.266"><vh>__init__</vh>
<v t="ekr.20050707212426"><vh>&lt;&lt; add stuff to builtins &gt;&gt;</vh></v>
<v t="ekr.20050707212426.1"><vh>&lt;&lt; Create the namespace where the user will operate &gt;&gt;</vh></v>
<v t="ekr.20050707212426.2"><vh>&lt;&lt; create ivars &gt;&gt;</vh></v>
<v t="ekr.20050707212426.3"><vh>&lt;&lt; handle escapes &gt;&gt;</vh></v>
<v t="ekr.20050708080420"><vh>&lt;&lt; create a job manager &gt;&gt;</vh></v>
<v t="ekr.20050708080420.1"><vh>&lt;&lt; init classes &gt;&gt;</vh></v>
<v t="ekr.20050708080420.2"><vh>&lt;&lt; set all default hooks, defined in the IPython.hooks module &gt;&gt;</vh></v>
<v t="ekr.20050708080420.3"><vh>&lt;&lt; define usage messages &gt;&gt;</vh></v>
<v t="ekr.20050708080420.4"><vh>&lt;&lt; define functions to call the underlying shell &gt;&gt;</vh></v>
<v t="ekr.20050708080420.5"><vh>&lt;&lt; define regular expressions &gt;&gt;</vh></v>
<v t="ekr.20050708080420.6"><vh>&lt;&lt; Attributes for Logger mixin class, make defaults here &gt;&gt;</vh></v>
<v t="ekr.20050708080420.7"><vh>&lt;&lt; various switches which can be set &gt;&gt;</vh></v>
<v t="ekr.20050708080420.8"><vh>&lt;&lt; traceBack handlers &gt;&gt;</vh></v>
<v t="ekr.20050708080420.9"><vh>&lt;&lt; object inspector &gt;&gt;</vh></v>
<v t="ekr.20050708080420.10"><vh>&lt;&lt; Make some aliases automatically &gt;&gt;</vh></v>
<v t="ekr.20050708080420.11"><vh>&lt;&lt; storage &gt;&gt;</vh></v>
<v t="ekr.20050708080420.12"><vh>&lt;&lt; for pushd/popd management &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708082932"><vh>Customization...</vh>
<v t="ekr.20050704165326.267"><vh>set_hook</vh></v>
<v t="ekr.20050707224615"><vh>set_custom_exc</vh></v>
<v t="ekr.20050707224710"><vh>set_custom_completer</vh></v>
</v>
<v t="ekr.20050708082932.1"><vh>Init...</vh>
<v t="ekr.20050707224710.1"><vh>post_config_initialization</vh></v>
<v t="ekr.20050707224710.2"><vh>init_auto_alias</vh></v>
<v t="ekr.20050707224710.3"><vh>alias_table_validate</vh></v>
<v t="ekr.20050707224710.6"><vh>user_setup</vh></v>
<v t="ekr.20050707224710.5"><vh>rc_set_toggle (not called from InteractiveShell)</vh></v>
</v>
<v t="ekr.20050708084235"><vh>Death...</vh>
<v t="ekr.20050707224710.7"><vh>atexit_operations</vh></v>
<v t="ekr.20050707230243.1"><vh>savehist</vh></v>
</v>
<v t="ekr.20050708084235.1"><vh>Interactives stuff (will not be used in Leo)</vh>
<v t="ekr.20050708082932.2"><vh>Readline...</vh>
<v t="ekr.20050707230243.2"><vh>pre_readline</vh></v>
<v t="ekr.20050707230243.3"><vh>init_readline</vh></v>
<v t="ekr.20050707224710.4"><vh>set_autoindent (called only from init_readline)</vh></v>
</v>
<v t="ekr.20050707230243.5"><vh>debugger</vh></v>
<v t="ekr.20050707230243.9"><vh>mainloop &amp; name_space_init</vh>
<v t="ekr.20050707230243.8"><vh>name_space_init</vh></v>
</v>
<v t="ekr.20050707230243.11"><vh>embed_mainloop</vh></v>
<v t="ekr.20050707230243.15"><vh>runlines</vh></v>
</v>
<v t="ekr.20050708084235.2"><vh>Calling system stuff</vh>
<v t="ekr.20050707230243.10"><vh>exec_init_cmd</vh></v>
<v t="ekr.20050707230243.14"><vh>call_alias</vh></v>
</v>
<v t="ekr.20050708072233.1"><vh>Overrides of code.InteractiveInterpreter</vh>
<v t="ekr.20050707230243.17"><vh>runcode</vh></v>
<v t="ekr.20050707230243.16"><vh>runsource</vh></v>
<v t="ekr.20050707230243.4"><vh>showsyntaxerror</vh></v>
<v t="ekr.20050707230243.6"><vh>showtraceback</vh></v>
<v t="ekr.20050708072233.2"><vh>write (use base class)  COULD OVERRIDE THIS</vh></v>
<v t="ekr.20050707230243.13"><vh>excepthook (helper)</vh></v>
</v>
<v t="ekr.20050708071222"><vh>Overrides of code.InteractiveConsole</vh>
<v t="ekr.20050707230243.12" a="M"><vh>interact</vh></v>
<v t="ekr.20050708072233.3"><vh>push (use base class)</vh></v>
<v t="ekr.20050707230243.18"><vh>raw_input</vh></v>
<v t="ekr.20050708072233.4"><vh>resetbuffer (use base class)</vh></v>
</v>
<v t="ekr.20050708074118.6" a="E"><vh>prefilter &amp; helpers</vh>
<v t="ekr.20050707230243.21"><vh>_prefilter_dumb</vh></v>
<v t="ekr.20050707230243.20" a="EM"><vh>_prefilter (Rewrite?)</vh>
<v t="ekr.20050708074118"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708074118.1"><vh>&lt;&lt; handle empty line &gt;&gt;</vh></v>
<v t="ekr.20050708074118.2"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708074118.3"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708074118.4"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708074118.5"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050707230243.22"><vh>handle_normal</vh></v>
<v t="ekr.20050707230243.23"><vh>handle_alias</vh></v>
<v t="ekr.20050707230243.24"><vh>handle_shell_escape</vh></v>
<v t="ekr.20050707230243.25"><vh>handle_magic</vh></v>
<v t="ekr.20050707230243.26"><vh>handle_auto</vh></v>
<v t="ekr.20050707230243.27"><vh>handle_help</vh></v>
<v t="ekr.20050707230243.28"><vh>handle_emacs</vh></v>
<v t="ekr.20050707230243.29"><vh>safe_execfile</vh></v>
<v t="ekr.20050707230243.19"><vh>split_user_input</vh></v>
<v t="ekr.20050707230243.7"><vh>update_cache</vh></v>
</v>
</v>
</v>
<v t="ekr.20050704165326.108"><vh>genutils.py</vh>
<v t="ekr.20050704165326.109"><vh>&lt;&lt; genutils declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.110"><vh>class Error</vh>
<v t="ekr.20050704165326.111"><vh>&lt;&lt; class Error declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.112"><vh>class Stream</vh>
<v t="ekr.20050704165326.113"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.114"><vh>class Term</vh>
<v t="ekr.20050704165326.115"><vh>&lt;&lt; class Term declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.116"><vh>reopen_all</vh></v>
<v t="ekr.20050704165326.117"><vh>set_stdout</vh></v>
<v t="ekr.20050704165326.118"><vh>set_stderr</vh></v>
</v>
<v t="ekr.20050704165326.119"><vh>warn</vh></v>
<v t="ekr.20050704165326.120"><vh>info</vh></v>
<v t="ekr.20050704165326.121"><vh>error</vh></v>
<v t="ekr.20050704165326.122"><vh>fatal</vh></v>
<v t="ekr.20050704165326.123"><vh>clock</vh></v>
<v t="ekr.20050704165326.124"><vh>clock2</vh></v>
<v t="ekr.20050704165326.125"><vh>timings_out</vh></v>
<v t="ekr.20050704165326.126"><vh>timings</vh></v>
<v t="ekr.20050704165326.127"><vh>timing</vh></v>
<v t="ekr.20050704165326.128"><vh>system</vh></v>
<v t="ekr.20050704165326.129"><vh>shell</vh></v>
<v t="ekr.20050704165326.130"><vh>getoutput</vh></v>
<v t="ekr.20050704165326.131"><vh>getoutputerror</vh></v>
<v t="ekr.20050704165326.132"><vh>class SystemExec</vh>
<v t="ekr.20050704165326.133"><vh>__init__</vh></v>
<v t="ekr.20050704165326.134"><vh>system</vh></v>
<v t="ekr.20050704165326.135"><vh>shell</vh></v>
<v t="ekr.20050704165326.136"><vh>getoutput</vh></v>
<v t="ekr.20050704165326.137"><vh>getoutputerror</vh></v>
</v>
<v t="ekr.20050704165326.138"><vh>mutex_opts</vh></v>
<v t="ekr.20050704165326.139"><vh>filefind</vh></v>
<v t="ekr.20050704165326.140"><vh>target_outdated</vh></v>
<v t="ekr.20050704165326.141"><vh>target_update</vh></v>
<v t="ekr.20050704165326.142"><vh>unquote_ends</vh></v>
<v t="ekr.20050704165326.143"><vh>process_cmdline</vh></v>
<v t="ekr.20050704165326.144"><vh>optstr2types</vh></v>
<v t="ekr.20050704165326.145"><vh>read_dict</vh></v>
<v t="ekr.20050704165326.146"><vh>flag_calls</vh></v>
<v t="ekr.20050704165326.147"><vh>class HomeDirError</vh>
<v t="ekr.20050704165326.148"><vh>&lt;&lt; class HomeDirError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.149"><vh>get_home_dir</vh></v>
<v t="ekr.20050704165326.150"><vh>class LSString</vh>
<v t="ekr.20050704165326.151"><vh>get_list</vh></v>
<v t="ekr.20050704165326.152"><vh>get_spstr</vh></v>
<v t="ekr.20050704165326.153"><vh>get_nlstr</vh></v>
</v>
<v t="ekr.20050704165326.154"><vh>class SList</vh>
<v t="ekr.20050704165326.155"><vh>get_list</vh></v>
<v t="ekr.20050704165326.156"><vh>get_spstr</vh></v>
<v t="ekr.20050704165326.157"><vh>get_nlstr</vh></v>
</v>
<v t="ekr.20050704165326.158"><vh>raw_input_multi</vh></v>
<v t="ekr.20050704165326.159"><vh>raw_input_ext</vh></v>
<v t="ekr.20050704165326.160"><vh>ask_yes_no</vh></v>
<v t="ekr.20050704165326.161"><vh>class EvalDict</vh>
<v t="ekr.20050704165326.162"><vh>&lt;&lt; class EvalDict declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.163"><vh>__getitem__</vh></v>
</v>
<v t="ekr.20050704165326.164"><vh>qw</vh></v>
<v t="ekr.20050704165326.165"><vh>qwflat</vh></v>
<v t="ekr.20050704165326.166"><vh>list_strings</vh></v>
<v t="ekr.20050704165326.167"><vh>grep</vh></v>
<v t="ekr.20050704165326.168"><vh>dgrep</vh></v>
<v t="ekr.20050704165326.169"><vh>idgrep</vh></v>
<v t="ekr.20050704165326.170"><vh>igrep</vh></v>
<v t="ekr.20050704165326.171"><vh>indent</vh></v>
<v t="ekr.20050704165326.172"><vh>native_line_ends</vh></v>
<v t="ekr.20050704165326.173"><vh>get_pager_cmd</vh></v>
<v t="ekr.20050704165326.174"><vh>get_pager_start</vh></v>
<v t="ekr.20050704165326.175"><vh>page_dumb</vh></v>
<v t="ekr.20050704165326.176"><vh>page (genutils)</vh></v>
<v t="ekr.20050704165326.177"><vh>page_file</vh></v>
<v t="ekr.20050704165326.178"><vh>snip_print</vh></v>
<v t="ekr.20050704165326.179"><vh>belong</vh></v>
<v t="ekr.20050704165326.180"><vh>uniq_stable</vh></v>
<v t="ekr.20050704165326.181"><vh>class NLprinter</vh>
<v t="ekr.20050704165326.182"><vh>__init__</vh></v>
<v t="ekr.20050704165326.183"><vh>__call__</vh></v>
</v>
<v t="ekr.20050704165326.184"><vh>all_belong</vh></v>
<v t="ekr.20050704165326.185"><vh>sort_compare</vh></v>
<v t="ekr.20050704165326.186"><vh>mkdict</vh></v>
<v t="ekr.20050704165326.187"><vh>list2dict</vh></v>
<v t="ekr.20050704165326.188"><vh>list2dict2</vh></v>
<v t="ekr.20050704165326.189"><vh>flatten</vh></v>
<v t="ekr.20050704165326.190"><vh>get_slice</vh></v>
<v t="ekr.20050704165326.191"><vh>chop</vh></v>
<v t="ekr.20050704165326.192"><vh>with</vh></v>
<v t="ekr.20050704165326.193"><vh>setattr_list</vh></v>
<v t="ekr.20050704165326.194"><vh>getattr_list</vh></v>
<v t="ekr.20050704165326.195"><vh>map_method</vh></v>
<v t="ekr.20050704165326.196"><vh>class NotGiven</vh></v>
<v t="ekr.20050704165326.197"><vh>popkey</vh></v>
</v>
<v t="ekr.20050704165326.268"><vh>ipmaker.py</vh>
<v t="ekr.20050704165326.269"><vh>&lt;&lt; ipmaker declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.270"><vh>make_IPython</vh></v>
<v t="ekr.20050707185729.1"><vh>&lt;&lt; directory stuff &gt;&gt;</vh></v>
<v t="ekr.20050707185105"><vh>&lt;&lt; handle log replay &gt;&gt;</vh></v>
<v t="ekr.20050707185105.1"><vh>&lt;&lt; set output traps &gt;&gt;</vh></v>
<v t="ekr.20050707185105.2"><vh>&lt;&lt; process ipythonrc config files &gt;&gt;</vh></v>
<v t="ekr.20050707185105.3"><vh>&lt;&lt; execute user config &gt;&gt;</vh></v>
<v t="ekr.20050707185105.4" a="M"><vh>&lt;&lt; setup interactive session &gt;&gt;</vh></v>
<v t="ekr.20050707185105.5"><vh>&lt;&lt; command line handling &gt;&gt;</vh>
<v t="ekr.20050707185105.6"><vh>&lt;&lt; Set sensible command line defaults &gt;&gt;</vh></v>
</v>
<v t="ekr.20050707185729"><vh>&lt;&lt; set exception handlers in mode requested by user &gt;&gt;</vh></v>
</v>
<v t="ekr.20050704165326.295"><vh>Logger.py</vh>
<v t="ekr.20050704165326.296"><vh>&lt;&lt; Logger declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.297"><vh>class Logger</vh>
<v t="ekr.20050704165326.299"><vh>__init__</vh></v>
<v t="ekr.20050704165326.300"><vh>create_log</vh></v>
<v t="ekr.20050704165326.301"><vh>logstart</vh></v>
<v t="ekr.20050704165326.302"><vh>switch_log</vh></v>
<v t="ekr.20050704165326.303"><vh>logstate</vh></v>
<v t="ekr.20050704165326.304"><vh>log</vh></v>
<v t="ekr.20050704165326.305"><vh>close_log</vh></v>
</v>
</v>
<v t="ekr.20050704165326.306"><vh>Magic.py</vh>
<v t="ekr.20050704165326.307"><vh>&lt;&lt; Magic declarations &gt;&gt;</vh></v>
<v t="ekr.20050708080420.13"><vh>Utility functions</vh>
<v t="ekr.20050704165326.308"><vh>magic2python</vh></v>
<v t="ekr.20050704165326.309"><vh>on_off</vh></v>
<v t="ekr.20050704165326.310"><vh>get_py_filename</vh></v>
<v t="ekr.20050704165326.311"><vh>shlex_split</vh></v>
</v>
<v t="ekr.20050704165326.312"><vh>class Macro</vh>
<v t="ekr.20050704165326.313"><vh>__init__</vh></v>
<v t="ekr.20050704165326.314"><vh>__str__</vh></v>
</v>
<v t="ekr.20050704165326.315"><vh>class Magic</vh>
<v t="ekr.20050704165326.317"><vh>__init__</vh></v>
<v t="ekr.20050704165326.318"><vh>profile_missing_notice</vh></v>
<v t="ekr.20050704165326.319"><vh>default_option</vh></v>
<v t="ekr.20050704165326.320"><vh>lsmagic</vh></v>
<v t="ekr.20050704165326.321"><vh>set_shell</vh></v>
<v t="ekr.20050704165326.322"><vh>extract_input_slices</vh></v>
<v t="ekr.20050704165326.323"><vh>_ofind</vh></v>
<v t="ekr.20050704165326.324"><vh>arg_err</vh></v>
<v t="ekr.20050704165326.325"><vh>format_latex</vh></v>
<v t="ekr.20050704165326.326"><vh>format_screen</vh></v>
<v t="ekr.20050704165326.327"><vh>parse_options</vh></v>
<v t="ekr.20050704165326.328"><vh>magic_lsmagic</vh></v>
<v t="ekr.20050704165326.329"><vh>magic_magic</vh></v>
<v t="ekr.20050704165326.330"><vh>magic_automagic</vh></v>
<v t="ekr.20050704165326.331"><vh>magic_autocall</vh></v>
<v t="ekr.20050704165326.332"><vh>magic_autoindent</vh></v>
<v t="ekr.20050704165326.333"><vh>magic_system_verbose</vh></v>
<v t="ekr.20050704165326.334"><vh>magic_history</vh></v>
<v t="ekr.20050704165326.335"><vh>magic_hist</vh></v>
<v t="ekr.20050704165326.336"><vh>magic_p</vh></v>
<v t="ekr.20050704165326.337"><vh>magic_r</vh></v>
<v t="ekr.20050704165326.338"><vh>magic_page</vh></v>
<v t="ekr.20050704165326.339"><vh>magic_profile</vh></v>
<v t="ekr.20050704165326.340"><vh>_inspect</vh></v>
<v t="ekr.20050704165326.341"><vh>magic_pdef</vh></v>
<v t="ekr.20050704165326.342"><vh>magic_pdoc</vh></v>
<v t="ekr.20050704165326.343"><vh>magic_psource</vh></v>
<v t="ekr.20050704165326.344"><vh>magic_pfile</vh></v>
<v t="ekr.20050704165326.345"><vh>magic_pinfo</vh></v>
<v t="ekr.20050704165326.346"><vh>magic_who_ls</vh></v>
<v t="ekr.20050704165326.347"><vh>magic_who</vh></v>
<v t="ekr.20050704165326.348"><vh>magic_whos</vh></v>
<v t="ekr.20050704165326.349"><vh>magic_reset</vh></v>
<v t="ekr.20050704165326.350"><vh>magic_config</vh></v>
<v t="ekr.20050704165326.351"><vh>magic_logstart</vh></v>
<v t="ekr.20050704165326.352"><vh>magic_logoff</vh></v>
<v t="ekr.20050704165326.353"><vh>magic_logon</vh></v>
<v t="ekr.20050704165326.354"><vh>magic_logstate</vh></v>
<v t="ekr.20050704165326.355"><vh>magic_pdb</vh></v>
<v t="ekr.20050704165326.356"><vh>magic_prun</vh></v>
<v t="ekr.20050704165326.357"><vh>magic_run</vh></v>
<v t="ekr.20050704165326.358"><vh>magic_runlog</vh></v>
<v t="ekr.20050704165326.359"><vh>magic_time</vh></v>
<v t="ekr.20050704165326.360"><vh>magic_macro</vh></v>
<v t="ekr.20050704165326.361"><vh>magic_save</vh></v>
<v t="ekr.20050704165326.362"><vh>magic_ed</vh></v>
<v t="ekr.20050704165326.363"><vh>magic_edit</vh></v>
<v t="ekr.20050704165326.364"><vh>magic_xmode</vh></v>
<v t="ekr.20050704165326.365"><vh>magic_colors</vh></v>
<v t="ekr.20050704165326.366"><vh>magic_color_info</vh></v>
<v t="ekr.20050704165326.367"><vh>magic_Pprint</vh></v>
<v t="ekr.20050704165326.368"><vh>magic_Exit</vh></v>
<v t="ekr.20050704165326.369"><vh>magic_Quit</vh></v>
<v t="ekr.20050704165326.370"><vh>magic_alias</vh></v>
<v t="ekr.20050704165326.371"><vh>magic_unalias</vh></v>
<v t="ekr.20050704165326.372"><vh>magic_rehash</vh></v>
<v t="ekr.20050704165326.373"><vh>magic_rehashx</vh></v>
<v t="ekr.20050704165326.374"><vh>magic_pwd</vh></v>
<v t="ekr.20050704165326.375"><vh>magic_cd</vh></v>
<v t="ekr.20050704165326.376"><vh>magic_dhist</vh></v>
<v t="ekr.20050704165326.377"><vh>magic_env</vh></v>
<v t="ekr.20050704165326.378"><vh>magic_pushd</vh></v>
<v t="ekr.20050704165326.379"><vh>magic_popd</vh></v>
<v t="ekr.20050704165326.380"><vh>magic_dirs</vh></v>
<v t="ekr.20050704165326.381"><vh>magic_sc</vh></v>
<v t="ekr.20050704165326.382"><vh>magic_sx</vh></v>
<v t="ekr.20050704165326.383"><vh>magic_bg</vh></v>
<v t="ekr.20050704165326.384"><vh>magic_bookmark</vh></v>
</v>
</v>
<v t="ekr.20050704165326.482"><vh>Shell.py</vh>
<v t="ekr.20050704165326.483"><vh>&lt;&lt; Shell declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.484"><vh>class IPShell</vh>
<v t="ekr.20050704165326.485"><vh>__init__</vh></v>
<v t="ekr.20050704165326.486"><vh>mainloop</vh></v>
</v>
<v t="ekr.20050704165326.487" a="M"><vh>class IPShellEmbed</vh>
<v t="ekr.20050704165326.488"><vh>__init__</vh></v>
<v t="ekr.20050704165326.489"><vh>restore_system_completer</vh></v>
<v t="ekr.20050704165326.490"><vh>__call__</vh></v>
<v t="ekr.20050704165326.491"><vh>set_dummy_mode</vh></v>
<v t="ekr.20050704165326.492"><vh>get_dummy_mode</vh></v>
<v t="ekr.20050704165326.493"><vh>set_banner</vh></v>
<v t="ekr.20050704165326.494"><vh>set_exit_msg</vh></v>
</v>
<v t="ekr.20050704165326.495"><vh>sigint_handler</vh></v>
<v t="ekr.20050704165326.496"><vh>class MTInteractiveShell</vh>
<v t="ekr.20050704165326.497"><vh>&lt;&lt; class MTInteractiveShell declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.498"><vh>__init__</vh></v>
<v t="ekr.20050704165326.499"><vh>runsource</vh></v>
<v t="ekr.20050704165326.500"><vh>runcode</vh></v>
<v t="ekr.20050704165326.501"><vh>kill</vh></v>
</v>
<v t="ekr.20050704165326.502"><vh>class MatplotlibShellBase</vh>
<v t="ekr.20050704165326.503"><vh>_matplotlib_config</vh></v>
<v t="ekr.20050704165326.504"><vh>mplot_exec</vh></v>
<v t="ekr.20050704165326.505"><vh>magic_run</vh></v>
</v>
<v t="ekr.20050704165326.506"><vh>class MatplotlibShell</vh>
<v t="ekr.20050704165326.507"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.508"><vh>class MatplotlibMTShell</vh>
<v t="ekr.20050704165326.509"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.510"><vh>get_tk</vh></v>
<v t="ekr.20050704165326.511"><vh>hijack_tk</vh></v>
<v t="ekr.20050704165326.512"><vh>update_tk</vh></v>
<v t="ekr.20050704165326.513"><vh>hijack_wx</vh></v>
<v t="ekr.20050704165326.514"><vh>hijack_gtk</vh></v>
<v t="ekr.20050704165326.515"><vh>class IPShellGTK</vh>
<v t="ekr.20050704165326.516"><vh>&lt;&lt; class IPShellGTK declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.517"><vh>__init__</vh></v>
<v t="ekr.20050704165326.518"><vh>run</vh></v>
<v t="ekr.20050704165326.519"><vh>mainloop</vh></v>
<v t="ekr.20050704165326.520"><vh>on_timer</vh></v>
</v>
<v t="ekr.20050704165326.521"><vh>class IPShellWX</vh>
<v t="ekr.20050704165326.522"><vh>&lt;&lt; class IPShellWX declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.523"><vh>__init__</vh></v>
<v t="ekr.20050704165326.524"><vh>wxexit</vh></v>
<v t="ekr.20050704165326.525"><vh>run</vh></v>
<v t="ekr.20050704165326.526"><vh>mainloop</vh></v>
</v>
<v t="ekr.20050704165326.527"><vh>class IPShellQt</vh>
<v t="ekr.20050704165326.528"><vh>&lt;&lt; class IPShellQt declarations &gt;&gt;</vh></v>
<v t="ekr.20050704165326.529"><vh>__init__</vh></v>
<v t="ekr.20050704165326.530"><vh>run</vh></v>
<v t="ekr.20050704165326.531"><vh>mainloop</vh></v>
<v t="ekr.20050704165326.532"><vh>on_timer</vh></v>
</v>
<v t="ekr.20050704165326.533"><vh>class IPShellMatplotlib</vh>
<v t="ekr.20050704165326.534"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.535"><vh>class IPShellMatplotlibGTK</vh>
<v t="ekr.20050704165326.536"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.537"><vh>class IPShellMatplotlibWX</vh>
<v t="ekr.20050704165326.538"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.539"><vh>class IPShellMatplotlibQt</vh>
<v t="ekr.20050704165326.540"><vh>__init__</vh></v>
</v>
<v t="ekr.20050704165326.541"><vh>_matplotlib_shell_class</vh></v>
<v t="ekr.20050704165326.542"><vh>start</vh></v>
</v>
</v>
<v t="ekr.20050708084235.3" a="E"><vh>Classes</vh>
<v t="ekr.20050704165326.466"><vh>class CachedOutput (in Prompts.py)</vh>
<v t="ekr.20050704165326.467"><vh>__init__</vh></v>
<v t="ekr.20050704165326.468"><vh>_set_prompt_str</vh></v>
<v t="ekr.20050704165326.469"><vh>set_colors</vh></v>
<v t="ekr.20050704165326.470"><vh>__call__</vh></v>
<v t="ekr.20050704165326.471"><vh>_display</vh></v>
<v t="ekr.20050704165326.472"><vh>update</vh></v>
<v t="ekr.20050704165326.473"><vh>flush</vh></v>
</v>
<v t="ekr.20050704165326.265" a="E"><vh>class InteractiveShell (code.InteractiveConsole,Logger,Magic) (in iplib.py)</vh>
<v t="ekr.20050704165326.266"><vh>__init__</vh>
<v t="ekr.20050707212426"><vh>&lt;&lt; add stuff to builtins &gt;&gt;</vh></v>
<v t="ekr.20050707212426.1"><vh>&lt;&lt; Create the namespace where the user will operate &gt;&gt;</vh></v>
<v t="ekr.20050707212426.2"><vh>&lt;&lt; create ivars &gt;&gt;</vh></v>
<v t="ekr.20050707212426.3"><vh>&lt;&lt; handle escapes &gt;&gt;</vh></v>
<v t="ekr.20050708080420"><vh>&lt;&lt; create a job manager &gt;&gt;</vh></v>
<v t="ekr.20050708080420.1"><vh>&lt;&lt; init classes &gt;&gt;</vh></v>
<v t="ekr.20050708080420.2"><vh>&lt;&lt; set all default hooks, defined in the IPython.hooks module &gt;&gt;</vh></v>
<v t="ekr.20050708080420.3"><vh>&lt;&lt; define usage messages &gt;&gt;</vh></v>
<v t="ekr.20050708080420.4"><vh>&lt;&lt; define functions to call the underlying shell &gt;&gt;</vh></v>
<v t="ekr.20050708080420.5"><vh>&lt;&lt; define regular expressions &gt;&gt;</vh></v>
<v t="ekr.20050708080420.6"><vh>&lt;&lt; Attributes for Logger mixin class, make defaults here &gt;&gt;</vh></v>
<v t="ekr.20050708080420.7"><vh>&lt;&lt; various switches which can be set &gt;&gt;</vh></v>
<v t="ekr.20050708080420.8"><vh>&lt;&lt; traceBack handlers &gt;&gt;</vh></v>
<v t="ekr.20050708080420.9"><vh>&lt;&lt; object inspector &gt;&gt;</vh></v>
<v t="ekr.20050708080420.10"><vh>&lt;&lt; Make some aliases automatically &gt;&gt;</vh></v>
<v t="ekr.20050708080420.11"><vh>&lt;&lt; storage &gt;&gt;</vh></v>
<v t="ekr.20050708080420.12"><vh>&lt;&lt; for pushd/popd management &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708082932"><vh>Customization...</vh>
<v t="ekr.20050704165326.267"><vh>set_hook</vh></v>
<v t="ekr.20050707224615"><vh>set_custom_exc</vh></v>
<v t="ekr.20050707224710"><vh>set_custom_completer</vh></v>
</v>
<v t="ekr.20050708082932.1"><vh>Init...</vh>
<v t="ekr.20050707224710.1"><vh>post_config_initialization</vh></v>
<v t="ekr.20050707224710.2"><vh>init_auto_alias</vh></v>
<v t="ekr.20050707224710.3"><vh>alias_table_validate</vh></v>
<v t="ekr.20050707224710.6"><vh>user_setup</vh></v>
<v t="ekr.20050707224710.5"><vh>rc_set_toggle (not called from InteractiveShell)</vh></v>
</v>
<v t="ekr.20050708084235"><vh>Death...</vh>
<v t="ekr.20050707224710.7"><vh>atexit_operations</vh></v>
<v t="ekr.20050707230243.1"><vh>savehist</vh></v>
</v>
<v t="ekr.20050708084235.1"><vh>Interactives stuff (will not be used in Leo)</vh>
<v t="ekr.20050708082932.2"><vh>Readline...</vh>
<v t="ekr.20050707230243.2"><vh>pre_readline</vh></v>
<v t="ekr.20050707230243.3"><vh>init_readline</vh></v>
<v t="ekr.20050707224710.4"><vh>set_autoindent (called only from init_readline)</vh></v>
</v>
<v t="ekr.20050707230243.5"><vh>debugger</vh></v>
<v t="ekr.20050707230243.9"><vh>mainloop &amp; name_space_init</vh>
<v t="ekr.20050707230243.8"><vh>name_space_init</vh></v>
</v>
<v t="ekr.20050707230243.11"><vh>embed_mainloop</vh></v>
<v t="ekr.20050707230243.15"><vh>runlines</vh></v>
</v>
<v t="ekr.20050708084235.2"><vh>Calling system stuff</vh>
<v t="ekr.20050707230243.10"><vh>exec_init_cmd</vh></v>
<v t="ekr.20050707230243.14"><vh>call_alias</vh></v>
</v>
<v t="ekr.20050708072233.1"><vh>Overrides of code.InteractiveInterpreter</vh>
<v t="ekr.20050707230243.17"><vh>runcode</vh></v>
<v t="ekr.20050707230243.16"><vh>runsource</vh></v>
<v t="ekr.20050707230243.4"><vh>showsyntaxerror</vh></v>
<v t="ekr.20050707230243.6"><vh>showtraceback</vh></v>
<v t="ekr.20050708072233.2"><vh>write (use base class)  COULD OVERRIDE THIS</vh></v>
<v t="ekr.20050707230243.13"><vh>excepthook (helper)</vh></v>
</v>
<v t="ekr.20050708071222"><vh>Overrides of code.InteractiveConsole</vh>
<v t="ekr.20050707230243.12" a="M"><vh>interact</vh></v>
<v t="ekr.20050708072233.3"><vh>push (use base class)</vh></v>
<v t="ekr.20050707230243.18"><vh>raw_input</vh></v>
<v t="ekr.20050708072233.4"><vh>resetbuffer (use base class)</vh></v>
</v>
<v t="ekr.20050708074118.6" a="ETV"><vh>prefilter &amp; helpers</vh>
<v t="ekr.20050707230243.21"><vh>_prefilter_dumb</vh></v>
<v t="ekr.20050707230243.20" a="EM"><vh>_prefilter (Rewrite?)</vh>
<v t="ekr.20050708074118"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708074118.1"><vh>&lt;&lt; handle empty line &gt;&gt;</vh></v>
<v t="ekr.20050708074118.2"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708074118.3"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708074118.4"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708074118.5"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050707230243.22"><vh>handle_normal</vh></v>
<v t="ekr.20050707230243.23"><vh>handle_alias</vh></v>
<v t="ekr.20050707230243.24"><vh>handle_shell_escape</vh></v>
<v t="ekr.20050707230243.25"><vh>handle_magic</vh></v>
<v t="ekr.20050707230243.26"><vh>handle_auto</vh></v>
<v t="ekr.20050707230243.27"><vh>handle_help</vh></v>
<v t="ekr.20050707230243.28"><vh>handle_emacs</vh></v>
<v t="ekr.20050707230243.29"><vh>safe_execfile</vh></v>
<v t="ekr.20050707230243.19"><vh>split_user_input</vh></v>
<v t="ekr.20050707230243.7"><vh>update_cache</vh></v>
</v>
</v>
</v>
<v t="ekr.20050708084235.4"><vh>Notes</vh>
<v t="ekr.20050704165326.176"><vh>page (genutils)</vh></v>
<v t="ekr.20050708074118.6"><vh>prefilter &amp; helpers</vh>
<v t="ekr.20050707230243.21"><vh>_prefilter_dumb</vh></v>
<v t="ekr.20050707230243.20" a="EM"><vh>_prefilter (Rewrite?)</vh>
<v t="ekr.20050708074118"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708074118.1"><vh>&lt;&lt; handle empty line &gt;&gt;</vh></v>
<v t="ekr.20050708074118.2"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708074118.3"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708074118.4"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708074118.5"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050707230243.22"><vh>handle_normal</vh></v>
<v t="ekr.20050707230243.23"><vh>handle_alias</vh></v>
<v t="ekr.20050707230243.24"><vh>handle_shell_escape</vh></v>
<v t="ekr.20050707230243.25"><vh>handle_magic</vh></v>
<v t="ekr.20050707230243.26"><vh>handle_auto</vh></v>
<v t="ekr.20050707230243.27"><vh>handle_help</vh></v>
<v t="ekr.20050707230243.28"><vh>handle_emacs</vh></v>
<v t="ekr.20050707230243.29"><vh>safe_execfile</vh></v>
<v t="ekr.20050707230243.19"><vh>split_user_input</vh></v>
<v t="ekr.20050707230243.7"><vh>update_cache</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20050704164036"></t>
<t tx="ekr.20050704164036.2"></t>
<t tx="ekr.20050704164036.3">@language python
#########################################################################
""" wingdbstub.py    -- Debug stub for debuggifying Python programs

Copyright (c) 1999-2001, Archaeopteryx Software, Inc.  All rights reserved.

Written by Stephan R.A. Deibel and John P. Ehresman

Usage:
-----

This is the file that Wing DB users copy into their python project 
directory if they want to be able to debug programs that are launched
outside of the IDE (e.g., CGI scripts, in response to a browser page
load).

To use this, edit the configuration values below to match your 
Wing IDE installation and requirements of your project.

Then, add the following line to your code:

  import wingdbstub

Debugging will start immediately after this import statements.

Next make sure that your IDE is running and that it's configured
to do passive listening and accept passive connections from the
host the debug program will be running on.

Now, invoking your python file should run the code within the debugger.
Note, however, that Wing will not stop in the code unless a breakpoint
set set.

If the debug process is started before the IDE, or is not listening
at the time this module is imported then the program will run with
debugging until an attach request is seen.  Attaching only works 
if the .wingdebugpw file is present; see the manual for details.

One win32, you either need to edit WINGHOME in this script or
pass in an environment variable called WINGHOME that points to
the Wing IDE installation directory.

"""
#########################################################################

import sys
import os
import string
import imp


#------------------------------------------------------------------------
# Default configuration values:  Note that the named environment 
# variables, if set, will override these settings.

# Set this to 1 to disable all debugging; 0 to enable debugging
# (WINGDB_DISABLED environment variable)
kWingDebugDisabled = 0

# Host:port of the IDE within which to debug: As configured in the IDE
# (WINGDB_HOSTPORT environment variable)
kWingHostPort = 'localhost:50005'

# Port on which to listen for connection requests, so that the
# IDE can (re)attach to the debug process after it has started
# Note that a random port is used instead if this port is already
# in use!
# (WINGDB_ATTACHPORT environment variable)
kAttachPort = '50015'

# Set this to a filename to log verbose information about the debugger
# internals to a file.  If the file does not exist, it will be created
# as long as its enclosing directory exists and is writeable.  Use 
# "&lt;stderr&gt;" or "&lt;stdout&gt;".  Note that "&lt;stderr&gt;" may cause problems 
# on win32 if the debug process is not running in a console.
# (WINGDB_LOGFILE environment variable)
kLogFile = None

# Set this to 1 when debugging embedded scripts:  It turns off
# automatic detecting of program quit so that the debug session
# can span multiple script invocations.
# (WINGDB_EMBEDDED environment variable)
kEmbedded = 0

# Path to search for the debug password file and the name of the file
# to use.  The password file contains the encryption type and connect 
# password for all connections to the IDE and must match the .wingdebugpw
# file in the profile dir used by the IDE.  Any entry of '$&lt;winguserprofile&gt;' 
# is replaced by the wing user profile directory for the user that the 
# current process is running as
# (WINGDB_PWFILEPATH environment variable)
kPWFilePath = [os.path.dirname(__file__), '$&lt;winguserprofile&gt;']
kPWFileName = '.wingdebugpw'

# Whether to exit if the debugger fails to run or to connect with an IDE
# for whatever reason
kExitOnFailure = 0

#------------------------------------------------------------------------
# Find Wing debugger installation location

# Edit this to point to your Wing installation or comment out to use env setting
WINGHOME = r"C:\Program Files\Wing IDE 2.0"

# Check environment:  Must have WINGHOME defined if still == None
if WINGHOME == None:
  if os.environ.has_key('WINGHOME'):
    WINGHOME=os.environ['WINGHOME']
  else:
    print "*******************************************************************"
    print "Error: Could not find Wing installation!  You must set WINGHOME or edit"
    print "wingdbstub.py where indicated to point it to the location where"
    print "Wing IDE is installed."
    sys.exit(1)


#------------------------------------------------------------------------
# Sanity check:  Debugging in optimized mode makes no sense
if __debug__ == 0:
  print "*******************************************************************"
  print "Error: Cannot run a debug process with optimized python because"
  print "Error: this omits necessary debug information from byte code."
  print "Error: You must omit the -O or -OO command line option, or undefine"
  print "Error: environment variable PYTHONOPTIMIZE before launching python."
  sys.exit(2)
  
#------------------------------------------------------------------------
# Start debugging if not disabled and this module has never been imported
# before
if not os.environ.has_key('WINGDB_ACTIVE'):
  debugger = None
if not kWingDebugDisabled and not os.environ.has_key('WINGDB_DISABLED') and \
   not os.environ.has_key('WINGDB_ACTIVE'):

  exit_on_fail = 0
  
  try:
    # Obtain exit if fails value
    exit_on_fail = os.environ.get('WINGDB_EXITONFAILURE', kExitOnFailure)
    
    # Obtain configuration for log file to use, if any
    logfile = os.environ.get('WINGDB_LOGFILE', kLogFile)
    if logfile == '-' or logfile == None or len(string.strip(logfile)) == 0:
      logfile = None
  
    # Determine remote host/port where the IDE is running
    hostport = os.environ.get('WINGDB_HOSTPORT', kWingHostPort)
    colonpos = string.find(hostport, ':')
    host = hostport[:colonpos]
    port = int(hostport[colonpos+1:])
  
    # Determine port to listen on locally for attach requests
    attachport = int(os.environ.get('WINGDB_ATTACHPORT', kAttachPort))
  
    # Check if running embedded script
    embedded = int(os.environ.get('WINGDB_EMBEDDED', kEmbedded))
  
    # Obtain debug password file search path
    if os.environ.has_key('WINGDB_PWFILEPATH'):
      pwfile_path = string.split(os.environ['WINGDB_PWFILEPATH'],
                                 os.pathsep)
    else:
      pwfile_path = kPWFilePath
    
    # Obtain debug password file name
    if os.environ.has_key('WINGDB_PWFILENAME'):
      pwfile_name = os.environ['WINGDB_PWFILENAME']
    else:
      pwfile_name = kPWFileName
    
    # Load wingdb.py
    wingdb = None
    for path in (os.path.join(WINGHOME, 'bin'), os.path.join(WINGHOME, 'src')):
      try:
        f, p, d = imp.find_module('wingdb', [path])
        try:
          wingdb = imp.load_module('wingdb', f, p, d)
        finally:
          if f is not None:
            f.close()
        break
      except ImportError:
        pass
    if wingdb == None:
      print "*******************************************************************"
      print "Error: Cannot find wingdb.py in $(WINGHOME)/bin or $(WINGHOME)/src"
      print "Error: Please check the WINGHOME definition in wingdbstub.py"
      sys.exit(2)
    
    # Find the netserver module and create an error stream
    netserver = wingdb.FindNetServerModule(WINGHOME)
    err = wingdb.CreateErrStream(netserver, logfile)
    
    # Start debugging
    debugger = netserver.CNetworkServer(host, port, attachport, err, 
                                        pwfile_path=pwfile_path,
                                        pwfile_name=pwfile_name)
    debugger.StartDebug(stophere=0, autoquit=not embedded)
    os.environ['WINGDB_ACTIVE'] = "1"
    if debugger.ChannelClosed():
      raise ValueError('Not connected')
    
  except:
    if exit_on_fail:
      raise
    else:
      pass
</t>
<t tx="ekr.20050704164036.4">@language python

from PyReadline import *

__all__ = [ 'parse_and_bind',
            'get_line_buffer',
            'insert_text',
            'read_init_file',
            'read_history_file',
            'write_history_file',
            'get_history_length',
            'set_history_length',
            'set_startup_hook',
            'set_pre_input_hook',
            'set_completer',
            'get_completer',
            'get_begidx',
            'get_endidx',
            'set_completer_delims',
            'get_completer_delims',
            'add_history' ]
</t>
<t tx="ekr.20050704164036.5">'''Cursor control and color for the Windows console.

This was modeled after the C extension of the same name by Fredrik Lundh. 
'''

@language python
@tabwidth -2

@others

if __name__ == '__main__':
  import time, sys
  c = Console(0)
  sys.stdout = c
  sys.stderr = c
  c.page()
  c.pos(5, 10)
  c.write('hi there')
  print 'some printed output'
  for i in range(10):
    c.getkeypress()
  del c
</t>
<t tx="ekr.20050704164036.7"># primitive debug printing that won't interfere with the screen
if 0:
  fp = open('debug.txt', 'w')
  def log(s):
    print &gt;&gt;fp, s
    fp.flush()
else:
  def log(s):
    pass</t>
<t tx="ekr.20050704164036.9">
import sys
import traceback
import re

try:
  # I developed this with ctypes 0.6
  from ctypes import *
  from _ctypes import call_function
except ImportError:
  print 'you need the ctypes module to run this code'
  print 'http://starship.python.net/crew/theller/ctypes/'
  raise

# my code
from keysyms import make_keysym, make_keyinfo

# some constants we need
STD_INPUT_HANDLE = -10
STD_OUTPUT_HANDLE = -11
ENABLE_WINDOW_INPUT = 0x0008
ENABLE_MOUSE_INPUT = 0x0010
ENABLE_PROCESSED_INPUT = 0x0001
WHITE = 0x7
BLACK = 0
MENU_EVENT = 0x0008
KEY_EVENT = 0x0001
MOUSE_MOVED = 0x0001
MOUSE_EVENT = 0x0002
WINDOW_BUFFER_SIZE_EVENT = 0x0004
FOCUS_EVENT = 0x0010
MENU_EVENT = 0x0008
VK_SHIFT = 0x10
VK_CONTROL = 0x11
VK_MENU = 0x12
GENERIC_READ = int(0x80000000L)
GENERIC_WRITE = 0x40000000

# Windows structures we'll need later
class COORD(Structure):
	&lt;&lt; class COORD declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.10">_fields_ = [("X", c_short),
            ("Y", c_short)]

</t>
<t tx="ekr.20050704164036.11">class SMALL_RECT(Structure):
	&lt;&lt; class SMALL_RECT declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.12">_fields_ = [("Left", c_short),
            ("Top", c_short),
            ("Right", c_short),
            ("Bottom", c_short)]

</t>
<t tx="ekr.20050704164036.13">class CONSOLE_SCREEN_BUFFER_INFO(Structure):
	&lt;&lt; class CONSOLE_SCREEN_BUFFER_INFO declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.14">_fields_ = [("dwSize", COORD),
            ("dwCursorPosition", COORD),
            ("wAttributes", c_short),
            ("srWindow", SMALL_RECT),
            ("dwMaximumWindowSize", COORD)]

</t>
<t tx="ekr.20050704164036.15">class CHAR_UNION(Union):
	&lt;&lt; class CHAR_UNION declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.16">_fields_ = [("UnicodeChar", c_short),
            ("AsciiChar", c_char)]

</t>
<t tx="ekr.20050704164036.17">class CHAR_INFO(Structure):
	&lt;&lt; class CHAR_INFO declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.18">_fields_ = [("Char", CHAR_UNION),
            ("Attributes", c_short)]

</t>
<t tx="ekr.20050704164036.19">class KEY_EVENT_RECORD(Structure):
	&lt;&lt; class KEY_EVENT_RECORD declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.20">_fields_ = [("bKeyDown", c_byte),
            ("pad2", c_byte),
            ('pad1', c_short),
            ("wRepeatCount", c_short),
            ("wVirtualKeyCode", c_short),
            ("wVirtualScanCode", c_short),
            ("uChar", CHAR_UNION),
            ("dwControlKeyState", c_int)]

</t>
<t tx="ekr.20050704164036.21">class MOUSE_EVENT_RECORD(Structure):
	&lt;&lt; class MOUSE_EVENT_RECORD declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.22">_fields_ = [("dwMousePosition", COORD),
            ("dwButtonState", c_int),
            ("dwControlKeyState", c_int),
            ("dwEventFlags", c_int)]

</t>
<t tx="ekr.20050704164036.23">class WINDOW_BUFFER_SIZE_RECORD(Structure):
	&lt;&lt; class WINDOW_BUFFER_SIZE_RECORD declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.24">_fields_ = [("dwSize", COORD)]

</t>
<t tx="ekr.20050704164036.25">class MENU_EVENT_RECORD(Structure):
	&lt;&lt; class MENU_EVENT_RECORD declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.26">_fields_ = [("dwCommandId", c_uint)]

</t>
<t tx="ekr.20050704164036.27">class FOCUS_EVENT_RECORD(Structure):
	&lt;&lt; class FOCUS_EVENT_RECORD declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.28">_fields_ = [("bSetFocus", c_byte)]

</t>
<t tx="ekr.20050704164036.29">class INPUT_UNION(Union):
	&lt;&lt; class INPUT_UNION declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.30">_fields_ = [("KeyEvent", KEY_EVENT_RECORD),
            ("MouseEvent", MOUSE_EVENT_RECORD),
            ("WindowBufferSizeEvent", WINDOW_BUFFER_SIZE_RECORD),
            ("MenuEvent", MENU_EVENT_RECORD),
            ("FocusEvent", FOCUS_EVENT_RECORD)]

</t>
<t tx="ekr.20050704164036.31">class INPUT_RECORD(Structure):
	&lt;&lt; class INPUT_RECORD declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.32">_fields_ = [("EventType", c_short),
            ("Event", INPUT_UNION)]

</t>
<t tx="ekr.20050704164036.33">class CONSOLE_CURSOR_INFO(Structure):
	&lt;&lt; class CONSOLE_CURSOR_INFO declarations &gt;&gt;
</t>
<t tx="ekr.20050704164036.34">_fields_ = [("dwSize", c_int),
            ("bVisible", c_byte)]

# I didn't want to have to individually import these so I made a list, they are
# added to the Console class later in this file.

</t>
<t tx="ekr.20050704164036.35">funcs = [
  'AllocConsole',
  'CreateConsoleScreenBuffer',
  'FillConsoleOutputAttribute',
  'FillConsoleOutputCharacterA',
  'FreeConsole',
  'GetConsoleCursorInfo',
  'GetConsoleMode',
  'GetConsoleScreenBufferInfo',
  'GetConsoleTitleA',
  'GetProcAddress',
  'GetStdHandle',
  'PeekConsoleInputA',
  'ReadConsoleInputA',
  'ScrollConsoleScreenBufferA',
  'SetConsoleActiveScreenBuffer',
  'SetConsoleCursorInfo',
  'SetConsoleCursorPosition',
  'SetConsoleMode',
  'SetConsoleScreenBufferSize',
  'SetConsoleTextAttribute',
  'SetConsoleTitleA',
  'SetConsoleWindowInfo',
  'WriteConsoleA',
  'WriteConsoleOutputCharacterA',
  ]

# I don't want events for these keys, they are just a bother for my application
key_modifiers = { VK_SHIFT:1,
                  VK_CONTROL:1,
                  VK_MENU:1, # alt key
                  0x5b:1, # windows key
                  }

class Console(object):
  '''Console driver for Windows.

  '''
	@others
</t>
<t tx="ekr.20050704164036.36">def __init__(self, newbuffer=0):
  '''Initialize the Console object.

  newbuffer=1 will allocate a new buffer so the old content will be restored
  on exit.
  '''
  #Do I need the following line? It causes a console to be created whenever
  #readline is imported into a pythonw application which seems wrong. Things
  #seem to work without it...
  #self.AllocConsole()

  if newbuffer:
    self.hout = self.CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                               0, None, 1, None)
    self.SetConsoleActiveScreenBuffer(self.hout)
  else:
    self.hout = self.GetStdHandle(STD_OUTPUT_HANDLE)

  self.hin = self.GetStdHandle(STD_INPUT_HANDLE)
  self.inmode = c_int(0)
  self.GetConsoleMode(self.hin, byref(self.inmode))
  self.SetConsoleMode(self.hin, 0xf)
  info = CONSOLE_SCREEN_BUFFER_INFO()
  self.GetConsoleScreenBufferInfo(self.hout, byref(info))
  self.attr = info.wAttributes # remember the initial colors
  background = self.attr &amp; 0xf0
  for escape in self.escape_to_color:
    if self.escape_to_color[escape] is not None:
      self.escape_to_color[escape] |= background
  log('initial attr=%x' % self.attr)
  self.softspace = 0 # this is for using it as a file-like object
  self.serial = 0

  self.pythondll = CDLL('python%s%s' % (sys.version[0], sys.version[2]))
  self.inputHookPtr = c_int.from_address(addressof(self.pythondll.PyOS_InputHook)).value
  setattr(Console, 'PyMem_Malloc', self.pythondll.PyMem_Malloc)
</t>
<t tx="ekr.20050704164036.37">def __del__(self):
  '''Cleanup the console when finished.'''
  # I don't think this ever gets called
  self.SetConsoleTextAttribute(self.hout, self.saveattr)
  self.SetConsoleMode(self.hin, self.inmode)
  self.FreeConsole()
</t>
<t tx="ekr.20050704164036.38">def fixcoord(self, x, y):
  '''Return a long with x and y packed inside, also handle negative x and y.'''
  if x &lt; 0 or y &lt; 0:
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    if x &lt; 0:
      x = info.srWindow.Right - x
      y = info.srWindow.Bottom + y

  # this is a hack! ctypes won't pass structures but COORD is just like a
  # long, so this works.
  return c_int(y &lt;&lt; 16 | x)
</t>
<t tx="ekr.20050704164036.39">def pos(self, x=None, y=None):
  '''Move or query the window cursor.'''
  if x is None:
    info = CONSOLE_SCREEN_BUFFER_INFO()
    self.GetConsoleScreenBufferInfo(self.hout, byref(info))
    return (info.dwCursorPosition.X, info.dwCursorPosition.Y)
  else:
    return self.SetConsoleCursorPosition(self.hout, self.fixcoord(x, y))
</t>
<t tx="ekr.20050704164036.40">def home(self):
  '''Move to home.'''
  self.pos(0,0)
</t>
<t tx="ekr.20050704164036.41"># Map ANSI color escape sequences into Windows Console Attributes

terminal_escape = re.compile('(\001?\033\\[[0-9;]+m\002?)')
escape_parts = re.compile('\001?\033\\[([0-9;]+)m\002?')
escape_to_color = { '0;30': 0x0,             #black
                    '0;31': 0x4,             #red
                    '0;32': 0x2,             #green
                    '0;33': 0x4+0x2,         #brown?
                    '0;34': 0x1,             #blue
                    '0;35': 0x1+0x4,         #purple
                    '0;36': 0x2+0x4,         #cyan
                    '0;37': 0x1+0x2+0x4,     #grey
                    '1;30': 0x1+0x2+0x4,     #dark gray
                    '1;31': 0x4+0x8,         #red
                    '1;32': 0x2+0x8,         #light green
                    '1;33': 0x4+0x2+0x8,     #yellow
                    '1;34': 0x1+0x8,         #light blue
                    '1;35': 0x1+0x4+0x8,     #light purple
                    '1;36': 0x1+0x2+0x8,     #light cyan
                    '1;37': 0x1+0x2+0x4+0x8, #white
                    '0': None,
                    }

# This pattern should match all characters that change the cursor position differently
# than a normal character.
motion_char_re = re.compile('([\n\r\t\010\007])')

def write_scrolling(self, text, attr=None):
  '''write text at current cursor position while watching for scrolling.

  If the window scrolls because you are at the bottom of the screen
  buffer, all positions that you are storing will be shifted by the
  scroll amount. For example, I remember the cursor position of the
  prompt so that I can redraw the line but if the window scrolls,
  the remembered position is off.

  This variant of write tries to keep track of the cursor position
  so that it will know when the screen buffer is scrolled. It
  returns the number of lines that the buffer scrolled.

  '''
  x, y = self.pos()
  w, h = self.size()
  scroll = 0 # the result

  # split the string into ordinary characters and funny characters
  chunks = self.motion_char_re.split(text)
  for chunk in chunks:
    log('C:'+chunk)
    n = self.write_color(chunk, attr)
    if len(chunk) == 1: # the funny characters will be alone
      if chunk[0] == '\n': # newline
        x = 0
        y += 1
      elif chunk[0] == '\r': # carriage return
        x = 0
      elif chunk[0] == '\t': # tab
        x = 8*(int(x/8)+1)
        if x &gt; w: # newline
          x -= w
          y += 1
      elif chunk[0] == '\007': # bell
        pass
      elif chunk[0] == '\010':
        x -= 1
        if x &lt; 0:
          y -= 1 # backed up 1 line
      else: # ordinary character
        x += 1
      if x == w: # wrap
        x = 0
        y += 1
      if y == h: # scroll
        scroll += 1
        y = h - 1
    else: # chunk of ordinary characters
      x += n
      l = int(x / w) # lines we advanced
      x = x % w # new x value
      y += l
      if y &gt;= h: # scroll
        scroll += y - h + 1
        y = h - 1
  return scroll
</t>
<t tx="ekr.20050704164036.42">def write_color(self, text, attr=None):
  '''write text at current cursor position and interpret color escapes.

  return the number of characters written.
  '''
  log('write_color("%s", %s)' % (text, attr))
  chunks = self.terminal_escape.split(text)
  log('chunks=%s' % repr(chunks))
  junk = c_int(0)
  n = 0 # count the characters we actually write, omitting the escapes
  for chunk in chunks:
    m = self.escape_parts.match(chunk)
    if m:
      attr = self.escape_to_color[m.group(1)]
      continue
    n += len(chunk)
    log('attr=%s' % attr)
    if attr is None:
      attr = self.attr
    self.SetConsoleTextAttribute(self.hout, attr)
    self.WriteConsoleA(self.hout, chunk, len(chunk), byref(junk), None)
  return n
</t>
<t tx="ekr.20050704164036.43">def write_plain(self, text, attr=None):
  '''write text at current cursor position.'''
  log('write("%s", %s)' %(text,attr))
  if attr is None:
    attr = self.attr
  n = c_int(0)
  self.SetConsoleTextAttribute(self.hout, attr)
  self.WriteConsoleA(self.hout, text, len(text), byref(n), None)
  return len(text)
</t>
<t tx="ekr.20050704164036.44"># make this class look like a file object
def write(self, text):
  log('write("%s")' % text)
  return self.write_color(text)
</t>
<t tx="ekr.20050704164036.45">#write = write_scrolling

def isatty(self):
  return True
</t>
<t tx="ekr.20050704164036.46">def flush(self):
  pass
</t>
<t tx="ekr.20050704164036.47">def page(self, attr=None, fill=' '):
  '''Fill the entire screen.'''
  if attr is None:
    attr = self.attr
  if len(fill) != 1:
    raise ValueError
  info = CONSOLE_SCREEN_BUFFER_INFO()
  self.GetConsoleScreenBufferInfo(self.hout, byref(info))
  if info.dwCursorPosition.X != 0 or info.dwCursorPosition.Y != 0:
    self.SetConsoleCursorPosition(self.hout, self.fixcoord(0, 0))

  w = info.dwSize.X
  n = c_int(0)
  for y in range(info.dwSize.Y):
    self.FillConsoleOutputAttribute(self.hout, attr, w, self.fixcoord(0, y), byref(n))
    self.FillConsoleOutputCharacterA(self.hout, ord(fill[0]), w, self.fixcoord(0, y), byref(n))

  self.attr = attr
</t>
<t tx="ekr.20050704164036.48">def text(self, x, y, text, attr=None):
  '''Write text at the given position.'''
  if attr is None:
    attr = self.attr

  pos = self.fixcoord(x, y)
  n = c_int(0)
  self.WriteConsoleOutputCharacterA(self.hout, text, len(text), pos, byref(n))
  self.FillConsoleOutputAttribute(self.hout, attr, n, pos, byref(n))
</t>
<t tx="ekr.20050704164036.49">def rectangle(self, rect, attr=None, fill=' '):
  '''Fill Rectangle.'''
  x0, y0, x1, y1 = rect
  n = c_int(0)
  if attr is None:
    attr = self.attr
  for y in range(y0, y1):
    pos = self.fixcoord(x0, y)
    self.FillConsoleOutputAttribute(self.hout, attr, x1-x0, pos, byref(n))
    self.FillConsoleOutputCharacterA(self.hout, ord(fill[0]), x1-x0, pos, byref(n))
</t>
<t tx="ekr.20050704164036.50">def scroll(self, rect, dx, dy, attr=None, fill=' '):
  '''Scroll a rectangle.'''
  if attr is None:
    attr = self.attr
    
  x0, y0, x1, y1 = rect
  source = SMALL_RECT(x0, y0, x1-1, y1-1)
  dest = self.fixcoord(x0+dx, y0+dy)
  style = CHAR_INFO()
  style.Char.AsciiChar = fill[0]
  style.Attributes = attr

  return self.ScrollConsoleScreenBufferA(self.hout, byref(source), byref(source),
                                         dest, byref(style))
</t>
<t tx="ekr.20050704164036.51">def scroll_window(self, lines):
  '''Scroll the window by the indicated number of lines.'''
  info = CONSOLE_SCREEN_BUFFER_INFO()
  self.GetConsoleScreenBufferInfo(self.hout, byref(info))
  rect = info.srWindow
  log('sw: rtop=%d rbot=%d' % (rect.Top, rect.Bottom))
  top = rect.Top + lines
  bot = rect.Bottom + lines
  h = bot - top
  maxbot = info.dwSize.Y-1
  log('sw: lines=%d mb=%d top=%d bot=%d' % (lines,maxbot,top,bot))
  if top &lt; 0:
    top = 0
    bot = h
  if bot &gt; maxbot:
    bot = maxbot
    top = bot - h

  nrect = SMALL_RECT()
  nrect.Top = top
  nrect.Bottom = bot
  nrect.Left = rect.Left
  nrect.Right = rect.Right
  log('sn: top=%d bot=%d' % (top,bot))
  r=self.SetConsoleWindowInfo(self.hout, True, byref(nrect))
  log('r=%d' % r)
</t>
<t tx="ekr.20050704164036.52">def get(self):
  '''Get next event from queue.'''
  inputHookFunc = c_int.from_address(self.inputHookPtr).value

  Cevent = INPUT_RECORD()
  count = c_int(0)
  while 1:
    if inputHookFunc:
      call_function(inputHookFunc, ())
    status = self.ReadConsoleInputA(self.hin, byref(Cevent), 1, byref(count))
    if status and count.value == 1:
      e = event(self, Cevent)
      return e
</t>
<t tx="ekr.20050704164036.53">def getkeypress(self):
  '''Return next key press event from the queue, ignoring others.'''
  while 1:
    e = self.get()
    if e.type == 'KeyPress' and e.keycode not in key_modifiers:
      log(e)
      if e.keysym == 'Next':
        self.scroll_window(12)
      elif e.keysym == 'Prior':
        self.scroll_window(-12)
      else:
        return e
</t>
<t tx="ekr.20050704164036.54">def getchar(self):
  '''Get next character from queue.'''

  Cevent = INPUT_RECORD()
  count = c_int(0)
  while 1:
    status = self.ReadConsoleInputA(self.hin, byref(Cevent), 1, byref(count))
    if (status and count.value==1 and Cevent.EventType == 1 and
        Cevent.Event.KeyEvent.bKeyDown):
      sym = keysym(Cevent.Event.KeyEvent.wVirtualKeyCode)
      if len(sym) == 0:
        sym = Cevent.Event.KeyEvent.uChar.AsciiChar
      return sym
</t>
<t tx="ekr.20050704164036.55">def peek(self):
  '''Check event queue.'''
  Cevent = INPUT_RECORD()
  count = c_int(0)
  status = PeekConsoleInput(self.hin, byref(Cevent), 1, byref(count))
  if status and count == 1:
    return event(self, Cevent)
</t>
<t tx="ekr.20050704164036.56">def title(self, txt=None):
  '''Set/get title.'''
  if txt:
    self.SetConsoleTitleA(txt)
  else:
    buffer = c_buffer(200)
    n = self.GetConsoleTitleA(buffer, 200)
    if n &gt; 0:
      return buffer.value[:n]
</t>
<t tx="ekr.20050704164036.57">def size(self, width=None, height=None):
  '''Set/get window size.'''
  info = CONSOLE_SCREEN_BUFFER_INFO()
  status = self.GetConsoleScreenBufferInfo(self.hout, byref(info))
  if not status:
    return None
  if width is not None and height is not None:
    wmin = info.srWindow.Right - info.srWindow.Left + 1
    hmin = info.srWindow.Bottom - info.srWindow.Top + 1
    #print wmin, hmin
    width = max(width, wmin)
    height = max(height, hmin)
    #print width, height
    self.SetConsoleScreenBufferSize(self.hout, self.fixcoord(width, height))
  else:
    return (info.dwSize.X, info.dwSize.Y)
</t>
<t tx="ekr.20050704164036.58">def cursor(self, visible):
  '''Set cursor on or off.'''
  info = CONSOLE_CURSOR_INFO()
  if self.GetConsoleCursorInfo(self.hout, byref(info)):
    info.bVisible = visible
    self.SetConsoleCursorInfo(self.hout, byref(info))
</t>
<t tx="ekr.20050704164036.59">def bell(self):
  self.write('\007')
</t>
<t tx="ekr.20050704164036.60">def next_serial(self):
  '''Get next event serial number.'''
  self.serial += 1
  return self.serial
</t>
<t tx="ekr.20050704164036.61">      
# add the functions from the dll to the class
for func in funcs:
  setattr(Console, func, getattr(windll.kernel32, func))

class event(object):
  '''Represent events from the console.'''
	@others
</t>
<t tx="ekr.20050704164036.62">def __init__(self, console, input):
  '''Initialize an event from the Windows input structure.'''
  self.type = '??'
  self.serial = console.next_serial()
  self.width = 0
  self.height = 0
  self.x = 0
  self.y = 0
  self.char = ''
  self.keycode = 0
  self.keysym = '??'
  self.keyinfo = '' # a tuple with (control, meta, shift, keycode) for dispatch
  self.width = None

  if input.EventType == KEY_EVENT:
    if input.Event.KeyEvent.bKeyDown:
      self.type = "KeyPress"
    else:
      self.type = "KeyRelease"
    self.char = input.Event.KeyEvent.uChar.AsciiChar
    self.keycode = input.Event.KeyEvent.wVirtualKeyCode
    self.state = input.Event.KeyEvent.dwControlKeyState
    self.keysym = make_keysym(self.keycode)
    self.keyinfo = make_keyinfo(self.keycode, self.state)
  elif input.EventType == MOUSE_EVENT:
    if input.Event.MouseEvent.dwEventFlags &amp; MOUSE_MOVED:
      self.type = "Motion"
    else:
      self.type = "Button"
    self.x = input.Event.MouseEvent.dwMousePosition.X
    self.y = input.Event.MouseEvent.dwMousePosition.Y
    self.state = input.Event.MouseEvent.dwButtonState
  elif input.EventType == WINDOW_BUFFER_SIZE_EVENT:
    self.type = "Configure"
    self.width = input.Event.WindowBufferSizeEvent.dwSize.X
    self.height = input.Event.WindowBufferSizeEvent.dwSize.Y
  elif input.EventType == FOCUS_EVENT:
    if input.Event.FocusEvent.bSetFocus:
      self.type = "FocusIn"
    else:
      self.type = "FocusOut"
  elif input.EventType == MENU_EVENT:
    self.type = "Menu"
    self.state = input.Event.MenuEvent.dwCommandId
</t>
<t tx="ekr.20050704164036.63">def __repr__(self):
  '''Display an event for debugging.'''
  if self.type in ['KeyPress', 'KeyRelease']:
    s = "%s char='%s'%d keysym='%s' keycode=%d:%x state=%x keyinfo=%s" % \
        (self.type, self.char, ord(self.char), self.keysym, self.keycode, self.keycode,
         self.state, self.keyinfo)
  elif self.type in ['Motion', 'Button']:
    s = '%s x=%d y=%d state=%x' % (self.type, self.x, self.y, self.state)
  elif self.type == 'Configure':
    s = '%s w=%d h=%d' % (self.type, self.width, self.height)
  elif self.type in ['FocusIn', 'FocusOut']:
    s = self.type
  elif self.type == 'Menu':
    s = '%s state=%x' % (self.type, self.state)
  else:
    s = 'unknown event type'
  return s
</t>
<t tx="ekr.20050704164036.64">def getconsole(buffer=1):
    """Get a console handle.

    If buffer is non-zero, a new console buffer is allocated and
    installed.  Otherwise, this returns a handle to the current
    console buffer"""

    c = Console(buffer)

    return c
</t>
<t tx="ekr.20050704164036.65"># The following code uses ctypes to allow a Python callable to
# substitute for GNU readline within the Python interpreter. Calling
# raw_input or other functions that do input, inside your callable
# might be a bad idea, then again, it might work.

# The Python callable can raise EOFError or KeyboardInterrupt and
# these will be translated into the appropriate outputs from readline
# so that they will then be translated back!

# If the Python callable raises any other exception, a traceback will
# be printed and readline will appear to return an empty line.

# I use ctypes to create a C-callable from a Python wrapper that
# handles the exceptions and gets the result into the right form.

# the type for our C-callable wrapper
HOOKFUNC22 = CFUNCTYPE(c_char_p, c_char_p)
HOOKFUNC23 = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)

readline_hook = None # the python hook goes here
readline_ref = None  # this holds a reference to the c-callable to keep it alive

def hook_wrapper_23(stdin, stdout, prompt):
  '''Wrap a Python readline so it behaves like GNU readline.'''
  try:
    # call the Python hook
    res = readline_hook(prompt)
    # make sure it returned the right sort of thing
    if res and not isinstance(res, str):
      raise TypeError, 'readline must return a string.'
  except KeyboardInterrupt:
    # GNU readline returns 0 on keyboard interrupt
    return 0
  except EOFError:
    # It returns an empty string on EOF
    res = ''
  except:
    print &gt;&gt;sys.stderr, 'Readline internal error'
    traceback.print_exc()
    res = '\n'
  # we have to make a copy because the caller expects to free the result
  n = len(res)
  p = Console.PyMem_Malloc(n+1)
  cdll.msvcrt.strncpy(p, res, n+1)
  return p
</t>
<t tx="ekr.20050704164036.66">def hook_wrapper(prompt):
  '''Wrap a Python readline so it behaves like GNU readline.'''
  try:
    # call the Python hook
    res = readline_hook(prompt)
    # make sure it returned the right sort of thing
    if res and not isinstance(res, str):
      raise TypeError, 'readline must return a string.'
  except KeyboardInterrupt:
    # GNU readline returns 0 on keyboard interrupt
    return 0
  except EOFError:
    # It returns an empty string on EOF
    res = ''
  except:
    print &gt;&gt;sys.stderr, 'Readline internal error'
    traceback.print_exc()
    res = '\n'
  # we have to make a copy because the caller expects to free the result
  p = cdll.msvcrt._strdup(res)
  return p
</t>
<t tx="ekr.20050704164036.67">def install_readline(hook):
  '''Set up things for the interpreter to call our function like GNU readline.'''
  global readline_hook, readline_ref
  # save the hook so the wrapper can call it
  readline_hook = hook
  # get the address of PyOS_ReadlineFunctionPointer so we can update it
  PyOS_RFP = c_int.from_address(Console.GetProcAddress(sys.dllhandle,
                                                       "PyOS_ReadlineFunctionPointer"))
  # save a reference to the generated C-callable so it doesn't go away
  if sys.version &lt; '2.3':
    readline_ref = HOOKFUNC22(hook_wrapper)
  else:
    readline_ref = HOOKFUNC23(hook_wrapper_23)
  # get the address of the function
  func_start = c_int.from_address(addressof(readline_ref)).value
  # write the function address into PyOS_ReadlineFunctionPointer
  PyOS_RFP.value = func_start
</t>
<t tx="ekr.20050704164036.68">@language python

import win32con as c32
from ctypes import windll

&lt;&lt; define code2sym_map &gt;&gt;
@others
</t>
<t tx="ekr.20050704164036.69"># table for translating virtual keys to X windows key symbols
code2sym_map = {c32.VK_CANCEL: 'Cancel',
                c32.VK_BACK: 'BackSpace',
                c32.VK_TAB: 'Tab',
                c32.VK_CLEAR: 'Clear',
                c32.VK_RETURN: 'Return',
                c32.VK_SHIFT:'Shift_L',
                c32.VK_CONTROL: 'Control_L',
                c32.VK_MENU: 'Alt_L',
                c32.VK_PAUSE: 'Pause',
                c32.VK_CAPITAL: 'Caps_Lock',
                c32.VK_ESCAPE: 'Escape',
                c32.VK_SPACE: 'space',
                c32.VK_PRIOR: 'Prior',
                c32.VK_NEXT: 'Next',
                c32.VK_END: 'End',
                c32.VK_HOME: 'Home',
                c32.VK_LEFT: 'Left',
                c32.VK_UP: 'Up',
                c32.VK_RIGHT: 'Right',
                c32.VK_DOWN: 'Down',
                c32.VK_SELECT: 'Select',
                c32.VK_PRINT: 'Print',
                c32.VK_EXECUTE: 'Execute',
                c32.VK_SNAPSHOT: 'Snapshot',
                c32.VK_INSERT: 'Insert',
                c32.VK_DELETE: 'Delete',
                c32.VK_HELP: 'Help',
                c32.VK_F1: 'F1',
                c32.VK_F2: 'F2',
                c32.VK_F3: 'F3',
                c32.VK_F4: 'F4',
                c32.VK_F5: 'F5',
                c32.VK_F6: 'F6',
                c32.VK_F7: 'F7',
                c32.VK_F8: 'F8',
                c32.VK_F9: 'F9',
                c32.VK_F10: 'F10',
                c32.VK_F11: 'F11',
                c32.VK_F12: 'F12',
                c32.VK_F13: 'F13',
                c32.VK_F14: 'F14',
                c32.VK_F15: 'F15',
                c32.VK_F16: 'F16',
                c32.VK_F17: 'F17',
                c32.VK_F18: 'F18',
                c32.VK_F19: 'F19',
                c32.VK_F20: 'F20',
                c32.VK_F21: 'F21',
                c32.VK_F22: 'F22',
                c32.VK_F23: 'F23',
                c32.VK_F24: 'F24',
                c32.VK_NUMLOCK: 'Num_Lock,',
                c32.VK_SCROLL: 'Scroll_Lock',
                c32.VK_APPS: 'VK_APPS',
                c32.VK_PROCESSKEY: 'VK_PROCESSKEY',
                c32.VK_ATTN: 'VK_ATTN',
                c32.VK_CRSEL: 'VK_CRSEL',
                c32.VK_EXSEL: 'VK_EXSEL',
                c32.VK_EREOF: 'VK_EREOF',
                c32.VK_PLAY: 'VK_PLAY',
                c32.VK_ZOOM: 'VK_ZOOM',
                c32.VK_NONAME: 'VK_NONAME',
                c32.VK_PA1: 'VK_PA1',
                c32.VK_OEM_CLEAR: 'VK_OEM_CLEAR',
                c32.VK_NUMPAD0: 'NUMPAD0',
                c32.VK_NUMPAD1: 'NUMPAD1',
                c32.VK_NUMPAD2: 'NUMPAD2',
                c32.VK_NUMPAD3: 'NUMPAD3',
                c32.VK_NUMPAD4: 'NUMPAD4',
                c32.VK_NUMPAD5: 'NUMPAD5',
                c32.VK_NUMPAD6: 'NUMPAD6',
                c32.VK_NUMPAD7: 'NUMPAD7',
                c32.VK_NUMPAD8: 'NUMPAD8',
                c32.VK_NUMPAD9: 'NUMPAD9',
                c32.VK_DIVIDE: 'Divide',
                c32.VK_MULTIPLY: 'Multiply',
                c32.VK_ADD: 'Add',
                c32.VK_SUBTRACT: 'Subtract',
                c32.VK_DECIMAL: 'VK_DECIMAL'
                }

# function to handle the mapping
</t>
<t tx="ekr.20050704164036.70">def make_keysym(keycode):
  try:
    sym = code2sym_map[keycode]
  except KeyError:
    sym = ''
  return sym
</t>
<t tx="ekr.20050704164036.71">sym2code_map = {}
for code,sym in code2sym_map.iteritems():
  sym2code_map[sym.lower()] = code
  
def key_text_to_keyinfo(keytext):
  '''Convert a GNU readline style textual description of a key to keycode with modifiers'''
  if keytext.startswith('"'): # "
    return keyseq_to_keyinfo(keytext[1:-1])
  else:
    return keyname_to_keyinfo(keytext)
</t>
<t tx="ekr.20050704164036.72">VkKeyScan = windll.user32.VkKeyScanA

def char_to_keyinfo(char, control=False, meta=False, shift=False):
  vk = VkKeyScan(ord(char))
  if vk &amp; 0xffff == 0xffff:
    print 'VkKeyScan("%s") = %x' % (char, vk)
    raise ValueError, 'bad key'
  if vk &amp; 0x100:
    shift = True
  if vk &amp; 0x200:
    control = True
  if vk &amp; 0x400:
    meta = True
  return (control, meta, shift, vk &amp; 0xff)
</t>
<t tx="ekr.20050704164036.73">def keyname_to_keyinfo(keyname):
  control = False
  meta = False
  shift = False

  while 1:
    lkeyname = keyname.lower()
    if lkeyname.startswith('control-'):
      control = True
      keyname = keyname[8:]
    elif lkeyname.startswith('meta-'):
      meta = True
      keyname = keyname[5:]
    elif lkeyname.startswith('alt-'):
      meta = True
      keyname = keyname[4:]
    elif lkeyname.startswith('shift-'):
      shift = True
      keyname = keyname[6:]
    else:
      if len(keyname) &gt; 1:
        return (control, meta, shift, sym2code_map[keyname.lower()])
      else:
        return char_to_keyinfo(keyname, control, meta, shift)
</t>
<t tx="ekr.20050704164036.74">def keyseq_to_keyinfo(keyseq):
  res = []
  control = False
  meta = False
  shift = False

  while 1:
    if keyseq.startswith('\\C-'):
      control = True
      keyseq = keyseq[3:]
    elif keyseq.startswith('\\M-'):
      meta = True
      keyseq = keyseq[3:]
    elif keyseq.startswith('\\e'):
      res.append(char_to_keyinfo('\033', control, meta, shift))
      control = meta = shift = False
      keyseq = keyseq[2:]
    elif len(keyseq) &gt;= 1:
      res.append(char_to_keyinfo(keyseq[0], control, meta, shift))
      control = meta = shift = False
      keyseq = keyseq[1:]
    else:
      return res[0]
</t>
<t tx="ekr.20050704164036.75">def make_keyinfo(keycode, state):
  control = (state &amp; (4+8)) != 0
  meta = (state &amp; (1+2)) != 0
  shift = (state &amp; 0x10) != 0
  return (control, meta, shift, keycode)
</t>
<t tx="ekr.20050704164036.76">@language python
&lt;&lt; imports &gt;&gt;
@others

# make these available so this looks like the python readline module
parse_and_bind = rl.parse_and_bind
get_line_buffer = rl.get_line_buffer
insert_text = rl.insert_text
read_init_file = rl.read_init_file
read_history_file = rl.read_history_file
write_history_file = rl.write_history_file
get_history_length = rl.get_history_length
set_history_length = rl.set_history_length
set_startup_hook = rl.set_startup_hook
set_pre_input_hook = rl.set_pre_input_hook
set_completer = rl.set_completer
get_begidx = rl.get_begidx
get_endidx = rl.get_endidx
set_completer_delims = rl.set_completer_delims
get_completer_delims = rl.get_completer_delims
add_history = rl.add_history

if __name__ == '__main__':
  res = [ rl.readline('In[%d] ' % i) for i in range(3) ]
  print res
else:
  Console.install_readline(rl.readline)
    
</t>
<t tx="ekr.20050704164036.77">''' an attempt to implement readline for Python in Python using ctypes'''

import string
import math
import sys
from glob import glob
import os
import re
import traceback
import operator

import win32con as c32

import Console
from Console import log
from keysyms import key_text_to_keyinfo
from ctypes import cdll, c_int, WinError, addressof
from _ctypes import call_function
import sys

</t>
<t tx="ekr.20050704164036.78">def quote_char(c):
  if ' ' &lt;= c &lt;= '~':
    return c
  else:
    return repr(c)[1:-1]
</t>
<t tx="ekr.20050704164036.79">  
class Readline:
	@others
</t>
<t tx="ekr.20050704164036.80">def __init__(self):
  self.startup_hook = None
  self.pre_input_hook = None
  self.completer = None
  self.completer_delims = " \t\n\"\\'`@$&gt;&lt;=;|&amp;{("
  self.history_length = -1
  self.history = [] # strings for previous commands
  self.history_cursor = 0
  self.undo_stack = [] # each entry is a tuple with cursor_position and line_text
  self.line_buffer = []
  self.line_cursor = 0
  self.console = Console.Console()
  self.size = self.console.size()
  self.prompt_color = None
  self.command_color = None
  self.key_dispatch = {}
  self.previous_func = None
  self.first_prompt = True
  self.next_meta = False # True to force meta on next character

  self.emacs_editing_mode(None)
  self.begidx = 0
  self.endidx = 0

  # variables you can control with parse_and_bind
  self.show_all_if_ambiguous = 'off'
  self.mark_directories = 'on'
  self.bell_style = 'none'
</t>
<t tx="ekr.20050704164036.81">def _bell(self):
  '''ring the bell if requested.'''
  if self.bell_style == 'none':
    self.console.bell()
</t>
<t tx="ekr.20050704164036.82">def _quoted_text(self):
  quoted = [ quote_char(c) for c in self.line_buffer ]
  self.line_char_width = [ len(c) for c in quoted ]
  return ''.join(quoted)
</t>
<t tx="ekr.20050704164036.83">def _line_text(self):
  return ''.join(self.line_buffer)
</t>
<t tx="ekr.20050704164036.84">def _set_line(self, text, cursor=None):
  self.line_buffer = [ c for c in str(text) ]
  if cursor is None:
    self.line_cursor = len(self.line_buffer)
  else:
    self.line_cursor = cursor
</t>
<t tx="ekr.20050704164036.85">def _reset_line(self):
  self.line_buffer = []
  self.line_cursor = 0
  self.undo_stack = []
</t>
<t tx="ekr.20050704164036.86">def _clear_after(self):
  c = self.console
  x, y = c.pos()
  w, h = c.size()
  c.rectangle((x, y, w, y+1))
  c.rectangle((0, y+1, w, h))
</t>
<t tx="ekr.20050704164036.87">def _set_cursor(self):
  c = self.console
  xc, yc = self.prompt_end_pos
  w, h = c.size()
  xc += reduce(operator.add, self.line_char_width[0:self.line_cursor], 0)
  while(xc &gt; w):
    xc -= w
    yc += 1
  c.pos(xc, yc)
</t>
<t tx="ekr.20050704164036.88">def _print_prompt(self):
  c = self.console
  log('prompt="%s"' % repr(self.prompt))
  x, y = c.pos()
  n = c.write_scrolling(self.prompt, self.prompt_color)
  self.prompt_begin_pos = (x, y - n)
  self.prompt_end_pos = c.pos()
  self.size = c.size()
</t>
<t tx="ekr.20050704164036.89">def _update_prompt_pos(self, n):
  if n != 0:
    bx, by = self.prompt_begin_pos
    ex, ey = self.prompt_end_pos
    self.prompt_begin_pos = (bx, by - n)
    self.prompt_end_pos = (ex, ey - n)
</t>
<t tx="ekr.20050704164036.90">def readline(self, prompt=''):
  '''Try to act like GNU readline.'''

  # handle startup_hook
  if self.first_prompt:
    self.first_prompt = False
    if self.startup_hook:
      try:
        self.startup_hook()
      except:
        print 'startup hook failed'
        traceback.print_exc()
        
  c = self.console
  self._reset_line()
  self.prompt = prompt
  self._print_prompt()

  if self.pre_input_hook:
    try:
      self.pre_input_hook()
    except:
      print 'pre_input_hook failed'
      traceback.print_exc()
      self.pre_input_hook = None

  inputHookPtr = c_int.from_address(addressof(cdll.python22.PyOS_InputHook)).value
  while 1:      
    c.pos(*self.prompt_end_pos)
    ltext = self._quoted_text()
    n = c.write_scrolling(ltext, self.command_color)
    self._update_prompt_pos(n)
    self._clear_after()
    self._set_cursor()

    inputHookFunc = c_int.from_address(inputHookPtr).value
    if inputHookFunc:
      call_function(inputHookFunc, ())

    event = c.getkeypress()
    if self.next_meta:
      self.next_meta = False
      control, meta, shift, code = event.keyinfo
      event.keyinfo = (control, True, shift, code)
      
    try:
      dispatch_func = self.key_dispatch[event.keyinfo]
    except KeyError:
      c.bell()
      continue
    r = None
    if dispatch_func:
      r = dispatch_func(event)
      ltext = self._line_text()
      if self.undo_stack and ltext == self.undo_stack[-1][1]:
        self.undo_stack[-1][0] = self.line_cursor
      else:
        self.undo_stack.append([self.line_cursor, ltext])

    self.previous_func = dispatch_func
    if r:
      break
    
  c.write('\r\n')

  rtext = self._line_text()
  self.add_history(rtext)
    
  log('returning(%s)' % rtext)
  return rtext + '\n'
</t>
<t tx="ekr.20050704164036.91">def parse_and_bind(self, string):
  '''Parse and execute single line of a readline init file.'''
  try:
    log('parse_and_bind("%s")' % string)
    if string.startswith('#'):
      return
    if string.startswith('set'):
      m = re.compile(r'set\s+([-a-zA-Z0-9]+)\s+(.+)\s*$').match(string)
      if m:
        var_name = m.group(1)
        val = m.group(2)
        try:
          setattr(self, var_name.replace('-','_'), val)
        except AttributeError:
          log('unknown var="%s" val="%s"' % (var_name, val))
      else:
        log('bad set "%s"' % string)
      return
    log('before')
    m = re.compile(r'\s*(.+)\s*:\s*([-a-zA-Z]+)\s*$').match(string)
    log('here')
    if m:
      key = m.group(1)
      func_name = m.group(2)
      py_name = func_name.replace('-', '_')
      try:
        func = getattr(self, py_name)
      except AttributeError:
        log('unknown func key="%s" func="%s"' % (key, func_name))
        print 'unknown function to bind: "%s"' % func_name
      self._bind_key(key, func)
  except:
    log('error')
    traceback.print_exc()
    raise
  log('return')
</t>
<t tx="ekr.20050704164036.92">def get_line_buffer(self):
  '''Return the current contents of the line buffer.'''
  return "".join(self.line_buffer)
</t>
<t tx="ekr.20050704164036.93">def insert_text(self, string):
  '''Insert text into the command line.'''
  for c in string:
    self.line_buffer.insert(self.line_cursor, c)
    self.line_cursor += 1
</t>
<t tx="ekr.20050704164036.94">def read_init_file(self, filename=None): 
  '''Parse a readline initialization file. The default filename is the last filename used.'''
  log('read_init_file("%s")' % filename)
</t>
<t tx="ekr.20050704164036.95">def read_history_file(self, filename='~/.history'): 
  '''Load a readline history file. The default filename is ~/.history.'''
  try:
    for line in open(filename, 'rt'):
      self.add_history(line.rstrip())
  except IOError:
    self.history = []
    self.history_cursor = 0
    raise IOError
</t>
<t tx="ekr.20050704164036.96">def write_history_file(self, filename='~/.history'): 
  '''Save a readline history file. The default filename is ~/.history.'''
  fp = open(filename, 'wt')
  for line in self.history:
    print &gt;&gt;fp, line
  fp.close()
</t>
<t tx="ekr.20050704164036.97">def get_history_length(self, ):
  '''Return the desired length of the history file.

  Negative values imply unlimited history file size.'''
  return self.history_length
</t>
<t tx="ekr.20050704164036.98">def set_history_length(self, length): 
  '''Set the number of lines to save in the history file.

  write_history_file() uses this value to truncate the history file
  when saving. Negative values imply unlimited history file size.
  '''
  self.history_length = length
</t>
<t tx="ekr.20050704164036.99">def set_startup_hook(self, function=None): 
  '''Set or remove the startup_hook function.

  If function is specified, it will be used as the new startup_hook
  function; if omitted or None, any hook function already installed is
  removed. The startup_hook function is called with no arguments just
  before readline prints the first prompt.

  '''
  self.startup_hook = function
</t>
<t tx="ekr.20050704164036.100">def set_pre_input_hook(self, function=None):
  '''Set or remove the pre_input_hook function.

  If function is specified, it will be used as the new pre_input_hook
  function; if omitted or None, any hook function already installed is
  removed. The pre_input_hook function is called with no arguments
  after the first prompt has been printed and just before readline
  starts reading input characters.

  '''
  self.pre_input_hook = function
</t>
<t tx="ekr.20050704164036.101">def set_completer(self, function=None): 
  '''Set or remove the completer function.

  If function is specified, it will be used as the new completer
  function; if omitted or None, any completer function already
  installed is removed. The completer function is called as
  function(text, state), for state in 0, 1, 2, ..., until it returns a
  non-string value. It should return the next possible completion
  starting with text.
  '''
  log('set_completer')
  self.completer = function
</t>
<t tx="ekr.20050704164036.102">def get_begidx(self):
  '''Get the beginning index of the readline tab-completion scope.'''
  return self.begidx
</t>
<t tx="ekr.20050704164036.103">def get_endidx(self):
  '''Get the ending index of the readline tab-completion scope.'''
  return self.endidx
</t>
<t tx="ekr.20050704164036.104">def set_completer_delims(self, string):
  '''Set the readline word delimiters for tab-completion.'''
  self.completer_delims = string
</t>
<t tx="ekr.20050704164036.105">def get_completer_delims(self):
  '''Get the readline word delimiters for tab-completion.'''
  return self.completer_delims
</t>
<t tx="ekr.20050704164036.106">def add_history(self, line):
  '''Append a line to the history buffer, as if it was the last line typed.'''
  if not line:
    return
  if len(self.history) &gt; 0 and self.history[-1] == line:
    return
  self.history.append(line)
  self.history_cursor = len(self.history)
  if self.history_length &gt; 0 and len(self.history) &gt; self.history_length:
    self.history = self.history[-self.history_length:]
</t>
<t tx="ekr.20050704164036.107">### Methods below here are bindable functions

def beginning_of_line(self, e): # (C-a)
  '''Move to the start of the current line. '''
  self.line_cursor = 0
</t>
<t tx="ekr.20050704164036.108">def end_of_line(self, e): # (C-e)
  '''Move to the end of the line. '''
  self.line_cursor = len(self.line_buffer)
</t>
<t tx="ekr.20050704164036.109">def forward_char(self, e): # (C-f)
  '''Move forward a character. '''
  if self.line_cursor &lt; len(self.line_buffer):
    self.line_cursor += 1
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.110">def backward_char(self, e): # (C-b)
  '''Move back a character. '''
  if self.line_cursor &gt; 0:
    self.line_cursor -= 1
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.111">def forward_word(self, e): # (M-f)
  '''Move forward to the end of the next word. Words are composed of
  letters and digits.'''
  L = len(self.line_buffer)
  while self.line_cursor &lt; L:
    self.line_cursor += 1
    if self.line_cursor == L:
      break
    if self.line_buffer[self.line_cursor] not in string.letters + string.digits:
      break
</t>
<t tx="ekr.20050704164036.112">def backward_word(self, e): # (M-b)
  '''Move back to the start of the current or previous word. Words are
  composed of letters and digits.'''
  while self.line_cursor &gt; 0:
    self.line_cursor -= 1
    if self.line_buffer[self.line_cursor] not in string.letters + string.digits:
      break
</t>
<t tx="ekr.20050704164036.113">def clear_screen(self, e): # (C-l)
  '''Clear the screen and redraw the current line, leaving the current
  line at the top of the screen.'''
  self.console.page()
</t>
<t tx="ekr.20050704164036.114">def redraw_current_line(self, e): # ()
  '''Refresh the current line. By default, this is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.115">def accept_line(self, e): # (Newline or Return)
  '''Accept the line regardless of where the cursor is. If this line
  is non-empty, it may be added to the history list for future recall
  with add_history(). If this line is a modified history line, the
  history line is restored to its original state.'''
  return True
</t>
<t tx="ekr.20050704164036.116">def previous_history(self, e): # (C-p)
  '''Move back through the history list, fetching the previous command. '''
  if self.history_cursor &gt; 0:
    self.history_cursor -= 1
    line = self.history[self.history_cursor]
    self._set_line(line)
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.117">def next_history(self, e): # (C-n)
  '''Move forward through the history list, fetching the next command. '''
  if self.history_cursor &lt; len(self.history) - 1:
    self.history_cursor += 1
    line = self.history[self.history_cursor]
    self._set_line(line)
  elif self.undo_stack:
    cursor, text = self.undo_stack[-1]
    self._set_line(text, cursor)
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.118">def beginning_of_history(self, e): # (M-&lt;)
  '''Move to the first line in the history.'''
  self.history_cursor = 0
  if len(self.history) &gt; 0:
    self._set_line(self.history[0])
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.119">def end_of_history(self, e): # (M-&gt;)
  '''Move to the end of the input history, i.e., the line currently
  being entered.'''
  if self.undo_stack:
    cursor, text = self.undo_stack[-1]
    self._set_line(text, cursor)
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.120">def _i_search(self, direction, init_event):
  c = self.console
  line = self._line_text()
  query = ''
  hc_start = self.history_cursor + direction
  hc = hc_start
  while 1:
    x, y = self.prompt_end_pos
    c.pos(0, y)
    if direction &lt; 0:
      prompt = 'reverse-i-search'
    else:
      prompt = 'forward-i-search'
      
    scroll = c.write_scrolling("%s`%s': %s" % (prompt, query, line))
    self._update_prompt_pos(scroll)
    self._clear_after()

    event = c.getkeypress()
    if event.keysym == 'BackSpace':
      if len(query) &gt; 0:
        query = query[:-1]
        hc = hc_start
      else:
        c.bell()
    elif event.char in string.letters + string.digits + string.punctuation + ' ':
      query += event.char
      hc = hc_start
    elif event.keyinfo == init_event.keyinfo:
      hc += direction
    else:
      if event.keysym != 'Return':
        c.bell()
      break

    while (direction &lt; 0 and hc &gt;= 0) or (direction &gt; 0 and hc &lt; len(self.history)):
      if self.history[hc].find(query) &gt;= 0:
        break
      hc += direction
    else:
      c.bell()
      continue
    line = self.history[hc]
    
  px, py = self.prompt_begin_pos
  c.pos(0, py)
  self._set_line(line)
  self._print_prompt()
</t>
<t tx="ekr.20050704164036.121">def reverse_search_history(self, e): # (C-r)
  '''Search backward starting at the current line and moving up
  through the history as necessary. This is an incremental search.'''
  self._i_search(-1, e)
</t>
<t tx="ekr.20050704164036.122">def forward_search_history(self, e): # (C-s)
  '''Search forward starting at the current line and moving down
  through the the history as necessary. This is an incremental search.'''
  self._i_search(1, e)
</t>
<t tx="ekr.20050704164036.123">def _non_i_search(self, direction):
  c = self.console
  line = self._line_text()
  query = ''
  while 1:
    c.pos(*self.prompt_end_pos)
    scroll = c.write_scrolling(":%s" % query)
    self._update_prompt_pos(scroll)
    self._clear_after()

    event = c.getkeypress()
    if event.keysym == 'BackSpace':
      if len(query) &gt; 0:
        query = query[:-1]
      else:
        break
    elif event.char in string.letters + string.digits + string.punctuation + ' ':
      query += event.char
    elif event.keysym == 'Return':
      break
    else:
      c.bell()

  if query:
    hc = self.history_cursor - 1
    while (direction &lt; 0 and hc &gt;= 0) or (direction &gt; 0 and hc &lt; len(self.history)):
      if self.history[hc].find(query) &gt;= 0:
        self._set_line(self.history[hc])
        self.history_cursor = hc
        return
      hc += direction
    else:
      c.bell()
</t>
<t tx="ekr.20050704164036.124">def non_incremental_reverse_search_history(self, e): # (M-p)
  '''Search backward starting at the current line and moving up
  through the history as necessary using a non-incremental search for
  a string supplied by the user.'''
  self._non_i_search(-1)
</t>
<t tx="ekr.20050704164036.125">def non_incremental_forward_search_history(self, e): # (M-n)
  '''Search forward starting at the current line and moving down
  through the the history as necessary using a non-incremental search
  for a string supplied by the user.'''
  self._non_i_search(1)
</t>
<t tx="ekr.20050704164036.126">def _search(self, direction):
  c = self.console
  if (self.previous_func != self.history_search_forward and
      self.previous_func != self.history_search_backward):
    self.query = ''.join(self.line_buffer[0:self.line_cursor])
  hc = self.history_cursor + direction
  while (direction &lt; 0 and hc &gt;= 0) or (direction &gt; 0 and hc &lt; len(self.history)):
    if not self.query:
      self._set_line(self.history[hc])
      self.history_cursor = hc
      return
    elif self.history[hc].startswith(self.query):
      self._set_line(self.history[hc], len(self.query))
      self.history_cursor = hc
      return
    hc += direction
  else:
    self._set_line(self.query)
    c.bell()
</t>
<t tx="ekr.20050704164036.127">def history_search_forward(self, e): # ()
  '''Search forward through the history for the string of characters
  between the start of the current line and the point. This is a
  non-incremental search. By default, this command is unbound.'''
  self._search(1)
</t>
<t tx="ekr.20050704164036.128">def history_search_backward(self, e): # ()
  '''Search backward through the history for the string of characters
  between the start of the current line and the point. This is a
  non-incremental search. By default, this command is unbound.'''
  self._search(-1)
</t>
<t tx="ekr.20050704164036.129">def yank_nth_arg(self, e): # (M-C-y)
  '''Insert the first argument to the previous command (usually the
  second word on the previous line) at point. With an argument n,
  insert the nth word from the previous command (the words in the
  previous command begin with word 0). A negative argument inserts the
  nth word from the end of the previous command.'''
  pass
</t>
<t tx="ekr.20050704164036.130">def yank_last_arg(self, e): # (M-. or M-_)
  '''Insert last argument to the previous command (the last word of
  the previous history entry). With an argument, behave exactly like
  yank-nth-arg. Successive calls to yank-last-arg move back through
  the history list, inserting the last argument of each line in turn.'''
  pass
</t>
<t tx="ekr.20050704164036.131">def delete_char(self, e): # (C-d)
  '''Delete the character at point. If point is at the beginning of
  the line, there are no characters in the line, and the last
  character typed was not bound to delete-char, then return EOF.'''
  if len(self.line_buffer) == 0:
    if self.previous_func != self.delete_char:
      raise EOFError
    self._bell()
  if self.line_cursor &lt; len(self.line_buffer):
    del self.line_buffer[self.line_cursor]
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.132">def backward_delete_char(self, e): # (Rubout)
  '''Delete the character behind the cursor. A numeric argument means
  to kill the characters instead of deleting them.'''
  if self.line_cursor &gt; 0:
    del self.line_buffer[self.line_cursor-1]
    self.line_cursor -= 1
</t>
<t tx="ekr.20050704164036.133">def forward_backward_delete_char(self, e): # ()
  '''Delete the character under the cursor, unless the cursor is at
  the end of the line, in which case the character behind the cursor
  is deleted. By default, this is not bound to a key.'''
  pass
</t>
<t tx="ekr.20050704164036.134">def quoted_insert(self, e): # (C-q or C-v)
  '''Add the next character typed to the line verbatim. This is how to
  insert key sequences like C-q, for example.'''
  e = self.console.getkeypress()
  self.line_buffer.insert(self.line_cursor, e.char)
  self.line_cursor += 1
</t>
<t tx="ekr.20050704164036.135">def tab_insert(self, e): # (M-TAB)
  '''Insert a tab character. '''
  pass
</t>
<t tx="ekr.20050704164036.136">def self_insert(self, e): # (a, b, A, 1, !, ...)
  '''Insert yourself. '''
  self.line_buffer.insert(self.line_cursor, e.char)
  self.line_cursor += 1
</t>
<t tx="ekr.20050704164036.137">def transpose_chars(self, e): # (C-t)
  '''Drag the character before the cursor forward over the character
  at the cursor, moving the cursor forward as well. If the insertion
  point is at the end of the line, then this transposes the last two
  characters of the line. Negative arguments have no effect.'''
  pass
</t>
<t tx="ekr.20050704164036.138">def transpose_words(self, e): # (M-t)
  '''Drag the word before point past the word after point, moving
  point past that word as well. If the insertion point is at the end
  of the line, this transposes the last two words on the line.'''
  pass
</t>
<t tx="ekr.20050704164036.139">def upcase_word(self, e): # (M-u)
  '''Uppercase the current (or following) word. With a negative
  argument, uppercase the previous word, but do not move the cursor.'''
  pass
</t>
<t tx="ekr.20050704164036.140">def downcase_word(self, e): # (M-l)
  '''Lowercase the current (or following) word. With a negative
  argument, lowercase the previous word, but do not move the cursor.'''
  pass
</t>
<t tx="ekr.20050704164036.141">def capitalize_word(self, e): # (M-c)
  '''Capitalize the current (or following) word. With a negative
  argument, capitalize the previous word, but do not move the cursor.'''
  pass
</t>
<t tx="ekr.20050704164036.142">def overwrite_mode(self, e): # ()
  '''Toggle overwrite mode. With an explicit positive numeric
  argument, switches to overwrite mode. With an explicit non-positive
  numeric argument, switches to insert mode. This command affects only
  emacs mode; vi mode does overwrite differently. Each call to
  readline() starts in insert mode. In overwrite mode, characters
  bound to self-insert replace the text at point rather than pushing
  the text to the right. Characters bound to backward-delete-char
  replace the character before point with a space.'''
  pass
</t>
<t tx="ekr.20050704164036.143">def kill_line(self, e): # (C-k)
  '''Kill the text from point to the end of the line. '''
  self.line_buffer[self.line_cursor:] = []
</t>
<t tx="ekr.20050704164036.144">def backward_kill_line(self, e): # (C-x Rubout)
  '''Kill backward to the beginning of the line. '''
  self.line_buffer[:self.line_cursor] = []
  self.line_cursor = 0
</t>
<t tx="ekr.20050704164036.145">def unix_line_discard(self, e): # (C-u)
  '''Kill backward from the cursor to the beginning of the current line. '''
  # how is this different from backward_kill_line?
  self.line_buffer[:self.line_cursor] = []
  self.line_cursor = 0
</t>
<t tx="ekr.20050704164036.146">def kill_whole_line(self, e): # ()
  '''Kill all characters on the current line, no matter where point
  is. By default, this is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.147">def kill_word(self, e): # (M-d)
  '''Kill from point to the end of the current word, or if between
  words, to the end of the next word. Word boundaries are the same as
  forward-word.'''
  begin = self.line_cursor
  self.forward_word(e)
  self.line_buffer[begin:self.line_cursor] = []
  self.line_cursor = begin
</t>
<t tx="ekr.20050704164036.148">def backward_kill_word(self, e): # (M-DEL)
  '''Kill the word behind point. Word boundaries are the same as
  backward-word. '''
  begin = self.line_cursor
  self.backward_word(e)
  self.line_buffer[self.line_cursor:begin] = []
</t>
<t tx="ekr.20050704164036.149">def unix_word_rubout(self, e): # (C-w)
  '''Kill the word behind point, using white space as a word
  boundary. The killed text is saved on the kill-ring.'''
  begin = self.line_cursor
  while self.line_cursor &gt; 0:
    self.line_cursor -= 1
    if self.line_buffer[self.line_cursor] == ' ':
      break
  self.line_buffer[self.line_cursor:begin] = []
</t>
<t tx="ekr.20050704164036.150">def delete_horizontal_space(self, e): # ()
  '''Delete all spaces and tabs around point. By default, this is unbound. '''
  pass
</t>
<t tx="ekr.20050704164036.151">def kill_region(self, e): # ()
  '''Kill the text in the current region. By default, this command is unbound. '''
  pass
</t>
<t tx="ekr.20050704164036.152">def copy_region_as_kill(self, e): # ()
  '''Copy the text in the region to the kill buffer, so it can be
  yanked right away. By default, this command is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.153">def copy_backward_word(self, e): # ()
  '''Copy the word before point to the kill buffer. The word
  boundaries are the same as backward-word. By default, this command
  is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.154">def copy_forward_word(self, e): # ()
  '''Copy the word following point to the kill buffer. The word
  boundaries are the same as forward-word. By default, this command is
  unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.155">def yank(self, e): # (C-y)
  '''Yank the top of the kill ring into the buffer at point. '''
  pass
</t>
<t tx="ekr.20050704164036.156">def yank_pop(self, e): # (M-y)
  '''Rotate the kill-ring, and yank the new top. You can only do this
  if the prior command is yank or yank-pop.'''
  pass
</t>
<t tx="ekr.20050704164036.157">def digit_argument(self, e): # (M-0, M-1, ... M--)
  '''Add this digit to the argument already accumulating, or start a
  new argument. M-- starts a negative argument.'''
  pass
</t>
<t tx="ekr.20050704164036.158">def universal_argument(self, e): # ()
  '''This is another way to specify an argument. If this command is
  followed by one or more digits, optionally with a leading minus
  sign, those digits define the argument. If the command is followed
  by digits, executing universal-argument again ends the numeric
  argument, but is otherwise ignored. As a special case, if this
  command is immediately followed by a character that is neither a
  digit or minus sign, the argument count for the next command is
  multiplied by four. The argument count is initially one, so
  executing this function the first time makes the argument count
  four, a second time makes the argument count sixteen, and so on. By
  default, this is not bound to a key.'''
  pass
</t>
<t tx="ekr.20050704164036.159">def _get_completions(self):
  '''Return a list of possible completions for the string ending at the point.

  Also set begidx and endidx in the process.'''
  completions = []
  self.begidx = self.line_cursor
  self.endidx = self.line_cursor
  if self.completer:
    # get the string to complete
    while self.begidx &gt; 0:
      self.begidx -= 1
      if self.line_buffer[self.begidx] in self.completer_delims:
        self.begidx += 1
        break
    text = ''.join(self.line_buffer[self.begidx:self.endidx])
    log('complete text="%s"' % text)
    i = 0
    while 1:
      try:
        r = self.completer(text, i)
      except:
        break
      i += 1
      if r and r not in completions:
        completions.append(r)
      else:
        break
    log('text completions=%s' % completions)
  if not completions:
    # get the filename to complete
    while self.begidx &gt; 0:
      self.begidx -= 1
      if self.line_buffer[self.begidx] in ' \t\n':
        self.begidx += 1
        break
    text = ''.join(self.line_buffer[self.begidx:self.endidx])
    log('file complete text="%s"' % text)
    completions = glob(os.path.expanduser(text) + '*')
    if self.mark_directories == 'on':
      mc = []
      for f in completions:
        if os.path.isdir(f):
          mc.append(f + os.sep)
        else:
          mc.append(f)
      completions = mc
    log('fnames=%s' % completions)
  return completions
</t>
<t tx="ekr.20050704164036.160">def _display_completions(self, completions):
  if not completions:
    return
  self.console.write('\n')
  wmax = max(map(len, completions))
  w, h = self.console.size()
  cols = max(1, int((w-1) / (wmax+1)))
  rows = int(math.ceil(float(len(completions)) / cols))
  for row in range(rows):
    s = ''
    for col in range(cols):
      i = col*rows + row
      if i &lt; len(completions):
        self.console.write(completions[i].ljust(wmax+1))
    self.console.write('\n')
  self._print_prompt()
</t>
<t tx="ekr.20050704164036.161">def complete(self, e): # (TAB)
  '''Attempt to perform completion on the text before point. The
  actual completion performed is application-specific. The default is
  filename completion.'''
  completions = self._get_completions()
  if completions:
    cprefix = commonprefix(completions)
    rep = [ c for c in cprefix ]
    self.line_buffer[self.begidx:self.endidx] = rep
    self.line_cursor += len(rep) - (self.endidx - self.begidx)
    if len(completions) &gt; 1:
      if self.show_all_if_ambiguous == 'on':
        self._display_completions(completions)
      else:
        self._bell()
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.162">def possible_completions(self, e): # (M-?)
  '''List the possible completions of the text before point. '''
  completions = self._get_completions()
  self._display_completions(completions)
</t>
<t tx="ekr.20050704164036.163">def insert_completions(self, e): # (M-*)
  '''Insert all completions of the text before point that would have
  been generated by possible-completions.'''
  completions = self._get_completions()
  b = self.begidx
  e = self.endidx
  for comp in completions:
    rep = [ c for c in comp ]
    rep.append(' ')
    self.line_buffer[b:e] = rep
    b += len(rep)
    e = b
  self.line_cursor = b      
</t>
<t tx="ekr.20050704164036.164">def menu_complete(self, e): # ()
  '''Similar to complete, but replaces the word to be completed with a
  single match from the list of possible completions. Repeated
  execution of menu-complete steps through the list of possible
  completions, inserting each match in turn. At the end of the list of
  completions, the bell is rung (subject to the setting of bell-style)
  and the original text is restored. An argument of n moves n
  positions forward in the list of matches; a negative argument may be
  used to move backward through the list. This command is intended to
  be bound to TAB, but is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.165">def delete_char_or_list(self, e): # ()
  '''Deletes the character under the cursor if not at the beginning or
  end of the line (like delete-char). If at the end of the line,
  behaves identically to possible-completions. This command is unbound
  by default.'''
  pass
</t>
<t tx="ekr.20050704164036.166">def start_kbd_macro(self, e): # (C-x ()
  '''Begin saving the characters typed into the current keyboard macro. '''
  pass
</t>
<t tx="ekr.20050704164036.167">def end_kbd_macro(self, e): # (C-x ))
  '''Stop saving the characters typed into the current keyboard macro
  and save the definition.'''
  pass
</t>
<t tx="ekr.20050704164036.168">def call_last_kbd_macro(self, e): # (C-x e)
  '''Re-execute the last keyboard macro defined, by making the
  characters in the macro appear as if typed at the keyboard.'''
  pass
</t>
<t tx="ekr.20050704164036.169">def re_read_init_file(self, e): # (C-x C-r)
  '''Read in the contents of the inputrc file, and incorporate any
  bindings or variable assignments found there.'''
  pass
</t>
<t tx="ekr.20050704164036.170">def abort(self, e): # (C-g)
  '''Abort the current editing command and ring the terminals bell
     (subject to the setting of bell-style).'''
  self._bell()
</t>
<t tx="ekr.20050704164036.171">def do_uppercase_version(self, e): # (M-a, M-b, M-x, ...)
  '''If the metafied character x is lowercase, run the command that is
  bound to the corresponding uppercase character.'''
  pass
</t>
<t tx="ekr.20050704164036.172">def prefix_meta(self, e): # (ESC)
  '''Metafy the next character typed. This is for keyboards without a
  meta key. Typing ESC f is equivalent to typing M-f. '''
  self.next_meta = True
</t>
<t tx="ekr.20050704164036.173">def undo(self, e): # (C-_ or C-x C-u)
  '''Incremental undo, separately remembered for each line.'''
  log(self.undo_stack)
  if len(self.undo_stack) &gt;= 2:
    self.undo_stack.pop()
    cursor, text = self.undo_stack.pop()
  else:
    cursor = 0
    text = ''
    self.undo_stack = []
  self._set_line(text, cursor)
</t>
<t tx="ekr.20050704164036.174">def revert_line(self, e): # (M-r)
  '''Undo all changes made to this line. This is like executing the
  undo command enough times to get back to the beginning.'''
  pass
</t>
<t tx="ekr.20050704164036.175">def tilde_expand(self, e): # (M-~)
  '''Perform tilde expansion on the current word.'''
  pass
</t>
<t tx="ekr.20050704164036.176">def set_mark(self, e): # (C-@)
  '''Set the mark to the point. If a numeric argument is supplied, the
  mark is set to that position.'''
  pass
</t>
<t tx="ekr.20050704164036.177">def exchange_point_and_mark(self, e): # (C-x C-x)
  '''Swap the point with the mark. The current cursor position is set
  to the saved position, and the old cursor position is saved as the
  mark.'''
  pass
</t>
<t tx="ekr.20050704164036.178">def character_search(self, e): # (C-])
  '''A character is read and point is moved to the next occurrence of
  that character. A negative count searches for previous occurrences.'''
  pass
</t>
<t tx="ekr.20050704164036.179">def character_search_backward(self, e): # (M-C-])
  '''A character is read and point is moved to the previous occurrence
  of that character. A negative count searches for subsequent
  occurrences.'''
  pass
</t>
<t tx="ekr.20050704164036.180">def insert_comment(self, e): # (M-#)
  '''Without a numeric argument, the value of the comment-begin
  variable is inserted at the beginning of the current line. If a
  numeric argument is supplied, this command acts as a toggle: if the
  characters at the beginning of the line do not match the value of
  comment-begin, the value is inserted, otherwise the characters in
  comment-begin are deleted from the beginning of the line. In either
  case, the line is accepted as if a newline had been typed.'''
  pass
</t>
<t tx="ekr.20050704164036.181">def dump_functions(self, e): # ()
  '''Print all of the functions and their key bindings to the Readline
  output stream. If a numeric argument is supplied, the output is
  formatted in such a way that it can be made part of an inputrc
  file. This command is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.182">def dump_variables(self, e): # ()
  '''Print all of the settable variables and their values to the
  Readline output stream. If a numeric argument is supplied, the
  output is formatted in such a way that it can be made part of an
  inputrc file. This command is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.183">def dump_macros(self, e): # ()
  '''Print all of the Readline key sequences bound to macros and the
  strings they output. If a numeric argument is supplied, the output
  is formatted in such a way that it can be made part of an inputrc
  file. This command is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.184">def _bind_key(self, key, func):
  '''setup the mapping from key to call the function.'''
  keyinfo = key_text_to_keyinfo(key)
  self.key_dispatch[keyinfo] = func
</t>
<t tx="ekr.20050704164036.185">def emacs_editing_mode(self, e): # (C-e)
  '''When in vi command mode, this causes a switch to emacs editing
  mode.'''
  # make ' ' to ~ self insert
  for c in range(ord(' '), 127):
    self._bind_key('"%s"' % chr(c), self.self_insert)
  # I often accidentally hold the shift or control while typing space
  self._bind_key('Shift-space', self.self_insert)
  self._bind_key('Control-space', self.self_insert)
  self._bind_key('Return', self.accept_line)
  self._bind_key('Left', self.backward_char)
  self._bind_key('Control-b', self.backward_char)
  self._bind_key('Right', self.forward_char)
  self._bind_key('Control-f', self.forward_char)
  self._bind_key('BackSpace', self.backward_delete_char)
  self._bind_key('Home', self.beginning_of_line)
  self._bind_key('End', self.end_of_line)
  self._bind_key('Delete', self.delete_char)
  self._bind_key('Control-d', self.delete_char)
  self._bind_key('Clear', self.clear_screen)
  self._bind_key('Alt-f', self.forward_word)
  self._bind_key('Alt-b', self.backward_word)
  self._bind_key('Control-l', self.clear_screen)
  self._bind_key('Control-p', self.previous_history)
  self._bind_key('Up', self.history_search_backward)
  self._bind_key('Control-n', self.next_history)
  self._bind_key('Down', self.history_search_forward)
  self._bind_key('Control-a', self.beginning_of_line)
  self._bind_key('Control-e', self.end_of_line)
  self._bind_key('Alt-&lt;', self.beginning_of_history)
  self._bind_key('Alt-&gt;', self.end_of_history)
  self._bind_key('Control-r', self.reverse_search_history)
  self._bind_key('Control-s', self.forward_search_history)
  self._bind_key('Alt-p', self.non_incremental_reverse_search_history)
  self._bind_key('Alt-n', self.non_incremental_forward_search_history)
  self._bind_key('Control-z', self.undo)
  self._bind_key('Control-_', self.undo)
  self._bind_key('Escape', self.prefix_meta)
  self._bind_key('Meta-d', self.kill_word)
  self._bind_key('Meta-Delete', self.backward_kill_word)
  self._bind_key('Control-w', self.unix_word_rubout)
  self._bind_key('Control-v', self.quoted_insert)
</t>
<t tx="ekr.20050704164036.186">def vi_editing_mode(self, e): # (M-C-j)
  '''When in emacs editing mode, this causes a switch to vi editing
  mode.'''
  pass
</t>
<t tx="ekr.20050704164036.187">def CTRL(c):
  '''make a control character'''
  assert '@' &lt;= c &lt;= '_'
  return chr(ord(c) - ord('@'))
</t>
<t tx="ekr.20050704164036.188"># make it case insensitive
def commonprefix(m):
  "Given a list of pathnames, returns the longest common leading component"
  if not m: return ''
  prefix = m[0]
  for item in m:
    for i in range(len(prefix)):
      if prefix[:i+1].lower() != item[:i+1].lower():
        prefix = prefix[:i]
        if i == 0: return ''
        break
  return prefix
</t>
<t tx="ekr.20050704164036.189"># create a Readline object to contain the state
rl = Readline()

def GetOutputFile():
  '''Return the console object used by readline so that it can be used for printing in color.'''
  return rl.console
</t>
<t tx="ekr.20050704164036.190">@language python
&lt;&lt; imports &gt;&gt;

@others

# make these available so this looks like the python readline module
parse_and_bind = rl.parse_and_bind
get_line_buffer = rl.get_line_buffer
insert_text = rl.insert_text
read_init_file = rl.read_init_file
read_history_file = rl.read_history_file
write_history_file = rl.write_history_file
get_history_length = rl.get_history_length
set_history_length = rl.set_history_length
set_startup_hook = rl.set_startup_hook
set_pre_input_hook = rl.set_pre_input_hook
set_completer = rl.set_completer
get_completer = rl.get_completer
get_begidx = rl.get_begidx
get_endidx = rl.get_endidx
set_completer_delims = rl.set_completer_delims
get_completer_delims = rl.get_completer_delims
add_history = rl.add_history

if __name__ == '__main__':
  res = [ rl.readline('In[%d] ' % i) for i in range(3) ]
  print res
else:
  #import wingdbstub
  Console.install_readline(rl.readline)</t>
<t tx="ekr.20050704164036.191">''' an attempt to implement readline for Python in Python using ctypes'''

import string
import math
import sys
from glob import glob
import os
import re
import traceback
import operator

import win32con as c32

import Console
from Console import log
from keysyms import key_text_to_keyinfo

</t>
<t tx="ekr.20050704164036.192">def quote_char(c):
  if ' ' &lt;= c &lt;= '~':
    return c
  else:
    return repr(c)[1:-1]
</t>
<t tx="ekr.20050704164036.193">class Readline:
	@others
</t>
<t tx="ekr.20050704164036.194">def __init__(self):
  self.startup_hook = None
  self.pre_input_hook = None
  self.completer = None
  self.completer_delims = " \t\n\"\\'`@$&gt;&lt;=;|&amp;{("
  self.history_length = -1
  self.history = [] # strings for previous commands
  self.history_cursor = 0
  self.undo_stack = [] # each entry is a tuple with cursor_position and line_text
  self.line_buffer = []
  self.line_cursor = 0
  self.console = Console.Console()
  self.size = self.console.size()
  self.prompt_color = None
  self.command_color = None
  self.key_dispatch = {}
  self.previous_func = None
  self.first_prompt = True
  self.next_meta = False # True to force meta on next character
  self.tabstop = 4

  self.emacs_editing_mode(None)
  self.begidx = 0
  self.endidx = 0

  # variables you can control with parse_and_bind
  self.show_all_if_ambiguous = 'off'
  self.mark_directories = 'on'
  self.bell_style = 'none'
</t>
<t tx="ekr.20050704164036.195">def _bell(self):
  '''ring the bell if requested.'''
  if self.bell_style == 'none':
    self.console.bell()
</t>
<t tx="ekr.20050704164036.196">def _quoted_text(self):
  quoted = [ quote_char(c) for c in self.line_buffer ]
  self.line_char_width = [ len(c) for c in quoted ]
  return ''.join(quoted)
</t>
<t tx="ekr.20050704164036.197">def _line_text(self):
  return ''.join(self.line_buffer)
</t>
<t tx="ekr.20050704164036.198">def _set_line(self, text, cursor=None):
  self.line_buffer = [ c for c in str(text) ]
  if cursor is None:
    self.line_cursor = len(self.line_buffer)
  else:
    self.line_cursor = cursor
</t>
<t tx="ekr.20050704164036.199">def _reset_line(self):
  self.line_buffer = []
  self.line_cursor = 0
  self.undo_stack = []
</t>
<t tx="ekr.20050704164036.200">def _clear_after(self):
  c = self.console
  x, y = c.pos()
  w, h = c.size()
  c.rectangle((x, y, w, y+1))
  c.rectangle((0, y+1, w, min(y+3,h)))
</t>
<t tx="ekr.20050704164036.201">def _set_cursor(self):
  c = self.console
  xc, yc = self.prompt_end_pos
  w, h = c.size()
  xc += reduce(operator.add, self.line_char_width[0:self.line_cursor], 0)
  while(xc &gt; w):
    xc -= w
    yc += 1
  c.pos(xc, yc)
</t>
<t tx="ekr.20050704164036.202">def _print_prompt(self):
  c = self.console
  log('prompt="%s"' % repr(self.prompt))
  x, y = c.pos()
  n = c.write_scrolling(self.prompt, self.prompt_color)
  self.prompt_begin_pos = (x, y - n)
  self.prompt_end_pos = c.pos()
  self.size = c.size()
</t>
<t tx="ekr.20050704164036.203">def _update_prompt_pos(self, n):
  if n != 0:
    bx, by = self.prompt_begin_pos
    ex, ey = self.prompt_end_pos
    self.prompt_begin_pos = (bx, by - n)
    self.prompt_end_pos = (ex, ey - n)
</t>
<t tx="ekr.20050704164036.204">def readline(self, prompt=''):
  '''Try to act like GNU readline.'''

  # handle startup_hook
  if self.first_prompt:
    self.first_prompt = False
    if self.startup_hook:
      try:
        self.startup_hook()
      except:
        print 'startup hook failed'
        traceback.print_exc()
        
  c = self.console
  self._reset_line()
  self.prompt = prompt
  self._print_prompt()

  if self.pre_input_hook:
    try:
      self.pre_input_hook()
    except:
      print 'pre_input_hook failed'
      traceback.print_exc()
      self.pre_input_hook = None

  while 1:
    c.pos(*self.prompt_end_pos)
    ltext = self._quoted_text()
    n = c.write_scrolling(ltext, self.command_color)
    self._update_prompt_pos(n)
    self._clear_after()
    self._set_cursor()

    event = c.getkeypress()
    if self.next_meta:
      self.next_meta = False
      control, meta, shift, code = event.keyinfo
      event.keyinfo = (control, True, shift, code)
      
    try:
      dispatch_func = self.key_dispatch[event.keyinfo]
    except KeyError:
      c.bell()
      continue
    r = None
    if dispatch_func:
      r = dispatch_func(event)
      ltext = self._line_text()
      if self.undo_stack and ltext == self.undo_stack[-1][1]:
        self.undo_stack[-1][0] = self.line_cursor
      else:
        self.undo_stack.append([self.line_cursor, ltext])

    self.previous_func = dispatch_func
    if r:
      break
    
  c.write('\r\n')

  rtext = self._line_text()
  self.add_history(rtext)
    
  log('returning(%s)' % rtext)
  return rtext + '\n'
</t>
<t tx="ekr.20050704164036.205">def parse_and_bind(self, string):
  '''Parse and execute single line of a readline init file.'''
  try:
    log('parse_and_bind("%s")' % string)
    if string.startswith('#'):
      return
    if string.startswith('set'):
      m = re.compile(r'set\s+([-a-zA-Z0-9]+)\s+(.+)\s*$').match(string)
      if m:
        var_name = m.group(1)
        val = m.group(2)
        try:
          setattr(self, var_name.replace('-','_'), val)
        except AttributeError:
          log('unknown var="%s" val="%s"' % (var_name, val))
      else:
        log('bad set "%s"' % string)
      return
    log('before')
    m = re.compile(r'\s*(.+)\s*:\s*([-a-zA-Z]+)\s*$').match(string)
    log('here')
    if m:
      key = m.group(1)
      func_name = m.group(2)
      py_name = func_name.replace('-', '_')
      try:
        func = getattr(self, py_name)
      except AttributeError:
        log('unknown func key="%s" func="%s"' % (key, func_name))
        print 'unknown function to bind: "%s"' % func_name
      self._bind_key(key, func)
  except:
    log('error')
    traceback.print_exc()
    raise
  log('return')
</t>
<t tx="ekr.20050704164036.206">def get_line_buffer(self):
  '''Return the current contents of the line buffer.'''
  return "".join(self.line_buffer)
</t>
<t tx="ekr.20050704164036.207">def insert_text(self, string):
  '''Insert text into the command line.'''
  for c in string:
    self.line_buffer.insert(self.line_cursor, c)
    self.line_cursor += 1
</t>
<t tx="ekr.20050704164036.208">def read_init_file(self, filename=None): 
  '''Parse a readline initialization file. The default filename is the last filename used.'''
  log('read_init_file("%s")' % filename)
</t>
<t tx="ekr.20050704164036.209">def read_history_file(self, filename='~/.history'): 
  '''Load a readline history file. The default filename is ~/.history.'''
  try:
    for line in open(filename, 'rt'):
      self.add_history(line.rstrip())
  except IOError:
    self.history = []
    self.history_cursor = 0
    raise IOError
</t>
<t tx="ekr.20050704164036.210">def write_history_file(self, filename='~/.history'): 
  '''Save a readline history file. The default filename is ~/.history.'''
  fp = open(filename, 'wb')
  for line in self.history:
    fp.write(line)
    fp.write('\n')
  fp.close()
</t>
<t tx="ekr.20050704164036.211">def get_history_length(self, ):
  '''Return the desired length of the history file.

  Negative values imply unlimited history file size.'''
  return self.history_length
</t>
<t tx="ekr.20050704164036.212">def set_history_length(self, length): 
  '''Set the number of lines to save in the history file.

  write_history_file() uses this value to truncate the history file
  when saving. Negative values imply unlimited history file size.
  '''
  self.history_length = length
</t>
<t tx="ekr.20050704164036.213">def set_startup_hook(self, function=None): 
  '''Set or remove the startup_hook function.

  If function is specified, it will be used as the new startup_hook
  function; if omitted or None, any hook function already installed is
  removed. The startup_hook function is called with no arguments just
  before readline prints the first prompt.

  '''
  self.startup_hook = function
</t>
<t tx="ekr.20050704164036.214">def set_pre_input_hook(self, function=None):
  '''Set or remove the pre_input_hook function.

  If function is specified, it will be used as the new pre_input_hook
  function; if omitted or None, any hook function already installed is
  removed. The pre_input_hook function is called with no arguments
  after the first prompt has been printed and just before readline
  starts reading input characters.

  '''
  self.pre_input_hook = function
</t>
<t tx="ekr.20050704164036.215">def set_completer(self, function=None): 
  '''Set or remove the completer function.

  If function is specified, it will be used as the new completer
  function; if omitted or None, any completer function already
  installed is removed. The completer function is called as
  function(text, state), for state in 0, 1, 2, ..., until it returns a
  non-string value. It should return the next possible completion
  starting with text.
  '''
  log('set_completer')
  self.completer = function
</t>
<t tx="ekr.20050704164036.216">def get_completer(self): 
  '''Get the completer function. 
  ''' 

  log('get_completer') 
  return self.completer 
</t>
<t tx="ekr.20050704164036.217">def get_begidx(self):
  '''Get the beginning index of the readline tab-completion scope.'''
  return self.begidx
</t>
<t tx="ekr.20050704164036.218">def get_endidx(self):
  '''Get the ending index of the readline tab-completion scope.'''
  return self.endidx
</t>
<t tx="ekr.20050704164036.219">def set_completer_delims(self, string):
  '''Set the readline word delimiters for tab-completion.'''
  self.completer_delims = string
</t>
<t tx="ekr.20050704164036.220">def get_completer_delims(self):
  '''Get the readline word delimiters for tab-completion.'''
  return self.completer_delims
</t>
<t tx="ekr.20050704164036.221">def add_history(self, line):
  '''Append a line to the history buffer, as if it was the last line typed.'''
  if not line:
    pass
  elif len(self.history) &gt; 0 and self.history[-1] == line:
    pass
  else:
    self.history.append(line)
    if self.history_length &gt; 0 and len(self.history) &gt; self.history_length:
      self.history = self.history[-self.history_length:]
  self.history_cursor = len(self.history)
</t>
<t tx="ekr.20050704164036.222">### Methods below here are bindable functions

def beginning_of_line(self, e): # (C-a)
  '''Move to the start of the current line. '''
  self.line_cursor = 0
</t>
<t tx="ekr.20050704164036.223">def end_of_line(self, e): # (C-e)
  '''Move to the end of the line. '''
  self.line_cursor = len(self.line_buffer)
</t>
<t tx="ekr.20050704164036.224">def forward_char(self, e): # (C-f)
  '''Move forward a character. '''
  if self.line_cursor &lt; len(self.line_buffer):
    self.line_cursor += 1
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.225">def backward_char(self, e): # (C-b)
  '''Move back a character. '''
  if self.line_cursor &gt; 0:
    self.line_cursor -= 1
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.226">def forward_word(self, e): # (M-f)
  '''Move forward to the end of the next word. Words are composed of
  letters and digits.'''
  L = len(self.line_buffer)
  while self.line_cursor &lt; L:
    self.line_cursor += 1
    if self.line_cursor == L:
      break
    if self.line_buffer[self.line_cursor] not in string.letters + string.digits:
      break
</t>
<t tx="ekr.20050704164036.227">def backward_word(self, e): # (M-b)
  '''Move back to the start of the current or previous word. Words are
  composed of letters and digits.'''
  while self.line_cursor &gt; 0:
    self.line_cursor -= 1
    if self.line_buffer[self.line_cursor] not in string.letters + string.digits:
      break
</t>
<t tx="ekr.20050704164036.228">def clear_screen(self, e): # (C-l)
  '''Clear the screen and redraw the current line, leaving the current
  line at the top of the screen.'''
  self.console.page()
</t>
<t tx="ekr.20050704164036.229">def redraw_current_line(self, e): # ()
  '''Refresh the current line. By default, this is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.230">def accept_line(self, e): # (Newline or Return)
  '''Accept the line regardless of where the cursor is. If this line
  is non-empty, it may be added to the history list for future recall
  with add_history(). If this line is a modified history line, the
  history line is restored to its original state.'''
  return True
</t>
<t tx="ekr.20050704164036.231">def previous_history(self, e): # (C-p)
  '''Move back through the history list, fetching the previous command. '''
  if self.history_cursor &gt; 0:
    self.history_cursor -= 1
    line = self.history[self.history_cursor]
    self._set_line(line)
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.232">def next_history(self, e): # (C-n)
  '''Move forward through the history list, fetching the next command. '''
  if self.history_cursor &lt; len(self.history) - 1:
    self.history_cursor += 1
    line = self.history[self.history_cursor]
    self._set_line(line)
  elif self.undo_stack:
    cursor, text = self.undo_stack[-1]
    self._set_line(text, cursor)
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.233">def beginning_of_history(self, e): # (M-&lt;)
  '''Move to the first line in the history.'''
  self.history_cursor = 0
  if len(self.history) &gt; 0:
    self._set_line(self.history[0])
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.234">def end_of_history(self, e): # (M-&gt;)
  '''Move to the end of the input history, i.e., the line currently
  being entered.'''
  if self.undo_stack:
    cursor, text = self.undo_stack[-1]
    self._set_line(text, cursor)
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.235">def _i_search(self, direction, init_event):
  c = self.console
  line = self._line_text()
  query = ''
  hc_start = self.history_cursor + direction
  hc = hc_start
  while 1:
    x, y = self.prompt_end_pos
    c.pos(0, y)
    if direction &lt; 0:
      prompt = 'reverse-i-search'
    else:
      prompt = 'forward-i-search'
      
    scroll = c.write_scrolling("%s`%s': %s" % (prompt, query, line))
    self._update_prompt_pos(scroll)
    self._clear_after()

    event = c.getkeypress()
    if event.keysym == 'BackSpace':
      if len(query) &gt; 0:
        query = query[:-1]
        hc = hc_start
      else:
        c.bell()
    elif event.char in string.letters + string.digits + string.punctuation + ' ':
      query += event.char
      hc = hc_start
    elif event.keyinfo == init_event.keyinfo:
      hc += direction
    else:
      if event.keysym != 'Return':
        c.bell()
      break

    while (direction &lt; 0 and hc &gt;= 0) or (direction &gt; 0 and hc &lt; len(self.history)):
      if self.history[hc].find(query) &gt;= 0:
        break
      hc += direction
    else:
      c.bell()
      continue
    line = self.history[hc]
    
  px, py = self.prompt_begin_pos
  c.pos(0, py)
  self._set_line(line)
  self._print_prompt()
</t>
<t tx="ekr.20050704164036.236">def reverse_search_history(self, e): # (C-r)
  '''Search backward starting at the current line and moving up
  through the history as necessary. This is an incremental search.'''
  self._i_search(-1, e)
</t>
<t tx="ekr.20050704164036.237">def forward_search_history(self, e): # (C-s)
  '''Search forward starting at the current line and moving down
  through the the history as necessary. This is an incremental search.'''
  self._i_search(1, e)
</t>
<t tx="ekr.20050704164036.238">def _non_i_search(self, direction):
  c = self.console
  line = self._line_text()
  query = ''
  while 1:
    c.pos(*self.prompt_end_pos)
    scroll = c.write_scrolling(":%s" % query)
    self._update_prompt_pos(scroll)
    self._clear_after()

    event = c.getkeypress()
    if event.keysym == 'BackSpace':
      if len(query) &gt; 0:
        query = query[:-1]
      else:
        break
    elif event.char in string.letters + string.digits + string.punctuation + ' ':
      query += event.char
    elif event.keysym == 'Return':
      break
    else:
      c.bell()

  if query:
    hc = self.history_cursor - 1
    while (direction &lt; 0 and hc &gt;= 0) or (direction &gt; 0 and hc &lt; len(self.history)):
      if self.history[hc].find(query) &gt;= 0:
        self._set_line(self.history[hc])
        self.history_cursor = hc
        return
      hc += direction
    else:
      c.bell()
</t>
<t tx="ekr.20050704164036.239">def non_incremental_reverse_search_history(self, e): # (M-p)
  '''Search backward starting at the current line and moving up
  through the history as necessary using a non-incremental search for
  a string supplied by the user.'''
  self._non_i_search(-1)
</t>
<t tx="ekr.20050704164036.240">def non_incremental_forward_search_history(self, e): # (M-n)
  '''Search forward starting at the current line and moving down
  through the the history as necessary using a non-incremental search
  for a string supplied by the user.'''
  self._non_i_search(1)
</t>
<t tx="ekr.20050704164036.241">def _search(self, direction):
  c = self.console

  if (self.previous_func != self.history_search_forward and
      self.previous_func != self.history_search_backward):
    self.query = ''.join(self.line_buffer[0:self.line_cursor])
  hc = self.history_cursor + direction
  while (direction &lt; 0 and hc &gt;= 0) or (direction &gt; 0 and hc &lt; len(self.history)):
    h = self.history[hc]
    if not self.query:
      self._set_line(h)
      self.history_cursor = hc
      return
    elif h.startswith(self.query) and h != self._line_text:
      self._set_line(h, len(self.query))
      self.history_cursor = hc
      return
    hc += direction
  else:
    self._set_line(self.query)
    c.bell()
</t>
<t tx="ekr.20050704164036.242">def history_search_forward(self, e): # ()
  '''Search forward through the history for the string of characters
  between the start of the current line and the point. This is a
  non-incremental search. By default, this command is unbound.'''
  self._search(1)
</t>
<t tx="ekr.20050704164036.243">def history_search_backward(self, e): # ()
  '''Search backward through the history for the string of characters
  between the start of the current line and the point. This is a
  non-incremental search. By default, this command is unbound.'''
  self._search(-1)
</t>
<t tx="ekr.20050704164036.244">def yank_nth_arg(self, e): # (M-C-y)
  '''Insert the first argument to the previous command (usually the
  second word on the previous line) at point. With an argument n,
  insert the nth word from the previous command (the words in the
  previous command begin with word 0). A negative argument inserts the
  nth word from the end of the previous command.'''
  pass
</t>
<t tx="ekr.20050704164036.245">def yank_last_arg(self, e): # (M-. or M-_)
  '''Insert last argument to the previous command (the last word of
  the previous history entry). With an argument, behave exactly like
  yank-nth-arg. Successive calls to yank-last-arg move back through
  the history list, inserting the last argument of each line in turn.'''
  pass
</t>
<t tx="ekr.20050704164036.246">def delete_char(self, e): # (C-d)
  '''Delete the character at point. If point is at the beginning of
  the line, there are no characters in the line, and the last
  character typed was not bound to delete-char, then return EOF.'''
  if len(self.line_buffer) == 0:
    if self.previous_func != self.delete_char:
      raise EOFError
    self._bell()
  if self.line_cursor &lt; len(self.line_buffer):
    del self.line_buffer[self.line_cursor]
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.247">def backward_delete_char(self, e): # (Rubout)
  '''Delete the character behind the cursor. A numeric argument means
  to kill the characters instead of deleting them.'''
  if self.line_cursor &gt; 0:
    del self.line_buffer[self.line_cursor-1]
    self.line_cursor -= 1
</t>
<t tx="ekr.20050704164036.248">def forward_backward_delete_char(self, e): # ()
  '''Delete the character under the cursor, unless the cursor is at
  the end of the line, in which case the character behind the cursor
  is deleted. By default, this is not bound to a key.'''
  pass
</t>
<t tx="ekr.20050704164036.249">def quoted_insert(self, e): # (C-q or C-v)
  '''Add the next character typed to the line verbatim. This is how to
  insert key sequences like C-q, for example.'''
  e = self.console.getkeypress()
  self.line_buffer.insert(self.line_cursor, e.char)
  self.line_cursor += 1
</t>
<t tx="ekr.20050704164036.250">def tab_insert(self, e): # (M-TAB)
  '''Insert a tab character. '''
  ws = ' ' * (self.tabstop - (self.line_cursor%self.tabstop))
  self.insert_text(ws)
</t>
<t tx="ekr.20050704164036.251">def self_insert(self, e): # (a, b, A, 1, !, ...)
  '''Insert yourself. '''
  self.line_buffer.insert(self.line_cursor, e.char)
  self.line_cursor += 1
</t>
<t tx="ekr.20050704164036.252">def transpose_chars(self, e): # (C-t)
  '''Drag the character before the cursor forward over the character
  at the cursor, moving the cursor forward as well. If the insertion
  point is at the end of the line, then this transposes the last two
  characters of the line. Negative arguments have no effect.'''
  pass
</t>
<t tx="ekr.20050704164036.253">def transpose_words(self, e): # (M-t)
  '''Drag the word before point past the word after point, moving
  point past that word as well. If the insertion point is at the end
  of the line, this transposes the last two words on the line.'''
  pass
</t>
<t tx="ekr.20050704164036.254">def upcase_word(self, e): # (M-u)
  '''Uppercase the current (or following) word. With a negative
  argument, uppercase the previous word, but do not move the cursor.'''
  pass
</t>
<t tx="ekr.20050704164036.255">def downcase_word(self, e): # (M-l)
  '''Lowercase the current (or following) word. With a negative
  argument, lowercase the previous word, but do not move the cursor.'''
  pass
</t>
<t tx="ekr.20050704164036.256">def capitalize_word(self, e): # (M-c)
  '''Capitalize the current (or following) word. With a negative
  argument, capitalize the previous word, but do not move the cursor.'''
  pass
</t>
<t tx="ekr.20050704164036.257">def overwrite_mode(self, e): # ()
  '''Toggle overwrite mode. With an explicit positive numeric
  argument, switches to overwrite mode. With an explicit non-positive
  numeric argument, switches to insert mode. This command affects only
  emacs mode; vi mode does overwrite differently. Each call to
  readline() starts in insert mode. In overwrite mode, characters
  bound to self-insert replace the text at point rather than pushing
  the text to the right. Characters bound to backward-delete-char
  replace the character before point with a space.'''
  pass
</t>
<t tx="ekr.20050704164036.258">def kill_line(self, e): # (C-k)
  '''Kill the text from point to the end of the line. '''
  self.line_buffer[self.line_cursor:] = []
</t>
<t tx="ekr.20050704164036.259">def backward_kill_line(self, e): # (C-x Rubout)
  '''Kill backward to the beginning of the line. '''
  self.line_buffer[:self.line_cursor] = []
  self.line_cursor = 0
</t>
<t tx="ekr.20050704164036.260">def unix_line_discard(self, e): # (C-u)
  '''Kill backward from the cursor to the beginning of the current line. '''
  # how is this different from backward_kill_line?
  self.line_buffer[:self.line_cursor] = []
  self.line_cursor = 0
</t>
<t tx="ekr.20050704164036.261">def kill_whole_line(self, e): # ()
  '''Kill all characters on the current line, no matter where point
  is. By default, this is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.262">def kill_word(self, e): # (M-d)
  '''Kill from point to the end of the current word, or if between
  words, to the end of the next word. Word boundaries are the same as
  forward-word.'''
  begin = self.line_cursor
  self.forward_word(e)
  self.line_buffer[begin:self.line_cursor] = []
  self.line_cursor = begin
</t>
<t tx="ekr.20050704164036.263">def backward_kill_word(self, e): # (M-DEL)
  '''Kill the word behind point. Word boundaries are the same as
  backward-word. '''
  begin = self.line_cursor
  self.backward_word(e)
  self.line_buffer[self.line_cursor:begin] = []
</t>
<t tx="ekr.20050704164036.264">def unix_word_rubout(self, e): # (C-w)
  '''Kill the word behind point, using white space as a word
  boundary. The killed text is saved on the kill-ring.'''
  begin = self.line_cursor
  while self.line_cursor &gt; 0:
    self.line_cursor -= 1
    if self.line_buffer[self.line_cursor] == ' ':
      break
  self.line_buffer[self.line_cursor:begin] = []
</t>
<t tx="ekr.20050704164036.265">def delete_horizontal_space(self, e): # ()
  '''Delete all spaces and tabs around point. By default, this is unbound. '''
  pass
</t>
<t tx="ekr.20050704164036.266">def kill_region(self, e): # ()
  '''Kill the text in the current region. By default, this command is unbound. '''
  pass
</t>
<t tx="ekr.20050704164036.267">def copy_region_as_kill(self, e): # ()
  '''Copy the text in the region to the kill buffer, so it can be
  yanked right away. By default, this command is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.268">def copy_backward_word(self, e): # ()
  '''Copy the word before point to the kill buffer. The word
  boundaries are the same as backward-word. By default, this command
  is unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.269">def copy_forward_word(self, e): # ()
  '''Copy the word following point to the kill buffer. The word
  boundaries are the same as forward-word. By default, this command is
  unbound.'''
  pass
</t>
<t tx="ekr.20050704164036.270">def yank(self, e): # (C-y)
  '''Yank the top of the kill ring into the buffer at point. '''
  pass
</t>
<t tx="ekr.20050704164036.271">def yank_pop(self, e): # (M-y)
  '''Rotate the kill-ring, and yank the new top. You can only do this
  if the prior command is yank or yank-pop.'''
  pass
</t>
<t tx="ekr.20050704164036.272">def digit_argument(self, e): # (M-0, M-1, ... M--)
  '''Add this digit to the argument already accumulating, or start a
  new argument. M-- starts a negative argument.'''
  pass
</t>
<t tx="ekr.20050704164036.273">def universal_argument(self, e): # ()
  '''This is another way to specify an argument. If this command is
  followed by one or more digits, optionally with a leading minus
  sign, those digits define the argument. If the command is followed
  by digits, executing universal-argument again ends the numeric
  argument, but is otherwise ignored. As a special case, if this
  command is immediately followed by a character that is neither a
  digit or minus sign, the argument count for the next command is
  multiplied by four. The argument count is initially one, so
  executing this function the first time makes the argument count
  four, a second time makes the argument count sixteen, and so on. By
  default, this is not bound to a key.'''
  pass
</t>
<t tx="ekr.20050704164036.274">def _get_completions(self):
  '''Return a list of possible completions for the string ending at the point.

  Also set begidx and endidx in the process.'''
  completions = []
  self.begidx = self.line_cursor
  self.endidx = self.line_cursor
  if self.completer:
    # get the string to complete
    while self.begidx &gt; 0:
      self.begidx -= 1
      if self.line_buffer[self.begidx] in self.completer_delims:
        self.begidx += 1
        break
    text = ''.join(self.line_buffer[self.begidx:self.endidx])
    log('complete text="%s"' % text)
    i = 0
    while 1:
      try:
        r = self.completer(text, i)
      except:
        break
      i += 1
      if r and r not in completions:
        completions.append(r)
      else:
        break
    log('text completions=%s' % completions)
  if not completions:
    # get the filename to complete
    while self.begidx &gt; 0:
      self.begidx -= 1
      if self.line_buffer[self.begidx] in ' \t\n':
        self.begidx += 1
        break
    text = ''.join(self.line_buffer[self.begidx:self.endidx])
    log('file complete text="%s"' % text)
    completions = glob(os.path.expanduser(text) + '*')
    if self.mark_directories == 'on':
      mc = []
      for f in completions:
        if os.path.isdir(f):
          mc.append(f + os.sep)
        else:
          mc.append(f)
      completions = mc
    log('fnames=%s' % completions)
  return completions
</t>
<t tx="ekr.20050704164036.275">def _display_completions(self, completions):
  if not completions:
    return
  self.console.write('\n')
  wmax = max(map(len, completions))
  w, h = self.console.size()
  cols = max(1, int((w-1) / (wmax+1)))
  rows = int(math.ceil(float(len(completions)) / cols))
  for row in range(rows):
    s = ''
    for col in range(cols):
      i = col*rows + row
      if i &lt; len(completions):
        self.console.write(completions[i].ljust(wmax+1))
    self.console.write('\n')
  self._print_prompt()
</t>
<t tx="ekr.20050704164036.276">def complete(self, e): # (TAB)
  '''Attempt to perform completion on the text before point. The
  actual completion performed is application-specific. The default is
  filename completion.'''
  completions = self._get_completions()
  if completions:
    cprefix = commonprefix(completions)
    rep = [ c for c in cprefix ]
    self.line_buffer[self.begidx:self.endidx] = rep
    self.line_cursor += len(rep) - (self.endidx - self.begidx)
    if len(completions) &gt; 1:
      if self.show_all_if_ambiguous == 'on':
        self._display_completions(completions)
      else:
        self._bell()
  else:
    self._bell()
</t>
<t tx="ekr.20050704164036.277">def possible_completions(self, e): # (M-?)
  '''List the possible completions of the text before point. '''
  completions = self._get_completions()
  self._display_completions(completions)
</t>
<t tx="ekr.20050704164036.278">def insert_completions(self, e): # (M-*)
  '''Insert all completions of the text before point that would have
  been generated by possible-completions.'''
  completions = self._get_completions()
  b = self.begidx
  e = self.endidx
  for comp in completions:
    rep = [ c for c in comp ]
    rep.append(' ')
    self.line_buffer[b:e] = rep
    b += len(rep)
    e = b
  self.line_cursor = b      
</t>
<t tx="ekr.20050704164036.279">def menu_complete(self, e): # ()
  '''Similar to complete, but replaces the word to be completed with a
  single match from the list of possible completions. Repeated
  execution of menu-complete steps through the list of possible
  completions, inserting each match in turn. At the end of the list of
  completions, the bell is rung (subject to the setting of bell-style)
  and the original text is restored. An argument of n moves n
  positions forward in the list of matches; a negative argument may be
  used to move backward through the list. This command is intended to
  be bound to TAB, but is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.280">def delete_char_or_list(self, e): # ()
  '''Deletes the character under the cursor if not at the beginning or
  end of the line (like delete-char). If at the end of the line,
  behaves identically to possible-completions. This command is unbound
  by default.'''
  pass
</t>
<t tx="ekr.20050704164036.281">def start_kbd_macro(self, e): # (C-x ()
  '''Begin saving the characters typed into the current keyboard macro. '''
  pass
</t>
<t tx="ekr.20050704164036.282">def end_kbd_macro(self, e): # (C-x ))
  '''Stop saving the characters typed into the current keyboard macro
  and save the definition.'''
  pass
</t>
<t tx="ekr.20050704164036.283">def call_last_kbd_macro(self, e): # (C-x e)
  '''Re-execute the last keyboard macro defined, by making the
  characters in the macro appear as if typed at the keyboard.'''
  pass
</t>
<t tx="ekr.20050704164036.284">def re_read_init_file(self, e): # (C-x C-r)
  '''Read in the contents of the inputrc file, and incorporate any
  bindings or variable assignments found there.'''
  pass
</t>
<t tx="ekr.20050704164036.285">def abort(self, e): # (C-g)
  '''Abort the current editing command and ring the terminals bell
     (subject to the setting of bell-style).'''
  self._bell()
</t>
<t tx="ekr.20050704164036.286">def do_uppercase_version(self, e): # (M-a, M-b, M-x, ...)
  '''If the metafied character x is lowercase, run the command that is
  bound to the corresponding uppercase character.'''
  pass
</t>
<t tx="ekr.20050704164036.287">def prefix_meta(self, e): # (ESC)
  '''Metafy the next character typed. This is for keyboards without a
  meta key. Typing ESC f is equivalent to typing M-f. '''
  self.next_meta = True
</t>
<t tx="ekr.20050704164036.288">def undo(self, e): # (C-_ or C-x C-u)
  '''Incremental undo, separately remembered for each line.'''
  log(self.undo_stack)
  if len(self.undo_stack) &gt;= 2:
    self.undo_stack.pop()
    cursor, text = self.undo_stack.pop()
  else:
    cursor = 0
    text = ''
    self.undo_stack = []
  self._set_line(text, cursor)
</t>
<t tx="ekr.20050704164036.289">def revert_line(self, e): # (M-r)
  '''Undo all changes made to this line. This is like executing the
  undo command enough times to get back to the beginning.'''
  pass
</t>
<t tx="ekr.20050704164036.290">def tilde_expand(self, e): # (M-~)
  '''Perform tilde expansion on the current word.'''
  pass
</t>
<t tx="ekr.20050704164036.291">def set_mark(self, e): # (C-@)
  '''Set the mark to the point. If a numeric argument is supplied, the
  mark is set to that position.'''
  pass
</t>
<t tx="ekr.20050704164036.292">def exchange_point_and_mark(self, e): # (C-x C-x)
  '''Swap the point with the mark. The current cursor position is set
  to the saved position, and the old cursor position is saved as the
  mark.'''
  pass
</t>
<t tx="ekr.20050704164036.293">def character_search(self, e): # (C-])
  '''A character is read and point is moved to the next occurrence of
  that character. A negative count searches for previous occurrences.'''
  pass
</t>
<t tx="ekr.20050704164036.294">def character_search_backward(self, e): # (M-C-])
  '''A character is read and point is moved to the previous occurrence
  of that character. A negative count searches for subsequent
  occurrences.'''
  pass
</t>
<t tx="ekr.20050704164036.295">def insert_comment(self, e): # (M-#)
  '''Without a numeric argument, the value of the comment-begin
  variable is inserted at the beginning of the current line. If a
  numeric argument is supplied, this command acts as a toggle: if the
  characters at the beginning of the line do not match the value of
  comment-begin, the value is inserted, otherwise the characters in
  comment-begin are deleted from the beginning of the line. In either
  case, the line is accepted as if a newline had been typed.'''
  pass
</t>
<t tx="ekr.20050704164036.296">def dump_functions(self, e): # ()
  '''Print all of the functions and their key bindings to the Readline
  output stream. If a numeric argument is supplied, the output is
  formatted in such a way that it can be made part of an inputrc
  file. This command is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.297">def dump_variables(self, e): # ()
  '''Print all of the settable variables and their values to the
  Readline output stream. If a numeric argument is supplied, the
  output is formatted in such a way that it can be made part of an
  inputrc file. This command is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.298">def dump_macros(self, e): # ()
  '''Print all of the Readline key sequences bound to macros and the
  strings they output. If a numeric argument is supplied, the output
  is formatted in such a way that it can be made part of an inputrc
  file. This command is unbound by default.'''
  pass
</t>
<t tx="ekr.20050704164036.299">def _bind_key(self, key, func):
  '''setup the mapping from key to call the function.'''
  keyinfo = key_text_to_keyinfo(key)
  self.key_dispatch[keyinfo] = func
</t>
<t tx="ekr.20050704164036.300">def emacs_editing_mode(self, e): # (C-e)
  '''When in vi command mode, this causes a switch to emacs editing
  mode.'''
  # make ' ' to ~ self insert
  for c in range(ord(' '), 127):
    self._bind_key('"%s"' % chr(c), self.self_insert)
  # I often accidentally hold the shift or control while typing space
  self._bind_key('Shift-space', self.self_insert)
  self._bind_key('Control-space', self.self_insert)
  self._bind_key('Return', self.accept_line)
  self._bind_key('Left', self.backward_char)
  self._bind_key('Control-b', self.backward_char)
  self._bind_key('Right', self.forward_char)
  self._bind_key('Control-f', self.forward_char)
  self._bind_key('BackSpace', self.backward_delete_char)
  self._bind_key('Home', self.beginning_of_line)
  self._bind_key('End', self.end_of_line)
  self._bind_key('Delete', self.delete_char)
  self._bind_key('Control-d', self.delete_char)
  self._bind_key('Clear', self.clear_screen)
  self._bind_key('Alt-f', self.forward_word)
  self._bind_key('Alt-b', self.backward_word)
  self._bind_key('Control-l', self.clear_screen)
  self._bind_key('Control-p', self.previous_history)
  self._bind_key('Up', self.history_search_backward)
  self._bind_key('Control-n', self.next_history)
  self._bind_key('Down', self.history_search_forward)
  self._bind_key('Control-a', self.beginning_of_line)
  self._bind_key('Control-e', self.end_of_line)
  self._bind_key('Alt-&lt;', self.beginning_of_history)
  self._bind_key('Alt-&gt;', self.end_of_history)
  self._bind_key('Control-r', self.reverse_search_history)
  self._bind_key('Control-s', self.forward_search_history)
  self._bind_key('Alt-p', self.non_incremental_reverse_search_history)
  self._bind_key('Alt-n', self.non_incremental_forward_search_history)
  self._bind_key('Control-z', self.undo)
  self._bind_key('Control-_', self.undo)
  self._bind_key('Escape', self.prefix_meta)
  self._bind_key('Meta-d', self.kill_word)
  self._bind_key('Meta-Delete', self.backward_kill_word)
  self._bind_key('Control-w', self.unix_word_rubout)
  self._bind_key('Control-v', self.quoted_insert)
  
  # Add keybindings for numpad
  # first the number keys
  self._bind_key('NUMPAD0', self.self_insert)
  self._bind_key('NUMPAD1', self.self_insert)
  self._bind_key('NUMPAD2', self.self_insert)
  self._bind_key('NUMPAD3', self.self_insert)
  self._bind_key('NUMPAD4', self.self_insert)
  self._bind_key('NUMPAD5', self.self_insert)
  self._bind_key('NUMPAD6', self.self_insert)
  self._bind_key('NUMPAD7', self.self_insert)
  self._bind_key('NUMPAD8', self.self_insert)
  self._bind_key('NUMPAD9', self.self_insert)
  # then the others: / * - + 
  self._bind_key('Divide', self.self_insert)
  self._bind_key('Multiply', self.self_insert)
  self._bind_key('Add', self.self_insert)
  self._bind_key('Subtract', self.self_insert)
  # the decimal separator: '.' on US keyboards, ',' on DE one's
  self._bind_key('VK_DECIMAL', self.self_insert)
</t>
<t tx="ekr.20050704164036.301">def vi_editing_mode(self, e): # (M-C-j)
  '''When in emacs editing mode, this causes a switch to vi editing
  mode.'''
  pass
</t>
<t tx="ekr.20050704164036.302">def CTRL(c):
  '''make a control character'''
  assert '@' &lt;= c &lt;= '_'
  return chr(ord(c) - ord('@'))</t>
<t tx="ekr.20050704164036.303"># make it case insensitive
def commonprefix(m):
  "Given a list of pathnames, returns the longest common leading component"
  if not m: return ''
  prefix = m[0]
  for item in m:
    for i in range(len(prefix)):
      if prefix[:i+1].lower() != item[:i+1].lower():
        prefix = prefix[:i]
        if i == 0: return ''
        break
  return prefix</t>
<t tx="ekr.20050704164036.304"># create a Readline object to contain the state
rl = Readline()

def GetOutputFile():
  '''Return the console object used by readline so that it can be used for printing in color.'''
  return rl.console
</t>
<t tx="ekr.20050704164142"></t>
<t tx="ekr.20050704165326">
@language python
# -*- coding: utf-8 -*-
#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

# $Id$

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

__doc__ = """
IPython -- An enhanced Interactive Python
=========================================

A Python shell with automatic history (input and output), dynamic object
introspection, easier configuration, command completion, access to the system
shell and more.

IPython can also be embedded in running programs. See EMBEDDING below.


USAGE
       ipython [options] files

       If invoked with no options, it executes all the files listed in
       sequence and drops you into the interpreter while still acknowledging
       any options you may have set in your ipythonrc file. This behavior is
       different from standard Python, which when called as python -i will
       only execute one file and will ignore your configuration setup.

       Please note that some of the configuration options are not available at
       the command line, simply because they are not practical here. Look into
       your ipythonrc configuration file for details on those. This file
       typically installed in the $HOME/.ipython directory.

       For Windows users, $HOME resolves to C:\\Documents and
       Settings\\YourUserName in most instances, and _ipython is used instead
       of .ipython, since some Win32 programs have problems with dotted names
       in directories.

       In the rest of this text, we will refer to this directory as
       IPYTHONDIR.


SPECIAL THREADING OPTIONS
       The following special options are ONLY valid at the  beginning  of  the
       command line, and not later.  This is because they control the initial-
       ization of ipython itself, before the normal option-handling  mechanism
       is active.

       -gthread, -qthread, -wthread, -pylab

              Only ONE of these can be given, and it can only be given as the
              first option passed to IPython (it will have no effect in any
              other position).  They provide threading support for the GTK, QT
              and WXWidgets toolkits, and for the matplotlib library.

              With any of the first three options, IPython starts running a
              separate thread for the graphical toolkit's operation, so that
              you can open and control graphical elements from within an
              IPython command line, without blocking.  All three provide
              essentially the same functionality, respectively for GTK, QT and
              WXWidgets (via their Python interfaces).

              If -pylab is given, IPython loads special support for the mat-
              plotlib library (http://matplotlib.sourceforge.net), allowing
              interactive usage of any of its backends as defined in the
              user's .matplotlibrc file.  It automatically activates GTK, QT
              or WX threading for IPyhton if the choice of matplotlib backend
              requires it.  It also modifies the %run command to correctly
              execute (without blocking) any matplotlib-based script which
              calls show() at the end.

       -tk    The -g/q/wthread options, and -pylab (if matplotlib is
              configured to use GTK, QT or WX), will normally block Tk
              graphical interfaces.  This means that when GTK, QT or WX
              threading is active, any attempt to open a Tk GUI will result in
              a dead window, and possibly cause the Python interpreter to
              crash.  An extra option, -tk, is available to address this
              issue.  It can ONLY be given as a SECOND option after any of the
              above (-gthread, -qthread, -wthread or -pylab).

              If -tk is given, IPython will try to coordinate Tk threading
              with GTK, QT or WX.  This is however potentially unreliable, and
              you will have to test on your platform and Python configuration
              to determine whether it works for you.  Debian users have
              reported success, apparently due to the fact that Debian builds
              all of Tcl, Tk, Tkinter and Python with pthreads support.  Under
              other Linux environments (such as Fedora Core 2/3), this option
              has caused random crashes and lockups of the Python interpreter.
              Under other operating systems (Mac OSX and Windows), you'll need
              to try it to find out, since currently no user reports are
              available.

              There is unfortunately no way for IPython to determine  at  run-
              time  whether -tk will work reliably or not, so you will need to
              do some experiments before relying on it for regular work.

A WARNING ABOUT SIGNALS AND THREADS

       When any of the thread systems (GTK, QT or WX) are active, either
       directly or via -pylab with a threaded backend, it is impossible to
       interrupt long-running Python code via Ctrl-C.  IPython can not pass
       the KeyboardInterrupt exception (or the underlying SIGINT) across
       threads, so any long-running process started from IPython will run to
       completion, or will have to be killed via an external (OS-based)
       mechanism.

       To the best of my knowledge, this limitation is imposed by the Python
       interpreter itself, and it comes from the difficulty of writing
       portable signal/threaded code.  If any user is an expert on this topic
       and can suggest a better solution, I would love to hear about it.  In
       the IPython sources, look at the Shell.py module, and in particular at
       the runcode() method.

REGULAR OPTIONS
       After the above threading options have been given, regular options  can
       follow  in any order.  All options can be abbreviated to their shortest
       non-ambiguous form and are case-sensitive.  One or two  dashes  can  be
       used.   Some options have an alternate short form, indicated after a |.

       Most options can also be set from your  ipythonrc  configuration  file.
       See the provided examples for assistance.  Options given on the comman-
       dline override the values set in the ipythonrc file.

       All options with a no| prepended can be specified in â€™noâ€™ form  (-noop-
       tion instead of -option) to turn the feature off.

       -h, --help
              Show summary of options.

       -pylab This can only be given as the first option passed to IPython (it
              will have no effect in any other position). It adds special sup-
              port   for  the  matplotlib  library  (http://matplotlib.source-
              forge.net), allowing interactive usage of any of its backends as
              defined  in  the  userâ€™s  .matplotlibrc  file.  It automatically
              activates GTK or WX threading for IPyhton if the choice of  mat-
              plotlib  backend requires it.  It also modifies the @run command
              to correctly execute  (without  blocking)  any  matplotlib-based
              script which calls show() at the end.

       -no|autocall
              Make  IPython automatically call any callable object even if you
              didnâ€™t type explicit parentheses. For example, â€™str 43â€™  becomes
              â€™str(43)â€™ automatically.

       -no|autoindent
              Turn automatic indentation on/off.

       -no|automagic
              Make magic commands automatic (without needing their first char-
              acter to be @).  Type @magic at  the  IPython  prompt  for  more
              information.

       -no|autoparens
              Make  IPython automatically call any callable object even if you
              didnâ€™t type explicit parentheses.  For example, â€™str 43â€™ becomes
              â€™str(43)â€™ automatically.

       -no|banner
              Print the intial information banner (default on).

       -c &lt;command&gt;
              Execute  the  given  command  string, and set sys.argv to [â€™câ€™].
              This is similar to the -c option in  the  normal  Python  inter-
              preter.

       -cache_size|cs &lt;n&gt;
              Size  of  the output cache (maximum number of entries to hold in
              memory).  The default is 1000, you can change it permanently  in
              your  config  file.   Setting  it  to  0 completely disables the
              caching system, and the minimum value accepted  is  20  (if  you
              provide  a value less than 20, it is reset to 0 and a warning is
              issued).  This limit is defined because otherwise  youâ€™ll  spend
              more time re-flushing a too small cache than working.

       -classic|cl
              Gives IPython a similar feel to the classic Python prompt.

       -colors &lt;scheme&gt;
              Color  scheme  for  prompts  and exception reporting.  Currently
              implemented: NoColor, Linux, and LightBG.

       -no|color_info
              IPython can display information about objects via a set of func-
              tions, and optionally can use colors for this, syntax highlight-
              ing source code and various other  elements.   However,  because
              this  information  is  passed  through a pager (like â€™lessâ€™) and
              many pagers get confused with color codes, this option is off by
              default.   You  can  test  it and turn it on permanently in your
              ipythonrc file if it works for you.  As a reference, the  â€™lessâ€™
              pager  supplied  with  Mandrake 8.2 works ok, but that in RedHat
              7.2 doesnâ€™t.

              Test it and turn it on permanently if it works with your system.
              The  magic function @color_info allows you to toggle this inter-
              actively for testing.

       -no|confirm_exit
              Set to confirm when you try to exit IPython with  an  EOF  (Con-
              trol-D in Unix, Control-Z/Enter in Windows). Note that using the
              magic functions @Exit or @Quit you  can  force  a  direct  exit,
              bypassing any confirmation.

       -no|debug
              Show  information  about the loading process. Very useful to pin
              down problems with your configuration files or  to  get  details
              about session restores.

       -no|deep_reload
              IPython  can use the deep_reload module which reloads changes in
              modules recursively (it replaces the reload() function,  so  you
              donâ€™t need to change anything to use it). deep_reload() forces a
              full reload of modules whose code may have  changed,  which  the
              default reload() function does not.

              When  deep_reload  is off, IPython will use the normal reload(),
              but deep_reload will still be available as dreload(). This  fea-
              ture  is  off  by default [which means that you have both normal
              reload() and dreload()].

       -editor &lt;name&gt;
              Which editor to use with the @edit command. By default,  IPython
              will  honor  your EDITOR environment variable (if not set, vi is
              the Unix default and notepad the Windows one). Since this editor
              is  invoked on the fly by IPython and is meant for editing small
              code snippets, you may want to use a small,  lightweight  editor
              here (in case your default EDITOR is something like Emacs).

       -ipythondir &lt;name&gt;
              The  name  of  your  IPython configuration directory IPYTHONDIR.
              This can also be  specified  through  the  environment  variable
              IPYTHONDIR.

       -log|l Generate  a log file of all input. The file is named ipython.log
              in your current directory (which  prevents  logs  from  multiple
              IPython sessions from trampling each other). You can use this to
              later restore a session by loading your logfile as a file to  be
              executed with option -logplay (see below).

       -logfile|lf
              Specifu the name of your logfile.

       -logplay|lp
              Replay  a previous log. For restoring a session as close as pos-
              sible to the state you left it in, use this option  (donâ€™t  just
              run the logfile). With -logplay, IPython will try to reconstruct
              the previous working environment in full, not just  execute  the
              commands in the logfile.
              When  a  session is restored, logging is automatically turned on
              again with the name of the logfile it was invoked  with  (it  is
              read  from the log header). So once youâ€™ve turned logging on for
              a session, you can quit IPython and reload it as many  times  as
              you  want  and  it  will continue to log its history and restore
              from the beginning every time.

              Caveats: there are limitations in this option. The history vari-
              ables  _i*,_* and _dh donâ€™t get restored properly. In the future
              we will try to implement full  session  saving  by  writing  and
              retrieving  a failed because of inherent limitations of Pythonâ€™s
              Pickle module, so this may have to wait.

       -no|messages
              Print messages which IPython collects about its startup  process
              (default on).

       -no|pdb
              Automatically  call the pdb debugger after every uncaught excep-
              tion. If you are used to debugging  using  pdb,  this  puts  you
              automatically  inside of it after any call (either in IPython or
              in code called by it) which triggers  an  exception  which  goes
              uncaught.

       -no|pprint
              IPython  can  optionally  use the pprint (pretty printer) module
              for displaying results. pprint tends to give a nicer display  of
              nested  data structures. If you like it, you can turn it on per-
              manently in your config file (default off).

       -profile|p &lt;name&gt;
              Assume that your config file is ipythonrc-&lt;name&gt; (looks in  cur-
              rent dir first, then in IPYTHONDIR). This is a quick way to keep
              and load multiple config files for different  tasks,  especially
              if  you  use  the include option of config files. You can keep a
              basic IPYTHONDIR/ipythonrc file and then have  other  â€™profilesâ€™
              which  include  this  one  and  load extra things for particular
              tasks. For example:

              1) $HOME/.ipython/ipythonrc : load basic things you always want.
              2)  $HOME/.ipython/ipythonrc-math  :  load  (1)  and basic math-
              related modules.
              3) $HOME/.ipython/ipythonrc-numeric : load (1) and  Numeric  and
              plotting modules.

              Since  it is possible to create an endless loop by having circu-
              lar file inclusions, IPython will stop if it reaches  15  recur-
              sive inclusions.

       -prompt_in1|pi1 &lt;string&gt;
              Specify  the string used for input prompts. Note that if you are
              using numbered prompts, the number is represented with a â€™\#â€™ in
              the  string.  Donâ€™t forget to quote strings with spaces embedded
              in them. Default: â€™In [\#]:â€™.

              Most bash-like  escapes  can  be  used  to  customize  IPythonâ€™s
              prompts, as well as a few additional ones which are IPython-spe-
              cific.  All valid prompt escapes are described in detail in  the
              Customization section of the IPython HTML/PDF manual.

       -prompt_in2|pi2 &lt;string&gt;
              Similar  to  the  previous option, but used for the continuation
              prompts. The special sequence â€™\Dâ€™ is similar to â€™\#â€™, but  with
              all  digits  replaced  dots  (so  you can have your continuation
              prompt aligned with your  input  prompt).  Default:  â€™    .\D.:â€™
              (note three spaces at the start for alignment with â€™In [\#]â€™).

       -prompt_out|po &lt;string&gt;
              String   used   for  output  prompts,  also  uses  numbers  like
              prompt_in1.  Default: â€™Out[\#]:â€™.

       -quick Start in bare bones mode (no config file loaded).

       -rcfile &lt;name&gt;
              Name of your  IPython  resource  configuration  file.   normally
              IPython    loads   ipythonrc   (from   current   directory)   or
              IPYTHONDIR/ipythonrc.  If the loading of your config file fails,
              IPython  starts  with  a  bare  bones  configuration (no modules
              loaded at all).

       -no|readline
              Use the readline library, which is needed to support  name  com-
              pletion  and  command history, among other things. It is enabled
              by default, but may cause  problems  for  users  of  X/Emacs  in
              Python comint or shell buffers.

              Note  that  emacs â€™etermâ€™ buffers (opened with M-x term) support
              IPythonâ€™s readline and syntax coloring fine, only  â€™emacsâ€™  (M-x
              shell and C-c !)  buffers do not.

       -screen_length|sl &lt;n&gt;
              Number  of lines of your screen.  This is used to control print-
              ing of very long strings.  Strings longer than  this  number  of
              lines  will be sent through a pager instead of directly printed.

              The default value for this is 0, which means IPython will  auto-
              detect  your  screen  size  every time it needs to print certain
              potentially long strings (this doesnâ€™t change  the  behavior  of
              the  â€™printâ€™  keyword,  itâ€™s  only triggered internally). If for
              some reason this isnâ€™t working well (it needs  curses  support),
              specify it yourself. Otherwise donâ€™t change the default.

       -separate_in|si &lt;string&gt;
              Separator before input prompts.  Default â€™0.

       -separate_out|so &lt;string&gt;
              Separator before output prompts.  Default: 0 (nothing).

       -separate_out2|so2 &lt;string&gt;
              Separator after output prompts.  Default: 0 (nothing).

       -nosep Shorthand for â€™-separate_in 0 -separate_out 0 -separate_out2 0â€™.
              Simply removes all input/output separators.

       -upgrade
              Allows you to upgrade your  IPYTHONDIR  configuration  when  you
              install  a  new  version  of  IPython.   Since  new versions may
              include new command lines options or example files, this  copies
              updated ipythonrc-type files.  However, it backs up (with a .old
              extension) all files which it overwrites so that you  can  merge
              back any custimizations you might have in your personal files.

       -Version
              Print version information and exit.

       -xmode &lt;modename&gt;
              Mode  for  exception reporting.  The valid modes are Plain, Con-
              text, and Verbose.

              - Plain: similar to pythonâ€™s normal traceback printing.

              - Context: prints 5 lines of context  source  code  around  each
              line in the traceback.

              - Verbose: similar to Context, but additionally prints the vari-
              ables currently visible where the exception happened (shortening
              their  strings if too long).  This can potentially be very slow,
              if you happen to have a huge data structure whose string  repre-
              sentation  is  complex  to compute.  Your computer may appear to
              freeze for a while with cpu usage at 100%.  If this occurs,  you
              can cancel the traceback with Ctrl-C (maybe hitting it more than
              once).


EMBEDDING
       It is possible to start an IPython instance inside your own Python pro-
       grams.  In the documentation example files there are some illustrations
       on how to do this.

       This feature allows you to evalutate  dynamically  the  state  of  your
       code,  operate  with  your  variables, analyze them, etc.  Note however
       that any changes you make to values while in the shell do NOT propagate
       back  to  the running code, so it is safe to modify your values because
       you wonâ€™t break your code in bizarre ways by doing so.
"""

cmd_line_usage = __doc__

#---------------------------------------------------------------------------
interactive_usage = """
IPython -- An enhanced Interactive Python
=========================================

IPython offers a combination of convenient shell features, special commands
and a history mechanism for both input (command history) and output (results
caching, similar to Mathematica). It is intended to be a fully compatible
replacement for the standard Python interpreter, while offering vastly
improved functionality and flexibility.

At your system command line, type 'ipython -help' to see the command line
options available. This document only describes interactive features.

Warning: IPython relies on the existence of a global variable called __IP which
controls the shell itself. If you redefine __IP to anything, bizarre behavior
will quickly occur.

MAIN FEATURES

* Access to the standard Python help. As of Python 2.1, a help system is
  available with access to object docstrings and the Python manuals. Simply
  type 'help' (no quotes) to access it.

* Magic commands: type %magic for information on the magic subsystem.

* System command aliases, via the %alias command or the ipythonrc config file.

* Dynamic object information:

  Typing ?word or word? prints detailed information about an object.  If
  certain strings in the object are too long (docstrings, code, etc.) they get
  snipped in the center for brevity.

  Typing ??word or word?? gives access to the full information without
  snipping long strings. Long strings are sent to the screen through the less
  pager if longer than the screen, printed otherwise.

  The ?/?? system gives access to the full source code for any object (if
  available), shows function prototypes and other useful information.

  If you just want to see an object's docstring, type '%pdoc object' (without
  quotes, and without % if you have automagic on).

  Both %pdoc and ?/?? give you access to documentation even on things which are
  not explicitely defined. Try for example typing {}.get? or after import os,
  type os.path.abspath??. The magic functions %pdef, %source and %file operate
  similarly.

* Completion in the local namespace, by typing TAB at the prompt.

  At any time, hitting tab will complete any available python commands or
  variable names, and show you a list of the possible completions if there's
  no unambiguous one. It will also complete filenames in the current directory.

  This feature requires the readline and rlcomplete modules, so it won't work
  if your Python lacks readline support (such as under Windows).

* Search previous command history in two ways (also requires readline):

  - Start typing, and then use Ctrl-p (previous,up) and Ctrl-n (next,down) to
  search through only the history items that match what you've typed so
  far. If you use Ctrl-p/Ctrl-n at a blank prompt, they just behave like
  normal arrow keys.

  - Hit Ctrl-r: opens a search prompt. Begin typing and the system searches
  your history for lines that match what you've typed so far, completing as
  much as it can.

* Persistent command history across sessions (readline required).

* Logging of input with the ability to save and restore a working session.
  
* System escape with !. Typing !ls will run 'ls' in the current directory.

* The reload command does a 'deep' reload of a module: changes made to the
  module since you imported will actually be available without having to exit.

* Verbose and colored exception traceback printouts. See the magic xmode and
  xcolor functions for details (just type %magic).

* Input caching system:

  IPython offers numbered prompts (In/Out) with input and output caching. All
  input is saved and can be retrieved as variables (besides the usual arrow
  key recall).

  The following GLOBAL variables always exist (so don't overwrite them!):
  _i: stores previous input.
  _ii: next previous.
  _iii: next-next previous.
  _ih : a list of all input _ih[n] is the input from line n.

  Additionally, global variables named _i&lt;n&gt; are dynamically created (&lt;n&gt;
  being the prompt counter), such that _i&lt;n&gt; == _ih[&lt;n&gt;]

  For example, what you typed at prompt 14 is available as _i14 and _ih[14].

  You can create macros which contain multiple input lines from this history,
  for later re-execution, with the %macro function.

  The history function %hist allows you to see any part of your input history
  by printing a range of the _i variables. Note that inputs which contain
  magic functions (%) appear in the history with a prepended comment. This is
  because they aren't really valid Python code, so you can't exec them.

* Output caching system:

  For output that is returned from actions, a system similar to the input
  cache exists but using _ instead of _i. Only actions that produce a result
  (NOT assignments, for example) are cached. If you are familiar with
  Mathematica, IPython's _ variables behave exactly like Mathematica's %
  variables.

  The following GLOBAL variables always exist (so don't overwrite them!):
  _ (one underscore): previous output.
  __ (two underscores): next previous.
  ___ (three underscores): next-next previous.

  Global variables named _&lt;n&gt; are dynamically created (&lt;n&gt; being the prompt
  counter), such that the result of output &lt;n&gt; is always available as _&lt;n&gt;.

  Finally, a global dictionary named _oh exists with entries for all lines
  which generated output.

* Directory history:

  Your history of visited directories is kept in the global list _dh, and the
  magic %cd command can be used to go to any entry in that list.

* Auto-parentheses and auto-quotes (adapted from Nathan Gray's LazyPython)

    1. Auto-parentheses
        Callable objects (i.e. functions, methods, etc) can be invoked like
        this (notice the commas between the arguments):
            &gt;&gt;&gt; callable_ob arg1, arg2, arg3
        and the input will be translated to this:
            --&gt; callable_ob(arg1, arg2, arg3)
        You can force auto-parentheses by using '/' as the first character
        of a line.  For example:
            &gt;&gt;&gt; /globals             # becomes 'globals()'
        Note that the '/' MUST be the first character on the line!  This
        won't work:
            &gt;&gt;&gt; print /globals    # syntax error
            
        In most cases the automatic algorithm should work, so you should
        rarely need to explicitly invoke /. One notable exception is if you
        are trying to call a function with a list of tuples as arguments (the
        parenthesis will confuse IPython):
            In [1]: zip (1,2,3),(4,5,6)  # won't work
        but this will work:
            In [2]: /zip (1,2,3),(4,5,6)
            ------&gt; zip ((1,2,3),(4,5,6))
            Out[2]= [(1, 4), (2, 5), (3, 6)]        

        IPython tells you that it has altered your command line by
        displaying the new command line preceded by --&gt;.  e.g.:
            In [18]: callable list
            -------&gt; callable (list) 

    2. Auto-Quoting
        You can force auto-quoting of a function's arguments by using ',' as
        the first character of a line.  For example:
            &gt;&gt;&gt; ,my_function /home/me   # becomes my_function("/home/me")

        If you use ';' instead, the whole argument is quoted as a single
        string (while ',' splits on whitespace):
            &gt;&gt;&gt; ,my_function a b c   # becomes my_function("a","b","c")
            &gt;&gt;&gt; ;my_function a b c   # becomes my_function("a b c")

        Note that the ',' MUST be the first character on the line!  This
        won't work:
            &gt;&gt;&gt; x = ,my_function /home/me    # syntax error
"""
</t>
<t tx="ekr.20050704165326.1">
@language python
# -*- coding: utf-8 -*-
"""
IPython -- An enhanced Interactive Python

One of Python's nicest features is its interactive interpreter. This allows
very fast testing of ideas without the overhead of creating test files as is
typical in most programming languages. However, the interpreter supplied with
the standard Python distribution is fairly primitive (and IDLE isn't really
much better).

IPython tries to:

  i - provide an efficient environment for interactive work in Python
  programming. It tries to address what we see as shortcomings of the standard
  Python prompt, and adds many features to make interactive work much more
  efficient.

  ii - offer a flexible framework so that it can be used as the base
  environment for other projects and problems where Python can be the
  underlying language. Specifically scientific environments like Mathematica,
  IDL and Mathcad inspired its design, but similar ideas can be useful in many
  fields. Python is a fabulous language for implementing this kind of system
  (due to its dynamic and introspective features), and with suitable libraries
  entire systems could be built leveraging Python's power.

  iii - serve as an embeddable, ready to go interpreter for your own programs.

IPython requires Python 2.2 or newer.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

# Enforce proper version requirements
import sys
if sys.version[0:3] &lt; '2.2':
    raise ImportError, 'Python Version 2.2 or above is required.'
        
# Define what gets imported with a 'from IPython import *'
__all__ = ['deep_reload','genutils','ultraTB','DPyGetOpt','Itpl','hooks',
           'ConfigLoader','OutputTrap','Release','Struct','Shell']

# Load __all__ in IPython namespace so that a simple 'import IPython' gives
# access to them via IPython.&lt;name&gt;
glob,loc = globals(),locals()
for name in __all__:
    __import__(name,glob,loc,[])

# Release data
from IPython import Release # do it explicitly so pydoc can see it - pydoc bug
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
              ( Release.authors['Fernando'] + Release.authors['Janko'] + \
                Release.authors['Nathan'] )
__license__ = Release.license
__version__ = Release.version

# Namespace cleanup
del name,glob,loc
</t>
<t tx="ekr.20050704165326.2">@first # -*- coding: utf-8 -*-

&lt;&lt; docstring &gt;&gt;

@language python

&lt;&lt; imports &gt;&gt;

@others</t>
<t tx="ekr.20050704165326.3">from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

# Code begins
import threading,sys

from IPython.ultraTB import AutoFormattedTB
from IPython.genutils import warn,error

# declares Python 2.2 compatibility symbols:
try:
    basestring
except NameError:
    import types
    basestring = (types.StringType, types.UnicodeType)
    True = 1==1
    False = 1==0

</t>
<t tx="ekr.20050704165326.4">class BackgroundJobManager:
    """Class to manage a pool of backgrounded threaded jobs.

    Below, we assume that 'jobs' is a BackgroundJobManager instance.
    
    Usage summary (see the method docstrings for details):

      jobs.new(...) -&gt; start a new job
      
      jobs() or jobs.status() -&gt; print status summary of all jobs

      jobs[N] -&gt; returns job number N.

      foo = jobs[N].result -&gt; assign to variable foo the result of job N

      jobs[N].traceback() -&gt; print the traceback of dead job N

      jobs.remove(N) -&gt; remove (finished) job N

      jobs.flush_finished() -&gt; remove all finished jobs
      
    As a convenience feature, BackgroundJobManager instances provide the
    utility result and traceback methods which retrieve the corresponding
    information from the jobs list:

      jobs.result(N) &lt;--&gt; jobs[N].result
      jobs.traceback(N) &lt;--&gt; jobs[N].traceback()

    While this appears minor, it allows you to use tab completion
    interactively on the job manager instance.

    In interactive mode, IPython provides the magic fuction %bg for quick
    creation of backgrounded expression-based jobs. Type bg? for details."""
	@others
</t>
<t tx="ekr.20050704165326.5">def __init__(self):
    # Lists for job management
    self.jobs_run  = []
    self.jobs_comp = []
    self.jobs_dead = []
    # A dict of all jobs, so users can easily access any of them
    self.jobs_all = {}
    # For reporting
    self._comp_report = []
    self._dead_report = []
    # Store status codes locally for fast lookups
    self._s_created   = BackgroundJobBase.stat_created_c
    self._s_running   = BackgroundJobBase.stat_running_c
    self._s_completed = BackgroundJobBase.stat_completed_c
    self._s_dead      = BackgroundJobBase.stat_dead_c
</t>
<t tx="ekr.20050704165326.6">def new(self,func_or_exp,*args,**kwargs):
    """Add a new background job and start it in a separate thread.

    There are two types of jobs which can be created:

    1. Jobs based on expressions which can be passed to an eval() call.
    The expression must be given as a string.  For example:

      job_manager.new('myfunc(x,y,z=1)'[,glob[,loc]])

    The given expression is passed to eval(), along with the optional
    global/local dicts provided.  If no dicts are given, they are
    extracted automatically from the caller's frame.
    
    A Python statement is NOT a valid eval() expression.  Basically, you
    can only use as an eval() argument something which can go on the right
    of an '=' sign and be assigned to a variable.

    For example,"print 'hello'" is not valid, but '2+3' is.

    2. Jobs given a function object, optionally passing additional
    positional arguments:

      job_manager.new(myfunc,x,y)

    The function is called with the given arguments.

    If you need to pass keyword arguments to your function, you must
    supply them as a dict named kw:

      job_manager.new(myfunc,x,y,kw=dict(z=1))

    The reason for this assymmetry is that the new() method needs to
    maintain access to its own keywords, and this prevents name collisions
    between arguments to new() and arguments to your own functions.

    In both cases, the result is stored in the job.result field of the
    background job object.


    Notes and caveats:

    1. All threads running share the same standard output.  Thus, if your
    background jobs generate output, it will come out on top of whatever
    you are currently writing.  For this reason, background jobs are best
    used with silent functions which simply return their output.

    2. Threads also all work within the same global namespace, and this
    system does not lock interactive variables.  So if you send job to the
    background which operates on a mutable object for a long time, and
    start modifying that same mutable object interactively (or in another
    backgrounded job), all sorts of bizarre behaviour will occur.

    3. If a background job is spending a lot of time inside a C extension
    module which does not release the Python Global Interpreter Lock
    (GIL), this will block the IPython prompt.  This is simply because the
    Python interpreter can only switch between threads at Python
    bytecodes.  While the execution is inside C code, the interpreter must
    simply wait unless the extension module releases the GIL.

    4. There is no way, due to limitations in the Python threads library,
    to kill a thread once it has started."""
    
    if callable(func_or_exp):
        kw  = kwargs.get('kw',{})
        job = BackgroundJobFunc(func_or_exp,*args,**kw)
    elif isinstance(func_or_exp,basestring):
        if not args:
            frame = sys._getframe(1)
            glob, loc = frame.f_globals, frame.f_locals
        elif len(args)==1:
            glob = loc = args[0]
        elif len(args)==2:
            glob,loc = args
        else:
            raise ValueError,\
                  'Expression jobs take at most 2 args (globals,locals)'
        job = BackgroundJobExpr(func_or_exp,glob,loc)
    else:
        raise
    jkeys = self.jobs_all.keys()
    if jkeys:
        job.num = max(jkeys)+1
    else:
        job.num = 0
    self.jobs_run.append(job)
    self.jobs_all[job.num] = job
    print 'Starting job # %s in a separate thread.' % job.num
    job.start()
    return job
</t>
<t tx="ekr.20050704165326.7">def __getitem__(self,key):
    return self.jobs_all[key]
</t>
<t tx="ekr.20050704165326.8">def __call__(self):
    """An alias to self.status(),

    This allows you to simply call a job manager instance much like the
    Unix jobs shell command."""

    return self.status()
</t>
<t tx="ekr.20050704165326.9">def _update_status(self):
    """Update the status of the job lists.

    This method moves finished jobs to one of two lists:
      - self.jobs_comp: jobs which completed successfully
      - self.jobs_dead: jobs which finished but died.

    It also copies those jobs to corresponding _report lists.  These lists
    are used to report jobs completed/dead since the last update, and are
    then cleared by the reporting function after each call."""
    
    run,comp,dead = self._s_running,self._s_completed,self._s_dead
    jobs_run = self.jobs_run
    for num in range(len(jobs_run)):
        job  = jobs_run[num]
        stat = job.stat_code
        if stat == run:
            continue
        elif stat == comp:
            self.jobs_comp.append(job)
            self._comp_report.append(job)
            jobs_run[num] = False
        elif stat == dead:
            self.jobs_dead.append(job)
            self._dead_report.append(job)
            jobs_run[num] = False
    self.jobs_run = filter(None,self.jobs_run)
</t>
<t tx="ekr.20050704165326.10">def _group_report(self,group,name):
    """Report summary for a given job group.

    Return True if the group had any elements."""

    if group:
        print '%s jobs:' % name
        for job in group:
            print '%s : %s' % (job.num,job)
        print
        return True
</t>
<t tx="ekr.20050704165326.11">def _group_flush(self,group,name):
    """Flush a given job group

    Return True if the group had any elements."""

    njobs = len(group)
    if njobs:
        plural = {1:''}.setdefault(njobs,'s')
        print 'Flushing %s %s job%s.' % (njobs,name,plural)
        group[:] = []
        return True
</t>
<t tx="ekr.20050704165326.12">def _status_new(self):
    """Print the status of newly finished jobs.

    Return True if any new jobs are reported.

    This call resets its own state every time, so it only reports jobs
    which have finished since the last time it was called."""

    self._update_status()
    new_comp = self._group_report(self._comp_report,'Completed')
    new_dead = self._group_report(self._dead_report,
                                  'Dead, call job.traceback() for details')
    self._comp_report[:] = []
    self._dead_report[:] = []
    return new_comp or new_dead
</t>
<t tx="ekr.20050704165326.13">def status(self,verbose=0):
    """Print a status of all jobs currently being managed."""

    self._update_status()
    self._group_report(self.jobs_run,'Running')
    self._group_report(self.jobs_comp,'Completed')
    self._group_report(self.jobs_dead,'Dead')
    # Also flush the report queues
    self._comp_report[:] = []
    self._dead_report[:] = []
</t>
<t tx="ekr.20050704165326.14">def remove(self,num):
    """Remove a finished (completed or dead) job."""

    try:
        job = self.jobs_all[num]
    except KeyError:
        error('Job #%s not found' % num)
    else:
        stat_code = job.stat_code
        if stat_code == self._s_running:
            error('Job #%s is still running, it can not be removed.' % num)
            return
        elif stat_code == self._s_completed:
            self.jobs_comp.remove(job)
        elif stat_code == self._s_dead:
            self.jobs_dead.remove(job)
</t>
<t tx="ekr.20050704165326.15">def flush_finished(self):
    """Flush all jobs finished (completed and dead) from lists.

    Running jobs are never flushed.

    It first calls _status_new(), to update info. If any jobs have
    completed since the last _status_new() call, the flush operation
    aborts."""

    if self._status_new():
        error('New jobs completed since last '\
              '_status_new(), aborting flush.')
        return

    # Remove the finished jobs from the master dict
    jobs_all = self.jobs_all
    for job in self.jobs_comp+self.jobs_dead:
        del(jobs_all[job.num])

    # Now flush these lists completely
    fl_comp = self._group_flush(self.jobs_comp,'Completed')
    fl_dead = self._group_flush(self.jobs_dead,'Dead')
    if not (fl_comp or fl_dead):
        print 'No jobs to flush.'
</t>
<t tx="ekr.20050704165326.16">def result(self,num):
    """result(N) -&gt; return the result of job N."""
    try:
        return self.jobs_all[num].result
    except KeyError:
        error('Job #%s not found' % num)
</t>
<t tx="ekr.20050704165326.17">def traceback(self,num):
    try:
        self.jobs_all[num].traceback()
    except KeyError:
        error('Job #%s not found' % num)
</t>
<t tx="ekr.20050704165326.18">

class BackgroundJobBase(threading.Thread):
    """Base class to build BackgroundJob classes.

    The derived classes must implement:

    - Their own __init__, since the one here raises NotImplementedError.  The
    derived constructor must call self._init() at the end, to provide common
    initialization.

    - A strform attribute used in calls to __str__.

    - A call() method, which will make the actual execution call and must
    return a value to be held in the 'result' field of the job object."""
	&lt;&lt; class BackgroundJobBase declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.19"># Class constants for status, in string and as numerical codes (when
# updating jobs lists, we don't want to do string comparisons).  This will
# be done at every user prompt, so it has to be as fast as possible
stat_created   = 'Created'; stat_created_c = 0
stat_running   = 'Running'; stat_running_c = 1
stat_completed = 'Completed'; stat_completed_c = 2
stat_dead      = 'Dead (Exception), call job.traceback() for details'
stat_dead_c = -1

</t>
<t tx="ekr.20050704165326.20">def __init__(self):
    raise NotImplementedError, \
          "This class can not be instantiated directly."
</t>
<t tx="ekr.20050704165326.21">def _init(self):
    """Common initialization for all BackgroundJob objects"""
    
    for attr in ['call','strform']:
        assert hasattr(self,attr), "Missing attribute &lt;%s&gt;" % attr
    
    # The num tag can be set by an external job manager
    self.num = None
  
    self.status    = BackgroundJobBase.stat_created
    self.stat_code = BackgroundJobBase.stat_created_c
    self.finished  = False
    self.result    = '&lt;BackgroundJob has not completed&gt;'
    # reuse the ipython traceback handler if we can get to it, otherwise
    # make a new one
    try:
        self._make_tb = __IPYTHON__.InteractiveTB.text
    except:
        self._make_tb = AutoFormattedTB(mode = 'Context',
                                       color_scheme='NoColor',
                                       tb_offset = 1).text
    # Hold a formatted traceback if one is generated.
    self._tb = None
    
    threading.Thread.__init__(self)
</t>
<t tx="ekr.20050704165326.22">def __str__(self):
    return self.strform
</t>
<t tx="ekr.20050704165326.23">def __repr__(self):
    return '&lt;BackgroundJob: %s&gt;' % self.strform
</t>
<t tx="ekr.20050704165326.24">def traceback(self):
    print self._tb
</t>
<t tx="ekr.20050704165326.25">def run(self):
    try:
        self.status    = BackgroundJobBase.stat_running
        self.stat_code = BackgroundJobBase.stat_running_c
        self.result    = self.call()
    except:
        self.status    = BackgroundJobBase.stat_dead
        self.stat_code = BackgroundJobBase.stat_dead_c
        self.finished  = None
        self.result    = ('&lt;BackgroundJob died, call job.traceback() for details&gt;')
        self._tb       = self._make_tb()
    else:
        self.status    = BackgroundJobBase.stat_completed
        self.stat_code = BackgroundJobBase.stat_completed_c
        self.finished  = True
</t>
<t tx="ekr.20050704165326.26">
class BackgroundJobExpr(BackgroundJobBase):
    """Evaluate an expression as a background job (uses a separate thread)."""
	@others
</t>
<t tx="ekr.20050704165326.27">def __init__(self,expression,glob=None,loc=None):
    """Create a new job from a string which can be fed to eval().

    global/locals dicts can be provided, which will be passed to the eval
    call."""

    # fail immediately if the given expression can't be compiled
    self.code = compile(expression,'&lt;BackgroundJob compilation&gt;','eval')
            
    if glob is None:
        glob = {}
    if loc is None:
        loc = {}
        
    self.expression = self.strform = expression
    self.glob = glob
    self.loc = loc
    self._init()
</t>
<t tx="ekr.20050704165326.28">def call(self):
    return eval(self.code,self.glob,self.loc)
</t>
<t tx="ekr.20050704165326.29">
class BackgroundJobFunc(BackgroundJobBase):
    """Run a function call as a background job (uses a separate thread)."""
	@others
</t>
<t tx="ekr.20050704165326.30">def __init__(self,func,*args,**kwargs):
    """Create a new job from a callable object.

    Any positional arguments and keyword args given to this constructor
    after the initial callable are passed directly to it."""

    assert callable(func),'first argument must be callable'
    
    if args is None:
        args = []
    if kwargs is None:
        kwargs = {}
    
    self.func = func
    self.args = args
    self.kwargs = kwargs
    # The string form will only include the function passed, because
    # generating string representations of the arguments is a potentially
    # _very_ expensive operation (e.g. with large arrays).
    self.strform = str(func)
    self._init()
</t>
<t tx="ekr.20050704165326.31">def call(self):
    return self.func(*self.args,**self.kwargs)
</t>
<t tx="ekr.20050704165326.32">if __name__=='__main__':

    import time

    def sleepfunc(interval=2,*a,**kw):
        args = dict(interval=interval,
                    args=a,
                    kwargs=kw)
        time.sleep(interval)
        return args

    def diefunc(interval=2,*a,**kw):
        time.sleep(interval)
        die

    def printfunc(interval=1,reps=5):
        for n in range(reps):
            time.sleep(interval)
            print 'In the background...'

    jobs = BackgroundJobManager()
    # first job will have # 0
    jobs.new(sleepfunc,4)
    jobs.new(sleepfunc,kw={'reps':2})
    # This makes a job which will die
    jobs.new(diefunc,1)
    jobs.new('printfunc(1,3)')

    # after a while, you can get the traceback of a dead job.  Run the line
    # below again interactively until it prints a traceback (check the status
    # of the job):
    print jobs[1].status
    jobs[1].traceback()
    
    # Run this line again until the printed result changes
    print "The result of job #0 is:",jobs[0].result
</t>
<t tx="ekr.20050704165326.33"># -*- coding: utf-8 -*-
"""Tools for coloring text in ANSI terminals.

$Id$"""

@language python
&lt;&lt; copywrite &gt;&gt;
&lt;&lt; ColorANSI declarations &gt;&gt;

@others
</t>
<t tx="ekr.20050704165326.34">#*****************************************************************************
#       Copyright (C) 2002-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['TermColors','InputTermColors','ColorScheme','ColorSchemeTable']

import os
from UserDict import UserDict

from IPython.Struct import Struct

</t>
<t tx="ekr.20050704165326.35">def make_color_table(in_class):
    """Build a set of color attributes in a class.

    Helper function for building the *TermColors classes."""
    
    color_templates = (
        ("Black"       , "0;30"),
        ("Red"         , "0;31"),
        ("Green"       , "0;32"),
        ("Brown"       , "0;33"),
        ("Blue"        , "0;34"),
        ("Purple"      , "0;35"),
        ("Cyan"        , "0;36"),
        ("LightGray"   , "0;37"),
        ("DarkGray"    , "1;30"),
        ("LightRed"    , "1;31"),
        ("LightGreen"  , "1;32"),
        ("Yellow"      , "1;33"),
        ("LightBlue"   , "1;34"),
        ("LightPurple" , "1;35"),
        ("LightCyan"   , "1;36"),
        ("White"       , "1;37"),  )

    for name,value in color_templates:
        setattr(in_class,name,in_class._base % value)
</t>
<t tx="ekr.20050704165326.36">
class TermColors:
    """Color escape sequences.

    This class defines the escape sequences for all the standard (ANSI?) 
    colors in terminals. Also defines a NoColor escape which is just the null
    string, suitable for defining 'dummy' color schemes in terminals which get
    confused by color escapes.

    This class should be used as a mixin for building color schemes."""
	&lt;&lt; class TermColors declarations &gt;&gt;
</t>
<t tx="ekr.20050704165326.37">NoColor = ''  # for color schemes in color-less terminals.
Normal = '\033[0m'   # Reset normal coloring
_base  = '\033[%sm'  # Template for all other colors

# Build the actual color table as a set of class attributes:
</t>
<t tx="ekr.20050704165326.38">make_color_table(TermColors)

class InputTermColors:
    """Color escape sequences for input prompts.

    This class is similar to TermColors, but the escapes are wrapped in \001
    and \002 so that readline can properly know the length of each line and
    can wrap lines accordingly.  Use this class for any colored text which
    needs to be used in input prompts, such as in calls to raw_input().

    This class defines the escape sequences for all the standard (ANSI?) 
    colors in terminals. Also defines a NoColor escape which is just the null
    string, suitable for defining 'dummy' color schemes in terminals which get
    confused by color escapes.

    This class should be used as a mixin for building color schemes."""
	&lt;&lt; class InputTermColors declarations &gt;&gt;
</t>
<t tx="ekr.20050704165326.39">NoColor = ''  # for color schemes in color-less terminals.
Normal = '\001\033[0m\002'   # Reset normal coloring
_base  = '\001\033[%sm\002'  # Template for all other colors

# Build the actual color table as a set of class attributes:
</t>
<t tx="ekr.20050704165326.40">make_color_table(InputTermColors)

class ColorScheme:
    """Generic color scheme class. Just a name and a Struct."""
	@others
</t>
<t tx="ekr.20050704165326.41">def __init__(self,__scheme_name_,colordict=None,**colormap):
    self.name = __scheme_name_
    if colordict is None:
        self.colors = Struct(**colormap)
    else:
        self.colors = Struct(colordict)
</t>
<t tx="ekr.20050704165326.42">        
class ColorSchemeTable(UserDict):
    """General class to handle tables of color schemes.

    It's basically a dict of color schemes with a couple of shorthand
    attributes and some convenient methods.
    
    active_scheme_name -&gt; obvious
    active_colors -&gt; actual color table of the active scheme"""
	@others
</t>
<t tx="ekr.20050704165326.43">def __init__(self,scheme_list=None,default_scheme=''):
    """Create a table of color schemes.

    The table can be created empty and manually filled or it can be
    created with a list of valid color schemes AND the specification for
    the default active scheme.
    """
    
    UserDict.__init__(self)
    if scheme_list is None:
        self.active_scheme_name = ''
        self.active_colors = None
    else:
        if default_scheme == '':
            raise ValueError,'you must specify the default color scheme'
        for scheme in scheme_list:
            self.add_scheme(scheme)
        self.set_active_scheme(default_scheme)
</t>
<t tx="ekr.20050704165326.44">def add_scheme(self,new_scheme):
    """Add a new color scheme to the table."""
    if not isinstance(new_scheme,ColorScheme):
        raise ValueError,'ColorSchemeTable only accepts ColorScheme instances'
    self[new_scheme.name] = new_scheme
</t>
<t tx="ekr.20050704165326.45">def set_active_scheme(self,scheme,case_sensitive=0):
    """Set the currently active scheme.

    Names are by default compared in a case-insensitive way, but this can
    be changed by setting the parameter case_sensitive to true."""

    scheme_list = self.keys()
    if case_sensitive:
        valid_schemes = scheme_list
        scheme_test = scheme
    else:
        valid_schemes = [s.lower() for s in scheme_list]
        scheme_test = scheme.lower()
    try:
        scheme_idx = valid_schemes.index(scheme_test)
    except ValueError:
        raise ValueError,'Unrecognized color scheme: ' + scheme + \
              '\nValid schemes: '+str(scheme_list).replace("'', ",'')
    else:
        active = scheme_list[scheme_idx]
        self.active_scheme_name = active
        self.active_colors = self[active].colors
        # Now allow using '' as an index for the current active scheme
        self[''] = self[active]
</t>
<t tx="ekr.20050704165326.46">
@language python
&lt;&lt; ConfigLoader declarations &gt;&gt;
@others

# end ConfigLoader
</t>
<t tx="ekr.20050704165326.47"># -*- coding: utf-8 -*-
"""Configuration loader

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

import os
from pprint import pprint
import exceptions

from IPython import ultraTB
from IPython.Struct import Struct
from IPython.genutils import *

</t>
<t tx="ekr.20050704165326.48">class ConfigLoaderError(exceptions.Exception):
    """Exception for ConfigLoader class."""
	@others
</t>
<t tx="ekr.20050704165326.49">def __init__(self,args=None):
    self.args = args
</t>
<t tx="ekr.20050704165326.50">
class ConfigLoader:

    """Configuration file loader capable of handling recursive inclusions and
    with parametrized conflict resolution for multiply found keys."""
	@others
</t>
<t tx="ekr.20050704165326.51">def __init__(self,conflict=None,field_sep=None,reclimit=15):

    """The reclimit parameter controls the number of recursive
    configuration file inclusions. This way we can stop early on (before
    python's own recursion limit is hit) if there is a circular
    inclusion.

    - conflict: dictionary for conflict resolutions (see Struct.merge())

    """
    self.conflict = conflict
    self.field_sep = field_sep
    self.reset(reclimit)
</t>
<t tx="ekr.20050704165326.52">def reset(self,reclimit=15):
    self.reclimit = reclimit
    self.recdepth = 0
    self.included = []
</t>
<t tx="ekr.20050704165326.53">def load(self,fname,convert=None,recurse_key='',incpath = '.',**kw):
    """Load a configuration file, return the resulting Struct.

    Call: load_config(fname,convert=None,conflict=None,recurse_key='')

     - fname: file to load from.
     - convert: dictionary of type conversions (see read_dict())
     - recurse_key: keyword in dictionary to trigger recursive file
     inclusions.
     """

    if self.recdepth &gt; self.reclimit:
        raise ConfigLoaderError, 'maximum recursive inclusion of rcfiles '+\
              'exceeded: ' + `self.recdepth` + \
              '.\nMaybe you have a circular chain of inclusions?'
    self.recdepth += 1
    fname = filefind(fname,incpath)
    data = Struct()
    # avoid including the same file more than once
    if fname in self.included:
        return data
    Xinfo = ultraTB.AutoFormattedTB()
    if convert==None and recurse_key : convert = {qwflat:recurse_key}
    # for production, change warn to 0:
    data.merge(read_dict(fname,convert,fs=self.field_sep,strip=1,
                         warn=0,no_empty=0,**kw))
    # keep track of successfully loaded files
    self.included.append(fname)
    if recurse_key in data.keys():
        for incfilename in data[recurse_key]:
            found=0
            try:
                incfile = filefind(incfilename,incpath)
            except IOError:
                if os.name in ['nt','dos']:
                    try:
                        # Try again with '.ini' extension
                        incfilename += '.ini'
                        incfile = filefind(incfilename,incpath)
                    except IOError:
                        found = 0
                    else:
                        found = 1
                else:
                    found = 0
            else:
                found = 1
            if found:
                try:
                    data.merge(self.load(incfile,convert,recurse_key,
                                         incpath,**kw),
                               self.conflict)
                except:
                    Xinfo()
                    warn('Problem loading included file: '+
                         `incfilename` + '. Ignoring it...')
            else:
                warn('File `%s` not found. Included by %s' % (incfilename,fname))

    return data
</t>
<t tx="ekr.20050704165326.54">@language python
&lt;&lt; CrashHandler declarations &gt;&gt;
@others
"""
Oops, IPython crashed. We do our best to make it stable, but...

A crash report was automatically generated with the following information:
  - A verbatim copy of the traceback above this text.
  - A copy of your input history during this session.
  - Data on your current IPython configuration.

It was left in the file named:
\t'$self.report_name'
If you can email this file to the developers, the information in it will help
them in understanding and correcting the problem.

You can mail it to $self.bug_contact at $self.mailto
with the subject 'IPython Crash Report'.

If you want to do it now, the following command will work (under Unix):
mail -s 'IPython Crash Report' $self.mailto &lt; $self.report_name

To ensure accurate tracking of this issue, please file a report about it at:
http://www.scipy.net/roundup/ipython  (IPython's online bug tracker).
""")
        print &gt;&gt; sys.stderr, msg

        sec_sep = '\n\n'+'*'*75+'\n\n'
        report.write('*'*75+'\n\n'+'IPython post-mortem report\n\n')
        report.write('IPython version: %s \n\n' % __version__)
        report.write('Platform info  : os.name -&gt; %s, sys.platform -&gt; %s' %
                     (os.name,sys.platform) )
        report.write(sec_sep+'Current user configuration structure:\n\n')
        report.write(pformat(self.IP.rc.dict()))
        report.write(sec_sep+'Crash traceback:\n\n' + traceback)
        try:
            report.write(sec_sep+"History of session input:")
            for line in self.IP.user_ns['_ih']:
                report.write(line)
            report.write('\n*** Last line of input (may not be in above history):\n')
            report.write(self.IP._last_input_line+'\n')
        except:
            pass
        report.close()
</t>
<t tx="ekr.20050704165326.55"># -*- coding: utf-8 -*-
"""sys.excepthook for IPython itself, leaves a detailed report on disk.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

#****************************************************************************
# Required modules

# From the standard library
import os,sys
from pprint import pprint,pformat

# Homebrewed
from IPython.genutils import *
from IPython.Itpl import Itpl,itpl,printpl
from IPython import ultraTB
from IPython.ultraTB import ColorScheme,ColorSchemeTable  # too long names

#****************************************************************************
</t>
<t tx="ekr.20050704165326.56">class CrashHandler:
    """sys.excepthook for IPython itself, leaves a detailed report on disk."""
	@others
</t>
<t tx="ekr.20050704165326.57">def __init__(self,IP):
    self.IP = IP  # IPython instance
    self.bug_contact = Release.authors['Fernando'][0]
    self.mailto = Release.authors['Fernando'][1]
</t>
<t tx="ekr.20050704165326.58">def __call__(self,etype, evalue, etb):

    # Report tracebacks shouldn't use color in general (safer for users)
    color_scheme = 'NoColor'

    # Use this ONLY for developer debugging (keep commented out for release)
    #color_scheme = 'Linux'   # dbg
    
    try:
        rptdir = self.IP.rc.ipythondir
    except:
        rptdir = os.getcwd()
    if not os.path.isdir(rptdir):
        rptdir = os.getcwd()
    self.report_name = os.path.join(rptdir,'IPython_crash_report.txt')
    self.TBhandler = ultraTB.VerboseTB(color_scheme=color_scheme,long_header=1)
    traceback = self.TBhandler.text(etype,evalue,etb,context=31)

    # print traceback to screen
    print &gt;&gt; sys.stderr, traceback

    # and generate a complete report on disk
    try:
        report = open(self.report_name,'w')
    except:
        print &gt;&gt; sys.stderr, 'Could not create crash report on disk.'
        return

    msg = itpl('\n'+'*'*70+'\n'
</t>
<t tx="ekr.20050704165326.59">
@language python
&lt;&lt; Debugger declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704165326.60"># -*- coding: utf-8 -*-
"""
Pdb debugger class.

Modified from the standard pdb.Pdb class to avoid including readline, so that
the command line completion of other programs which include this isn't
damaged.

In the future, this class will be expanded with improvements over the standard
pdb.

The code in this file is mainly lifted out of cmd.py in Python 2.2, with minor
changes. Licensing should therefore be under the standard Python terms.  For
details on the PSF (Python Software Foundation) standard license, see:

http://www.python.org/2.2.3/license.html

$Id$"""

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = 'Python'

import pdb,bdb,cmd,os,sys

</t>
<t tx="ekr.20050704165326.61">class Pdb(pdb.Pdb):
    """Modified Pdb class, does not load readline."""
	@others
</t>
<t tx="ekr.20050704165326.62">def __init__(self):
    bdb.Bdb.__init__(self)
    cmd.Cmd.__init__(self,completekey=None) # don't load readline
    self.prompt = '(Pdb) '
    self.aliases = {}

    # Read $HOME/.pdbrc and ./.pdbrc
    self.rcLines = []
    if os.environ.has_key('HOME'):
        envHome = os.environ['HOME']
        try:
            rcFile = open(os.path.join(envHome, ".pdbrc"))
        except IOError:
            pass
        else:
            for line in rcFile.readlines():
                self.rcLines.append(line)
            rcFile.close()
    try:
        rcFile = open(".pdbrc")
    except IOError:
        pass
    else:
        for line in rcFile.readlines():
            self.rcLines.append(line)
        rcFile.close()
</t>
<t tx="ekr.20050704165326.63">
@language python
&lt;&lt; deep_reload declarations &gt;&gt;
@others

# Uncomment the following to automatically activate deep reloading whenever
# this module is imported
#__builtin__.reload = reload
</t>
<t tx="ekr.20050704165326.64"># -*- coding: utf-8 -*-
"""
A module to change reload() so that it acts recursively.
To enable it type:
    &gt;&gt;&gt; import __builtin__, deep_reload
    &gt;&gt;&gt; __builtin__.reload = deep_reload.reload
You can then disable it with:
    &gt;&gt;&gt; __builtin__.reload = deep_reload.original_reload
    
Alternatively, you can add a dreload builtin alongside normal reload with:
    &gt;&gt;&gt; __builtin__.dreload = deep_reload.reload
    
This code is almost entirely based on knee.py from the standard library.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001 Nathaniel Gray &lt;n8gray@caltech.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release # do it explicitly so pydoc can see it - pydoc bug
__author__  = '%s &lt;%s&gt;' %  Release.authors['Nathan']
__license__ = Release.license
__version__ = "0.5"
__date__    = "21 August 2001"

import sys, imp, __builtin__

# Replacement for __import__()
</t>
<t tx="ekr.20050704165326.65">def deep_import_hook(name, globals=None, locals=None, fromlist=None):
    parent = determine_parent(globals)
    q, tail = find_head_package(parent, name)
    m = load_tail(q, tail)
    if not fromlist:
        return q
    if hasattr(m, "__path__"):
        ensure_fromlist(m, fromlist)
    return m
</t>
<t tx="ekr.20050704165326.66">def determine_parent(globals):
    if not globals or  not globals.has_key("__name__"):
        return None
    pname = globals['__name__']
    if globals.has_key("__path__"):
        parent = sys.modules[pname]
        assert globals is parent.__dict__
        return parent
    if '.' in pname:
        i = pname.rfind('.')
        pname = pname[:i]
        parent = sys.modules[pname]
        assert parent.__name__ == pname
        return parent
    return None
</t>
<t tx="ekr.20050704165326.67">def find_head_package(parent, name):
    # Import the first
    if '.' in name:
        # 'some.nested.package' -&gt; head = 'some', tail = 'nested.package'
        i = name.find('.')
        head = name[:i]
        tail = name[i+1:]
    else:
        # 'packagename' -&gt; head = 'packagename', tail = ''
        head = name
        tail = ""
    if parent:
        # If this is a subpackage then qname = parent's name + head
        qname = "%s.%s" % (parent.__name__, head)
    else:
        qname = head
    q = import_module(head, qname, parent)
    if q: return q, tail
    if parent:
        qname = head
        parent = None
        q = import_module(head, qname, parent)
        if q: return q, tail
    raise ImportError, "No module named " + qname
</t>
<t tx="ekr.20050704165326.68">def load_tail(q, tail):
    m = q
    while tail:
        i = tail.find('.')
        if i &lt; 0: i = len(tail)
        head, tail = tail[:i], tail[i+1:]

        # fperez: fix dotted.name reloading failures by changing:
        #mname = "%s.%s" % (m.__name__, head)
        # to:
        mname = m.__name__
        # This needs more testing!!! (I don't understand this module too well)
        
        #print '** head,tail=|%s|-&gt;|%s|, mname=|%s|' % (head,tail,mname)  # dbg
        m = import_module(head, mname, m)
        if not m:
            raise ImportError, "No module named " + mname
    return m
</t>
<t tx="ekr.20050704165326.69">def ensure_fromlist(m, fromlist, recursive=0):
    for sub in fromlist:
        if sub == "*":
            if not recursive:
                try:
                    all = m.__all__
                except AttributeError:
                    pass
                else:
                    ensure_fromlist(m, all, 1)
            continue
        if sub != "*" and not hasattr(m, sub):
            subname = "%s.%s" % (m.__name__, sub)
            submod = import_module(sub, subname, m)
            if not submod:
                raise ImportError, "No module named " + subname
</t>
<t tx="ekr.20050704165326.70"># Need to keep track of what we've already reloaded to prevent cyclic evil
found_now = {}

def import_module(partname, fqname, parent):
    global found_now
    if found_now.has_key(fqname):
        try:
            return sys.modules[fqname]    
        except KeyError:
            pass
    
    print 'Reloading', fqname #, sys.excepthook is sys.__excepthook__, \
            #sys.displayhook is sys.__displayhook__
    
    found_now[fqname] = 1
    try:
        fp, pathname, stuff = imp.find_module(partname,
                                              parent and parent.__path__)
    except ImportError:
        return None
        
    try:
        m = imp.load_module(fqname, fp, pathname, stuff)
    finally:
        if fp: fp.close()
        
    if parent:
        setattr(parent, partname, m)

    return m
</t>
<t tx="ekr.20050704165326.71">def deep_reload_hook(module):
    name = module.__name__
    if '.' not in name:
        return import_module(name, name, None)
    i = name.rfind('.')
    pname = name[:i]
    parent = sys.modules[pname]
    return import_module(name[i+1:], name, parent)
</t>
<t tx="ekr.20050704165326.72"># Save the original hooks
original_reload = __builtin__.reload

# Replacement for reload()
def reload(module, exclude=['sys', '__builtin__', '__main__']):
    """Recursively reload all modules used in the given module.  Optionally
    takes a list of modules to exclude from reloading.  The default exclude
    list contains sys, __main__, and __builtin__, to prevent, e.g., resetting 
    display, exception, and io hooks.
    """
    global found_now
    for i in exclude:
        found_now[i] = 1
    original_import = __builtin__.__import__
    __builtin__.__import__ = deep_import_hook    
    try:
        ret = deep_reload_hook(module)
    finally:
        __builtin__.__import__ = original_import
        found_now = {}
    return ret
</t>
<t tx="ekr.20050704165326.73">
@language python
&lt;&lt; DPyGetOpt declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704165326.74"># -*- coding: utf-8 -*-
"""DPyGetOpt -- Demiurge Python GetOptions Module

 $Id$

This module is modeled after perl's Getopt::Long module-- which
is, in turn, modeled after GNU's extended getopt() function.

Upon instantiation, the option specification should be a sequence
(list) of option definitions.

Options that take no arguments should simply contain the name of
the option.  If a ! is post-pended, the option can be negated by
prepending 'no';  ie 'debug!' specifies that -debug and -nodebug
should be accepted.

Mandatory arguments to options are specified using a postpended
'=' + a type specifier.  '=s' specifies a mandatory string
argument, '=i' specifies a mandatory integer argument, and '=f'
specifies a mandatory real number.  In all cases, the '=' can be
substituted with ':' to specify that the argument is optional.

Dashes '-' in option names are allowed.

If an option has the character '@' postpended (after the
argumentation specification), it can appear multiple times within
each argument list that is processed. The results will be stored
in a list.

The option name can actually be a list of names separated by '|'
characters;  ie-- 'foo|bar|baz=f@' specifies that all -foo, -bar,
and -baz options that appear on within the parsed argument list
must have a real number argument and that the accumulated list
of values will be available under the name 'foo'

$Id$"""

#*****************************************************************************
#
# Copyright (c) 2001 Bill Bumgarner &lt;bbum@friday.com&gt;
#
#
# Published under the terms of the MIT license, hereby reproduced:
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
#*****************************************************************************

__author__  = 'Bill Bumgarner &lt;bbum@friday.com&gt;'
__license__ = 'MIT'
__version__ = '1.2'

# Modified to use re instead of regex and regsub modules.
# 2001/5/7, Jonathan Hogg &lt;jonathan@onegoodidea.com&gt;

import string
import re
import sys
import types

arg_error  = 'DPyGetOpt Argument Error'
spec_error = 'DPyGetOpt Specification Error'
term_error = 'DPyGetOpt Termination Error'

specificationExpr = re.compile('(?P&lt;required&gt;.)(?P&lt;type&gt;.)(?P&lt;multi&gt;@?)')

ArgRequired	= 'Requires an Argument'
ArgOptional	= 'Argument Optional'

# The types modules is not used for these identifiers because there
# is no identifier for 'boolean' or 'generic'
StringArgType	= 'String Argument Type'
IntegerArgType	= 'Integer Argument Type'
RealArgType		= 'Real Argument Type'
BooleanArgType	= 'Boolean Argument Type'
GenericArgType  = 'Generic Argument Type'

# dictionary of conversion functions-- boolean and generic options
# do not accept arguments and do not need conversion functions;
# the identity function is used purely for convenience.
ConversionFunctions = {
	StringArgType : lambda x: x,
	IntegerArgType : string.atoi,
	RealArgType : string.atof,
	BooleanArgType : lambda x: x,
	GenericArgType : lambda x: x,
	}

</t>
<t tx="ekr.20050704165326.75">class DPyGetOpt:
	@others
</t>
<t tx="ekr.20050704165326.76">def __init__(self, spec = None, terminators = ['--']):
	"""
	Declare and intialize instance variables

	Yes, declaration is not necessary... but one of the things
	I sorely miss from C/Obj-C is the concept of having an
	interface definition that clearly declares all instance
	variables and methods without providing any implementation
	 details.   it is a useful reference!

	all instance variables are initialized to 0/Null/None of
	the appropriate type-- not even the default value...
	"""

#		sys.stderr.write(string.join(spec) + "\n")

	self.allowAbbreviations	= 1  # boolean, 1 if abbreviations will
										  # be expanded
	self.freeValues		= [] # list, contains free values
	self.ignoreCase		= 0  # boolean, YES if ignoring case
	self.needsParse		= 0  # boolean, YES if need to reparse parameter spec
	self.optionNames	= {} # dict, all option names-- value is index of tuple
	self.optionStartExpr	= None # regexp defining the start of an option (ie; '-', '--')
	self.optionTuples	= [] # list o' tuples containing defn of options AND aliases
	self.optionValues	= {} # dict, option names (after alias expansion) -&gt; option value(s)
	self.orderMixed		= 0  # boolean, YES if options can be mixed with args
	self.posixCompliance	= 0  # boolean, YES indicates posix like behaviour
	self.spec		= [] # list, raw specs (in case it must be reparsed)
	self.terminators	= terminators # list, strings that terminate argument processing
	self.termValues		= [] # list, values after terminator
	self.terminator		= None # full name of terminator that ended
					       # option processing

	# set up defaults
	self.setPosixCompliance()
	self.setIgnoreCase()
	self.setAllowAbbreviations()

	# parse spec-- if present
	if spec:
		self.parseConfiguration(spec)
</t>
<t tx="ekr.20050704165326.77">def setPosixCompliance(self, aFlag = 0):
	"""
	Enables and disables posix compliance.

	When enabled, '+' can be used as an option prefix and free
	values can be mixed with options.
	"""
	self.posixCompliance = aFlag
	self.needsParse = 1

	if self.posixCompliance:
		self.optionStartExpr = re.compile('(--|-)(?P&lt;option&gt;[A-Za-z0-9_-]+)(?P&lt;arg&gt;=.*)?')
		self.orderMixed = 0
	else:
		self.optionStartExpr = re.compile('(--|-|\+)(?P&lt;option&gt;[A-Za-z0-9_-]+)(?P&lt;arg&gt;=.*)?')
		self.orderMixed = 1
</t>
<t tx="ekr.20050704165326.78">def isPosixCompliant(self):
	"""
	Returns the value of the posix compliance flag.
	"""
	return self.posixCompliance
</t>
<t tx="ekr.20050704165326.79">def setIgnoreCase(self, aFlag = 1):
	"""
	Enables and disables ignoring case during option processing.
	"""
	self.needsParse = 1
	self.ignoreCase = aFlag
</t>
<t tx="ekr.20050704165326.80">def ignoreCase(self):
	"""
	Returns 1 if the option processor will ignore case when
	processing options.
	"""
	return self.ignoreCase
</t>
<t tx="ekr.20050704165326.81">def setAllowAbbreviations(self, aFlag = 1):
	"""
	Enables and disables the expansion of abbreviations during
	option processing.
	"""
	self.allowAbbreviations = aFlag
</t>
<t tx="ekr.20050704165326.82">def willAllowAbbreviations(self):
	"""
	Returns 1 if abbreviated options will be automatically
	expanded to the non-abbreviated form (instead of causing an
	unrecognized option error).
	"""
	return self.allowAbbreviations
</t>
<t tx="ekr.20050704165326.83">def addTerminator(self, newTerm):
	"""
	Adds newTerm as terminator of option processing.

	Whenever the option processor encounters one of the terminators
	during option processing, the processing of options terminates
	immediately, all remaining options are stored in the termValues
	instance variable and the full name of the terminator is stored
	in the terminator instance variable.
	"""
	self.terminators = self.terminators + [newTerm]
</t>
<t tx="ekr.20050704165326.84">def _addOption(self, oTuple):
	"""
	Adds the option described by oTuple (name, (type, mode,
	default), alias) to optionTuples.  Adds index keyed under name
	to optionNames.  Raises spec_error if name already in
	optionNames
	"""
	(name, (type, mode, default, multi), realName) = oTuple

	# verify name and add to option names dictionary
	if self.optionNames.has_key(name):
		if realName:
			raise spec_error, 'Alias \'' + name + '\' for \'' + realName + \
					'\' already used for another option or alias.'
		else:
			raise spec_error, 'Option named \'' + name + \
					'\' specified more than once. Specification: ' + option

	# validated. add to optionNames
	self.optionNames[name] = self.tupleIndex
	self.tupleIndex = self.tupleIndex + 1

	# add to optionTuples
	self.optionTuples = self.optionTuples + [oTuple]

	# if type is boolean, add negation
	if type == BooleanArgType:
		alias		 = 'no' + name
		specTuple = (type, mode, 0, multi)
		oTuple = (alias, specTuple, name)

		# verify name and add to option names dictionary
		if self.optionNames.has_key(alias):
			if realName:
				raise spec_error, 'Negated alias \'' + name + '\' for \'' + realName + \
						'\' already used for another option or alias.'
			else:
				raise spec_error, 'Negated option named \'' + name + \
						'\' specified more than once. Specification: ' + option

		# validated. add to optionNames
		self.optionNames[alias] = self.tupleIndex
		self.tupleIndex = self.tupleIndex + 1

		# add to optionTuples
		self.optionTuples = self.optionTuples + [oTuple]
</t>
<t tx="ekr.20050704165326.85">def addOptionConfigurationTuple(self, oTuple):
	(name, argSpec, realName) = oTuple
	if self.ignoreCase:
		name = string.lower(name)
		if realName:
			realName = string.lower(realName)
		else:
			realName = name

		oTuple = (name, argSpec, realName)

	# add option
	self._addOption(oTuple)
</t>
<t tx="ekr.20050704165326.86">def addOptionConfigurationTuples(self, oTuple):
	if type(oTuple) is ListType:
		for t in oTuple:
			self.addOptionConfigurationTuple(t)
	else:
		self.addOptionConfigurationTuple(oTuple)
</t>
<t tx="ekr.20050704165326.87">def parseConfiguration(self, spec):
	# destroy previous stored information + store raw spec
	self.spec			= spec
	self.optionTuples	= []
	self.optionNames  = {}
	self.tupleIndex   = 0

	tupleIndex = 0

	# create some regex's for parsing each spec
	splitExpr = \
				 re.compile('(?P&lt;names&gt;\w+[-A-Za-z0-9|]*)?(?P&lt;spec&gt;!|[=:][infs]@?)?')
	for option in spec:
     # push to lower case (does not negatively affect
     # specification)
		if self.ignoreCase:
			option = string.lower(option)

		# break into names, specification
		match = splitExpr.match(option)
		if match is None:
			raise spec_error, 'Invalid specification {' + option + '}'

		names			  = match.group('names')
		specification = match.group('spec')

		# break name into name, aliases
		nlist = string.split(names, '|')

		# get name
		name	  = nlist[0]
		aliases = nlist[1:]

		# specificationExpr = regex.symcomp('\(&lt;required&gt;.\)\(&lt;type&gt;.\)\(&lt;multi&gt;@?\)')
		if not specification:
			#spec tuple is ('type', 'arg mode', 'default value', 'multiple')
			argType		= GenericArgType
			argMode		= None
			argDefault	= 1
			argMultiple	= 0
		elif specification == '!':
			argType		= BooleanArgType
			argMode		= None
			argDefault	= 1
			argMultiple	= 0
		else:
			# parse
			match = specificationExpr.match(specification)
			if match is None:
				# failed to parse, die
				raise spec_error, 'Invalid configuration for option \'' + option + '\''

			# determine mode
			required = match.group('required')
			if required == '=':
				argMode = ArgRequired
			elif required == ':':
				argMode = ArgOptional
			else:
				raise spec_error, 'Unknown requirement configuration \'' + required + '\''

			# determine type
			type = match.group('type')
			if type == 's':
				argType	  = StringArgType
				argDefault = ''
			elif type == 'i':
				argType	  = IntegerArgType
				argDefault = 1
			elif type == 'f' or type == 'n':
				argType	  = RealArgType
				argDefault = 1
			else:
				raise spec_error, 'Unknown type specifier \'' + type + '\''

			# determine quantity
			if match.group('multi') == '@':
				argMultiple = 1
			else:
				argMultiple = 0
		## end else (of not specification)

		# construct specification tuple
		specTuple = (argType, argMode, argDefault, argMultiple)

		# add the option-- option tuple is (name, specTuple, real name)
		oTuple = (name, specTuple, name)
		self._addOption(oTuple)

		for alias in aliases:
			# drop to all lower (if configured to do so)
			if self.ignoreCase:
				alias = string.lower(alias)
			# create configuration tuple
			oTuple = (alias, specTuple, name)
			# add
			self._addOption(oTuple)

	# successfully parsed....
	self.needsParse = 0
</t>
<t tx="ekr.20050704165326.88">def _getArgTuple(self, argName):
	"""
	Returns a list containing all the specification tuples that
	match argName.  If none match, None is returned.  If one
	matches, a list with one tuple is returned.  If more than one
	match, a list containing all the tuples that matched is
	returned.

	In other words, this function does not pass judgement upon the
	validity of multiple matches.
	"""
	# is it in the optionNames dict?

	try:
#			sys.stderr.write(argName + string.join(self.optionNames.keys()) + "\n")

		# yes, get index
		tupleIndex = self.optionNames[argName]
		# and return tuple as element of list
		return [self.optionTuples[tupleIndex]]
	except KeyError:
		# are abbreviations allowed?
		if not self.allowAbbreviations:
			# No! terefore, this cannot be valid argument-- nothing found
			return None

	# argName might be an abbreviation (and, abbreviations must
	# be allowed... or this would not have been reached!)

	# create regex for argName
	argExpr = re.compile('^' + argName)

	tuples = filter(lambda x, argExpr=argExpr: argExpr.search(x[0]) is not None,
						  self.optionTuples)

	if not len(tuples):
		return None
	else:
		return tuples
</t>
<t tx="ekr.20050704165326.89">def _isTerminator(self, optionName):
	"""
	Returns the full name of the terminator if optionName is a valid
	terminator.  If it is, sets self.terminator to the full name of
	the terminator.

	If more than one terminator matched, raises a term_error with a
	string describing the ambiguity.
	"""

#		sys.stderr.write(optionName + "\n")
#		sys.stderr.write(repr(self.terminators))

	if optionName in self.terminators:
		self.terminator = optionName
	elif not self.allowAbbreviations:
		return None

# regex thing in bogus
#		termExpr = regex.compile('^' + optionName)

	terms = filter(lambda x, on=optionName: string.find(x,on) == 0, self.terminators)

	if not len(terms):
		return None
	elif len(terms) &gt; 1:
		raise term_error, 'Ambiguous terminator \'' + optionName + \
				'\' matches ' + repr(terms)

	self.terminator = terms[0]
	return self.terminator
</t>
<t tx="ekr.20050704165326.90">def processArguments(self, args = None):
	"""
	Processes args, a list of arguments (including options).

	If args is the same as sys.argv, automatically trims the first
	argument (the executable name/path).

	If an exception is not raised, the argument list was parsed
	correctly.

	Upon successful completion, the freeValues instance variable
	will contain all the arguments that were not associated with an
	option in the order they were encountered.  optionValues is a
	dictionary containing the value of each option-- the method
	valueForOption() can be used to query this dictionary.
	terminator will contain the argument encountered that terminated
	option processing (or None, if a terminator was never
	encountered) and termValues will contain all of the options that
	appeared after the Terminator (or an empty list).
	"""

	if hasattr(sys, "argv") and args == sys.argv:
		args = sys.argv[1:]

	max		= len(args) # maximum index + 1
	self.freeValues	= []        # array to hold return values
	self.optionValues= {}
	index		= 0         # initial index
	self.terminator = None
	self.termValues  = []

	while index &lt; max:
		# obtain argument
		arg = args[index]
		# increment index -- REMEMBER; it is NOW incremented
		index = index + 1

		# terminate immediately if option terminator encountered
		if self._isTerminator(arg):
			self.freeValues = self.freeValues + args[index:]
			self.termValues = args[index:]
			return

		# is this possibly an option?
		match = self.optionStartExpr.match(arg)
		if match is None:
			# not an option-- add to freeValues
			self.freeValues = self.freeValues + [arg]
			if not self.orderMixed:
				# mixing not allowed;  add rest of args as freeValues
				self.freeValues = self.freeValues + args[index:]
				# return to caller
				return
			else:
				continue

		# grab name
		optName = match.group('option')

		# obtain next argument-- index has already been incremented
		nextArg = match.group('arg')
		if nextArg:
			nextArg = nextArg[1:]
			index = index - 1 # put it back
		else:
			try:
				nextArg = args[index]
			except:
				nextArg = None

		# transpose to lower case, if necessary
		if self.ignoreCase:
			optName = string.lower(optName)

		# obtain defining tuple
		tuples = self._getArgTuple(optName)

		if tuples == None:
			raise arg_error, 'Illegal option \'' + arg + '\''
		elif len(tuples) &gt; 1:
			raise arg_error, 'Ambiguous option \'' + arg + '\';  matches ' + \
					repr(map(lambda x: x[0], tuples))
		else:
			config = tuples[0]

		# config is now set to the configuration tuple for the
		# argument
		(fullName, spec, realName) = config
		(optType, optMode, optDefault, optMultiple) = spec

		# if opt mode required, but nextArg is none, raise an error
		if (optMode == ArgRequired):
			if (not nextArg) or self._isTerminator(nextArg):
#					print nextArg
				raise arg_error, 'Option \'' + arg + \
						'\' requires an argument of type ' + optType

		if (not optMode == None) and nextArg and (not self._isTerminator(nextArg)):
			# nextArg defined, option configured to possibly consume arg
			try:
				# grab conversion function-- the try is more for internal diagnostics
				func = ConversionFunctions[optType]
				try:
					optionValue = func(nextArg)
					index = index + 1
				except:
					# only raise conversion error if REQUIRED to consume argument
					if optMode == ArgRequired:
						raise arg_error, 'Invalid argument to option \'' + arg + \
								'\';  should be \'' + optType + '\''
					else:
						optionValue = optDefault
			except arg_error:
				raise arg_error, sys.exc_value
			except:
				raise arg_error, '(' + arg + \
						') Conversion function for \'' + optType + '\' not found.'
		else:
			optionValue = optDefault

		# add value to options dictionary
		if optMultiple:
			# can be multiple values
			try:
				# try to append element
				self.optionValues[realName] = self.optionValues[realName] + [optionValue]
			except:
				# failed-- must not exist;  add it
				self.optionValues[realName] = [optionValue]
		else:
			# only one value per
			if self.isPosixCompliant and self.optionValues.has_key(realName):
				raise arg_error, 'Argument \'' + arg + '\' occurs multiple times.'

			self.optionValues[realName] = optionValue
</t>
<t tx="ekr.20050704165326.91">def valueForOption(self, optionName, defaultValue = None):
	"""
	Return the value associated with optionName.  If optionName was
	not encountered during parsing of the arguments, returns the
	defaultValue (which defaults to None).
	"""
	try:
		optionValue = self.optionValues[optionName]
	except:
		optionValue = defaultValue

	return optionValue
</t>
<t tx="ekr.20050704165326.92">##
## test/example section
##
test_error = 'Test Run Amok!'
def _test():
	"""
	A relatively complete test suite.
	"""
	try:
		DPyGetOpt(['foo', 'bar=s', 'foo'])
	except:
		print 'EXCEPTION (should be \'foo\' already used..): ' + sys.exc_value

	try:
		DPyGetOpt(['foo|bar|apple=s@', 'baz|apple!'])
	except:
		print 'EXCEPTION (should be duplicate alias/name error): ' + sys.exc_value

	x = DPyGetOpt(['apple|atlas=i@', 'application|executable=f@'])
	try:
		x.processArguments(['-app', '29.3'])
	except:
		print 'EXCEPTION (should be ambiguous argument): ' +	sys.exc_value

	x = DPyGetOpt(['foo'], ['antigravity', 'antithesis'])
	try:
		x.processArguments(['-foo', 'anti'])
	except:
		print 'EXCEPTION (should be ambiguous terminator): ' + sys.exc_value

	profile = ['plain-option',
				  'boolean-option!',
				  'list-of-integers=i@',
				  'list-real-option|list-real-alias|list-real-pseudonym=f@',
				  'optional-string-option:s',
				  'abbreviated-string-list=s@']

	terminators = ['terminator']

	args = ['-plain-option',
			  '+noboolean-option',
			  '--list-of-integers', '1',
			  '+list-of-integers', '2',
			  '-list-of-integers', '3',
			  'freeargone',
			  '-list-real-option', '1.1',
			  '+list-real-alias', '1.2',
			  '--list-real-pseudonym', '1.3',
			  'freeargtwo',
			  '-abbreviated-string-list', 'String1',
			  '--abbreviated-s', 'String2',
			  '-abbrev', 'String3',
			  '-a', 'String4',
			  '-optional-string-option',
			  'term',
			  'next option should look like an invalid arg',
			  '-a']


	print 'Using profile: ' + repr(profile)
	print 'With terminator: ' + repr(terminators)
	print 'Processing arguments: ' + repr(args)

	go = DPyGetOpt(profile, terminators)
	go.processArguments(args)

	print 'Options (and values): ' + repr(go.optionValues)
	print 'free args: ' + repr(go.freeValues)
	print 'term args: ' + repr(go.termValues)
</t>
<t tx="ekr.20050704165326.93">
@language python
&lt;&lt; FakeModule declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704165326.94"># -*- coding: utf-8 -*-
"""
Class which mimics a module.

Needed to allow pickle to correctly resolve namespaces during IPython
sessions.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2002-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

</t>
<t tx="ekr.20050704165326.95">class FakeModule:
    """Simple class with attribute access to fake a module.

    This is not meant to replace a module, but to allow inserting a fake
    module in sys.modules so that systems which rely on run-time module
    importing (like shelve and pickle) work correctly in interactive IPython
    sessions.

    Do NOT use this code for anything other than this IPython private hack."""
	@others
</t>
<t tx="ekr.20050704165326.96">def __init__(self,adict):

    # It seems pydoc (and perhaps others) needs any module instance to
    # implement a __nonzero__ method, so we add it if missing:
    if '__nonzero__' not in adict:
        def __nonzero__():
            return 1
        adict['__nonzero__'] = __nonzero__

        self.__dict__ = adict
</t>
<t tx="ekr.20050704165326.97">def __getattr__(self,key):
    try:
        return self.__dict__[key]
    except KeyError, e:
        raise AttributeError("FakeModule object has no attribute %s" % e)
</t>
<t tx="ekr.20050704165326.98">def __str__(self):
    return "&lt;IPython.FakeModule instance&gt;"
</t>
<t tx="ekr.20050704165326.99">def __repr__(self):
    return str(self)
</t>
<t tx="ekr.20050704165326.100">
@language python
&lt;&lt; FlexCompleter declarations &gt;&gt;
@others

readline.set_completer(Completer().complete)
</t>
<t tx="ekr.20050704165326.101"># -*- coding: utf-8 -*-
"""Word completion for GNU readline 2.0.

---------------------------------------------------------------------------
NOTE: This version is a re-implementation of rlcompleter with selectable
namespace.

The problem with rlcompleter is that it's hardwired to work with
__main__.__dict__, and in some cases one may have 'sandboxed' namespaces. So
this class is a ripoff of rlcompleter, with the namespace to work in as an
optional parameter.

This class can be used just like rlcompleter, but the Completer class now has
a constructor with the optional 'namespace' parameter.

A patch has been submitted to Python@sourceforge for these changes to go in
the standard Python distribution.

The patch went in for Python 2.3.  Once IPython drops support for Python 2.2,
this file can be significantly reduced.
---------------------------------------------------------------------------

Original rlcompleter documentation:

This requires the latest extension to the readline module (the
completes keywords, built-ins and globals in __main__; when completing
NAME.NAME..., it evaluates (!) the expression up to the last dot and
completes its attributes.

It's very cool to do "import string" type "string.", hit the
completion key (twice), and see the list of names defined by the
string module!

Tip: to use the tab key as the completion key, call

    readline.parse_and_bind("tab: complete")

Notes:

- Exceptions raised by the completer function are *ignored* (and
generally cause the completion to fail).  This is a feature -- since
readline sets the tty device in raw (or cbreak) mode, printing a
traceback wouldn't work well without some complicated hoopla to save,
reset and restore the tty state.

- The evaluation of the NAME.NAME... form may cause arbitrary
application defined code to be executed if an object with a
__getattr__ hook is found.  Since it is the responsibility of the
application (or the user) to enable this feature, I consider this an
acceptable risk.  More complicated expressions (e.g. function calls or
indexing operations) are *not* evaluated.

- GNU readline is also used by the built-in functions input() and
raw_input(), and thus these also benefit/suffer from the completer
features.  Clearly an interactive application can benefit by
specifying its own completer function and using raw_input() for all
its input.

- When the original stdin is not a tty device, GNU readline is never
used, and this module (and the readline module) are silently inactive.

"""

#*****************************************************************************
#
# Since this file is essentially a minimally modified copy of the rlcompleter
# module which is part of the standard Python distribution, I assume that the
# proper procedure is to maintain its copyright as belonging to the Python
# Software Foundation:
#
#       Copyright (C) 2001 Python Software Foundation, www.python.org
#
#  Distributed under the terms of the Python Software Foundation license.
#
#  Full text available at:
#
#                  http://www.python.org/2.1/license.html
#
#*****************************************************************************

import readline
import __builtin__
import __main__

__all__ = ["Completer"]

</t>
<t tx="ekr.20050704165326.102">class Completer:
	@others
</t>
<t tx="ekr.20050704165326.103">def __init__(self, namespace = None):
    """Create a new completer for the command line.

    Completer([namespace]) -&gt; completer instance.

    If unspecified, the default namespace where completions are performed
    is __main__ (technically, __main__.__dict__). Namespaces should be
    given as dictionaries.

    Completer instances should be used as the completion mechanism of
    readline via the set_completer() call:

    readline.set_completer(Completer(my_namespace).complete)
    """
    
    if namespace and type(namespace) != type({}):
        raise TypeError,'namespace must be a dictionary'

    # Don't bind to namespace quite yet, but flag whether the user wants a
    # specific namespace or to use __main__.__dict__. This will allow us
    # to bind to __main__.__dict__ at completion time, not now.
    if namespace is None:
        self.use_main_ns = 1
    else:
        self.use_main_ns = 0
        self.namespace = namespace
</t>
<t tx="ekr.20050704165326.104">def complete(self, text, state):
    """Return the next possible completion for 'text'.

    This is called successively with state == 0, 1, 2, ... until it
    returns None.  The completion should begin with 'text'.

    """
    if self.use_main_ns:
        self.namespace = __main__.__dict__
        
    if state == 0:
        if "." in text:
            self.matches = self.attr_matches(text)
        else:
            self.matches = self.global_matches(text)
    try:
        return self.matches[state]
    except IndexError:
        return None
</t>
<t tx="ekr.20050704165326.105">def global_matches(self, text):
    """Compute matches when text is a simple name.

    Return a list of all keywords, built-in functions and names currently
    defined in self.namespace that match.

    """
    import keyword
    matches = []
    n = len(text)
    for list in [keyword.kwlist,
                 __builtin__.__dict__.keys(),
                 self.namespace.keys()]:
        for word in list:
            if word[:n] == text and word != "__builtins__":
                matches.append(word)
    return matches
</t>
<t tx="ekr.20050704165326.106">def attr_matches(self, text):
    """Compute matches when text contains a dot.

    Assuming the text is of the form NAME.NAME....[NAME], and is
    evaluatable in self.namespace, it will be evaluated and its attributes
    (as revealed by dir()) are used as possible completions.  (For class
    instances, class members are are also considered.)

    WARNING: this can still invoke arbitrary C code, if an object
    with a __getattr__ hook is evaluated.

    """
    import re

    # Another option, seems to work great. Catches things like ''.&lt;tab&gt;
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", text)

    if not m:
        return []
    expr, attr = m.group(1, 3)
    object = eval(expr, self.namespace)
    words = dir(object)
    if hasattr(object,'__class__'):
        words.append('__class__')
        words.extend(get_class_members(object.__class__))
    n = len(attr)
    matches = []
    for word in words:
        try:
            if word[:n] == attr and word != "__builtins__":
                matches.append("%s.%s" % (expr, word))
        except:
            # some badly behaved objects pollute dir() with non-strings,
            # which cause the completion to fail.  This way we skip the
            # bad entries and can still continue processing the others.
            pass
    return matches
</t>
<t tx="ekr.20050704165326.107">def get_class_members(klass):
    ret = dir(klass)
    if hasattr(klass,'__bases__'):
        for base in klass.__bases__:
            ret.extend(get_class_members(base))
    return ret
</t>
<t tx="ekr.20050704165326.108">
@language python
&lt;&lt; genutils declarations &gt;&gt;
@others
#*************************** end of file &lt;genutils.py&gt; **********************

</t>
<t tx="ekr.20050704165326.109"># -*- coding: utf-8 -*-
"""
General purpose utilities.

This is a grab-bag of stuff I find useful in most programs I write. Some of
these things are also convenient when working at the command line.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

#****************************************************************************
# required modules
import __main__
import types,commands,time,sys,os,re,shutil
import tempfile
from IPython.Itpl import Itpl,itpl,printpl
from IPython import DPyGetOpt

#****************************************************************************
# Exceptions
</t>
<t tx="ekr.20050704165326.110">class Error(Exception):
    """Base class for exceptions in this module."""
	&lt;&lt; class Error declarations &gt;&gt;
</t>
<t tx="ekr.20050704165326.111">pass

#----------------------------------------------------------------------------
</t>
<t tx="ekr.20050704165326.112">class Stream:
    """Simple class to hold the various I/O streams in Term"""
	@others
</t>
<t tx="ekr.20050704165326.113">def __init__(self,stream,name):
    self.stream = stream
    self.name = name
    try:
        self.fileno = stream.fileno()
    except AttributeError:
        msg = ("Stream &lt;%s&gt; looks suspicious: it lacks a 'fileno' attribute."
               % name)
        print &gt;&gt; sys.stderr, 'WARNING:',msg
    try:
        self.mode = stream.mode
    except AttributeError:
        msg = ("Stream &lt;%s&gt; looks suspicious: it lacks a 'mode' attribute."
               % name)
        print &gt;&gt; sys.stderr, 'WARNING:',msg
</t>
<t tx="ekr.20050704165326.114">
class Term:
    """ Term holds the file or file-like objects for handling I/O operations.

    These are normally just sys.stdin, sys.stdout and sys.stderr but for
    Windows they can can replaced to allow editing the strings before they are
    displayed."""
	&lt;&lt; class Term declarations &gt;&gt;
	@others
    set_stderr = classmethod(set_stderr)</t>
<t tx="ekr.20050704165326.115"># In the future, having IPython channel all its I/O operations through
# this class will make it easier to embed it into other environments which
# are not a normal terminal (such as a GUI-based shell)
in_s  = Stream(sys.stdin,'cin')
out_s = Stream(sys.stdout,'cout')
err_s = Stream(sys.stderr,'cerr')

# Store the three streams in (err,out,in) order so that if we need to reopen
# them, the error channel is reopened first to provide info.
streams = [err_s,out_s,in_s]

# The class globals should be the actual 'bare' streams for normal I/O to work
cin  = streams[2].stream
cout = streams[1].stream
cerr = streams[0].stream

</t>
<t tx="ekr.20050704165326.116">def reopen_all(cls):
    """Reopen all streams if necessary.

    This should only be called if it is suspected that someting closed
    accidentally one of the I/O streams."""

    any_closed = 0

    for sn in range(len(cls.streams)):
        st = cls.streams[sn]
        if st.stream.closed:
            any_closed = 1
            new_stream = os.fdopen(os.dup(st.fileno), st.mode,0)
            cls.streams[sn] = Stream(new_stream,st.name)
            print &gt;&gt; cls.streams[0].stream, \
                  '\nWARNING:\nStream Term.%s had to be reopened!' % st.name

    # Rebuild the class globals
    cls.cin = cls.streams[2].stream
    cls.cout = cls.streams[1].stream
    cls.cerr = cls.streams[0].stream
</t>
<t tx="ekr.20050704165326.117">reopen_all = classmethod(reopen_all)

def set_stdout(cls,stream):
    """Set the stream """
    cls.cout = stream
</t>
<t tx="ekr.20050704165326.118">set_stdout = classmethod(set_stdout)

def set_stderr(cls,stream):
    cls.cerr = stream
</t>
<t tx="ekr.20050704165326.119"># Windows-specific code to load Gary Bishop's readline and configure it
# automatically for the users
# Note: os.name on cygwin returns posix, so this should only pick up 'native'
# windows.  Cygwin returns 'cygwin' for sys.platform.
if os.name == 'nt':
    try:
        import readline
    except ImportError:
        pass
    else:
        try:
            _out = readline.GetOutputFile()
        except AttributeError:
            pass
        else:
            Term.set_stdout(_out)
            Term.set_stderr(_out)
            del _out

#****************************************************************************
# Generic warning/error printer, used by everything else
def warn(msg,level=2,exit_val=1):
    """Standard warning printer. Gives formatting consistency.

    Output is sent to Term.cerr (sys.stderr by default).
    
    Options:
    
    -level(2): allows finer control:
      0 -&gt; Do nothing, dummy function.
      1 -&gt; Print message.
      2 -&gt; Print 'WARNING:' + message. (Default level).
      3 -&gt; Print 'ERROR:' + message.
      4 -&gt; Print 'FATAL ERROR:' + message and trigger a sys.exit(exit_val).

    -exit_val (1): exit value returned by sys.exit() for a level 4
    warning. Ignored for all other levels."""
    
    if level&gt;0:
        header = ['','','WARNING: ','ERROR: ','FATAL ERROR: ']
        print &gt;&gt; Term.cerr, '%s%s' % (header[level],msg)
        if level == 4:
            print &gt;&gt; Term.cerr,'Exiting.\n'
            sys.exit(exit_val)
</t>
<t tx="ekr.20050704165326.120">def info(msg):
    """Equivalent to warn(msg,level=1)."""

    warn(msg,level=1)
</t>
<t tx="ekr.20050704165326.121">def error(msg):
    """Equivalent to warn(msg,level=3)."""

    warn(msg,level=3)
</t>
<t tx="ekr.20050704165326.122">def fatal(msg,exit_val=1):
    """Equivalent to warn(msg,exit_val=exit_val,level=4)."""

    warn(msg,exit_val=exit_val,level=4)
</t>
<t tx="ekr.20050704165326.123">#----------------------------------------------------------------------------
StringTypes = types.StringTypes

# Basic timing functionality

# If possible (Unix), use the resource module instead of time.clock()
try:
    import resource
    def clock():
        """clock() -&gt; floating point number

        Return the CPU time in seconds (user time only, system time is
        ignored) since the start of the process.  This is done via a call to
        resource.getrusage, so it avoids the wraparound problems in
        time.clock()."""
        
        return resource.getrusage(resource.RUSAGE_SELF)[0]
    
    def clock2():
        """clock2() -&gt; (t_user,t_system)

        Similar to clock(), but return a tuple of user/system times."""
        return resource.getrusage(resource.RUSAGE_SELF)[:2]
</t>
<t tx="ekr.20050704165326.124">except ImportError:
    clock = time.clock
    def clock2():
        """Under windows, system CPU time can't be measured.

        This just returns clock() and zero."""
        return time.clock(),0.0
</t>
<t tx="ekr.20050704165326.125">def timings_out(reps,func,*args,**kw):
    """timings_out(reps,func,*args,**kw) -&gt; (t_total,t_per_call,output)

    Execute a function reps times, return a tuple with the elapsed total
    CPU time in seconds, the time per call and the function's output.

    Under Unix, the return value is the sum of user+system time consumed by
    the process, computed via the resource module.  This prevents problems
    related to the wraparound effect which the time.clock() function has.
    
    Under Windows the return value is in wall clock seconds. See the
    documentation for the time module for more details."""

    reps = int(reps)
    assert reps &gt;=1, 'reps must be &gt;= 1'
    if reps==1:
        start = clock()
        out = func(*args,**kw)
        tot_time = clock()-start
    else:
        rng = xrange(reps-1) # the last time is executed separately to store output
        start = clock()
        for dummy in rng: func(*args,**kw)
        out = func(*args,**kw)  # one last time
        tot_time = clock()-start
    av_time = tot_time / reps
    return tot_time,av_time,out
</t>
<t tx="ekr.20050704165326.126">def timings(reps,func,*args,**kw):
    """timings(reps,func,*args,**kw) -&gt; (t_total,t_per_call)

    Execute a function reps times, return a tuple with the elapsed total CPU
    time in seconds and the time per call. These are just the first two values
    in timings_out()."""

    return timings_out(reps,func,*args,**kw)[0:2]
</t>
<t tx="ekr.20050704165326.127">def timing(func,*args,**kw):
    """timing(func,*args,**kw) -&gt; t_total

    Execute a function once, return the elapsed total CPU time in
    seconds. This is just the first value in timings_out()."""

    return timings_out(1,func,*args,**kw)[0]
</t>
<t tx="ekr.20050704165326.128">#****************************************************************************
# file and system

def system(cmd,verbose=0,debug=0,header=''):
    """Execute a system command, return its exit status.

    Options:

    - verbose (0): print the command to be executed.
    
    - debug (0): only print, do not actually execute.

    - header (''): Header to print on screen prior to the executed command (it
    is only prepended to the command, no newlines are added).

    Note: a stateful version of this function is available through the
    SystemExec class."""

    stat = 0
    if verbose or debug: print header+cmd
    sys.stdout.flush()
    if not debug: stat = os.system(cmd)
    return stat
</t>
<t tx="ekr.20050704165326.129">def shell(cmd,verbose=0,debug=0,header=''):
    """Execute a command in the system shell, always return None.

    Options:

    - verbose (0): print the command to be executed.
    
    - debug (0): only print, do not actually execute.

    - header (''): Header to print on screen prior to the executed command (it
    is only prepended to the command, no newlines are added).

    Note: this is similar to genutils.system(), but it returns None so it can
    be conveniently used in interactive loops without getting the return value
    (typically 0) printed many times."""

    stat = 0
    if verbose or debug: print header+cmd
    # flush stdout so we don't mangle python's buffering
    sys.stdout.flush()
    if not debug:
        os.system(cmd)
</t>
<t tx="ekr.20050704165326.130">def getoutput(cmd,verbose=0,debug=0,header='',split=0):
    """Dummy substitute for perl's backquotes.

    Executes a command and returns the output.

    Accepts the same arguments as system(), plus:

    - split(0): if true, the output is returned as a list split on newlines.

    Note: a stateful version of this function is available through the
    SystemExec class."""

    if verbose or debug: print header+cmd
    if not debug:
        output = commands.getoutput(cmd)
        if split:
            return output.split('\n')
        else:
            return output
</t>
<t tx="ekr.20050704165326.131">def getoutputerror(cmd,verbose=0,debug=0,header='',split=0):
    """Return (standard output,standard error) of executing cmd in a shell.

    Accepts the same arguments as system(), plus:

    - split(0): if true, each of stdout/err is returned as a list split on
    newlines.

    Note: a stateful version of this function is available through the
    SystemExec class."""

    if verbose or debug: print header+cmd
    if not cmd:
        if split:
            return [],[]
        else:
            return '',''
    if not debug:
        pin,pout,perr = os.popen3(cmd)
        tout = pout.read().rstrip()
        terr = perr.read().rstrip()
        pin.close()
        pout.close()
        perr.close()
        if split:
            return tout.split('\n'),terr.split('\n')
        else:
            return tout,terr
</t>
<t tx="ekr.20050704165326.132">
# for compatibility with older naming conventions
xsys = system
bq = getoutput

class SystemExec:
    """Access the system and getoutput functions through a stateful interface.

    Note: here we refer to the system and getoutput functions from this
    library, not the ones from the standard python library.
    
    This class offers the system and getoutput functions as methods, but the
    verbose, debug and header parameters can be set for the instance (at
    creation time or later) so that they don't need to be specified on each
    call.

    For efficiency reasons, there's no way to override the parameters on a
    per-call basis other than by setting instance attributes. If you need
    local overrides, it's best to directly call system() or getoutput().

    The following names are provided as alternate options:
     - xsys: alias to system
     - bq: alias to getoutput

    An instance can then be created as:
     &gt;&gt;&gt; sysexec = SystemExec(verbose=1,debug=0,header='Calling: ')

    And used as:
     &gt;&gt;&gt; sysexec.xsys('pwd')
     &gt;&gt;&gt; dirlist = sysexec.bq('ls -l')
    """
	@others

    bq = getoutput  # alias</t>
<t tx="ekr.20050704165326.133">def __init__(self,verbose=0,debug=0,header='',split=0):
    """Specify the instance's values for verbose, debug and header."""
    setattr_list(self,'verbose debug header split')
</t>
<t tx="ekr.20050704165326.134">def system(self,cmd):
    """Stateful interface to system(), with the same keyword parameters."""

    system(cmd,self.verbose,self.debug,self.header)
</t>
<t tx="ekr.20050704165326.135">def shell(self,cmd):
    """Stateful interface to shell(), with the same keyword parameters."""

    shell(cmd,self.verbose,self.debug,self.header)
</t>
<t tx="ekr.20050704165326.136">xsys = system  # alias

def getoutput(self,cmd):
    """Stateful interface to getoutput()."""

    return getoutput(cmd,self.verbose,self.debug,self.header,self.split)
</t>
<t tx="ekr.20050704165326.137">def getoutputerror(self,cmd):
    """Stateful interface to getoutputerror()."""

    return getoutputerror(cmd,self.verbose,self.debug,self.header,self.split)
</t>
<t tx="ekr.20050704165326.138">#-----------------------------------------------------------------------------
def mutex_opts(dict,ex_op):
    """Check for presence of mutually exclusive keys in a dict.

    Call: mutex_opts(dict,[[op1a,op1b],[op2a,op2b]...]"""
    for op1,op2 in ex_op:
        if op1 in dict and op2 in dict:
            raise ValueError,'\n*** ERROR in Arguments *** '\
                  'Options '+op1+' and '+op2+' are mutually exclusive.'
</t>
<t tx="ekr.20050704165326.139">#-----------------------------------------------------------------------------
def filefind(fname,alt_dirs = None):
    """Return the given filename either in the current directory, if it
    exists, or in a specified list of directories.

    ~ expansion is done on all file and directory names.

    Upon an unsuccessful search, raise an IOError exception."""

    if alt_dirs is None:
        try:
            alt_dirs = get_home_dir()
        except HomeDirError:
            alt_dirs = os.getcwd()
    search = [fname] + list_strings(alt_dirs)
    search = map(os.path.expanduser,search)
    #print 'search list for',fname,'list:',search  # dbg
    fname = search[0]
    if os.path.isfile(fname):
        return fname
    for direc in search[1:]:
        testname = os.path.join(direc,fname)
        #print 'testname',testname  # dbg
        if os.path.isfile(testname):
            return testname
    raise IOError,'File' + `fname` + \
          ' not found in current or supplied directories:' + `alt_dirs`
</t>
<t tx="ekr.20050704165326.140">#----------------------------------------------------------------------------
def target_outdated(target,deps):
    """Determine whether a target is out of date.

    target_outdated(target,deps) -&gt; 1/0

    deps: list of filenames which MUST exist.
    target: single filename which may or may not exist.

    If target doesn't exist or is older than any file listed in deps, return
    true, otherwise return false.
    """
    try:
        target_time = os.path.getmtime(target)
    except os.error:
        return 1
    for dep in deps:
        dep_time = os.path.getmtime(dep)
        if dep_time &gt; target_time:
            #print "For target",target,"Dep failed:",dep # dbg
            #print "times (dep,tar):",dep_time,target_time # dbg
            return 1
    return 0
</t>
<t tx="ekr.20050704165326.141">#-----------------------------------------------------------------------------
def target_update(target,deps,cmd):
    """Update a target with a given command given a list of dependencies.

    target_update(target,deps,cmd) -&gt; runs cmd if target is outdated.

    This is just a wrapper around target_outdated() which calls the given
    command if target is outdated."""

    if target_outdated(target,deps):
        xsys(cmd)
</t>
<t tx="ekr.20050704165326.142">#----------------------------------------------------------------------------
def unquote_ends(istr):
    """Remove a single pair of quotes from the endpoints of a string."""

    if not istr:
        return istr
    if (istr[0]=="'" and istr[-1]=="'") or \
       (istr[0]=='"' and istr[-1]=='"'):
        return istr[1:-1]
    else:
        return istr
</t>
<t tx="ekr.20050704165326.143">#----------------------------------------------------------------------------
def process_cmdline(argv,names=[],defaults={},usage=''):
    """ Process command-line options and arguments.

    Arguments:

    - argv: list of arguments, typically sys.argv.
    
    - names: list of option names. See DPyGetOpt docs for details on options
    syntax.

    - defaults: dict of default values.

    - usage: optional usage notice to print if a wrong argument is passed.

    Return a dict of options and a list of free arguments."""

    getopt = DPyGetOpt.DPyGetOpt()
    getopt.setIgnoreCase(0)
    getopt.parseConfiguration(names)

    try:
        getopt.processArguments(argv)
    except:
        print usage
        warn(`sys.exc_value`,level=4)

    defaults.update(getopt.optionValues)
    args = getopt.freeValues
    
    return defaults,args
</t>
<t tx="ekr.20050704165326.144">#----------------------------------------------------------------------------
def optstr2types(ostr):
    """Convert a string of option names to a dict of type mappings.

    optstr2types(str) -&gt; {None:'string_opts',int:'int_opts',float:'float_opts'}

    This is used to get the types of all the options in a string formatted
    with the conventions of DPyGetOpt. The 'type' None is used for options
    which are strings (they need no further conversion). This function's main
    use is to get a typemap for use with read_dict().
    """

    typeconv = {None:'',int:'',float:''}
    typemap = {'s':None,'i':int,'f':float}
    opt_re = re.compile(r'([\w]*)([^:=]*:?=?)([sif]?)')

    for w in ostr.split():
        oname,alias,otype = opt_re.match(w).groups()
        if otype == '' or alias == '!':   # simple switches are integers too
            otype = 'i'
        typeconv[typemap[otype]] += oname + ' '
    return typeconv
</t>
<t tx="ekr.20050704165326.145">#----------------------------------------------------------------------------
def read_dict(filename,type_conv=None,**opt):

    """Read a dictionary of key=value pairs from an input file, optionally
    performing conversions on the resulting values.

    read_dict(filename,type_conv,**opt) -&gt; dict

    Only one value per line is accepted, the format should be
     # optional comments are ignored
     key value\n

    Args:

      - type_conv: A dictionary specifying which keys need to be converted to
      which types. By default all keys are read as strings. This dictionary
      should have as its keys valid conversion functions for strings
      (int,long,float,complex, or your own).  The value for each key
      (converter) should be a whitespace separated string containing the names
      of all the entries in the file to be converted using that function. For
      keys to be left alone, use None as the conversion function (only needed
      with purge=1, see below).

      - opt: dictionary with extra options as below (default in parens)

        purge(0): if set to 1, all keys *not* listed in type_conv are purged out
        of the dictionary to be returned. If purge is going to be used, the
        set of keys to be left as strings also has to be explicitly specified
        using the (non-existent) conversion function None.

        fs(None): field separator. This is the key/value separator to be used
        when parsing the file. The None default means any whitespace [behavior
        of string.split()].

        strip(0): if 1, strip string values of leading/trailinig whitespace.

        warn(1): warning level if requested keys are not found in file.
          - 0: silently ignore.
          - 1: inform but proceed.
          - 2: raise KeyError exception.

        no_empty(0): if 1, remove keys with whitespace strings as a value.

        unique([]): list of keys (or space separated string) which can't be
        repeated. If one such key is found in the file, each new instance
        overwrites the previous one. For keys not listed here, the behavior is
        to make a list of all appearances.

    Example:
    If the input file test.ini has:
      i 3
      x 4.5
      y 5.5
      s hi ho
    Then:

    &gt;&gt;&gt; type_conv={int:'i',float:'x',None:'s'}
    &gt;&gt;&gt; read_dict('test.ini')
    {'i': '3', 's': 'hi ho', 'x': '4.5', 'y': '5.5'}
    &gt;&gt;&gt; read_dict('test.ini',type_conv)
    {'i': 3, 's': 'hi ho', 'x': 4.5, 'y': '5.5'}
    &gt;&gt;&gt; read_dict('test.ini',type_conv,purge=1)
    {'i': 3, 's': 'hi ho', 'x': 4.5}
    """

    # starting config
    opt.setdefault('purge',0)
    opt.setdefault('fs',None)  # field sep defaults to any whitespace
    opt.setdefault('strip',0)
    opt.setdefault('warn',1)
    opt.setdefault('no_empty',0)
    opt.setdefault('unique','')
    if type(opt['unique']) in StringTypes:
        unique_keys = qw(opt['unique'])
    elif type(opt['unique']) in (types.TupleType,types.ListType):
        unique_keys = opt['unique']
    else:
        raise ValueError, 'Unique keys must be given as a string, List or Tuple'

    dict = {}
    # first read in table of values as strings
    file = open(filename,'r')
    for line in file.readlines():
        line = line.strip()
        if len(line) and line[0]=='#': continue
        if len(line)&gt;0:
            lsplit = line.split(opt['fs'],1)
            try:
                key,val = lsplit
            except ValueError:
                key,val = lsplit[0],''
            key = key.strip()
            if opt['strip']: val = val.strip()
            if val == "''" or val == '""': val = ''
            if opt['no_empty'] and (val=='' or val.isspace()):
                continue
            # if a key is found more than once in the file, build a list
            # unless it's in the 'unique' list. In that case, last found in file
            # takes precedence. User beware.
            try:
                if dict[key] and key in unique_keys:
                    dict[key] = val
                elif type(dict[key]) is types.ListType:
                    dict[key].append(val)
                else:
                    dict[key] = [dict[key],val]
            except KeyError:
                dict[key] = val
    # purge if requested
    if opt['purge']:
        accepted_keys = qwflat(type_conv.values())
        for key in dict.keys():
            if key in accepted_keys: continue
            del(dict[key])
    # now convert if requested
    if type_conv==None: return dict
    conversions = type_conv.keys()
    try: conversions.remove(None)
    except: pass
    for convert in conversions:
        for val in qw(type_conv[convert]):
            try:
                dict[val] = convert(dict[val])
            except KeyError,e:
                if opt['warn'] == 0:
                    pass
                elif opt['warn'] == 1:
                    print &gt;&gt;sys.stderr, 'Warning: key',val,\
                          'not found in file',filename
                elif opt['warn'] == 2:
                    raise KeyError,e
                else:
                    raise ValueError,'Warning level must be 0,1 or 2'

    return dict
</t>
<t tx="ekr.20050704165326.146">#----------------------------------------------------------------------------
def flag_calls(func):
    """Wrap a function to detect and flag when it gets called.

    This is a decorator which takes a function and wraps it in a function with
    a 'called' attribute. wrapper.called is initialized to False.

    The wrapper.called attribute is set to False right before each call to the
    wrapped function, so if the call fails it remains False.  After the call
    completes, wrapper.called is set to True and the output is returned.

    Testing for truth in wrapper.called allows you to determine if a call to
    func() was attempted and succeeded."""
    
    def wrapper(*args,**kw):
        wrapper.called = False
        out = func(*args,**kw)
        wrapper.called = True
        return out

    wrapper.called = False
    wrapper.__doc__ = func.__doc__
    return wrapper
</t>
<t tx="ekr.20050704165326.147">
#----------------------------------------------------------------------------
class HomeDirError(Error):
	&lt;&lt; class HomeDirError declarations &gt;&gt;
</t>
<t tx="ekr.20050704165326.148">pass

</t>
<t tx="ekr.20050704165326.149">def get_home_dir():
    """Return the closest possible equivalent to a 'home' directory.

    We first try $HOME.  Absent that, on NT it's $HOMEDRIVE\$HOMEPATH.

    Currently only Posix and NT are implemented, a HomeDirError exception is
    raised for all other OSes. """ #'

    try:
        return os.environ['HOME']
    except KeyError:
        if os.name == 'posix':
            raise HomeDirError,'undefined $HOME, IPython can not proceed.'
        elif os.name == 'nt':
            # For some strange reason, win9x returns 'nt' for os.name.
            try:
                return os.path.join(os.environ['HOMEDRIVE'],os.environ['HOMEPATH'])
            except:
                try:
                    # Use the registry to get the 'My Documents' folder.
                    import _winreg as wreg
                    key = wreg.OpenKey(wreg.HKEY_CURRENT_USER,
                                       "Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders")
                    homedir = wreg.QueryValueEx(key,'Personal')[0]
                    key.Close()
                    return homedir
                except:
                    return 'C:\\'
        elif os.name == 'dos':
            # Desperate, may do absurd things in classic MacOS. May work under DOS.
            return 'C:\\'
        else:
            raise HomeDirError,'support for your operating system not implemented.'
</t>
<t tx="ekr.20050704165326.150">
#****************************************************************************
# strings and text

class LSString(str):
    """String derivative with a special access attributes.

    These are normal strings, but with the special attributes:

        .l (or .list) : value as list (split on newlines).
        .n (or .nlstr): original value (the string itself).
        .s (or .spstr): value as whitespace-separated string.
        
    Any values which require transformations are computed only once and
    cached.

    Such strings are very useful to efficiently interact with the shell, which
    typically only understands whitespace-separated options for commands."""
	@others

    n = nlstr = property(get_nlstr)</t>
<t tx="ekr.20050704165326.151">def get_list(self):
    try:
        return self.__list
    except AttributeError:
        self.__list = self.split('\n')
        return self.__list
</t>
<t tx="ekr.20050704165326.152">l = list = property(get_list)

def get_spstr(self):
    try:
        return self.__spstr
    except AttributeError:
        self.__spstr = self.replace('\n',' ')
        return self.__spstr
</t>
<t tx="ekr.20050704165326.153">s = spstr = property(get_spstr)

def get_nlstr(self):
    return self
</t>
<t tx="ekr.20050704165326.154">

class SList(list):
    """List derivative with a special access attributes.

    These are normal lists, but with the special attributes:

        .l (or .list) : value as list (the list itself).
        .n (or .nlstr): value as a string, joined on newlines.
        .s (or .spstr): value as a string, joined on spaces.

    Any values which require transformations are computed only once and
    cached."""
	@others

    n = nlstr = property(get_nlstr)</t>
<t tx="ekr.20050704165326.155">def get_list(self):
    return self
</t>
<t tx="ekr.20050704165326.156">l = list = property(get_list)

def get_spstr(self):
    try:
        return self.__spstr
    except AttributeError:
        self.__spstr = ' '.join(self)
        return self.__spstr
</t>
<t tx="ekr.20050704165326.157">s = spstr = property(get_spstr)

def get_nlstr(self):
    try:
        return self.__nlstr
    except AttributeError:
        self.__nlstr = '\n'.join(self)
        return self.__nlstr
</t>
<t tx="ekr.20050704165326.158">def raw_input_multi(header='', ps1='==&gt; ', ps2='..&gt; ',terminate_str = '.'):
    """Take multiple lines of input.

    A list with each line of input as a separate element is returned when a
    termination string is entered (defaults to a single '.'). Input can also
    terminate via EOF (^D in Unix, ^Z-RET in Windows).

    Lines of input which end in \\ are joined into single entries (and a
    secondary continuation prompt is issued as long as the user terminates
    lines with \\). This allows entering very long strings which are still
    meant to be treated as single entities.
    """

    try:
        if header:
            header += '\n'
        lines = [raw_input(header + ps1)]
    except EOFError:
        return []
    terminate = [terminate_str]
    try:
        while lines[-1:] != terminate:
            new_line = raw_input(ps1)
            while new_line.endswith('\\'):
                new_line = new_line[:-1] + raw_input(ps2)
            lines.append(new_line)
                
        return lines[:-1]  # don't return the termination command
    except EOFError:
        print
        return lines
</t>
<t tx="ekr.20050704165326.159">#----------------------------------------------------------------------------
def raw_input_ext(prompt='',  ps2='... '):
    """Similar to raw_input(), but accepts extended lines if input ends with \\."""

    line = raw_input(prompt)
    while line.endswith('\\'):
        line = line[:-1] + raw_input(ps2)
    return line
</t>
<t tx="ekr.20050704165326.160">#----------------------------------------------------------------------------
def ask_yes_no(prompt,default=None):
    """Asks a question and returns an integer 1/0 (y/n) answer.

    If default is given (one of 'y','n'), it is used if the user input is
    empty. Otherwise the question is repeated until an answer is given.
    If EOF occurs 20 times consecutively, the default answer is assumed,
    or if there is no default, an exception is raised to prevent infinite
    loops.

    Valid answers are: y/yes/n/no (match is not case sensitive)."""

    answers = {'y':1,'n':0,'yes':1,'no':0}
    ans = None
    eofs, max_eofs = 0, 20
    while ans not in answers.keys():
        try:
            ans = raw_input(prompt+' ').lower()
            if not ans:  # response was an empty string
                ans = default
            eofs = 0
        except (EOFError,KeyboardInterrupt):
            eofs = eofs + 1
            if eofs &gt;= max_eofs:
                if default in answers.keys():
                    ans = default
                else:
                    raise
            
    return answers[ans]
</t>
<t tx="ekr.20050704165326.161">
#----------------------------------------------------------------------------
class EvalDict:
    """
    Emulate a dict which evaluates its contents in the caller's frame.

    Usage:
    &gt;&gt;&gt;number = 19
    &gt;&gt;&gt;text = "python"
    &gt;&gt;&gt;print "%(text.capitalize())s %(number/9.0).1f rules!" % EvalDict()
    """
	&lt;&lt; class EvalDict declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.162">    # This version is due to sismex01@hebmex.com on c.l.py, and is basically a
    # modified (shorter) version of:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66018 by
    # Skip Montanaro (skip@pobox.com).

</t>
<t tx="ekr.20050704165326.163">def __getitem__(self, name):
    frame = sys._getframe(1)
    return eval(name, frame.f_globals, frame.f_locals)
</t>
<t tx="ekr.20050704165326.164">EvalString = EvalDict  # for backwards compatibility
#----------------------------------------------------------------------------
def qw(words,flat=0,sep=None,maxsplit=-1):
    """Similar to Perl's qw() operator, but with some more options.

    qw(words,flat=0,sep=' ',maxsplit=-1) -&gt; words.split(sep,maxsplit)

    words can also be a list itself, and with flat=1, the output will be
    recursively flattened. Examples:

    &gt;&gt;&gt; qw('1 2')
    ['1', '2']
    &gt;&gt;&gt; qw(['a b','1 2',['m n','p q']])
    [['a', 'b'], ['1', '2'], [['m', 'n'], ['p', 'q']]]
    &gt;&gt;&gt; qw(['a b','1 2',['m n','p q']],flat=1)
    ['a', 'b', '1', '2', 'm', 'n', 'p', 'q']    """

    if type(words) in StringTypes:
        return [word.strip() for word in words.split(sep,maxsplit)
                if word and not word.isspace() ]
    if flat:
        return flatten(map(qw,words,[1]*len(words)))
    return map(qw,words)
</t>
<t tx="ekr.20050704165326.165">#----------------------------------------------------------------------------
def qwflat(words,sep=None,maxsplit=-1):
    """Calls qw(words) in flat mode. It's just a convenient shorthand."""
    return qw(words,1,sep,maxsplit)
</t>
<t tx="ekr.20050704165326.166">#-----------------------------------------------------------------------------
def list_strings(arg):
    """Always return a list of strings, given a string or list of strings
    as input."""

    if type(arg) in StringTypes: return [arg]
    else: return arg
</t>
<t tx="ekr.20050704165326.167">#----------------------------------------------------------------------------
def grep(pat,list,case=1):
    """Simple minded grep-like function.
    grep(pat,list) returns occurrences of pat in list, None on failure.

    It only does simple string matching, with no support for regexps. Use the
    option case=0 for case-insensitive matching."""

    # This is pretty crude. At least it should implement copying only references
    # to the original data in case it's big. Now it copies the data for output.
    out=[]
    if case:
        for term in list:
            if term.find(pat)&gt;-1: out.append(term)
    else:
        lpat=pat.lower()
        for term in list:
            if term.lower().find(lpat)&gt;-1: out.append(term)

    if len(out): return out
    else: return None
</t>
<t tx="ekr.20050704165326.168">#----------------------------------------------------------------------------
def dgrep(pat,*opts):
    """Return grep() on dir()+dir(__builtins__).

    A very common use of grep() when working interactively."""

    return grep(pat,dir(__main__)+dir(__main__.__builtins__),*opts)
</t>
<t tx="ekr.20050704165326.169">#----------------------------------------------------------------------------
def idgrep(pat):
    """Case-insensitive dgrep()"""

    return dgrep(pat,0)
</t>
<t tx="ekr.20050704165326.170">#----------------------------------------------------------------------------
def igrep(pat,list):
    """Synonym for case-insensitive grep."""

    return grep(pat,list,case=0)
</t>
<t tx="ekr.20050704165326.171">#----------------------------------------------------------------------------
def indent(str,nspaces=4,ntabs=0):
    """Indent a string a given number of spaces or tabstops.
    
    indent(str,nspaces=4,ntabs=0) -&gt; indent str by ntabs+nspaces.
    """
    if str is None:
        return
    ind = '\t'*ntabs+' '*nspaces
    outstr = '%s%s' % (ind,str.replace(os.linesep,os.linesep+ind))
    if outstr.endswith(os.linesep+ind):
        return outstr[:-len(ind)]
    else:
        return outstr
</t>
<t tx="ekr.20050704165326.172">#-----------------------------------------------------------------------------
def native_line_ends(filename,backup=1):
    """Convert (in-place) a file to line-ends native to the current OS.

    If the optional backup argument is given as false, no backup of the
    original file is left.  """

    backup_suffixes = {'posix':'~','dos':'.bak','nt':'.bak','mac':'.bak'}

    bak_filename = filename + backup_suffixes[os.name]

    original = open(filename).read()
    shutil.copy2(filename,bak_filename)
    try:
        new = open(filename,'wb')
        new.write(os.linesep.join(original.splitlines()))
        new.write(os.linesep) # ALWAYS put an eol at the end of the file
        new.close()
    except:
        os.rename(bak_filename,filename)
    if not backup:
        try:
            os.remove(bak_filename)
        except:
            pass
</t>
<t tx="ekr.20050704165326.173">#----------------------------------------------------------------------------
def get_pager_cmd(pager_cmd = None):
    """Return a pager command.

    Makes some attempts at finding an OS-correct one."""
    
    if os.name == 'posix':
        default_pager_cmd = 'less -r'  # -r for color control sequences
    elif os.name in ['nt','dos']:
        default_pager_cmd = 'type'

    if pager_cmd is None:
        try:
            pager_cmd = os.environ['PAGER']
        except:
            pager_cmd = default_pager_cmd
    return pager_cmd
</t>
<t tx="ekr.20050704165326.174">#-----------------------------------------------------------------------------
def get_pager_start(pager,start):
    """Return the string for paging files with an offset.

    This is the '+N' argument which less and more (under Unix) accept.
    """

    if pager in ['less','more']:
        if start:
            start_string = '+' + str(start)
        else:
            start_string = ''
    else:
        start_string = ''
    return start_string
</t>
<t tx="ekr.20050704165326.175">#----------------------------------------------------------------------------
def page_dumb(strng,start=0,screen_lines=25):
    """Very dumb 'pager' in Python, for when nothing else works.

    Only moves forward, same interface as page(), except for pager_cmd and
    mode."""

    out_ln  = strng.splitlines()[start:]
    screens = chop(out_ln,screen_lines-1)
    if len(screens) == 1:
        print &gt;&gt;Term.cout, os.linesep.join(screens[0])
    else:
        for scr in screens[0:-1]:
            print &gt;&gt;Term.cout, os.linesep.join(scr)
            ans = raw_input('---Return to continue, q to quit--- ')
            if ans.lower().startswith('q'):
                return
        print &gt;&gt;Term.cout, os.linesep.join(screens[-1])
</t>
<t tx="ekr.20050704165326.176">#----------------------------------------------------------------------------
def page(strng,start=0,screen_lines=0,pager_cmd = None):
    """Print a string, piping through a pager after a certain length.

    The screen_lines parameter specifies the number of *usable* lines of your
    terminal screen (total lines minus lines you need to reserve to show other
    information).

    If you set screen_lines to a number &lt;=0, page() will try to auto-determine
    your screen size and will only use up to (screen_size+screen_lines) for
    printing, paging after that. That is, if you want auto-detection but need
    to reserve the bottom 3 lines of the screen, use screen_lines = -3, and for
    auto-detection without any lines reserved simply use screen_lines = 0.

    If a string won't fit in the allowed lines, it is sent through the
    specified pager command. If none given, look for PAGER in the environment,
    and ultimately default to less.

    If no system pager works, the string is sent through a 'dumb pager'
    written in python, very simplistic.
    """
    
    # Ugly kludge, but calling curses.initscr() flat out crashes in emacs
    TERM = os.environ.get('TERM','dumb')
    if TERM in ['dumb','emacs'] and os.name != 'nt':
        print strng
        return
    # chop off the topmost part of the string we don't want to see
    str_lines = strng.split(os.linesep)[start:]
    str_toprint = os.linesep.join(str_lines)
    num_newlines = len(str_lines)
    len_str = len(str_toprint)
    
    # Dumb heuristics to guesstimate number of on-screen lines the string
    # takes.  Very basic, but good enough for docstrings in reasonable
    # terminals. If someone later feels like refining it, it's not hard.
    numlines = max(num_newlines,int(len_str/80)+1)

    screen_lines_def = 25 # default value if we can't auto-determine

    # auto-determine screen size
    if screen_lines &lt;= 0:
        if TERM=='xterm':
            try:
                import curses
                if hasattr(curses,'initscr'):
                    use_curses = 1
                else:
                    use_curses = 0
            except ImportError:
                use_curses = 0
        else:
            # curses causes problems on many terminals other than xterm.
            use_curses = 0
        if use_curses:
                scr = curses.initscr()
                screen_lines_real,screen_cols = scr.getmaxyx()
                curses.endwin()
                screen_lines += screen_lines_real
                #print '***Screen size:',screen_lines_real,'lines x',\
                #screen_cols,'columns.' # dbg
        else:
                screen_lines += screen_lines_def

    #print 'numlines',numlines,'screenlines',screen_lines  # dbg
    if numlines &lt;= screen_lines :
        #print '*** normal print'  # dbg
        print &gt;&gt;Term.cout, str_toprint
    else:
        # Try to open pager and default to internal one if that fails.
        # All failure modes are tagged as 'retval=1', to match the return
        # value of a failed system command.  If any intermediate attempt
        # sets retval to 1, at the end we resort to our own page_dumb() pager.
        pager_cmd = get_pager_cmd(pager_cmd)
        pager_cmd += ' ' + get_pager_start(pager_cmd,start)
        if os.name == 'nt':
            if pager_cmd.startswith('type'):
                # The default WinXP 'type' command is failing on complex strings.
                retval = 1
            else:
                tmpname = tempfile.mktemp('.txt')
                tmpfile = file(tmpname,'wt')
                tmpfile.write(strng)
                tmpfile.close()
                cmd = "%s &lt; %s" % (pager_cmd,tmpname)
                if os.system(cmd):
                  retval = 1
                else:
                  retval = None
                os.remove(tmpname)
        else:
            try:
                retval = None
                # if I use popen4, things hang. No idea why.
                #pager,shell_out = os.popen4(pager_cmd)
                pager = os.popen(pager_cmd,'w')
                pager.write(strng)
                pager.close()
                retval = pager.close()  # success returns None
            except IOError,msg:  # broken pipe when user quits
                if msg.args == (32,'Broken pipe'):
                    retval = None
                else:
                    retval = 1
            except OSError:
                # Other strange problems, sometimes seen in Win2k/cygwin
                retval = 1
        if retval is not None:
            page_dumb(strng,screen_lines=screen_lines)
</t>
<t tx="ekr.20050704165326.177">#----------------------------------------------------------------------------
def page_file(fname,start = 0, pager_cmd = None):
    """Page a file, using an optional pager command and starting line.
    """

    pager_cmd = get_pager_cmd(pager_cmd)
    pager_cmd += ' ' + get_pager_start(pager_cmd,start)

    try:
        if os.environ['TERM'] in ['emacs','dumb']:
            raise EnvironmentError
        xsys(pager_cmd + ' ' + fname)
    except:
        try:
            if start &gt; 0:
                start -= 1
            page(open(fname).read(),start)
        except:
            print 'Unable to show file',`fname`
</t>
<t tx="ekr.20050704165326.178">#----------------------------------------------------------------------------
def snip_print(str,width = 75,print_full = 0,header = ''):
    """Print a string snipping the midsection to fit in width.

    print_full: mode control:
      - 0: only snip long strings
      - 1: send to page() directly.
      - 2: snip long strings and ask for full length viewing with page()
    Return 1 if snipping was necessary, 0 otherwise."""

    if print_full == 1:
        page(header+str)
        return 0

    print header,
    if len(str) &lt; width:
        print str
        snip = 0
    else:
        whalf = int((width -5)/2)
        print str[:whalf] + ' &lt;...&gt; ' + str[-whalf:]
        snip = 1
    if snip and print_full == 2:
        if raw_input(header+' Snipped. View (y/n)? [N]').lower() == 'y':
            page(str)
    return snip
</t>
<t tx="ekr.20050704165326.179">#****************************************************************************
# lists, dicts and structures

def belong(candidates,checklist):
    """Check whether a list of items appear in a given list of options.

    Returns a list of 1 and 0, one for each candidate given."""

    return [x in checklist for x in candidates]
</t>
<t tx="ekr.20050704165326.180">#----------------------------------------------------------------------------
def uniq_stable(elems):
    """uniq_stable(elems) -&gt; list

    Return from an iterable, a list of all the unique elements in the input,
    but maintaining the order in which they first appear.

    A naive solution to this problem which just makes a dictionary with the
    elements as keys fails to respect the stability condition, since
    dictionaries are unsorted by nature.

    Note: All elements in the input must be valid dictionary keys for this
    routine to work, as it internally uses a dictionary for efficiency
    reasons."""
    
    unique = []
    unique_dict = {}
    for nn in elems:
        if nn not in unique_dict:
            unique.append(nn)
            unique_dict[nn] = None
    return unique
</t>
<t tx="ekr.20050704165326.181">
#----------------------------------------------------------------------------
class NLprinter:
    """Print an arbitrarily nested list, indicating index numbers.

    An instance of this class called nlprint is available and callable as a
    function.
    
    nlprint(list,indent=' ',sep=': ') -&gt; prints indenting each level by 'indent'
    and using 'sep' to separate the index from the value. """
	@others
</t>
<t tx="ekr.20050704165326.182">def __init__(self):
    self.depth = 0
</t>
<t tx="ekr.20050704165326.183">def __call__(self,lst,pos='',**kw):
    """Prints the nested list numbering levels."""
    kw.setdefault('indent',' ')
    kw.setdefault('sep',': ')
    kw.setdefault('start',0)
    kw.setdefault('stop',len(lst))
    # we need to remove start and stop from kw so they don't propagate
    # into a recursive call for a nested list.
    start = kw['start']; del kw['start']
    stop = kw['stop']; del kw['stop']
    if self.depth == 0 and 'header' in kw.keys():
        print kw['header']
        
    for idx in range(start,stop):
        elem = lst[idx]
        if type(elem)==type([]):
            self.depth += 1
            self.__call__(elem,itpl('$pos$idx,'),**kw)
            self.depth -= 1
        else:
            printpl(kw['indent']*self.depth+'$pos$idx$kw["sep"]$elem')
</t>
<t tx="ekr.20050704165326.184">nlprint = NLprinter()
#----------------------------------------------------------------------------
def all_belong(candidates,checklist):
    """Check whether a list of items ALL appear in a given list of options.

    Returns a single 1 or 0 value."""

    return 1-(0 in [x in checklist for x in candidates])
</t>
<t tx="ekr.20050704165326.185">#----------------------------------------------------------------------------
def sort_compare(lst1,lst2,inplace = 1):
    """Sort and compare two lists.

    By default it does it in place, thus modifying the lists. Use inplace = 0
    to avoid that (at the cost of temporary copy creation)."""
    if not inplace:
        lst1 = lst1[:]
        lst2 = lst2[:]
    lst1.sort(); lst2.sort()
    return lst1 == lst2
</t>
<t tx="ekr.20050704165326.186">#----------------------------------------------------------------------------
def mkdict(**kwargs):
    """Return a dict from a keyword list.

    It's just syntactic sugar for making ditcionary creation more convenient:
    # the standard way
    &gt;&gt;&gt;data = { 'red' : 1, 'green' : 2, 'blue' : 3 }
    # a cleaner way
    &gt;&gt;&gt;data = dict(red=1, green=2, blue=3)

    If you need more than this, look at the Struct() class."""

    return kwargs
</t>
<t tx="ekr.20050704165326.187">#----------------------------------------------------------------------------
def list2dict(lst):
    """Takes a list of (key,value) pairs and turns it into a dict."""

    dic = {}
    for k,v in lst: dic[k] = v
    return dic
</t>
<t tx="ekr.20050704165326.188">#----------------------------------------------------------------------------
def list2dict2(lst,default=''):
    """Takes a list and turns it into a dict.
    Much slower than list2dict, but more versatile. This version can take
    lists with sublists of arbitrary length (including sclars)."""

    dic = {}
    for elem in lst:
        if type(elem) in (types.ListType,types.TupleType):
            size = len(elem)
            if  size == 0:
                pass
            elif size == 1:
                dic[elem] = default
            else:
                k,v = elem[0], elem[1:]
                if len(v) == 1: v = v[0]
                dic[k] = v
        else:
            dic[elem] = default
    return dic
</t>
<t tx="ekr.20050704165326.189">#----------------------------------------------------------------------------
def flatten(seq):
    """Flatten a list of lists (NOT recursive, only works for 2d lists)."""

    # bug in python??? (YES. Fixed in 2.2, let's leave the kludgy fix in).

    # if the x=0 isn't made, a *global* variable x is left over after calling
    # this function, with the value of the last element in the return
    # list. This does seem like a bug big time to me.

    # the problem is fixed with the x=0, which seems to force the creation of
    # a local name

    x = 0 
    return [x for subseq in seq for x in subseq]
</t>
<t tx="ekr.20050704165326.190">#----------------------------------------------------------------------------
def get_slice(seq,start=0,stop=None,step=1):
    """Get a slice of a sequence with variable step. Specify start,stop,step."""
    if stop == None:
        stop = len(seq)
    item = lambda i: seq[i]
    return map(item,xrange(start,stop,step))
</t>
<t tx="ekr.20050704165326.191">#----------------------------------------------------------------------------
def chop(seq,size):
    """Chop a sequence into chunks of the given size."""
    chunk = lambda i: seq[i:i+size]
    return map(chunk,xrange(0,len(seq),size))
</t>
<t tx="ekr.20050704165326.192">#----------------------------------------------------------------------------
def with(object, **args):
    """Set multiple attributes for an object, similar to Pascal's with.

    Example:
    with(jim,
         born = 1960,
         haircolour = 'Brown',
         eyecolour = 'Green')

    Credit: Greg Ewing, in
    http://mail.python.org/pipermail/python-list/2001-May/040703.html"""

    object.__dict__.update(args)
</t>
<t tx="ekr.20050704165326.193">#----------------------------------------------------------------------------
def setattr_list(obj,alist,nspace = None):
    """Set a list of attributes for an object taken from a namespace.

    setattr_list(obj,alist,nspace) -&gt; sets in obj all the attributes listed in
    alist with their values taken from nspace, which must be a dict (something
    like locals() will often do) If nspace isn't given, locals() of the
    *caller* is used, so in most cases you can omit it.

    Note that alist can be given as a string, which will be automatically
    split into a list on whitespace. If given as a list, it must be a list of
    *strings* (the variable names themselves), not of variables."""

    # this grabs the local variables from the *previous* call frame -- that is
    # the locals from the function that called setattr_list().
    # - snipped from weave.inline()
    if nspace is None:
        call_frame = sys._getframe().f_back
        nspace = call_frame.f_locals

    if type(alist) in StringTypes:
        alist = alist.split()
    for attr in alist:
        val = eval(attr,nspace)
        setattr(obj,attr,val)
</t>
<t tx="ekr.20050704165326.194">#----------------------------------------------------------------------------
def getattr_list(obj,alist,*args):
    """getattr_list(obj,alist[, default]) -&gt; attribute list.

    Get a list of named attributes for an object. When a default argument is
    given, it is returned when the attribute doesn't exist; without it, an
    exception is raised in that case.

    Note that alist can be given as a string, which will be automatically
    split into a list on whitespace. If given as a list, it must be a list of
    *strings* (the variable names themselves), not of variables."""

    if type(alist) in StringTypes:
        alist = alist.split()
    if args:
        if len(args)==1:
            default = args[0]
            return map(lambda attr: getattr(obj,attr,default),alist)
        else:
            raise ValueError,'getattr_list() takes only one optional argument'
    else:
        return map(lambda attr: getattr(obj,attr),alist)
</t>
<t tx="ekr.20050704165326.195">#----------------------------------------------------------------------------
def map_method(method,object_list,*argseq,**kw):
    """map_method(method,object_list,*args,**kw) -&gt; list

    Return a list of the results of applying the methods to the items of the
    argument sequence(s).  If more than one sequence is given, the method is
    called with an argument list consisting of the corresponding item of each
    sequence. All sequences must be of the same length.

    Keyword arguments are passed verbatim to all objects called.

    This is Python code, so it's not nearly as fast as the builtin map()."""

    out_list = []
    idx = 0
    for object in object_list:
        try:
            handler = getattr(object, method)
        except AttributeError:
            out_list.append(None)
        else:
            if argseq:
                args = map(lambda lst:lst[idx],argseq)
                #print 'ob',object,'hand',handler,'ar',args # dbg
                out_list.append(handler(args,**kw))
            else:
                out_list.append(handler(**kw))
        idx += 1
    return out_list
</t>
<t tx="ekr.20050704165326.196">
#----------------------------------------------------------------------------
# Proposed popitem() extension, written as a method

class NotGiven: pass
</t>
<t tx="ekr.20050704165326.197">def popkey(dct,key,default=NotGiven):
    """Return dct[key] and delete dct[key].

    If default is given, return it if dct[key] doesn't exist, otherwise raise
    KeyError.  """

    try:
        val = dct[key]
    except KeyError:
        if default is NotGiven:
            raise
        else:
            return default
    else:
        del dct[key]
        return val
</t>
<t tx="ekr.20050704165326.198">
@language python
&lt;&lt; Gnuplot2 declarations &gt;&gt;
@others

#********************** End of file &lt;Gnuplot2.py&gt; ************************
</t>
<t tx="ekr.20050704165326.199"># -*- coding: utf-8 -*-
"""Improved replacement for the Gnuplot.Gnuplot class.

This module imports Gnuplot and replaces some of its functionality with
improved versions. They add better handling of arrays for plotting and more
convenient PostScript generation, plus some fixes for hardcopy().

It also adds a convenient plot2 method for plotting dictionaries and
lists/tuples of arrays.

This module is meant to be used as a drop-in replacement to the original
Gnuplot, so it should be safe to do:

import IPython.Gnuplot2 as Gnuplot

$Id$"""

import string,os,time,types
import cStringIO
import sys
import tempfile
import Numeric
import Gnuplot as Gnuplot_ori
from IPython.genutils import popkey,xsys

# needed by hardcopy():
gp = Gnuplot_ori.gp

# Patch for Gnuplot.py 1.6 compatibility.
# Thanks to Hayden Callow &lt;h.callow@elec.canterbury.ac.nz&gt;
try:
    OptionException = Gnuplot_ori.PlotItems.OptionException
except AttributeError:
    OptionException = Gnuplot_ori.Errors.OptionError

# exhibit a similar interface to Gnuplot so it can be somewhat drop-in
Data      = Gnuplot_ori.Data
Func      = Gnuplot_ori.Func
GridData  = Gnuplot_ori.GridData
PlotItem  = Gnuplot_ori.PlotItem
PlotItems = Gnuplot_ori.PlotItems

# Modify some of Gnuplot's functions with improved versions (or bugfixed, in
# hardcopy's case). In order to preserve the docstrings at runtime, I've
# copied them from the original code.

# After some significant changes in v 1.7 of Gnuplot.py, we need to do a bit
# of version checking.

if Gnuplot_ori.__version__ &lt;= '1.6':
    _BaseFileItem = PlotItems.File
    _BaseTempFileItem = PlotItems.TempFile

    # Fix the File class to add the 'index' option for Gnuplot versions &lt; 1.7
</t>
<t tx="ekr.20050704165326.200">class File(_BaseFileItem):
	&lt;&lt; class File declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.201">_option_list = _BaseFileItem._option_list.copy()
_option_list.update({
    'index' : lambda self, index: self.set_option_index(index),
    })

# A new initializer is needed b/c we want to add a modified
# _option_sequence list which includes 'index' in the right place.
</t>
<t tx="ekr.20050704165326.202">def __init__(self,*args,**kw):
    self._option_sequence = ['binary', 'index', 'using', 'smooth', 'axes',
                 'title', 'with']

    _BaseFileItem.__init__(self,*args,**kw)
</t>
<t tx="ekr.20050704165326.203"># Let's fix the constructor docstring
__newdoc = \
    """Additional Keyword arguments added by IPython:

     'index=&lt;int&gt;' -- similar to the `index` keyword in Gnuplot.
         This allows only some of the datasets in a file to be
         plotted. Datasets within a file are assumed to be separated
         by _pairs_ of blank lines, and the first one is numbered as
         0 (similar to C/Python usage)."""
__init__.__doc__ = PlotItems.File.__init__.__doc__ + __newdoc

def set_option_index(self, index):
    if index is None:
        self.clear_option('index')
    elif type(index) in [type(''), type(1)]:
        self._options['index'] = (index, 'index %s' % index)
    elif type(index) is type(()):
        self._options['index'] = (index,'index %s' %
                                  string.join(map(repr, index), ':'))
    else:
        raise OptionException('index=%s' % (index,))
</t>
<t tx="ekr.20050704165326.204"># We need a FileClass with a different name from 'File', which is a
# factory function in 1.7, so that our String class can subclass FileClass
# in any version.
_FileClass = File

else:  # Gnuplot.py version 1.7 and greater
_FileClass = _BaseFileItem = PlotItems._FileItem
_BaseTempFileItem = PlotItems._TempFileItem
File = PlotItems.File

# Now, we can add our generic code which is version independent

# First some useful utilities
def eps_fix_bbox(fname):
</t>
<t tx="ekr.20050704165326.205">"""Fix the bounding box of an eps file by running ps2eps on it.

If its name ends in .eps, the original file is removed.

This is particularly useful for plots made by Gnuplot with square aspect
ratio: there is a bug in Gnuplot which makes it generate a bounding box
which is far wider than the actual plot.

This function assumes that ps2eps is installed in your system."""

# note: ps2ps and eps2eps do NOT work, ONLY ps2eps works correctly. The
# others make output with bitmapped fonts, which looks horrible.
print 'Fixing eps file: &lt;%s&gt;' % fname
xsys('ps2eps -f -q -l %s' % fname)
if fname.endswith('.eps'):
    os.rename(fname+'.eps',fname)

def is_list1d(x,containers = [types.ListType,types.TupleType]):
</t>
<t tx="ekr.20050704165326.206">"""Returns true if x appears to be a 1d list/tuple/array.

The heuristics are: identify Numeric arrays, or lists/tuples whose first
element is not itself a list/tuple. This way zipped lists should work like
the original Gnuplot. There's no inexpensive way to know if a list doesn't
have a composite object after its first element, so that kind of input
will produce an error. But it should work well in most cases.
"""
x_type = type(x)

return x_type == Numeric.ArrayType and len(x.shape)==1 or \
       (x_type in containers and
        type(x[0]) not in containers + [Numeric.ArrayType])

def zip_items(items,titles=None):
</t>
<t tx="ekr.20050704165326.207">"""zip together neighboring 1-d arrays, and zip standalone ones
with their index. Leave other plot items alone."""

class StandaloneItem(Exception): pass
</t>
<t tx="ekr.20050704165326.208">def get_titles(titles):
    """Return the next title and the input titles array.

    The input array may be changed to None when no titles are left to
    prevent extra unnecessary calls to this function."""
    
    try:
        title = titles[tit_ct[0]]  # tit_ct[0] is in zip_items'scope
    except IndexError:
        titles = None # so we don't enter again
        title = None
    else:
        tit_ct[0] += 1
    return title,titles
</t>
<t tx="ekr.20050704165326.209">
new_items = []

if titles:
    # Initialize counter. It was put in a list as a hack to allow the
    # nested get_titles to modify it without raising a NameError.
    tit_ct = [0]

n = 0  # this loop needs to be done by hand
while n &lt; len(items):
    item = items[n]
    try:
        if is_list1d(item):
            if n==len(items)-1: # last in list
                raise StandaloneItem
            else: # check the next item and zip together if needed
                next_item = items[n+1]
                if next_item is None:
                    n += 1
                    raise StandaloneItem
                elif is_list1d(next_item):
                    # this would be best done with an iterator
                    if titles:
                        title,titles = get_titles(titles)
                    else:
                        title = None
                    new_items.append(Data(zip(item,next_item),
                                          title=title))
                    n += 1  # avoid double-inclusion of next item
                else: # can't zip with next, zip with own index list
                    raise StandaloneItem
        else:  # not 1-d array
            new_items.append(item)
    except StandaloneItem:
        if titles:
            title,titles = get_titles(titles)
        else:
            title = None
        new_items.append(Data(zip(range(len(item)),item),title=title))
    except AttributeError:
        new_items.append(item)
    n+=1

return new_items

# And some classes with enhanced functionality.
class String(_FileClass):
"""Make a PlotItem from data in a string with the same format as a File.

This allows writing data directly inside python scripts using the exact
same format and manipulation options which would be used for external
files."""
	@others
</t>
<t tx="ekr.20050704165326.210">def __init__(self, data_str, **keyw):
    """Construct a String object.

    &lt;data_str&gt; is a string formatted exactly like a valid Gnuplot data
    file would be. All options from the File constructor are valid here.

    Warning: when used for interactive plotting in scripts which exit
    immediately, you may get an error because the temporary file used to
    hold the string data was deleted before Gnuplot had a chance to see
    it. You can work around this problem by putting a raw_input() call at
    the end of the script.

    This problem does not appear when generating PostScript output, only
    with Gnuplot windows."""

    self.tmpfile = _BaseTempFileItem()
    tmpfile = file(self.tmpfile.filename,'w')
    tmpfile.write(data_str)
    _BaseFileItem.__init__(self,self.tmpfile,**keyw)
</t>
<t tx="ekr.20050704165326.211">

class Gnuplot(Gnuplot_ori.Gnuplot):
    """Improved Gnuplot class.

    Enhancements: better plot,replot and hardcopy methods. New methods for
    quick range setting.
    """
	@others
</t>
<t tx="ekr.20050704165326.212">def xrange(self,min='*',max='*'):
    """Set xrange. If min/max is omitted, it is set to '*' (auto).

    Note that this is different from the regular Gnuplot behavior, where
    an unspecified limit means no change. Here any unspecified limit is
    set to autoscaling, allowing these functions to be used for full
    autoscaling when called with no arguments.

    To preserve one limit's current value while changing the other, an
    explicit '' argument must be given as the limit to be kept.

    Similar functions exist for [y{2}z{2}rtuv]range."""
    
    self('set xrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.213">def yrange(self,min='*',max='*'):
    self('set yrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.214">def zrange(self,min='*',max='*'):
    self('set zrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.215">def x2range(self,min='*',max='*'):
    self('set xrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.216">def y2range(self,min='*',max='*'):
    self('set yrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.217">def z2range(self,min='*',max='*'):
    self('set zrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.218">def rrange(self,min='*',max='*'):
    self('set rrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.219">def trange(self,min='*',max='*'):
    self('set trange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.220">def urange(self,min='*',max='*'):
    self('set urange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.221">def vrange(self,min='*',max='*'):
    self('set vrange [%s:%s]' % (min,max))
</t>
<t tx="ekr.20050704165326.222">def set_ps(self,option):
    """Set an option for the PostScript terminal and reset default term."""

    self('set terminal postscript %s ' % option)
    self('set terminal %s' % gp.GnuplotOpts.default_term)
</t>
<t tx="ekr.20050704165326.223">def __plot_ps(self, plot_method,*items, **keyw):
    """Wrapper for plot/splot/replot, with processing of hardcopy options.

    For internal use only."""

    # Filter out PostScript options which will crash the normal plot/replot
    psargs = {'filename':None,
              'mode':None,
              'eps':None,
              'enhanced':None,
              'color':None,
              'solid':None,
              'duplexing':None,
              'fontname':None,
              'fontsize':None,
              'debug':0 }

    for k in psargs.keys():
        if keyw.has_key(k):
            psargs[k] = keyw[k]
            del keyw[k]

    # Filter out other options the original plot doesn't know
    hardcopy = popkey(keyw,'hardcopy',psargs['filename'] is not None)
    titles = popkey(keyw,'titles',0)
    
    # the filename keyword should control hardcopy generation, this is an
    # override switch only which needs to be explicitly set to zero
    if hardcopy:
        if psargs['filename'] is None:
            raise ValueError, \
                  'If you request hardcopy, you must give a filename.'

        # set null output so nothing goes to screen. hardcopy() restores output
        self('set term dumb')
        # I don't know how to prevent screen output in Windows
        if os.name == 'posix':
            self('set output "/dev/null"')

    new_items = zip_items(items,titles)
    # plot_method is either plot or replot from the original Gnuplot class:
    plot_method(self,*new_items,**keyw)

    # Do hardcopy if requested
    if hardcopy:
        if psargs['filename'].endswith('.eps'):
            psargs['eps'] = 1
        self.hardcopy(**psargs)
</t>
<t tx="ekr.20050704165326.224">def plot(self, *items, **keyw):
    """Draw a new plot.

    Clear the current plot and create a new 2-d plot containing
    the specified items.  Each arguments should be of the
    following types:

    'PlotItem' (e.g., 'Data', 'File', 'Func') -- This is the most
        flexible way to call plot because the PlotItems can
        contain suboptions.  Moreover, PlotItems can be saved to
        variables so that their lifetime is longer than one plot
        command; thus they can be replotted with minimal overhead.

    'string' (e.g., 'sin(x)') -- The string is interpreted as
        'Func(string)' (a function that is computed by gnuplot).

    Anything else -- The object, which should be convertible to an
        array, is passed to the 'Data' constructor, and thus
        plotted as data.  If the conversion fails, an exception is
        raised.


    This is a modified version of plot(). Compared to the original in
    Gnuplot.py, this version has several enhancements, listed below.


    Modifications to the input arguments
    ------------------------------------

    (1-d array means Numeric array, list or tuple):

    (i) Any 1-d array which is NOT followed by another 1-d array, is
    automatically zipped with range(len(array_1d)). Typing g.plot(y) will
    plot y against its indices.

    (ii) If two 1-d arrays are contiguous in the argument list, they are
    automatically zipped together. So g.plot(x,y) plots y vs. x, and
    g.plot(x1,y1,x2,y2) plots y1 vs. x1 and y2 vs. x2.

    (iii) Any 1-d array which is followed by None is automatically zipped
    with range(len(array_1d)). In this form, typing g.plot(y1,None,y2)
    will plot both y1 and y2 against their respective indices (and NOT
    versus one another). The None prevents zipping y1 and y2 together, and
    since y2 is unpaired it is automatically zipped to its indices by (i)

    (iv) Any other arguments which don't match these cases are left alone and
    passed to the code below.

    For lists or tuples, the heuristics used to determine whether they are
    in fact 1-d is fairly simplistic: their first element is checked, and
    if it is not a list or tuple itself, it is assumed that the whole
    object is one-dimensional.

    An additional optional keyword 'titles' has been added: it must be a
    list of strings to be used as labels for the individual plots which
    are NOT PlotItem objects (since those objects carry their own labels
    within).


    PostScript generation
    ---------------------

    This version of plot() also handles automatically the production of
    PostScript output. The main options are (given as keyword arguments):

    - filename: a string, typically ending in .eps. If given, the plot is
    sent to this file in PostScript format.
    
    - hardcopy: this can be set to 0 to override 'filename'. It does not
    need to be given to produce PostScript, its purpose is to allow
    switching PostScript output off globally in scripts without having to
    manually change 'filename' values in multiple calls.

    All other keywords accepted by Gnuplot.hardcopy() are transparently
    passed, and safely ignored if output is sent to the screen instead of
    PostScript.

    For example:
    
    In [1]: x=frange(0,2*pi,npts=100)

    Generate a plot in file 'sin.eps':

    In [2]: plot(x,sin(x),filename = 'sin.eps')

    Plot to screen instead, without having to change the filename:

    In [3]: plot(x,sin(x),filename = 'sin.eps',hardcopy=0)

    Pass the 'color=0' option to hardcopy for monochrome output:

    In [4]: plot(x,sin(x),filename = 'sin.eps',color=0)

    PostScript generation through plot() is useful mainly for scripting
    uses where you are not interested in interactive plotting. For
    interactive use, the hardcopy() function is typically more convenient:
    
    In [5]: plot(x,sin(x))

    In [6]: hardcopy('sin.eps')  """
    
    self.__plot_ps(Gnuplot_ori.Gnuplot.plot,*items,**keyw)
</t>
<t tx="ekr.20050704165326.225">def plot2(self,arg,**kw):
    """Plot the entries of a dictionary or a list/tuple of arrays.        
    
    This simple utility calls plot() with a list of Gnuplot.Data objects
    constructed either from the values of the input dictionary, or the entries
    in it if it is a tuple or list.  Each item gets labeled with the key/index
    in the Gnuplot legend.

    Each item is plotted by zipping it with a list of its indices.

    Any keywords are passed directly to plot()."""

    if hasattr(arg,'keys'):
        keys = arg.keys()
        keys.sort()
    else:
        keys = range(len(arg))

    pitems = [Data(zip(range(len(arg[k])),arg[k]),title=`k`) for k in keys]
    self.plot(*pitems,**kw)
</t>
<t tx="ekr.20050704165326.226">def splot(self, *items, **keyw):
    """Draw a new three-dimensional plot.

    Clear the current plot and create a new 3-d plot containing
    the specified items.  Arguments can be of the following types:

    'PlotItem' (e.g., 'Data', 'File', 'Func', 'GridData' ) -- This
        is the most flexible way to call plot because the
        PlotItems can contain suboptions.  Moreover, PlotItems can
        be saved to variables so that their lifetime is longer
        than one plot command--thus they can be replotted with
        minimal overhead.

    'string' (e.g., 'sin(x*y)') -- The string is interpreted as a
        'Func()' (a function that is computed by gnuplot).

    Anything else -- The object is converted to a Data() item, and
        thus plotted as data.  Note that each data point should
        normally have at least three values associated with it
        (i.e., x, y, and z).  If the conversion fails, an
        exception is raised.

    This is a modified version of splot(). Compared to the original in
    Gnuplot.py, this version has several enhancements, listed in the
    plot() documentation.
    """
    
    self.__plot_ps(Gnuplot_ori.Gnuplot.splot,*items,**keyw)
</t>
<t tx="ekr.20050704165326.227">def replot(self, *items, **keyw):
    """Replot the data, possibly adding new 'PlotItem's.

    Replot the existing graph, using the items in the current
    itemlist.  If arguments are specified, they are interpreted as
    additional items to be plotted alongside the existing items on
    the same graph.  See 'plot' for details.

    If you want to replot to a postscript file, you MUST give the
    'filename' keyword argument in each call to replot. The Gnuplot python
    interface has no way of knowing that your previous call to
    Gnuplot.plot() was meant for PostScript output."""
    
    self.__plot_ps(Gnuplot_ori.Gnuplot.replot,*items,**keyw)
</t>
<t tx="ekr.20050704165326.228"># The original hardcopy has a bug. See fix at the end. The rest of the code
# was lifted verbatim from the original, so that people using IPython get the
# benefits without having to manually patch Gnuplot.py
def hardcopy(self, filename=None,
             mode=None,
             eps=None,
             enhanced=None,
             color=None,
             solid=None,
             duplexing=None,
             fontname=None,
             fontsize=None,
             debug = 0,
             ):
    """Create a hardcopy of the current plot.

    Create a postscript hardcopy of the current plot to the
    default printer (if configured) or to the specified filename.

    Note that gnuplot remembers the postscript suboptions across
    terminal changes.  Therefore if you set, for example, color=1
    for one hardcopy then the next hardcopy will also be color
    unless you explicitly choose color=0.  Alternately you can
    force all of the options to their defaults by setting
    mode='default'.  I consider this to be a bug in gnuplot.

    Keyword arguments:

      'filename=&lt;string&gt;' -- if a filename is specified, save the
          output in that file; otherwise print it immediately
          using the 'default_lpr' configuration option.  If the
          filename ends in '.eps', EPS mode is automatically
          selected (like manually specifying eps=1 or mode='eps').

      'mode=&lt;string&gt;' -- set the postscript submode ('landscape',
          'portrait', 'eps', or 'default').  The default is
          to leave this option unspecified.

      'eps=&lt;bool&gt;' -- shorthand for 'mode="eps"'; asks gnuplot to
          generate encapsulated postscript.

      'enhanced=&lt;bool&gt;' -- if set (the default), then generate
          enhanced postscript, which allows extra features like
          font-switching, superscripts, and subscripts in axis
          labels.  (Some old gnuplot versions do not support
          enhanced postscript; if this is the case set
          gp.GnuplotOpts.prefer_enhanced_postscript=None.)

      'color=&lt;bool&gt;' -- if set, create a plot with color.  Default
          is to leave this option unchanged.

      'solid=&lt;bool&gt;' -- if set, force lines to be solid (i.e., not
          dashed).

      'duplexing=&lt;string&gt;' -- set duplexing option ('defaultplex',
          'simplex', or 'duplex').  Only request double-sided
          printing if your printer can handle it.  Actually this
          option is probably meaningless since hardcopy() can only
          print a single plot at a time.

      'fontname=&lt;string&gt;' -- set the default font to &lt;string&gt;,
          which must be a valid postscript font.  The default is
          to leave this option unspecified.

      'fontsize=&lt;double&gt;' -- set the default font size, in
          postscript points.

      'debug=&lt;bool&gt;' -- print extra debugging information (useful if
          your PostScript files are misteriously not being created).
    """

    if filename is None:
        assert gp.GnuplotOpts.default_lpr is not None, \
               OptionException('default_lpr is not set, so you can only '
                               'print to a file.')
        filename = gp.GnuplotOpts.default_lpr
        lpr_output = 1
    else:
        if filename.endswith('.eps'):
            eps = 1
        lpr_output = 0

    # Be careful processing the options.  If the user didn't
    # request an option explicitly, do not specify it on the 'set
    # terminal' line (don't even specify the default value for the
    # option).  This is to avoid confusing older versions of
    # gnuplot that do not support all of these options.  The
    # exception is 'enhanced', which is just too useful to have to
    # specify each time!

    setterm = ['set', 'terminal', 'postscript']
    if eps:
        assert mode is None or mode=='eps', \
               OptionException('eps option and mode are incompatible')
        setterm.append('eps')
    else:
        if mode is not None:
            assert mode in ['landscape', 'portrait', 'eps', 'default'], \
                   OptionException('illegal mode "%s"' % mode)
            setterm.append(mode)
    if enhanced is None:
        enhanced = gp.GnuplotOpts.prefer_enhanced_postscript
    if enhanced is not None:
        if enhanced: setterm.append('enhanced')
        else: setterm.append('noenhanced')
    if color is not None:
        if color: setterm.append('color')
        else: setterm.append('monochrome')
    if solid is not None:
        if solid: setterm.append('solid')
        else: setterm.append('dashed')
    if duplexing is not None:
        assert duplexing in ['defaultplex', 'simplex', 'duplex'], \
               OptionException('illegal duplexing mode "%s"' % duplexing)
        setterm.append(duplexing)
    if fontname is not None:
        setterm.append('"%s"' % fontname)
    if fontsize is not None:
        setterm.append('%s' % fontsize)

    self(string.join(setterm))
    self.set_string('output', filename)
    # replot the current figure (to the printer):
    self.refresh()

    # fperez. Ugly kludge: often for some reason the file is NOT created
    # and we must reissue the creation commands. I have no idea why!
    if not lpr_output:
        #print 'Hardcopy &lt;%s&gt;' % filename  # dbg
        maxtries = 20
        delay = 0.1  # delay (in seconds) between print attempts
        for i in range(maxtries):
            time.sleep(0.05)  # safety, very small delay
            if os.path.isfile(filename):
                if debug:
                    print 'Hardcopy to file &lt;%s&gt; success at attempt #%s.' \
                    % (filename,i+1)
                break
            time.sleep(delay)
            # try again, issue all commands just in case
            self(string.join(setterm))
            self.set_string('output', filename)
            self.refresh()
        if not os.path.isfile(filename):
            print &gt;&gt; sys.stderr,'ERROR: Tried %s times and failed to '\
            'create hardcopy file `%s`' % (maxtries,filename)

    # reset the terminal to its `default' setting:
    self('set terminal %s' % gp.GnuplotOpts.default_term)
    self.set_string('output')
</t>
<t tx="ekr.20050704165326.229">
@language python
&lt;&lt; GnuplotInteractive declarations &gt;&gt;
@others

try:
    __IPYTHON__
except NameError:
    pass
else:
    # make the global Gnuplot instance known to IPython
    __IPYTHON__.gnuplot = GRun.gp
    __IPYTHON__.gnuplot.shell_first_time = 1

    print """*** Type `gphelp` for help on the Gnuplot integration features."""

    # Add the new magic functions to the class dict
    from IPython.iplib import InteractiveShell
    InteractiveShell.magic_gpc = magic_gpc
    InteractiveShell.magic_gp_set_default = magic_gp_set_default

#********************** End of file &lt;GnuplotInteractive.py&gt; *******************
</t>
<t tx="ekr.20050704165326.230"># -*- coding: utf-8 -*-
"""Interactive functions and magic functions for Gnuplot usage.

This requires the Gnuplot.py module for interfacing python with Gnuplot, which
can be downloaded from:

http://gnuplot-py.sourceforge.net/

See gphelp() below for details on the services offered by this module.

Inspired by a suggestion/request from Arnd Baecker.

$Id$"""

__all__ = ['Gnuplot','gp','gp_new','plot','plot2','splot','replot',
           'hardcopy','gpdata','gpfile','gpstring','gpfunc','gpgrid',
           'gphelp']

import IPython.GnuplotRuntime as GRun
from IPython.genutils import page,warn

# Set global names for interactive use
Gnuplot  = GRun.Gnuplot
gp_new   = GRun.gp_new
gp       = GRun.gp
plot     = gp.plot
plot2    = gp.plot2
splot    = gp.splot
replot   = gp.replot
hardcopy = gp.hardcopy

# Accessors for the main plot object constructors:
gpdata   = Gnuplot.Data
gpfile   = Gnuplot.File
gpstring = Gnuplot.String
gpfunc   = Gnuplot.Func
gpgrid   = Gnuplot.GridData

</t>
<t tx="ekr.20050704165326.231">def gphelp():
    """Print information about the Gnuplot facilities in IPython."""

    page("""
IPython provides an interface to access the Gnuplot scientific plotting
system, in an environment similar to that of Mathematica or Matlab.

New top-level global objects
----------------------------

Please see their respective docstrings for further details.

- gp: a running Gnuplot instance. You can access its methods as
gp.&lt;method&gt;. gp(`a string`) will execute the given string as if it had been
typed in an interactive gnuplot window.

- plot, splot, replot and hardcopy: aliases to the methods of the same name in
the global running Gnuplot instance gp. These allow you to simply type:

In [1]: plot(x,sin(x),title='Sin(x)')  # assuming x is a Numeric array

and obtain a plot of sin(x) vs x with the title 'Sin(x)'.

- gp_new: a function which returns a new Gnuplot instance. This can be used to
have multiple Gnuplot instances running in your session to compare different
plots, each in a separate window.

- Gnuplot: alias to the Gnuplot2 module, an improved drop-in replacement for
the original Gnuplot.py. Gnuplot2 needs Gnuplot but redefines several of its
functions with improved versions (Gnuplot2 comes with IPython).

- gpdata, gpfile, gpstring, gpfunc, gpgrid: aliases to Gnuplot.Data,
Gnuplot.File, Gnuplot.String, Gnuplot.Func and Gnuplot.GridData
respectively. These functions create objects which can then be passed to the
plotting commands. See the Gnuplot.py documentation for details.

Keep in mind that all commands passed to a Gnuplot instance are executed in
the Gnuplot namespace, where no Python variables exist. For example, for
plotting sin(x) vs x as above, typing

In [2]: gp('plot x,sin(x)')

would not work. Instead, you would get the plot of BOTH the functions 'x' and
'sin(x)', since Gnuplot doesn't know about the 'x' Python array. The plot()
method lives in python and does know about these variables.


New magic functions
-------------------

%gpc: pass one command to Gnuplot and execute it or open a Gnuplot shell where
each line of input is executed.

%gp_set_default: reset the value of IPython's global Gnuplot instance.""")
</t>
<t tx="ekr.20050704165326.232"># Code below is all for IPython use
# Define the magic functions for communicating with the above gnuplot instance.
def magic_gpc(self,parameter_s=''):
    """Execute a gnuplot command or open a gnuplot shell.

    Usage (omit the % if automagic is on). There are two ways to use it:

      1) %gpc 'command' -&gt; passes 'command' directly to the gnuplot instance.

      2) %gpc -&gt; will open up a prompt (gnuplot&gt;&gt;&gt;) which takes input like the
      standard gnuplot interactive prompt. If you need to type a multi-line
      command, use \\ at the end of each intermediate line.

      Upon exiting of the gnuplot sub-shell, you return to your IPython
      session (the gnuplot sub-shell can be invoked as many times as needed).
      """

    if parameter_s.strip():
        self.shell.gnuplot(parameter_s)
    else:
        self.shell.gnuplot.interact()
</t>
<t tx="ekr.20050704165326.233">def magic_gp_set_default(self,parameter_s=''):
    """Set the default gnuplot instance accessed by the %gp magic function.

    %gp_set_default name

    Call with the name of the new instance at the command line. If you want to
    set this instance in your own code (using an embedded IPython, for
    example), simply set the variable __IPYTHON__.gnuplot to your own gnuplot
    instance object."""

    gname = parameter_s.strip()
    G = eval(gname,self.shell.user_ns)
    self.shell.gnuplot = G
    self.shell.user_ns.update({'plot':G.plot,'splot':G.splot,'plot2':G.plot2,
                               'replot':G.replot,'hardcopy':G.hardcopy})
</t>
<t tx="ekr.20050704165326.234">
@language python
&lt;&lt; GnuplotRuntime declarations &gt;&gt;
@others

# Global-level names.

# A global Gnuplot instance for interactive use:
gp = gp_new()

# Accessors for the main plot object constructors:
Data = Gnuplot.Data
File = Gnuplot.File
Func = Gnuplot.Func
String = Gnuplot.String
GridData = Gnuplot.GridData

# A Unix-only function to fix eps files with bad bounding boxes (which Gnuplot
# generates when the plot size is set to square):
eps_fix_bbox = Gnuplot.eps_fix_bbox

# String for configuring pm3d. Simply call g(pm3d_config) to execute it.  pm3d
# is a very nice mode for plotting colormaps on surfaces. Modify the defaults
# below to suit your taste.
pm3d_config = """
set pm3d solid
set hidden3d
unset surface
set isosamples 50
"""
#******************** End of file &lt;GnuplotRuntime.py&gt; ******************
</t>
<t tx="ekr.20050704165326.235"># -*- coding: utf-8 -*-
"""Basic Gnuplot functionality for inclusion in other code.

This module creates a running Gnuplot instance called 'gp' and builds other
convenient globals for quick use in running scripts. It is intended to allow
you to script plotting tasks in Python with a minimum of effort. A typical
usage would be:

import IPython.GnuplotRuntime as GP  # or some other short name
GP.gp.plot(GP.File('your_data.dat'))


This module exposes the following objects:

- gp: a running Gnuplot instance. You can access its methods as
gp.&lt;method&gt;. gp(`a string`) will execute the given string as if it had been
typed in an interactive gnuplot window.

- gp_new: a function which returns a new Gnuplot instance. This can be used to
have multiple Gnuplot instances running in your session to compare different
plots.

- Gnuplot: alias to the Gnuplot2 module, an improved drop-in replacement for
the original Gnuplot.py. Gnuplot2 needs Gnuplot but redefines several of its
functions with improved versions (Gnuplot2 comes with IPython).

- Data: alias to Gnuplot.Data, makes a PlotItem from array data.

- File: alias to Gnuplot.File, makes a PlotItem from a file.

- String: alias to Gnuplot.String, makes a PlotItem from a string formatted
exactly like a file for Gnuplot.File would be.

- Func: alias to Gnuplot.Func, makes a PlotItem from a function string.

- GridData: alias to Gnuplot.GridData, makes a PlotItem from grid data.

- pm3d_config: a string with Gnuplot commands to set up the pm3d mode for
surface plotting. You can activate it simply by calling gp(pm3d_config).

- eps_fix_bbox: A Unix-only function to fix eps files with bad bounding boxes
(which Gnuplot generates when the plot size is set to square).

This requires the Gnuplot.py module for interfacing Python with Gnuplot, which
can be downloaded from:

http://gnuplot-py.sourceforge.net/

Inspired by a suggestion/request from Arnd Baecker.

$Id$"""

__all__ = ['Gnuplot','gp','gp_new','Data','File','Func','GridData',
           'pm3d_config','eps_fix_bbox']

import os,tempfile,sys
from IPython.genutils import getoutput

#---------------------------------------------------------------------------
# Notes on mouse support for Gnuplot.py

# If you do not have a mouse-enabled gnuplot, set gnuplot_mouse to 0. If you
# use gnuplot, you should really grab a recent, mouse enabled copy. It is an
# extremely useful feature.  Mouse support is official as of gnuplot 4.0,
# released in April 2004.

# For the mouse features to work correctly, you MUST set your Gnuplot.py
# module to use temporary files instead of 'inline data' for data
# communication. Note that this is the default, so unless you've manually
# fiddled with it you should be ok. If you need to make changes, in the
# Gnuplot module directory, loook for the gp_unix.py file and make sure the
# prefer_inline_data variable is set to 0. If you set it to 1 Gnuplot.py will
# try to pass the data to gnuplot via standard input, which completely
# confuses the mouse control system (even though it may be a bit faster than
# using temp files).

# As of Gnuplot.py v1.7, a new option was added to use FIFOs (pipes).  This
# mechanism, while fast, also breaks the mouse system.  You must therefore set
# the variable prefer_fifo_data to 0 in gp_unix.py.

tmpname = tempfile.mktemp()
open(tmpname,'w').write('set mouse')
gnu_out = getoutput('gnuplot '+ tmpname)
os.unlink(tmpname)
if gnu_out:  # Gnuplot won't print anything if it has mouse support
    print "*** Your version of Gnuplot appears not to have mouse support."
    gnuplot_mouse = 0
else:
    gnuplot_mouse = 1
del tmpname,gnu_out

# Default state for persistence of new gnuplot instances
if os.name in ['nt','dos'] or sys.platform == 'cygwin':
    gnuplot_persist = 0
else:
    gnuplot_persist = 1

import IPython.Gnuplot2 as Gnuplot

</t>
<t tx="ekr.20050704165326.236">class NotGiven: pass
</t>
<t tx="ekr.20050704165326.237">def gp_new(mouse=NotGiven,persist=NotGiven):
    """Return a new Gnuplot instance.

    The instance returned uses the improved methods defined in Gnuplot2.

    Options (boolean):

    - mouse: if unspecified, the module global gnuplot_mouse is used.

    - persist: if unspecified, the module global gnuplot_persist is used."""
    
    if mouse is NotGiven:
        mouse = gnuplot_mouse
    if persist is NotGiven:
        persist = gnuplot_persist
    g = Gnuplot.Gnuplot(persist=persist)
    if mouse:
        g('set mouse')
    return g
</t>
<t tx="ekr.20050704165326.238">
@language python
&lt;&lt; hooks declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704165326.239">"""hooks for IPython.

In Python, it is possible to overwrite any method of any object if you really
want to.  But IPython exposes a few 'hooks', methods which are _designed_ to
be overwritten by users for customization purposes.  This module defines the
default versions of all such hooks, which get used by IPython if not
overridden by the user.

hooks are simple functions, but they should be declared with 'self' as their
first argument, because when activated they are registered into IPython as
instance methods.  The self argument will be the IPython running instance
itself, so hooks have full access to the entire IPython object.

If you wish to define a new hook and activate it, you need to put the
necessary code into a python file which can be either imported or execfile()'d
from within your ipythonrc configuration.

For example, suppose that you have a module called 'myiphooks' in your
PYTHONPATH, which contains the following definition:

import os
def calljed(self,filename, linenum):
    "My editor hook calls the jed editor directly."
    print "Calling my own editor, jed ..."
    os.system('jed +%d %s' % (linenum,filename))

You can then execute the following line of code to make it the new IPython
editor hook, after having imported 'myiphooks':

ip_set_hook('editor',myiphooks.calljed)

The ip_set_hook function is put by IPython into the builtin namespace, so it
is always available from all running code.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2005 Fernando Perez. &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

import os

# List here all the default hooks.  For now it's just the editor, but over
# time we'll move here all the public API for user-accessible things.
__all__ = ['editor']

</t>
<t tx="ekr.20050704165326.240">def editor(self,filename, linenum):
    """Open the default editor at the given filename and linenumber.

    This is IPython's default editor hook, you can use it as an example to
    write your own modified one.  To set your own editor function as the
    new editor hook, call ip_set_hook('editor',yourfunc)."""

    # IPython configures a default editor at startup by reading $EDITOR from
    # the environment, and falling back on vi (unix) or notepad (win32).
    editor = self.rc.editor
    
    # marker for at which line to open the file (for existing objects)
    if linenum is None or editor=='notepad':
        linemark = ''
    else:
        linemark = '+%d' % linenum
    # Call the actual editor
    os.system('%s %s %s' % (editor,linemark,filename))
</t>
<t tx="ekr.20050704165326.241">@first # -*- coding: utf-8 -*-

"""
IPython -- An enhanced Interactive Python

Requires Python 2.1 or newer.

This file contains all the classes and helper functions specific to IPython.

$Id$
"""

@language python
&lt;&lt; iplib declarations &gt;&gt;
@others</t>
<t tx="ekr.20050704165326.242">

#****************************************************************************
# Modules and globals

from __future__ import generators  # for 2.2 backwards-compatibility

from IPython import Release
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
              ( Release.authors['Janko'] + Release.authors['Fernando'] )
__license__ = Release.license
__version__ = Release.version

# Python standard modules
import __main__
import __builtin__
import exceptions
import keyword
import new
import os, sys, shutil
import code, glob, types, re
import string, StringIO
import inspect, pydoc
import bdb, pdb
import UserList # don't subclass list so this works with Python2.1
from pprint import pprint, pformat
import cPickle as pickle
import traceback

# IPython's own modules
import IPython
from IPython import OInspect,PyColorize,ultraTB
from IPython.ultraTB import ColorScheme,ColorSchemeTable  # too long names
from IPython.Logger import Logger
from IPython.Magic import Magic,magic2python,shlex_split
from IPython.usage import cmd_line_usage,interactive_usage
from IPython.Struct import Struct
from IPython.Itpl import Itpl,itpl,printpl,ItplNS,itplns
from IPython.FakeModule import FakeModule
from IPython.background_jobs import BackgroundJobManager
from IPython.genutils import *

# Global pointer to the running 

# store the builtin raw_input globally, and use this always, in case user code
# overwrites it (like wx.py.PyShell does)
raw_input_original = raw_input

# declares Python 2.2 compatibility symbols:
try:
    enumerate
except NameError:
</t>
<t tx="ekr.20050704165326.243">def enumerate(obj):
    i = -1
    for item in obj:
        i += 1
        yield i, item
</t>
<t tx="ekr.20050704165326.244">#****************************************************************************
# Some utility function definitions

class Bunch: pass
</t>
<t tx="ekr.20050704165326.245">def esc_quotes(strng):
    """Return the input string with single and double quotes escaped out"""

    return strng.replace('"','\\"').replace("'","\\'")
</t>
<t tx="ekr.20050704165326.246">def import_fail_info(mod_name,fns=None):
    """Inform load failure for a module."""

    if fns == None:
        warn("Loading of %s failed.\n" % (mod_name,))
    else:
        warn("Loading of %s from %s failed.\n" % (fns,mod_name))
</t>
<t tx="ekr.20050704165326.247">def qw_lol(indata):
    """qw_lol('a b') -&gt; [['a','b']],
    otherwise it's just a call to qw().

    We need this to make sure the modules_some keys *always* end up as a
    list of lists."""

    if type(indata) in StringTypes:
        return [qw(indata)]
    else:
        return qw(indata)
</t>
<t tx="ekr.20050704165326.248">def ipmagic(arg_s):
    """Call a magic function by name.

    Input: a string containing the name of the magic function to call and any
    additional arguments to be passed to the magic.

    ipmagic('name -opt foo bar') is equivalent to typing at the ipython
    prompt:

    In[1]: %name -opt foo bar

    To call a magic without arguments, simply use ipmagic('name').

    This provides a proper Python function to call IPython's magics in any
    valid Python code you can type at the interpreter, including loops and
    compound statements.  It is added by IPython to the Python builtin
    namespace upon initialization."""

    args = arg_s.split(' ',1)
    magic_name = args[0]
    if magic_name.startswith(__IPYTHON__.ESC_MAGIC):
        magic_name = magic_name[1:]
    try:
        magic_args = args[1]
    except IndexError:
        magic_args = ''
    fn = getattr(__IPYTHON__,'magic_'+magic_name,None)
    if fn is None:
        error("Magic function `%s` not found." % magic_name)
    else:
        magic_args = __IPYTHON__.var_expand(magic_args)
        return fn(magic_args)
</t>
<t tx="ekr.20050704165326.249">def ipalias(arg_s):
    """Call an alias by name.

    Input: a string containing the name of the alias to call and any
    additional arguments to be passed to the magic.

    ipalias('name -opt foo bar') is equivalent to typing at the ipython
    prompt:

    In[1]: name -opt foo bar

    To call an alias without arguments, simply use ipalias('name').

    This provides a proper Python function to call IPython's aliases in any
    valid Python code you can type at the interpreter, including loops and
    compound statements.  It is added by IPython to the Python builtin
    namespace upon initialization."""

    args = arg_s.split(' ',1)
    alias_name = args[0]
    try:
        alias_args = args[1]
    except IndexError:
        alias_args = ''
    if alias_name in __IPYTHON__.alias_table:
        __IPYTHON__.call_alias(alias_name,alias_args)
    else:
        error("Alias `%s` not found." % alias_name)
</t>
<t tx="ekr.20050704165326.250">#-----------------------------------------------------------------------------
# Local use classes

try:
    from IPython import FlexCompleter

    class MagicCompleter(FlexCompleter.Completer):
        """Extension of the completer class to work on %-prefixed lines."""
	@others

except ImportError:
    pass  # no readline support

except KeyError:
    pass  # Windows doesn't set TERM, it doesn't matter</t>
<t tx="ekr.20050704165326.251">def __init__(self,shell,namespace=None,omit__names=0,alias_table=None):
    """MagicCompleter() -&gt; completer

    Return a completer object suitable for use by the readline library
    via readline.set_completer().

    Inputs:

    - shell: a pointer to the ipython shell itself.  This is needed
    because this completer knows about magic functions, and those can
    only be accessed via the ipython instance.

    - namespace: an optional dict where completions are performed.
    
    - The optional omit__names parameter sets the completer to omit the
    'magic' names (__magicname__) for python objects unless the text
    to be completed explicitly starts with one or more underscores.

    - If alias_table is supplied, it should be a dictionary of aliases
    to complete. """

    FlexCompleter.Completer.__init__(self,namespace)
    self.magic_prefix = shell.name+'.magic_'
    self.magic_escape = shell.ESC_MAGIC
    self.readline = FlexCompleter.readline
    delims = self.readline.get_completer_delims()
    delims = delims.replace(self.magic_escape,'')
    self.readline.set_completer_delims(delims)
    self.get_line_buffer = self.readline.get_line_buffer
    self.omit__names = omit__names
    self.merge_completions = shell.rc.readline_merge_completions
    
    if alias_table is None:
        alias_table = {}
    self.alias_table = alias_table
    # Regexp to split filenames with spaces in them
    self.space_name_re = re.compile(r'([^\\] )')
    # Hold a local ref. to glob.glob for speed
    self.glob = glob.glob
    # Special handling of backslashes needed in win32 platforms
    if sys.platform == "win32":
        self.clean_glob = self._clean_glob_win32
    else:
        self.clean_glob = self._clean_glob
    self.matchers = [self.python_matches,
                     self.file_matches,
                     self.alias_matches,
                     self.python_func_kw_matches]
</t>
<t tx="ekr.20050704165326.252"># Code contributed by Alex Schmolck, for ipython/emacs integration
def all_completions(self, text):
    """Return all possible completions for the benefit of emacs."""
    
    completions = []
    try:
        for i in xrange(sys.maxint):
            res = self.complete(text, i)

            if not res: break

            completions.append(res)
    #XXX workaround for ``notDefined.&lt;tab&gt;``
    except NameError:
        pass
    return completions
</t>
<t tx="ekr.20050704165326.253"># /end Alex Schmolck code.

def _clean_glob(self,text):
    return self.glob("%s*" % text)
</t>
<t tx="ekr.20050704165326.254">def _clean_glob_win32(self,text):
    return [f.replace("\\","/")
            for f in self.glob("%s*" % text)]            
</t>
<t tx="ekr.20050704165326.255">def file_matches(self, text):
    """Match filneames, expanding ~USER type strings.

    Most of the seemingly convoluted logic in this completer is an
    attempt to handle filenames with spaces in them.  And yet it's not
    quite perfect, because Python's readline doesn't expose all of the
    GNU readline details needed for this to be done correctly.

    For a filename with a space in it, the printed completions will be
    only the parts after what's already been typed (instead of the
    full completions, as is normally done).  I don't think with the
    current (as of Python 2.3) Python readline it's possible to do
    better."""
    
    #print 'Completer-&gt;file_matches: &lt;%s&gt;' % text # dbg

    # chars that require escaping with backslash - i.e. chars
    # that readline treats incorrectly as delimiters, but we
    # don't want to treat as delimiters in filename matching
    # when escaped with backslash
    
    protectables = ' ()[]{}'

    def protect_filename(s):
        return "".join([(ch in protectables and '\\' + ch or ch)
                        for ch in s])

    lbuf = self.get_line_buffer()[:self.readline.get_endidx()]
    open_quotes = 0  # track strings with open quotes
    try:
        lsplit = shlex_split(lbuf)[-1]
    except ValueError:
        # typically an unmatched ", or backslash without escaped char.
        if lbuf.count('"')==1:
            open_quotes = 1
            lsplit = lbuf.split('"')[-1]
        elif lbuf.count("'")==1:
            open_quotes = 1
            lsplit = lbuf.split("'")[-1]
        else:
            return None
    except IndexError:
        # tab pressed on empty line
        lsplit = ""

    if lsplit != protect_filename(lsplit):
        # if protectables are found, do matching on the whole escaped
        # name
        has_protectables = 1
        text0,text = text,lsplit
    else:
        has_protectables = 0
        text = os.path.expanduser(text)
    
    if text == "":
        return [protect_filename(f) for f in self.glob("*")]

    m0 = self.clean_glob(text.replace('\\',''))
    if has_protectables:
        # If we had protectables, we need to revert our changes to the
        # beginning of filename so that we don't double-write the part
        # of the filename we have so far
        len_lsplit = len(lsplit)
        matches = [text0 + protect_filename(f[len_lsplit:]) for f in m0]
    else:
        if open_quotes:
            # if we have a string with an open quote, we don't need to
            # protect the names at all (and we _shouldn't_, as it
            # would cause bugs when the filesystem call is made).
            matches = m0
        else:
            matches = [protect_filename(f) for f in m0]
    if len(matches) == 1 and os.path.isdir(matches[0]):
        # Takes care of links to directories also.  Use '/'
        # explicitly, even under Windows, so that name completions
        # don't end up escaped.
        matches[0] += '/'
    return matches
</t>
<t tx="ekr.20050704165326.256">def alias_matches(self, text):
    """Match internal system aliases"""
    #print 'Completer-&gt;alias_matches:',text # dbg
    text = os.path.expanduser(text)
    aliases =  self.alias_table.keys()
    if text == "":
        return aliases
    else:
        return [alias for alias in aliases if alias.startswith(text)]
</t>
<t tx="ekr.20050704165326.257">def python_matches(self,text):
    """Match attributes or global python names"""
    #print 'Completer-&gt;python_matches' # dbg
    if "." in text:
        try:
            matches = self.attr_matches(text)
            if text.endswith('.') and self.omit__names:
                if self.omit__names == 1:
                    # true if txt is _not_ a __ name, false otherwise:
                    no__name = (lambda txt:
                                re.match(r'.*\.__.*?__',txt) is None)
                else:
                    # true if txt is _not_ a _ name, false otherwise:
                    no__name = (lambda txt:
                                re.match(r'.*\._.*?',txt) is None)
                matches = filter(no__name, matches)
        except NameError:
            # catches &lt;undefined attributes&gt;.&lt;tab&gt;
            matches = []
    else:
        matches = self.global_matches(text)
        # this is so completion finds magics when automagic is on:
        if matches == [] and not text.startswith(os.sep):
            matches = self.attr_matches(self.magic_prefix+text)
    return matches
</t>
<t tx="ekr.20050704165326.258">def _default_arguments(self, obj):
    """Return the list of default arguments of obj if it is callable,
    or empty list otherwise."""
    
    if not (inspect.isfunction(obj) or inspect.ismethod(obj)):
        # for classes, check for __init__,__new__
        if inspect.isclass(obj):
            obj = (getattr(obj,'__init__',None) or
                   getattr(obj,'__new__',None))
        # for all others, check if they are __call__able
        elif hasattr(obj, '__call__'):
            obj = obj.__call__
        # XXX: is there a way to handle the builtins ?
    try:
        args,_,_1,defaults = inspect.getargspec(obj)
        if defaults:
            return args[-len(defaults):]
    except TypeError: pass
    return []
</t>
<t tx="ekr.20050704165326.259">def python_func_kw_matches(self,text):
    """Match named parameters (kwargs) of the last open function"""

    if "." in text: # a parameter cannot be dotted
        return []
    try: regexp = self.__funcParamsRegex
    except AttributeError:
        regexp = self.__funcParamsRegex = re.compile(r'''
            '.*?' |    # single quoted strings or
            ".*?" |    # double quoted strings or
            \w+   |    # identifier
            \S         # other characters
            ''', re.VERBOSE | re.DOTALL)
    # 1. find the nearest identifier that comes before an unclosed
    # parenthesis e.g. for "foo (1+bar(x), pa", the candidate is "foo"
    tokens = regexp.findall(self.get_line_buffer())
    tokens.reverse()
    iterTokens = iter(tokens); openPar = 0
    for token in iterTokens:
        if token == ')':
            openPar -= 1
        elif token == '(':
            openPar += 1
            if openPar &gt; 0:
                # found the last unclosed parenthesis
                break
    else:
        return []
    # 2. Concatenate any dotted names (e.g. "foo.bar" for "foo.bar(x, pa" )
    ids = []
    isId = re.compile(r'\w+$').match
    while True:
        try:
            ids.append(iterTokens.next())
            if not isId(ids[-1]):
                ids.pop(); break
            if not iterTokens.next() == '.':
                break
        except StopIteration:
            break
    # lookup the candidate callable matches either using global_matches
    # or attr_matches for dotted names
    if len(ids) == 1:
        callableMatches = self.global_matches(ids[0])
    else:
        callableMatches = self.attr_matches('.'.join(ids[::-1]))
    argMatches = []
    for callableMatch in callableMatches:
        try: namedArgs = self._default_arguments(eval(callableMatch,
                                                     self.namespace))
        except: continue
        for namedArg in namedArgs:
            if namedArg.startswith(text):
                argMatches.append("%s=" %namedArg)
    return argMatches
</t>
<t tx="ekr.20050704165326.260">def complete(self, text, state):
    """Return the next possible completion for 'text'.

    This is called successively with state == 0, 1, 2, ... until it
    returns None.  The completion should begin with 'text'.  """
    
    #print '\n*** COMPLETE: &lt;%s&gt; (%s)' % (text,state)  # dbg
    magic_escape = self.magic_escape
    magic_prefix = self.magic_prefix
    
    try:
        if text.startswith(magic_escape):
            text = text.replace(magic_escape,magic_prefix)
        elif text.startswith('~'):
            text = os.path.expanduser(text)
        if state == 0:
            # Extend the list of completions with the results of each
            # matcher, so we return results to the user from all
            # namespaces.
            if self.merge_completions:
                self.matches = []
                for matcher in self.matchers:
                    self.matches.extend(matcher(text))
            else:
                for matcher in self.matchers:
                    self.matches = matcher(text)
                    if self.matches:
                        break
                
        try:
            return self.matches[state].replace(magic_prefix,magic_escape)
        except IndexError:
            return None
    except:
        # If completion fails, don't annoy the user.
        pass
</t>
<t tx="ekr.20050704165326.261">class InputList(UserList.UserList):
    """Class to store user input.

    It's basically a list, but slices return a string instead of a list, thus
    allowing things like (assuming 'In' is an instance):

    exec In[4:7]

    or

    exec In[5:9] + In[14] + In[21:25]"""
	@others
</t>
<t tx="ekr.20050704165326.262">def __getslice__(self,i,j):
    return ''.join(UserList.UserList.__getslice__(self,i,j))
</t>
<t tx="ekr.20050704165326.263"># Local use exceptions
class SpaceInInput(exceptions.Exception):
	pass
</t>
<t tx="ekr.20050704165326.264">

</t>
<t tx="ekr.20050704165326.265"># Main IPython class

class InteractiveShell(code.InteractiveConsole, Logger, Magic):
    """An enhanced console for Python."""
	@others
</t>
<t tx="ekr.20050704165326.266">def __init__(self,name,usage=None,
    rc=Struct(opts=None,args=None),
    user_ns = None,
    banner2='',
    custom_exceptions=((),None)
):
    &lt;&lt; add stuff to builtins &gt;&gt;
    &lt;&lt; Create the namespace where the user will operate &gt;&gt;
    &lt;&lt; create ivars &gt;&gt;
    &lt;&lt; create a job manager &gt;&gt;
    &lt;&lt; handle escapes &gt;&gt;
    &lt;&lt; init classes &gt;&gt;
    # hooks holds pointers used for user-side customizations
    self.hooks = Struct()
    &lt;&lt; set all default hooks, defined in the IPython.hooks module &gt;&gt;
    # Flag to mark unconditional exit
    self.exit_now = False
    &lt;&lt; define usage messages &gt;&gt;
    &lt;&lt; storage &gt;&gt;
    &lt;&lt; for pushd/popd management &gt;&gt;
    &lt;&lt; define functions to call the underlying shell &gt;&gt;
    &lt;&lt; define regular expressions &gt;&gt;
    # keep track of where we started running (mainly for crash post-mortem)
    self.starting_dir = os.getcwd()
    &lt;&lt; Attributes for Logger mixin class, make defaults here &gt;&gt;
    &lt;&lt; various switches which can be set &gt;&gt;
    &lt;&lt; traceBack handlers &gt;&gt;
    &lt;&lt; object inspector &gt;&gt;
    &lt;&lt; Make some aliases automatically &gt;&gt;
    self.init_auto_alias() # Call the actual (public) initializer
</t>
<t tx="ekr.20050704165326.267">def set_hook(self,name,hook):
    """set_hook(name,hook) -&gt; sets an internal IPython hook.

    IPython exposes some of its internal API as user-modifiable hooks.  By
    resetting one of these hooks, you can modify IPython's behavior to
    call at runtime your own routines."""

    # At some point in the future, this should validate the hook before it
    # accepts it.  Probably at least check that the hook takes the number
    # of args it's supposed to.
    setattr(self.hooks,name,new.instancemethod(hook,self,self.__class__))</t>
<t tx="ekr.20050704165326.268">@first # -*- coding: utf-8 -*-
"""
IPython -- An enhanced Interactive Python

Requires Python 2.1 or better.

This file contains the main make_IPython() starter function.

$Id$"""

@language python
&lt;&lt; ipmaker declarations &gt;&gt;

@others

IP.usage = interactive_usage
&lt;&lt; directory stuff &gt;&gt;
&lt;&lt; command line handling &gt;&gt;
&lt;&lt; handle log replay &gt;&gt;
&lt;&lt; set output traps &gt;&gt;
&lt;&lt; process ipythonrc config files &gt;&gt;
&lt;&lt; set exception handlers in mode requested by user &gt;&gt;
&lt;&lt; execute user config &gt;&gt;
&lt;&lt; setup interactive session &gt;&gt;</t>
<t tx="ekr.20050704165326.269">from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

credits._Printer__data = """
Python: %s

IPython: Fernando Perez, Janko Hauser, Nathan Gray, and many users.
See http://ipython.scipy.org for more information.""" \
% credits._Printer__data

copyright._Printer__data += """

Copyright (c) 2001-2004 Fernando Perez, Janko Hauser, Nathan Gray.
All Rights Reserved."""

# From the standard library
import __main__, __builtin__
import os,sys,types,re
from pprint import pprint,pformat

# Our own
from IPython import DPyGetOpt
from IPython.Struct import Struct
from IPython.OutputTrap import OutputTrap
from IPython.ConfigLoader import ConfigLoader
from IPython.iplib import InteractiveShell,qw_lol,import_fail_info
from IPython.usage import cmd_line_usage,interactive_usage
from IPython.Prompts import CachedOutput
from IPython.genutils import *</t>
<t tx="ekr.20050704165326.270">def make_IPython(argv=None,user_ns=None,debug=1,rc_override=None,
                 shell_class=InteractiveShell,embedded=False,**kw):
    """This is a dump of IPython into a single function.

    Later it will have to be broken up in a sensible manner.

    Arguments:

    - argv: a list similar to sys.argv[1:].  It should NOT contain the desired
    script name, b/c DPyGetOpt strips the first argument only for the real
    sys.argv.

    - user_ns: a dict to be used as the user's namespace."""

    #----------------------------------------------------------------------
    # Defaults and initialization
    
    # For developer debugging, deactivates crash handler and uses pdb.
    DEVDEBUG = False

    if argv is None:
        argv = sys.argv

    # __IP is the main global that lives throughout and represents the whole
    # application. If the user redefines it, all bets are off as to what
    # happens.

    # __IP is the name of he global which the caller will have accessible as
    # __IP.name. We set its name via the first parameter passed to
    # InteractiveShell:

    IP = shell_class('__IP',user_ns=user_ns,**kw)

    # Put 'help' in the user namespace
    try:
        from site import _Helper
    except ImportError:
        # Use the _Helper class from Python 2.2 for older Python versions
        class _Helper:
            def __repr__(self):
                return "Type help() for interactive help, " \
                       "or help(object) for help about object."
            def __call__(self, *args, **kwds):
                import pydoc
                return pydoc.help(*args, **kwds)
    else:
        IP.user_ns['help'] = _Helper()

    if DEVDEBUG:
        # For developer debugging only (global flag)
        from IPython import ultraTB
        sys.excepthook = ultraTB.VerboseTB(call_pdb=1)
    else:
        # IPython itself shouldn't crash. This will produce a detailed
        # post-mortem if it does
        from IPython import CrashHandler
        sys.excepthook = CrashHandler.CrashHandler(IP)

    IP.BANNER_PARTS = ['Python %s\n'
                         'Type "copyright", "credits" or "license" '
                         'for more information.\n'
                         % (sys.version.split('\n')[0],),
                         "IPython %s -- An enhanced Interactive Python."
                         % (__version__,),
"""?       -&gt; Introduction to IPython's features.
%magic  -&gt; Information about IPython's 'magic' % functions.
help    -&gt; Python's own help system.
object? -&gt; Details about 'object'. ?object also works, ?? prints more.
""" ]</t>
<t tx="ekr.20050704165326.271">
@language python
&lt;&lt; Itpl declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704165326.272"># -*- coding: utf-8 -*-
"""String interpolation for Python (by Ka-Ping Yee, 14 Feb 2000).

This module lets you quickly and conveniently interpolate values into
strings (in the flavour of Perl or Tcl, but with less extraneous
punctuation).  You get a bit more power than in the other languages,
because this module allows subscripting, slicing, function calls,
attribute lookup, or arbitrary expressions.  Variables and expressions
are evaluated in the namespace of the caller.

The itpl() function returns the result of interpolating a string, and
printpl() prints out an interpolated string.  Here are some examples:

    from Itpl import printpl
    printpl("Here is a $string.")
    printpl("Here is a $module.member.")
    printpl("Here is an $object.member.")
    printpl("Here is a $functioncall(with, arguments).")
    printpl("Here is an ${arbitrary + expression}.")
    printpl("Here is an $array[3] member.")
    printpl("Here is a $dictionary['member'].")

The filter() function filters a file object so that output through it
is interpolated.  This lets you produce the illusion that Python knows
how to do interpolation:

    import Itpl
    sys.stdout = Itpl.filter()
    f = "fancy"
    print "Isn't this $f?"
    print "Standard output has been replaced with a $sys.stdout object."
    sys.stdout = Itpl.unfilter()
    print "Okay, back $to $normal."

Under the hood, the Itpl class represents a string that knows how to
interpolate values.  An instance of the class parses the string once
upon initialization; the evaluation and substitution can then be done
each time the instance is evaluated with str(instance).  For example:

    from Itpl import Itpl
    s = Itpl("Here is $foo.")
    foo = 5
    print str(s)
    foo = "bar"
    print str(s)

$Id$
"""                   # ' -&gt; close an open quote for stupid emacs

#*****************************************************************************
#
# Copyright (c) 2001 Ka-Ping Yee &lt;ping@lfw.org&gt;
#
#
# Published under the terms of the MIT license, hereby reproduced:
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
#*****************************************************************************

__author__  = 'Ka-Ping Yee &lt;ping@lfw.org&gt;'
__license__ = 'MIT'

import sys, string
from types import StringType
from tokenize import tokenprog

</t>
<t tx="ekr.20050704165326.273">class ItplError(ValueError):
	@others
</t>
<t tx="ekr.20050704165326.274">def __init__(self, text, pos):
    self.text = text
    self.pos = pos
</t>
<t tx="ekr.20050704165326.275">def __str__(self):
    return "unfinished expression in %s at char %d" % (
        repr(self.text), self.pos)
</t>
<t tx="ekr.20050704165326.276">def matchorfail(text, pos):
    match = tokenprog.match(text, pos)
    if match is None:
        raise ItplError(text, pos)
    return match, match.end()
</t>
<t tx="ekr.20050704165326.277">
class Itpl:
    """Class representing a string with interpolation abilities.
    
    Upon creation, an instance works out what parts of the format
    string are literal and what parts need to be evaluated.  The
    evaluation and substitution happens in the namespace of the
    caller when str(instance) is called."""
	@others
</t>
<t tx="ekr.20050704165326.278">def __init__(self, format):
    """The single argument to this constructor is a format string.

    The format string is parsed according to the following rules:

    1.  A dollar sign and a name, possibly followed by any of: 
          - an open-paren, and anything up to the matching paren 
          - an open-bracket, and anything up to the matching bracket 
          - a period and a name 
        any number of times, is evaluated as a Python expression.

    2.  A dollar sign immediately followed by an open-brace, and
        anything up to the matching close-brace, is evaluated as
        a Python expression.

    3.  Outside of the expressions described in the above two rules,
        two dollar signs in a row give you one literal dollar sign."""

    if type(format) != StringType:
        raise TypeError, "needs string initializer"
    self.format = format

    namechars = "abcdefghijklmnopqrstuvwxyz" \
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
    chunks = []
    pos = 0

    while 1:
        dollar = string.find(format, "$", pos)
        if dollar &lt; 0: break
        nextchar = format[dollar+1]

        if nextchar == "{":
            chunks.append((0, format[pos:dollar]))
            pos, level = dollar+2, 1
            while level:
                match, pos = matchorfail(format, pos)
                tstart, tend = match.regs[3]
                token = format[tstart:tend]
                if token == "{": level = level+1
                elif token == "}": level = level-1
            chunks.append((1, format[dollar+2:pos-1]))

        elif nextchar in namechars:
            chunks.append((0, format[pos:dollar]))
            match, pos = matchorfail(format, dollar+1)
            while pos &lt; len(format):
                if format[pos] == "." and \
                    pos+1 &lt; len(format) and format[pos+1] in namechars:
                    match, pos = matchorfail(format, pos+1)
                elif format[pos] in "([":
                    pos, level = pos+1, 1
                    while level:
                        match, pos = matchorfail(format, pos)
                        tstart, tend = match.regs[3]
                        token = format[tstart:tend]
                        if token[0] in "([": level = level+1
                        elif token[0] in ")]": level = level-1
                else: break
            chunks.append((1, format[dollar+1:pos]))

        else:
            chunks.append((0, format[pos:dollar+1]))
            pos = dollar + 1 + (nextchar == "$")

    if pos &lt; len(format): chunks.append((0, format[pos:]))
    self.chunks = chunks
</t>
<t tx="ekr.20050704165326.279">def __repr__(self):
    return "&lt;Itpl %s &gt;" % repr(self.format)
</t>
<t tx="ekr.20050704165326.280">def __str__(self):
    """Evaluate and substitute the appropriate parts of the string."""

    # We need to skip enough frames to get to the actual caller outside of
    # Itpl.
    frame = sys._getframe(1)
    while frame.f_globals["__name__"] == __name__: frame = frame.f_back
    loc, glob = frame.f_locals, frame.f_globals

    result = []
    for live, chunk in self.chunks:
        if live: result.append(str(eval(chunk,glob,loc)))
        else: result.append(chunk)

    return ''.join(result)
</t>
<t tx="ekr.20050704165326.281">
class ItplNS(Itpl):
    """Class representing a string with interpolation abilities.

    This inherits from Itpl, but at creation time a namespace is provided
    where the evaluation will occur.  The interpolation becomes a bit more
    efficient, as no traceback needs to be extracte.  It also allows the
    caller to supply a different namespace for the interpolation to occur than
    its own."""
	@others
</t>
<t tx="ekr.20050704165326.282">def __init__(self, format,globals,locals=None):
    """ItplNS(format,globals[,locals]) -&gt; interpolating string instance.

    This constructor, besides a format string, takes a globals dictionary
    and optionally a locals (which defaults to globals if not provided).

    For further details, see the Itpl constructor."""

    if locals is None:
        locals = globals
    self.globals = globals
    self.locals = locals
    Itpl.__init__(self,format)
</t>
<t tx="ekr.20050704165326.283">def __str__(self):
    """Evaluate and substitute the appropriate parts of the string."""
    glob = self.globals
    loc = self.locals
    result = []
    for live, chunk in self.chunks:
        if live: result.append(str(eval(chunk,glob,loc)))
        else: result.append(chunk)
    return ''.join(result)
</t>
<t tx="ekr.20050704165326.284"># utilities for fast printing
def itpl(text): return str(Itpl(text))
</t>
<t tx="ekr.20050704165326.285">def printpl(text): print itpl(text)
</t>
<t tx="ekr.20050704165326.286"># versions with namespace
def itplns(text,globals,locals=None): return str(ItplNS(text,globals,locals))
</t>
<t tx="ekr.20050704165326.287">def printplns(text,globals,locals=None): print itplns(text,globals,locals)
</t>
<t tx="ekr.20050704165326.288">
class ItplFile:
    """A file object that filters each write() through an interpolator."""
	@others
</t>
<t tx="ekr.20050704165326.289">def __init__(self, file): self.file = file
</t>
<t tx="ekr.20050704165326.290">def __repr__(self): return "&lt;interpolated " + repr(self.file) + "&gt;"
</t>
<t tx="ekr.20050704165326.291">def __getattr__(self, attr): return getattr(self.file, attr)
</t>
<t tx="ekr.20050704165326.292">def write(self, text): self.file.write(str(Itpl(text)))
</t>
<t tx="ekr.20050704165326.293">def filter(file=sys.stdout):
    """Return an ItplFile that filters writes to the given file object.
    
    'file = filter(file)' replaces 'file' with a filtered object that
    has a write() method.  When called with no argument, this creates
    a filter to sys.stdout."""
    return ItplFile(file)
</t>
<t tx="ekr.20050704165326.294">def unfilter(ifile=None):
    """Return the original file that corresponds to the given ItplFile.
    
    'file = unfilter(file)' undoes the effect of 'file = filter(file)'.
    'sys.stdout = unfilter()' undoes the effect of 'sys.stdout = filter()'."""
    return ifile and ifile.file or sys.stdout.file
</t>
<t tx="ekr.20050704165326.295">@first # -*- coding: utf-8 -*-
"""
Logger class for IPython's logging facilities.

$Id$
"""

@language python

&lt;&lt; Logger declarations &gt;&gt;

#****************************************************************************
# FIXME: The logger class shouldn't be a mixin, it throws too many things into
# the InteractiveShell namespace. Rather make it a standalone tool, and create
# a Logger instance in InteractiveShell that uses it. Doing this will require
# tracking down a *lot* of nasty uses of the Logger attributes in
# InteractiveShell, but will clean up things quite a bit.

@others
</t>
<t tx="ekr.20050704165326.296">#****************************************************************************
# Modules and globals

from IPython import Release

__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
              ( Release.authors['Janko'] + Release.authors['Fernando'] )
__license__ = Release.license

# Python standard modules
import os,sys,glob

# Homebrewed
from IPython.genutils import *</t>
<t tx="ekr.20050704165326.297">class Logger:

    """A Logfile Mixin class with different policies for file creation"""
    
	# FIXME: once this isn't a mixin, log_ns should just be 'namespace',
    # since the names won't collide anymore.

	@others</t>
<t tx="ekr.20050704165326.299">def __init__(self,log_ns):
    self._i00,self._i,self._ii,self._iii = '','','',''
    self.do_full_cache = 0 # FIXME. There's also a do_full.. in OutputCache
    self.log_ns = log_ns
    # defaults
    self.LOGMODE = 'backup'
    self.defname = 'logfile'
</t>
<t tx="ekr.20050704165326.300">def create_log(self,header='',fname='',defname='.Logger.log'):
    """Generate a new log-file with a default header"""
    if fname:
        self.LOG = fname

    if self.LOG:
        self.logfname = self.LOG
    else:
        self.logfname = defname
    
    if self.LOGMODE == 'over':
        if os.path.isfile(self.logfname):
            os.remove(self.logfname) 
        self.logfile = open(self.logfname,'w')
    if self.LOGMODE == 'backup':
        if os.path.isfile(self.logfname):
            backup_logname = self.logfname+'~'
            # Manually remove any old backup, since os.rename may fail
            # under Windows.
            if os.path.isfile(backup_logname):
                os.remove(backup_logname)
            os.rename(self.logfname,backup_logname)
        self.logfile = open(self.logfname,'w')
    elif self.LOGMODE == 'global':
        self.logfname = os.path.join(self.home_dir, self.defname)
        self.logfile = open(self.logfname, 'a')
        self.LOG = self.logfname
    elif self.LOGMODE == 'rotate':
        if os.path.isfile(self.logfname):
            if os.path.isfile(self.logfname+'.001~'): 
                old = glob.glob(self.logfname+'.*~')
                old.sort()
                old.reverse()
                for f in old:
                    root, ext = os.path.splitext(f)
                    num = int(ext[1:-1])+1
                    os.rename(f, root+'.'+`num`.zfill(3)+'~')
            os.rename(self.logfname, self.logfname+'.001~')
        self.logfile = open(self.logfname,'w')
    elif self.LOGMODE == 'append':
        self.logfile = open(self.logfname,'a')
        
    if self.LOGMODE != 'append':
        self.logfile.write(header)
    self.logfile.flush()
</t>
<t tx="ekr.20050704165326.301">def logstart(self, header='',parameter_s = ''):
    if not hasattr(self, 'LOG'):
        logfname = self.LOG or parameter_s or './'+self.defname
        self.create_log(header,logfname)
    elif parameter_s and hasattr(self,'logfname') and \
         parameter_s != self.logfname:
        self.close_log()
        self.create_log(header,parameter_s)
        
    self._dolog = 1
</t>
<t tx="ekr.20050704165326.302">def switch_log(self,val):
    """Switch logging on/off. val should be ONLY 0 or 1."""

    if not val in [0,1]:
        raise ValueError, \
              'Call switch_log ONLY with 0 or 1 as argument, not with:',val
    
    label = {0:'OFF',1:'ON'}

    try:
        _ = self.logfile
    except AttributeError:
        print """
Logging hasn't been started yet (use %logstart for that).

%logon/%logoff are for temporarily starting and stopping logging for a logfile
which already exists. But you must first start the logging process with
%logstart (optionally giving a logfile name)."""
        
    else:
        if self._dolog == val:
            print 'Logging is already',label[val]
        else:
            print 'Switching logging',label[val]
            self._dolog = 1 - self._dolog
</t>
<t tx="ekr.20050704165326.303">def logstate(self):
    """Print a status message about the logger."""
    try:
        logfile = self.logfname
    except:
        print 'Logging has not been activated.'
    else:
        state = self._dolog and 'active' or 'temporarily suspended'
        print """
File:\t%s
Mode:\t%s
State:\t%s """ % (logfile,self.LOGMODE,state)
</t>
<t tx="ekr.20050704165326.304">def log(self, line,continuation=None):
    """Write the line to a log and create input cache variables _i*."""

    # update the auto _i tables
    #print '***logging line',line # dbg
    #print '***cache_count', self.outputcache.prompt_count # dbg
    input_hist = self.log_ns['_ih']
    if not continuation and line:
        self._iii = self._ii
        self._ii = self._i
        self._i = self._i00
        # put back the final \n of every input line
        self._i00 = line+'\n'
        #print 'Logging input:&lt;%s&gt;' % line  # dbg
        input_hist.append(self._i00)

    # hackish access to top-level namespace to create _i1,_i2... dynamically
    to_main = {'_i':self._i,'_ii':self._ii,'_iii':self._iii}
    if self.do_full_cache:
        in_num = self.outputcache.prompt_count
        # add blank lines if the input cache fell out of sync. This can happen
        # for embedded instances which get killed via C-D and then get resumed.
        while in_num &gt;= len(input_hist):
            input_hist.append('\n')
        new_i = '_i%s' % in_num
        if continuation:
            self._i00 = '%s%s\n' % (self.log_ns[new_i],line)
            input_hist[in_num] = self._i00
        to_main[new_i] = self._i00
    self.log_ns.update(to_main)
    
    if self._dolog and line:
        self.logfile.write(line+'\n')
        self.logfile.flush()
</t>
<t tx="ekr.20050704165326.305">def close_log(self):
    if hasattr(self, 'logfile'):
        self.logfile.close()
        self.logfname = ''
</t>
<t tx="ekr.20050704165326.306">
@language python
&lt;&lt; Magic declarations &gt;&gt;
@others
# end Magic
</t>
<t tx="ekr.20050704165326.307"># -*- coding: utf-8 -*-
"""Magic functions for InteractiveShell.

$Id$"""

#****************************************************************************
# Modules and globals

from IPython import Release
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % \
              ( Release.authors['Janko'] + Release.authors['Fernando'] )
__license__ = Release.license

# Python standard modules
import __builtin__
import os,sys,inspect,pydoc,re,tempfile,shlex,pdb,bdb,time
try:
    import profile,pstats
except ImportError:
    profile = pstats = None
from getopt import getopt
from pprint import pprint, pformat
from cStringIO import StringIO

# Homebrewed
from IPython.Struct import Struct
from IPython.Itpl import Itpl, itpl, printpl,itplns
from IPython.FakeModule import FakeModule
from IPython import OInspect
from IPython.genutils import *

# Globals to be set later by Magic constructor
MAGIC_PREFIX = ''
MAGIC_ESCAPE = ''</t>
<t tx="ekr.20050704165326.308">def magic2python(cmd):
    """Convert a command string of magic syntax to valid Python code."""

    if cmd.startswith('#'+MAGIC_ESCAPE) or \
           cmd.startswith(MAGIC_ESCAPE):
        if cmd[0]=='#':
            cmd = cmd[1:]
        # we need to return the proper line end later
        if cmd[-1] == '\n':
            endl = '\n'
        else:
            endl = ''
        try:
            func,args = cmd[1:].split(' ',1)
        except:
            func,args = cmd[1:].rstrip(),''
        args = args.replace('"','\\"').replace("'","\\'").rstrip()
        return '%s%s ("%s")%s' % (MAGIC_PREFIX,func,args,endl)
    else:
        return cmd
</t>
<t tx="ekr.20050704165326.309">def on_off(tag):
    """Return an ON/OFF string for a 1/0 input. Simple utility function."""
    return ['OFF','ON'][tag]
</t>
<t tx="ekr.20050704165326.310">def get_py_filename(name):
    """Return a valid python filename in the current directory.

    If the given name is not a file, it adds '.py' and searches again.
    Raises IOError with an informative message if the file isn't found."""

    name = os.path.expanduser(name)
    if not os.path.isfile(name) and not name.endswith('.py'):
        name += '.py'
    if os.path.isfile(name):
        return name
    else:
        raise IOError,'File `%s` not found.' % name
</t>
<t tx="ekr.20050704165326.311"># Try to use shlex.split for converting an input string into a sys.argv-type
# list.  This appeared in Python 2.3, so here's a quick backport for 2.2.
try:
    shlex_split = shlex.split
except AttributeError:
    _quotesre = re.compile(r'[\'"](.*)[\'"]')
    _wordchars = ('abcdfeghijklmnopqrstuvwxyz'
                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.~*?'
                  'ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿'
                  'Ã€Ã�Ã‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃ�ÃŽÃ�Ã�Ã‘Ã’Ã“Ã”Ã•Ã–Ã˜Ã™ÃšÃ›ÃœÃ�Ãž%s'
                  % os.sep)
    
    def shlex_split(s):
        """Simplified backport to Python 2.2 of shlex.split().

        This is a quick and dirty hack, since the shlex module under 2.2 lacks
        several of the features needed to really match the functionality of
        shlex.split() in 2.3."""

        lex = shlex.shlex(StringIO(s))
        # Try to get options, extensions and path separators as characters
        lex.wordchars = _wordchars
        lex.commenters = ''
        # Make a list out of the lexer by hand, since in 2.2 it's not an
        # iterator.
        lout = []
        while 1:
            token = lex.get_token()
            if token == '':
                break
            # Try to handle quoted tokens correctly
            quotes = _quotesre.match(token)
            if quotes:
                token = quotes.group(1)
            lout.append(token)
        return lout
</t>
<t tx="ekr.20050704165326.312"># Utility classes
class Macro:
    """Simple class to store the value of macros as strings.

    This allows us to later exec them by checking when something is an
    instance of this class."""

	@others
</t>
<t tx="ekr.20050704165326.313">def __init__(self,cmds):
    """Build a macro from a list of commands."""

    # Since the list may include multi-line entries, first make sure that
    # they've been all broken up before passing it to magic2python
    cmdlist = map(magic2python,''.join(cmds).split('\n'))
    self.value = '\n'.join(cmdlist)</t>
<t tx="ekr.20050704165326.314">def __str__(self):
    return self.value
</t>
<t tx="ekr.20050704165326.315"># Main class implementing Magic functionality
class Magic:

    """Magic functions for InteractiveShell.

    Shell functions which can be reached as %function_name. All magic
    functions should accept a string, which they can parse for their own
    needs. This can make some functions easier to type, eg `%cd ../`
    vs. `%cd("../")`

    ALL definitions MUST begin with the prefix magic_. The user won't need it
    at the command line, but it is is needed in the definition. """
	
    # class globals
    auto_status = [
        'Automagic is OFF, % prefix IS needed for magic functions.',
        'Automagic is ON, % prefix NOT needed for magic functions.']

	@others
</t>
<t tx="ekr.20050704165326.317">def __init__(self,shell):

    # XXX This is hackish, clean up later to avoid these messy globals
    global MAGIC_PREFIX, MAGIC_ESCAPE
    
    self.options_table = {}
    MAGIC_PREFIX = shell.name+'.magic_'
    MAGIC_ESCAPE = shell.ESC_MAGIC
    if profile is None:
        self.magic_prun = self.profile_missing_notice
</t>
<t tx="ekr.20050704165326.318">def profile_missing_notice(self, *args, **kwargs):
    error("""\
The profile module could not be found.  If you are a Debian user,
it has been removed from the standard Debian package because of its non-free
license. To use profiling, please install"python2.3-profiler" from non-free.""")
</t>
<t tx="ekr.20050704165326.319">def default_option(self,fn,optstr):
    """Make an entry in the options_table for fn, with value optstr"""
    
    if fn not in self.lsmagic():
        error("%s is not a magic function" % fn)
    self.options_table[fn] = optstr
</t>
<t tx="ekr.20050704165326.320">def lsmagic(self):
    """Return a list of currently available magic functions.

    Gives a list of the bare names after mangling (['ls','cd', ...], not
    ['magic_ls','magic_cd',...]"""

    # FIXME. This needs a cleanup, in the way the magics list is built.
    
    # magics in class definition
    class_magic = lambda fn: fn.startswith('magic_') and \
                  callable(Magic.__dict__[fn])
    # in instance namespace (run-time user additions)
    inst_magic =  lambda fn: fn.startswith('magic_') and \
                 callable(self.__dict__[fn])
    # and bound magics by user (so they can access self):
    inst_bound_magic =  lambda fn: fn.startswith('magic_') and \
                       callable(self.__class__.__dict__[fn])
    magics = filter(class_magic,Magic.__dict__.keys()) + \
             filter(inst_magic,self.__dict__.keys()) + \
             filter(inst_bound_magic,self.__class__.__dict__.keys())
    out = []
    for fn in magics:
        out.append(fn.replace('magic_','',1))
    out.sort()
    return out
</t>
<t tx="ekr.20050704165326.321">def set_shell(self,shell):
    self.shell = shell
    self.alias_table = shell.alias_table
</t>
<t tx="ekr.20050704165326.322">def extract_input_slices(self,slices):
    """Return as a string a set of input history slices.

    The set of slices is given as a list of strings (like ['1','4:8','9'],
    since this function is for use by magic functions which get their
    arguments as strings."""

    cmds = []
    for chunk in slices:
        if ':' in chunk:
            ini,fin = map(int,chunk.split(':'))
        else:
            ini = int(chunk)
            fin = ini+1
        cmds.append(self.shell.input_hist[ini:fin])
    return cmds
</t>
<t tx="ekr.20050704165326.323">def _ofind(self,oname):
    """Find an object in the available namespaces.

    self._ofind(oname) -&gt; dict with keys: found,obj,ospace,ismagic

    Has special code to detect magic functions.
    """
    
    oname = oname.strip()

    # Namespaces to search in:
    user_ns        = self.shell.user_ns
    internal_ns    = self.shell.internal_ns
    builtin_ns     = __builtin__.__dict__
    alias_ns       = self.shell.alias_table

    # Put them in a list. The order is important so that we find things in
    # the same order that Python finds them.
    namespaces = [ ('Interactive',user_ns),
                   ('IPython internal',internal_ns),
                   ('Python builtin',builtin_ns),
                   ('Alias',alias_ns),
                   ]

    # initialize results to 'null'
    found = 0; obj = None;  ospace = None;  ds = None;
    ismagic = 0; isalias = 0

    # Look for the given name by splitting it in parts.  If the head is
    # found, then we look for all the remaining parts as members, and only
    # declare success if we can find them all.
    oname_parts = oname.split('.')
    oname_head, oname_rest = oname_parts[0],oname_parts[1:]
    for nsname,ns in namespaces:
        try:
            obj = ns[oname_head]
        except KeyError:
            continue
        else:
            for part in oname_rest:
                try:
                    obj = getattr(obj,part)
                except:
                    # Blanket except b/c some badly implemented objects
                    # allow __getattr__ to raise exceptions other than
                    # AttributeError, which then crashes IPython.
                    break
            else:
                # If we finish the for loop (no break), we got all members
                found = 1
                ospace = nsname
                if ns == alias_ns:
                    isalias = 1
                break  # namespace loop

    # Try to see if it's magic
    if not found:
        if oname.startswith(self.shell.ESC_MAGIC):
            oname = oname[1:]
        obj = getattr(self,'magic_'+oname,None)
        if obj is not None:
            found = 1
            ospace = 'IPython internal'
            ismagic = 1

    # Last try: special-case some literals like '', [], {}, etc:
    if not found and oname_head in ["''",'""','[]','{}','()']:
        obj = eval(oname_head)
        found = 1
        ospace = 'Interactive'
        
    return {'found':found, 'obj':obj, 'namespace':ospace,
            'ismagic':ismagic, 'isalias':isalias}
</t>
<t tx="ekr.20050704165326.324">def arg_err(self,func):
    """Print docstring if incorrect arguments were passed"""
    print 'Error in arguments:'
    print OInspect.getdoc(func)
</t>
<t tx="ekr.20050704165326.325">def format_latex(self,str):
    """Format a string for latex inclusion."""

    # Characters that need to be escaped for latex:
    escape_re = re.compile(r'(%|_|\$)',re.MULTILINE)
    # Magic command names as headers:
    cmd_name_re = re.compile(r'^(%s.*?):' % self.shell.ESC_MAGIC,
                             re.MULTILINE)
    # Magic commands 
    cmd_re = re.compile(r'(?P&lt;cmd&gt;%s.+?\b)(?!\}\}:)' % self.shell.ESC_MAGIC,
                        re.MULTILINE)
    # Paragraph continue
    par_re = re.compile(r'\\$',re.MULTILINE)

    str = cmd_name_re.sub(r'\n\\texttt{\\textsl{\\large \1}}:',str)
    str = cmd_re.sub(r'\\texttt{\g&lt;cmd&gt;}',str)
    str = par_re.sub(r'\\\\',str)
    str = escape_re.sub(r'\\\1',str)
    return str
</t>
<t tx="ekr.20050704165326.326">def format_screen(self,str):
    """Format a string for screen printing.

    This removes some latex-type format codes."""
    # Paragraph continue
    par_re = re.compile(r'\\$',re.MULTILINE)
    str = par_re.sub('',str)
    return str
</t>
<t tx="ekr.20050704165326.327">def parse_options(self,arg_str,opt_str,*long_opts,**kw):
    """Parse options passed to an argument string.

    The interface is similar to that of getopt(), but it returns back a
    Struct with the options as keys and the stripped argument string still
    as a string.

    arg_str is quoted as a true sys.argv vector by calling on the fly a
    python process in a subshell.  This allows us to easily expand
    variables, glob files, quote arguments, etc, with all the power and
    correctness of the underlying system shell.

    Options:
      -mode: default 'string'. If given as 'list', the argument string is
      returned as a list (split on whitespace) instead of a string.

      -list_all: put all option values in lists. Normally only options
      appearing more than once are put in a list."""

    # inject default options at the beginning of the input line
    caller = sys._getframe(1).f_code.co_name.replace('magic_','')
    arg_str = '%s %s' % (self.options_table.get(caller,''),arg_str)
    
    mode = kw.get('mode','string')
    if mode not in ['string','list']:
        raise ValueError,'incorrect mode given: %s' % mode
    # Get options
    list_all = kw.get('list_all',0)

    # Check if we have more than one argument to warrant extra processing:
    odict = {}  # Dictionary with options
    args = arg_str.split()
    if len(args) &gt;= 1:
        # If the list of inputs only has 0 or 1 thing in it, there's no
        # need to look for options
        argv = shlex_split(arg_str)
        # Do regular option processing
        opts,args = getopt(argv,opt_str,*long_opts)
        for o,a in opts:
            if o.startswith('--'):
                o = o[2:]
            else:
                o = o[1:]
            try:
                odict[o].append(a)
            except AttributeError:
                odict[o] = [odict[o],a]
            except KeyError:
                if list_all:
                    odict[o] = [a]
                else:
                    odict[o] = a

    # Prepare opts,args for return
    opts = Struct(odict)
    if mode == 'string':
        args = ' '.join(args)

    return opts,args
</t>
<t tx="ekr.20050704165326.328">#......................................................................
# And now the actual magic functions

# Functions for IPython shell work (vars,funcs, config, etc)
def magic_lsmagic(self, parameter_s = ''):
    """List currently available magic functions."""
    mesc = self.shell.ESC_MAGIC
    print 'Available magic functions:\n'+mesc+\
          ('  '+mesc).join(self.lsmagic())
    print '\n' + Magic.auto_status[self.shell.rc.automagic]
    return None
</t>
<t tx="ekr.20050704165326.329">def magic_magic(self, parameter_s = ''):
    """Print information about the magic function system."""

    mode = ''
    try:
        if parameter_s.split()[0] == '-latex':
            mode = 'latex'
    except:
        pass

    magic_docs = []
    for fname in self.lsmagic():
        mname = 'magic_' + fname
        for space in (Magic,self,self.__class__):
            try:
                fn = space.__dict__[mname]
            except KeyError:
                pass
            else:
                break
        magic_docs.append('%s%s:\n\t%s\n' %(self.shell.ESC_MAGIC,
                                            fname,fn.__doc__))
    magic_docs = ''.join(magic_docs)

    if mode == 'latex':
        print self.format_latex(magic_docs)
        return
    else:
        magic_docs = self.format_screen(magic_docs)
    
    outmsg = """
IPython's 'magic' functions
===========================

The magic function system provides a series of functions which allow you to
control the behavior of IPython itself, plus a lot of system-type
features. All these functions are prefixed with a % character, but parameters
are given without parentheses or quotes.

NOTE: If you have 'automagic' enabled (via the command line option or with the
%automagic function), you don't need to type in the % explicitly.  By default,
IPython ships with automagic on, so you should only rarely need the % escape.

Example: typing '%cd mydir' (without the quotes) changes you working directory
to 'mydir', if it exists.

You can define your own magic functions to extend the system. See the supplied
ipythonrc and example-magic.py files for details (in your ipython
configuration directory, typically $HOME/.ipython/).

You can also define your own aliased names for magic functions. In your
ipythonrc file, placing a line like:

execute __IPYTHON__.magic_pf = __IPYTHON__.magic_profile

will define %pf as a new name for %profile.

You can also call magics in code using the ipmagic() function, which IPython
automatically adds to the builtin namespace.  Type 'ipmagic?' for details.

For a list of the available magic functions, use %lsmagic. For a description
of any of them, type %magic_name?, e.g. '%cd?'.

Currently the magic system has the following functions:\n"""

    mesc = self.shell.ESC_MAGIC
    outmsg = ("%s\n%s\n\nSummary of magic functions (from %slsmagic):"
              "\n\n%s%s\n\n%s" % (outmsg,
                                 magic_docs,mesc,mesc,
                                 ('  '+mesc).join(self.lsmagic()),
                                 Magic.auto_status[self.shell.rc.automagic] ) )

    page(outmsg,screen_lines=self.shell.rc.screen_length)
</t>
<t tx="ekr.20050704165326.330">def magic_automagic(self, parameter_s = ''):
    """Make magic functions callable without having to type the initial %.
    
    Toggles on/off (when off, you must call it as %automagic, of
    course). Note that magic functions have lowest priority, so if there's
    a variable whose name collides with that of a magic fn, automagic
    won't work for that function (you get the variable instead). However,
    if you delete the variable (del var), the previously shadowed magic
    function becomes visible to automagic again."""

    rc = self.shell.rc
    rc.automagic = not rc.automagic
    print '\n' + Magic.auto_status[rc.automagic]
</t>
<t tx="ekr.20050704165326.331">def magic_autocall(self, parameter_s = ''):
    """Make functions callable without having to type parentheses.

    This toggles the autocall command line option on and off."""
    
    rc = self.shell.rc
    rc.autocall = not rc.autocall
    print "Automatic calling is:",['OFF','ON'][rc.autocall]
</t>
<t tx="ekr.20050704165326.332">def magic_autoindent(self, parameter_s = ''):
    """Toggle autoindent on/off (if available)."""

    self.shell.set_autoindent()
    print "Automatic indentation is:",['OFF','ON'][self.shell.autoindent]
</t>
<t tx="ekr.20050704165326.333">def magic_system_verbose(self, parameter_s = ''):
    """Toggle verbose printing of system calls on/off."""

    self.shell.rc_set_toggle('system_verbose')
    print "System verbose printing is:",\
          ['OFF','ON'][self.shell.rc.system_verbose]
</t>
<t tx="ekr.20050704165326.334">def magic_history(self, parameter_s = ''):
    """Print input history (_i&lt;n&gt; variables), with most recent last.
    
    %history [-n]       -&gt; print at most 40 inputs (some may be multi-line)\\
    %history [-n] n     -&gt; print at most n inputs\\
    %history [-n] n1 n2 -&gt; print inputs between n1 and n2 (n2 not included)\\

    Each input's number &lt;n&gt; is shown, and is accessible as the
    automatically generated variable _i&lt;n&gt;.  Multi-line statements are
    printed starting at a new line for easy copy/paste.

    If option -n is used, input numbers are not printed. This is useful if
    you want to get a printout of many lines which can be directly pasted
    into a text editor.

    This feature is only available if numbered prompts are in use."""

    if not self.do_full_cache:
        print 'This feature is only available if numbered prompts are in use.'
        return
    opts,args = self.parse_options(parameter_s,'n',mode='list')
    
    default_length = 40
    if len(args) == 0:
        final = self.outputcache.prompt_count
        init = max(1,final-default_length)
    elif len(args) == 1:
        final = self.outputcache.prompt_count
        init = max(1,final-int(args[0]))
    elif len(args) == 2:
        init,final = map(int,args)
    else:
        warn('%hist takes 0, 1 or 2 arguments separated by spaces.')
        print self.magic_hist.__doc__
        return
    width = len(str(final))
    line_sep = ['','\n']
    input_hist = self.shell.input_hist
    print_nums = not opts.has_key('n')
    for in_num in range(init,final):
        inline = input_hist[in_num]
        multiline = inline.count('\n') &gt; 1
        if print_nums:
            print str(in_num).ljust(width)+':'+ line_sep[multiline],
        if inline.startswith('#'+self.shell.ESC_MAGIC) or \
               inline.startswith('#!'):
            print inline[1:],
        else:
            print inline,
</t>
<t tx="ekr.20050704165326.335">def magic_hist(self, parameter_s=''):
    """Alternate name for %history."""
    return self.magic_history(parameter_s)
</t>
<t tx="ekr.20050704165326.336">def magic_p(self, parameter_s=''):
    """Just a short alias for Python's 'print'."""
    exec 'print ' + parameter_s in self.shell.user_ns
</t>
<t tx="ekr.20050704165326.337">def magic_r(self, parameter_s=''):
    """Repeat previous input.

    If given an argument, repeats the previous command which starts with
    the same string, otherwise it just repeats the previous input.

    Shell escaped commands (with ! as first character) are not recognized
    by this system, only pure python code and magic commands.
    """

    start = parameter_s.strip()
    esc_magic = self.shell.ESC_MAGIC
    # Identify magic commands even if automagic is on (which means
    # the in-memory version is different from that typed by the user).
    if self.shell.rc.automagic:
        start_magic = esc_magic+start
    else:
        start_magic = start
    # Look through the input history in reverse
    for n in range(len(self.shell.input_hist)-2,0,-1):
        input = self.shell.input_hist[n]
        # skip plain 'r' lines so we don't recurse to infinity
        if input != 'ipmagic("r")\n' and \
               (input.startswith(start) or input.startswith(start_magic)):
            #print 'match',`input`  # dbg
            if input.startswith(esc_magic):
                input = magic2python(input)
                #print 'modified',`input`  # dbg
            print 'Executing:',input,
            exec input in self.shell.user_ns
            return
    print 'No previous input matching `%s` found.' % start
</t>
<t tx="ekr.20050704165326.338">def magic_page(self, parameter_s=''):
    """Pretty print the object and display it through a pager.
    
    If no parameter is given, use _ (last output)."""
    # After a function contributed by Olivier Aubert, slightly modified.

    oname = parameter_s and parameter_s or '_' 
    info = self._ofind(oname)
    if info['found']:
        page(pformat(info['obj']))
    else:
        print 'Object `%s` not found' % oname
</t>
<t tx="ekr.20050704165326.339">def magic_profile(self, parameter_s=''):
    """Print your currently active IPyhton profile."""
    if self.shell.rc.profile:
        printpl('Current IPython profile: $self.shell.rc.profile.')
    else:
        print 'No profile active.'
</t>
<t tx="ekr.20050704165326.340">def _inspect(self,meth,oname,**kw):
    """Generic interface to the inspector system.

    This function is meant to be called by pdef, pdoc &amp; friends."""
    
    oname = oname.strip()
    info = Struct(self._ofind(oname))
    if info.found:
        pmethod = getattr(self.shell.inspector,meth)
        formatter = info.ismagic and self.format_screen or None
        if meth == 'pdoc':
            pmethod(info.obj,oname,formatter)
        elif meth == 'pinfo':
            pmethod(info.obj,oname,formatter,info,**kw)
        else:
            pmethod(info.obj,oname)
    else:
        print 'Object `%s` not found.' % oname
        return 'not found'  # so callers can take other action
</t>
<t tx="ekr.20050704165326.341">def magic_pdef(self, parameter_s=''):
    """Print the definition header for any callable object.

    If the object is a class, print the constructor information."""
    self._inspect('pdef',parameter_s)
</t>
<t tx="ekr.20050704165326.342">def magic_pdoc(self, parameter_s=''):
    """Print the docstring for an object.

    If the given object is a class, it will print both the class and the
    constructor docstrings."""
    self._inspect('pdoc',parameter_s)
</t>
<t tx="ekr.20050704165326.343">def magic_psource(self, parameter_s=''):
    """Print (or run through pager) the source code for an object."""
    self._inspect('psource',parameter_s)
</t>
<t tx="ekr.20050704165326.344">def magic_pfile(self, parameter_s=''):
    """Print (or run through pager) the file where an object is defined.

    The file opens at the line where the object definition begins. IPython
    will honor the environment variable PAGER if set, and otherwise will
    do its best to print the file in a convenient form.

    If the given argument is not an object currently defined, IPython will
    try to interpret it as a filename (automatically adding a .py extension
    if needed). You can thus use %pfile as a syntax highlighting code
    viewer."""

    # first interpret argument as an object name
    out = self._inspect('pfile',parameter_s)
    # if not, try the input as a filename
    if out == 'not found':
        try:
            filename = get_py_filename(parameter_s)
        except IOError,msg:
            print msg
            return
        page(self.shell.inspector.format(file(filename).read()))
</t>
<t tx="ekr.20050704165326.345">def magic_pinfo(self, parameter_s=''):
    """Provide detailed information about an object.

    '%pinfo object' is just a synonym for object? or ?object."""

    #print 'pinfo par: &lt;%s&gt;' % parameter_s  # dbg

    # detail_level: 0 -&gt; obj? , 1 -&gt; obj??
    detail_level = 0
    # We need to detect if we got called as 'pinfo pinfo foo', which can
    # happen if the user types 'pinfo foo?' at the cmd line.
    pinfo,qmark1,oname,qmark2 = \
           re.match('(pinfo )?(\?*)(.*?)(\??$)',parameter_s).groups()
    if pinfo or qmark1 or qmark2:
        detail_level = 1
    self._inspect('pinfo',oname,detail_level=detail_level)
</t>
<t tx="ekr.20050704165326.346">def magic_who_ls(self, parameter_s=''):
    """Return a sorted list of all interactive variables.

    If arguments are given, only variables of types matching these
    arguments are returned."""

    user_ns = self.shell.user_ns
    out = []
    typelist = parameter_s.split()
    for i in self.shell.user_ns.keys():
        if not (i.startswith('_') or i.startswith('_i')) \
               and not (self.internal_ns.has_key(i) or
                        self.user_config_ns.has_key(i)):
            if typelist:
                if type(user_ns[i]).__name__ in typelist:
                    out.append(i)
            else:
                out.append(i)
    out.sort()
    return out
</t>
<t tx="ekr.20050704165326.347">def magic_who(self, parameter_s=''):
    """Print all interactive variables, with some minimal formatting.

    If any arguments are given, only variables whose type matches one of
    these are printed.  For example:

      %who function str

    will only list functions and strings, excluding all other types of
    variables.  To find the proper type names, simply use type(var) at a
    command line to see how python prints type names.  For example:

      In [1]: type('hello')\\
      Out[1]: &lt;type 'str'&gt;

    indicates that the type name for strings is 'str'.

    %who always excludes executed names loaded through your configuration
    file and things which are internal to IPython.

    This is deliberate, as typically you may load many modules and the
    purpose of %who is to show you only what you've manually defined."""

    varlist = self.magic_who_ls(parameter_s)
    if not varlist:
        print 'Interactive namespace is empty.'
        return

    # if we have variables, move on...

    # stupid flushing problem: when prompts have no separators, stdout is
    # getting lost. I'm starting to think this is a python bug. I'm having
    # to force a flush with a print because even a sys.stdout.flush
    # doesn't seem to do anything!

    count = 0
    for i in varlist:
        print i+'\t',
        count += 1
        if count &gt; 8:
            count = 0
            print
        sys.stdout.flush()  # FIXME. Why the hell isn't this flushing???
        
    print # well, this does force a flush at the expense of an extra \n
</t>
<t tx="ekr.20050704165326.348">def magic_whos(self, parameter_s=''):
    """Like %who, but gives some extra information about each variable.

    The same type filtering of %who can be applied here.

    For all variables, the type is printed. Additionally it prints:
    
      - For {},[],(): their length.

      - For Numeric arrays, a summary with shape, number of elements,
      typecode and size in memory.

      - Everything else: a string representation, snipping their middle if
      too long."""
    
    varnames = self.magic_who_ls(parameter_s)
    if not varnames:
        print 'Interactive namespace is empty.'
        return

    # if we have variables, move on...

    # for these types, show len() instead of data:
    seq_types = [types.DictType,types.ListType,types.TupleType]

    # for Numeric arrays, display summary info
    try:
        import Numeric
    except ImportError:
        array_type = None
    else:
        array_type = Numeric.ArrayType.__name__
    
    # Find all variable names and types so we can figure out column sizes
    get_vars = lambda i: self.locals[i]
    type_name = lambda v: type(v).__name__
    varlist = map(get_vars,varnames)
    typelist = map(type_name,varlist)
    # column labels and # of spaces as separator
    varlabel = 'Variable'
    typelabel = 'Type'
    datalabel = 'Data/Info'
    colsep = 3
    # variable format strings
    vformat    = "$vname.ljust(varwidth)$vtype.ljust(typewidth)"
    vfmt_short = '$vstr[:25]&lt;...&gt;$vstr[-25:]'
    aformat    = "%s: %s elems, type `%s`, %s bytes"
    # find the size of the columns to format the output nicely
    varwidth = max(max(map(len,varnames)), len(varlabel)) + colsep
    typewidth = max(max(map(len,typelist)), len(typelabel)) + colsep
    # table header
    print varlabel.ljust(varwidth) + typelabel.ljust(typewidth) + \
          ' '+datalabel+'\n' + '-'*(varwidth+typewidth+len(datalabel)+1)
    # and the table itself
    kb = 1024
    Mb = 1048576  # kb**2
    for vname,var,vtype in zip(varnames,varlist,typelist):
        print itpl(vformat),
        if vtype in seq_types:
            print len(var)
        elif vtype==array_type:
            vshape = str(var.shape).replace(',','').replace(' ','x')[1:-1]
            vsize  = Numeric.size(var)
            vbytes = vsize*var.itemsize()
            if vbytes &lt; 100000:
                print aformat % (vshape,vsize,var.typecode(),vbytes)
            else:
                print aformat % (vshape,vsize,var.typecode(),vbytes),
                if vbytes &lt; Mb:
                    print '(%s kb)' % (vbytes/kb,)
                else:
                    print '(%s Mb)' % (vbytes/Mb,)
        else:
            vstr = str(var)
            if len(vstr) &lt; 50:
                print vstr
            else:
                printpl(vfmt_short)
</t>
<t tx="ekr.20050704165326.349">def magic_reset(self, parameter_s=''):
    """Resets the namespace by removing all names defined by the user.

    Input/Output history are left around in case you need them."""

    ans = raw_input(
      "Once deleted, variables cannot be recovered. Proceed (y/n)? ")
    if not ans.lower() == 'y':
        print 'Nothing done.'
        return
    for i in self.magic_who_ls():
        del(self.locals[i])
</t>
<t tx="ekr.20050704165326.350">def magic_config(self,parameter_s=''):
    """Show IPython's internal configuration."""
    
    page('Current configuration structure:\n'+
         pformat(self.shell.rc.dict()))
</t>
<t tx="ekr.20050704165326.351">def magic_logstart(self,parameter_s=''):
    """Start logging anywhere in a session.

    %logstart [log_name [log_mode]]

    If no name is given, it defaults to a file named 'ipython.log' in your
    current directory, in 'rotate' mode (see below).

    '%logstart name' saves to file 'name' in 'backup' mode.  It saves your
    history up to that point and then continues logging.

    %logstart takes a second optional parameter: logging mode. This can be one
    of (note that the modes are given unquoted):\\
      over: overwrite existing log.\\
      backup: rename (if exists) to name~ and start name.\\
      append: well, that says it.\\
      rotate: create rotating logs name.1~, name.2~, etc.
    """

    #FIXME. This function should all be moved to the Logger class.
    
    valid_modes = qw('over backup append rotate')
    if self.LOG:
        print 'Logging is already in place. Logfile:',self.LOG
        return

    par = parameter_s.strip()
    if not par:
        logname = self.LOGDEF
        logmode = 'rotate'  # use rotate for the auto-generated logs
    else:
        try:
            logname,logmode = par.split()
        except:
            try:
                logname = par
                logmode = 'backup'
            except:
                warn('Usage: %log [log_name [log_mode]]')
                return
    if not logmode in valid_modes:
        warn('Logging NOT activated.\n'
             'Usage: %log [log_name [log_mode]]\n'
             'Valid modes: '+str(valid_modes))
        return

    # If we made it this far, I think we're ok:
    print 'Activating auto-logging.'
    print 'Current session state plus future input saved to:',logname
    print 'Logging mode: ',logmode
    # put logname into rc struct as if it had been called on the command line,
    # so it ends up saved in the log header
    # Save it in case we need to restore it...
    old_logfile = self.shell.rc.opts.get('logfile','')  
    logname = os.path.expanduser(logname)
    self.shell.rc.opts.logfile = logname
    self.LOGMODE = logmode  # FIXME: this should be set through a function.
    try:
        header = str(self.LOGHEAD)
        self.create_log(header,logname)
        self.logstart(header,logname)
    except:
        self.LOG = ''  # we are NOT logging, something went wrong
        self.shell.rc.opts.logfile = old_logfile
        warn("Couldn't start log: "+str(sys.exc_info()[1]))
    else:  # log input history up to this point
        self.logfile.write(self.shell.user_ns['_ih'][1:])
        self.logfile.flush()
</t>
<t tx="ekr.20050704165326.352">def magic_logoff(self,parameter_s=''):
    """Temporarily stop logging.

    You must have previously started logging."""
    self.switch_log(0)
</t>
<t tx="ekr.20050704165326.353">def magic_logon(self,parameter_s=''):
    """Restart logging.

    This function is for restarting logging which you've temporarily
    stopped with %logoff. For starting logging for the first time, you
    must use the %logstart function, which allows you to specify an
    optional log filename."""
    
    self.switch_log(1)
</t>
<t tx="ekr.20050704165326.354">def magic_logstate(self,parameter_s=''):
    """Print the status of the logging system."""

    self.logstate()
</t>
<t tx="ekr.20050704165326.355">def magic_pdb(self, parameter_s=''):
    """Control the calling of the pdb interactive debugger.

    Call as '%pdb on', '%pdb 1', '%pdb off' or '%pdb 0'. If called without
    argument it works as a toggle.

    When an exception is triggered, IPython can optionally call the
    interactive pdb debugger after the traceback printout. %pdb toggles
    this feature on and off."""

    par = parameter_s.strip().lower()

    if par:
        try:
            pdb = {'off':0,'0':0,'on':1,'1':1}[par]
        except KeyError:
            print 'Incorrect argument. Use on/1, off/0 or nothing for a toggle.'
            return
        else:
           self.shell.InteractiveTB.call_pdb = pdb 
    else:
        self.shell.InteractiveTB.call_pdb = 1 - self.shell.InteractiveTB.call_pdb
    print 'Automatic pdb calling has been turned',\
          on_off(self.shell.InteractiveTB.call_pdb)
</t>
<t tx="ekr.20050704165326.356">def magic_prun(self, parameter_s ='',user_mode=1,
               opts=None,arg_lst=None,prog_ns=None):

    """Run a statement through the python code profiler.

    Usage:\\
      %prun [options] statement

    The given statement (which doesn't require quote marks) is run via the
    python profiler in a manner similar to the profile.run() function.
    Namespaces are internally managed to work correctly; profile.run
    cannot be used in IPython because it makes certain assumptions about
    namespaces which do not hold under IPython.

    Options:

    -l &lt;limit&gt;: you can place restrictions on what or how much of the
    profile gets printed. The limit value can be:

      * A string: only information for function names containing this string
      is printed.

      * An integer: only these many lines are printed.

      * A float (between 0 and 1): this fraction of the report is printed
      (for example, use a limit of 0.4 to see the topmost 40% only).

    You can combine several limits with repeated use of the option. For
    example, '-l __init__ -l 5' will print only the topmost 5 lines of
    information about class constructors.

    -r: return the pstats.Stats object generated by the profiling. This
    object has all the information about the profile in it, and you can
    later use it for further analysis or in other functions.

    Since magic functions have a particular form of calling which prevents
    you from writing something like:\\
      In [1]: p = %prun -r print 4  # invalid!\\
    you must instead use IPython's automatic variables to assign this:\\
      In [1]: %prun -r print 4  \\
      Out[1]: &lt;pstats.Stats instance at 0x8222cec&gt;\\
      In [2]: stats = _

    If you really need to assign this value via an explicit function call,
    you can always tap directly into the true name of the magic function
    by using the ipmagic function (which IPython automatically adds to the
    builtins):\\
      In [3]: stats = ipmagic('prun','-r print 4')

    You can type ipmagic? for more details on ipmagic.

   -s &lt;key&gt;: sort profile by given key. You can provide more than one key
    by using the option several times: '-s key1 -s key2 -s key3...'. The
    default sorting key is 'time'.

    The following is copied verbatim from the profile documentation
    referenced below:

    When more than one key is provided, additional keys are used as
    secondary criteria when the there is equality in all keys selected
    before them.
    
    Abbreviations can be used for any key names, as long as the
    abbreviation is unambiguous.  The following are the keys currently
    defined:

            Valid Arg       Meaning\\
              "calls"      call count\\
              "cumulative" cumulative time\\
              "file"       file name\\
              "module"     file name\\
              "pcalls"     primitive call count\\
              "line"       line number\\
              "name"       function name\\
              "nfl"        name/file/line\\
              "stdname"    standard name\\
              "time"       internal time

    Note that all sorts on statistics are in descending order (placing
    most time consuming items first), where as name, file, and line number
    searches are in ascending order (i.e., alphabetical). The subtle
    distinction between "nfl" and "stdname" is that the standard name is a
    sort of the name as printed, which means that the embedded line
    numbers get compared in an odd way.  For example, lines 3, 20, and 40
    would (if the file names were the same) appear in the string order
    "20" "3" and "40".  In contrast, "nfl" does a numeric compare of the
    line numbers.  In fact, sort_stats("nfl") is the same as
    sort_stats("name", "file", "line").

    -T &lt;filename&gt;: save profile results as shown on screen to a text
    file. The profile is still shown on screen.

    -D &lt;filename&gt;: save (via dump_stats) profile statistics to given
    filename. This data is in a format understod by the pstats module, and
    is generated by a call to the dump_stats() method of profile
    objects. The profile is still shown on screen.

    If you want to run complete programs under the profiler's control, use
    '%run -p [prof_opts] filename.py [args to program]' where prof_opts
    contains profiler specific options as described here.
    
    You can read the complete documentation for the profile module with:\\
      In [1]: import profile; profile.help() """

    opts_def = Struct(D=[''],l=[],s=['time'],T=[''])
    # protect user quote marks
    parameter_s = parameter_s.replace('"',r'\"').replace("'",r"\'")
    
    if user_mode:  # regular user call
        opts,arg_str = self.parse_options(parameter_s,'D:l:rs:T:',
                                          list_all=1)
        namespace = self.shell.user_ns
    else:  # called to run a program by %run -p
        try:
            filename = get_py_filename(arg_lst[0])
        except IOError,msg:
            error(msg)
            return

        arg_str = 'execfile(filename,prog_ns)'
        namespace = locals()

    opts.merge(opts_def)
    
    prof = profile.Profile()
    try:
        prof = prof.runctx(arg_str,namespace,namespace)
        sys_exit = ''
    except SystemExit:
        sys_exit = """*** SystemExit exception caught in code being profiled."""

    stats = pstats.Stats(prof).strip_dirs().sort_stats(*opts.s)

    lims = opts.l
    if lims:
        lims = []  # rebuild lims with ints/floats/strings
        for lim in opts.l:
            try:
                lims.append(int(lim))
            except ValueError:
                try:
                    lims.append(float(lim))
                except ValueError:
                    lims.append(lim)
                
    # trap output
    sys_stdout = sys.stdout
    stdout_trap = StringIO()
    try:
        sys.stdout = stdout_trap
        stats.print_stats(*lims)
    finally:
        sys.stdout = sys_stdout
    output = stdout_trap.getvalue()
    output = output.rstrip()

    page(output,screen_lines=self.shell.rc.screen_length)
    print sys_exit,

    dump_file = opts.D[0]
    text_file = opts.T[0]
    if dump_file:
        prof.dump_stats(dump_file)
        print '\n*** Profile stats marshalled to file',\
              `dump_file`+'.',sys_exit
    if text_file:
        file(text_file,'w').write(output)
        print '\n*** Profile printout saved to text file',\
              `text_file`+'.',sys_exit

    if opts.has_key('r'):
        return stats
    else:
        return None
</t>
<t tx="ekr.20050704165326.357">def magic_run(self, parameter_s ='',runner=None):
    """Run the named file inside IPython as a program.

    Usage:\\
      %run [-n -i -t [-N&lt;N&gt;] -d [-b&lt;N&gt;] -p [profile options]] file [args]

    Parameters after the filename are passed as command-line arguments to
    the program (put in sys.argv). Then, control returns to IPython's
    prompt.

    This is similar to running at a system prompt:\\
      $ python file args\\
    but with the advantage of giving you IPython's tracebacks, and of
    loading all variables into your interactive namespace for further use
    (unless -p is used, see below).

    The file is executed in a namespace initially consisting only of
    __name__=='__main__' and sys.argv constructed as indicated. It thus
    sees its environment as if it were being run as a stand-alone
    program. But after execution, the IPython interactive namespace gets
    updated with all variables defined in the program (except for __name__
    and sys.argv). This allows for very convenient loading of code for
    interactive work, while giving each program a 'clean sheet' to run in.

    Options:
    
    -n: __name__ is NOT set to '__main__', but to the running file's name
    without extension (as python does under import).  This allows running
    scripts and reloading the definitions in them without calling code
    protected by an ' if __name__ == "__main__" ' clause.

    -i: run the file in IPython's namespace instead of an empty one. This
    is useful if you are experimenting with code written in a text editor
    which depends on variables defined interactively.

    -e: ignore sys.exit() calls or SystemExit exceptions in the script
    being run.  This is particularly useful if IPython is being used to
    run unittests, which always exit with a sys.exit() call.  In such
    cases you are interested in the output of the test results, not in
    seeing a traceback of the unittest module.

    -t: print timing information at the end of the run.  IPython will give
    you an estimated CPU time consumption for your script, which under
    Unix uses the resource module to avoid the wraparound problems of
    time.clock().  Under Unix, an estimate of time spent on system tasks
    is also given (for Windows platforms this is reported as 0.0).

    If -t is given, an additional -N&lt;N&gt; option can be given, where &lt;N&gt;
    must be an integer indicating how many times you want the script to
    run.  The final timing report will include total and per run results.

    For example (testing the script uniq_stable.py):

        In [1]: run -t uniq_stable

        IPython CPU timings (estimated):\\
          User  :    0.19597 s.\\
          System:        0.0 s.\\

        In [2]: run -t -N5 uniq_stable

        IPython CPU timings (estimated):\\
        Total runs performed: 5\\
          Times :      Total       Per run\\
          User  :   0.910862 s,  0.1821724 s.\\
          System:        0.0 s,        0.0 s.

    -d: run your program under the control of pdb, the Python debugger.
    This allows you to execute your program step by step, watch variables,
    etc.  Internally, what IPython does is similar to calling:
    
      pdb.run('execfile("YOURFILENAME")')

    with a breakpoint set on line 1 of your file.  You can change the line
    number for this automatic breakpoint to be &lt;N&gt; by using the -bN option
    (where N must be an integer).  For example:

      %run -d -b40 myscript

    will set the first breakpoint at line 40 in myscript.py.  Note that
    the first breakpoint must be set on a line which actually does
    something (not a comment or docstring) for it to stop execution.

    When the pdb debugger starts, you will see a (Pdb) prompt.  You must
    first enter 'c' (without qoutes) to start execution up to the first
    breakpoint.

    Entering 'help' gives information about the use of the debugger.  You
    can easily see pdb's full documentation with "import pdb;pdb.help()"
    at a prompt.

    -p: run program under the control of the Python profiler module (which
    prints a detailed report of execution times, function calls, etc).

    You can pass other options after -p which affect the behavior of the
    profiler itself. See the docs for %prun for details.

    In this mode, the program's variables do NOT propagate back to the
    IPython interactive namespace (because they remain in the namespace
    where the profiler executes them).

    Internally this triggers a call to %prun, see its documentation for
    details on the options available specifically for profiling."""

    # get arguments and set sys.argv for program to be run.
    opts,arg_lst = self.parse_options(parameter_s,'nidtN:b:pD:l:rs:T:e',
                                      mode='list',list_all=1)

    try:
        filename = get_py_filename(arg_lst[0])
    except IndexError:
        warn('you must provide at least a filename.')
        print '\n%run:\n',OInspect.getdoc(self.magic_run)
        return
    except IOError,msg:
        error(msg)
        return

    # Control the response to exit() calls made by the script being run
    exit_ignore = opts.has_key('e')
    
    # Make sure that the running script gets a proper sys.argv as if it
    # were run from a system shell.
    save_argv = sys.argv # save it for later restoring
    sys.argv = [filename]+ arg_lst[1:]  # put in the proper filename

    if opts.has_key('i'):
        prog_ns = self.shell.user_ns
        __name__save = self.shell.user_ns['__name__']
        prog_ns['__name__'] = '__main__'
    else:
        if opts.has_key('n'):
            name = os.path.splitext(os.path.basename(filename))[0]
        else:
            name = '__main__'
        prog_ns = {'__name__':name}

    # pickle fix.  See iplib for an explanation
    sys.modules[prog_ns['__name__']] = FakeModule(prog_ns)
    
    stats = None
    try:
        if opts.has_key('p'):
            stats = self.magic_prun('',0,opts,arg_lst,prog_ns)
        else:
            if opts.has_key('d'):
                deb = pdb.Pdb()
                # reset Breakpoint state, which is moronically kept
                # in a class
                bdb.Breakpoint.next = 1
                bdb.Breakpoint.bplist = {}
                bdb.Breakpoint.bpbynumber = [None]
                # Set an initial breakpoint to stop execution
                maxtries = 10
                bp = int(opts.get('b',[1])[0])
                checkline = deb.checkline(filename,bp)
                if not checkline:
                    for bp in range(bp+1,bp+maxtries+1):
                        if deb.checkline(filename,bp):
                            break
                    else:
                        msg = ("\nI failed to find a valid line to set "
                               "a breakpoint\n"
                               "after trying up to line: %s.\n"
                               "Please set a valid breakpoint manually "
                               "with the -b option." % bp)
                        error(msg)
                        return
                # if we find a good linenumber, set the breakpoint
                deb.do_break('%s:%s' % (filename,bp))
                # Start file run
                print "NOTE: Enter 'c' at the",
                print "(Pdb) prompt to start your script."
                deb.run('execfile("%s")' % filename,prog_ns)
            else:
                if runner is None:
                    runner = self.shell.safe_execfile
                if opts.has_key('t'):
                    try:
                        nruns = int(opts['N'][0])
                        if nruns &lt; 1:
                            error('Number of runs must be &gt;=1')
                            return
                    except (KeyError):
                        nruns = 1
                    if nruns == 1:
                        t0 = clock2()
                        runner(filename,prog_ns,prog_ns,exit_ignore=exit_ignore)
                        t1 = clock2()
                        t_usr = t1[0]-t0[0]
                        t_sys = t1[1]-t1[1]
                        print "\nIPython CPU timings (estimated):"
                        print "  User  : %10s s." % t_usr
                        print "  System: %10s s." % t_sys
                    else:
                        runs = range(nruns)
                        t0 = clock2()
                        for nr in runs:
                            runner(filename,prog_ns,prog_ns,exit_ignore=exit_ignore)
                        t1 = clock2()
                        t_usr = t1[0]-t0[0]
                        t_sys = t1[1]-t1[1]
                        print "\nIPython CPU timings (estimated):"
                        print "Total runs performed:",nruns
                        print "  Times : %10s    %10s" % ('Total','Per run')
                        print "  User  : %10s s, %10s s." % (t_usr,t_usr/nruns)
                        print "  System: %10s s, %10s s." % (t_sys,t_sys/nruns)
                        
                else:
                    runner(filename,prog_ns,prog_ns,exit_ignore=exit_ignore)
            if opts.has_key('i'):
                self.shell.user_ns['__name__'] = __name__save
            else:
                # update IPython interactive namespace
                del prog_ns['__name__']
                self.shell.user_ns.update(prog_ns)
    finally:
        sys.argv = save_argv
    return stats
</t>
<t tx="ekr.20050704165326.358">def magic_runlog(self, parameter_s =''):
    """Run files as logs.

    Usage:\\
      %runlog file1 file2 ...

    Run the named files (treating them as log files) in sequence inside
    the interpreter, and return to the prompt.  This is much slower than
    %run because each line is executed in a try/except block, but it
    allows running files with syntax errors in them.

    Normally IPython will guess when a file is one of its own logfiles, so
    you can typically use %run even for logs. This shorthand allows you to
    force any file to be treated as a log file."""

    for f in parameter_s.split():
        self.shell.safe_execfile(f,self.shell.user_ns,
                                 self.shell.user_ns,islog=1)
</t>
<t tx="ekr.20050704165326.359">def magic_time(self,parameter_s = ''):
    """Time execution of a Python statement or expression.

    The CPU and wall clock times are printed, and the value of the
    expression (if any) is returned.  Note that under Win32, system time
    is always reported as 0, since it can not be measured.

    This function provides very basic timing functionality.  In Python
    2.3, the timeit module offers more control and sophistication, but for
    now IPython supports Python 2.2, so we can not rely on timeit being
    present.
    
    Some examples:

      In [1]: time 2**128
      CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
      Wall time: 0.00
      Out[1]: 340282366920938463463374607431768211456L

      In [2]: n = 1000000

      In [3]: time sum(range(n))
      CPU times: user 1.20 s, sys: 0.05 s, total: 1.25 s
      Wall time: 1.37
      Out[3]: 499999500000L

      In [4]: time print 'hello world'
      hello world
      CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
      Wall time: 0.00
      """
    
    # fail immediately if the given expression can't be compiled
    try:
        mode = 'eval'
        code = compile(parameter_s,'&lt;timed eval&gt;',mode)
    except SyntaxError:
        mode = 'exec'
        code = compile(parameter_s,'&lt;timed exec&gt;',mode)
    # skew measurement as little as possible
    glob = self.shell.user_ns
    clk = clock2
    wtime = time.time
    # time execution
    wall_st = wtime()
    if mode=='eval':
        st = clk()
        out = eval(code,glob)
        end = clk()
    else:
        st = clk()
        exec code in glob
        end = clk()
        out = None
    wall_end = wtime()
    # Compute actual times and report
    wall_time = wall_end-wall_st
    cpu_user = end[0]-st[0]
    cpu_sys = end[1]-st[1]
    cpu_tot = cpu_user+cpu_sys
    print "CPU times: user %.2f s, sys: %.2f s, total: %.2f s" % \
          (cpu_user,cpu_sys,cpu_tot)
    print "Wall time: %.2f" % wall_time
    return out
</t>
<t tx="ekr.20050704165326.360">def magic_macro(self,parameter_s = ''):
    """Define a set of input lines as a macro for future re-execution.

    Usage:\\
      %macro name n1:n2 n3:n4 ... n5 .. n6 ...

    This will define a global variable called `name` which is a string
    made of joining the slices and lines you specify (n1,n2,... numbers
    above) from your input history into a single string. This variable
    acts like an automatic function which re-executes those lines as if
    you had typed them. You just type 'name' at the prompt and the code
    executes.

    Note that the slices use the standard Python slicing notation (5:8
    means include lines numbered 5,6,7).

    For example, if your history contains (%hist prints it):
    
      44: x=1\\
      45: y=3\\
      46: z=x+y\\
      47: print x\\
      48: a=5\\
      49: print 'x',x,'y',y\\

    you can create a macro with lines 44 through 47 (included) and line 49
    called my_macro with:

      In [51]: %macro my_macro 44:48 49

    Now, typing `my_macro` (without quotes) will re-execute all this code
    in one pass.

    You don't need to give the line-numbers in order, and any given line
    number can appear multiple times. You can assemble macros with any
    lines from your input history in any order.

    The macro is a simple object which holds its value in an attribute,
    but IPython's display system checks for macros and executes them as
    code instead of printing them when you type their name.

    You can view a macro's contents by explicitly printing it with:
    
      'print macro_name'.

    For one-off cases which DON'T contain magic function calls in them you
    can obtain similar results by explicitly executing slices from your
    input history with:

      In [60]: exec In[44:48]+In[49]"""

    args = parameter_s.split()
    name,ranges = args[0], args[1:]
    #print 'rng',ranges  # dbg
    cmds = self.extract_input_slices(ranges)
    macro = Macro(cmds)
    self.shell.user_ns.update({name:macro})
    print 'Macro `%s` created. To execute, type its name (without quotes).' % name
    print 'Macro contents:'
    print str(macro).rstrip(),
</t>
<t tx="ekr.20050704165326.361">def magic_save(self,parameter_s = ''):
    """Save a set of lines to a given filename.

    Usage:\\
      %save filename n1:n2 n3:n4 ... n5 .. n6 ...

    This function uses the same syntax as %macro for line extraction, but
    instead of creating a macro it saves the resulting string to the
    filename you specify.

    It adds a '.py' extension to the file if you don't do so yourself, and
    it asks for confirmation before overwriting existing files."""

    args = parameter_s.split()
    fname,ranges = args[0], args[1:]
    if not fname.endswith('.py'):
        fname += '.py'
    if os.path.isfile(fname):
        ans = raw_input('File `%s` exists. Overwrite (y/[N])? ' % fname)
        if ans.lower() not in ['y','yes']:
            print 'Operation cancelled.'
            return
    cmds = ''.join(self.extract_input_slices(ranges))
    f = file(fname,'w')
    f.write(cmds)
    f.close()
    print 'The following commands were written to file `%s`:' % fname
    print cmds
</t>
<t tx="ekr.20050704165326.362">def magic_ed(self,parameter_s = ''):
    """Alias to %edit."""
    return self.magic_edit(parameter_s)
</t>
<t tx="ekr.20050704165326.363">def magic_edit(self,parameter_s = '',last_call=['','']):
    """Bring up an editor and execute the resulting code.

    Usage:
      %edit [options] [args]

    %edit runs IPython's editor hook.  The default version of this hook is
    set to call the __IPYTHON__.rc.editor command.  This is read from your
    environment variable $EDITOR.  If this isn't found, it will default to
    vi under Linux/Unix and to notepad under Windows.  See the end of this
    docstring for how to change the editor hook.

    You can also set the value of this editor via the command line option
    '-editor' or in your ipythonrc file. This is useful if you wish to use
    specifically for IPython an editor different from your typical default
    (and for Windows users who typically don't set environment variables).

    This command allows you to conveniently edit multi-line code right in
    your IPython session.
    
    If called without arguments, %edit opens up an empty editor with a
    temporary file and will execute the contents of this file when you
    close it (don't forget to save it!).

    Options:

    -p: this will call the editor with the same data as the previous time
    it was used, regardless of how long ago (in your current session) it
    was.

    -x: do not execute the edited code immediately upon exit. This is
    mainly useful if you are editing programs which need to be called with
    command line arguments, which you can then do using %run.

    Arguments:

    If arguments are given, the following possibilites exist:

    - The arguments are numbers or pairs of colon-separated numbers (like
    1 4:8 9). These are interpreted as lines of previous input to be
    loaded into the editor. The syntax is the same of the %macro command.

    - If the argument doesn't start with a number, it is evaluated as a
    variable and its contents loaded into the editor. You can thus edit
    any string which contains python code (including the result of
    previous edits).

    - If the argument is the name of an object (other than a string),
    IPython will try to locate the file where it was defined and open the
    editor at the point where it is defined. You can use `%edit function`
    to load an editor exactly at the point where 'function' is defined,
    edit it and have the file be executed automatically.

    Note: opening at an exact line is only supported under Unix, and some
    editors (like kedit and gedit up to Gnome 2.8) do not understand the
    '+NUMBER' parameter necessary for this feature. Good editors like
    (X)Emacs, vi, jed, pico and joe all do.

    - If the argument is not found as a variable, IPython will look for a
    file with that name (adding .py if necessary) and load it into the
    editor. It will execute its contents with execfile() when you exit,
    loading any code in the file into your interactive namespace.

    After executing your code, %edit will return as output the code you
    typed in the editor (except when it was an existing file). This way
    you can reload the code in further invocations of %edit as a variable,
    via _&lt;NUMBER&gt; or Out[&lt;NUMBER&gt;], where &lt;NUMBER&gt; is the prompt number of
    the output.

    Note that %edit is also available through the alias %ed.

    This is an example of creating a simple function inside the editor and
    then modifying it. First, start up the editor:

    In [1]: ed\\
    Editing... done. Executing edited code...\\
    Out[1]: 'def foo():\\n    print "foo() was defined in an editing session"\\n'

    We can then call the function foo():
    
    In [2]: foo()\\
    foo() was defined in an editing session

    Now we edit foo.  IPython automatically loads the editor with the
    (temporary) file where foo() was previously defined:
    
    In [3]: ed foo\\
    Editing... done. Executing edited code...

    And if we call foo() again we get the modified version:
    
    In [4]: foo()\\
    foo() has now been changed!

    Here is an example of how to edit a code snippet successive
    times. First we call the editor:

    In [8]: ed\\
    Editing... done. Executing edited code...\\
    hello\\
    Out[8]: "print 'hello'\\n"

    Now we call it again with the previous output (stored in _):

    In [9]: ed _\\
    Editing... done. Executing edited code...\\
    hello world\\
    Out[9]: "print 'hello world'\\n"

    Now we call it with the output #8 (stored in _8, also as Out[8]):

    In [10]: ed _8\\
    Editing... done. Executing edited code...\\
    hello again\\
    Out[10]: "print 'hello again'\\n"


    Changing the default editor hook:

    If you wish to write your own editor hook, you can put it in a
    configuration file which you load at startup time.  The default hook
    is defined in the IPython.hooks module, and you can use that as a
    starting example for further modifications.  That file also has
    general instructions on how to set a new hook for use once you've
    defined it."""
    
    # FIXME: This function has become a convoluted mess.  It needs a
    # ground-up rewrite with clean, simple logic.

    def make_filename(arg):
        "Make a filename from the given args"
        try:
            filename = get_py_filename(arg)
        except IOError:
            if args.endswith('.py'):
                filename = arg
            else:
                filename = None
        return filename

    # custom exceptions
    class DataIsObject(Exception): pass

    opts,args = self.parse_options(parameter_s,'px')

    # Default line number value
    lineno = None
    if opts.has_key('p'):
        args = '_%s' % last_call[0]
        if not self.shell.user_ns.has_key(args):
            args = last_call[1]
        
    # use last_call to remember the state of the previous call, but don't
    # let it be clobbered by successive '-p' calls.
    try:
        last_call[0] = self.shell.outputcache.prompt_count
        if not opts.has_key('p'):
            last_call[1] = parameter_s
    except:
        pass

    # by default this is done with temp files, except when the given
    # arg is a filename
    use_temp = 1

    if re.match(r'\d',args):
        # Mode where user specifies ranges of lines, like in %macro.
        # This means that you can't edit files whose names begin with
        # numbers this way. Tough.
        ranges = args.split()
        data = ''.join(self.extract_input_slices(ranges))
    elif args.endswith('.py'):
        filename = make_filename(args)
        data = ''
        use_temp = 0
    elif args:
        try:
            # Load the parameter given as a variable. If not a string,
            # process it as an object instead (below)

            #print '*** args',args,'type',type(args)  # dbg
            data = eval(args,self.shell.user_ns)
            if not type(data) in StringTypes:
                raise DataIsObject
        except (NameError,SyntaxError):
            # given argument is not a variable, try as a filename
            filename = make_filename(args)
            if filename is None:
                warn("Argument given (%s) can't be found as a variable "
                     "or as a filename." % args)
                return
            data = ''
            use_temp = 0
        except DataIsObject:
            # For objects, try to edit the file where they are defined
            try:
                filename = inspect.getabsfile(data)
                datafile = 1
            except TypeError:
                filename = make_filename(args)
                datafile = 1
                warn('Could not find file where `%s` is defined.\n'
                     'Opening a file named `%s`' % (args,filename))
            # Now, make sure we can actually read the source (if it was in
            # a temp file it's gone by now).
            if datafile:
                try:
                    lineno = inspect.getsourcelines(data)[1]
                except IOError:
                    filename = make_filename(args)
                    if filename is None:
                        warn('The file `%s` where `%s` was defined cannot '
                             'be read.' % (filename,data))
                        return
            use_temp = 0
    else:
        data = ''

    if use_temp:
        filename = tempfile.mktemp('.py')
        self.shell.tempfiles.append(filename)
    
    if data and use_temp:
        tmp_file = open(filename,'w')
        tmp_file.write(data)
        tmp_file.close()

    # do actual editing here
    print 'Editing...',
    sys.stdout.flush()
    self.shell.hooks.editor(filename,lineno)
    if opts.has_key('x'):  # -x prevents actual execution
        print
    else:
        print 'done. Executing edited code...'
        try:
            execfile(filename,self.shell.user_ns)
        except IOError,msg:
            if msg.filename == filename:
                warn('File not found. Did you forget to save?')
                return
            else:
                self.shell.showtraceback()
        except:
            self.shell.showtraceback()
    if use_temp:
        contents = open(filename).read()
        return contents
</t>
<t tx="ekr.20050704165326.364">def magic_xmode(self,parameter_s = ''):
    """Switch modes for the exception handlers.

    Valid modes: Plain, Context and Verbose.

    If called without arguments, acts as a toggle."""

    new_mode = parameter_s.strip().capitalize()
    try:
        self.InteractiveTB.set_mode(mode = new_mode)
        print 'Exception reporting mode:',self.InteractiveTB.mode
    except:
        warn('Error changing exception modes.\n' + str(sys.exc_info()[1]))
</t>
<t tx="ekr.20050704165326.365">def magic_colors(self,parameter_s = ''):
    """Switch color scheme for prompts, info system and exception handlers.

    Currently implemented schemes: NoColor, Linux, LightBG.

    Color scheme names are not case-sensitive."""
    
    new_scheme = parameter_s.strip()
    if not new_scheme:
        print 'You must specify a color scheme.'
        return
    # Under Windows, check for Gary Bishop's readline, which is necessary
    # for ANSI coloring
    if os.name in ['nt','dos']:
        try:
            import readline
        except ImportError:
            has_readline = 0
        else:
            try:
                readline.GetOutputFile()
            except AttributeError:
                has_readline = 0
            else:
                has_readline = 1
        if not has_readline:
            msg = """\
Proper color support under MS Windows requires Gary Bishop's readline library.
You can find it at:
http://sourceforge.net/projects/uncpythontools
Gary's readline needs the ctypes module, from:
http://starship.python.net/crew/theller/ctypes

Defaulting color scheme to 'NoColor'"""
            new_scheme = 'NoColor'
            warn(msg)
    
    # Set prompt colors
    try:
        self.shell.outputcache.set_colors(new_scheme)
    except:
        warn('Error changing prompt color schemes.\n'
             + str(sys.exc_info()[1]))
    else:
        self.shell.rc.colors = \
                   self.shell.outputcache.color_table.active_scheme_name
    # Set exception colors
    try:
        self.shell.InteractiveTB.set_colors(scheme = new_scheme)
        self.shell.SyntaxTB.set_colors(scheme = new_scheme)
    except:
        warn('Error changing exception color schemes.\n'
             + str(sys.exc_info()[1]))
    # Set info (for 'object?') colors
    if self.shell.rc.color_info:
        try:
            self.shell.inspector.set_active_scheme(new_scheme)
        except:
            warn('Error changing object inspector color schemes.\n'
                 + str(sys.exc_info()[1]))
    else:
        self.shell.inspector.set_active_scheme('NoColor')
</t>
<t tx="ekr.20050704165326.366">def magic_color_info(self,parameter_s = ''):
    """Toggle color_info.

    The color_info configuration parameter controls whether colors are
    used for displaying object details (by things like %psource, %pfile or
    the '?' system). This function toggles this value with each call.

    Note that unless you have a fairly recent pager (less works better
    than more) in your system, using colored object information displays
    will not work properly. Test it and see."""
    
    self.shell.rc.color_info = 1 - self.shell.rc.color_info
    self.magic_colors(self.shell.rc.colors)
    print 'Object introspection functions have now coloring:',
    print ['OFF','ON'][self.shell.rc.color_info]
</t>
<t tx="ekr.20050704165326.367">def magic_Pprint(self, parameter_s=''):
    """Toggle pretty printing on/off."""
    
    self.shell.outputcache.Pprint = 1 - self.shell.outputcache.Pprint
    print 'Pretty printing has been turned', \
          ['OFF','ON'][self.shell.outputcache.Pprint]
</t>
<t tx="ekr.20050704165326.368">def magic_Exit(self, parameter_s=''):
    """Exit IPython without confirmation."""

    self.shell.exit_now = True
</t>
<t tx="ekr.20050704165326.369">def magic_Quit(self, parameter_s=''):
    """Exit IPython without confirmation (like %Exit)."""

    self.shell.exit_now = True
</t>
<t tx="ekr.20050704165326.370">#......................................................................
# Functions to implement unix shell-type things

def magic_alias(self, parameter_s = ''):
    """Define an alias for a system command.

    '%alias alias_name cmd' defines 'alias_name' as an alias for 'cmd'

    Then, typing 'alias_name params' will execute the system command 'cmd
    params' (from your underlying operating system).

    Aliases have lower precedence than magic functions and Python normal
    variables, so if 'foo' is both a Python variable and an alias, the
    alias can not be executed until 'del foo' removes the Python variable.

    You can use the %l specifier in an alias definition to represent the
    whole line when the alias is called.  For example:

      In [2]: alias all echo "Input in brackets: &lt;%l&gt;"\\
      In [3]: all hello world\\
      Input in brackets: &lt;hello world&gt;

    You can also define aliases with parameters using %s specifiers (one
    per parameter):
    
      In [1]: alias parts echo first %s second %s\\
      In [2]: %parts A B\\
      first A second B\\
      In [3]: %parts A\\
      Incorrect number of arguments: 2 expected.\\
      parts is an alias to: 'echo first %s second %s'

    Note that %l and %s are mutually exclusive.  You can only use one or
    the other in your aliases.

    Aliases expand Python variables just like system calls using ! or !! 
    do: all expressions prefixed with '$' get expanded.  For details of
    the semantic rules, see PEP-215:
    http://www.python.org/peps/pep-0215.html.  This is the library used by
    IPython for variable expansion.  If you want to access a true shell
    variable, an extra $ is necessary to prevent its expansion by IPython:

    In [6]: alias show echo\\
    In [7]: PATH='A Python string'\\
    In [8]: show $PATH\\
    A Python string\\
    In [9]: show $$PATH\\
    /usr/local/lf9560/bin:/usr/local/intel/compiler70/ia32/bin:...

    You can use the alias facility to acess all of $PATH.  See the %rehash
    and %rehashx functions, which automatically create aliases for the
    contents of your $PATH.

    If called with no parameters, %alias prints the current alias table."""

    par = parameter_s.strip()
    if not par:
        if self.shell.rc.automagic:
            prechar = ''
        else:
            prechar = self.shell.ESC_MAGIC
        print 'Alias\t\tSystem Command\n'+'-'*30
        atab = self.shell.alias_table
        aliases = atab.keys()
        aliases.sort()
        for alias in aliases:
            print prechar+alias+'\t\t'+atab[alias][1]
        print '-'*30+'\nTotal number of aliases:',len(aliases)
        return
    try:
        alias,cmd = par.split(None,1)
    except:
        print OInspect.getdoc(self.magic_alias)
    else:
        nargs = cmd.count('%s')
        if nargs&gt;0 and cmd.find('%l')&gt;=0:
            error('The %s and %l specifiers are mutually exclusive '
                  'in alias definitions.')
        else:  # all looks OK
            self.shell.alias_table[alias] = (nargs,cmd)
            self.shell.alias_table_validate(verbose=1)
</t>
<t tx="ekr.20050704165326.371"># end magic_alias

def magic_unalias(self, parameter_s = ''):
    """Remove an alias"""

    aname = parameter_s.strip()
    if aname in self.shell.alias_table:
        del self.shell.alias_table[aname]
</t>
<t tx="ekr.20050704165326.372">def magic_rehash(self, parameter_s = ''):
    """Update the alias table with all entries in $PATH.

    This version does no checks on execute permissions or whether the
    contents of $PATH are truly files (instead of directories or something
    else).  For such a safer (but slower) version, use %rehashx."""

    # This function (and rehashx) manipulate the alias_table directly
    # rather than calling magic_alias, for speed reasons.  A rehash on a
    # typical Linux box involves several thousand entries, so efficiency
    # here is a top concern.
    
    path = filter(os.path.isdir,os.environ['PATH'].split(os.pathsep))
    alias_table = self.shell.alias_table
    for pdir in path:
        for ff in os.listdir(pdir):
            # each entry in the alias table must be (N,name), where
            # N is the number of positional arguments of the alias.
            alias_table[ff] = (0,ff)
    # Make sure the alias table doesn't contain keywords or builtins
    self.shell.alias_table_validate()
    # Call again init_auto_alias() so we get 'rm -i' and other modified
    # aliases since %rehash will probably clobber them
    self.shell.init_auto_alias()
</t>
<t tx="ekr.20050704165326.373">def magic_rehashx(self, parameter_s = ''):
    """Update the alias table with all executable files in $PATH.

    This version explicitly checks that every entry in $PATH is a file
    with execute access (os.X_OK), so it is much slower than %rehash.

    Under Windows, it checks executability as a match agains a
    '|'-separated string of extensions, stored in the IPython config
    variable win_exec_ext.  This defaults to 'exe|com|bat'. """
    
    path = filter(os.path.isdir,os.environ['PATH'].split(os.pathsep))
    alias_table = self.shell.alias_table

    if os.name == 'posix':
        isexec = lambda fname:os.path.isfile(fname) and \
                 os.access(fname,os.X_OK)
    else:

        try:
            winext = os.environ['pathext'].replace(';','|').replace('.','')
        except KeyError:
            winext = 'exe|com|bat'

        execre = re.compile(r'(.*)\.(%s)$' % winext,re.IGNORECASE)
        isexec = lambda fname:os.path.isfile(fname) and execre.match(fname)
    savedir = os.getcwd()
    try:
        # write the whole loop for posix/Windows so we don't have an if in
        # the innermost part
        if os.name == 'posix':
            for pdir in path:
                os.chdir(pdir)
                for ff in os.listdir(pdir):
                    if isexec(ff):
                        # each entry in the alias table must be (N,name),
                        # where N is the number of positional arguments of the
                        # alias.
                        alias_table[ff] = (0,ff)
        else:
            for pdir in path:
                os.chdir(pdir)
                for ff in os.listdir(pdir):
                    if isexec(ff):
                        alias_table[execre.sub(r'\1',ff)] = (0,ff)
        # Make sure the alias table doesn't contain keywords or builtins
        self.shell.alias_table_validate()
        # Call again init_auto_alias() so we get 'rm -i' and other
        # modified aliases since %rehashx will probably clobber them
        self.shell.init_auto_alias()
    finally:
        os.chdir(savedir)
</t>
<t tx="ekr.20050704165326.374">def magic_pwd(self, parameter_s = ''):
    """Return the current working directory path."""
    return os.getcwd()
</t>
<t tx="ekr.20050704165326.375">def magic_cd(self, parameter_s=''):
    """Change the current working directory.

    This command automatically maintains an internal list of directories
    you visit during your IPython session, in the variable _dh. The
    command %dhist shows this history nicely formatted.

    Usage:

      cd 'dir': changes to directory 'dir'.

      cd -: changes to the last visited directory.

      cd -&lt;n&gt;: changes to the n-th directory in the directory history.

      cd -b &lt;bookmark_name&gt;: jump to a bookmark set by %bookmark
         (note: cd &lt;bookmark_name&gt; is enough if there is no
          directory &lt;bookmark_name&gt;, but a bookmark with the name exists.)

    Options:

    -q: quiet.  Do not print the working directory after the cd command is
    executed.  By default IPython's cd command does print this directory,
    since the default prompts do not display path information.
    
    Note that !cd doesn't work for this purpose because the shell where
    !command runs is immediately discarded after executing 'command'."""

    parameter_s = parameter_s.strip()
    bkms = self.shell.persist.get("bookmarks",{})

    numcd = re.match(r'(-)(\d+)$',parameter_s)
    # jump in directory history by number
    if numcd:
        nn = int(numcd.group(2))
        try:
            ps = self.shell.user_ns['_dh'][nn]
        except IndexError:
            print 'The requested directory does not exist in history.'
            return
        else:
            opts = {}
    else:
        opts,ps = self.parse_options(parameter_s,'qb',mode='string')
    # jump to previous
    if ps == '-':
        try:
            ps = self.shell.user_ns['_dh'][-2]
        except IndexError:
            print 'No previous directory to change to.'
            return
    # jump to bookmark
    elif opts.has_key('b') or (bkms.has_key(ps) and not os.path.isdir(ps)):
        if bkms.has_key(ps):
            target = bkms[ps]
            print '(bookmark:%s) -&gt; %s' % (ps,target)
            ps = target
        else:
            if bkms:
                error("Bookmark '%s' not found.  "
                      "Use '%bookmark -l' to see your bookmarks." % ps)
            else:
                print "Bookmarks not set - use %bookmark &lt;bookmarkname&gt;"
            return
        
    # at this point ps should point to the target dir
    if ps:
        try:
            os.chdir(os.path.expanduser(ps))
        except OSError:
            print sys.exc_info()[1]
        else:
            self.shell.user_ns['_dh'].append(os.getcwd())
    else:
        os.chdir(self.home_dir)
        self.shell.user_ns['_dh'].append(os.getcwd())
    if not 'q' in opts:
        print self.shell.user_ns['_dh'][-1]
</t>
<t tx="ekr.20050704165326.376">def magic_dhist(self, parameter_s=''):
    """Print your history of visited directories.

    %dhist       -&gt; print full history\\
    %dhist n     -&gt; print last n entries only\\
    %dhist n1 n2 -&gt; print entries between n1 and n2 (n1 not included)\\

    This history is automatically maintained by the %cd command, and
    always available as the global list variable _dh. You can use %cd -&lt;n&gt;
    to go to directory number &lt;n&gt;."""

    dh = self.shell.user_ns['_dh']
    if parameter_s:
        try:
            args = map(int,parameter_s.split())
        except:
            self.arg_err(Magic.magic_dhist)
            return
        if len(args) == 1:
            ini,fin = max(len(dh)-(args[0]),0),len(dh)
        elif len(args) == 2:
            ini,fin = args
        else:
            self.arg_err(Magic.magic_dhist)
            return
    else:
        ini,fin = 0,len(dh)
    nlprint(dh,
            header = 'Directory history (kept in _dh)',
            start=ini,stop=fin)
</t>
<t tx="ekr.20050704165326.377">def magic_env(self, parameter_s=''):
    """List environment variables."""
    
    # environ is an instance of UserDict
    return os.environ.data
</t>
<t tx="ekr.20050704165326.378">def magic_pushd(self, parameter_s=''):
    """Place the current dir on stack and change directory.
    
    Usage:\\
      %pushd ['dirname']

    %pushd with no arguments does a %pushd to your home directory.
    """
    if parameter_s == '': parameter_s = '~'
    if len(self.dir_stack)&gt;0 and os.path.expanduser(parameter_s) != \
       os.path.expanduser(self.dir_stack[0]):
        try:
            self.magic_cd(parameter_s)
            self.dir_stack.insert(0,os.getcwd().replace(self.home_dir,'~'))
            self.magic_dirs()
        except:
            print 'Invalid directory'
    else:
        print 'You are already there!'
</t>
<t tx="ekr.20050704165326.379">def magic_popd(self, parameter_s=''):
    """Change to directory popped off the top of the stack.
    """
    if len (self.dir_stack) &gt; 1:
        self.dir_stack.pop(0)
        self.magic_cd(self.dir_stack[0])
        print self.dir_stack[0]
    else:
        print "You can't remove the starting directory from the stack:",\
              self.dir_stack
</t>
<t tx="ekr.20050704165326.380">def magic_dirs(self, parameter_s=''):
    """Return the current directory stack."""

    return self.dir_stack[:]
</t>
<t tx="ekr.20050704165326.381">def magic_sc(self, parameter_s=''):
    """Shell capture - execute a shell command and capture its output.

    %sc [options] varname=command

    IPython will run the given command using commands.getoutput(), and
    will then update the user's interactive namespace with a variable
    called varname, containing the value of the call.  Your command can
    contain shell wildcards, pipes, etc.

    The '=' sign in the syntax is mandatory, and the variable name you
    supply must follow Python's standard conventions for valid names.

    Options:

      -l: list output.  Split the output on newlines into a list before
      assigning it to the given variable.  By default the output is stored
      as a single string.

      -v: verbose.  Print the contents of the variable.

    In most cases you should not need to split as a list, because the
    returned value is a special type of string which can automatically
    provide its contents either as a list (split on newlines) or as a
    space-separated string.  These are convenient, respectively, either
    for sequential processing or to be passed to a shell command.

    For example:

        # Capture into variable a
        In [9]: sc a=ls *py

        # a is a string with embedded newlines
        In [10]: a
        Out[10]: 'setup.py\nwin32_manual_post_install.py'

        # which can be seen as a list:
        In [11]: a.l
        Out[11]: ['setup.py', 'win32_manual_post_install.py']

        # or as a whitespace-separated string:
        In [12]: a.s
        Out[12]: 'setup.py win32_manual_post_install.py'

        # a.s is useful to pass as a single command line:
        In [13]: !wc -l $a.s
          146 setup.py
          130 win32_manual_post_install.py
          276 total

        # while the list form is useful to loop over:
        In [14]: for f in a.l:
           ....:      !wc -l $f
           ....:
        146 setup.py
        130 win32_manual_post_install.py

    Similiarly, the lists returned by the -l option are also special, in
    the sense that you can equally invoke the .s attribute on them to
    automatically get a whitespace-separated string from their contents:

        In [1]: sc -l b=ls *py

        In [2]: b
        Out[2]: ['setup.py', 'win32_manual_post_install.py']

        In [3]: b.s
        Out[3]: 'setup.py win32_manual_post_install.py'

    In summary, both the lists and strings used for ouptut capture have
    the following special attributes:

        .l (or .list) : value as list.
        .n (or .nlstr): value as newline-separated string.
        .s (or .spstr): value as space-separated string.
    """

    opts,args = self.parse_options(parameter_s,'lv')
    # Try to get a variable name and command to run
    try:
        # the variable name must be obtained from the parse_options
        # output, which uses shlex.split to strip options out.
        var,_ = args.split('=',1)
        var = var.strip()
        # But the the command has to be extracted from the original input
        # parameter_s, not on what parse_options returns, to avoid the
        # quote stripping which shlex.split performs on it.
        _,cmd = parameter_s.split('=',1)
    except ValueError:
        var,cmd = '',''
    if not var:
        error('you must specify a variable to assign the command to.')
        return
    # If all looks ok, proceed
    out,err = self.shell.getoutputerror(cmd)
    if err:
        print &gt;&gt; Term.cerr,err
    if opts.has_key('l'):
        out = SList(out.split('\n'))
    else:
        out = LSString(out)
    if opts.has_key('v'):
        print '%s ==\n%s' % (var,pformat(out))
    self.shell.user_ns.update({var:out})
</t>
<t tx="ekr.20050704165326.382">def magic_sx(self, parameter_s=''):
    """Shell execute - run a shell command and capture its output.

    %sx command

    IPython will run the given command using commands.getoutput(), and
    return the result formatted as a list (split on '\\n').  Since the
    output is _returned_, it will be stored in ipython's regular output
    cache Out[N] and in the '_N' automatic variables.

    Notes:

    1) If an input line begins with '!!', then %sx is automatically
    invoked.  That is, while:
      !ls
    causes ipython to simply issue system('ls'), typing
      !!ls
    is a shorthand equivalent to:
      %sx ls
    
    2) %sx differs from %sc in that %sx automatically splits into a list,
    like '%sc -l'.  The reason for this is to make it as easy as possible
    to process line-oriented shell output via further python commands.
    %sc is meant to provide much finer control, but requires more
    typing.

    3) Just like %sc -l, this is a list with special attributes:

      .l (or .list) : value as list.
      .n (or .nlstr): value as newline-separated string.
      .s (or .spstr): value as whitespace-separated string.

    This is very useful when trying to use such lists as arguments to
    system commands."""

    if parameter_s:
        out,err = self.shell.getoutputerror(parameter_s)
        if err:
            print &gt;&gt; Term.cerr,err
        return SList(out.split('\n'))
</t>
<t tx="ekr.20050704165326.383">def magic_bg(self, parameter_s=''):
    """Run a job in the background, in a separate thread.

    For example,

      %bg myfunc(x,y,z=1)

    will execute 'myfunc(x,y,z=1)' in a background thread.  As soon as the
    execution starts, a message will be printed indicating the job
    number.  If your job number is 5, you can use

      myvar = jobs.result(5)  or  myvar = jobs[5].result

    to assign this result to variable 'myvar'.

    IPython has a job manager, accessible via the 'jobs' object.  You can
    type jobs? to get more information about it, and use jobs.&lt;TAB&gt; to see
    its attributes.  All attributes not starting with an underscore are
    meant for public use.

    In particular, look at the jobs.new() method, which is used to create
    new jobs.  This magic %bg function is just a convenience wrapper
    around jobs.new(), for expression-based jobs.  If you want to create a
    new job with an explicit function object and arguments, you must call
    jobs.new() directly.

    The jobs.new docstring also describes in detail several important
    caveats associated with a thread-based model for background job
    execution.  Type jobs.new? for details.

    You can check the status of all jobs with jobs.status().

    The jobs variable is set by IPython into the Python builtin namespace.
    If you ever declare a variable named 'jobs', you will shadow this
    name.  You can either delete your global jobs variable to regain
    access to the job manager, or make a new name and assign it manually
    to the manager (stored in IPython's namespace).  For example, to
    assign the job manager to the Jobs name, use:

      Jobs = __builtins__.jobs"""
    
    self.shell.jobs.new(parameter_s,self.shell.user_ns)
</t>
<t tx="ekr.20050704165326.384">def magic_bookmark(self, parameter_s=''):
    """Manage IPython's bookmark system.

    %bookmark &lt;name&gt;       - set bookmark to current dir
    %bookmark &lt;name&gt; &lt;dir&gt; - set bookmark to &lt;dir&gt;
    %bookmark -l           - list all bookmarks
    %bookmark -d &lt;name&gt;    - remove bookmark
    %bookmark -r           - remove all bookmarks

    You can later on access a bookmarked folder with:
      %cd -b &lt;name&gt;
    or simply '%cd &lt;name&gt;' if there is no directory called &lt;name&gt; AND
    there is such a bookmark defined.

    Your bookmarks persist through IPython sessions, but they are
    associated with each profile."""

    opts,args = self.parse_options(parameter_s,'drl',mode='list')
    if len(args) &gt; 2:
        error('You can only give at most two arguments')
        return

    bkms = self.shell.persist.get('bookmarks',{})
        
    if opts.has_key('d'):
        try:
            todel = args[0]
        except IndexError:
            error('You must provide a bookmark to delete')
        else:
            try:
                del bkms[todel]
            except:
                error("Can't delete bookmark '%s'" % todel)
    elif opts.has_key('r'):
        bkms = {}
    elif opts.has_key('l'):
        bks = bkms.keys()
        bks.sort()
        if bks:
            size = max(map(len,bks))
        else:
            size = 0
        fmt = '%-'+str(size)+'s -&gt; %s'
        print 'Current bookmarks:'
        for bk in bks:
            print fmt % (bk,bkms[bk])
    else:
        if not args:
            error("You must specify the bookmark name")
        elif len(args)==1:
            bkms[args[0]] = os.getcwd()
        elif len(args)==2:
            bkms[args[0]] = args[1]
    self.persist['bookmarks'] = bkms
</t>
<t tx="ekr.20050704165326.385">
@language python
&lt;&lt; numutils declarations &gt;&gt;
@others

#**************************** end file &lt;numutils.py&gt; ************************
</t>
<t tx="ekr.20050704165326.386"># -*- coding: utf-8 -*-
"""
A set of convenient utilities for numerical work.

Most of this module requires Numerical Python or is meant to be used with it.
See http://www.pfdubois.com/numpy for details.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2005 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['sum_flat','mean_flat','rms_flat','base_repr','binary_repr',
           'amin','amax','amap','zeros_like','empty_like',
           'frange','diagonal_matrix','identity',
           'fromfunction_kw','log2','ispower2',
           'norm','l1norm','l2norm','exp_safe',
           'inf','infty','Infinity',
           'Numeric']

#****************************************************************************
# required modules
import __main__
import sys,operator
import math
import Numeric
from Numeric import *

#*****************************************************************************
# Globals

# useful for testing infinities in results of array divisions (which don't
# raise an exception)
# Python, LaTeX and Mathematica names.
inf = infty = Infinity = (array([1])/0.0)[0]

#****************************************************************************
# function definitions        
exp_safe_MIN = math.log(2.2250738585072014e-308)
exp_safe_MAX = 1.7976931348623157e+308

</t>
<t tx="ekr.20050704165326.387">def exp_safe(x):
    """Compute exponentials which safely underflow to zero.

    Slow but convenient to use. Note that NumArray will introduce proper
    floating point exception handling with access to the underlying
    hardware."""

    if type(x) is ArrayType:
        return exp(clip(x,exp_safe_MIN,exp_safe_MAX))
    else:
        return math.exp(x)
</t>
<t tx="ekr.20050704165326.388">def amap(fn,*args):
    """amap(function, sequence[, sequence, ...]) -&gt; array.

    Works like map(), but it returns an array.  This is just a convenient
    shorthand for Numeric.array(map(...))"""
    return array(map(fn,*args))
</t>
<t tx="ekr.20050704165326.389">def amin(m,axis=0):
    """amin(m,axis=0) returns the minimum of m along dimension axis.
    """
    return minimum.reduce(asarray(m),axis)
</t>
<t tx="ekr.20050704165326.390">def amax(m,axis=0):
    """amax(m,axis=0) returns the maximum of m along dimension axis.
    """
    return maximum.reduce(asarray(m),axis)
</t>
<t tx="ekr.20050704165326.391">def zeros_like(a):
    """Return an array of zeros of the shape and typecode of a.

    If you don't explicitly need the array to be zeroed, you should instead
    use empty_like(), which is faster as it only allocates memory."""

    return zeros(a.shape,a.typecode())
</t>
<t tx="ekr.20050704165326.392">def empty_like(a):
    """Return an empty (uninitialized) array of the shape and typecode of a.

    Note that this does NOT initialize the returned array.  If you require
    your array to be initialized, you should use zeros_like().

    This requires Numeric.empty(), which appeared in Numeric 23.7."""

    return empty(a.shape,a.typecode())
</t>
<t tx="ekr.20050704165326.393">def sum_flat(a):
    """Return the sum of all the elements of a, flattened out.

    It uses a.flat, and if a is not contiguous, a call to ravel(a) is made."""

    if a.iscontiguous():
        return Numeric.sum(a.flat)
    else:
        return Numeric.sum(ravel(a))
</t>
<t tx="ekr.20050704165326.394">def mean_flat(a):
    """Return the mean of all the elements of a, flattened out."""

    return sum_flat(a)/float(size(a))
</t>
<t tx="ekr.20050704165326.395">def rms_flat(a):
    """Return the root mean square of all the elements of a, flattened out."""

    return math.sqrt(sum_flat(absolute(a)**2)/float(size(a)))
</t>
<t tx="ekr.20050704165326.396">def l1norm(a):
    """Return the l1 norm of a, flattened out.

    Implemented as a separate function (not a call to norm() for speed).

    Ref: http://mathworld.wolfram.com/L1-Norm.html"""

    return sum_flat(absolute(a))
</t>
<t tx="ekr.20050704165326.397">def l2norm(a):
    """Return the l2 norm of a, flattened out.

    Implemented as a separate function (not a call to norm() for speed).

    Ref: http://mathworld.wolfram.com/L2-Norm.html"""

    return math.sqrt(sum_flat(absolute(a)**2))
</t>
<t tx="ekr.20050704165326.398">def norm(a,p=2):
    """norm(a,p=2) -&gt; l-p norm of a.flat

    Return the l-p norm of a, considered as a flat array.  This is NOT a true
    matrix norm, since arrays of arbitrary rank are always flattened.

    p can be a number or one of the strings ('inf','Infinity') to get the
    L-infinity norm.

    Ref: http://mathworld.wolfram.com/VectorNorm.html
         http://mathworld.wolfram.com/L-Infinity-Norm.html"""
    
    if p in ('inf','Infinity'):
        return max(absolute(a).flat)
    else:
        return (sum_flat(absolute(a)**p))**(1.0/p)    
</t>
<t tx="ekr.20050704165326.399">def frange(xini,xfin=None,delta=None,**kw):
    """frange([start,] stop[, step, keywords]) -&gt; array of floats

    Return a Numeric array() containing a progression of floats. Similar to
    arange(), but defaults to a closed interval.

    frange(x0, x1) returns [x0, x0+1, x0+2, ..., x1]; start defaults to 0, and
    the endpoint *is included*. This behavior is different from that of
    range() and arange(). This is deliberate, since frange will probably be
    more useful for generating lists of points for function evaluation, and
    endpoints are often desired in this use. The usual behavior of range() can
    be obtained by setting the keyword 'closed=0', in this case frange()
    basically becomes arange().

    When step is given, it specifies the increment (or decrement). All
    arguments can be floating point numbers.

    frange(x0,x1,d) returns [x0,x0+d,x0+2d,...,xfin] where xfin&lt;=x1.

    frange can also be called with the keyword 'npts'. This sets the number of
    points the list should contain (and overrides the value 'step' might have
    been given). arange() doesn't offer this option.

    Examples:
    &gt;&gt;&gt; frange(3)
    array([ 0.,  1.,  2.,  3.])
    &gt;&gt;&gt; frange(3,closed=0)
    array([ 0.,  1.,  2.])
    &gt;&gt;&gt; frange(1,6,2)
    array([1, 3, 5])
    &gt;&gt;&gt; frange(1,6.5,npts=5)
    array([ 1.   ,  2.375,  3.75 ,  5.125,  6.5  ])
    """

    #defaults
    kw.setdefault('closed',1)
    endpoint = kw['closed'] != 0
        
    # funny logic to allow the *first* argument to be optional (like range())
    # This was modified with a simpler version from a similar frange() found
    # at http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66472
    if xfin == None:
        xfin = xini + 0.0
        xini = 0.0
        
    if delta == None:
        delta = 1.0

    # compute # of points, spacing and return final list
    try:
        npts=kw['npts']
        delta=(xfin-xini)/float(npts-endpoint)
    except KeyError:
        # round() gets npts right even with the vagaries of floating point.
        npts=int(round((xfin-xini)/delta+endpoint))

    return arange(npts)*delta+xini
</t>
<t tx="ekr.20050704165326.400">def diagonal_matrix(diag):
    """Return square diagonal matrix whose non-zero elements are given by the
    input array."""

    return diag*identity(len(diag))
</t>
<t tx="ekr.20050704165326.401">def identity(n,rank=2,typecode='l'):
    """identity(n,r) returns the identity matrix of shape (n,n,...,n) (rank r).

    For ranks higher than 2, this object is simply a multi-index Kronecker
    delta:
                        /  1  if i0=i1=...=iR,
    id[i0,i1,...,iR] = -|
                        \  0  otherwise.

    Optionally a typecode may be given (it defaults to 'l').

    Since rank defaults to 2, this function behaves in the default case (when
    only n is given) like the Numeric identity function."""
    
    iden = zeros((n,)*rank,typecode=typecode)
    for i in range(n):
        idx = (i,)*rank
        iden[idx] = 1
    return iden
</t>
<t tx="ekr.20050704165326.402">def base_repr (number, base = 2, padding = 0):
    """Return the representation of a number in any given base."""
    chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    if number &lt; base: \
       return (padding - 1) * chars [0] + chars [int (number)]
    max_exponent = int (math.log (number)/math.log (base))
    max_power = long (base) ** max_exponent
    lead_digit = int (number/max_power)
    return chars [lead_digit] + \
           base_repr (number - max_power * lead_digit, base, \
                      max (padding - 1, max_exponent))
</t>
<t tx="ekr.20050704165326.403">def binary_repr(number, max_length = 1025):
    """Return the binary representation of the input number as a string.

    This is more efficient than using base_repr with base 2.

    Increase the value of max_length for very large numbers. Note that on
    32-bit machines, 2**1023 is the largest integer power of 2 which can be
    converted to a Python float."""
    
    assert number &lt; 2L &lt;&lt; max_length
    shifts = map (operator.rshift, max_length * [number], \
                  range (max_length - 1, -1, -1))
    digits = map (operator.mod, shifts, max_length * [2])
    if not digits.count (1): return 0
    digits = digits [digits.index (1):]
    return ''.join (map (repr, digits)).replace('L','')
</t>
<t tx="ekr.20050704165326.404">def log2(x,ln2 = math.log(2.0)):
    """Return the log(x) in base 2.
    
    This is a _slow_ function but which is guaranteed to return the correct
    integer value if the input is an ineger exact power of 2."""

    try:
        bin_n = binary_repr(x)[1:]
    except (AssertionError,TypeError):
        return math.log(x)/ln2
    else:
        if '1' in bin_n:
            return math.log(x)/ln2
        else:
            return len(bin_n)
</t>
<t tx="ekr.20050704165326.405">def ispower2(n):
    """Returns the log base 2 of n if n is a power of 2, zero otherwise.

    Note the potential ambiguity if n==1: 2**0==1, interpret accordingly."""

    bin_n = binary_repr(n)[1:]
    if '1' in bin_n:
        return 0
    else:
        return len(bin_n)
</t>
<t tx="ekr.20050704165326.406">def fromfunction_kw(function, dimensions, **kwargs):
    """Drop-in replacement for fromfunction() from Numerical Python.
 
    Allows passing keyword arguments to the desired function.

    Call it as (keywords are optional):
    fromfunction_kw(MyFunction, dimensions, keywords)

    The function MyFunction() is responsible for handling the dictionary of
    keywords it will recieve."""

    return function(tuple(indices(dimensions)),**kwargs)
</t>
<t tx="ekr.20050704165326.407">
@language python
&lt;&lt; OInspect declarations &gt;&gt;
@others
        # end pinfo
</t>
<t tx="ekr.20050704165326.408"># -*- coding: utf-8 -*-
"""Tools for inspecting Python objects.

Uses syntax highlighting for presenting the various information elements.

Similar in spirit to the inspect module, but all calls take a name argument to
reference the name under which an object is being read.

$Id$
"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['Inspector','InspectColors']

# stdlib modules
import inspect,linecache,types,StringIO,string

# IPython's own
from IPython.Itpl import itpl
from IPython.genutils import page,indent,Term
from IPython import PyColorize
from IPython.ColorANSI import *

#****************************************************************************
# Builtin color schemes

Colors = TermColors  # just a shorthand

# Build a few color schemes
NoColor = ColorScheme(
    'NoColor',{
    'header' : Colors.NoColor,
    'normal' : Colors.NoColor  # color off (usu. Colors.Normal)
    }  )

LinuxColors = ColorScheme(
    'Linux',{
    'header' : Colors.LightRed,
    'normal' : Colors.Normal  # color off (usu. Colors.Normal)
    } )

LightBGColors = ColorScheme(
    'LightBG',{
    'header' : Colors.Red,
    'normal' : Colors.Normal  # color off (usu. Colors.Normal)
    }  )

# Build table of color schemes (needed by the parser)
InspectColors = ColorSchemeTable([NoColor,LinuxColors,LightBGColors],
                                 'Linux')

#****************************************************************************
# Auxiliary functions
</t>
<t tx="ekr.20050704165326.409">def getdoc(obj):
    """Stable wrapper around inspect.getdoc.

    This can't crash because of attribute problems.

    It also attempts to call a getdoc() method on the given object.  This
    allows objects which provide their docstrings via non-standard mechanisms
    (like Pyro proxies) to still be inspected by ipython's ? system."""

    ds = None  # default return value
    try:
        ds = inspect.getdoc(obj)
    except:
        # Harden against an inspect failure, which can occur with
        # SWIG-wrapped extensions.
        pass
    # Allow objects to offer customized documentation via a getdoc method:
    try:
        ds2 = obj.getdoc()
    except:
        pass
    else:
        # if we get extra info, we add it to the normal docstring.
        if ds is None:
            ds = ds2
        else:
            ds = '%s\n%s' % (ds,ds2)
    return ds
</t>
<t tx="ekr.20050704165326.410">
#****************************************************************************
# Class definitions

class myStringIO(StringIO.StringIO):
    """Adds a writeln method to normal StringIO."""
	@others
</t>
<t tx="ekr.20050704165326.411">def writeln(self,*arg,**kw):
    """Does a write() and then a write('\n')"""
    self.write(*arg,**kw)
    self.write('\n')
</t>
<t tx="ekr.20050704165326.412">
class Inspector:
	@others
</t>
<t tx="ekr.20050704165326.413">def __init__(self,color_table,code_color_table,scheme):
    self.color_table = color_table
    self.parser = PyColorize.Parser(code_color_table,out='str')
    self.format = self.parser.format
    self.set_active_scheme(scheme)
</t>
<t tx="ekr.20050704165326.414">def __getargspec(self,obj):
    """Get the names and default values of a function's arguments.

    A tuple of four things is returned: (args, varargs, varkw, defaults).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'defaults' is an n-tuple of the default values of the last n arguments.

    Modified version of inspect.getargspec from the Python Standard
    Library."""

    if inspect.isfunction(obj):
        func_obj = obj
    elif inspect.ismethod(obj):
        func_obj = obj.im_func
    else:
        raise TypeError, 'arg is not a Python function'
    args, varargs, varkw = inspect.getargs(func_obj.func_code)
    return args, varargs, varkw, func_obj.func_defaults
</t>
<t tx="ekr.20050704165326.415">def __getdef(self,obj,oname=''):
    """Return the definition header for any callable object.

    If any exception is generated, None is returned instead and the
    exception is suppressed."""
    
    try:
        return oname + inspect.formatargspec(*self.__getargspec(obj))
    except:
        return None
</t>
<t tx="ekr.20050704165326.416">def __head(self,h):
    """Return a header string with proper colors."""
    return '%s%s%s' % (self.color_table.active_colors.header,h,
                       self.color_table.active_colors.normal)
</t>
<t tx="ekr.20050704165326.417">def set_active_scheme(self,scheme):
    self.color_table.set_active_scheme(scheme)
    self.parser.color_table.set_active_scheme(scheme)
</t>
<t tx="ekr.20050704165326.418">def noinfo(self,msg,oname):
    """Generic message when no information is found."""
    print 'No %s found' % msg,
    if oname:
        print 'for %s' % oname
    else:
        print
</t>
<t tx="ekr.20050704165326.419">def pdef(self,obj,oname=''):
    """Print the definition header for any callable object.

    If the object is a class, print the constructor information."""

    if not callable(obj):
        print 'Object is not callable.'
        return

    header = ''
    if type(obj) is types.ClassType:
        header = self.__head('Class constructor information:\n')
        obj = obj.__init__
    elif type(obj) is types.InstanceType:
        obj = obj.__call__

    output = self.__getdef(obj,oname)
    if output is None:
        self.noinfo('definition header',oname)
    else:
        print &gt;&gt;Term.cout, header,self.format(output),
</t>
<t tx="ekr.20050704165326.420">def pdoc(self,obj,oname='',formatter = None):
    """Print the docstring for any object.

    Optional:
    -formatter: a function to run the docstring through for specially
    formatted docstrings."""
    
    head = self.__head  # so that itpl can find it even if private
    ds = getdoc(obj)
    if formatter:
        ds = formatter(ds)
    if type(obj) is types.ClassType:
        init_ds = getdoc(obj.__init__)
        output = itpl('$head("Class Docstring:")\n'
                      '$indent(ds)\n'
                      '$head("Constructor Docstring"):\n'
                      '$indent(init_ds)')
    elif type(obj) is types.InstanceType and hasattr(obj,'__call__'):
        call_ds = getdoc(obj.__call__)
        if call_ds:
            output = itpl('$head("Class Docstring:")\n$indent(ds)\n'
                          '$head("Calling Docstring:")\n$indent(call_ds)')
        else:
            output = ds
    else:
        output = ds
    if output is None:
        self.noinfo('documentation',oname)
        return
    page(output)
</t>
<t tx="ekr.20050704165326.421">def psource(self,obj,oname=''):
    """Print the source code for an object."""

    # Flush the source cache because inspect can return out-of-date source
    linecache.checkcache()
    try:
        src = inspect.getsource(obj) 
    except:
        self.noinfo('source',oname)
    else:
        page(self.format(src))
</t>
<t tx="ekr.20050704165326.422">def pfile(self,obj,oname=''):
    """Show the whole file where an object was defined."""
    try:
        sourcelines,lineno = inspect.getsourcelines(obj)
    except:
        self.noinfo('file',oname)
    else:
        # run contents of file through pager starting at line
        # where the object is defined            
        page(self.format(open(inspect.getabsfile(obj)).read()),lineno)
</t>
<t tx="ekr.20050704165326.423">def pinfo(self,obj,oname='',formatter=None,info=None,detail_level=0):
    """Show detailed information about an object.

    Optional arguments:
    
    - oname: name of the variable pointing to the object.

    - formatter: special formatter for docstrings (see pdoc)

    - info: a structure with some information fields which may have been
    precomputed already.

    - detail_level: if set to 1, more information is given.
    """

    obj_type = type(obj)

    header = self.__head
    if info is None:
        ismagic = 0
        isalias = 0
        ospace = ''
    else:
        ismagic = info.ismagic
        isalias = info.isalias
        ospace = info.namespace
    # Get docstring, special-casing aliases:
    if isalias:
        ds = "Alias to the system command:\n  %s" % obj[1]
    else:
        ds = getdoc(obj)
    if formatter is not None:
        ds = formatter(ds)

    # store output in a list which gets joined with \n at the end.
    out = myStringIO()
    
    string_max = 200 # max size of strings to show (snipped if longer)
    shalf = int((string_max -5)/2)

    if ismagic:
        obj_type_name = 'Magic function'
    elif isalias:
        obj_type_name = 'System alias'
    else:
        obj_type_name = obj_type.__name__
    out.writeln(header('Type:\t\t')+obj_type_name)

    try:
        bclass = obj.__class__
        out.writeln(header('Base Class:\t')+str(bclass))
    except: pass

    # String form, but snip if too long in ? form (full in ??)
    try:
        ostr = str(obj)
        str_head = 'String Form:'
        if not detail_level and len(ostr)&gt;string_max:
            ostr = ostr[:shalf] + ' &lt;...&gt; ' + ostr[-shalf:]
            ostr = ("\n" + " " * len(str_head.expandtabs())).\
                   join(map(string.strip,ostr.split("\n")))
        if ostr.find('\n') &gt; -1:
            # Print multi-line strings starting at the next line.
            str_sep = '\n'
        else:
            str_sep = '\t'
        out.writeln("%s%s%s" % (header(str_head),str_sep,ostr))
    except:
        pass

    if ospace:
        out.writeln(header('Namespace:\t')+ospace)

    # Length (for strings and lists)
    try:
        length = str(len(obj))
        out.writeln(header('Length:\t\t')+length)
    except: pass

    # Filename where object was defined
    try:
        file = inspect.getabsfile(obj)
        if file.endswith('&lt;string&gt;'):
            file = 'Dynamically generated function. No source code available.'
        out.writeln(header('File:\t\t')+file)
    except: pass

    # reconstruct the function definition and print it:
    defln = self.__getdef(obj,oname)
    if defln:
        out.write(header('Definition:\t')+self.format(defln))

    # Docstrings only in detail 0 mode, since source contains them (we
    # avoid repetitions).  If source fails, we add them back, see below.
    if ds and detail_level == 0:
            out.writeln(header('Docstring:\n') + indent(ds))

    # Original source code for any callable
    if detail_level:
        # Flush the source cache because inspect can return out-of-date source
        linecache.checkcache()
        try:
            source = self.format(inspect.getsource(obj))
            out.write(header('Source:\n')+source.rstrip())
        except:
            if ds:
                out.writeln(header('Docstring:\n') + indent(ds))

    # Constructor docstring for classes
    if obj_type is types.ClassType:
        # reconstruct the function definition and print it:
        try:
            obj_init =  obj.__init__
        except AttributeError:
            init_def = init_ds = None
        else:
            init_def = self.__getdef(obj_init,oname)
            init_ds  = getdoc(obj_init)

        if init_def or init_ds:
            out.writeln(header('\nConstructor information:'))
            if init_def:
                out.write(header('Definition:\t')+ self.format(init_def))
            if init_ds:
                out.writeln(header('Docstring:\n') + indent(init_ds))
    # and class docstring for instances:
    elif obj_type is types.InstanceType:

        # First, check whether the instance docstring is identical to the
        # class one, and print it separately if they don't coincide.  In
        # most cases they will, but it's nice to print all the info for
        # objects which use instance-customized docstrings.
        if ds:
            class_ds = getdoc(obj.__class__)
            if class_ds and ds != class_ds:
                out.writeln(header('Class Docstring:\n') +
                            indent(class_ds))

        # Next, try to show constructor docstrings
        try:
            init_ds = getdoc(obj.__init__)
        except AttributeError:
            init_ds = None
        if init_ds:
            out.writeln(header('Constructor Docstring:\n') +
                        indent(init_ds))

        # Call form docstring for callable instances
        if hasattr(obj,'__call__'):
            out.writeln(header('Callable:\t')+'Yes')
            call_def = self.__getdef(obj.__call__,oname)
            if call_def is None:
                out.write(header('Call def:\t')+
                          'Calling definition not available.')
            else:
                out.write(header('Call def:\t')+self.format(call_def))
            call_ds = getdoc(obj.__call__)
            if call_ds:
                out.writeln(header('Call docstring:\n') + indent(call_ds))

    # Finally send to printer/pager
    output = out.getvalue()
    if output:
        page(output)
</t>
<t tx="ekr.20050704165326.424">
@language python
&lt;&lt; OutputTrap declarations &gt;&gt;
@others


if __name__=="__main__":
    # _test_all() # XXX BROKEN.
    pass

#************************ end of file &lt;OutputTrap.py&gt; ************************
</t>
<t tx="ekr.20050704165326.425"># -*- coding: utf-8 -*-
"""Class to trap stdout and stderr and log them separately.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

import exceptions,sys
from cStringIO import StringIO

</t>
<t tx="ekr.20050704165326.426">class OutputTrapError(exceptions.Exception):
    """Exception for OutputTrap class."""
	@others
</t>
<t tx="ekr.20050704165326.427">def __init__(self,args=None):
    exceptions.Exception.__init__(self)
    self.args = args
</t>
<t tx="ekr.20050704165326.428">
class OutputTrap:

    """Class to trap standard output and standard error. They get logged in
    StringIO objects which are available as &lt;instance&gt;.out and
    &lt;instance&gt;.err. The class also offers summary methods which format this
    data a bit.

    A word of caution: because it blocks messages, using this class can make
    debugging very tricky. If you are having bizarre problems silently, try
    turning your output traps off for a while. You can call the constructor
    with the parameter debug=1 for these cases. This turns actual trapping
    off, but you can keep the rest of your code unchanged (this has already
    been a life saver).

    Example:

    # config: trapper with a line of dots as log separator (final '\\n' needed)
    config = OutputTrap('Config','Out ','Err ','.'*80+'\\n')

    # start trapping output
    config.trap_all()

    # now all output is logged ...
    # do stuff...

    # output back to normal:
    config.release_all()

    # print all that got logged:
    print config.summary()

    # print individual raw data:
    print config.out.getvalue()
    print config.err.getvalue()
    """
	@others

    # a few shorthands
    trap = trap_all
    release = release_all
    summary = summary_all
    flush = flush_all</t>
<t tx="ekr.20050704165326.429">def __init__(self,name='Generic Output Trap',
             out_head='Standard Output. ',err_head='Standard Error. ',
             sum_sep='\n',debug=0,trap_out=0,trap_err=0,
             quiet_out=0,quiet_err=0):
    self.name = name
    self.out_head = out_head
    self.err_head = err_head
    self.sum_sep = sum_sep
    self.out = StringIO()
    self.err = StringIO()
    self.out_save = None
    self.err_save = None
    self.debug = debug
    self.quiet_out = quiet_out
    self.quiet_err = quiet_err
    if trap_out:
        self.trap_out()
    if trap_err:
        self.trap_err()
</t>
<t tx="ekr.20050704165326.430">def trap_out(self):
    """Trap and log stdout."""
    if sys.stdout is self.out:
        raise OutputTrapError,'You are already trapping stdout.'
    if not self.debug:
        self._out_save = sys.stdout
        sys.stdout = self.out
</t>
<t tx="ekr.20050704165326.431">def release_out(self):
    """Release stdout."""
    if not self.debug:
        if not sys.stdout is self.out:
            raise OutputTrapError,'You are not trapping stdout.'
        sys.stdout = self._out_save
        self.out_save = None
</t>
<t tx="ekr.20050704165326.432">def summary_out(self):
    """Return as a string the log from stdout."""
    out = self.out.getvalue()
    if out:
        if self.quiet_out:
            return out
        else:
            return self.out_head + 'Log by '+ self.name + ':\n' + out
    else:
        return ''
</t>
<t tx="ekr.20050704165326.433">def flush_out(self):
    """Flush the stdout log. All data held in the log is lost."""

    self.out.close()
    self.out = StringIO()
</t>
<t tx="ekr.20050704165326.434">def trap_err(self):
    """Trap and log stderr."""
    if sys.stderr is self.err:
        raise OutputTrapError,'You are already trapping stderr.'
    if not self.debug:
        self._err_save = sys.stderr
        sys.stderr = self.err
</t>
<t tx="ekr.20050704165326.435">def release_err(self):
    """Release stderr."""
    if not self.debug:
        if not sys.stderr is self.err:
            raise OutputTrapError,'You are not trapping stderr.'
        sys.stderr = self._err_save
        self.err_save = None
</t>
<t tx="ekr.20050704165326.436">def summary_err(self):
    """Return as a string the log from stderr."""
    err = self.err.getvalue()
    if err:
        if self.quiet_err:
            return err
        else:
            return self.err_head + 'Log by '+ self.name + ':\n' + err
    else:
        return ''
</t>
<t tx="ekr.20050704165326.437">def flush_err(self):
    """Flush the stdout log. All data held in the log is lost."""

    self.err.close()
    self.err = StringIO()
</t>
<t tx="ekr.20050704165326.438">def trap_all(self):
    """Trap and log both stdout and stderr.

    Cacthes and discards OutputTrapError exceptions raised."""
    try:
        self.trap_out()
    except OutputTrapError:
        pass
    try:
        self.trap_err()
    except OutputTrapError:
        pass
</t>
<t tx="ekr.20050704165326.439">def release_all(self):
    """Release both stdout and stderr.

    Cacthes and discards OutputTrapError exceptions raised."""
    try:
        self.release_out()
    except OutputTrapError:
        pass
    try:
        self.release_err()
    except OutputTrapError:
        pass
</t>
<t tx="ekr.20050704165326.440">def summary_all(self):
    """Return as a string the log from stdout and stderr, prepending a separator
    to each (defined in __init__ as sum_sep)."""
    sum = ''
    sout = self.summary_out()
    if sout:
        sum += self.sum_sep + sout
    serr = self.summary_err()
    if serr:
        sum += '\n'+self.sum_sep + serr
    return sum
</t>
<t tx="ekr.20050704165326.441">def flush_all(self):
    """Flush stdout and stderr"""
    self.flush_out()
    self.flush_err()
</t>
<t tx="ekr.20050704165326.442"># end OutputTrap


#****************************************************************************
# Module testing. Incomplete, I'm lazy...

def _test_all():

    """Module testing functions, activated when the module is called as a
    script (not imported)."""

    # Put tests for this module in here.
    # Define them as nested functions so they don't clobber the
    # pydoc-generated docs

    def _test_():
        name = ''
        print '#'*50+'\nRunning test for ' + name
        # ...
        print 'Finished test for '+ name +'\n'+'#'*50

    def _test_OutputTrap():
        trap = OutputTrap(name = 'Test Trap', sum_sep = '.'*50+'\n',
                          out_head = 'SOut. ', err_head = 'SErr. ')

        name = 'OutputTrap class'
        print '#'*50+'\nRunning test for ' + name
        print 'Trapping out'
        trap.trap_out()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stdout is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stdout is trapped.'
        trap.release_out()
        print trap.summary_out()

        print 'Trapping err'
        trap.trap_err()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stderr is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stderr is trapped.'
        trap.release_err()
        print trap.summary_err()

        print 'Trapping all (no flushing)'
        trap.trap_all()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stdout/err is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stdout/err is trapped.'
        trap.release_all()
        print trap.summary_all()

        print 'Trapping all (flushing first)'
        trap.flush()
        trap.trap_all()
        print &gt;&gt;sys.stdout, '&gt;&gt;stdout. stdout/err is trapped.'
        print &gt;&gt;sys.stderr, '&gt;&gt;stderr. stdout/err is trapped.'
        trap.release_all()
        print trap.summary_all()
        print 'Finished test for '+ name +'\n'+'#'*50

    # call the actual tests here:
    _test_OutputTrap()
</t>
<t tx="ekr.20050704165326.443">
@language python
&lt;&lt; Prompts declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704165326.444"># -*- coding: utf-8 -*-
"""
Classes for handling input/output prompts.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license
__version__ = Release.version

#****************************************************************************
# Required modules
import __builtin__
import os,sys,socket
import time
from pprint import pprint,pformat

# IPython's own
from IPython.genutils import *
from IPython.Struct import Struct
from IPython.Magic import Macro
from IPython.Itpl import ItplNS
from IPython import ColorANSI

#****************************************************************************
#Color schemes for Prompts.

PromptColors = ColorANSI.ColorSchemeTable()
InputColors = ColorANSI.InputTermColors  # just a shorthand
Colors = ColorANSI.TermColors  # just a shorthand

PromptColors.add_scheme(ColorANSI.ColorScheme(
    'NoColor',
    in_prompt  = InputColors.NoColor,  # Input prompt
    in_number  = InputColors.NoColor,  # Input prompt number
    in_prompt2 = InputColors.NoColor, # Continuation prompt
    in_normal  = InputColors.NoColor,  # color off (usu. Colors.Normal)
    
    out_prompt = Colors.NoColor, # Output prompt
    out_number = Colors.NoColor, # Output prompt number

    normal = Colors.NoColor  # color off (usu. Colors.Normal)
    ))
# make some schemes as instances so we can copy them for modification easily:
__PColLinux =  ColorANSI.ColorScheme(
    'Linux',
    in_prompt  = InputColors.Green,
    in_number  = InputColors.LightGreen,
    in_prompt2 = InputColors.Green,
    in_normal  = InputColors.Normal,  # color off (usu. Colors.Normal)

    out_prompt = Colors.Red,
    out_number = Colors.LightRed,

    normal = Colors.Normal
    )
# Don't forget to enter it into the table!
PromptColors.add_scheme(__PColLinux)
# Slightly modified Linux for light backgrounds
__PColLightBG  = ColorANSI.ColorScheme('LightBG',**__PColLinux.colors.dict().copy())

__PColLightBG.colors.update(
    in_prompt  = InputColors.Blue,
    in_number  = InputColors.LightBlue,
    in_prompt2 = InputColors.Blue
)
PromptColors.add_scheme(__PColLightBG)

del Colors,InputColors

#-----------------------------------------------------------------------------
</t>
<t tx="ekr.20050704165326.445">def multiple_replace(dict, text):
    """ Replace in 'text' all occurences of any key in the given
    dictionary by its corresponding value.  Returns the new string."""

    # Function by Xavier Defrang, originally found at:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/81330

    # Create a regular expression  from the dictionary keys
    regex = re.compile("(%s)" % "|".join(map(re.escape, dict.keys())))
    # For each match, look-up corresponding value in dictionary
    return regex.sub(lambda mo: dict[mo.string[mo.start():mo.end()]], text)
</t>
<t tx="ekr.20050704165326.446">#-----------------------------------------------------------------------------
# Special characters that can be used in prompt templates, mainly bash-like

# If $HOME isn't defined (Windows), make it an absurd string so that it can
# never be expanded out into '~'.  Basically anything which can never be a
# reasonable directory name will do, we just want the $HOME -&gt; '~' operation
# to become a no-op.  We pre-compute $HOME here so it's not done on every
# prompt call.

# FIXME:

# - This should be turned into a class which does proper namespace management,
# since the prompt specials need to be evaluated in a certain namespace.
# Currently it's just globals, which need to be managed manually by code
# below.

# - I also need to split up the color schemes from the prompt specials
# somehow.  I don't have a clean design for that quite yet.

HOME = os.environ.get("HOME","//////:::::ZZZZZ,,,~~~")

# We precompute a few more strings here for the prompt_specials, which are
# fixed once ipython starts.  This reduces the runtime overhead of computing
# prompt strings.
USER           = os.environ.get("USER")
HOSTNAME       = socket.gethostname()
HOSTNAME_SHORT = HOSTNAME.split(".")[0]
ROOT_SYMBOL    = "$#"[os.name=='nt' or os.getuid()==0]

prompt_specials_color = {
    # Prompt/history count
    '%n' : '${self.col_num}' '${self.cache.prompt_count}' '${self.col_p}',
    '\\#': '${self.col_num}' '${self.cache.prompt_count}' '${self.col_p}',
    # Prompt/history count, with the actual digits replaced by dots.  Used
    # mainly in continuation prompts (prompt_in2)
    '\\D': '${"."*len(str(self.cache.prompt_count))}',
    # Current working directory
    '\\w': '${os.getcwd()}',
    # Current time
    '\\t' : '${time.strftime("%H:%M:%S")}',
    # Basename of current working directory.
    # (use os.sep to make this portable across OSes)
    '\\W' : '${os.getcwd().split("%s")[-1]}' % os.sep,
    # These X&lt;N&gt; are an extension to the normal bash prompts.  They return
    # N terms of the path, after replacing $HOME with '~'
    '\\X0': '${os.getcwd().replace("%s","~")}' % HOME,
    '\\X1': '${self.cwd_filt(1)}',
    '\\X2': '${self.cwd_filt(2)}',
    '\\X3': '${self.cwd_filt(3)}',
    '\\X4': '${self.cwd_filt(4)}',
    '\\X5': '${self.cwd_filt(5)}',
    # Y&lt;N&gt; are similar to X&lt;N&gt;, but they show '~' if it's the directory
    # N+1 in the list.  Somewhat like %cN in tcsh.
    '\\Y0': '${self.cwd_filt2(0)}',
    '\\Y1': '${self.cwd_filt2(1)}',
    '\\Y2': '${self.cwd_filt2(2)}',
    '\\Y3': '${self.cwd_filt2(3)}',
    '\\Y4': '${self.cwd_filt2(4)}',
    '\\Y5': '${self.cwd_filt2(5)}',
    # Hostname up to first .
    '\\h': HOSTNAME_SHORT,
    # Full hostname
    '\\H': HOSTNAME,
    # Username of current user
    '\\u': USER,
    # Escaped '\'
    '\\\\': '\\',
    # Newline
    '\\n': '\n',
    # Carriage return
    '\\r': '\r',
    # Release version
    '\\v': __version__,
    # Root symbol ($ or #)
    '\\$': ROOT_SYMBOL,
    }

# A copy of the prompt_specials dictionary but with all color escapes removed,
# so we can correctly compute the prompt length for the auto_rewrite method.
prompt_specials_nocolor = prompt_specials_color.copy()
prompt_specials_nocolor['%n'] = '${self.cache.prompt_count}'
prompt_specials_nocolor['\\#'] = '${self.cache.prompt_count}'

# Add in all the InputTermColors color escapes as valid prompt characters.
# They all get added as \\C_COLORNAME, so that we don't have any conflicts
# with a color name which may begin with a letter used by any other of the
# allowed specials.  This of course means that \\C will never be allowed for
# anything else.
input_colors = ColorANSI.InputTermColors
for _color in dir(input_colors):
    if _color[0] != '_':
        c_name = '\\C_'+_color
        prompt_specials_color[c_name] = getattr(input_colors,_color)
        prompt_specials_nocolor[c_name] = ''

# we default to no color for safety.  Note that prompt_specials is a global
# variable used by all prompt objects.
prompt_specials = prompt_specials_nocolor

#-----------------------------------------------------------------------------
def str_safe(arg):
    """Convert to a string, without ever raising an exception.

    If str(arg) fails, &lt;ERROR: ... &gt; is returned, where ... is the exception
    error message."""
    
    try:
        return str(arg)
    except Exception,msg:
        return '&lt;ERROR: %s&gt;' % msg
</t>
<t tx="ekr.20050704165326.447">
class BasePrompt:
    """Interactive prompt similar to Mathematica's."""
	@others
</t>
<t tx="ekr.20050704165326.448">def __init__(self,cache,sep,prompt,pad_left=False):

    # Hack: we access information about the primary prompt through the
    # cache argument.  We need this, because we want the secondary prompt
    # to be aligned with the primary one.  Color table info is also shared
    # by all prompt classes through the cache.  Nice OO spaghetti code!
    self.cache = cache
    self.sep = sep
    
    # regexp to count the number of spaces at the end of a prompt
    # expression, useful for prompt auto-rewriting
    self.rspace = re.compile(r'(\s*)$')
    # Flag to left-pad prompt strings to match the length of the primary
    # prompt
    self.pad_left = pad_left
    # Set template to create each actual prompt (where numbers change)
    self.p_template = prompt
    self.set_p_str()
</t>
<t tx="ekr.20050704165326.449">def set_p_str(self):
    """ Set the interpolating prompt strings.

    This must be called every time the color settings change, because the
    prompt_specials global may have changed."""

    import os,time  # needed in locals for prompt string handling
    loc = locals()
    self.p_str = ItplNS('%s%s%s' %
                        ('${self.sep}${self.col_p}',
                         multiple_replace(prompt_specials, self.p_template),
                         '${self.col_norm}'),self.cache.user_ns,loc)
    
    self.p_str_nocolor = ItplNS(multiple_replace(prompt_specials_nocolor,
                                                 self.p_template),
                                self.cache.user_ns,loc)
</t>
<t tx="ekr.20050704165326.450">def write(self,msg):  # dbg
    sys.stdout.write(msg)
    return ''
</t>
<t tx="ekr.20050704165326.451">def __str__(self):
    """Return a string form of the prompt.

    This for is useful for continuation and output prompts, since it is
    left-padded to match lengths with the primary one (if the
    self.pad_left attribute is set)."""

    out_str = str_safe(self.p_str)
    if self.pad_left:
        # We must find the amount of padding required to match lengths,
        # taking the color escapes (which are invisible on-screen) into
        # account.
        esc_pad = len(out_str) - len(str_safe(self.p_str_nocolor))
        format = '%%%ss' % (len(str(self.cache.last_prompt))+esc_pad)
        return format % out_str
    else:
        return out_str
</t>
<t tx="ekr.20050704165326.452"># these path filters are put in as methods so that we can control the
# namespace where the prompt strings get evaluated
def cwd_filt(self,depth):
    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""

    cwd = os.getcwd().replace(HOME,"~")
    out = os.sep.join(cwd.split(os.sep)[-depth:])
    if out:
        return out
    else:
        return os.sep
</t>
<t tx="ekr.20050704165326.453">def cwd_filt2(self,depth):
    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""

    cwd = os.getcwd().replace(HOME,"~").split(os.sep)
    if '~' in cwd and len(cwd) == depth+1:
        depth += 1
    out = os.sep.join(cwd[-depth:])
    if out:
        return out
    else:
        return os.sep
</t>
<t tx="ekr.20050704165326.454">
class Prompt1(BasePrompt):
    """Input interactive prompt similar to Mathematica's."""
	@others
</t>
<t tx="ekr.20050704165326.455">def __init__(self,cache,sep='\n',prompt='In [\\#]: ',pad_left=True):
    BasePrompt.__init__(self,cache,sep,prompt,pad_left)
</t>
<t tx="ekr.20050704165326.456">def set_colors(self):
    self.set_p_str()
    Colors = self.cache.color_table.active_colors # shorthand
    self.col_p = Colors.in_prompt
    self.col_num = Colors.in_number
    self.col_norm = Colors.in_normal
    # We need a non-input version of these escapes for the '---&gt;'
    # auto-call prompts used in the auto_rewrite() method.
    self.col_p_ni = self.col_p.replace('\001','').replace('\002','') 
    self.col_norm_ni = Colors.normal        
</t>
<t tx="ekr.20050704165326.457">def __str__(self):
    self.cache.prompt_count += 1
    self.cache.last_prompt = str_safe(self.p_str_nocolor).split('\n')[-1]
    return str_safe(self.p_str)
</t>
<t tx="ekr.20050704165326.458">def auto_rewrite(self):
    """Print a string of the form '---&gt;' which lines up with the previous
    input string. Useful for systems which re-write the user input when
    handling automatically special syntaxes."""

    curr = str(self.cache.last_prompt)
    nrspaces = len(self.rspace.search(curr).group())
    return '%s%s&gt;%s%s' % (self.col_p_ni,'-'*(len(curr)-nrspaces-1),
                          ' '*nrspaces,self.col_norm_ni)
</t>
<t tx="ekr.20050704165326.459">
class PromptOut(BasePrompt):
    """Output interactive prompt similar to Mathematica's."""
	@others
</t>
<t tx="ekr.20050704165326.460">def __init__(self,cache,sep='',prompt='Out[\\#]: ',pad_left=True):
    BasePrompt.__init__(self,cache,sep,prompt,pad_left)
    if not self.p_template:
        self.__str__ = lambda: ''
</t>
<t tx="ekr.20050704165326.461">def set_colors(self):
    self.set_p_str()
    Colors = self.cache.color_table.active_colors # shorthand
    self.col_p = Colors.out_prompt
    self.col_num = Colors.out_number
    self.col_norm = Colors.normal
</t>
<t tx="ekr.20050704165326.462">
class Prompt2(BasePrompt):
    """Interactive continuation prompt."""
	@others
</t>
<t tx="ekr.20050704165326.463">def __init__(self,cache,prompt='   .\\D.: ',pad_left=True):
    self.cache = cache
    self.p_template = prompt
    self.pad_left = pad_left
    self.set_p_str()
</t>
<t tx="ekr.20050704165326.464">def set_p_str(self):
    import os,time  # needed in locals for prompt string handling
    loc = locals()
    self.p_str = ItplNS('%s%s%s' %
                        ('${self.col_p2}',
                         multiple_replace(prompt_specials, self.p_template),
                         '$self.col_norm'),
                        self.cache.user_ns,loc)
    self.p_str_nocolor = ItplNS(multiple_replace(prompt_specials_nocolor,
                                                 self.p_template),
                                self.cache.user_ns,loc)
</t>
<t tx="ekr.20050704165326.465">def set_colors(self):
    self.set_p_str()
    Colors = self.cache.color_table.active_colors
    self.col_p2 = Colors.in_prompt2
    self.col_norm = Colors.in_normal
    # FIXME (2004-06-16) HACK: prevent crashes for users who haven't
    # updated their prompt_in2 definitions.  Remove eventually.
    self.col_p = Colors.out_prompt
    self.col_num = Colors.out_number
</t>
<t tx="ekr.20050704165326.466">class CachedOutput:
    """Class for printing output from calculations while keeping a cache of
    reults. It dynamically creates global variables prefixed with _ which
    contain these results.

    Meant to be used as a sys.displayhook replacement, providing numbered
    prompts and cache services.

    Initialize with initial and final values for cache counter (this defines
    the maximum size of the cache."""

	@others</t>
<t tx="ekr.20050704165326.467">def __init__(self,cache_size,Pprint,colors='NoColor',input_sep='\n',
             output_sep='\n',output_sep2='',user_ns={},
             ps1 = None, ps2 = None,ps_out = None,
             input_hist = None,pad_left=True):

    cache_size_min = 20
    if cache_size &lt;= 0:
        self.do_full_cache = 0
        cache_size = 0
    elif cache_size &lt; cache_size_min:
        self.do_full_cache = 0
        cache_size = 0
        warn('caching was disabled (min value for cache size is %s).' %
             cache_size_min,level=3)
    else:
        self.do_full_cache = 1

    self.cache_size = cache_size
    self.input_sep = input_sep

    # we need a reference to the user-level namespace
    self.user_ns = user_ns
    # and to the user's input
    self.input_hist = input_hist

    # Set input prompt strings and colors
    if cache_size == 0:
        if ps1.find('%n') &gt; -1 or ps1.find('\\#') &gt; -1: ps1 = '&gt;&gt;&gt; '
        if ps2.find('%n') &gt; -1 or ps2.find('\\#') &gt; -1: ps2 = '... '
    self.ps1_str = self._set_prompt_str(ps1,'In [\\#]: ','&gt;&gt;&gt; ')
    self.ps2_str = self._set_prompt_str(ps2,'   .\\D.: ','... ')
    self.ps_out_str = self._set_prompt_str(ps_out,'Out[\\#]: ','')

    self.prompt1 = Prompt1(self,sep=input_sep,prompt=self.ps1_str,
                           pad_left=pad_left)
    self.prompt2 = Prompt2(self,prompt=self.ps2_str,pad_left=pad_left)
    self.prompt_out = PromptOut(self,sep='',prompt=self.ps_out_str,
                                pad_left=pad_left)
    self.color_table = PromptColors
    self.set_colors(colors)

    # other more normal stuff
    # b/c each call to the In[] prompt raises it by 1, even the first.
    self.prompt_count = 0
    self.cache_count = 1
    # Store the last prompt string each time, we need it for aligning
    # continuation and auto-rewrite prompts
    self.last_prompt = ''
    self.entries = [None]  # output counter starts at 1 for the user
    self.Pprint = Pprint
    self.output_sep = output_sep
    self.output_sep2 = output_sep2
    self._,self.__,self.___ = '','',''
    self.pprint_types = map(type,[(),[],{}])
    
    # these are deliberately global:
    to_user_ns = {'_':self._,'__':self.__,'___':self.___}
    self.user_ns.update(to_user_ns)
</t>
<t tx="ekr.20050704165326.468">def _set_prompt_str(self,p_str,cache_def,no_cache_def):
    if p_str is None:
        if self.do_full_cache:
            return cache_def
        else:
            return no_cache_def
    else:
        return p_str
</t>
<t tx="ekr.20050704165326.469">def set_colors(self,colors):
    """Set the active color scheme and configure colors for the three
    prompt subsystems."""

    # FIXME: the prompt_specials global should be gobbled inside this
    # class instead.  Do it when cleaning up the whole 3-prompt system.
    global prompt_specials
    if colors.lower()=='nocolor':
        prompt_specials = prompt_specials_nocolor
    else:
        prompt_specials = prompt_specials_color
    
    self.color_table.set_active_scheme(colors)
    self.prompt1.set_colors()
    self.prompt2.set_colors()
    self.prompt_out.set_colors()
</t>
<t tx="ekr.20050704165326.470">def __call__(self,arg=None):
    """Printing with history cache management.
    
    This is invoked everytime the interpreter needs to print, and is
    activated by setting the variable sys.displayhook to it."""

    # If something injected a '_' variable in __builtin__, delete
    # ipython's automatic one so we don't clobber that.  gettext() in
    # particular uses _, so we need to stay away from it.
    if '_' in __builtin__.__dict__:
        try:
            del self.user_ns['_']
        except KeyError:
            pass
    if arg is not None:
        # first handle the cache and counters
        self.update(arg)
        # do not print output if input ends in ';'
        if self.input_hist[self.prompt_count].endswith(';\n'):
            return
        # don't use print, puts an extra space
        Term.cout.write(self.output_sep)
        if self.do_full_cache:
            Term.cout.write(str(self.prompt_out))

        if isinstance(arg,Macro):
            print 'Executing Macro...'
            # in case the macro takes a long time to execute
            Term.cout.flush()
            exec arg.value in self.user_ns
            return None

        # and now call a possibly user-defined print mechanism
        self.display(arg)
        Term.cout.write(self.output_sep2)
        Term.cout.flush()
</t>
<t tx="ekr.20050704165326.471">def _display(self,arg):
    """Default printer method, uses pprint.

    This can be over-ridden by the users to implement special formatting
    of certain types of output."""

    if self.Pprint:
        # The following is an UGLY kludge, b/c python fails to properly
        # identify instances of classes imported in the user namespace
        # (they have different memory locations, I guess). Structs are
        # essentially dicts but pprint doesn't know what to do with them.
        try:
            if arg.__class__.__module__ == 'Struct' and \
               arg.__class__.__name__ == 'Struct':
                out = 'Struct:\n%s' % pformat(arg.dict())
            else:
                out = pformat(arg)
        except:
            out = pformat(arg)
        if '\n' in out:
            # So that multi-line strings line up with the left column of
            # the screen, instead of having the output prompt mess up
            # their first line.                
            Term.cout.write('\n')
        print &gt;&gt;Term.cout, out
    else:
        print &gt;&gt;Term.cout, arg
        
# Assign the default display method:
display = _display
</t>
<t tx="ekr.20050704165326.472">def update(self,arg):
    #print '***cache_count', self.cache_count # dbg
    if self.cache_count &gt;= self.cache_size and self.do_full_cache:
        self.flush()
    # Don't overwrite '_' and friends if '_' is in __builtin__ (otherwise
    # we cause buggy behavior for things like gettext).
    if '_' not in __builtin__.__dict__:
        self.___ = self.__
        self.__ = self._
        self._ = arg
        self.user_ns.update({'_':self._,'__':self.__,'___':self.___})
        
    # hackish access to top-level  namespace to create _1,_2... dynamically
    to_main = {}
    if self.do_full_cache:
        self.cache_count += 1
        self.entries.append(arg)
        new_result = '_'+`self.prompt_count`
        to_main[new_result] = self.entries[-1]
    self.user_ns.update(to_main)
    self.user_ns['_oh'][self.prompt_count] = arg
</t>
<t tx="ekr.20050704165326.473">def flush(self):
    if not self.do_full_cache:
        raise ValueError,"You shouldn't have reached the cache flush "\
              "if full caching is not enabled!"
    warn('Output cache limit (currently '+\
          `self.cache_count`+' entries) hit.\n'
         'Flushing cache and resetting history counter...\n'
         'The only history variables available will be _,__,___ and _1\n'
         'with the current result.')
    # delete auto-generated vars from global namespace
    for n in range(1,self.prompt_count + 1):
        key = '_'+`n`
        try:
            del self.user_ns[key]
        except: pass
    self.prompt_count = 1
    self.cache_count = 1
</t>
<t tx="ekr.20050704165326.474">
@language python
&lt;&lt; PyColorize declarations &gt;&gt;
@others

if __name__ == "__main__":
    main()
</t>
<t tx="ekr.20050704165326.475"># -*- coding: utf-8 -*-
"""
    Class and program to colorize python source code for ANSI terminals.

    Based on an HTML code highlighter by Jurgen Hermann found at:
    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52298

    Modifications by Fernando Perez (fperez@colorado.edu).

    Information on the original HTML highlighter follows:
    
    MoinMoin - Python Source Parser

    Title:olorize Python source using the built-in tokenizer
           
    Submitter: Jurgen Hermann
    Last Updated:2001/04/06
           
    Version no:1.2

    Description:

    This code is part of MoinMoin (http://moin.sourceforge.net/) and converts
    Python source code to HTML markup, rendering comments, keywords,
    operators, numeric and string literals in different colors.

    It shows how to use the built-in keyword, token and tokenize modules to
    scan Python source code and re-emit it with no changes to its original
    formatting (which is the hard part).

    $Id$"""

__all__ = ['ANSICodeColors','Parser']

_scheme_default = 'Linux'

# Imports
import string, sys, os, cStringIO
import keyword, token, tokenize

from IPython.ColorANSI import *

#############################################################################
### Python Source Parser (does Hilighting)
#############################################################################

_KEYWORD = token.NT_OFFSET + 1
_TEXT    = token.NT_OFFSET + 2

#****************************************************************************
# Builtin color schemes

Colors = TermColors  # just a shorthand

# Build a few color schemes
NoColor = ColorScheme(
    'NoColor',{
    token.NUMBER     : Colors.NoColor,
    token.OP         : Colors.NoColor,
    token.STRING     : Colors.NoColor,
    tokenize.COMMENT : Colors.NoColor,
    token.NAME       : Colors.NoColor,
    token.ERRORTOKEN : Colors.NoColor,

    _KEYWORD         : Colors.NoColor,
    _TEXT            : Colors.NoColor,

    'normal'         : Colors.NoColor  # color off (usu. Colors.Normal)
    }  )

LinuxColors = ColorScheme(
    'Linux',{
    token.NUMBER     : Colors.LightCyan,
    token.OP         : Colors.Yellow,
    token.STRING     : Colors.LightBlue,
    tokenize.COMMENT : Colors.LightRed,
    token.NAME       : Colors.White,
    token.ERRORTOKEN : Colors.Red,

    _KEYWORD         : Colors.LightGreen,
    _TEXT            : Colors.Yellow,

    'normal'         : Colors.Normal  # color off (usu. Colors.Normal)
    } )

LightBGColors = ColorScheme(
    'LightBG',{
    token.NUMBER     : Colors.Cyan,
    token.OP         : Colors.Blue,
    token.STRING     : Colors.Blue,
    tokenize.COMMENT : Colors.Red,
    token.NAME       : Colors.Black,
    token.ERRORTOKEN : Colors.Red,

    _KEYWORD         : Colors.Green,
    _TEXT            : Colors.Blue,

    'normal'         : Colors.Normal  # color off (usu. Colors.Normal)
    }  )

# Build table of color schemes (needed by the parser)
ANSICodeColors = ColorSchemeTable([NoColor,LinuxColors,LightBGColors],
                                  _scheme_default)

</t>
<t tx="ekr.20050704165326.476">class Parser:
    """ Format colored Python source.
    """
	@others
</t>
<t tx="ekr.20050704165326.477">def __init__(self, color_table=None,out = sys.stdout):
    """ Create a parser with a specified color table and output channel.

    Call format() to process code.
    """
    self.color_table = color_table and color_table or ANSICodeColors
    self.out = out
</t>
<t tx="ekr.20050704165326.478">def format(self, raw, out = None, scheme = ''):
    """ Parse and send the colored source.

    If out and scheme are not specified, the defaults (given to
    constructor) are used.

    out should be a file-type object. Optionally, out can be given as the
    string 'str' and the parser will automatically return the output in a
    string."""
    
    self.raw = string.strip(string.expandtabs(raw))
    string_output = 0
    if out == 'str' or self.out == 'str':
        out_old = self.out
        self.out = cStringIO.StringIO()
        string_output = 1
    elif out is not None:
        self.out = out
    # local shorthand
    colors = self.color_table[scheme].colors
    self.colors = colors # put in object so __call__ sees it
    # store line offsets in self.lines
    self.lines = [0, 0]
    pos = 0
    while 1:
        pos = string.find(self.raw, '\n', pos) + 1
        if not pos: break
        self.lines.append(pos)
    self.lines.append(len(self.raw))

    # parse the source and write it
    self.pos = 0
    text = cStringIO.StringIO(self.raw)
    #self.out.write('&lt;pre&gt;&lt;font face="Courier New"&gt;')
    try:
        tokenize.tokenize(text.readline, self)
    except tokenize.TokenError, ex:
        msg = ex[0]
        line = ex[1][0]
        self.out.write("%s\n\n*** ERROR: %s%s%s\n" %
                       (colors[token.ERRORTOKEN],
                        msg, self.raw[self.lines[line]:],
                        colors.normal)
                       )
    self.out.write(colors.normal+'\n')
    if string_output:
        output = self.out.getvalue()
        self.out = out_old
        return output
</t>
<t tx="ekr.20050704165326.479">def __call__(self, toktype, toktext, (srow,scol), (erow,ecol), line):
    """ Token handler, with syntax highlighting."""

    # local shorthand
    colors = self.colors

    # line separator, so this works across platforms
    linesep = os.linesep

    # calculate new positions
    oldpos = self.pos
    newpos = self.lines[srow] + scol
    self.pos = newpos + len(toktext)

    # handle newlines
    if toktype in [token.NEWLINE, tokenize.NL]:
        self.out.write(linesep)
        return

    # send the original whitespace, if needed
    if newpos &gt; oldpos:
        self.out.write(self.raw[oldpos:newpos])

    # skip indenting tokens
    if toktype in [token.INDENT, token.DEDENT]:
        self.pos = newpos
        return

    # map token type to a color group
    if token.LPAR &lt;= toktype and toktype &lt;= token.OP:
        toktype = token.OP
    elif toktype == token.NAME and keyword.iskeyword(toktext):
        toktype = _KEYWORD
    color = colors.get(toktype, colors[_TEXT])

    #print '&lt;%s&gt;' % toktext,    # dbg

    # Triple quoted strings must be handled carefully so that backtracking
    # in pagers works correctly. We need color terminators on _each_ line.
    if linesep in toktext:
        toktext = toktext.replace(linesep, '%s%s%s' %
                                  (colors.normal,linesep,color))

    # send text
    self.out.write('%s%s%s' % (color,toktext,colors.normal))
</t>
<t tx="ekr.20050704165326.480">def main():
    """Colorize a python file using ANSI color escapes and print to stdout.

    Usage:
      %s [-s scheme] filename

    Options:

      -s scheme: give the color scheme to use. Currently only 'Linux'
      (default) and 'LightBG' and 'NoColor' are implemented (give without
      quotes).  """  

    def usage():
        print &gt;&gt; sys.stderr, main.__doc__ % sys.argv[0]
        sys.exit(1)
        
    # FIXME: rewrite this to at least use getopt
    try:
        if sys.argv[1] == '-s':
            scheme_name = sys.argv[2]
            del sys.argv[1:3]
        else:
            scheme_name = _scheme_default
        
    except:
        usage()

    try:
        fname = sys.argv[1]
    except:
        usage()
        
    # write colorized version to stdout
    parser = Parser()
    try:
        parser.format(file(fname).read(),scheme = scheme_name)
    except IOError,msg:
        # if user reads through a pager and quits, don't print traceback
        if msg.args != (32,'Broken pipe'):
            raise
</t>
<t tx="ekr.20050704165326.481">
@language python
# -*- coding: utf-8 -*-
"""Release data for the IPython project.

$Id$"""

# Name of the package for release purposes.  This is the name which labels
# the tarballs and RPMs made by distutils, so it's best to lowercase it.
name = 'ipython'

# For versions with substrings (like 0.6.7_rc1), use _ but NOT -, since
# bdist_rpm chokes on dashes in the version string.
version = '0.6.15'

description = "An enhanced interactive Python shell."

long_description = \
"""
IPython provides a replacement for the interactive Python interpreter with
extra functionality.

Main features:

 * Comprehensive object introspection.

 * Input history, persistent across sessions.

 * Caching of output results during a session with automatically generated
   references.

 * Readline based name completion.

 * Extensible system of 'magic' commands for controlling the environment and
   performing many tasks related either to IPython or the operating system.

 * Configuration system with easy switching between different setups (simpler
   than changing $PYTHONSTARTUP environment variables every time).

 * Session logging and reloading.

 * Extensible syntax processing for special purpose situations.

 * Access to the system shell with user-extensible alias system.

 * Easily embeddable in other Python programs.

 * Integrated access to the pdb debugger and the Python profiler. """

license = 'BSD'

authors = {'Fernando' : ('Fernando Perez','fperez@colorado.edu'),
           'Janko'    : ('Janko Hauser','jhauser@zscout.de'),
           'Nathan'   : ('Nathaniel Gray','n8gray@caltech.edu')
           }

url = 'http://ipython.scipy.org'

platforms = ['Linux','Mac OSX','Windows XP/2000/NT','Windows 95/98/ME']

keywords = ['Interactive','Interpreter','Shell']
</t>
<t tx="ekr.20050704165326.482">
@language python
&lt;&lt; Shell declarations &gt;&gt;
@others

# Some aliases for backwards compatibility
IPythonShell = IPShell
IPythonShellEmbed = IPShellEmbed
#************************ End of file &lt;Shell.py&gt; ***************************
</t>
<t tx="ekr.20050704165326.483"># -*- coding: utf-8 -*-
"""IPython Shell classes.

All the matplotlib support code was co-developed with John Hunter,
matplotlib's author.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

# Code begins
import __main__
import __builtin__
import sys
import os
import code
import threading
import signal

import IPython
from IPython.iplib import InteractiveShell
from IPython.ipmaker import make_IPython
from IPython.genutils import Term,warn,error,flag_calls
from IPython.Struct import Struct
from IPython.Magic import Magic
from IPython import ultraTB

# global flag to pass around information about Ctrl-C without exceptions
KBINT = False

# global flag to turn on/off Tk support.
USE_TK = False

#-----------------------------------------------------------------------------
# This class is trivial now, but I want to have it in to publish a clean
# interface. Later when the internals are reorganized, code that uses this
# shouldn't have to change.

</t>
<t tx="ekr.20050704165326.484">class IPShell:
    """Create an IPython instance."""
	@others
</t>
<t tx="ekr.20050704165326.485">def __init__(self,argv=None,user_ns=None,debug=1,
             shell_class=InteractiveShell):
    self.IP = make_IPython(argv,user_ns=user_ns,debug=debug,
                           shell_class=shell_class)
</t>
<t tx="ekr.20050704165326.486">def mainloop(self,sys_exit=0,banner=None):
    self.IP.mainloop(banner)
    if sys_exit:
        sys.exit()
</t>
<t tx="ekr.20050704165326.487">
#-----------------------------------------------------------------------------
class IPShellEmbed:
    """Allow embedding an IPython shell into a running program.

    Instances of this class are callable, with the __call__ method being an
    alias to the embed() method of an InteractiveShell instance.

    Usage (see also the example-embed.py file for a running example):

    ipshell = IPShellEmbed([argv,banner,exit_msg,rc_override])

    - argv: list containing valid command-line options for IPython, as they
    would appear in sys.argv[1:].

    For example, the following command-line options:

      $ ipython -prompt_in1 'Input &lt;\\#&gt;' -colors LightBG

    would be passed in the argv list as:

      ['-prompt_in1','Input &lt;\\#&gt;','-colors','LightBG']

    - banner: string which gets printed every time the interpreter starts.

    - exit_msg: string which gets printed every time the interpreter exits.

    - rc_override: a dict or Struct of configuration options such as those
    used by IPython. These options are read from your ~/.ipython/ipythonrc
    file when the Shell object is created. Passing an explicit rc_override
    dict with any options you want allows you to override those values at
    creation time without having to modify the file. This way you can create
    embeddable instances configured in any way you want without editing any
    global files (thus keeping your interactive IPython configuration
    unchanged).

    Then the ipshell instance can be called anywhere inside your code:
    
    ipshell(header='') -&gt; Opens up an IPython shell.

    - header: string printed by the IPython shell upon startup. This can let
    you know where in your code you are when dropping into the shell. Note
    that 'banner' gets prepended to all calls, so header is used for
    location-specific information.

    For more details, see the __call__ method below.

    When the IPython shell is exited with Ctrl-D, normal program execution
    resumes.

    This functionality was inspired by a posting on comp.lang.python by cmkl
    &lt;cmkleffner@gmx.de&gt; on Dec. 06/01 concerning similar uses of pyrepl, and
    by the IDL stop/continue commands."""
	@others
</t>
<t tx="ekr.20050704165326.488">def __init__(self,argv=None,banner='',exit_msg=None,rc_override=None):
    """Note that argv here is a string, NOT a list."""
    self.set_banner(banner)
    self.set_exit_msg(exit_msg)
    self.set_dummy_mode(0)

    # sys.displayhook is a global, we need to save the user's original
    # Don't rely on __displayhook__, as the user may have changed that.
    self.sys_displayhook_ori = sys.displayhook

    # save readline completer status
    try:
        #print 'Save completer',sys.ipcompleter  # dbg
        self.sys_ipcompleter_ori = sys.ipcompleter
    except:
        pass # not nested with IPython
    
    # FIXME. Passing user_ns breaks namespace handling.
    #self.IP = make_IPython(argv,user_ns=__main__.__dict__)
    self.IP = make_IPython(argv,rc_override=rc_override,embedded=True)

    self.IP.name_space_init()
    # mark this as an embedded instance so we know if we get a crash
    # post-mortem
    self.IP.rc.embedded = 1
    # copy our own displayhook also
    self.sys_displayhook_embed = sys.displayhook
    # and leave the system's display hook clean
    sys.displayhook = self.sys_displayhook_ori
    # don't use the ipython crash handler so that user exceptions aren't
    # trapped
    sys.excepthook = ultraTB.FormattedTB(color_scheme = self.IP.rc.colors,
                                         mode = self.IP.rc.xmode,
                                         call_pdb = self.IP.rc.pdb)
    self.restore_system_completer()
</t>
<t tx="ekr.20050704165326.489">def restore_system_completer(self):
    """Restores the readline completer which was in place.

    This allows embedded IPython within IPython not to disrupt the
    parent's completion.
    """
    
    try:
        self.IP.readline.set_completer(self.sys_ipcompleter_ori)
        sys.ipcompleter = self.sys_ipcompleter_ori
    except:
        pass
</t>
<t tx="ekr.20050704165326.490">def __call__(self,header='',local_ns=None,global_ns=None,dummy=None):
    """Activate the interactive interpreter.

    __call__(self,header='',local_ns=None,global_ns,dummy=None) -&gt; Start
    the interpreter shell with the given local and global namespaces, and
    optionally print a header string at startup.

    The shell can be globally activated/deactivated using the
    set/get_dummy_mode methods. This allows you to turn off a shell used
    for debugging globally.

    However, *each* time you call the shell you can override the current
    state of dummy_mode with the optional keyword parameter 'dummy'. For
    example, if you set dummy mode on with IPShell.set_dummy_mode(1), you
    can still have a specific call work by making it as IPShell(dummy=0).

    The optional keyword parameter dummy controls whether the call
    actually does anything.  """

    # Allow the dummy parameter to override the global __dummy_mode
    if dummy or (dummy != 0 and self.__dummy_mode):
        return

    # Set global subsystems (display,completions) to our values
    sys.displayhook = self.sys_displayhook_embed
    if self.IP.has_readline:
        self.IP.readline.set_completer(self.IP.Completer.complete)

    if self.banner and header:
        format = '%s\n%s\n'
    else:
        format = '%s%s\n'
    banner =  format % (self.banner,header)

    # Call the embedding code with a stack depth of 1 so it can skip over
    # our call and get the original caller's namespaces.
    self.IP.embed_mainloop(banner,local_ns,global_ns,stack_depth=1)

    if self.exit_msg:
        print self.exit_msg
        
    # Restore global systems (display, completion)
    sys.displayhook = self.sys_displayhook_ori
    self.restore_system_completer()
</t>
<t tx="ekr.20050704165326.491">def set_dummy_mode(self,dummy):
    """Sets the embeddable shell's dummy mode parameter.

    set_dummy_mode(dummy): dummy = 0 or 1.

    This parameter is persistent and makes calls to the embeddable shell
    silently return without performing any action. This allows you to
    globally activate or deactivate a shell you're using with a single call.

    If you need to manually"""

    if dummy not in [0,1]:
        raise ValueError,'dummy parameter must be 0 or 1'
    self.__dummy_mode = dummy
</t>
<t tx="ekr.20050704165326.492">def get_dummy_mode(self):
    """Return the current value of the dummy mode parameter.
    """
    return self.__dummy_mode
</t>
<t tx="ekr.20050704165326.493">def set_banner(self,banner):
    """Sets the global banner.

    This banner gets prepended to every header printed when the shell
    instance is called."""

    self.banner = banner
</t>
<t tx="ekr.20050704165326.494">def set_exit_msg(self,exit_msg):
    """Sets the global exit_msg.

    This exit message gets printed upon exiting every time the embedded
    shell is called. It is None by default. """

    self.exit_msg = exit_msg
</t>
<t tx="ekr.20050704165326.495">#-----------------------------------------------------------------------------
def sigint_handler (signum,stack_frame):
    """Sigint handler for threaded apps.

    This is a horrible hack to pass information about SIGINT _without_ using
    exceptions, since I haven't been able to properly manage cross-thread
    exceptions in GTK/WX.  In fact, I don't think it can be done (or at least
    that's my understanding from a c.l.py thread where this was discussed)."""

    global KBINT
    
    print '\nKeyboardInterrupt - Press &lt;Enter&gt; to continue.',
    Term.cout.flush()
    # Set global flag so that runsource can know that Ctrl-C was hit
    KBINT = True
</t>
<t tx="ekr.20050704165326.496">
class MTInteractiveShell(InteractiveShell):
    """Simple multi-threaded shell."""
	&lt;&lt; class MTInteractiveShell declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.497">    # Threading strategy taken from:
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65109, by Brian
    # McErlean and John Finlay.  Modified with corrections by Antoon Pardon,
    # from the pygtk mailing list, to avoid lockups with system calls.

</t>
<t tx="ekr.20050704165326.498">def __init__(self,name,usage=None,rc=Struct(opts=None,args=None),
             user_ns = None, banner2='',**kw):
    """Similar to the normal InteractiveShell, but with threading control"""
    
    IPython.iplib.InteractiveShell.__init__(self,name,usage,rc,user_ns,banner2)

    # Locking control variable
    self.thread_ready = threading.Condition()

    # Stuff to do at closing time
    self._kill = False
    on_kill = kw.get('on_kill')
    if on_kill is None:
        on_kill = []
    # Check that all things to kill are callable:
    for t in on_kill:
        if not callable(t):
            raise TypeError,'on_kill must be a list of callables'
    self.on_kill = on_kill
</t>
<t tx="ekr.20050704165326.499">def runsource(self, source, filename="&lt;input&gt;", symbol="single"):
    """Compile and run some source in the interpreter.

    Modified version of code.py's runsource(), to handle threading issues.
    See the original for full docstring details."""

    global KBINT
    
    # If Ctrl-C was typed, we reset the flag and return right away
    if KBINT:
        KBINT = False
        return False
    
    try:
        code = self.compile(source, filename, symbol)
    except (OverflowError, SyntaxError, ValueError):
        # Case 1
        self.showsyntaxerror(filename)
        return False

    if code is None:
        # Case 2
        return True

    # Case 3
    # Store code in self, so the execution thread can handle it
    self.thread_ready.acquire()
    self.code_to_run_src = source
    self.code_to_run = code
    self.thread_ready.wait()  # Wait until processed in timeout interval
    self.thread_ready.release()

    return False
</t>
<t tx="ekr.20050704165326.500">def runcode(self):
    """Execute a code object.

    Multithreaded wrapper around IPython's runcode()."""

    # lock thread-protected stuff
    self.thread_ready.acquire()

    # Install sigint handler
    try:
        signal.signal(signal.SIGINT, sigint_handler)
    except SystemError:
        # This happens under Windows, which seems to have all sorts
        # of problems with signal handling.  Oh well...
        pass

    if self._kill:
        print &gt;&gt;Term.cout, 'Closing threads...',
        Term.cout.flush()
        for tokill in self.on_kill:
            tokill()
        print &gt;&gt;Term.cout, 'Done.'

    # Run pending code by calling parent class
    if self.code_to_run is not None:
        self.thread_ready.notify()
        InteractiveShell.runcode(self,self.code_to_run)
        
    # We're done with thread-protected variables
    self.thread_ready.release()
    # This MUST return true for gtk threading to work
    return True
</t>
<t tx="ekr.20050704165326.501">def kill (self):
    """Kill the thread, returning when it has been shut down."""
    self.thread_ready.acquire()
    self._kill = True
    self.thread_ready.release()
</t>
<t tx="ekr.20050704165326.502">
class MatplotlibShellBase:
    """Mixin class to provide the necessary modifications to regular IPython
    shell classes for matplotlib support.

    Given Python's MRO, this should be used as the FIRST class in the
    inheritance hierarchy, so that it overrides the relevant methods."""
	@others

    # Fix the docstring so users see the original as well
    magic_run.__doc__ = "%s\n%s" % (Magic.magic_run.__doc__,
                                    "\n        *** Modified %run for Matplotlib,"
                                    " with proper interactive handling ***")</t>
<t tx="ekr.20050704165326.503">def _matplotlib_config(self,name):
    """Return various items needed to setup the user's shell with matplotlib"""

    # Initialize matplotlib to interactive mode always
    import matplotlib
    from matplotlib import backends
    matplotlib.interactive(True)

    def use(arg):
        """IPython wrapper for matplotlib's backend switcher.

        In interactive use, we can not allow switching to a different
        interactive backend, since thread conflicts will most likely crash
        the python interpreter.  This routine does a safety check first,
        and refuses to perform a dangerous switch.  It still allows
        switching to non-interactive backends."""

        if arg in backends.interactive_bk and arg != self.mpl_backend:
            m=('invalid matplotlib backend switch.\n'
               'This script attempted to switch to the interactive '
               'backend: `%s`\n'
               'Your current choice of interactive backend is: `%s`\n\n'
               'Switching interactive matplotlib backends at runtime\n'
               'would crash the python interpreter, '
               'and IPython has blocked it.\n\n'
               'You need to either change your choice of matplotlib backend\n'
               'by editing your .matplotlibrc file, or run this script as a \n'
               'standalone file from the command line, not using IPython.\n' %
               (arg,self.mpl_backend) )
            raise RuntimeError, m
        else:
            self.mpl_use(arg)
            self.mpl_use._called = True
    
    self.matplotlib = matplotlib

    # Take control of matplotlib's error handling, which can normally
    # lock up the python interpreter when raw_input() is called
    import matplotlib.backends as backend
    backend.error_msg = error
    
    # we'll handle the mainloop, tell show not to
    import matplotlib.backends
    matplotlib.backends.show._needmain = False
    self.mpl_backend = matplotlib.rcParams['backend']

    # we also need to block switching of interactive backends by use()
    self.mpl_use = matplotlib.use
    self.mpl_use._called = False
    # overwrite the original matplotlib.use with our wrapper
    matplotlib.use = use

    # We need to detect at runtime whether show() is called by the user.
    # For this, we wrap it into a decorator which adds a 'called' flag.
    backend.draw_if_interactive = flag_calls(backend.draw_if_interactive)

    # This must be imported last in the matplotlib series, after
    # backend/interactivity choices have been made
    try:
        import matplotlib.pylab as pylab
        self.pylab = pylab
        self.pylab_name = 'pylab'
    except ImportError:
        import matplotlib.matlab as matlab            
        self.pylab = matlab
        self.pylab_name = 'matlab'

    # Build a user namespace initialized with matplotlib/matlab features.
    user_ns = {'__name__':'__main__',
               '__builtins__' : __builtin__ }

    # Be careful not to remove the final \n in the code string below, or
    # things will break badly with py22 (I think it's a python bug, 2.3 is
    # OK).
    pname = self.pylab_name # Python can't interpolate dotted var names
    exec ("import matplotlib\n"
          "import matplotlib.%(pname)s as %(pname)s\n"
          "from matplotlib.%(pname)s import *\n" % locals()) in user_ns
    
    # Build matplotlib info banner
    b="""
Welcome to pylab, a matplotlib-based Python environment.
For more information, type 'help(pylab)'.
"""
    return user_ns,b
</t>
<t tx="ekr.20050704165326.504">def mplot_exec(self,fname,*where,**kw):
    """Execute a matplotlib script.

    This is a call to execfile(), but wrapped in safeties to properly
    handle interactive rendering and backend switching."""

    #print '*** Matplotlib runner ***' # dbg
    # turn off rendering until end of script
    isInteractive = self.matplotlib.rcParams['interactive']
    self.matplotlib.interactive(False)
    self.safe_execfile(fname,*where,**kw)
    self.matplotlib.interactive(isInteractive)
    # make rendering call now, if the user tried to do it
    if self.pylab.draw_if_interactive.called:
        self.pylab.draw()
        self.pylab.draw_if_interactive.called = False
            
    # if a backend switch was performed, reverse it now
    if self.mpl_use._called:
        self.matplotlib.rcParams['backend'] = self.mpl_backend
</t>
<t tx="ekr.20050704165326.505">def magic_run(self,parameter_s=''):
    Magic.magic_run(self,parameter_s,runner=self.mplot_exec)
</t>
<t tx="ekr.20050704165326.506">

# Now we provide 2 versions of a matplotlib-aware IPython base shells, single
# and multithreaded.  Note that these are meant for internal use, the IPShell*
# classes below are the ones meant for public consumption.

class MatplotlibShell(MatplotlibShellBase,InteractiveShell):
    """Single-threaded shell with matplotlib support."""
	@others
</t>
<t tx="ekr.20050704165326.507">def __init__(self,name,usage=None,rc=Struct(opts=None,args=None),
             user_ns = None, **kw):
    user_ns,b2 = self._matplotlib_config(name)
    InteractiveShell.__init__(self,name,usage,rc,user_ns,banner2=b2,**kw)
</t>
<t tx="ekr.20050704165326.508">
class MatplotlibMTShell(MatplotlibShellBase,MTInteractiveShell):
    """Multi-threaded shell with matplotlib support."""
	@others
</t>
<t tx="ekr.20050704165326.509">def __init__(self,name,usage=None,rc=Struct(opts=None,args=None),
             user_ns = None, **kw):
    user_ns,b2 = self._matplotlib_config(name)
    MTInteractiveShell.__init__(self,name,usage,rc,user_ns,banner2=b2,**kw)
</t>
<t tx="ekr.20050704165326.510">#-----------------------------------------------------------------------------
# Utility functions for the different GUI enabled IPShell* classes.

def get_tk():
    """Tries to import Tkinter and returns a withdrawn Tkinter root
    window.  If Tkinter is already imported or not available, this
    returns None.  This function calls `hijack_tk` underneath.
    """
    if not USE_TK or sys.modules.has_key('Tkinter'):
        return None
    else:
        try:
            import Tkinter
        except ImportError:
            return None
        else:
            hijack_tk()
            r = Tkinter.Tk()
            r.withdraw()
            return r
</t>
<t tx="ekr.20050704165326.511">def hijack_tk():
    """Modifies Tkinter's mainloop with a dummy so when a module calls
    mainloop, it does not block.

    """
    def misc_mainloop(self, n=0):
        pass
    def tkinter_mainloop(n=0):
        pass
    
    import Tkinter
    Tkinter.Misc.mainloop = misc_mainloop
    Tkinter.mainloop = tkinter_mainloop
</t>
<t tx="ekr.20050704165326.512">def update_tk(tk):
    """Updates the Tkinter event loop.  This is typically called from
    the respective WX or GTK mainloops.
    """    
    if tk:
        tk.update()
</t>
<t tx="ekr.20050704165326.513">def hijack_wx():
    """Modifies wxPython's MainLoop with a dummy so user code does not
    block IPython.  The hijacked mainloop function is returned.
    """    
    def dummy_mainloop(*args, **kw):
        pass
    import wxPython
    ver = wxPython.__version__
    orig_mainloop = None
    if ver[:3] &gt;= '2.5':
        import wx
        if hasattr(wx, '_core_'): core = getattr(wx, '_core_')
        elif hasattr(wx, '_core'): core = getattr(wx, '_core')
        else: raise AttributeError('Could not find wx core module')
        orig_mainloop = core.PyApp_MainLoop
        core.PyApp_MainLoop = dummy_mainloop
    elif ver[:3] == '2.4':
        orig_mainloop = wxPython.wxc.wxPyApp_MainLoop
        wxPython.wxc.wxPyApp_MainLoop = dummy_mainloop
    else:
        warn("Unable to find either wxPython version 2.4 or &gt;= 2.5.")
    return orig_mainloop
</t>
<t tx="ekr.20050704165326.514">def hijack_gtk():
    """Modifies pyGTK's mainloop with a dummy so user code does not
    block IPython.  This function returns the original `gtk.mainloop`
    function that has been hijacked.

    NOTE: Make sure you import this *AFTER* you call
    pygtk.require(...).
    """    
    def dummy_mainloop(*args, **kw):
        pass
    import gtk
    if gtk.pygtk_version &gt;= (2,4,0): orig_mainloop = gtk.main
    else:                            orig_mainloop = gtk.mainloop
    gtk.mainloop = dummy_mainloop
    gtk.main = dummy_mainloop
    return orig_mainloop
</t>
<t tx="ekr.20050704165326.515">
#-----------------------------------------------------------------------------
# The IPShell* classes below are the ones meant to be run by external code as
# IPython instances.  Note that unless a specific threading strategy is
# desired, the factory function start() below should be used instead (it
# selects the proper threaded class).

class IPShellGTK(threading.Thread):
    """Run a gtk mainloop() in a separate thread.
    
    Python commands can be passed to the thread where they will be executed.
    This is implemented by periodically checking for passed code using a
    GTK timeout callback."""
	&lt;&lt; class IPShellGTK declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.516">TIMEOUT = 100 # Millisecond interval between timeouts.

</t>
<t tx="ekr.20050704165326.517">def __init__(self,argv=None,user_ns=None,debug=1,
             shell_class=MTInteractiveShell):

    import pygtk
    pygtk.require("2.0")
    import gtk
    
    self.gtk = gtk
    self.gtk_mainloop = hijack_gtk()

    # Allows us to use both Tk and GTK.
    self.tk = get_tk()
    
    if gtk.pygtk_version &gt;= (2,4,0): mainquit = self.gtk.main_quit
    else:                            mainquit = self.gtk.mainquit

    self.IP = make_IPython(argv,user_ns=user_ns,debug=debug,
                           shell_class=shell_class,
                           on_kill=[mainquit])
    threading.Thread.__init__(self)
</t>
<t tx="ekr.20050704165326.518">def run(self):
    self.IP.mainloop()
    self.IP.kill()
</t>
<t tx="ekr.20050704165326.519">def mainloop(self):
    
    self.gtk.timeout_add(self.TIMEOUT, self.on_timer)
    if sys.platform != 'win32':
        try:
            if self.gtk.gtk_version[0] &gt;= 2:
                self.gtk.threads_init()
        except AttributeError:
            pass
        except RuntimeError:
            error('Your pyGTK likely has not been compiled with '
                  'threading support.\n'
                  'The exception printout is below.\n'
                  'You can either rebuild pyGTK with threads, or '
                  'try using \n'
                  'matplotlib with a different backend (like Tk or WX).\n'
                  'Note that matplotlib will most likely not work in its '
                  'current state!')
            self.IP.InteractiveTB()
    self.start()
    self.gtk.threads_enter()
    self.gtk_mainloop()
    self.gtk.threads_leave()
    self.join()
</t>
<t tx="ekr.20050704165326.520">def on_timer(self):
    update_tk(self.tk)
    return self.IP.runcode()
</t>
<t tx="ekr.20050704165326.521">        

class IPShellWX(threading.Thread):
    """Run a wx mainloop() in a separate thread.
    
    Python commands can be passed to the thread where they will be executed.
    This is implemented by periodically checking for passed code using a
    GTK timeout callback."""
	&lt;&lt; class IPShellWX declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.522">TIMEOUT = 100 # Millisecond interval between timeouts.

</t>
<t tx="ekr.20050704165326.523">def __init__(self,argv=None,user_ns=None,debug=1,
             shell_class=MTInteractiveShell):

    import wxPython.wx as wx

    threading.Thread.__init__(self)
    self.wx = wx
    self.wx_mainloop = hijack_wx()

    # Allows us to use both Tk and GTK.
    self.tk = get_tk()
    
    self.IP = make_IPython(argv,user_ns=user_ns,debug=debug,
                           shell_class=shell_class,
                           on_kill=[self.wxexit])
    self.app = None
</t>
<t tx="ekr.20050704165326.524">def wxexit(self, *args):
    if self.app is not None:
        self.app.agent.timer.Stop()
        self.app.ExitMainLoop()
</t>
<t tx="ekr.20050704165326.525">def run(self):
    self.IP.mainloop()
    self.IP.kill()
</t>
<t tx="ekr.20050704165326.526">def mainloop(self):
    
    self.start()

    class TimerAgent(self.wx.wxMiniFrame):
        wx = self.wx
        IP = self.IP
        tk = self.tk
        def __init__(self, parent, interval):
            style = self.wx.wxDEFAULT_FRAME_STYLE | self.wx.wxTINY_CAPTION_HORIZ
            self.wx.wxMiniFrame.__init__(self, parent, -1, ' ', pos=(200, 200),
                                         size=(100, 100),style=style)
            self.Show(False)
            self.interval = interval
            self.timerId = self.wx.wxNewId()                                

        def StartWork(self):
            self.timer = self.wx.wxTimer(self, self.timerId)
            self.wx.EVT_TIMER(self,  self.timerId, self.OnTimer)
            self.timer.Start(self.interval)

        def OnTimer(self, event):
            update_tk(self.tk)
            self.IP.runcode()

    class App(self.wx.wxApp):
        wx = self.wx
        TIMEOUT = self.TIMEOUT
        def OnInit(self):
            'Create the main window and insert the custom frame'
            self.agent = TimerAgent(None, self.TIMEOUT)
            self.agent.Show(self.wx.false)
            self.agent.StartWork()
            return self.wx.true
    
    self.app = App(redirect=False)
    self.wx_mainloop(self.app)
    self.join()
</t>
<t tx="ekr.20050704165326.527">

class IPShellQt(threading.Thread):
    """Run a Qt event loop in a separate thread.
    
    Python commands can be passed to the thread where they will be executed.
    This is implemented by periodically checking for passed code using a
    Qt timer / slot."""
	&lt;&lt; class IPShellQt declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.528">TIMEOUT = 100 # Millisecond interval between timeouts.

</t>
<t tx="ekr.20050704165326.529">def __init__(self,argv=None,user_ns=None,debug=0,
             shell_class=MTInteractiveShell):
    
    import qt

    class newQApplication:
        def __init__( self ):
            self.QApplication = qt.QApplication
            
        def __call__( *args, **kwargs ):
            return qt.qApp

        def exec_loop( *args, **kwargs ):
            pass

        def __getattr__( self, name ):
            return getattr( self.QApplication, name )
      
    qt.QApplication = newQApplication()

    # Allows us to use both Tk and QT.
    self.tk = get_tk()

    self.IP = make_IPython(argv,user_ns=user_ns,debug=debug,
                           shell_class=shell_class,
                           on_kill=[qt.qApp.exit])
    threading.Thread.__init__(self)
</t>
<t tx="ekr.20050704165326.530">def run(self):
    self.IP.mainloop()
    self.IP.kill()
</t>
<t tx="ekr.20050704165326.531">def mainloop(self):

    import qt, sys
    if qt.QApplication.startingUp():
      a = qt.QApplication.QApplication( sys.argv )
    self.timer = qt.QTimer()
    qt.QObject.connect( self.timer, qt.SIGNAL( 'timeout()' ), self.on_timer )

    self.start()
    self.timer.start( self.TIMEOUT, True )
    while True:
        if self.IP._kill: break
        qt.qApp.exec_loop()
    self.join()
</t>
<t tx="ekr.20050704165326.532">def on_timer(self):
    update_tk(self.tk)
    result = self.IP.runcode()
    self.timer.start( self.TIMEOUT, True )
    return result
</t>
<t tx="ekr.20050704165326.533">
# A set of matplotlib public IPython shell classes, for single-threaded
# (Tk* and FLTK* backends) and multithreaded (GTK* and WX* backends) use.
class IPShellMatplotlib(IPShell):
    """Subclass IPShell with MatplotlibShell as the internal shell.

    Single-threaded class, meant for the Tk* and FLTK* backends.

    Having this on a separate class simplifies the external driver code."""
	@others
</t>
<t tx="ekr.20050704165326.534">def __init__(self,argv=None,user_ns=None,debug=1):
    IPShell.__init__(self,argv,user_ns,debug,shell_class=MatplotlibShell)
</t>
<t tx="ekr.20050704165326.535">
class IPShellMatplotlibGTK(IPShellGTK):
    """Subclass IPShellGTK with MatplotlibMTShell as the internal shell.

    Multi-threaded class, meant for the GTK* backends."""
	@others
</t>
<t tx="ekr.20050704165326.536">def __init__(self,argv=None,user_ns=None,debug=1):
    IPShellGTK.__init__(self,argv,user_ns,debug,shell_class=MatplotlibMTShell)
</t>
<t tx="ekr.20050704165326.537">
class IPShellMatplotlibWX(IPShellWX):
    """Subclass IPShellWX with MatplotlibMTShell as the internal shell.

    Multi-threaded class, meant for the WX* backends."""
	@others
</t>
<t tx="ekr.20050704165326.538">def __init__(self,argv=None,user_ns=None,debug=1):
    IPShellWX.__init__(self,argv,user_ns,debug,shell_class=MatplotlibMTShell)
</t>
<t tx="ekr.20050704165326.539">
class IPShellMatplotlibQt(IPShellQt):
    """Subclass IPShellQt with MatplotlibMTShell as the internal shell.

    Multi-threaded class, meant for the Qt* backends."""
	@others
</t>
<t tx="ekr.20050704165326.540">def __init__(self,argv=None,user_ns=None,debug=1):
    IPShellQt.__init__(self,argv,user_ns,debug,shell_class=MatplotlibMTShell)
</t>
<t tx="ekr.20050704165326.541">#-----------------------------------------------------------------------------
# Factory functions to actually start the proper thread-aware shell

def _matplotlib_shell_class():
    """Factory function to handle shell class selection for matplotlib.

    The proper shell class to use depends on the matplotlib backend, since
    each backend requires a different threading strategy."""

    try:
        import matplotlib
    except ImportError:
        error('matplotlib could NOT be imported!  Starting normal IPython.')
        sh_class = IPShell
    else:
        backend = matplotlib.rcParams['backend']
        if backend.startswith('GTK'):
            sh_class = IPShellMatplotlibGTK
        elif backend.startswith('WX'):
            sh_class = IPShellMatplotlibWX
        elif backend.startswith('Qt'):
            sh_class = IPShellMatplotlibQt
        else:
            sh_class = IPShellMatplotlib
    #print 'Using %s with the %s backend.' % (sh_class,backend) # dbg
    return sh_class
</t>
<t tx="ekr.20050704165326.542"># This is the one which should be called by external code.
def start():
    """Return a running shell instance, dealing with threading options.

    This is a factory function which will instantiate the proper IPython shell
    based on the user's threading choice.  Such a selector is needed because
    different GUI toolkits require different thread handling details."""

    global USE_TK
    # Crude sys.argv hack to extract the threading options.
    if len(sys.argv) &gt; 1:
        if len(sys.argv) &gt; 2:
            arg2 = sys.argv[2]
            if arg2.endswith('-tk'):
                USE_TK = True
        arg1 = sys.argv[1]
        if arg1.endswith('-gthread'):
            shell = IPShellGTK
        elif arg1.endswith( '-qthread' ):
            shell = IPShellQt
        elif arg1.endswith('-wthread'):
            shell = IPShellWX
        elif arg1.endswith('-pylab'):
            shell = _matplotlib_shell_class()
        else:
            shell = IPShell
    else:
        shell = IPShell
    return shell()
</t>
<t tx="ekr.20050704165326.543">
@language python
&lt;&lt; Struct declarations &gt;&gt;
@others
# end class Struct

</t>
<t tx="ekr.20050704165326.544"># -*- coding: utf-8 -*-
"""Mimic C structs with lots of extra functionality.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;' % Release.authors['Fernando']
__license__ = Release.license

__all__ = ['Struct']

import types
from IPython.genutils import list2dict2

</t>
<t tx="ekr.20050704165326.545">class Struct:
    """Class to mimic C structs but also provide convenient dictionary-like
    functionality.

    Instances can be initialized with a dictionary, a list of key=value pairs
    or both. If both are present, the dictionary must come first.

    Because Python classes provide direct assignment to their members, it's
    easy to overwrite normal methods (S.copy = 1 would destroy access to
    S.copy()). For this reason, all builtin method names are protected and
    can't be assigned to. An attempt to do s.copy=1 or s['copy']=1 will raise
    a KeyError exception. If you really want to, you can bypass this
    protection by directly assigning to __dict__: s.__dict__['copy']=1 will
    still work. Doing this will break functionality, though. As in most of
    Python, namespace protection is weakly enforced, so feel free to shoot
    yourself if you really want to.

    Note that this class uses more memory and is *much* slower than a regular
    dictionary, so be careful in situations where memory or performance are
    critical. But for day to day use it should behave fine. It is particularly
    convenient for storing configuration data in programs.

    +,+=,- and -= are implemented. +/+= do merges (non-destructive updates),
    -/-= remove keys from the original. See the method descripitions.

    This class allows a quick access syntax: both s.key and s['key'] are
    valid.  This syntax has a limitation: each 'key' has to be explicitly
    accessed by its original name. The normal s.key syntax doesn't provide
    access to the keys via variables whose values evaluate to the desired
    keys. An example should clarify this:

    Define a dictionary and initialize both with dict and k=v pairs:
    &gt;&gt;&gt; d={'a':1,'b':2}
    &gt;&gt;&gt; s=Struct(d,hi=10,ho=20)
    The return of __repr__ can be used to create a new instance:
    &gt;&gt;&gt; s
    Struct({'ho': 20, 'b': 2, 'hi': 10, 'a': 1})
    __str__ (called by print) shows it's not quite a regular dictionary:
    &gt;&gt;&gt; print s
    Struct {a: 1, b: 2, hi: 10, ho: 20}
    Access by explicitly named key with dot notation:
    &gt;&gt;&gt; s.a
    1
    Or like a dictionary:
    &gt;&gt;&gt; s['a']
    1
    If you want a variable to hold the key value, only dictionary access works:
    &gt;&gt;&gt; key='hi'
    &gt;&gt;&gt; s.key
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
    AttributeError: Struct instance has no attribute 'key'
    &gt;&gt;&gt; s[key]
    10

    Another limitation of the s.key syntax (and Struct(key=val)
    initialization): keys can't be numbers. But numeric keys can be used and
    accessed using the dictionary syntax. Again, an example:

    This doesn't work:
    &gt;&gt;&gt; s=Struct(4='hi')
    SyntaxError: keyword can't be an expression
    But this does:
    &gt;&gt;&gt; s=Struct()
    &gt;&gt;&gt; s[4]='hi'
    &gt;&gt;&gt; s
    Struct({4: 'hi'})
    &gt;&gt;&gt; s[4]
    'hi'
    """
	&lt;&lt; class Struct declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704165326.546"># Attributes to which __setitem__ and __setattr__ will block access.
# Note: much of this will be moot in Python 2.2 and will be done in a much
# cleaner way.
__protected = ('copy dict dictcopy get has_attr has_key items keys '
               'merge popitem setdefault update values '
               '__make_dict __dict_invert ').split()

</t>
<t tx="ekr.20050704165326.547">def __init__(self,dict=None,**kw):
    """Initialize with a dictionary, another Struct, or by giving
    explicitly the list of attributes.

    Both can be used, but the dictionary must come first:
    Struct(dict), Struct(k1=v1,k2=v2) or Struct(dict,k1=v1,k2=v2).
    """
    if dict is None:
        dict = {}
    if isinstance(dict,Struct):
        dict = dict.dict()
    elif dict and  type(dict) is not types.DictType:
        raise TypeError,\
              'Initialize with a dictionary or key=val pairs.'
    dict.update(kw)
    # do the updating by hand to guarantee that we go through the
    # safety-checked __setitem__
    for k,v in dict.items():
        self[k] = v
</t>
<t tx="ekr.20050704165326.548">def __setitem__(self,key,value):
    """Used when struct[key] = val calls are made."""
    if key in Struct.__protected:
        raise KeyError,'Key '+`key`+' is a protected key of class Struct.'
    self.__dict__[key] = value
</t>
<t tx="ekr.20050704165326.549">def __setattr__(self, key, value):
    """Used when struct.key = val calls are made."""
    self.__setitem__(key,value)
</t>
<t tx="ekr.20050704165326.550">def __str__(self):
    """Gets called by print."""
    
    return 'Struct('+str(self.__dict__)+')'
</t>
<t tx="ekr.20050704165326.551">def __repr__(self):
    """Gets called by repr.
    
    A Struct can be recreated with S_new=eval(repr(S_old))."""
    return 'Struct('+str(self.__dict__)+')'
</t>
<t tx="ekr.20050704165326.552">def __getitem__(self,key):
    """Allows struct[key] access."""
    return self.__dict__[key]
</t>
<t tx="ekr.20050704165326.553">def __contains__(self,key):
    """Allows use of the 'in' operator."""
    return self.__dict__.has_key(key)
</t>
<t tx="ekr.20050704165326.554">def __iadd__(self,other):
    """S += S2 is a shorthand for S.merge(S2)."""
    self.merge(other)
    return self
</t>
<t tx="ekr.20050704165326.555">def __add__(self,other):
    """S + S2 -&gt; New Struct made form S and S.merge(S2)"""
    Sout = self.copy()
    Sout.merge(other)
    return Sout
</t>
<t tx="ekr.20050704165326.556">def __sub__(self,other):
    """Return S1-S2, where all keys in S2 have been deleted (if present)
    from S1."""
    Sout = self.copy()
    Sout -= other
    return Sout
</t>
<t tx="ekr.20050704165326.557">def __isub__(self,other):
    """Do in place S = S - S2, meaning all keys in S2 have been deleted
    (if present) from S1."""

    for k in other.keys():
        if self.has_key(k):
            del self.__dict__[k]
</t>
<t tx="ekr.20050704165326.558">def __make_dict(self,__loc_data__,**kw):
    "Helper function for update and merge. Return a dict from data."

    if __loc_data__ == None:
        dict = {}
    elif type(__loc_data__) is types.DictType:
        dict = __loc_data__
    elif isinstance(__loc_data__,Struct):
        dict = __loc_data__.__dict__
    else:
        raise TypeError, 'Update with a dict, a Struct or key=val pairs.'
    if kw:
        dict.update(kw)
    return dict
</t>
<t tx="ekr.20050704165326.559">def __dict_invert(self,dict):
    """Helper function for merge. Takes a dictionary whose values are
    lists and returns a dict. with the elements of each list as keys and
    the original keys as values."""

    outdict = {}
    for k,lst in dict.items():
        if type(lst) is types.StringType:
            lst = lst.split()
        for entry in lst:
            outdict[entry] = k
    return outdict
</t>
<t tx="ekr.20050704165326.560">def clear(self):
    """Clear all attributes."""
    self.__dict__.clear()
</t>
<t tx="ekr.20050704165326.561">def copy(self):
    """Return a (shallow) copy of a Struct."""
    return Struct(self.__dict__.copy())
</t>
<t tx="ekr.20050704165326.562">def dict(self):
    """Return the Struct's dictionary."""
    return self.__dict__
</t>
<t tx="ekr.20050704165326.563">def dictcopy(self):
    """Return a (shallow) copy of the Struct's dictionary."""
    return self.__dict__.copy()
</t>
<t tx="ekr.20050704165326.564">def popitem(self):
    """S.popitem() -&gt; (k, v), remove and return some (key, value) pair as
    a 2-tuple; but raise KeyError if S is empty."""
    return self.__dict__.popitem()
</t>
<t tx="ekr.20050704165326.565">def update(self,__loc_data__=None,**kw):
    """Update (merge) with data from another Struct or from a dictionary.
    Optionally, one or more key=value pairs can be given at the end for
    direct update."""

    # The funny name __loc_data__ is to prevent a common variable name which
    # could be a fieled of a Struct to collide with this parameter. The problem
    # would arise if the function is called with a keyword with this same name
    # that a user means to add as a Struct field.
    newdict = Struct.__make_dict(self,__loc_data__,**kw)
    for k,v in newdict.items():
        self[k] = v
</t>
<t tx="ekr.20050704165326.566">def merge(self,__loc_data__=None,__conflict_solve=None,**kw):
    """S.merge(data,conflict,k=v1,k=v2,...) -&gt; merge data and k=v into S.

    This is similar to update(), but much more flexible.  First, a dict is
    made from data+key=value pairs. When merging this dict with the Struct
    S, the optional dictionary 'conflict' is used to decide what to do.

    If conflict is not given, the default behavior is to preserve any keys
    with their current value (the opposite of the update method's
    behavior).

    conflict is a dictionary of binary functions which will be used to
    solve key conflicts. It must have the following structure:

      conflict == { fn1 : [Skey1,Skey2,...], fn2 : [Skey3], etc }

    Values must be lists or whitespace separated strings which are
    automatically converted to lists of strings by calling string.split().

    Each key of conflict is a function which defines a policy for
    resolving conflicts when merging with the input data. Each fn must be
    a binary function which returns the desired outcome for a key
    conflict. These functions will be called as fn(old,new).

    An example is probably in order. Suppose you are merging the struct S
    with a dict D and the following conflict policy dict:

        S.merge(D,{fn1:['a','b',4], fn2:'key_c key_d'})

    If the key 'a' is found in both S and D, the merge method will call:

        S['a'] = fn1(S['a'],D['a'])

    As a convenience, merge() provides five (the most commonly needed)
    pre-defined policies: preserve, update, add, add_flip and add_s. The
    easiest explanation is their implementation:

      preserve = lambda old,new: old
      update   = lambda old,new: new
      add      = lambda old,new: old + new
      add_flip = lambda old,new: new + old  # note change of order!
      add_s    = lambda old,new: old + ' ' + new  # only works for strings!

    You can use those four words (as strings) as keys in conflict instead
    of defining them as functions, and the merge method will substitute
    the appropriate functions for you. That is, the call

      S.merge(D,{'preserve':'a b c','add':[4,5,'d'],my_function:[6]})

    will automatically substitute the functions preserve and add for the
    names 'preserve' and 'add' before making any function calls.

    For more complicated conflict resolution policies, you still need to
    construct your own functions. """

    data_dict = Struct.__make_dict(self,__loc_data__,**kw)

    # policies for conflict resolution: two argument functions which return
    # the value that will go in the new struct
    preserve = lambda old,new: old
    update   = lambda old,new: new
    add      = lambda old,new: old + new
    add_flip = lambda old,new: new + old  # note change of order!
    add_s    = lambda old,new: old + ' ' + new

    # default policy is to keep current keys when there's a conflict
    conflict_solve = list2dict2(self.keys(),default = preserve)

    # the conflict_solve dictionary is given by the user 'inverted': we
    # need a name-function mapping, it comes as a function -&gt; names
    # dict. Make a local copy (b/c we'll make changes), replace user
    # strings for the three builtin policies and invert it.
    if __conflict_solve:
        inv_conflict_solve_user = __conflict_solve.copy()
        for name, func in [('preserve',preserve), ('update',update),
                           ('add',add), ('add_flip',add_flip), ('add_s',add_s)]:
            if name in inv_conflict_solve_user.keys():
                inv_conflict_solve_user[func] = inv_conflict_solve_user[name]
                del inv_conflict_solve_user[name]
        conflict_solve.update(Struct.__dict_invert(self,inv_conflict_solve_user))
    #print 'merge. conflict_solve: '; pprint(conflict_solve) # dbg
    # after Python 2.2, use iterators: for key in data_dict will then work
    #print '*'*50,'in merger. conflict_solver:';  pprint(conflict_solve)
    for key in data_dict.keys():
        if key not in self:
            self[key] = data_dict[key]
        else:
            self[key] = conflict_solve[key](self[key],data_dict[key])
</t>
<t tx="ekr.20050704165326.567">def has_key(self,key):
    """Like has_key() dictionary method."""
    return self.__dict__.has_key(key)
</t>
<t tx="ekr.20050704165326.568">def hasattr(self,key):
    """hasattr function available as a method.

    Implemented like has_key, to make sure that all available keys in the
    internal dictionary of the Struct appear also as attributes (even
    numeric keys)."""
    return self.__dict__.has_key(key)
</t>
<t tx="ekr.20050704165326.569">def items(self):
    """Return the items in the Struct's dictionary, in the same format
    as a call to {}.items()."""
    return self.__dict__.items()
</t>
<t tx="ekr.20050704165326.570">def keys(self):
    """Return the keys in the Struct's dictionary, in the same format
    as a call to {}.keys()."""
    return self.__dict__.keys()
</t>
<t tx="ekr.20050704165326.571">def values(self,keys=None):
    """Return the values in the Struct's dictionary, in the same format
    as a call to {}.values().

    Can be called with an optional argument keys, which must be a list or
    tuple of keys. In this case it returns only the values corresponding
    to those keys (allowing a form of 'slicing' for Structs)."""
    if not keys:
        return self.__dict__.values()
    else:
        ret=[]
        for k in keys:
            ret.append(self[k])
        return ret
</t>
<t tx="ekr.20050704165326.572">def get(self,attr,val=None):
    """S.get(k[,d]) -&gt; S[k] if S.has_key(k), else d.  d defaults to None."""
    try:
        return self[attr]
    except KeyError:
        return val
</t>
<t tx="ekr.20050704165326.573">def setdefault(self,attr,val=None):
    """S.setdefault(k[,d]) -&gt; S.get(k,d), also set S[k]=d if not S.has_key(k)"""
    if not self.has_key(attr):
        self[attr] = val
    return self.get(attr,val)
</t>
<t tx="ekr.20050704165326.574">
@language python
&lt;&lt; ultraTB declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704165326.575"># -*- coding: utf-8 -*-
"""
ultraTB.py -- Spice up your tracebacks!

* ColorTB
I've always found it a bit hard to visually parse tracebacks in Python.  The
ColorTB class is a solution to that problem.  It colors the different parts of a
traceback in a manner similar to what you would expect from a syntax-highlighting
text editor.

Installation instructions for ColorTB:
    import sys,ultraTB
    sys.excepthook = ultraTB.ColorTB()

* VerboseTB  
I've also included a port of Ka-Ping Yee's "cgitb.py" that produces all kinds
of useful info when a traceback occurs.  Ping originally had it spit out HTML
and intended it for CGI programmers, but why should they have all the fun?  I
altered it to spit out colored text to the terminal.  It's a bit overwhelming,
but kind of neat, and maybe useful for long-running programs that you believe
are bug-free.  If a crash *does* occur in that type of program you want details.
Give it a shot--you'll love it or you'll hate it.

Note:

  The Verbose mode prints the variables currently visible where the exception
  happened (shortening their strings if too long). This can potentially be
  very slow, if you happen to have a huge data structure whose string
  representation is complex to compute. Your computer may appear to freeze for
  a while with cpu usage at 100%. If this occurs, you can cancel the traceback
  with Ctrl-C (maybe hitting it more than once).

  If you encounter this kind of situation often, you may want to use the
  Verbose_novars mode instead of the regular Verbose, which avoids formatting
  variables (but otherwise includes the information and context given by
  Verbose).
  

Installation instructions for ColorTB:
    import sys,ultraTB
    sys.excepthook = ultraTB.VerboseTB()

Note:  Much of the code in this module was lifted verbatim from the standard
library module 'traceback.py' and Ka-Ping Yee's 'cgitb.py'.

* Color schemes
The colors are defined in the class TBTools through the use of the
ColorSchemeTable class. Currently the following exist:

  - NoColor: allows all of this module to be used in any terminal (the color
  escapes are just dummy blank strings).

  - Linux: is meant to look good in a terminal like the Linux console (black
  or very dark background).

  - LightBG: similar to Linux but swaps dark/light colors to be more readable
  in light background terminals.

You can implement other color schemes easily, the syntax is fairly
self-explanatory. Please send back new schemes you develop to the author for
possible inclusion in future releases.

$Id$"""

#*****************************************************************************
#       Copyright (C) 2001 Nathaniel Gray &lt;n8gray@caltech.edu&gt;
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************

from IPython import Release
__author__  = '%s &lt;%s&gt;\n%s &lt;%s&gt;' % (Release.authors['Nathan']+
                                    Release.authors['Fernando'])
__license__ = Release.license

# Required modules
import sys, os, traceback, types, string, time
import keyword, tokenize, linecache, inspect, pydoc
from UserDict import UserDict

# IPython's own modules
# Modified pdb which doesn't damage IPython's readline handling
from IPython import Debugger

from IPython.Struct import Struct
from IPython.ColorANSI import *
from IPython.genutils import Term,uniq_stable,error,info

#---------------------------------------------------------------------------
# Code begins

</t>
<t tx="ekr.20050704165326.576">def inspect_error():
    """Print a message about internal inspect errors.

    These are unfortunately quite common."""
    
    error('Internal Python error in the inspect module.\n'
          'Below is the traceback from this internal error.\n')
</t>
<t tx="ekr.20050704165326.577">    
class TBTools:
    """Basic tools used by all traceback printer classes."""
	@others
</t>
<t tx="ekr.20050704165326.578">def __init__(self,color_scheme = 'NoColor',call_pdb=0):
    # Whether to call the interactive pdb debugger after printing
    # tracebacks or not
    self.call_pdb = call_pdb
    if call_pdb:
        self.pdb = Debugger.Pdb()
    else:
        self.pdb = None

    # Create color table
    self.ColorSchemeTable = ColorSchemeTable()
    
    # Populate it with color schemes
    C = TermColors # shorthand and local lookup
    self.ColorSchemeTable.add_scheme(ColorScheme(
        'NoColor',
        # The color to be used for the top line
        topline = C.NoColor,

        # The colors to be used in the traceback
        filename = C.NoColor,
        lineno = C.NoColor,
        name = C.NoColor,
        vName = C.NoColor,
        val = C.NoColor,
        em = C.NoColor,

        # Emphasized colors for the last frame of the traceback
        normalEm = C.NoColor,
        filenameEm = C.NoColor,
        linenoEm = C.NoColor,
        nameEm = C.NoColor,
        valEm = C.NoColor,

        # Colors for printing the exception
        excName = C.NoColor,
        line = C.NoColor,
        caret = C.NoColor,
        Normal = C.NoColor
        ))

    # make some schemes as instances so we can copy them for modification easily:
    self.ColorSchemeTable.add_scheme(ColorScheme(
        'Linux',
        # The color to be used for the top line
        topline = C.LightRed,

        # The colors to be used in the traceback
        filename = C.Green,
        lineno = C.Green,
        name = C.Purple,
        vName = C.Cyan,
        val = C.Green,
        em = C.LightCyan,

        # Emphasized colors for the last frame of the traceback
        normalEm = C.LightCyan,
        filenameEm = C.LightGreen,
        linenoEm = C.LightGreen,
        nameEm = C.LightPurple,
        valEm = C.LightBlue,

        # Colors for printing the exception
        excName = C.LightRed,
        line = C.Yellow,
        caret = C.White,
        Normal = C.Normal
        ))

    # For light backgrounds, swap dark/light colors
    self.ColorSchemeTable.add_scheme(ColorScheme(
        'LightBG',
        # The color to be used for the top line
        topline = C.Red,

        # The colors to be used in the traceback
        filename = C.LightGreen,
        lineno = C.LightGreen,
        name = C.LightPurple,
        vName = C.Cyan,
        val = C.LightGreen,
        em = C.Cyan,

        # Emphasized colors for the last frame of the traceback
        normalEm = C.Cyan,
        filenameEm = C.Green,
        linenoEm = C.Green,
        nameEm = C.Purple,
        valEm = C.Blue,

        # Colors for printing the exception
        excName = C.Red,
        #line = C.Brown,  # brown often is displayed as yellow
        line = C.Red,
        caret = C.Normal,
        Normal = C.Normal
        ))

    self.set_colors(color_scheme)
    self.old_scheme = color_scheme  # save initial value for toggles
</t>
<t tx="ekr.20050704165326.579">def set_colors(self,*args,**kw):
    """Shorthand access to the color table scheme selector method."""
    
    self.ColorSchemeTable.set_active_scheme(*args,**kw)
    # for convenience, set Colors to the active scheme
    self.Colors = self.ColorSchemeTable.active_colors
</t>
<t tx="ekr.20050704165326.580">def color_toggle(self):
    """Toggle between the currently active color scheme and NoColor."""
    
    if self.ColorSchemeTable.active_scheme_name == 'NoColor':
        self.ColorSchemeTable.set_active_scheme(self.old_scheme)
        self.Colors = self.ColorSchemeTable.active_colors
    else:
        self.old_scheme = self.ColorSchemeTable.active_scheme_name
        self.ColorSchemeTable.set_active_scheme('NoColor')
        self.Colors = self.ColorSchemeTable.active_colors
</t>
<t tx="ekr.20050704165326.581">
#---------------------------------------------------------------------------
class ListTB(TBTools):
    """Print traceback information from a traceback list, with optional color.
        
    Calling: requires 3 arguments:
      (etype, evalue, elist)
    as would be obtained by:
      etype, evalue, tb = sys.exc_info()
      if tb:
        elist = traceback.extract_tb(tb)
      else:
        elist = None

    It can thus be used by programs which need to process the traceback before
    printing (such as console replacements based on the code module from the
    standard library).

    Because they are meant to be called without a full traceback (only a
    list), instances of this class can't call the interactive pdb debugger."""
	@others
</t>
<t tx="ekr.20050704165326.582">def __init__(self,color_scheme = 'NoColor'):
    TBTools.__init__(self,color_scheme = color_scheme,call_pdb=0)
</t>
<t tx="ekr.20050704165326.583">def __call__(self, etype, value, elist):
    print &gt;&gt; Term.cerr, self.text(etype,value,elist)
</t>
<t tx="ekr.20050704165326.584">def text(self,etype, value, elist,context=5):
    """Return a color formatted string with the traceback info."""

    Colors = self.Colors
    out_string = ['%s%s%s\n' % (Colors.topline,'-'*60,Colors.Normal)]
    if elist:
        out_string.append('Traceback %s(most recent call last)%s:' % \
                            (Colors.normalEm, Colors.Normal) + '\n')
        out_string.extend(self._format_list(elist))
    lines = self._format_exception_only(etype, value)
    for line in lines[:-1]:
        out_string.append(" "+line)
    out_string.append(lines[-1])
    return ''.join(out_string)
</t>
<t tx="ekr.20050704165326.585">def _format_list(self, extracted_list):
    """Format a list of traceback entry tuples for printing.

    Given a list of tuples as returned by extract_tb() or
    extract_stack(), return a list of strings ready for printing.
    Each string in the resulting list corresponds to the item with the
    same index in the argument list.  Each string ends in a newline;
    the strings may contain internal newlines as well, for those items
    whose source text line is not None.
    
    Lifted almost verbatim from traceback.py
    """

    Colors = self.Colors
    list = []
    for filename, lineno, name, line in extracted_list[:-1]:
        item = '  File %s"%s"%s, line %s%d%s, in %s%s%s\n' % \
                (Colors.filename, filename, Colors.Normal, 
                 Colors.lineno, lineno, Colors.Normal,
                 Colors.name, name, Colors.Normal)
        if line:
            item = item + '    %s\n' % line.strip()
        list.append(item)
    # Emphasize the last entry
    filename, lineno, name, line = extracted_list[-1]
    item = '%s  File %s"%s"%s, line %s%d%s, in %s%s%s%s\n' % \
            (Colors.normalEm,
             Colors.filenameEm, filename, Colors.normalEm,
             Colors.linenoEm, lineno, Colors.normalEm,
             Colors.nameEm, name, Colors.normalEm,
             Colors.Normal)
    if line:
        item = item + '%s    %s%s\n' % (Colors.line, line.strip(),
                                        Colors.Normal)
    list.append(item)
    return list
</t>
<t tx="ekr.20050704165326.586">def _format_exception_only(self, etype, value):
    """Format the exception part of a traceback.

    The arguments are the exception type and value such as given by
    sys.last_type and sys.last_value. The return value is a list of
    strings, each ending in a newline.  Normally, the list contains a
    single string; however, for SyntaxError exceptions, it contains
    several lines that (when printed) display detailed information
    about where the syntax error occurred.  The message indicating
    which exception occurred is the always last string in the list.
    
    Also lifted nearly verbatim from traceback.py
    """
    
    Colors = self.Colors
    list = []
    if type(etype) == types.ClassType:
        stype = Colors.excName + etype.__name__ + Colors.Normal
    else:
        stype = etype  # String exceptions don't get special coloring
    if value is None:
        list.append( str(stype) + '\n')
    else:
        if etype is SyntaxError:
            try:
                msg, (filename, lineno, offset, line) = value
            except:
                pass
            else:
                #print 'filename is',filename  # dbg
                if not filename: filename = "&lt;string&gt;"
                list.append('%s  File %s"%s"%s, line %s%d%s\n' % \
                        (Colors.normalEm,
                         Colors.filenameEm, filename, Colors.normalEm,
                         Colors.linenoEm, lineno, Colors.Normal  ))
                if line is not None:
                    i = 0
                    while i &lt; len(line) and line[i].isspace():
                        i = i+1
                    list.append('%s    %s%s\n' % (Colors.line,
                                                  line.strip(), 
                                                  Colors.Normal))
                    if offset is not None:
                        s = '    '
                        for c in line[i:offset-1]:
                            if c.isspace():
                                s = s + c
                            else:
                                s = s + ' '
                        list.append('%s%s^%s\n' % (Colors.caret, s,
                                                   Colors.Normal) )
                    value = msg
        s = self._some_str(value)
        if s:
            list.append('%s%s:%s %s\n' % (str(stype), Colors.excName,
                                          Colors.Normal, s))
        else:
            list.append('%s\n' % str(stype))
    return list
</t>
<t tx="ekr.20050704165326.587">def _some_str(self, value):
    # Lifted from traceback.py
    try:
        return str(value)
    except:
        return '&lt;unprintable %s object&gt;' % type(value).__name__
</t>
<t tx="ekr.20050704165326.588">
#----------------------------------------------------------------------------
class VerboseTB(TBTools):
    """A port of Ka-Ping Yee's cgitb.py module that outputs color text instead
    of HTML.  Requires inspect and pydoc.  Crazy, man.

    Modified version which optionally strips the topmost entries from the
    traceback, to be used with alternate interpreters (because their own code
    would appear in the traceback)."""
	@others
</t>
<t tx="ekr.20050704165326.589">def __init__(self,color_scheme = 'Linux',tb_offset=0,long_header=0,
             call_pdb = 0, include_vars=1):
    """Specify traceback offset, headers and color scheme.

    Define how many frames to drop from the tracebacks. Calling it with
    tb_offset=1 allows use of this handler in interpreters which will have
    their own code at the top of the traceback (VerboseTB will first
    remove that frame before printing the traceback info)."""
    TBTools.__init__(self,color_scheme=color_scheme,call_pdb=call_pdb)
    self.tb_offset = tb_offset
    self.long_header = long_header
    self.include_vars = include_vars
</t>
<t tx="ekr.20050704165326.590">def text(self, etype, evalue, etb, context=5):
    """Return a nice text document describing the traceback."""

    # some locals
    Colors        = self.Colors   # just a shorthand + quicker name lookup
    ColorsNormal  = Colors.Normal  # used a lot
    indent_size   = 8  # we need some space to put line numbers before
    indent        = ' '*indent_size
    numbers_width = indent_size - 1 # leave space between numbers &amp; code
    text_repr     = pydoc.text.repr
    exc           = '%s%s%s' % (Colors.excName, str(etype), ColorsNormal)
    em_normal     = '%s\n%s%s' % (Colors.valEm, indent,ColorsNormal)
    undefined     = '%sundefined%s' % (Colors.em, ColorsNormal)

    # some internal-use functions
    def eqrepr(value, repr=text_repr): return '=%s' % repr(value)
    def nullrepr(value, repr=text_repr): return ''

    # meat of the code begins
    if type(etype) is types.ClassType:
        etype = etype.__name__

    if self.long_header:
        # Header with the exception type, python version, and date
        pyver = 'Python ' + string.split(sys.version)[0] + ': ' + sys.executable
        date = time.ctime(time.time())
        
        head = '%s%s%s\n%s%s%s\n%s' % (Colors.topline, '-'*75, ColorsNormal,
                                       exc, ' '*(75-len(str(etype))-len(pyver)),
                                       pyver, string.rjust(date, 75) )
        head += "\nA problem occured executing Python code.  Here is the sequence of function"\
                "\ncalls leading up to the error, with the most recent (innermost) call last."
    else:
        # Simplified header
        head = '%s%s%s\n%s%s' % (Colors.topline, '-'*75, ColorsNormal,exc,
                                 string.rjust('Traceback (most recent call last)',
                                              75 - len(str(etype)) ) )
    frames = []
    # Flush cache before calling inspect.  This helps alleviate some of the
    # problems with python 2.3's inspect.py.
    linecache.checkcache()
    # Drop topmost frames if requested
    try:
        records = inspect.getinnerframes(etb, context)[self.tb_offset:]
    except:

        # FIXME: I've been getting many crash reports from python 2.3
        # users, traceable to inspect.py.  If I can find a small test-case
        # to reproduce this, I should either write a better workaround or
        # file a bug report against inspect (if that's the real problem).
        # So far, I haven't been able to find an isolated example to
        # reproduce the problem.
        inspect_error()
        traceback.print_exc(file=Term.cerr)
        info('\nUnfortunately, your original traceback can not be constructed.\n')
        return ''

    # build some color string templates outside these nested loops
    tpl_link       = '%s%%s%s' % (Colors.filenameEm,ColorsNormal)
    tpl_call       = 'in %s%%s%s%%s%s' % (Colors.vName, Colors.valEm,
                                          ColorsNormal)
    tpl_call_fail  = 'in %s%%s%s(***failed resolving arguments***)%s' % \
                     (Colors.vName, Colors.valEm, ColorsNormal)
    tpl_local_var  = '%s%%s%s' % (Colors.vName, ColorsNormal)
    tpl_global_var = '%sglobal%s %s%%s%s' % (Colors.em, ColorsNormal,
                                             Colors.vName, ColorsNormal)
    tpl_name_val   = '%%s %s= %%s%s' % (Colors.valEm, ColorsNormal)
    tpl_line       = '%s%%s%s %%s' % (Colors.lineno, ColorsNormal)
    tpl_line_em    = '%s%%s%s %%s%s' % (Colors.linenoEm,Colors.line,
                                        ColorsNormal)

    # now, loop over all records printing context and info
    abspath = os.path.abspath
    for frame, file, lnum, func, lines, index in records:
        #print '*** record:',file,lnum,func,lines,index  # dbg
        try:
            file = file and abspath(file) or '?'
        except OSError:
            # if file is '&lt;console&gt;' or something not in the filesystem,
            # the abspath call will throw an OSError.  Just ignore it and
            # keep the original file string.
            pass
        link = tpl_link % file
        try:
            args, varargs, varkw, locals = inspect.getargvalues(frame)
        except:
            # This can happen due to a bug in python2.3.  We should be
            # able to remove this try/except when 2.4 becomes a
            # requirement.  Bug details at http://python.org/sf/1005466
            inspect_error()
            traceback.print_exc(file=Term.cerr)
            info("\nIPython's exception reporting continues...\n")
            
        if func == '?':
            call = ''
        else:
            # Decide whether to include variable details or not
            var_repr = self.include_vars and eqrepr or nullrepr
            try:
                call = tpl_call % (func,inspect.formatargvalues(args,
                                            varargs, varkw,
                                            locals,formatvalue=var_repr))
            except KeyError:
                # Very odd crash from inspect.formatargvalues().  The
                # scenario under which it appeared was a call to
                # view(array,scale) in NumTut.view.view(), where scale had
                # been defined as a scalar (it should be a tuple). Somehow
                # inspect messes up resolving the argument list of view()
                # and barfs out. At some point I should dig into this one
                # and file a bug report about it.
                inspect_error()
                traceback.print_exc(file=Term.cerr)
                info("\nIPython's exception reporting continues...\n")
                call = tpl_call_fail % func

        # Initialize a list of names on the current line, which the
        # tokenizer below will populate.
        names = []

        def tokeneater(token_type, token, start, end, line):
            """Stateful tokeneater which builds dotted names.

            The list of names it appends to (from the enclosing scope) can
            contain repeated composite names.  This is unavoidable, since
            there is no way to disambguate partial dotted structures until
            the full list is known.  The caller is responsible for pruning
            the final list of duplicates before using it."""
            
            # build composite names
            if token == '.':
                try:
                    names[-1] += '.'
                    # store state so the next token is added for x.y.z names
                    tokeneater.name_cont = True
                    return
                except IndexError:
                    pass
            if token_type == tokenize.NAME and token not in keyword.kwlist:
                if tokeneater.name_cont:
                    # Dotted names
                    names[-1] += token
                    tokeneater.name_cont = False
                else:
                    # Regular new names.  We append everything, the caller
                    # will be responsible for pruning the list later.  It's
                    # very tricky to try to prune as we go, b/c composite
                    # names can fool us.  The pruning at the end is easy
                    # to do (or the caller can print a list with repeated
                    # names if so desired.
                    names.append(token)
            elif token_type == tokenize.NEWLINE:
                raise IndexError
        # we need to store a bit of state in the tokenizer to build
        # dotted names
        tokeneater.name_cont = False

        def linereader(file=file, lnum=[lnum], getline=linecache.getline):
            line = getline(file, lnum[0])
            lnum[0] += 1
            return line

        # Build the list of names on this line of code where the exception
        # occurred.
        try:
            # This builds the names list in-place by capturing it from the
            # enclosing scope.
            tokenize.tokenize(linereader, tokeneater)
        except IndexError:
            # signals exit of tokenizer
            pass
        except tokenize.TokenError,msg:
            _m = ("An unexpected error occurred while tokenizing input\n"
                  "The following traceback may be corrupted or invalid\n"
                  "The error message is: %s\n" % msg)
            error(_m)
        
        # prune names list of duplicates, but keep the right order
        unique_names = uniq_stable(names)

        # Start loop over vars
        lvals = []
        if self.include_vars:
            for name_full in unique_names:
                name_base = name_full.split('.',1)[0]
                if name_base in frame.f_code.co_varnames:
                    if locals.has_key(name_base):
                        try:
                            value = repr(eval(name_full,locals))
                        except:
                            value = undefined
                    else:
                        value = undefined
                    name = tpl_local_var % name_full
                else:
                    if frame.f_globals.has_key(name_base):
                        try:
                            value = repr(eval(name_full,frame.f_globals))
                        except:
                            value = undefined
                    else:
                        value = undefined
                    name = tpl_global_var % name_full
                lvals.append(tpl_name_val % (name,value))
        if lvals:
            lvals = '%s%s' % (indent,em_normal.join(lvals))
        else:
            lvals = ''

        level = '%s %s\n' % (link,call)
        excerpt = []
        if index is not None:
            i = lnum - index
            for line in lines:
                if i == lnum:
                    # This is the line with the error
                    pad = numbers_width - len(str(i))
                    if pad &gt;= 3:
                        marker = '-'*(pad-3) + '-&gt; '
                    elif pad == 2:
                        marker = '&gt; '
                    elif pad == 1:
                        marker = '&gt;'
                    else:
                        marker = ''
                    num = '%s%s' % (marker,i)
                    line = tpl_line_em % (num,line)
                else:
                    num = '%*s' % (numbers_width,i)
                    line = tpl_line % (num,line)

                excerpt.append(line)
                if self.include_vars and i == lnum:
                    excerpt.append('%s\n' % lvals)
                i += 1
        frames.append('%s%s' % (level,''.join(excerpt)) )

    # Get (safely) a string form of the exception info
    try:
        etype_str,evalue_str = map(str,(etype,evalue))
    except:
        # User exception is improperly defined.
        etype,evalue = str,sys.exc_info()[:2]
        etype_str,evalue_str = map(str,(etype,evalue))
    # ... and format it
    exception = ['%s%s%s: %s' % (Colors.excName, etype_str,
                                 ColorsNormal, evalue_str)]
    if type(evalue) is types.InstanceType:
        for name in dir(evalue):
            value = text_repr(getattr(evalue, name))
            exception.append('\n%s%s = %s' % (indent, name, value))
    # return all our info assembled as a single string
    return '%s\n\n%s\n%s' % (head,'\n'.join(frames),''.join(exception[0]) )
</t>
<t tx="ekr.20050704165326.591">def debugger(self):
    """Call up the pdb debugger if desired, always clean up the tb reference.

    If the call_pdb flag is set, the pdb interactive debugger is
    invoked. In all cases, the self.tb reference to the current traceback
    is deleted to prevent lingering references which hamper memory
    management.

    Note that each call to pdb() does an 'import readline', so if your app
    requires a special setup for the readline completers, you'll have to
    fix that by hand after invoking the exception handler."""

    if self.call_pdb:
        if self.pdb is None:
            self.pdb = Debugger.Pdb()
        # the system displayhook may have changed, restore the original for pdb
        dhook = sys.displayhook
        sys.displayhook = sys.__displayhook__
        self.pdb.reset()
        while self.tb.tb_next is not None:
            self.tb = self.tb.tb_next
        try:
            self.pdb.interaction(self.tb.tb_frame, self.tb)
        except:
            print '*** ERROR ***'
            print 'This version of pdb has a bug and crashed.'
            print 'Returning to IPython...'
        sys.displayhook = dhook
    del self.tb
</t>
<t tx="ekr.20050704165326.592">def handler(self, info=None):
    (etype, evalue, etb) = info or sys.exc_info()
    self.tb = etb
    print &gt;&gt; Term.cerr, self.text(etype, evalue, etb)
</t>
<t tx="ekr.20050704165326.593"># Changed so an instance can just be called as VerboseTB_inst() and print
# out the right info on its own.
def __call__(self, etype=None, evalue=None, etb=None):
    """This hook can replace sys.excepthook (for Python 2.1 or higher)."""
    if etb is not None:
        self.handler((etype, evalue, etb))
    else:
        self.handler()
    self.debugger()
</t>
<t tx="ekr.20050704165326.594">
#----------------------------------------------------------------------------
class FormattedTB(VerboseTB,ListTB):
    """Subclass ListTB but allow calling with a traceback.

    It can thus be used as a sys.excepthook for Python &gt; 2.1.

    Also adds 'Context' and 'Verbose' modes, not available in ListTB.

    Allows a tb_offset to be specified. This is useful for situations where
    one needs to remove a number of topmost frames from the traceback (such as
    occurs with python programs that themselves execute other python code,
    like Python shells).  """
	@others
</t>
<t tx="ekr.20050704165326.595">def __init__(self, mode = 'Plain', color_scheme='Linux',
             tb_offset = 0,long_header=0,call_pdb=0,include_vars=0):

    # NEVER change the order of this list. Put new modes at the end:
    self.valid_modes = ['Plain','Context','Verbose']
    self.verbose_modes = self.valid_modes[1:3]

    VerboseTB.__init__(self,color_scheme,tb_offset,long_header,
                       call_pdb=call_pdb,include_vars=include_vars)
    self.set_mode(mode)
</t>
<t tx="ekr.20050704165326.596">def _extract_tb(self,tb):
    if tb:
        return traceback.extract_tb(tb)
    else:
        return None
</t>
<t tx="ekr.20050704165326.597">def text(self, etype, value, tb,context=5,mode=None):
    """Return formatted traceback.

    If the optional mode parameter is given, it overrides the current
    mode."""

    if mode is None:
        mode = self.mode
    if mode in self.verbose_modes:
        # verbose modes need a full traceback
        return VerboseTB.text(self,etype, value, tb,context=5)
    else:
        # We must check the source cache because otherwise we can print
        # out-of-date source code.
        linecache.checkcache()
        # Now we can extract and format the exception
        elist = self._extract_tb(tb)
        if len(elist) &gt; self.tb_offset:
            del elist[:self.tb_offset]
        return ListTB.text(self,etype,value,elist)
</t>
<t tx="ekr.20050704165326.598">def set_mode(self,mode=None):
    """Switch to the desired mode.

    If mode is not specified, cycles through the available modes."""

    if not mode:
        new_idx = ( self.valid_modes.index(self.mode) + 1 ) % \
                  len(self.valid_modes)
        self.mode = self.valid_modes[new_idx]
    elif mode not in self.valid_modes:
        raise ValueError, 'Unrecognized mode in FormattedTB: &lt;'+mode+'&gt;\n'\
              'Valid modes: '+str(self.valid_modes)
    else:
        self.mode = mode
    # include variable details only in 'Verbose' mode
    self.include_vars = (self.mode == self.valid_modes[2])
</t>
<t tx="ekr.20050704165326.599"># some convenient shorcuts
def plain(self):
    self.set_mode(self.valid_modes[0])
</t>
<t tx="ekr.20050704165326.600">def context(self):
    self.set_mode(self.valid_modes[1])
</t>
<t tx="ekr.20050704165326.601">def verbose(self):
    self.set_mode(self.valid_modes[2])
</t>
<t tx="ekr.20050704165326.602">
#----------------------------------------------------------------------------
class AutoFormattedTB(FormattedTB):
    """A traceback printer which can be called on the fly.

    It will find out about exceptions by itself.

    A brief example:
    
    AutoTB = AutoFormattedTB(mode = 'Verbose',color_scheme='Linux')
    try:
      ...
    except:
      AutoTB()  # or AutoTB(out=logfile) where logfile is an open file object
    """
	@others
</t>
<t tx="ekr.20050704165326.603">def __call__(self,etype=None,evalue=None,etb=None,
             out=None,tb_offset=None):
    """Print out a formatted exception traceback.

    Optional arguments:
      - out: an open file-like object to direct output to.

      - tb_offset: the number of frames to skip over in the stack, on a
      per-call basis (this overrides temporarily the instance's tb_offset
      given at initialization time.  """
    
    if out is None:
        out = Term.cerr
    if tb_offset is not None:
        tb_offset, self.tb_offset = self.tb_offset, tb_offset
        print &gt;&gt; out, self.text(etype, evalue, etb)
        self.tb_offset = tb_offset
    else:
        print &gt;&gt; out, self.text()
    self.debugger()
</t>
<t tx="ekr.20050704165326.604">def text(self,etype=None,value=None,tb=None,context=5,mode=None):
    if etype is None:
        etype,value,tb = sys.exc_info()
    self.tb = tb
    return FormattedTB.text(self,etype,value,tb,context=5,mode=mode)
</t>
<t tx="ekr.20050704165326.605">
#---------------------------------------------------------------------------
# A simple class to preserve Nathan's original functionality.
class ColorTB(FormattedTB):
    """Shorthand to initialize a FormattedTB in Linux colors mode."""
	@others
</t>
<t tx="ekr.20050704165326.606">def __init__(self,color_scheme='Linux',call_pdb=0):
    FormattedTB.__init__(self,color_scheme=color_scheme,
                         call_pdb=call_pdb)
</t>
<t tx="ekr.20050704165326.607">#----------------------------------------------------------------------------
# module testing (minimal)
if __name__ == "__main__":
    def spam(c, (d, e)):
        x = c + d
        y = c * d
        foo(x, y)

    def foo(a, b, bar=1):
        eggs(a, b + bar)

    def eggs(f, g, z=globals()):
        h = f + g
        i = f - g
        return h / i

    print ''
    print '*** Before ***'
    try:
        print spam(1, (2, 3))
    except:
        traceback.print_exc()
    print ''
    
    handler = ColorTB()
    print '*** ColorTB ***'
    try:
        print spam(1, (2, 3))
    except:
        apply(handler, sys.exc_info() )
    print ''
    
    handler = VerboseTB()
    print '*** VerboseTB ***'
    try:
        print spam(1, (2, 3))
    except:
        apply(handler, sys.exc_info() )
    print ''
</t>
<t tx="ekr.20050704170205">#*****************************************************************************
#       Copyright (C) 2005 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************</t>
<t tx="ekr.20050704170205.1">"""Manage background (threaded) jobs conveniently from an interactive shell.

This module provides a BackgroundJobManager class.  This is the main class
meant for public usage, it implements an object which can create and manage
new background jobs.

It also provides the actual job classes managed by these BackgroundJobManager
objects, see their docstrings below.


This system was inspired by discussions with B. Granger and the
BackgroundCommand class described in the book Python Scripting for
Computational Science, by H. P. Langtangen:

http://folk.uio.no/hpl/scripting

(although ultimately no code from this text was used, as IPython's system is a
separate implementation).

$Id$
"""</t>
<t tx="ekr.20050704170205.2"></t>
<t tx="ekr.20050704170205.3">@ignore
@language python
&lt;&lt; wintypes declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.4">from ctypes import *

DWORD = c_ulong
WORD = c_ushort
BYTE = c_byte

ULONG = c_ulong
LONG = c_long

LARGE_INTEGER = c_longlong
ULARGE_INTEGER = c_ulonglong


HANDLE = c_ulong # in the header files: void *

HWND = HANDLE
HDC = HANDLE
HMODULE = HANDLE
HINSTANCE = HANDLE
HRGN = HANDLE
HTASK = HANDLE
HKEY = HANDLE
HPEN = HANDLE
HGDIOBJ = HANDLE
HMENU = HANDLE

LCID = DWORD

WPARAM = c_uint
LPARAM = c_long

BOOL = c_long
VARIANT_BOOL = c_short

LPCOLESTR = LPOLESTR = OLESTR = c_wchar_p
LPCWSTR = LPWSTR = c_wchar_p

LPCSTR = LPSTR = c_char_p

</t>
<t tx="ekr.20050704170205.5">class RECT(Structure):
	&lt;&lt; class RECT declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.6">_fields_ = [("left", c_long),
            ("top", c_long),
            ("right", c_long),
            ("bottom", c_long)]
</t>
<t tx="ekr.20050704170205.7">RECTL = RECT

class POINT(Structure):
	&lt;&lt; class POINT declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.8">_fields_ = [("x", c_long),
            ("y", c_long)]
</t>
<t tx="ekr.20050704170205.9">POINTL = POINT

class SIZE(Structure):
	&lt;&lt; class SIZE declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.10">_fields_ = [("cx", c_long),
            ("cy", c_long)]
</t>
<t tx="ekr.20050704170205.11">SIZEL = SIZE

def RGB(red, green, blue):
    return red + (green &lt;&lt; 8) + (blue &lt;&lt; 16)
</t>
<t tx="ekr.20050704170205.12">
class FILETIME(Structure):
	&lt;&lt; class FILETIME declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.13">_fields_ = [("dwLowDateTime", DWORD),
            ("dwHighDateTime", DWORD)]

</t>
<t tx="ekr.20050704170205.14">class MSG(Structure):
	&lt;&lt; class MSG declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.15">_fields_ = [("hWnd", HWND),
            ("message", c_uint),
            ("wParam", WPARAM),
            ("lParam", LPARAM),
            ("time", DWORD),
            ("pt", POINT)]
</t>
<t tx="ekr.20050704170205.16">MAX_PATH = 260

# there's also a unicode version of that
class WIN32_FIND_DATAA(Structure):
	&lt;&lt; class WIN32_FIND_DATAA declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.17">_fields_ = [("dwFileAttributes", DWORD),
            ("ftCreationTime", FILETIME),
            ("ftLastAccessTime", FILETIME),
            ("ftLastWriteTime", FILETIME),
            ("nFileSizeHigh", DWORD),
            ("nFileSizeLow", DWORD),
            ("dwReserved0", DWORD),
            ("dwReserved1", DWORD),
            ("cFileName", c_char * MAX_PATH),
            ("cAlternameFileName", c_char * 14)]
</t>
<t tx="ekr.20050704170205.18">@ignore
@language python
&lt;&lt; __init__ declarations &gt;&gt;
@others

_pointer_type_cache[None] = c_void_p

# functions

from _ctypes import memmove, memset, string_at, cast

from decorators import cdecl
if _os.name == "nt":
    from decorators import stdcall
</t>
<t tx="ekr.20050704170205.19">"""create and manipulate C data types in Python"""

# special developer support to use ctypes from the CVS sandbox,
# without installing it
import os as _os, sys
_magicfile = _os.path.join(_os.path.dirname(__file__), ".CTYPES_DEVEL")
if _os.path.isfile(_magicfile):
    execfile(_magicfile)
del _magicfile

__version__ = "0.9.6"

from _ctypes import Union, Structure, Array
from _ctypes import _Pointer
from _ctypes import CFuncPtr as _CFuncPtr
from _ctypes import __version__ as _ctypes_version

from _ctypes import ArgumentError

from struct import calcsize as _calcsize

if __version__ != _ctypes_version:
    raise Exception, ("Version number mismatch", __version__, _ctypes_version)

if _os.name == "nt":
    from _ctypes import FormatError

from _ctypes import FUNCFLAG_CDECL as _FUNCFLAG_CDECL, \
     FUNCFLAG_PYTHONAPI as _FUNCFLAG_PYTHONAPI

"""
WINOLEAPI -&gt; HRESULT
WINOLEAPI_(type)

STDMETHODCALLTYPE

STDMETHOD(name)
STDMETHOD_(type, name)

STDAPICALLTYPE
"""

</t>
<t tx="ekr.20050704170205.20">def create_string_buffer(init, size=None):
    """create_string_buffer(aString) -&gt; character array
    create_string_buffer(anInteger) -&gt; character array
    create_string_buffer(aString, anInteger) -&gt; character array
    """
    if isinstance(init, (str, unicode)):
        if size is None:
            size = len(init)+1
        buftype = c_char * size
        buf = buftype()
        buf.value = init
        return buf
    elif isinstance(init, (int, long)):
        buftype = c_char * init
        buf = buftype()
        return buf
    raise TypeError, init
</t>
<t tx="ekr.20050704170205.21">def c_buffer(init, size=None):
##    "deprecated, use create_string_buffer instead"
##    import warnings
##    warnings.warn("c_buffer is deprecated, use create_string_buffer instead",
##                  DeprecationWarning, stacklevel=2)
    return create_string_buffer(init, size)
</t>
<t tx="ekr.20050704170205.22">_c_functype_cache = {}
def CFUNCTYPE(restype, *argtypes):
    """CFUNCTYPE(restype, *argtypes) -&gt; function prototype.
    
    restype: the result type
    argtypes: a sequence specifying the argument types
    
    The function prototype can be called in three ways to create a
    callable object:
    
    prototype(vtbl_index, method_name) - a function that calls a COM method
    prototype(callable) - returns a C callable function that calls callable
    prototype(funct_name, dll) - a function that calls an exported function in a dll
    """
    try:
        return _c_functype_cache[(restype, argtypes)]
    except KeyError:
        class CFunctionType(_CFuncPtr):
            _argtypes_ = argtypes
            _restype_ = restype
            _flags_ = _FUNCFLAG_CDECL
        _c_functype_cache[(restype, argtypes)] = CFunctionType
        return CFunctionType
</t>
<t tx="ekr.20050704170205.23">if _os.name == "nt":
    from _ctypes import LoadLibrary as _LoadLibrary, \
         FreeLibrary as _FreeLibrary
    from _ctypes import FUNCFLAG_HRESULT as _FUNCFLAG_HRESULT, \
         FUNCFLAG_STDCALL as _FUNCFLAG_STDCALL

    _win_functype_cache = {}
    def WINFUNCTYPE(restype, *argtypes):
        """WINFUNCTYPE(restype, *argtypes) -&gt; function prototype.
    
        restype: the result type
        argtypes: a sequence specifying the argument types
        
        The function prototype can be called in three ways to create a
        callable object:
        
        prototype(vtbl_index, method_name) - a function that calls a COM method
        prototype(callable) - returns a C callable function that calls callable
        prototype(funct_name, dll) - a function that calls an exported function in a dll
        """
        try:
            return _win_functype_cache[(restype, argtypes)]
        except KeyError:
            class WinFunctionType(_CFuncPtr):
                _argtypes_ = argtypes
                _restype_ = restype
                _flags_ = _FUNCFLAG_STDCALL
            _win_functype_cache[(restype, argtypes)] = WinFunctionType
            return WinFunctionType
</t>
<t tx="ekr.20050704170205.24">
elif _os.name == "posix":
    from _ctypes import dlopen as _LoadLibrary
    _FreeLibrary = None

from _ctypes import sizeof, byref, addressof, alignment
from _ctypes import _SimpleCData

class py_object(_SimpleCData):
	&lt;&lt; class py_object declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.25">_type_ = "O"

</t>
<t tx="ekr.20050704170205.26">class c_short(_SimpleCData):
	&lt;&lt; class c_short declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.27">_type_ = "h"
</t>
<t tx="ekr.20050704170205.28">def __repr__(self):
    return "c_short(%d)" % self.value
</t>
<t tx="ekr.20050704170205.29">
class c_ushort(_SimpleCData):
	&lt;&lt; class c_ushort declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.30">_type_ = "H"
</t>
<t tx="ekr.20050704170205.31">def __repr__(self):
    return "c_ushort(%d)" % self.value
</t>
<t tx="ekr.20050704170205.32">
class c_long(_SimpleCData):
	&lt;&lt; class c_long declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.33">_type_ = "l"
</t>
<t tx="ekr.20050704170205.34">def __repr__(self):
    return "c_long(%d)" % self.value
</t>
<t tx="ekr.20050704170205.35">
class c_ulong(_SimpleCData):
	&lt;&lt; class c_ulong declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.36">_type_ = "L"
</t>
<t tx="ekr.20050704170205.37">def __repr__(self):
    return "c_ulong(%d)" % self.value
</t>
<t tx="ekr.20050704170205.38">    
if _calcsize("i") == _calcsize("l"):
    # if int and long have the same size, make c_int an alias for c_long
    c_int = c_long
    c_uint = c_ulong
else:
    class c_int(_SimpleCData):
	&lt;&lt; class c_int declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.39">_type_ = "i"
</t>
<t tx="ekr.20050704170205.40">def __repr__(self):
    return "c_int(%d)" % self.value
</t>
<t tx="ekr.20050704170205.41">
class c_uint(_SimpleCData):
	&lt;&lt; class c_uint declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.42">_type_ = "I"
</t>
<t tx="ekr.20050704170205.43">def __repr__(self):
    return "c_uint(%d)" % self.value
</t>
<t tx="ekr.20050704170205.44">
class c_float(_SimpleCData):
	&lt;&lt; class c_float declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.45">_type_ = "f"
</t>
<t tx="ekr.20050704170205.46">def __repr__(self):
    return "%s(%f)" % (self.__class__.__name__, self.value)
</t>
<t tx="ekr.20050704170205.47">    
class c_double(_SimpleCData):
	&lt;&lt; class c_double declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.48">_type_ = "d"
</t>
<t tx="ekr.20050704170205.49">def __repr__(self):
    return "%s(%f)" % (self.__class__.__name__, self.value)
</t>
<t tx="ekr.20050704170205.50">
if _calcsize("l") == _calcsize("q"):
    # if long and long long have the same size, make c_longlong an alias for c_long
    c_longlong = c_long
    c_ulonglong = c_ulong
else:
    class c_longlong(_SimpleCData):
	&lt;&lt; class c_longlong declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.51">_type_ = "q"
</t>
<t tx="ekr.20050704170205.52">def __repr__(self):
    return "c_longlong(%s)" % self.value
</t>
<t tx="ekr.20050704170205.53">
class c_ulonglong(_SimpleCData):
	&lt;&lt; class c_ulonglong declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.54">_type_ = "Q"
</t>
<t tx="ekr.20050704170205.55">def __repr__(self):
    return "c_ulonglong(%s)" % self.value
</t>
<t tx="ekr.20050704170205.56">    ##    def from_param(cls, val):
    ##        return ('d', float(val), val)
    ##    from_param = classmethod(from_param)

class c_ubyte(_SimpleCData):
	&lt;&lt; class c_ubyte declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.57">_type_ = "B"
</t>
<t tx="ekr.20050704170205.58">def __repr__(self):
    return "c_ubyte(%s)" % self.value
</t>
<t tx="ekr.20050704170205.59"># backward compatibility:
##c_uchar = c_ubyte

class c_byte(_SimpleCData):
	&lt;&lt; class c_byte declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.60">_type_ = "b"
</t>
<t tx="ekr.20050704170205.61">def __repr__(self):
    return "c_byte(%s)" % self.value
</t>
<t tx="ekr.20050704170205.62">
class c_char(_SimpleCData):
	&lt;&lt; class c_char declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.63">_type_ = "c"
</t>
<t tx="ekr.20050704170205.64">def __repr__(self):
    return "c_char(%r)" % self.value
</t>
<t tx="ekr.20050704170205.65">
class c_char_p(_SimpleCData):
	&lt;&lt; class c_char_p declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.66">_type_ = "z"
</t>
<t tx="ekr.20050704170205.67">def __repr__(self):
    return "%s(%r)" % (self.__class__.__name__, self.value)
</t>
<t tx="ekr.20050704170205.68">
class c_void_p(_SimpleCData):
	&lt;&lt; class c_void_p declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.69">_type_ = "P"
</t>
<t tx="ekr.20050704170205.70">def __repr__(self):
    return "%s(%r)" % (self.__class__.__name__, self.value)
</t>
<t tx="ekr.20050704170205.71">c_voidp = c_void_p # backwards compatibility (to a bug)

# This cache maps types to pointers to them.
_pointer_type_cache = {}

def POINTER(cls):
    try:
        return _pointer_type_cache[cls]
    except KeyError:
        pass
    if type(cls) is str:
        klass = type(_Pointer)("LP_%s" % cls,
                               (_Pointer,),
                               {})
        _pointer_type_cache[id(klass)] = klass
        return klass
    else:
        name = "LP_%s" % cls.__name__
        klass = type(_Pointer)(name,
                               (_Pointer,),
                               {'_type_': cls})
        _pointer_type_cache[cls] = klass
    return klass
</t>
<t tx="ekr.20050704170205.72">
try:
    from _ctypes import set_conversion_mode
except ImportError:
    pass
else:
    if _os.name == "nt":
        set_conversion_mode("mbcs", "ignore")
    else:
        set_conversion_mode("ascii", "strict")

    class c_wchar_p(_SimpleCData):
	&lt;&lt; class c_wchar_p declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.73">_type_ = "Z"
</t>
<t tx="ekr.20050704170205.74">def __repr__(self):
    return "%s(%r)" % (self.__class__.__name__, self.value)
</t>
<t tx="ekr.20050704170205.75">
class c_wchar(_SimpleCData):
	&lt;&lt; class c_wchar declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.76">_type_ = "u"
</t>
<t tx="ekr.20050704170205.77">def __repr__(self):
    return "c_wchar(%r)" % self.value
</t>
<t tx="ekr.20050704170205.78">POINTER(c_wchar).from_param = c_wchar_p.from_param #_SimpleCData.c_wchar_p_from_param

def create_unicode_buffer(init, size=None):
    """create_unicode_buffer(aString) -&gt; character array
    create_unicode_buffer(anInteger) -&gt; character array
    create_unicode_buffer(aString, anInteger) -&gt; character array
    """
    if isinstance(init, (str, unicode)):
        if size is None:
            size = len(init)+1
        buftype = c_wchar * size
        buf = buftype()
        buf.value = init
        return buf
    elif isinstance(init, (int, long)):
        buftype = c_wchar * init
        buf = buftype()
        return buf
    raise TypeError, init
</t>
<t tx="ekr.20050704170205.79">from _ctypes import wstring_at

POINTER(c_char).from_param = c_char_p.from_param #_SimpleCData.c_char_p_from_param

def SetPointerType(pointer, cls):
</t>
<t tx="ekr.20050704170205.80">if _pointer_type_cache.get(cls, None) is not None:
    raise RuntimeError, \
          "This type already exists in the cache"
if not _pointer_type_cache.has_key(id(pointer)):
    raise RuntimeError, \
          "What's this???"
pointer.set_type(cls)
_pointer_type_cache[cls] = pointer
del _pointer_type_cache[id(pointer)]


def pointer(inst):
</t>
<t tx="ekr.20050704170205.81">return POINTER(type(inst))(inst)

def ARRAY(typ, len):
</t>
<t tx="ekr.20050704170205.82">return typ * len

################################################################


class CDLL:
	@others
</t>
<t tx="ekr.20050704170205.83">class _CdeclFuncPtr(_CFuncPtr):
	&lt;&lt; class _CdeclFuncPtr declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.84">_flags_ = _FUNCFLAG_CDECL
_restype_ = c_int # default, can be overridden in instances

</t>
<t tx="ekr.20050704170205.85">_handle = 0
def __init__(self, name, handle=None):
    self._name = name
    if handle is None:
        self._handle = _LoadLibrary(self._name)
    else:
        self._handle = handle
</t>
<t tx="ekr.20050704170205.86">def __repr__(self):
    return "&lt;%s '%s', handle %x at %x&gt;" % \
           (self.__class__.__name__, self._name,
            (self._handle &amp; (sys.maxint*2 + 1)),
            id(self))
</t>
<t tx="ekr.20050704170205.87">def __getattr__(self, name):
    if name[:2] == '__' and name[-2:] == '__':
        raise AttributeError, name
    func = self._CdeclFuncPtr(name, self)
    func.__name__ = name
    setattr(self, name, func)
    return func
</t>
<t tx="ekr.20050704170205.88">def __getitem__(self, name):
    return getattr(self, name)
</t>
<t tx="ekr.20050704170205.89">
# This creates problems in gc.  See
# https://sourceforge.net/tracker/index.php?func=detail&amp;aid=1042541&amp;group_id=71702&amp;atid=532154
# but since we cannot free the libraries anyway (the functions
# retrieved don't keep a reference to the _DLL instance), it does no
# harm to disable this code.
#
##    def __del__(self, FreeLibrary=_FreeLibrary):
##        if self._handle != 0 and FreeLibrary:
##            FreeLibrary(self._handle)
##        self._handle = 0

class PyDLL(CDLL):
	@others
</t>
<t tx="ekr.20050704170205.90">class _CdeclFuncPtr(_CFuncPtr):
	&lt;&lt; class _CdeclFuncPtr declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.91">_flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI
_restype_ = c_int # default, can be overridden in instances

</t>
<t tx="ekr.20050704170205.92">if _os.name ==  "nt":
        
    class WinDLL(CDLL):
	@others
</t>
<t tx="ekr.20050704170205.93">class _StdcallFuncPtr(_CFuncPtr):
	&lt;&lt; class _StdcallFuncPtr declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.94">_flags_ = _FUNCFLAG_STDCALL
_restype_ = c_int # default, can be overridden in instances

</t>
<t tx="ekr.20050704170205.95">def __getattr__(self, name):
    if name[:2] == '__' and name[-2:] == '__':
        raise AttributeError, name
    func = self._StdcallFuncPtr(name, self)
    func.__name__ = name
    setattr(self, name, func)
    return func
</t>
<t tx="ekr.20050704170205.96">
from _ctypes import _check_HRESULT
class HRESULT(c_long):
	&lt;&lt; class HRESULT declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.97"># _check_retval_ is called with the function's result when it
# is used as restype.  It checks for the FAILED bit, and
# raises a WindowsError if it is set.
#
# The _check_retval_ method is implemented in C, so that the
# method definition itself is not included in the traceback
# when it raises an error - that is what we want (and Python
# doesn't have a way to raise an exception in the caller's
# frame.
_check_retval_ = _check_HRESULT

</t>
<t tx="ekr.20050704170205.98">class OleDLL(CDLL):
	@others
</t>
<t tx="ekr.20050704170205.99">class _OlecallFuncPtr(_CFuncPtr):
	&lt;&lt; class _OlecallFuncPtr declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.100"># It would be possible to remove the _FUNCFLAG_HRESULT
# code, and use HRESULT as _restype_.  But
# _FUNCFLAG_HRESULT is used in other places in the C code
# as well, so we leave it as it is.
_flags_ = _FUNCFLAG_STDCALL | _FUNCFLAG_HRESULT
_restype_ = c_int # needed, but unused (see _FUNCFLAG_HRESULT flag)
</t>
<t tx="ekr.20050704170205.101">def __getattr__(self, name):
    if name[:2] == '__' and name[-2:] == '__':
        raise AttributeError, name
    func = self._OlecallFuncPtr(name, self)
    func.__name__ = name
    setattr(self, name, func)
    return func
</t>
<t tx="ekr.20050704170205.102">
class _DLLS:
	@others
</t>
<t tx="ekr.20050704170205.103">def __init__(self, dlltype):
    self._dlltype = dlltype
</t>
<t tx="ekr.20050704170205.104">def __getattr__(self, name):
    if name[0] == '_':
        raise AttributeError, name
    dll = self._dlltype(name)
    setattr(self, name, dll)
    return dll
</t>
<t tx="ekr.20050704170205.105">def __getitem__(self, name):
    return getattr(self, name)
</t>
<t tx="ekr.20050704170205.106">def LoadLibrary(self, name):
    return self._dlltype(name)
</t>
<t tx="ekr.20050704170205.107">cdll = _DLLS(CDLL)
pydll = _DLLS(PyDLL)

if _os.name == "nt":
    pythonapi = PyDLL("python dll", sys.dllhandle)
elif sys.platform == "cygwin":
    pythonapi = PyDLL("libpython%d.%d.dll" % sys.version_info[:2])
else:
    pythonapi = PyDLL(None)


if _os.name == "nt":
    windll = _DLLS(WinDLL)
    oledll = _DLLS(OleDLL)

    GetLastError = windll.kernel32.GetLastError

    def WinError(code=None, descr=None):
        if code is None:
            code = GetLastError()
        if descr is None:
            descr = FormatError(code).strip()
        return WindowsError(code, descr)
</t>
<t tx="ekr.20050704170205.108">@ignore
@language python
&lt;&lt; decorators declarations &gt;&gt;
@others

################################################################

##if __name__ == "__main__":
if 0:
    import doctest
    doctest.testmod()
</t>
<t tx="ekr.20050704170205.109">"""
This module implements decorators for native api function calls.

stdcall(restype, dllname, argtypes[, logging=False])
cdecl(restype, dllname, argtypes[, logging=False])

The decorator functions are used like this:

&gt;&gt;&gt; from ctypes import *
&gt;&gt;&gt; # wrap the GetModuleFileNameA function
&gt;&gt;&gt; @ stdcall(c_ulong, 'kernel32', [c_ulong, POINTER(c_char), c_ulong])
... def GetModuleFileNameA(handle=0):
...     buf = create_string_buffer(256)
...     if 0 == GetModuleFileNameA._api_(handle, buf, sizeof(buf)):
...         raise WinError()
...     return buf.value
&gt;&gt;&gt;
&gt;&gt;&gt; sys.executable == GetModuleFileNameA()
True
&gt;&gt;&gt;
&gt;&gt;&gt; @ cdecl(c_char_p, 'msvcrt', [c_char_p, c_int])
... def strchr(string, c):
...     'find a character in a string'
...     return strchr._api_(string, c)
&gt;&gt;&gt; print strchr('abcdef', ord('x'))
None
&gt;&gt;&gt; print strchr('abcdef', ord('c'))
cdef
&gt;&gt;&gt;
"""

# This doesn't work, see below.
##&gt;&gt;&gt; @ cdecl(c_char_p, 'msvcrt', [c_char_p, c_int])
##... def strchr(string, c):
##...     'find a character in a string'
##...
##&gt;&gt;&gt; print strchr('abcdef', ord('x'))
##None
##&gt;&gt;&gt; print strchr('abcdef', ord('c'))
##cdef
##&gt;&gt;&gt;

import sys
import ctypes

LOGGING = False

##def _create_func_codestring(func, doc=None):
##    # given a function object &lt;func&gt;, build the source code for
##    # another function, having the same argument list, and a function
##    # body which contains a call to an _api_ function.
##    #
##    # Assuming the &lt;func&gt; has this definition:
##    #   def func(first, second="spam", third=42):
##    #       ....
##    # a string containing the following code is returned:
##    #   def func(first, second="spam", third=42):
##    #       return _api_(first, second, third)
##    import inspect
##    args, varargs, varkw, defaults = inspect.getargspec(func)
##    if varkw:
##        raise TypeError, "function argument list cannot contain ** argument"
##    if doc:
##        return "def %s%s:\n    %r\n    return %s._api_%s" % \
##               (func.func_name,
##                inspect.formatargspec(args, varargs, varkw, defaults),
##                doc,
##                func.func_name,
##                inspect.formatargspec(args, varargs, varkw))
##    return "def %s%s:\n    return %s._api_%s" % \
##           (func.func_name,
##            inspect.formatargspec(args, varargs, varkw, defaults),
##            func.func_name,
##            inspect.formatargspec(args, varargs, varkw))

################################################################

</t>
<t tx="ekr.20050704170205.110">def stdcall(restype, dll, argtypes, logging=False):
    """stdcall(restype, dll, argtypes, logging=False) -&gt; decorator.

    The decorator, when applied to a function, attaches an '_api_'
    attribute to the function.  Calling this attribute calls the
    function exported from the dll, using the MS '__stdcall' calling
    convention.

    restype - result type
    dll - name or instance of a dll
    argtypes - list of argument types
    logging - if this is True, the result of each function call
        is printed to stderr.
    """
    def decorate(func):
        if isinstance(dll, basestring):
            # this call should cache the result
            this_dll = ctypes.CDLL(dll)
        else:
            this_dll = dll
        api = ctypes.WINFUNCTYPE(restype, *argtypes)(func.func_name, this_dll)
        # This simple way to find out an empty function body doesn't work.
##        if len(func.func_code.co_code) == 4:
##            codestring = _create_func_codestring(func, func.__doc__)
##            d = {}
##            exec codestring in d
##            func = d[func.func_name]
        func._api_ = api
        if logging or LOGGING:
            def f(*args):
                result = func(*args)
                print &gt;&gt; sys.stderr, "# function call: %s%s -&gt; %s" % (func.func_name, args, result)
                return result
            return f
        else:
            return func
    return decorate
</t>
<t tx="ekr.20050704170205.111">def cdecl(restype, dll, argtypes, logging=False):
    """cdecl(restype, dll, argtypes, logging=False) -&gt; decorator.

    The decorator, when applied to a function, attaches an '_api_'
    attribute to the function.  Calling this attribute calls the
    function exported from the dll, using the standard C calling
    convention.
   
    restype - result type
    dll - name or instance of a dll/shared library
    argtypes - list of argument types
    logging - if this is True, the result of each function call
        is printed to stderr.
    """
    def decorate(func):
        if isinstance(dll, basestring):
            # this call should cache the result
            this_dll = ctypes.CDLL(dll)
        else:
            this_dll = dll
        api = ctypes.CFUNCTYPE(restype, *argtypes)(func.func_name, this_dll)
        # This simple way to find out an empty function body doesn't work.
##        if len(func.func_code.co_code) == 4:
##            codestring = _create_func_codestring(func, func.__doc__)
##            d = {}
##            exec codestring in d
##            func = d[func.func_name]
        func._api_ = api
        if logging or LOGGING:
            def f(*args):
                result = func(*args)
                print &gt;&gt; sys.stderr, func.func_name, args, "-&gt;", result
                return result
            return f
        else:
            return func
    return decorate
</t>
<t tx="ekr.20050704170205.112"></t>
<t tx="ekr.20050704170205.113">@ignore
@language python
@others

        unittest.main()
</t>
<t tx="ekr.20050704170205.114">class GetoptError(Exception):
	&lt;&lt; class GetoptError declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.115">pass

</t>
<t tx="ekr.20050704170205.116">def w_getopt(args, options):
    """A getopt for Windows.

    Options may start with either '-' or '/', the option names may
    have more than one letter (/tlb or -RegServer), and option names
    are case insensitive.

    Returns two elements, just as getopt.getopt.  The first is a list
    of (option, value) pairs in the same way getopt.getopt does, but
    there is no '-' or '/' prefix to the option name, and the option
    name is always lower case.  The second is the list of arguments
    which do not belong to an option.

    Different from getopt.getopt, a single argument not belonging to an option
    does not terminate parsing.
    """
    opts = []
    arguments = []
    while args:
        if args[0][:1] in "/-":
            arg = args[0][1:] # strip the '-' or '/'
            arg = arg.lower()

            if arg + ':' in options:
                try:
                    opts.append((arg, args[1]))
                except IndexError:
                    raise GetoptError, "option '%s' requires an argument" % args[0]
                args = args[1:]
            elif arg in options:
                opts.append((arg, ''))
            else:
                raise GetoptError, "invalid option '%s'" % args[0]
            args = args[1:]
        else:
            arguments.append(args[0])
            args = args[1:]

    return opts, arguments
</t>
<t tx="ekr.20050704170205.117">
if __debug__:
    if __name__ == "__main__":
        import unittest

        class TestCase(unittest.TestCase):
	@others
</t>
<t tx="ekr.20050704170205.118">def test_1(self):
    args = "-embedding spam /RegServer foo /UnregSERVER blabla".split()
    opts, args = w_getopt(args,
                          "regserver unregserver embedding".split())
    self.assertEqual(opts,
                     [('embedding', ''),
                      ('regserver', ''),
                      ('unregserver', '')])
    self.assertEqual(args, ["spam", "foo", "blabla"])
</t>
<t tx="ekr.20050704170205.119">def test_2(self):
    args = "/TLB Hello.Tlb HELLO.idl".split()
    opts, args = w_getopt(args, ["tlb:"])
    self.assertEqual(opts, [('tlb', 'Hello.Tlb')])
    self.assertEqual(args, ['HELLO.idl'])
</t>
<t tx="ekr.20050704170205.120">def test_3(self):
    # Invalid option
    self.assertRaises(GetoptError, w_getopt,
                      "/TLIB hello.tlb hello.idl".split(), ["tlb:"])
</t>
<t tx="ekr.20050704170205.121">def test_4(self):
    # Missing argument
    self.assertRaises(GetoptError, w_getopt,
                      "/TLB".split(), ["tlb:"])
</t>
<t tx="ekr.20050704170205.122">@ignore
@language python
&lt;&lt; __init__ declarations &gt;&gt;
@others

PIUnknown = POINTER(IUnknown) # deprecated

##if __name__ == "__main__":
##    print CreateGuid()
</t>
<t tx="ekr.20050704170205.123">from ctypes import *
from ctypes.com.hresult import *
import _ctypes
from ctypes.wintypes import DWORD, WORD, BYTE

DEBUG = __debug__ # enable debugging output (via Windows' OutputDebugString)

from ctypes import HRESULT

CopyComPointer = _ctypes.CopyComPointer

ole32 = oledll.ole32

################################################################

# Still experimenting with COM shutdown without crashes...

ole32.CoInitialize(None)

</t>
<t tx="ekr.20050704170205.124">class _Cleaner(object):
	@others
</t>
<t tx="ekr.20050704170205.125">def __del__(self, func=ole32.CoUninitialize):
    # Sometimes, CoUnititialize, running at Python shutdown, raises an exception.
    # We suppress this when __debug__ is False.
    if __debug__:
        func()
    else:
        try: func()
        except WindowsError: pass
</t>
<t tx="ekr.20050704170205.126">__cleaner = _Cleaner()
del _Cleaner

def _clean_exc_info():
    # the purpose of this function is to ensure that no com object
    # pointers are in sys.exc_info()
    try: 1//0
    except: pass
</t>
<t tx="ekr.20050704170205.127">
import atexit
atexit.register(_clean_exc_info)

################################################################
# Basic COM data types
#

class GUID(Structure):
	&lt;&lt; class GUID declarations &gt;&gt;
	@others
    from_progid = classmethod(from_progid)</t>
<t tx="ekr.20050704170205.128">_fields_ = [("Data1", DWORD),
            ("Data2", WORD),
            ("Data3", WORD),
            ("Data4", BYTE * 8)]

</t>
<t tx="ekr.20050704170205.129">def __init__(self, name=None):
    if name is not None:
        ole32.CLSIDFromString(unicode(name), byref(self))
</t>
<t tx="ekr.20050704170205.130">def __repr__(self):
    s = (c_wchar * 39)()
    ole32.StringFromGUID2(byref(self), s, 39)
    return 'GUID("%s")' % s.value
</t>
<t tx="ekr.20050704170205.131">def __str__(self):
    s = (c_wchar * 39)()
    ole32.StringFromGUID2(byref(self), s, 39)
    return s.value
</t>
<t tx="ekr.20050704170205.132">def __cmp__(self, other):
    if isinstance(other, GUID):
        return not ole32.IsEqualGUID(byref(self), byref(other))
    return -1
</t>
<t tx="ekr.20050704170205.133">def __nonzero__(self):
    result = str(buffer(self)) != "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    return result
</t>
<t tx="ekr.20050704170205.134">def __eq__(self, other, IsEqualGUID=ole32.IsEqualGUID):
    return isinstance(other, GUID) and \
           IsEqualGUID(byref(self), byref(other))               
</t>
<t tx="ekr.20050704170205.135">##    def __hash__(self):
##        return hash(repr(self))

def copy(self):
    return GUID(str(self))
</t>
<t tx="ekr.20050704170205.136">def from_progid(cls, progid):
    inst = cls()
    ole32.CLSIDFromProgID(unicode(progid), byref(inst))
    return inst
</t>
<t tx="ekr.20050704170205.137">assert(sizeof(GUID) == 16), sizeof(GUID)

REFCLSID = REFGUID = REFIID = POINTER(GUID)

################################################################
# COM interface and pointer meta and baseclasses
#

def STDMETHOD(restype, name, *argtypes, **kw):
    # First argument (this) for COM method implementation is really a
    # pointer to a IUnknown subclass, but we don't want this to be
    # built all the time, since we probably don't use it, so use
    # c_void_p
    return name, WINFUNCTYPE(restype, c_void_p, *argtypes)
</t>
<t tx="ekr.20050704170205.138">def COMPointer__del__(self):
    if self:
        self.Release()
</t>
<t tx="ekr.20050704170205.139"># disabled for now
##def COMPointer__init__(self, *args):
##    if self:
##        self.AddRef()
##    _Pointer.__init__(self, *args)

class _interface_meta(type(Structure)):
    """Metaclass for COM interface classes.

    These classes require a _methods_ list, which must be a sequence
    of (name, prototype) pairs. 'name' is the name of the COM method,
    'prototype' is the function class containing return type and
    argument types. These pairs are usually created by the STDMETHOD()
    function.

    The list must be a VTable order, and it must include all methods
    of all base interfaces.

    The method list is used to create a VTable instance and populating
    it with C function pointers if the interface is *implemented* in
    Python.

    It is also used to automatically create Python methods for the
    POINTER class for an interface, which forward the call to the COM
    object which implements this interface.

    The list *may* be set after the class is created, but it must be
    available when the class is first used.
    """
	@others
</t>
<t tx="ekr.20050704170205.140">def __new__(cls, name, bases, kwds):
    # create a new COM interface class
    VTable_ptr = POINTER("%s_VTable" % name)
    fields = [("lpVtbl", VTable_ptr)]
    kwds["_fields_"] = fields
    result = type(Structure).__new__(cls, name, bases, kwds)
    result.VTable_ptr = VTable_ptr
    if kwds.has_key("_methods_"):
        result._init_class()
    return result
</t>
<t tx="ekr.20050704170205.141">def __make_vtable(self):
    # Now that self._methods_ is available, create the VTable
    _VTable = type(Structure)("%s_VTable" % self.__name__,
                              (Structure,),
                              {"_fields_": self._methods_})
    SetPointerType(self.VTable_ptr, _VTable)
</t>
<t tx="ekr.20050704170205.142">def _init_class(self):
    self.__make_vtable()
    self.__make_methods()
    P = POINTER(self)
    P.__del__ = COMPointer__del__
    # the presence of this attribute triggers automatic AddRef()
    # calls in COM method implementations, for aruments we receive.
    P._needs_com_addref_ = None
</t>
<t tx="ekr.20050704170205.143">def __setattr__(self, name, value):
    if name == "_methods_" and self.__dict__.has_key("_methods_"):
        raise TypeError, "Cannot change _methods_"
    type(Structure).__setattr__(self, name, value)
    if name == "_methods_":
        self._init_class()
</t>
<t tx="ekr.20050704170205.144">def __make_methods(self):
    """This method attaches methods to the interface POINTER class"""
##        from ctypes.com.server import dprint
##        dprint("# making client methods for interface", self.__name__)
    import new
    index = 0
    ptrclass = POINTER(self)
    for name, PROTO in self._fields_[0][1]._type_._fields_: # VTable._fields_
        # PROTO is already a subclass of CFuncPtr. It is the type of a
        # function which can be used as the COM method implementation.
        # We read the restype and the argtypes from it, and construct
        # another function type, which can be used as the COM method *client*.
        # For this we don't want the first argument - the 'this' pointer.
        restype = PROTO.__dict__["_restype_"]
        argtypes = PROTO.__dict__["_argtypes_"][1:]
        clientPROTO = WINFUNCTYPE(restype, *argtypes)
        mth = new.instancemethod(clientPROTO(index, name), None, ptrclass)
        setattr(ptrclass, name, mth)
        index += 1
</t>
<t tx="ekr.20050704170205.145">
################################################################
# IUnknown, the root of all evil...

class IUnknown(Structure):
	&lt;&lt; class IUnknown declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.146">_use_broken_old_ctypes_structure_semantics_ = None # hack, hack
__metaclass__ = _interface_meta
_iid_ = GUID("{00000000-0000-0000-C000-000000000046}")

################################################################
# Custom argument checking function for POINTER(POINTER(IUnknown))
</t>
<t tx="ekr.20050704170205.147">_PyCArgType = type(byref(c_int()))
def from_param(self, obj):
    # We accept two types of arguments here:
    # - pointer to pointer to an instance of an IUnknown (sub)class
    # - PyCArgObjects containing pointer to an instance of an IUnknown (sub)class
    if type(obj) == _PyCArgType and \
           issubclass(obj._obj._type_, IUnknown):
        return obj
    if isinstance(obj, _ctypes._Pointer) and \
           issubclass(obj._type_._type_, IUnknown):
        return obj
## Do we also accept integers? Currently not.
##    if type(obj) is int:
##        return obj
    raise TypeError, "expected a reference to a IUnknown"
</t>
<t tx="ekr.20050704170205.148"># This must be set before it is first used in an argument list
# XXX explain reason
POINTER(POINTER(IUnknown)).from_param = classmethod(from_param)

IUnknown._methods_ = [STDMETHOD(HRESULT, "QueryInterface", REFIID, POINTER(POINTER(IUnknown))),
                      STDMETHOD(c_ulong, "AddRef"),
                      STDMETHOD(c_ulong, "Release")]

################################################################

import _winreg
def interface_name(iid):
    # A handy function which returns the name of an interface from
    # it's iid.  If the interface is not registered, returns str(iid).
    try:
        return _winreg.QueryValue(_winreg.HKEY_CLASSES_ROOT, "Interface\\%s" % iid)
    except WindowsError:
        return str(iid)
</t>
<t tx="ekr.20050704170205.149">def _wrap(func, name, itfclass):
    # This function is called, if DEBUG is True, to wrap a COM
    # interface method implementation.  For now, it prints method
    # calls via Windows' OutputDebugString mechanism, and for the
    # QueryInterface and CreateInstance method calls additionally the
    # interface requested.  This can be very handy in debugging.
    from ctypes.com.server import dprint
    if name == "QueryInterface":
        def wrapped_QI(this, *args):
            result = func(this, *args)
            dprint("&lt;method call&gt; %s.%s(%s) -&gt; 0x%x" % \
                   (itfclass.__name__, name, interface_name(args[0][0]), result))
            return result
        return wrapped_QI
    elif name == "CreateInstance":
        def wrapped_CI(this, *args):
            result = func(this, *args)
            dprint("&lt;method call&gt; %s.%s(%s) -&gt; 0x%x" % \
                   (itfclass.__name__, name, interface_name(args[1][0]), result))
            return result
        return wrapped_CI
    def wrapped(this, *args):
        result = func(this, *args)
        dprint("&lt;method call&gt; %s.%s -&gt; %s" % \
               (itfclass.__name__, name, result))
        return result
    return wrapped
</t>
<t tx="ekr.20050704170205.150">
class COMObject(object):
	&lt;&lt; class COMObject declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.151">_refcnt = 0
_factory = None
_com_interfaces_ = [] # should be replaced in subclasses

</t>
<t tx="ekr.20050704170205.152">def _get_registrar(cls):
    from ctypes.com.register import Registrar
    return Registrar(cls)
</t>
<t tx="ekr.20050704170205.153">_get_registrar = classmethod(_get_registrar)

def __init__(self):
    # actually this contains (iid, interface) pairs, where iid is
    # a GUID instance, and interface is an IUnknown or subclass instance.
    # The address of this instance is the actual COM interface pointer!
    self._com_pointers_ = []
    for itf in self._com_interfaces_:
        self._make_interface_pointer(itf)
</t>
<t tx="ekr.20050704170205.154">def _get_funcimpl(self, name, itfclass, proto):
    from ctypes.com.server import dprint
    # Search for methods named &lt;interface&gt;_&lt;methodname&gt; in the
    # interface, including base interfaces
##        print str([hasattr(x, "AddRef") and i for i, x in enumerate(proto._argtypes_)])

    # We still have the problem when a COM method is implemented in Python,
    # that we have to call .AddRef on all received COM interface pointers manually.
    # This MUST either be fixed here, or in wrap, or in _ctypes' C code.
    for i in itfclass.mro()[:-3]:
        func = getattr(self, "%s_%s" % (i.__name__, name), None)
        if func is not None:
            if DEBUG:
                return _wrap(func, name, itfclass)
            else:
                return func
    if hasattr(self, name):
        func = getattr(self, name)
        if DEBUG:
            return _wrap(func, name, itfclass)
        else:
            return func

    def notimpl(self, *args):
        if DEBUG:
            dprint("&lt;called E_NOTIMPL method&gt; %s.%s, args: %s" % \
                   (name, itfclass.__name__, str(args)))
        return E_NOTIMPL
    if DEBUG:
        dprint("# unimplemented %s for interface %s" % (name, itfclass.__name__))
    return notimpl
</t>
<t tx="ekr.20050704170205.155">def _make_interface_pointer(self, itfclass):
    # Take an interface class like 'IUnknown' and create
    # an pointer to it, implementing this interface.
    vtbltype = itfclass._fields_[0][1]._type_
    methods = []
    for name, proto in vtbltype._fields_:
        func = self._get_funcimpl(name, itfclass, proto)
        methods.append(proto(func))

    vtbl = vtbltype(*methods)
    itf = itfclass()
    itf.lpVtbl = pointer(vtbl)
    for iid in [cls._iid_ for cls in itfclass.mro()[:-3]]:
        self._com_pointers_.append((iid, itf))
</t>
<t tx="ekr.20050704170205.156">################################################################
# IUnknown methods

def QueryInterface(self, this, refiid, ppiunk):
    iid = refiid[0]
    for i, itf in self._com_pointers_:
        if i == iid:
            # *ppiunk = &amp;itf
            return CopyComPointer(addressof(itf), ppiunk)
    return E_NOINTERFACE
</t>
<t tx="ekr.20050704170205.157">def AddRef(self, this):
    self._refcnt += 1
    self._factory.LockServer(None, 1)
    return self._refcnt
</t>
<t tx="ekr.20050704170205.158">def Release(self, this):
    self._refcnt -= 1
    self._factory.LockServer(None, 0)
# Later
##        if self._refcnt == 0:
##            import ctypes.com.server
##            ctypes.com.server._active_objects.remove(self)
    return self._refcnt
</t>
<t tx="ekr.20050704170205.159">################################################################

CLSCTX_INPROC_SERVER = 0x1
CLSCTX_LOCAL_SERVER = 0x4

def CreateInstance(coclass, interface=None,
                   clsctx = CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER):
    # Later: docs, docs
    if interface is None:
        interface = coclass._com_interfaces_[0]
    p = POINTER(interface)()
    clsid = GUID(coclass._reg_clsid_)
    ole32.CoCreateInstance(byref(clsid),
                           0,
                           clsctx,
                           byref(interface._iid_),
                           byref(p))
    return p
</t>
<t tx="ekr.20050704170205.160">def CreateGuid():
    # Create a new GUID
    g = GUID()
    ole32.CoCreateGuid(byref(g))
    return g
</t>
<t tx="ekr.20050704170205.161">@ignore
@language python
&lt;&lt; automation declarations &gt;&gt;
@others
if __debug__:
    if __name__ == "__main__":
        print repr(VARIANT("String").value)
        print repr(VARIANT(u"Unicode").value)

        v = VARIANT(False)
        print repr(v.value), v._.VT_BOOL

        v = VARIANT(True)
        print repr(v.value), v._.VT_BOOL

        print VARIANT.optional().value
        print VARIANT().value

        tlb = LoadTypeLibEx(r"c:\windows\system32\shdocvw.dll")
        v = VARIANT(tlb)
        print v.value, (tlb.AddRef(), tlb.Release())
        v.value = tlb
        print v.value, (tlb.AddRef(), tlb.Release())
        v.value = u"-1"
        print v.value, (tlb.AddRef(), tlb.Release())

        v.value = 42
        for i in range(32):
            dst = VARIANT()
            try:
                oleaut32.VariantChangeType(byref(dst), byref(v), 0, i)
            except WindowsError, detail:
                print i, detail
            else:
                try:
                    x = dst.value
                except:
                    pass
                else:
                    print i, repr(dst.value)
</t>
<t tx="ekr.20050704170205.162">import datetime, array

from ctypes import *
from ctypes.wintypes import DWORD, WORD, LPOLESTR, LPCOLESTR, LCID
from ctypes.com import IUnknown, GUID, REFIID, REFGUID, STDMETHOD, HRESULT, \
     COMObject, CopyComPointer
from ctypes.com.hresult import *

from _ctypes import _Pointer

oleaut32 = oledll.oleaut32

################################################################
# types

HREFTYPE = c_ulong

VARTYPE = c_ushort
SCODE = DWORD

################################################################
# typeinfo, typelib and automation data types
#
DISPID = c_long
MEMBERID = DISPID
TYPEKIND = c_int # enum

SYSKIND = c_int # enu

FUNCKIND = c_int # enum
INVKIND = c_int # enum
CALLCONV = c_int # enum

IMPLTYPEFLAGS = c_int

################################################################
# constants
#
REGKIND_DEFAULT = 0
REGKIND_REGISTER = 1
REGKIND_NONE = 2

IMPLTYPEFLAG_FDEFAULT   = 0x1
IMPLTYPEFLAG_FSOURCE      = 0x2
IMPLTYPEFLAG_FRESTRICTED   = 0x4
IMPLTYPEFLAG_FDEFAULTVTABLE   = 0x8

TKIND_ENUM = 0
TKIND_RECORD = 1
TKIND_MODULE = 2
TKIND_INTERFACE = 3
TKIND_DISPATCH = 4
TKIND_COCLASS = 5
TKIND_ALIAS = 6
TKIND_UNION = 7

DISPATCH_METHOD = 0x1
DISPATCH_PROPERTYGET = 0x2
DISPATCH_PROPERTYPUT = 0x4
DISPATCH_PROPERTYPUTREF = 0x8

VAR_PERINSTANCE = 0
VAR_STATIC = 1
VAR_CONST = 2
VAR_DISPATCH = 3

################################################################
# I don't know if it's possible to do BSTR correctly.
#
# For debugging BSTR memory leaks, see
# http://www.distobj.com/comleaks.htm
#  and
# http://support.microsoft.com/default.aspx?scid=KB;en-us;q139071
# Q139071
#
# Apparently the debug version of the ole libraries is no longer
# required starting with windows 2000, and we could implement
# IMallocSpy in Python.
################################################################

################################################################
# Memory mamagement of BSTR is broken.
#
# The way we do them here, it is not possible to transfer the
# ownership of a BSTR instance.  ctypes allocates the memory with
# SysAllocString if we call the constructor with a string, and the
# instance calls SysFreeString when it is destroyed.
# So BSTR's received from dll function calls will never be freed,
# and BSTR's we pass to functions are freed too often ;-(

from _ctypes import _SimpleCData

</t>
<t tx="ekr.20050704170205.163">class BSTR(_SimpleCData):
	&lt;&lt; class BSTR declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.164">_type_ = "X"
</t>
<t tx="ekr.20050704170205.165">def __repr__(self):
    return "%s(%r)" % (self.__class__.__name__, self.value)
</t>
<t tx="ekr.20050704170205.166">
assert(sizeof(BSTR) == 4)

################################################################
# Interfaces declarations
#

DESCKIND = c_int

class ITypeComp(IUnknown):
	&lt;&lt; class ITypeComp declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.167">_iid_ = GUID("{00020403-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.168">class ITypeInfo(IUnknown):
	&lt;&lt; class ITypeInfo declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.169">_iid_ = GUID("{00020401-0000-0000-C000-000000000046}")
             
</t>
<t tx="ekr.20050704170205.170">class ITypeLib(IUnknown):
	&lt;&lt; class ITypeLib declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.171">_iid_ = GUID("{00020402-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.172">class IDispatch(IUnknown):
	&lt;&lt; class IDispatch declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.173">_iid_ = GUID("{00020400-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.174">PIDispatch = POINTER(IDispatch)

################################################################
# VARIANT
"""
/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing
 *  VT_NULL             [V]   [P]     SQL style Null
 *  VT_I2               [V][T][P][S]  2 byte signed int
 *  VT_I4               [V][T][P][S]  4 byte signed int
 *  VT_R4               [V][T][P][S]  4 byte real
 *  VT_R8               [V][T][P][S]  8 byte real
 *  VT_CY               [V][T][P][S]  currency
 *  VT_DATE             [V][T][P][S]  date
 *  VT_BSTR             [V][T][P][S]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S]  IDispatch *
 *  VT_ERROR            [V][T][P][S]  SCODE
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]  VARIANT *
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
 *  VT_RECORD           [V]   [P][S]  user defined type
 *  VT_I1               [V][T][P][s]  signed char
 *  VT_UI1              [V][T][P][S]  unsigned char
 *  VT_UI2              [V][T][P][S]  unsigned short
 *  VT_UI4              [V][T][P][S]  unsigned short
 *  VT_I8                  [T][P]     signed 64-bit int
 *  VT_UI8                 [T][P]     unsigned 64-bit int
 *  VT_INT              [V][T][P][S]  signed machine int
 *  VT_UINT             [V][T]   [S]  unsigned machine int
 *  VT_VOID                [T]        C style void
 *  VT_HRESULT             [T]        Standard return type
 *  VT_PTR                 [T]        pointer type
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]        C style array
 *  VT_USERDEFINED         [T]        user defined type
 *  VT_LPSTR               [T][P]     null terminated string
 *  VT_LPWSTR              [T][P]     wide null terminated string
 *  VT_FILETIME               [P]     FILETIME
 *  VT_BLOB                   [P]     Length prefixed bytes
 *  VT_STREAM                 [P]     Name of the stream follows
 *  VT_STORAGE                [P]     Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
 *  VT_STORED_OBJECT          [P]     Storage contains an object
 *  VT_BLOB_OBJECT            [P]     Blob contains an object 
 *  VT_CF                     [P]     Clipboard format
 *  VT_CLSID                  [P]     A Class ID
 *  VT_VECTOR                 [P]     simple counted array
 *  VT_ARRAY            [V]           SAFEARRAY*
 *  VT_BYREF            [V]           void* for local use
 *  VT_BSTR_BLOB                      Reserved for system use
 */
"""
VT_EMPTY = 0
VT_NULL = 1
VT_I2 = 2
VT_I4 = 3
VT_R4 = 4
VT_R8 = 5
VT_CY = 6
VT_DATE = 7
VT_BSTR = 8
VT_DISPATCH = 9
VT_ERROR = 10
VT_BOOL = 11
VT_VARIANT = 12
VT_UNKNOWN = 13
VT_DECIMAL = 14
VT_I1 = 16
VT_UI1 = 17
VT_UI2 = 18
VT_UI4 = 19
VT_I8 = 20 # not allowed in VARIANT
VT_UI8 = 21 # not allowed in VARIANT
VT_INT = 22
VT_UINT = 23
VT_VOID = 24 # not allowed in VARIANT
VT_HRESULT = 25 # not allowed in VARIANT
VT_PTR = 26 # not allowed in VARIANT
VT_SAFEARRAY = 27 # not allowed in VARIANT
VT_CARRAY = 28 # not allowed in VARIANT
VT_USERDEFINED = 29 # not allowed in VARIANT
VT_LPSTR = 30 # not allowed in VARIANT
VT_LPWSTR = 31 # not allowed in VARIANT
VT_RECORD = 36
VT_FILETIME = 64 # not allowed in VARIANT
VT_BLOB = 65 # not allowed in VARIANT
VT_STREAM = 66 # not allowed in VARIANT
VT_STORAGE = 67 # not allowed in VARIANT
VT_STREAMED_OBJECT = 68 # not allowed in VARIANT
VT_STORED_OBJECT = 69 # not allowed in VARIANT
VT_BLOB_OBJECT = 70 # not allowed in VARIANT
VT_CF = 71 # not allowed in VARIANT
VT_CLSID = 72 # not allowed in VARIANT
VT_BSTR_BLOB = 0xfff # not allowed in VARIANT
VT_VECTOR = 0x1000 # not allowed in VARIANT
VT_ARRAY = 0x2000
VT_BYREF = 0x4000
# VT_RESERVED = 0x8000
# VT_ILLEGAL = 0xffff
# VT_ILLEGALMASKED = 0xfff
VT_TYPEMASK = 0xfff

"""
/* VARIANT STRUCTURE
 *
 *  VARTYPE vt;
 *  WORD wReserved1;
 *  WORD wReserved2;
 *  WORD wReserved3;
 *  union {
 *    LONG           VT_I4
 *    BYTE           VT_UI1
 *    SHORT          VT_I2
 *    FLOAT          VT_R4
 *    DOUBLE         VT_R8
 *    VARIANT_BOOL   VT_BOOL
 *    SCODE          VT_ERROR
 *    CY             VT_CY
 *    DATE           VT_DATE
 *    BSTR           VT_BSTR
 *    IUnknown *     VT_UNKNOWN
 *    IDispatch *    VT_DISPATCH
 *    SAFEARRAY *    VT_ARRAY
 *    BYTE *         VT_BYREF|VT_UI1
 *    SHORT *        VT_BYREF|VT_I2
 *    LONG *         VT_BYREF|VT_I4
 *    FLOAT *        VT_BYREF|VT_R4
 *    DOUBLE *       VT_BYREF|VT_R8
 *    VARIANT_BOOL * VT_BYREF|VT_BOOL
 *    SCODE *        VT_BYREF|VT_ERROR
 *    CY *           VT_BYREF|VT_CY
 *    DATE *         VT_BYREF|VT_DATE
 *    BSTR *         VT_BYREF|VT_BSTR
 *    IUnknown **    VT_BYREF|VT_UNKNOWN
 *    IDispatch **   VT_BYREF|VT_DISPATCH
 *    SAFEARRAY **   VT_BYREF|VT_ARRAY
 *    VARIANT *      VT_BYREF|VT_VARIANT
 *    PVOID          VT_BYREF (Generic ByRef)
 *    CHAR           VT_I1
 *    USHORT         VT_UI2
 *    ULONG          VT_UI4
 *    INT            VT_INT
 *    UINT           VT_UINT
 *    DECIMAL *      VT_BYREF|VT_DECIMAL
 *    CHAR *         VT_BYREF|VT_I1
 *    USHORT *       VT_BYREF|VT_UI2
 *    ULONG *        VT_BYREF|VT_UI4
 *    INT *          VT_BYREF|VT_INT
 *    UINT *         VT_BYREF|VT_UINT
 *  }
 */
"""

VARIANT_BOOL = c_short

PVARIANT = POINTER("VARIANT")

class SAFEARRAYBOUND(Structure):
	&lt;&lt; class SAFEARRAYBOUND declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.175">_fields_ = [("cElements", c_ulong),
            ("lLbound", c_long)]

</t>
<t tx="ekr.20050704170205.176">class VARIANT(Structure):
	@others
    optional = classmethod(optional)</t>
<t tx="ekr.20050704170205.177">class U(Union):
	&lt;&lt; class U declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.178">_fields_ = [("VT_BOOL", c_short),
            ("VT_I1", c_char),
            ("VT_I2", c_short),
            ("VT_I4", c_long),
            ("VT_INT", c_int),
            ("VT_R4", c_float),
            ("VT_R8", c_double),
            ("VT_SCODE", c_ulong),
            ("VT_UI1", c_byte),
            ("VT_UI2", c_ushort),
            ("VT_UI4", c_ulong),
            ("VT_UINT", c_uint),

            ("pvarVal", PVARIANT),

            # These fields are not defined or used, accessing
            # them is too dangerous.  We simply copy COM
            # pointers out and in with the CopyComPointer
            # function, and for BSTR we use the faked
            # c_wchar_p field, and call SysAllocString
            # outselves.
            #("VT_DISPATCH", POINTER(IDispatch)),
            #("VT_UNKNOWN", POINTER(IUnknown)),
            ##("VT_BSTR", BSTR),

            # faked fields, only for our convenience:
            ("wstrVal", c_wchar_p),
            ("bstrVal", BSTR),
            ("voidp", c_void_p),
            ]
</t>
<t tx="ekr.20050704170205.179">_fields_ = [("vt", VARTYPE),
            ("wReserved1", c_ushort),
            ("wReserved2", c_ushort),
            ("wReserved3", c_ushort),
            ("_", U)]

# we want to be able to create uninitialized VARIANTs, but we also
# want to create them with None as argument.
def __init__(self, *args):
    if args[1:]:
        raise TypeError, "__init__() takes at most 2 arguments (%d given)" % (len(args) + 1)
    if args:
        self.value = args[0]
</t>
<t tx="ekr.20050704170205.180"># 30. December 1899, midnight.
_com_null_date = datetime.datetime(1899, 12, 31, 0, 0, 0)

def _set_value(self, value):
    oleaut32.VariantClear(byref(self))
    typ = type(value)
    if typ is long:
        # try to convert to int
        value = int(value)
        typ = type(value)

    if typ is int:
        self.vt = VT_I4
        self._.VT_I4 = value
    elif typ in (float, long):
        self.vt = VT_R8
        self._.VT_R8 = float(value)
    elif typ is str:
        self.vt = VT_BSTR
        value = unicode(value)
        self._.voidp = oleaut32.SysAllocStringLen(value, len(value))
    elif typ is unicode:
        self.vt = VT_BSTR
        self._.voidp = oleaut32.SysAllocStringLen(value, len(value))
    elif value is None:
        return
    elif typ is array.array:
        TYPECODE = {
            "d": (VT_R8, c_double),
            "f": (VT_R4, c_float),
            "l": (VT_I4, c_long),
            "i": (VT_INT, c_int),
            "h": (VT_I2, c_short),
            "b": (VT_I1, c_byte),
            "I": (VT_UINT, c_uint),
            "L": (VT_UI4, c_ulong),
            "H": (VT_UI2, c_ushort),
            "B": (VT_UI1, c_ubyte),
            }
        vt, itemklass = TYPECODE[value.typecode]
        sab = SAFEARRAYBOUND(len(value), 0)
        psa = oleaut32.SafeArrayCreate(vt, 1, byref(sab))
        ix = c_long()
        item = itemklass()
        for index, v in enumerate(value):
            ix.value = index
            item.value = v
            oleaut32.SafeArrayPutElement(psa, byref(ix), byref(item))
        self._.VT_I4 = psa
        self.vt = VT_ARRAY | vt
    elif typ is bool:
        self.vt = VT_BOOL
        self._.VT_BOOL = value and -1 or 0
    elif typ is POINTER(IDispatch) \
             or isinstance(value, _Pointer) and issubclass(typ._type_, IDispatch):
        # It is a POINTER(IDispatch or IDispatch subclass)
        CopyComPointer(value, byref(self._))
        self.vt = VT_DISPATCH
    elif typ is POINTER(IUnknown) \
             or isinstance(value, _Pointer) and issubclass(typ._type_, IUnknown):
        # It is a POINTER(IUnknown or IUnknown subclass)
        CopyComPointer(value, byref(self._))
        self.vt = VT_UNKNOWN
    elif typ is datetime.datetime:
        delta = value - self._com_null_date
        # a day has 24 * 60 * 60 = 86400 seconds
        com_days = delta.days + (delta.seconds + delta.microseconds * 1e-6) / 86400.
        self.vt = VT_DATE
        self._.VT_R8 = com_days
    else:
        raise TypeError, "don't know how to store %r in a VARIANT" % value
</t>
<t tx="ekr.20050704170205.181">def _get_value(self):
    if self.vt == VT_EMPTY:
        return None
    elif self.vt == VT_I1:
        return self._.VT_I1
    elif self.vt == VT_I2:
        return self._.VT_I2
    elif self.vt == VT_I4:
        return self._.VT_I4
    elif self.vt == VT_UI1:
        return self._.VT_UI1
    elif self.vt == VT_UI2:
        return self._.VT_UI2
    elif self.vt == VT_UI4:
        return self._.VT_UI4
    elif self.vt == VT_INT:
        return self._.VT_INT
    elif self.vt == VT_UINT:
        return self._.VT_UINT
    elif self.vt == VT_R4:
        return self._.VT_R4
    elif self.vt == VT_R8:
        return self._.VT_R8
    elif self.vt == VT_BSTR:
        # NULL BSTR count as empty strings, not None!
##            return self._.wstrVal or u''
        return self._.bstrVal or u''
    # The following code can be enabled again when all the POINTER(ISomeInterface)
    # classes have a constructor that calls AddRef() if not-null.
##        elif self.vt == VT_UNKNOWN:
##            return self._.VT_UNKNOWN
##        elif self.vt == VT_DISPATCH:
##            return self._.VT_DISPATCH
    elif self.vt == VT_UNKNOWN:
        p = POINTER(IUnknown)()
        CopyComPointer(self._.voidp, byref(p))
        return p
    elif self.vt == VT_DISPATCH:
        p = POINTER(IDispatch)()
        CopyComPointer(self._.voidp, byref(p))
        return p

    elif self.vt == VT_BOOL:
        return bool(self._.VT_BOOL)

    # see also c:/sf/pywin32/com/win32com/src/oleargs.cpp
    elif self.vt == VT_BYREF|VT_VARIANT:
        return self._.pvarVal[0].value
        # same as the line above, faster, but less readable?
        # v = self
        # while v.vt == VT_BYREF|VT_VARIANT:
        #    v = v._.pvarVal[0]
        # return v.value
    elif self.vt &amp; VT_BYREF:
        v = VARIANT()
        oleaut32.VariantCopyInd(byref(v), byref(self))
        return v.value
    elif self.vt == VT_ERROR:
        return ("Error", self._.VT_SCODE)
    elif self.vt == VT_NULL:
        return None
    elif self.vt == VT_DATE:
        days = self._.VT_R8
        return datetime.timedelta(days=days) + self._com_null_date
        raise "NYI"
    elif self.vt &amp; VT_ARRAY:
        TYPECODE = {
            VT_R8: c_double,
            VT_R4: c_float,
            VT_I4: c_long,
            VT_INT: c_int,
            VT_I2: c_short,
            VT_I1: c_byte,
            VT_UI4: c_ulong,
            VT_UINT: c_uint,
            VT_UI2: c_ushort,
            VT_UI1: c_ubyte,
            }

        # idea: use a LONG array (array.array('l')
        # to specify indices?
        # requires buffer support for function calls
        psa = self._.VT_I4
        dim = oleaut32.SafeArrayGetDim(psa)
        assert dim == 1
        lb, ub = c_long(), c_long()
        oleaut32.SafeArrayGetLBound(psa, 1, byref(lb))
        oleaut32.SafeArrayGetUBound(psa, 1, byref(ub))
        ix = c_long()
        data = TYPECODE[self.vt &amp; ~VT_ARRAY]()
        result = []
        for i in range(lb.value, ub.value+1):
            ix.value = i
            oleaut32.SafeArrayGetElement(psa, byref(ix), byref(data))
            result.append(data.value)
        return result
    else:
        raise TypeError, "don't know how to convert typecode %d" % self.vt
</t>
<t tx="ekr.20050704170205.182">    # not yet done:
    # VT_ARRAY
    # VT_CY
    # VT_DATE

value = property(_get_value, _set_value)

def __repr__(self):
    return "&lt;VARIANT 0x%X at %x&gt;" % (self.vt, addressof(self))
</t>
<t tx="ekr.20050704170205.183">##    _owned = True

##    # We must do this manually, BUT ONLY if we own the VARIANT
##    def __del__(self, _clear = oleaut32.VariantClear):
##        if self._owned:
##            _clear(byref(self))

##    def own(self, how):
##        self._owned = how

def optional(cls):
    var = VARIANT()
    var.vt = VT_ERROR
    var._.VT_SCODE = 0x80020004L
    return var
</t>
<t tx="ekr.20050704170205.184">

SetPointerType(PVARIANT, VARIANT)

assert(sizeof(VARIANT) == 16)

################################################################

class DISPPARAMS(Structure):
	&lt;&lt; class DISPPARAMS declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.185">_fields_ = [("rgvarg", POINTER(VARIANT)),
            ("rgdispidNamedArgs", POINTER(DISPID)),
            ("cArgs", c_uint),
            ("cNamedArgs", c_uint)]
</t>
<t tx="ekr.20050704170205.186">assert(sizeof(DISPPARAMS) == 16)

# c:/vc98/include/oaidl.h

class EXCEPINFO(Structure):
	&lt;&lt; class EXCEPINFO declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.187">_fields_ = [("wCode", c_ushort),
            ("wReserved", c_ushort),
            ("bstrSource", BSTR),
            ("bstrDescription", BSTR),
            ("bstrHelpFile", BSTR),
            ("dwHelpContext", DWORD),
            ("pvReserved", c_void_p),
            ("pfnDeferredFillIn", c_int), # XXX
##                ("scode", SCODE)]
            ("scode", c_long)]
</t>
<t tx="ekr.20050704170205.188">def as_tuple(self):
    return (self.wCode, self.bstrSource, self.bstrDescription,
            self.bstrHelpFile, self.dwHelpContext, self.scode)
</t>
<t tx="ekr.20050704170205.189">assert(sizeof(EXCEPINFO) == 32)

class TLIBATTR(Structure):
	&lt;&lt; class TLIBATTR declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.190">_fields_ = [("guid", GUID),
            ("lcid", LCID),
            ("syskind", SYSKIND),
            ("wMajorVerNum", WORD),
            ("wMinorVerNum", WORD),
            ("wLibFlags", WORD)]
</t>
<t tx="ekr.20050704170205.191">assert(sizeof(TLIBATTR) == 32), sizeof(TLIBATTR)
LPTLIBATTR = POINTER(TLIBATTR)

class PARAMDESCEX(Structure):
	&lt;&lt; class PARAMDESCEX declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.192">_fields_ = [("cBytes", c_ulong),
            ("varDefaultValue", VARIANT)]
</t>
<t tx="ekr.20050704170205.193">assert(sizeof(PARAMDESCEX) == 24)
    
class PARAMDESC(Structure):
	&lt;&lt; class PARAMDESC declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.194">_fields_ = [("pPARAMDescEx", POINTER(PARAMDESCEX)),
            ("wPARAMFlags", WORD)]
</t>
<t tx="ekr.20050704170205.195">assert sizeof(PARAMDESC) == 8

LPTYPEDESC = POINTER("TYPEDESC")
LPADESC = POINTER("ARRAYDESC")

class TYPEDESC(Structure):
	@others
    _fields_ = [("u", U),
                ("vt", VARTYPE)]</t>
<t tx="ekr.20050704170205.196">class U(Union):
	&lt;&lt; class U declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.197">_fields_ = [("lptdesc", LPTYPEDESC),
            ("lpadesc", LPADESC),
            ("hreftype", HREFTYPE)]
</t>
<t tx="ekr.20050704170205.198">
assert(sizeof(TYPEDESC) == 8), sizeof(TYPEDESC)

class ARRAYDESC(Structure):
	&lt;&lt; class ARRAYDESC declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.199">_fields_ = [("tdescElem", TYPEDESC),
            ("cDims", c_ushort),
            # XXX Variable length array containing one element for
            # each dimension
            #
            # Hack: We limit ourself to 8-dimensional arrays,
            # and client code must make sure it doesn't access more than
            # cDims elements in this array.
            ("rgbounds", c_int * 8)]

</t>
<t tx="ekr.20050704170205.200">LPADESC.set_type(ARRAYDESC)
LPTYPEDESC.set_type(TYPEDESC)

class IDLDESC(Structure):
	&lt;&lt; class IDLDESC declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.201">_fields_ = [("dwReserved", c_ulong),
            ("wIDLFlags", c_ushort)]
</t>
<t tx="ekr.20050704170205.202">assert(sizeof(IDLDESC) == 8)

class TYPEATTR(Structure):
	&lt;&lt; class TYPEATTR declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.203">_fields_ = [("guid", GUID),
            ("lcid", LCID),
            ("dwReserved", c_ulong),
            ("memidConstructor", MEMBERID),
            ("memidDestructor", MEMBERID),
            ("lpstrSchema", c_wchar_p),
            ("cbSizeInstance", c_ulong),
            ("typekind", TYPEKIND),
            ("cFuncs", c_ushort),
            ("cVars", c_ushort),
            ("cImplTypes", c_ushort),
            ("cbSizeVft", c_ushort),
            ("cbAlignment", c_ushort),
            ("wTypeFlags", c_ushort),
            ("wMajorVerNum", c_ushort),
            ("wMinorVerNum", c_ushort),
            ("tdescAlias", TYPEDESC),
            ("idldescType", IDLDESC),
            ]
</t>
<t tx="ekr.20050704170205.204">LPTYPEATTR = POINTER(TYPEATTR)
assert(sizeof(TYPEATTR) == 76)

class ELEMDESC(Structure):
	&lt;&lt; class ELEMDESC declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.205">_fields_ = [("tdesc", TYPEDESC),
            ("paramdesc", PARAMDESC)]
</t>
<t tx="ekr.20050704170205.206">assert(sizeof(ELEMDESC) == 16)

VARKIND = c_int # enum

class VARDESC(Structure):
	@others
    _fields_ = [("memid", MEMBERID),
                ("strSchema", c_wchar_p),
                ("u", U),
                ("elemdescVar", ELEMDESC),
                ("wVarFlags", c_ushort),
                ("varkind", VARKIND)]</t>
<t tx="ekr.20050704170205.207">class U(Union):
	&lt;&lt; class U declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.208">_fields_ = [("oInst", c_ulong),
            ("lpvarValue", POINTER(VARIANT))]
</t>
<t tx="ekr.20050704170205.209">
LPVARDESC = POINTER(VARDESC)
assert(sizeof(VARDESC) == 36)

class FUNCDESC(Structure):
	&lt;&lt; class FUNCDESC declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.210">_fields_ = [("memid", MEMBERID),
            ("lprgscode", POINTER(SCODE)),
            ("lprgelemdescParam", POINTER(ELEMDESC)),
            ("funckind", FUNCKIND),
            ("invkind", INVKIND),
            ("callconv", CALLCONV),
            ("cParams", c_short),
            ("cParamsOpt", c_short),
            ("oVft", c_short),
            ("cScodes", c_short),
            ("elemdescFunc", ELEMDESC),
            ("wFuncFlags", WORD)]
</t>
<t tx="ekr.20050704170205.211">LPFUNCDESC = POINTER(FUNCDESC)
assert(sizeof(FUNCDESC) == 52), sizeof(FUNCDESC)

class BINDPTR(Union):
	&lt;&lt; class BINDPTR declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.212">_fields_ = [("lpfuncdesc", POINTER(FUNCDESC)),
            ("lpvardesc", POINTER(VARDESC)),
            ("lptcomp", POINTER(ITypeComp))]

# For CreateDispTypeInfo

##from ctypes import c_ushort, c_int, c_uint, c_long, c_wchar_p, Structure

##VARTYPE = c_int # enum
##DISPID = c_long
##CALLCONV = c_int

##class PARAMDATA(Structure):
##    _fields_ = [("szName", c_wchar_p),
##                ("vt", VARTYPE)]

##class METHODDATA(Structure):
##    _fields_ = [("szName", c_wchar_p),
##                ("ppdata", POINTER(PARAMDATA)),
##                ("dispid", DISPID),
##                ("iMeth", c_uint),
##                ("cc", CALLCONV),
##                ("cArgs", c_uint),
##                ("wFlags", c_ushort),
##                ("vtReturn", VARTYPE)]

##class INTERFACEDATA(Structure):
##    _fields_ = [("pmethdata", POINTER(METHODDATA)),
##                ("cMembers", c_uint)]


################################################################
# The interfaces COM methods

</t>
<t tx="ekr.20050704170205.213">ITypeComp._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Bind", c_wchar_p, c_ulong, c_short,
              POINTER(POINTER(ITypeInfo)), POINTER(DESCKIND), POINTER(BINDPTR)),
    STDMETHOD(HRESULT, "BindType", c_wchar_p, c_ulong,
              POINTER(POINTER(ITypeInfo)), POINTER(POINTER(ITypeComp)))]

ITypeInfo._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetTypeAttr", POINTER(LPTYPEATTR)),
    STDMETHOD(HRESULT, "GetTypeComp", POINTER(POINTER(ITypeComp))),
    STDMETHOD(HRESULT, "GetFuncDesc", c_uint,  POINTER(POINTER(FUNCDESC))),
    STDMETHOD(HRESULT, "GetVarDesc", c_uint, POINTER(POINTER(VARDESC))),
    STDMETHOD(HRESULT, "GetNames", MEMBERID, POINTER(BSTR), c_uint, POINTER(c_uint)),
    STDMETHOD(HRESULT, "GetRefTypeOfImplType", c_uint, POINTER(HREFTYPE)),
    STDMETHOD(HRESULT, "GetImplTypeFlags", c_uint, POINTER(IMPLTYPEFLAGS)),
    STDMETHOD(HRESULT, "GetIDsOfNames", POINTER(LPOLESTR), c_uint, POINTER(c_int)),
    STDMETHOD(HRESULT, "Invoke", POINTER(IUnknown), MEMBERID, WORD, POINTER(DISPPARAMS),
              POINTER(VARIANT), POINTER(EXCEPINFO), POINTER(c_uint)),
    STDMETHOD(HRESULT, "GetDocumentation", MEMBERID, POINTER(BSTR), POINTER(BSTR),
              POINTER(c_ulong), POINTER(BSTR)),
    STDMETHOD(HRESULT, "GetDllEntry", MEMBERID, c_int, POINTER(BSTR), POINTER(BSTR),
              POINTER(c_ushort)),
    STDMETHOD(HRESULT, "GetRefTypeInfo", HREFTYPE, POINTER(POINTER(ITypeInfo))),
    STDMETHOD(HRESULT, "AddressOfMember", MEMBERID, c_int, POINTER(c_void_p)),
    STDMETHOD(HRESULT, "CreateInstance", c_void_p, REFIID, POINTER(POINTER(IUnknown))),
    STDMETHOD(HRESULT, "GetMops", MEMBERID, POINTER(BSTR)),
    STDMETHOD(HRESULT, "GetContainingTypeLib", POINTER(POINTER(ITypeLib)), POINTER(c_uint)),
    STDMETHOD(HRESULT, "ReleaseTypeAttr", LPTYPEATTR),
    STDMETHOD(HRESULT, "ReleaseFuncDesc", LPFUNCDESC),
    STDMETHOD(HRESULT, "ReleaseVarDesc", LPVARDESC)]

ITypeLib._methods_ = IUnknown._methods_ + [
    STDMETHOD(c_uint, "GetTypeInfoCount"),
    STDMETHOD(HRESULT, "GetTypeInfo", c_uint, POINTER(POINTER(ITypeInfo))),
    STDMETHOD(HRESULT, "GetTypeInfoType", c_int, POINTER(TYPEKIND)),
    STDMETHOD(HRESULT, "GetTypeInfoOfGuid", REFGUID, POINTER(POINTER(ITypeInfo))),
    STDMETHOD(HRESULT, "GetLibAttr", POINTER(POINTER(TLIBATTR))),
    STDMETHOD(HRESULT, "GetTypeComp", POINTER(POINTER(ITypeComp))),
    STDMETHOD(HRESULT, "GetDocumentation", c_int, POINTER(BSTR), POINTER(BSTR),
              POINTER(c_ulong), POINTER(BSTR)),
    STDMETHOD(HRESULT, "IsName", c_wchar_p, c_ulong, c_int),
    STDMETHOD(HRESULT, "FindName", c_wchar_p, c_ulong, POINTER(POINTER(ITypeInfo)),
              POINTER(MEMBERID), POINTER(c_uint)),
    STDMETHOD(HRESULT, "ReleaseTLibAttr", POINTER(TLIBATTR))]

IDispatch._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetTypeInfoCount", POINTER(c_uint)),
    STDMETHOD(HRESULT, "GetTypeInfo", c_uint, LCID, POINTER(POINTER(ITypeInfo))),
    STDMETHOD(HRESULT, "GetIDsOfNames", REFIID, POINTER(c_wchar_p), c_uint,
              LCID, POINTER(DISPID)),
    STDMETHOD(HRESULT, "Invoke", DISPID, REFIID, LCID, WORD, POINTER(DISPPARAMS),
              POINTER(VARIANT), POINTER(EXCEPINFO), POINTER(c_uint))]

class IProvideClassInfo(IUnknown):
	&lt;&lt; class IProvideClassInfo declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.214">_iid_ = GUID("{B196B283-BAB4-101A-B69C-00AA00341D07}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetClassInfo", POINTER(POINTER(ITypeInfo)))]

</t>
<t tx="ekr.20050704170205.215">class IProvideClassInfo2(IProvideClassInfo):
	&lt;&lt; class IProvideClassInfo2 declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.216">_iid_ = GUID("{A6BC3AC0-DBAA-11CE-9DE3-00AA004BB851}")
_methods_ = IProvideClassInfo._methods_ + [
    STDMETHOD(HRESULT, "GetGUID", DWORD, POINTER(GUID))]

################################################################
# functions
#

</t>
<t tx="ekr.20050704170205.217">def LoadTypeLib(fnm):
    p = POINTER(ITypeLib)()
    oleaut32.LoadTypeLib(unicode(fnm), byref(p))
    return p
</t>
<t tx="ekr.20050704170205.218">def LoadTypeLibEx(fnm, regkind=REGKIND_NONE):
    p = POINTER(ITypeLib)()
    oleaut32.LoadTypeLibEx(unicode(fnm), regkind, byref(p))
    return p
</t>
<t tx="ekr.20050704170205.219">def LoadRegTypeLib(guid, wVerMajor, wVerMinor, lcid=0):
    p = POINTER(ITypeLib)()
    oleaut32.LoadRegTypeLib(byref(guid), wVerMajor, wVerMinor, lcid, byref(p))
    return p
</t>
<t tx="ekr.20050704170205.220">
################################################################

class DualObjImpl(COMObject):
	@others
</t>
<t tx="ekr.20050704170205.221">def __init__(self):
    COMObject.__init__(self)
    try:
        self.LoadTypeInfo()
    except WindowsError:
        # Do we want to see the exception? Not clear...
        import traceback
        traceback.print_exc()
        # continue without typeinfo
        self.typeinfo = None
</t>
<t tx="ekr.20050704170205.222">def LoadTypeInfo(self):
    interface = self._com_interfaces_[0]
    tlib = LoadRegTypeLib(self._typelib_.guid,
                          self._typelib_.version[0],
                          self._typelib_.version[1])
    typeinfo = POINTER(ITypeInfo)()
    tlib.GetTypeInfoOfGuid(byref(interface._iid_), byref(typeinfo))
    self.typeinfo = typeinfo
</t>
<t tx="ekr.20050704170205.223"># IDispatch methods

def GetIDsOfNames(self, this, riid, rgszNames, cNames, lcid, rgDispid):
    if self.typeinfo is None:
        return E_NOTIMPL
    # We use windll.oleaut32 instead of oledll.oleaut32 because
    # we don't want an exception here, instead we pass the returned HRESULT
    # value to the caller.
    return windll.oleaut32.DispGetIDsOfNames(self.typeinfo, rgszNames,
                                             cNames, rgDispid)
</t>
<t tx="ekr.20050704170205.224">def Invoke(self, this, dispid, refiid, lcid, wFlags,
           pDispParams, pVarResult, pExcepInfo, puArgErr):
    if self.typeinfo is None:
        return E_NOTIMPL
    # See the comment in GetIDsOfNames
    return windll.oleaut32.DispInvoke(this, self.typeinfo, dispid,
                                      wFlags, pDispParams,
                                      pVarResult, pExcepInfo, puArgErr)
</t>
<t tx="ekr.20050704170205.225">def GetTypeInfoCount(self, this, pctInfo):
    if pctInfo:
        pctInfo[0] = self.typeinfo is not None
    return S_OK
</t>
<t tx="ekr.20050704170205.226">def GetTypeInfo(self, this, index, lcid, ppTInfo):
    if self.typeinfo is None:
        return E_NOTIMPL
    # *ppTInfo = self.typeinfo
    return CopyComPointer(self.typeinfo, ppTInfo)
</t>
<t tx="ekr.20050704170205.227">
################################################################
# The following two are used by the readtlb tool

class dispinterface(IDispatch):
	@others
</t>
<t tx="ekr.20050704170205.228">class __metaclass__(type(IDispatch)):
	@others
</t>
<t tx="ekr.20050704170205.229">def __setattr__(self, name, value):
    if name == '_dispmethods_':
        dispmap = {}
        for dispid, mthname, proto in value:
            dispmap[dispid] = mthname
        setattr(self, '_methods_', IDispatch._methods_)
        type(IDispatch).__setattr__(self, '_dispmap_', dispmap)
    type(IDispatch).__setattr__(self, name, value)
</t>
<t tx="ekr.20050704170205.230">def DISPMETHOD(dispid, restype, name, *argtypes):
    return dispid, name, STDMETHOD(HRESULT, name, *argtypes)
</t>
<t tx="ekr.20050704170205.231">
################################################################
# some more automation COM interfaces
class IEnumVARIANT(IUnknown):
	&lt;&lt; class IEnumVARIANT declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.232">_iid_ = GUID("{00020404-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.233">IEnumVARIANT._methods_ = IUnknown._methods_ + [
        STDMETHOD(HRESULT, "Next", c_ulong, POINTER(VARIANT), POINTER(c_ulong)),
        STDMETHOD(HRESULT, "Skip", c_ulong),
        STDMETHOD(HRESULT, "Reset"),
        STDMETHOD(HRESULT, "Clone", POINTER(POINTER(IEnumVARIANT)))
        ]

class IErrorLog(IUnknown):
	&lt;&lt; class IErrorLog declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.234">_iid_ = GUID("{3127CA40-446E-11CE-8135-00AA004BB851}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "AddError", LPCOLESTR, POINTER(EXCEPINFO))
    ]

################################################################
# test code

</t>
<t tx="ekr.20050704170205.235">@ignore
@language python
&lt;&lt; client declarations &gt;&gt;
@others


################################################################
</t>
<t tx="ekr.20050704170205.236">"""
Dispatch(progid, interface, clsctx
"""
import inspect

from ctypes import *
from ctypes.com import IUnknown, GUID, CreateInstance, CLSCTX_LOCAL_SERVER, \
     CLSCTX_INPROC_SERVER, ole32, STDMETHOD, HRESULT, COMObject
from ctypes.com.hresult import *
from ctypes.com.automation import IDispatch, ITypeInfo, ITypeComp, VARIANT, DISPPARAMS, \
     IEnumVARIANT, EXCEPINFO, DISPID, ITypeLib, IProvideClassInfo2
from ctypes.com.automation import BINDPTR, DESCKIND
from ctypes.com.connectionpoints import IConnectionPointContainer, IConnectionPoint, \
     IEnumConnectionPoints


################################################################

DISPATCH_METHOD = 0x1
DISPATCH_PROPERTYGET = 0x2
DISPATCH_PROPERTYPUT = 0x4
DISPATCH_PROPERTYPUTREF = 0x8

FUNC_VIRTUAL = 0
FUNC_PUREVIRTUAL = FUNC_VIRTUAL + 1
FUNC_NONVIRTUAL = FUNC_PUREVIRTUAL + 1
FUNC_STATIC = FUNC_NONVIRTUAL + 1
FUNC_DISPATCH = FUNC_STATIC + 1

DESCKIND_FUNCDESC = 1
DESCKIND_VARDESC = 2
DESCKIND_TYPECOMP = 3

DISPID_PROPERTYPUT = -3

guid_null = GUID()

################################################################

</t>
<t tx="ekr.20050704170205.237">def _wrap(variant):
    if variant.vt == 9: # VT_DISPATCH
        result = variant.value
        if result:
            return _Dispatch(result)
        return None
    return variant.value
</t>
<t tx="ekr.20050704170205.238">def _unwrap(x):
    if isinstance(x, _Dispatch):
        return x._comobj
    if isinstance(x, COMObject):
        ptr = POINTER(IUnknown)()
        x.QueryInterface(None, pointer(IUnknown._iid_), byref(ptr))
        return ptr
    return x
</t>
<t tx="ekr.20050704170205.239">
################################################################

class _funcdesc(object):
	&lt;&lt; class _funcdesc declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.240">    # FUNCDESC wrapper which will eventually release the funcdesc via
    # the supplied typeinfo interface
</t>
<t tx="ekr.20050704170205.241">def __init__(self, fd, ti):
    self.fd = fd
    self.ti = ti
</t>
<t tx="ekr.20050704170205.242">def __getattr__(self, name):
    return getattr(self.fd, name)
</t>
<t tx="ekr.20050704170205.243">def __del__(self):
    self.ti.ReleaseFuncDesc(byref(self.fd))
</t>
<t tx="ekr.20050704170205.244">
from ctypes.com.automation import TYPEATTR, HREFTYPE, IMPLTYPEFLAGS
from ctypes.com.automation import IMPLTYPEFLAG_FSOURCE, IMPLTYPEFLAG_FDEFAULT, TKIND_DISPATCH

################################################################
# Convenience functions, simplyfing code quite a bit

class _typeattr(object):
	&lt;&lt; class _typeattr declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.245">    # TYPEATTR wrapper which will eventually release the typeattr via
    # the supplied typeinfo interface
</t>
<t tx="ekr.20050704170205.246">def __init__(self, ta, ti):
    self.ta = ta
    self.ti = ti
</t>
<t tx="ekr.20050704170205.247">def __getattr__(self, name):
    return getattr(self.ta, name)
</t>
<t tx="ekr.20050704170205.248">def __del__(self):
    self.ti.ReleaseTypeAttr(byref(self.ta))
</t>
<t tx="ekr.20050704170205.249">################
def GetTypeInfo(disp, index=0, lcid=0):
    ti = POINTER(ITypeInfo)()
    disp.GetTypeInfo(index, lcid, byref(ti))
    return ti
</t>
<t tx="ekr.20050704170205.250">def GetContainingTypeLib(typeinfo):
    tlb = POINTER(ITypeLib)()
    typeinfo.GetContainingTypeLib(byref(tlb), None)
    return tlb
</t>
<t tx="ekr.20050704170205.251">def GetTypeInfoOfGuid(typelib, clsid):
    ti = POINTER(ITypeInfo)()
    typelib.GetTypeInfoOfGuid(byref(clsid), byref(ti))
    return ti
</t>
<t tx="ekr.20050704170205.252">def GetTypeAttr(typeinfo):
    pta = POINTER(TYPEATTR)()
    typeinfo.GetTypeAttr(byref(pta))
    return _typeattr(pta[0], typeinfo)
</t>
<t tx="ekr.20050704170205.253">def GetImplTypeFlags(typeinfo, index):
    flags = IMPLTYPEFLAGS()
    typeinfo.GetImplTypeFlags(index, byref(flags))
    return flags.value
</t>
<t tx="ekr.20050704170205.254">def GetRefTypeInfo(typeinfo, index):
    hr = HREFTYPE()
    typeinfo.GetRefTypeOfImplType(index, byref(hr))
    ti = POINTER(ITypeInfo)()
    typeinfo.GetRefTypeInfo(hr, byref(ti))
    return ti
</t>
<t tx="ekr.20050704170205.255">def QueryInterface(obj, interface):
    ptr = POINTER(interface)()
    obj.QueryInterface(byref(interface._iid_), byref(ptr))
    return ptr
</t>
<t tx="ekr.20050704170205.256">def EnumConnectionPoints(container):
    ecp = POINTER(IEnumConnectionPoints)()
    container.EnumConnectionPoints(byref(ecp))
    return ecp
</t>
<t tx="ekr.20050704170205.257">def GetConnectionInterface(cp):
    guid = GUID()
    cp.GetConnectionInterface(byref(guid))
    return guid
</t>
<t tx="ekr.20050704170205.258">def Next(enum):
    cp = POINTER(IConnectionPoint)()
    if S_OK != enum.Next(1, byref(cp), None):
        raise StopIteration # ??? make the IEnumXXX pointer classes iterators themselves?
    return cp
</t>
<t tx="ekr.20050704170205.259">def GetTypeComp(tlb):
    tc = POINTER(ITypeComp)()
    tlb.GetTypeComp(byref(tc))
    return tc
</t>
<t tx="ekr.20050704170205.260">
################################################################

class COMError(WindowsError):
	@others
</t>
<t tx="ekr.20050704170205.261">def __init__(self, *args):
    WindowsError.__init__(self, *args)
    self.args = args
</t>
<t tx="ekr.20050704170205.262">def __str__(self):
    return str(self.args)
</t>
<t tx="ekr.20050704170205.263">
################################################################

class _Constants(object):
	@others
</t>
<t tx="ekr.20050704170205.264">def __init__(self, ti):
    tlb = GetContainingTypeLib(ti)
    self.__tc = GetTypeComp(tlb)
</t>
<t tx="ekr.20050704170205.265">def __getattr__(self, name):
    bp = BINDPTR()
    dk = DESCKIND()
    ti = POINTER(ITypeInfo)()
    self.__tc.Bind(unicode(name),
                   0,
                   0,
                   byref(ti),
                   byref(dk),
                   byref(bp))
    if dk.value != DESCKIND_VARDESC:
        raise AttributeError, name
    vd = bp.lpvardesc[0]
    result = vd.u.lpvarValue[0].value
    ti.ReleaseVarDesc(bp.lpvardesc)
    return result
</t>
<t tx="ekr.20050704170205.266">

# For *some* info about the usage of the ITypeComp interface,
# see Inside OLE, 2nd edition: Chapter 3

# There's also a quite useful document at
# http://aromakiki.ismyweb.net/doc/S1227.htm

class _InvokeMixin(object):
	@others
</t>
<t tx="ekr.20050704170205.267">def _do_invoke(self, memid, invkind, parms):
    result = VARIANT()
    excepinfo = EXCEPINFO()
    uArgError = c_uint()
    try:
        self._comobj.Invoke(memid,
                            byref(guid_null),
                            0, # LCID
                            invkind,
                            byref(parms),
                            byref(result), # pVarResult
                            byref(excepinfo), # pExcepInfo
                            byref(uArgError)) # puArgError
    except WindowsError, what:
        assert excepinfo.pfnDeferredFillIn == 0
        raise COMError(what.errno, what.strerror, excepinfo.as_tuple(), uArgError.value)
    return result
</t>
<t tx="ekr.20050704170205.268">
class _Dispatch(_InvokeMixin):
	&lt;&lt; class _Dispatch declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.269"># these are to silence pychecker
_comobj = None
_typecomp = None

##    def __del__(self):
##        if self._connection is not None:
####            print "disconnecting...", self._connection
##            self._connection()
####            print "...disconnected"

</t>
<t tx="ekr.20050704170205.270">def __init__(self, comobj, typeinfo=None):
    self.__dict__["_comobj"] = comobj

    if typeinfo is None:
        typeinfo = GetTypeInfo(comobj)
    tc = QueryInterface(typeinfo, ITypeComp)
    self.__dict__["_typecomp"] = tc
    self.__dict__["_constants_"] = _Constants(typeinfo)
</t>
<t tx="ekr.20050704170205.271">def _get_funcdesc(self, name, flags):
    bp = BINDPTR()
    dk = DESCKIND()
    ti = POINTER(ITypeInfo)()
    self._typecomp.Bind(unicode(name),
                       0,
                       flags,
                       byref(ti),
                       byref(dk),
                       byref(bp))
    if dk.value != DESCKIND_FUNCDESC:
        return None
    fd = bp.lpfuncdesc[0]
##        assert fd.funckind == FUNC_DISPATCH
    return _funcdesc(fd, ti)
</t>
<t tx="ekr.20050704170205.272">def __prop_get(self, memid):
    result = self._do_invoke(memid, DISPATCH_PROPERTYGET, DISPPARAMS())
    return _wrap(result)
</t>
<t tx="ekr.20050704170205.273">def __prop_put(self, memid, value):
    parms = DISPPARAMS()
    parms.rgvarg = pointer(VARIANT(value))
    parms.rgdispidNamedArgs = pointer(DISPID(DISPID_PROPERTYPUT))
    parms.cArgs = 1
    parms.cNamedArgs = 1
    self._do_invoke(memid, DISPATCH_PROPERTYPUT, parms)
</t>
<t tx="ekr.20050704170205.274">def __setattr__(self, name, value):
    fd = self._get_funcdesc(name, DISPATCH_PROPERTYPUT) # | DISPATCH_PROPERTYPUTREF)
    if fd is None:
        raise AttributeError, name
    assert fd.cParams == 1
    self.__prop_put(fd.memid, _unwrap(value))
</t>
<t tx="ekr.20050704170205.275">def __getattr__(self, name):
    fd = self._get_funcdesc(name, DISPATCH_METHOD + DISPATCH_PROPERTYGET)
    if fd is None:
        raise AttributeError, name
    if fd.invkind == DISPATCH_PROPERTYGET:
        if fd.cParams == 0:
            return self.__prop_get(fd.memid)
        if fd.cParams == 1 and fd.cParamsOpt == 0:
            # Guesswork.  InternetExplorer, and other typelibs,
            # have propget properties with cParams == 1, and cParamsOpt == 0.
            # The parameter type is VT_PTR | VT_..., and wPARAMFlags == PARAMFLAG_FOPT.
            #
            # And calling those without any parameter via Invoke works great...
            if fd.lprgelemdescParam[0].paramdesc.wPARAMFlags == 10:
                return self.__prop_get(fd.memid)
        return _DispMethod(name, self._comobj, fd)
    elif fd.invkind == DISPATCH_METHOD:
        return _DispMethod(name, self._comobj, fd)
    else:
        raise "What's this", fd.invkind
</t>
<t tx="ekr.20050704170205.276">def __call__(self):
    return self.__prop_get(0)
</t>
<t tx="ekr.20050704170205.277">def __nonzero__(self):
    # XXX needs more...
    return True
</t>
<t tx="ekr.20050704170205.278"># What if there isn't a Count or _NewEnum method? Shouldn't we raise another
def __len__(self):
    # XXX Should raise TypeError: len() of unsized object
    return self.Count
</t>
<t tx="ekr.20050704170205.279">def __getitem__(self, index):
    # XXX Should raise TypeError: unindexable object
    enum = POINTER(IEnumVARIANT)()
    self._NewEnum.QueryInterface(byref(IEnumVARIANT._iid_),
                                 byref(enum))
    if index:
        enum.Skip(index)
    result = VARIANT()
    enum.Next(1, byref(result), None)
    return _wrap(result)
</t>
<t tx="ekr.20050704170205.280">def __iter__(self):
    enum = POINTER(IEnumVARIANT)()
    self._NewEnum.QueryInterface(byref(IEnumVARIANT._iid_),
                                 byref(enum))
    return _NewEnum(enum)
</t>
<t tx="ekr.20050704170205.281">
class _NewEnum(object):
	@others
</t>
<t tx="ekr.20050704170205.282">def __init__(self, enum):
    self.enum = enum
</t>
<t tx="ekr.20050704170205.283">def __iter__(self):
    return self
</t>
<t tx="ekr.20050704170205.284">def next(self):
    result = VARIANT()
    if S_FALSE == self.enum.Next(1, byref(result), None):
        raise StopIteration
    return _wrap(result)
</t>
<t tx="ekr.20050704170205.285">
class _DispMethod(_InvokeMixin):
	@others
</t>
<t tx="ekr.20050704170205.286">def __init__(self, name, comobj, fd):
    self.name = name
    self._comobj = comobj
    self.fd = fd
</t>
<t tx="ekr.20050704170205.287">def _get_dispid_dict(self, names):
    # returns a dictionary mapping parameter names to dispids.
    # The function name itself is also included, but does no harm imo.
    # XXX Is there a way to do this more efficiently, with ITypeComp?
    names = [self.name] + names
    name_array = (c_wchar_p * len(names))()
    for i, n in enumerate(names):
        name_array[i] = c_wchar_p(unicode(n))
    memids = (DISPID * len(names))()
    self._comobj.GetIDsOfNames(byref(guid_null),
                              name_array,
                              len(names),
                              0,
                              memids)
    return dict(zip(names, memids))
</t>
<t tx="ekr.20050704170205.288">def _build_parms(self, *args, **kw):
    parms = DISPPARAMS()
    parms.cArgs = len(args) + len(kw)
    parms.cNamedArgs = len(kw)
    parms.rgvarg = rgvarg = (VARIANT * parms.cArgs)()

    i = 0
    if kw:
        parms.rgdispidNamedArgs = rgdispids = (DISPID * parms.cNamedArgs)()
        d = self._get_dispid_dict(kw.keys())
        for name, value in kw.items():
            rgvarg[i].value = value
            rgdispids[i] = d[name]
            i += 1

    arguments = [_unwrap(a) for a in args]
    arguments.reverse() # that's the required ordering
    for a in arguments:
        rgvarg[i].value = a
        i += 1

    return parms
</t>
<t tx="ekr.20050704170205.289"># To support [out] parameters, it seems the following is needed:
# build an rgvarg array containing as long as funcdesc.cParams
# For the actual parameters passed, set the VARIANT to their value.
# For [out] parameters (as specified in PARAMDESC.wPARAMFlags, set the VAIRANT
# vt field to VT_BYREF (otherwise the parameter is considered read only),
# together with the VT_XXX code as specified in TYPEDESC.vt.
# After the call, retrieve the [out] parameters value and return
# a tuple of them.
def __call__(self, *args, **kw):
    parms = self._build_parms(*args, **kw)
    result = self._do_invoke(self.fd.memid, self.fd.invkind, parms)
    return _wrap(result)
</t>
<t tx="ekr.20050704170205.290">    # XXX Note to self: There's a DispGetParam oleaut32 api, is this useful somewhere?

def Dispatch(progid, interface=IDispatch, clsctx=CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER):
    # XXX Should we also allow GUID instances for the first parameter?
    guid = GUID.from_progid(unicode(progid))
    p = POINTER(interface)()
    ole32.CoCreateInstance(byref(guid),
                           None,
                           clsctx,
                           byref(interface._iid_),
                           byref(p))
    return _Dispatch(p)
</t>
<t tx="ekr.20050704170205.291">################################################################

################################################################

def _GetOutgoingInterfaceGuid(comobj, clsid):
    try:
        pci = QueryInterface(comobj, IProvideClassInfo2)
        GUIDKIND_DEFAULT_SOURCE_DISP_IID = 1
        iid = GUID()
        pci.GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, byref(iid))
        return iid
    except WindowsError:
        pass

    try:
        tlb = GetContainingTypeLib(GetTypeInfo(comobj))
    except WindowsError:
        try:
            cpc = QueryInterface(comobj, IConnectionPointContainer)
        except WindowsError:
            raise TypeError, "this COM object doesn't support events"


        cp = Next(ecp)
        guid = GetConnectionInterface(cp)
        return guid

    ti = GetTypeInfoOfGuid(tlb, clsid)
    cImplTypes = GetTypeAttr(ti).cImplTypes

    for i in range(cImplTypes):
        if GetImplTypeFlags(ti, i) != IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE:
            continue
        iti = GetRefTypeInfo(ti, i)
        ta = GetTypeAttr(iti)
        if ta.typekind != TKIND_DISPATCH:
            continue
        iid = ta.guid.copy()
        return iid
    raise TypeError, "no usable outgoing interface found"
</t>
<t tx="ekr.20050704170205.292">def _CreateOutgoingInterface(comobj, clsid):
    guid = _GetOutgoingInterfaceGuid(comobj, clsid)
    tlb = GetContainingTypeLib(GetTypeInfo(comobj))
    typeinfo = GetTypeInfoOfGuid(tlb, guid)
    typecomp = QueryInterface(typeinfo, ITypeComp)

    class MyInterface(IDispatch):
        _methods_ = IDispatch._methods_
        _iid_ = guid
        _typecomp = typecomp
        
    return MyInterface
</t>
<t tx="ekr.20050704170205.293">
################################################################

class _EventReceiver(COMObject):
	&lt;&lt; class _EventReceiver declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.294">_com_interfaces_ = None # for pychecker
</t>
<t tx="ekr.20050704170205.295">def __init__(self, handler_class):
    super(_EventReceiver, self).__init__()
    self._handler = handler_class()
    disp_map = self.disp_map = {}
    for name, _ in inspect.getmembers(handler_class, inspect.ismethod):
        if name.startswith("_") and name.endswith("_"):
            continue
        ti = POINTER(ITypeInfo)()
        dk = DESCKIND()
        bp = BINDPTR()
        self._com_interfaces_[0]._typecomp.Bind(c_wchar_p(name),
                                                0, # hashval
                                                DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                                                byref(ti),
                                                byref(dk),
                                                byref(bp))
        if dk.value == DESCKIND_FUNCDESC:
##                print "FOUND", name
            disp_map[bp.lpfuncdesc[0].memid] = name
            ti.ReleaseFuncDesc(bp.lpfuncdesc)
        elif dk.value == DESCKIND_VARDESC:
            ti.ReleaseVarDesc(bp.lpvardesc)
        elif dk.value == DESCKIND_TYPECOMP:
            bp.lptcomp.Release()
        elif dk.value == 0:
##                print "UNFOUND", name
            pass
</t>
<t tx="ekr.20050704170205.296">def AddRef(self, this): return 2
</t>
<t tx="ekr.20050704170205.297">def Release(self, this): return 1
</t>
<t tx="ekr.20050704170205.298">def Invoke(self, this, dispid, riid, lcid, wFlags, pDispParams,
           pVarResult, pExcepInfo, puArgError):
    mth_name = self.disp_map.get(dispid)
    if mth_name is None:
        return 0
    cArgs = pDispParams[0].cArgs
    rgvarg = pDispParams[0].rgvarg
    args = [rgvarg[i].value for i in range(cArgs-1, -1, -1)]
    result = getattr(self._handler, mth_name)(*args)
    # Hm, if some of the arguments are BYREF, we should fill in
    # the return values of the method calls.  Or not?
    # No, we should only do this for out parameters.
    return 0
</t>
<t tx="ekr.20050704170205.299">def connect(self, source):
    from ctypes.com.connectionpoints import GetConnectionPoint
    cp = GetConnectionPoint(source, self._com_interfaces_[0])
    pevents = self._com_pointers_[0][1]
    from ctypes.wintypes import DWORD
    cookie = DWORD()
    cp.Advise(byref(pevents), byref(cookie))
    return cp, cookie
</t>
<t tx="ekr.20050704170205.300">def disconnect(self, (cp, cookie)):
    # disconnect. Call this with the data returned by connect()
    cp.Unadvise(cookie)
</t>
<t tx="ekr.20050704170205.301">_objects = []

def DispatchWithEvents(progid, user_class, interface=IDispatch,
                       clsctx=CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER):
    p = POINTER(interface)()
    clsid = GUID.from_progid(progid)
    ole32.CoCreateInstance(byref(clsid),
                           None,
                           clsctx,
                           byref(interface._iid_),
                           byref(p))

    class EventReceiver(_EventReceiver):
        _com_interfaces_ = [_CreateOutgoingInterface(p, clsid)]

    rcv = EventReceiver(user_class)
    _objects.append(rcv)
    info = rcv.connect(p)

##    def disconnect():
##        rcv.disconnect(info)

    result = _Dispatch(p)#, disconnect)
    result.__dict__["_event_handler"] = rcv._handler
    return result
</t>
<t tx="ekr.20050704170205.302">def WithEvents(d, user_class):
    class EventReceiver(_EventReceiver):
        _com_interfaces_ = [_CreateOutgoingInterface(d._comobj, None)]

    rcv = EventReceiver(user_class)
    _objects.append(rcv)
    info = rcv.connect(d._comobj)

##    def disconnect():
##        rcv.disconnect(info)

    return rcv
</t>
<t tx="ekr.20050704170205.303">def GetObject(displayName):
    pdisp = POINTER(IDispatch)()
    # Do we need a way to specify the BIND_OPTS parameter?
    ole32.CoGetObject(unicode(displayName), None, byref(IDispatch._iid_), byref(pdisp))
    return _Dispatch(pdisp)
</t>
<t tx="ekr.20050704170205.304">@ignore
@language python
&lt;&lt; connectionpoints declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.305"># connect.py - ConnectionPoint support
from ctypes import *
from ctypes.com import IUnknown, GUID, REFIID, STDMETHOD, HRESULT, COMObject
from ctypes.wintypes import DWORD

################

</t>
<t tx="ekr.20050704170205.306">class CONNECTDATA(Structure):
	&lt;&lt; class CONNECTDATA declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.307">_fields_ = [("pUnk", POINTER(IUnknown)),
            ("dwCookie", DWORD)]

</t>
<t tx="ekr.20050704170205.308">class IEnumConnections(IUnknown):
	&lt;&lt; class IEnumConnections declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.309">_iid_ = GUID("{B196B287-BAB4-101A-B69C-00AA00341D07}")
</t>
<t tx="ekr.20050704170205.310">PIEnumConnections = POINTER(IEnumConnections)

class IEnumConnectionPoints(IUnknown):
	&lt;&lt; class IEnumConnectionPoints declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.311">_iid_ = GUID("{B196B285-BAB4-101A-B69C-00AA00341D07}")
</t>
<t tx="ekr.20050704170205.312">PIEnumConnectionPoints = POINTER(IEnumConnectionPoints)

class IConnectionPointContainer(IUnknown):
	&lt;&lt; class IConnectionPointContainer declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.313">_iid_ = GUID("{B196B284-BAB4-101A-B69C-00AA00341D07}")
</t>
<t tx="ekr.20050704170205.314">PIConnectionPointContainer = POINTER(IConnectionPointContainer)

class IConnectionPoint(IUnknown):
	&lt;&lt; class IConnectionPoint declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.315">_iid_ = GUID("{B196B286-BAB4-101A-B69C-00AA00341D07}")
</t>
<t tx="ekr.20050704170205.316">PIConnectionPoint = POINTER(IConnectionPoint)

################

IEnumConnections._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Next", c_ulong, POINTER(CONNECTDATA), POINTER(c_ulong)),
    STDMETHOD(HRESULT, "Skip", c_ulong),
    STDMETHOD(HRESULT, "Reset"),
    STDMETHOD(HRESULT, "Clone", POINTER(PIEnumConnections))]

IEnumConnectionPoints._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Next", c_ulong, POINTER(IConnectionPoint), POINTER(c_ulong)),
    STDMETHOD(HRESULT, "Skip", c_ulong),
    STDMETHOD(HRESULT, "Reset"),
    STDMETHOD(HRESULT, "Clone", POINTER(PIEnumConnectionPoints))]

IConnectionPoint._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetConnectionInterface", POINTER(GUID)),
    STDMETHOD(HRESULT, "GetConnectionPointContainer", POINTER(PIConnectionPointContainer)),
    STDMETHOD(HRESULT, "Advise", POINTER(IUnknown), POINTER(DWORD)),
    STDMETHOD(HRESULT, "Unadvise", DWORD),
    STDMETHOD(HRESULT, "EnumConnections", POINTER(PIEnumConnections))]

IConnectionPointContainer._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "EnumConnectionPoints", POINTER(PIEnumConnectionPoints)),
    STDMETHOD(HRESULT, "FindConnectionPoint", REFIID, POINTER(PIConnectionPoint))]

def GetConnectionPoint(comptr, event_interface):
    # query for IConnectionPointContainer
    cpc = POINTER(IConnectionPointContainer)()
    comptr.QueryInterface(byref(IConnectionPointContainer._iid_), byref(cpc))

    # Find the connection point
    cp = POINTER(IConnectionPoint)()
    cpc.FindConnectionPoint(byref(event_interface._iid_), byref(cp))
    return cp
</t>
<t tx="ekr.20050704170205.317">
################################################################
# A Base class for events delivered to a dispinterface
#

class dispinterface_EventReceiver(COMObject):
	&lt;&lt; class dispinterface_EventReceiver declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.318">_refcnt = 0

# We fake the reference counts...
</t>
<t tx="ekr.20050704170205.319">def AddRef(self, this):
    return 2
</t>
<t tx="ekr.20050704170205.320">def Release(self, this):
    return 1
</t>
<t tx="ekr.20050704170205.321">def _get_args(self, dp):
    args = []
    for i in range(dp.cArgs-1, -1, -1):
        x = dp.rgvarg[i].value
        if hasattr(x, "AddRef") and x:
            x.AddRef()
        args.append(x)
    return tuple(args)
</t>
<t tx="ekr.20050704170205.322">def Invoke(self,
           this,      dispid,    refiid,    lcid,
           wFlags, pDispParams, pVarResult, pExcepInfo,
           puArgErr):
    # It seems we don't have any alternative to implement Invoke
    # in Python.  Although DispInvoke does work for dual
    # interfaces, it doesn't work for dispinterfaces.  I have
    # tried this and failed with DispInvoke, and I assume its the
    # same with CreateStdDispatch.
    mthname = self._com_interfaces_[0]._dispmap_[dispid]
    mth = getattr(self, mthname, None)
    if mth is not None:
        # For symmetry with other code we also pass the this pointer
        args = self._get_args(pDispParams[0])
        mth(this, *args)
    elif __debug__:
        print "# Unimplemented method %s" % mthname
    return 0
</t>
<t tx="ekr.20050704170205.323">def connect(self, source):
    # connect with a source.
    # returns data which must be passed to disconnect later.
    cp = GetConnectionPoint(source, self._com_interfaces_[0])
    pevents = self._com_pointers_[0][1]
    cookie = DWORD()
    cp.Advise(byref(pevents), byref(cookie))
    return cp, cookie
</t>
<t tx="ekr.20050704170205.324">def disconnect(self, (cp, cookie)):
    # disconnect. Call this with the data returned by connect()
    cp.Unadvise(cookie)
</t>
<t tx="ekr.20050704170205.325">@ignore
@language python
&lt;&lt; errorinfo declarations &gt;&gt;
@others

##    ctypes.com.__cleaner = None
</t>
<t tx="ekr.20050704170205.326">from ctypes import *
from ctypes.wintypes import LPOLESTR
from ctypes.com import IUnknown, GUID, STDMETHOD, HRESULT
from ctypes.com.automation import BSTR, oleaut32, BSTR
from ctypes.com.hresult import S_FALSE, S_OK

</t>
<t tx="ekr.20050704170205.327">class ICreateErrorInfo(IUnknown):
	&lt;&lt; class ICreateErrorInfo declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.328">_iid_ = GUID("{22F03340-547D-101B-8E65-08002B2BD119}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "SetGUID", POINTER(GUID)),
    STDMETHOD(HRESULT, "SetSource", LPOLESTR),
    STDMETHOD(HRESULT, "SetDescription", LPOLESTR),
    STDMETHOD(HRESULT, "SetHelpFile", LPOLESTR),
    STDMETHOD(HRESULT, "SetHelpContext", LPOLESTR),
    ]

</t>
<t tx="ekr.20050704170205.329">class IErrorInfo(IUnknown):
	&lt;&lt; class IErrorInfo declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.330">_iid_ = GUID("{1CF2B120-547D-101B-8E65-08002B2BD119}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetGUID", POINTER(GUID)),
    STDMETHOD(HRESULT, "GetSource", POINTER(BSTR)),
    STDMETHOD(HRESULT, "GetDescription", POINTER(BSTR)),
    STDMETHOD(HRESULT, "GetHelpFile", POINTER(BSTR)),
    STDMETHOD(HRESULT, "GetHelpContext", POINTER(BSTR)),
    ]


</t>
<t tx="ekr.20050704170205.331">def CreateErrorInfo():
    cei = POINTER(ICreateErrorInfo)()
    oleaut32.CreateErrorInfo(byref(cei))
    return cei
</t>
<t tx="ekr.20050704170205.332">def GetErrorInfo():
    errinfo = POINTER(IErrorInfo)()
    if S_OK == oleaut32.GetErrorInfo(0, byref(errinfo)):
        return errinfo
    return None
</t>
<t tx="ekr.20050704170205.333">def SetErrorInfo(errinfo):
    return oleaut32.SetErrorInfo(0, errinfo)
</t>
<t tx="ekr.20050704170205.334">################################################################

if __name__ == "__main__":
    def doit():
        for i in range(10):
            cei = CreateErrorInfo()
            cei.SetSource(u"Spam, spam, and spam")

            SetErrorInfo(cei)

            ei = GetErrorInfo()
            src = BSTR()
            ei.GetSource(byref(src))

            oleaut32.SysAllocString(u"aber halle")

    from mallocspy import MallocSpy

    mallocspy = MallocSpy()
    mallocspy.register()

    doit()

    import ctypes.com
    windll.ole32.CoUninitialize()
    print "Clean"

    mallocspy.revoke()
    print "Done"
</t>
<t tx="ekr.20050704170205.335">@ignore
@language python
import warnings
warnings.filterwarnings("ignore", category=FutureWarning)
# COM success and error codes

S_OK = 0
S_FALSE = 1

E_UNEXPECTED = 0x8000FFFFL

E_NOTIMPL = 0x80004001L
E_NOINTERFACE = 0x80004002L
E_POINTER = 0x80004003L
E_FAIL = 0x80004005L
E_INVALIDARG = 0x80070057L

CLASS_E_NOAGGREGATION = 0x80040110L
CLASS_E_CLASSNOTAVAILABLE = 0x80040111L

TYPE_E_ELEMENTNOTFOUND = 0x8002802BL

CO_E_CLASSSTRING = 0x800401F3L
</t>
<t tx="ekr.20050704170205.336">@ignore
@language python
&lt;&lt; mallocspy declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.337">"""
See also:

http://support.microsoft.com/default.aspx?scid=http://support.microsoft.com:80/support/kb/articles/q139/0/71.asp

http://www.microsoft.com/msj/1095/activex1095.aspx

http://msdn.microsoft.com/msdnmag/issues/01/03/leaks/default.aspx
"""
from ctypes import *
from ctypes.wintypes import BOOL
from ctypes.com import CreateInstance, GUID, ole32, IUnknown, \
     STDMETHOD, HRESULT, REFIID, COMObject
from ctypes.com.hresult import TYPE_E_ELEMENTNOTFOUND

</t>
<t tx="ekr.20050704170205.338">class IMalloc(IUnknown):
	&lt;&lt; class IMalloc declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.339">_iid_ = GUID("{00000002-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(c_voidp, "Alloc", c_ulong),
    STDMETHOD(c_voidp, "Realloc", c_voidp, c_ulong),
    STDMETHOD(None, "Free", c_voidp),
    STDMETHOD(c_ulong, "GetSize", c_voidp),
    STDMETHOD(c_int, "DidAlloc", c_voidp),
    STDMETHOD(None, "HeapMinimize")]
    

</t>
<t tx="ekr.20050704170205.340">class IMallocSpy(IUnknown):
	&lt;&lt; class IMallocSpy declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.341">_iid_ = GUID("{0000001D-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(c_ulong, "PreAlloc", c_ulong),
    STDMETHOD(c_voidp, "PostAlloc", c_voidp),
    STDMETHOD(c_voidp, "PreFree", c_voidp, BOOL),
    STDMETHOD(None, "PostFree", BOOL),
    STDMETHOD(c_ulong, "PreRealloc", c_voidp, c_ulong, POINTER(c_voidp), BOOL),
    STDMETHOD(c_voidp, "PostRealloc", c_voidp, BOOL),
    STDMETHOD(c_voidp, "PreGetSize", c_voidp, BOOL),
    STDMETHOD(c_ulong, "PostGetSize", c_ulong, BOOL),
    STDMETHOD(c_voidp, "PreDidAlloc", c_voidp, BOOL),
    STDMETHOD(c_int, "PostDidAlloc", c_voidp, BOOL, c_int),
    STDMETHOD(None, "PreHeapMinimize"),
    STDMETHOD(None, "PostHeapMinimize")]

</t>
<t tx="ekr.20050704170205.342">class MallocSpy(COMObject):
	&lt;&lt; class MallocSpy declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.343">_com_interfaces_ = [IMallocSpy]

</t>
<t tx="ekr.20050704170205.344">def __init__(self):
    self.blocks = {}
    super(MallocSpy, self).__init__()
</t>
<t tx="ekr.20050704170205.345">def AddRef(self, this):
    self._refcnt += 1
    return self._refcnt
</t>
<t tx="ekr.20050704170205.346">def Release(self, this):
    self._refcnt -= 1
    return self._refcnt
</t>
<t tx="ekr.20050704170205.347">################

# keep track of allocated blocks and size
def PreAlloc(self, this, cbRequest):
    self.cbRequest = cbRequest
    return cbRequest
</t>
<t tx="ekr.20050704170205.348">def PostAlloc(self, this, pActual):
    self.blocks[pActual] = self.cbRequest
    del self.cbRequest
    return pActual
</t>
<t tx="ekr.20050704170205.349">def PreFree(self, this, pRequest, fSpyed):
    if fSpyed:
        del self.blocks [pRequest]
    else:
        print "PreFree", pRequest, fSpyed
    return pRequest
</t>
<t tx="ekr.20050704170205.350">def PostFree(self, this, fSpyed):
    pass
</t>
<t tx="ekr.20050704170205.351">def PreGetSize(self, this, pRequest, fSpyed):
    return pRequest
</t>
<t tx="ekr.20050704170205.352">def PostGetSize(self, this, cbActual, fSpyed):
    return cbActual
</t>
<t tx="ekr.20050704170205.353">def PreRealloc(self, this, pRequest, cbRequest, ppNewRequest, fSpyed):
    return cbRequest
</t>
<t tx="ekr.20050704170205.354">def PostRealloc(self, this, pActual, fSpyed):
    return pActual
</t>
<t tx="ekr.20050704170205.355">def PreDidAlloc(self, this, pRequest, fSpyed):
    return pRequest
</t>
<t tx="ekr.20050704170205.356">def PostDidAlloc(self, this, pRequest, fSpyed, fActual):
    return fActual
</t>
<t tx="ekr.20050704170205.357">def PreHeapMinimize(self, this):
    pass
</t>
<t tx="ekr.20050704170205.358">def PostHeapMinimize(self, this):
    pass
</t>
<t tx="ekr.20050704170205.359">################

def active_blocks(self):
    return self.blocks
</t>
<t tx="ekr.20050704170205.360">def register(self):
    oledll.ole32.CoRegisterMallocSpy(byref(self._com_pointers_[0][1]))
</t>
<t tx="ekr.20050704170205.361">def revoke(self, warn=1):
    self.release_all(warn=warn)
    oledll.ole32.CoRevokeMallocSpy()
</t>
<t tx="ekr.20050704170205.362">def release_all(self, warn=1):
    active = self.active_blocks()
    if active:
        m = CoGetMalloc()
        if warn:
            print "%d Allocated Memory Blocks:" % len(active)
            for block, size in active.items():
                didalloc = m.DidAlloc(c_voidp(block))
                print "\t%d bytes at %08X" % (size, block), didalloc
        for block, size in active.items():
            m.Free(c_voidp(block))
</t>
<t tx="ekr.20050704170205.363">def CoGetMalloc():
    m = POINTER(IMalloc)()
    ole32.CoGetMalloc(1, byref(m))
    return m
</t>
<t tx="ekr.20050704170205.364">################################################################

if __name__ == "__main__":
    import ctypes.com
    from ctypes.com.automation import LoadTypeLib, BSTR

    def doit(n):
        tlb = LoadTypeLib(r"c:\windows\system32\shdocvw.dll")
        for i in xrange(-1, n):
            name = BSTR()
            doc = BSTR()
            help = BSTR()
            
            try:
                tlb.GetDocumentation(i, byref(name), byref(doc), None, byref(help))
            except WindowsError, detail:
                if detail.errno != TYPE_E_ELEMENTNOTFOUND:
                    raise
                break
##            print [name.value, doc.value]

    mallocspy = MallocSpy()
    mallocspy.register()

    try:
        doit(32000)
    except:
        import traceback
        traceback.print_exc()

    # Clear sys.exc_info(), in case there are COM objects left
    try: 1/0
    except: pass

    # Shutdown COM by calling CoUninitialize *now*.
    # See ctypes.com.__init__.py for details
    import ctypes.com
    ctypes.com.__cleaner = None
    
    mallocspy.revoke()
</t>
<t tx="ekr.20050704170205.365">@ignore
@language python
&lt;&lt; moniker declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.366">from ctypes import c_ulong, POINTER, byref, c_void_p, c_wchar_p, Structure
from ctypes.wintypes import DWORD, BOOL, FILETIME, LCID, ULONG, LPOLESTR
from ctypes.com import CreateInstance, GUID, ole32, IUnknown, STDMETHOD, HRESULT, REFIID
from ctypes.com.persist import IPersistStream

</t>
<t tx="ekr.20050704170205.367">class BIND_OPTS(Structure):
	&lt;&lt; class BIND_OPTS declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.368">_fields_ = [("cbStruct", DWORD),
            ("grfFlags", DWORD),
            ("grfMode", DWORD),
            ("dwTickCountDeadline", DWORD)]

# BIND_OPTS2 can be used instead of BIND_OPTS.  But BIND_OPTS2
# requires a lot of other structure definitions, and we don't need
# this now.  When BIND_OPTS2 is defined, make sure to define a
# BIND_OPTS.from_parameter class method, which will accept BIND_OPTS2
# instances as well.

################################################################

</t>
<t tx="ekr.20050704170205.369">class IRunningObjectTable(IUnknown):
	&lt;&lt; class IRunningObjectTable declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.370">_iid_ = GUID("{00000010-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.371">class IEnumString(IUnknown):
	&lt;&lt; class IEnumString declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.372">_iid_ = GUID("{00000101-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.373">class IEnumMoniker(IUnknown):
	&lt;&lt; class IEnumMoniker declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.374">_iid_ = GUID("{00000102-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.375">class IBindCtx(IUnknown):
	&lt;&lt; class IBindCtx declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.376">_iid_ = GUID("{0000000E-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.377">class IMoniker(IPersistStream):
	&lt;&lt; class IMoniker declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.378">_iid_ = GUID("{0000000F-0000-0000-C000-000000000046}")

################################

</t>
<t tx="ekr.20050704170205.379">IRunningObjectTable._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Register", DWORD, POINTER(IUnknown), POINTER(IMoniker), POINTER(DWORD)),
    STDMETHOD(HRESULT, "Revoke", DWORD),
    STDMETHOD(HRESULT, "IsRunning", POINTER(IMoniker)),
    STDMETHOD(HRESULT, "GetObject", POINTER(IMoniker), POINTER(POINTER(IUnknown))),
    STDMETHOD(HRESULT, "NoteChangeTime", DWORD, POINTER(FILETIME)),
    STDMETHOD(HRESULT, "GetTimeOfLastChange", POINTER(IMoniker), POINTER(FILETIME)),
    STDMETHOD(HRESULT, "EnumRunning", POINTER(POINTER(IEnumMoniker)))]

IEnumString._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Next", c_ulong, POINTER(LPOLESTR), POINTER(c_ulong)),
    STDMETHOD(HRESULT, "Skip", c_ulong),
    STDMETHOD(HRESULT, "Reset"),
    STDMETHOD(HRESULT, "Clone", POINTER(POINTER(IEnumString)))
    ]

IEnumMoniker._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Next", c_ulong, POINTER(POINTER(IMoniker)), POINTER(c_ulong)),
    STDMETHOD(HRESULT, "Skip", c_ulong),
    STDMETHOD(HRESULT, "Reset"),
    STDMETHOD(HRESULT, "Clone", POINTER(POINTER(IEnumMoniker)))
    ]

IBindCtx._methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "RegisterObjectBound", POINTER(IUnknown)),
    STDMETHOD(HRESULT, "RevokeObjectBound", POINTER(IUnknown)),
    STDMETHOD(HRESULT, "ReleaseBoundObjects"),
    STDMETHOD(HRESULT, "SetBindOptions", POINTER(BIND_OPTS)),
    STDMETHOD(HRESULT, "GetBindOptions", POINTER(BIND_OPTS)),
    STDMETHOD(HRESULT, "GetRunningObjectTable", POINTER(POINTER(IRunningObjectTable))),
    STDMETHOD(HRESULT, "RegisterObjectParam", LPOLESTR, POINTER(IUnknown)),
    STDMETHOD(HRESULT, "GetObjectParam", LPOLESTR, POINTER(POINTER(IUnknown))),
    STDMETHOD(HRESULT, "EnumObjectParam", POINTER(POINTER(IEnumString))),
    STDMETHOD(HRESULT, "RevokeObjectParam", LPOLESTR)]

IMoniker._methods_ = IPersistStream._methods_ + [
    STDMETHOD(HRESULT, "BindToObject", POINTER(IBindCtx), POINTER(IMoniker), REFIID, c_void_p),
    STDMETHOD(HRESULT, "BindToStorage", POINTER(IBindCtx), POINTER(IMoniker), REFIID, c_void_p),
    STDMETHOD(HRESULT, "Reduce", POINTER(IBindCtx), DWORD,
              POINTER(POINTER(IMoniker)), POINTER(POINTER(IMoniker))),
    STDMETHOD(HRESULT, "ComposeWith", POINTER(IMoniker), BOOL, POINTER(POINTER(IMoniker))),
    STDMETHOD(HRESULT, "Enum", BOOL, POINTER(IEnumMoniker)),
    STDMETHOD(HRESULT, "IsEqual", POINTER(IMoniker)),
    STDMETHOD(HRESULT, "Hash", POINTER(DWORD)),
    STDMETHOD(HRESULT, "IsRunning", POINTER(IBindCtx), POINTER(IMoniker), POINTER(IMoniker)),
    STDMETHOD(HRESULT, "GetTimeOfLastChange", POINTER(IBindCtx), POINTER(IMoniker),
              POINTER(FILETIME)),
    STDMETHOD(HRESULT, "Inverse", POINTER(IMoniker)),
    STDMETHOD(HRESULT, "CommonPrefixWith", POINTER(IMoniker), POINTER(POINTER(IMoniker))),
    STDMETHOD(HRESULT, "RelativePathTo", POINTER(IMoniker), POINTER(POINTER(IMoniker))),
    STDMETHOD(HRESULT, "GetDisplayName", POINTER(IBindCtx), POINTER(IMoniker), POINTER(LPOLESTR)),
    STDMETHOD(HRESULT, "ParseDisplayName", POINTER(IBindCtx), POINTER(IMoniker),
              LPOLESTR, POINTER(ULONG), POINTER(POINTER(IMoniker))),
    STDMETHOD(HRESULT, "IsSystemMoniker", POINTER(DWORD))]

################################################################

def CreateBindContext():
    bc = POINTER(IBindCtx)()
    ole32.CreateBindCtx(0, byref(bc))
    return bc
</t>
<t tx="ekr.20050704170205.380">def MkParseDisplayName(displayName, bindCtx=None):
    if bindCtx is None:
        bindCtx = CreateBindContext()
    moniker = POINTER(IMoniker)()
    chEaten = c_ulong()
    ole32.MkParseDisplayName(bindCtx,
                             unicode(displayName),
                             byref(chEaten),
                             byref(moniker))
    # That's what win32com returns:
    return moniker, chEaten.value, bindCtx
</t>
<t tx="ekr.20050704170205.381">@ignore
@language python
&lt;&lt; ole declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.382">from ctypes import *
from ctypes.com import IUnknown, STDMETHOD, HRESULT, GUID
from ctypes.com.storage import IStream, IStorage
from ctypes.wintypes import BYTE, WORD, DWORD, MSG, SIZE, SIZEL, RECTL, RECT, OLESTR, HANDLE, \
     LPWSTR, BOOL, HWND, HMENU, HDC

CLIPFORMAT = WORD

HBITMAP = HANDLE
HOLEMENU = HGLOBAL = HENHMETAFILE = HMETAFILEPICT = HANDLE

# Fakes:
void = c_int # Can we use None instead? Seems so, but not yet tested...
IMoniker = IUnknown

</t>
<t tx="ekr.20050704170205.383">class DVTARGETDEVICE(Structure):
	&lt;&lt; class DVTARGETDEVICE declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.384">_fields_ = [("tdSize", DWORD),
            ("tdDriverNameOffset", WORD),
            ("tdDeviceNameOffset", WORD),
            ("tdPortNameOffset", WORD),
            ("tdExtDevmodeOffset", WORD),
            ("tdData", BYTE * 1)]

</t>
<t tx="ekr.20050704170205.385">class FORMATETC(Structure):
	&lt;&lt; class FORMATETC declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.386">_fields_ = [("cfFormat", CLIPFORMAT),
            ("ptd", POINTER(DVTARGETDEVICE)),
            ("dwAspect", DWORD),
            ("lindex", c_long),
            ("tymed", DWORD)]
</t>
<t tx="ekr.20050704170205.387">assert sizeof(FORMATETC) == 20

TYMED_NULL      = 0
TYMED_HGLOBAL   = 1
TYMED_FILE      = 2
TYMED_ISTREAM   = 4
TYMED_ISTORAGE  = 8
TYMED_GDI       = 16
TYMED_MFPICT    = 32
TYMED_ENHMF     = 64

class STGMEDIUM(Structure):
	@others
    _fields_ = [("tymed", DWORD),
                ("_", _u),
                ("pUnkForRelease", POINTER(IUnknown))]</t>
<t tx="ekr.20050704170205.388">class _u(Union):
	&lt;&lt; class _u declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.389">_fields_ = [("hBitmap", HBITMAP),
            ("hMetaFilePict", HMETAFILEPICT),
            ("hEnhMetaFile", HENHMETAFILE),
            ("hGlobal", HGLOBAL),
            ("lpszFileName", LPWSTR),
            ("pstm", POINTER(IStream)),
            ("pstg", POINTER(IStorage))]
</t>
<t tx="ekr.20050704170205.390">

class PALETTEENTRY(Structure):
	&lt;&lt; class PALETTEENTRY declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.391">_fields_ = [("peRed", BYTE),
            ("peGreen", BYTE),
            ("peBlue", BYTE),
            ("peFlags", BYTE)]

</t>
<t tx="ekr.20050704170205.392">class LOGPALETTE(Structure):
	&lt;&lt; class LOGPALETTE declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.393">_fields_ = [("palVersion", WORD),
            ("palNumEntried", WORD),
            ("palPalEntry", PALETTEENTRY * 1)]


</t>
<t tx="ekr.20050704170205.394">BORDERWIDTHS = RECT

class OLEINPLACEFRAMEINFO(Structure):
	&lt;&lt; class OLEINPLACEFRAMEINFO declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.395">_fields_ = [("cb", c_uint),
            ("fMDIApp", BOOL),
            ("hwndFrame", HWND),
            ("cAccelEntries", c_uint)]

</t>
<t tx="ekr.20050704170205.396">class IOleWindow(IUnknown):
	&lt;&lt; class IOleWindow declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.397">_iid_ = GUID("{00000114-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetWindow", POINTER(HWND)),
    STDMETHOD(HRESULT, "ContextSensitiveHelp", c_int)]

</t>
<t tx="ekr.20050704170205.398">class IOleInPlaceUIWindow(IOleWindow):
	&lt;&lt; class IOleInPlaceUIWindow declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.399">_iid_ = GUID("{00000115-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.400">class IOleInPlaceActiveObject(IOleWindow):
	&lt;&lt; class IOleInPlaceActiveObject declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.401">_iid_ = GUID("{00000117-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.402">IOleInPlaceUIWindow._methods_ = IOleWindow._methods_ + [
    STDMETHOD(HRESULT, "GetBorder", POINTER(RECT)),
    STDMETHOD(HRESULT, "RequestBorderSpace", POINTER(BORDERWIDTHS)),
    STDMETHOD(HRESULT, "SetBorderSpace", POINTER(BORDERWIDTHS)),
    STDMETHOD(HRESULT, "SetActiveObject", POINTER(IOleInPlaceActiveObject), POINTER(OLESTR))]

IOleInPlaceActiveObject._methods_ = IOleWindow._methods_ + [
    STDMETHOD(HRESULT, "TranslateAccelerator", POINTER(MSG)),
    STDMETHOD(HRESULT, "OnFrameWindowActivate", c_int),
    STDMETHOD(HRESULT, "OnDocWindowActivate", c_int),
    STDMETHOD(HRESULT, "ResizeBorder", POINTER(RECT), POINTER(IOleInPlaceUIWindow), c_int),
    STDMETHOD(HRESULT, "EnableModeless", c_int)]

class OLEMENUGROUPWIDTHS(Structure):
	&lt;&lt; class OLEMENUGROUPWIDTHS declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.403">_fields_ = [("widths", c_long * 6)]

# functions: OleCreateMenuDescriptor, OleDestroyMenuDescriptor

</t>
<t tx="ekr.20050704170205.404">class IOleInPlaceFrame(IOleInPlaceUIWindow):
	&lt;&lt; class IOleInPlaceFrame declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.405">_iid_ = GUID("{00000116-0000-0000-C000-000000000046}")
_methods_ = IOleInPlaceUIWindow._methods_ + [
    STDMETHOD(HRESULT, "InsertMenus", HMENU, POINTER(OLEMENUGROUPWIDTHS)),
    STDMETHOD(HRESULT, "SetMenu", HMENU, HOLEMENU, HWND),
    STDMETHOD(HRESULT, "RemoveMenus", HMENU),
    STDMETHOD(HRESULT, "SetStatusText", POINTER(OLESTR)),
    STDMETHOD(HRESULT, "EnableModeless", BOOL),
    STDMETHOD(HRESULT, "TranslateAccelerator", POINTER(MSG), WORD),
    ]

</t>
<t tx="ekr.20050704170205.406">class IOleInPlaceObject(IOleWindow):
	&lt;&lt; class IOleInPlaceObject declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.407">_iid_ = GUID("{00000113-0000-0000-C000-000000000046}")
_methods_ = IOleWindow._methods_ + [
    STDMETHOD(HRESULT, "InPlaceDeactivate"),
    STDMETHOD(HRESULT, "UIDeactivate"),
    STDMETHOD(HRESULT, "SetObjectRects", POINTER(RECT), POINTER(RECT)),
    STDMETHOD(HRESULT, "ReactivateAndUndo"),
    ]

</t>
<t tx="ekr.20050704170205.408">class IOleInPlaceSite(IOleWindow):
	&lt;&lt; class IOleInPlaceSite declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.409">_iid_ = GUID("{00000119-0000-0000-C000-000000000046}")
_methods_ = IOleWindow._methods_ + [
    STDMETHOD(HRESULT, "CanInPlaceActivate"),
    STDMETHOD(HRESULT, "OnInPlaceActivate"),
    STDMETHOD(HRESULT, "OnUIActivate"),
    STDMETHOD(HRESULT, "GetWindowContext",
              POINTER(POINTER(IOleInPlaceFrame)),
              POINTER(POINTER(IOleInPlaceUIWindow)),
              POINTER(RECT), POINTER(RECT),
              POINTER(OLEINPLACEFRAMEINFO)),
    STDMETHOD(HRESULT, "Scroll", SIZE),
    STDMETHOD(HRESULT, "OnUIDeactivate", BOOL),
    STDMETHOD(HRESULT, "OnInPlaceDeactivate"),
    STDMETHOD(HRESULT, "DiscardUndoState"),
    STDMETHOD(HRESULT, "DeactivateAndUndo"),
    STDMETHOD(HRESULT, "OnPosRectChange", POINTER(RECT))]

</t>
<t tx="ekr.20050704170205.410">class IAdviseSink(IUnknown):
	&lt;&lt; class IAdviseSink declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.411">_iid_ = GUID("{0000010F-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(void, "OnDataChange", POINTER(FORMATETC), POINTER(STGMEDIUM)),
    STDMETHOD(void, "OnViewChange", DWORD, c_long),
    STDMETHOD(void, "OnRename", POINTER(IMoniker)),
    STDMETHOD(void, "OnSave"),
    STDMETHOD(void, "OnClose")]

</t>
<t tx="ekr.20050704170205.412">class IViewObject(IUnknown):
	&lt;&lt; class IViewObject declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.413">_iid_ = GUID("{0000010D-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Draw", DWORD, c_long, c_void_p,
              POINTER(DVTARGETDEVICE), HDC, HDC, POINTER(RECTL),
              POINTER(RECTL), c_void_p, DWORD),
    STDMETHOD(HRESULT, "GetColorSet", DWORD, c_long, c_void_p,
              POINTER(DVTARGETDEVICE), HDC, POINTER(POINTER(LOGPALETTE))),
    STDMETHOD(HRESULT, "Freeze", DWORD, c_long, c_void_p, POINTER(DWORD)),
    STDMETHOD(HRESULT, "Unfreeze", DWORD),
    STDMETHOD(HRESULT, "SetAdvise", DWORD, DWORD, POINTER(IAdviseSink)),
    STDMETHOD(HRESULT, "GetAdvise", POINTER(DWORD), POINTER(DWORD),
              POINTER(POINTER(IAdviseSink)))]

</t>
<t tx="ekr.20050704170205.414">class IViewObject2(IViewObject):
	&lt;&lt; class IViewObject2 declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.415">_iid_ = GUID("{00000127-0000-0000-C000-000000000046}")
_methods_ = IViewObject._methods_ + [
    STDMETHOD(HRESULT, "GetExtent", DWORD, c_long,
              POINTER(DVTARGETDEVICE), POINTER(SIZEL))]
</t>
<t tx="ekr.20050704170205.416">@ignore
@language python
&lt;&lt; oleobject declarations &gt;&gt;
@others

##if __name__ == "__main__":
##    holder = CreateOleAdviseHolder()
##    print holder
##    holder.SendOnSave()
##    holder.SendOnClose()
</t>
<t tx="ekr.20050704170205.417">from ctypes import *
from ctypes.wintypes import BYTE, WORD, DWORD, MSG, HWND, RECT, BOOL, SIZEL, \
     LPOLESTR, LPCOLESTR, LONG
from ctypes.com import IUnknown, STDMETHOD, HRESULT, GUID, ole32
from ctypes.com.ole import IAdviseSink, LOGPALETTE

# fake defines
IMoniker = IUnknown
IDataObject = IUnknown
IEnumOleVerb = IUnknown
IOleContainer = IUnknown

IEnumSTATDATA = IUnknown

# shortcuts
LPMSG = POINTER(MSG)
LPRECT = POINTER(RECT)

</t>
<t tx="ekr.20050704170205.418">class IOleClientSite(IUnknown):
	&lt;&lt; class IOleClientSite declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.419">_iid_ = GUID("{00000118-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "SaveObject"),
    STDMETHOD(HRESULT, "GetMoniker", DWORD, DWORD, POINTER(POINTER(IMoniker))),
    STDMETHOD(HRESULT, "GetContainer", POINTER(POINTER(IOleContainer))),
    STDMETHOD(HRESULT, "ShowObject"),
    STDMETHOD(HRESULT, "OnShowWindow", BOOL),
    STDMETHOD(HRESULT, "RequestNewObjectLayout")]

</t>
<t tx="ekr.20050704170205.420">class IOleObject(IUnknown):
	&lt;&lt; class IOleObject declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.421">_iid_ = GUID("{00000112-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "SetClientSite", POINTER(IOleClientSite)),
    STDMETHOD(HRESULT, "GetClientSite", POINTER(POINTER(IOleClientSite))),
    STDMETHOD(HRESULT, "SetHostNames", LPCOLESTR, LPCOLESTR),
    STDMETHOD(HRESULT, "Close", DWORD),
    STDMETHOD(HRESULT, "SetMoniker", DWORD, POINTER(IMoniker)),
    STDMETHOD(HRESULT, "GetMoniker", DWORD, DWORD, POINTER(POINTER(IMoniker))),
    STDMETHOD(HRESULT, "InitFromData", POINTER(IDataObject), BOOL, DWORD),
    STDMETHOD(HRESULT, "GetClipboardData", DWORD, POINTER(POINTER(IDataObject))),
    STDMETHOD(HRESULT, "DoVerb", LONG, LPMSG, POINTER(IOleClientSite), LONG, HWND, LPRECT),
    STDMETHOD(HRESULT, "EnumVerbs", POINTER(POINTER(IEnumOleVerb))),
    STDMETHOD(HRESULT, "Update"),
    STDMETHOD(HRESULT, "IsUpToDate"),
    STDMETHOD(HRESULT, "GetUserClassID", POINTER(GUID)),
    STDMETHOD(HRESULT, "GetUserType", DWORD, POINTER(LPOLESTR)),
    STDMETHOD(HRESULT, "SetExtent", DWORD, POINTER(SIZEL)),
    STDMETHOD(HRESULT, "GetExtent", DWORD, POINTER(SIZEL)),
    STDMETHOD(HRESULT, "Advise", POINTER(IAdviseSink), POINTER(DWORD)),
    STDMETHOD(HRESULT, "Unadvise", DWORD),
    STDMETHOD(HRESULT, "EnumAdvise", POINTER(POINTER(IEnumSTATDATA))),
    STDMETHOD(HRESULT, "GetMiscStatus", DWORD, POINTER(DWORD)),
    STDMETHOD(HRESULT, "SetColorScheme", POINTER(LOGPALETTE))]

</t>
<t tx="ekr.20050704170205.422">class IOleAdviseHolder(IUnknown):
	&lt;&lt; class IOleAdviseHolder declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.423">_iid_ = GUID("{00000111-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Advise", POINTER(IAdviseSink), POINTER(DWORD)),
    STDMETHOD(HRESULT, "Unadvise", DWORD),
    STDMETHOD(HRESULT, "EnumAdvise", POINTER(POINTER(IEnumSTATDATA))),
    STDMETHOD(HRESULT, "SendOnRename", POINTER(IMoniker)),
    STDMETHOD(HRESULT, "SendOnSave"),
    STDMETHOD(HRESULT, "SendOnClose")]

</t>
<t tx="ekr.20050704170205.424">def CreateOleAdviseHolder():
    p = POINTER(IOleAdviseHolder)()
    ole32.CreateOleAdviseHolder(byref(p))
    return p
</t>
<t tx="ekr.20050704170205.425">@ignore
@language python
&lt;&lt; persist declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.426">from ctypes import *
from ctypes.com import IUnknown, GUID, HRESULT, STDMETHOD
from ctypes.wintypes import DWORD, LPOLESTR, LPCOLESTR, BOOL
from ctypes.com.automation import VARIANT, IErrorLog
from ctypes.com.storage import IStream

</t>
<t tx="ekr.20050704170205.427">class IPersist(IUnknown):
	&lt;&lt; class IPersist declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.428">_iid_ = GUID("{0000010C-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetClassID", POINTER(GUID))
    ]


</t>
<t tx="ekr.20050704170205.429">class IPersistStream(IPersist):
	&lt;&lt; class IPersistStream declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.430">_iid_ = GUID("{00000109-0000-0000-C000-000000000046}")
_methods_ = IPersist._methods_ + [
    STDMETHOD(HRESULT, "IsDirty"),
    STDMETHOD(HRESULT, "Load", POINTER(IStream)),
    STDMETHOD(HRESULT, "Save", POINTER(IStream), BOOL),
    STDMETHOD(HRESULT, "GetSizeMax", POINTER(c_longlong))
    ]

</t>
<t tx="ekr.20050704170205.431">class IPersistStreamInit(IPersist):
	&lt;&lt; class IPersistStreamInit declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.432">_iid_ = GUID("{7FD52380-4E07-101B-AE2D-08002B2EC713}")
_methods_ = IPersist._methods_ + [
    STDMETHOD(HRESULT, "IsDirty"),
    STDMETHOD(HRESULT, "Load", POINTER(IStream)),
    STDMETHOD(HRESULT, "Save", POINTER(IStream), BOOL),
    STDMETHOD(HRESULT, "GetSizeMax", POINTER(c_longlong)),
    STDMETHOD(HRESULT, "InitNew")
    ]

</t>
<t tx="ekr.20050704170205.433">class IPersistFile(IPersist):
	&lt;&lt; class IPersistFile declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.434">_iid_ = GUID("{0000010B-0000-0000-C000-000000000046}")
_methods_ = IPersist._methods_ + [
    STDMETHOD(HRESULT, "IsDirty"),
    STDMETHOD(HRESULT, "Load", LPCOLESTR, DWORD),
    STDMETHOD(HRESULT, "Save", LPCOLESTR, BOOL),
    STDMETHOD(HRESULT, "SaveCompleted", LPCOLESTR),
    # Returned string pointer must be freed with IMalloc::Free
    # How would we do this?
    STDMETHOD(HRESULT, "GetCurFile", POINTER(LPCOLESTR))
    ]

</t>
<t tx="ekr.20050704170205.435">class IPropertyBag(IUnknown):
	&lt;&lt; class IPropertyBag declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.436">_iid_ = GUID("{55272A00-42CB-11CE-8135-00AA004BB851}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Read", LPCOLESTR, POINTER(VARIANT), POINTER(IErrorLog)),
    STDMETHOD(HRESULT, "Write", LPCOLESTR, POINTER(VARIANT))
    ]

</t>
<t tx="ekr.20050704170205.437">class IPersistPropertyBag(IPersist):
	&lt;&lt; class IPersistPropertyBag declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.438">_iid_ = GUID("{37D84F60-42CB-11CE-8135-00AA004BB851}")
_methods_ = IPersist._methods_ + [
    STDMETHOD(HRESULT, "InitNew"),
    STDMETHOD(HRESULT, "Load", POINTER(IPropertyBag), POINTER(IErrorLog)),
    STDMETHOD(HRESULT, "Save", POINTER(IPropertyBag), BOOL, BOOL)
    ]

##__all__ = ["Persist", "IPersistFile", "IPropertyBag", "IPersistPropertyBag"]
</t>
<t tx="ekr.20050704170205.439">@ignore
@language python
&lt;&lt; register declarations &gt;&gt;
@others

if __debug__:
    if __name__ == '__main__':
        sys.path.insert(0, "samples\\server")
        import sum, ctypes.com.server
        ctypes.com.server.UseCommandLine(sum.SumObject)
</t>
<t tx="ekr.20050704170205.440">import _winreg, sys, imp, os
from ctypes import byref, POINTER
from ctypes.com import GUID, CLSCTX_LOCAL_SERVER, CLSCTX_INPROC_SERVER
from ctypes.com.automation import REGKIND_REGISTER, LoadTypeLibEx, TLIBATTR, oleaut32

################################################################
# Registration
#
# COMObject attributes for registration:
#
# _reg_clsid_ - required string
# _reg_progid_ - optional (?) string
# _reg_desc_ - optional string
# _reg_clsctx_ - optional REGCLS_CTX* constants
#
# _typelib_ - optional object, which must have a 'path' attribute
#
# If registration is run from a frozen executable then the _typelib_
# attribute is ignored, and a typelib resource in sys.executable is
# used instead.

</t>
<t tx="ekr.20050704170205.441">def main_is_frozen():
    return (hasattr(sys, "importers") # py2exe
            or imp.is_frozen("__main__") # tools/freeze
            or hasattr(sys, "frozen") # McMillan installer
            )
</t>
<t tx="ekr.20050704170205.442">
class Registrar(object):
    """Registrar registers or unregisters a COM coclass in the registry.

    It can be extended by overriding the build_table method.
    """
	&lt;&lt; class Registrar declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.443">_reg_progid_ = None
_reg_clsctx_ = CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER

</t>
<t tx="ekr.20050704170205.444">def __init__(self, cls):
    self._cls = cls
    self._reg_clsid_ = cls._reg_clsid_
    if hasattr(cls, "_reg_progid_"):
        self._reg_progid_ = cls._reg_progid_
    self._reg_desc_ = getattr(cls, "_reg_desc_", self._reg_progid_)
    self._reg_clsctx_ = getattr(cls, "_reg_clsctx_", self._reg_clsctx_)
</t>
<t tx="ekr.20050704170205.445">def build_table(self):
    """Return a sequence of tuples containing registry entries.

    The tuples must be (key, subkey, name, value).
    """
    HKCR = _winreg.HKEY_CLASSES_ROOT

    # rootkey, subkey, valuename, value
    table = [(HKCR, "CLSID\\%s" % self._reg_clsid_, "", self._reg_desc_),
             (HKCR, "CLSID\\%s\\ProgID" % self._reg_clsid_, "", self._reg_progid_),
             (HKCR, "AppID\\%s" % self._reg_clsid_, "", self._reg_progid_),
             (HKCR, "%s\\CLSID" % self._reg_progid_, "", self._reg_clsid_),
             (HKCR, self._reg_progid_, "", self._reg_desc_),
             ]

    if not main_is_frozen() and self._reg_clsctx_ &amp; CLSCTX_INPROC_SERVER:
        import _ctypes
        modname = self._cls.__module__
        if modname == "__main__":
            modname = os.path.splitext(os.path.basename(sys.argv[0]))[0]
            path = os.path.abspath(os.path.dirname(sys.argv[0]))
        else:
            mod = sys.modules[self._cls.__module__]
            path = os.path.abspath(os.path.dirname(mod.__file__))

        classname = "%s.%s" % (modname, self._cls.__name__)
        e = [(HKCR, "CLSID\\%s\\InprocServer32" % self._reg_clsid_, "PythonClass", classname),
             (HKCR, "CLSID\\%s\\InprocServer32" % self._reg_clsid_, "PythonPath", path),
             (HKCR, "CLSID\\%s\\InprocServer32" % self._reg_clsid_, "", _ctypes.__file__),
##                 (HKCR, "CLSID\\%s\\InprocServer32" % self._reg_clsid_, "ThreadingModel", "Both")
             ]
        
        table.extend(e)
        
    if self._reg_clsctx_ &amp; CLSCTX_LOCAL_SERVER:
        if main_is_frozen():
            exe = sys.executable
        else:
            # Or pythonw.exe?
            exe = '%s "%s"' % (sys.executable, os.path.abspath(sys.argv[0]))
        table.append((HKCR, "CLSID\\%s\\LocalServer32" % self._reg_clsid_, "", exe))
             
    return table
</t>
<t tx="ekr.20050704170205.446">def unregister(self):
    table = self.build_table()
    table.sort()
    table.reverse() # so the "deepest" entries come first
    for root, key, name, value in table:
        try:
            _winreg.DeleteKey(root, key)
        except WindowsError, detail:
            if detail.errno != 2:
                raise
    if hasattr(self._cls, "_typelib_"):
        if main_is_frozen():
            unregister_typelib(sys.executable)
        else:
            lib = self._cls._typelib_
            unregister_typelib(lib.path)
</t>
<t tx="ekr.20050704170205.447">def register(self):
    table = self.build_table()
    table.sort() # so the "deepest" entries come last
    for root, key, name, value in table:
        if key:
            handle = _winreg.CreateKey(root, key)
        else:
            handle = root
        _winreg.SetValueEx(handle, name, None, _winreg.REG_SZ, value)
    if hasattr(self._cls, "_typelib_"):
        if main_is_frozen():
            register_typelib(sys.executable)
        else:
            lib = self._cls._typelib_
            register_typelib(lib.path)
</t>
<t tx="ekr.20050704170205.448">def register_typelib(path):
    try:
        LoadTypeLibEx(path, REGKIND_REGISTER)
##        print "Registered Typelib", path
    except:
        import traceback
        traceback.print_exc()
</t>
<t tx="ekr.20050704170205.449">def unregister_typelib(path):
    try:
        tlib = LoadTypeLibEx(path, REGKIND_REGISTER)
        pta = POINTER(TLIBATTR)()
        tlib.GetLibAttr(byref(pta))
        ta = pta.contents
        libid = str(ta.guid)
        lcid = ta.lcid
        syskind = ta.syskind
        wMajorVerNum = ta.wMajorVerNum
        wMinorVerNum = ta.wMinorVerNum
        tlib.ReleaseTLibAttr(pta)

        oleaut32.UnRegisterTypeLib(byref(GUID(libid)), wMajorVerNum,
                                   wMinorVerNum, lcid, syskind)
##        print "Unregistered Typelib", libid, (wMajorVerNum, wMinorVerNum)
    except:
        import traceback
        traceback.print_exc()
</t>
<t tx="ekr.20050704170205.450">def register(*classes):
    for cls in classes:
        cls._get_registrar().register()
</t>
<t tx="ekr.20050704170205.451">def unregister(*classes):
    for cls in classes:
        cls._get_registrar().unregister()
</t>
<t tx="ekr.20050704170205.452">@ignore
@language python
&lt;&lt; server declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.453">import _winreg, sys
from ctypes import *
from ctypes.wintypes import DWORD
from ctypes.com import IUnknown, PIUnknown, COMObject, ole32, \
     GUID, HRESULT, STDMETHOD, REFIID, CLSCTX_INPROC_SERVER, CLSCTX_LOCAL_SERVER
from ctypes.com.hresult import *
from ctypes.com.w_getopt import w_getopt
from ctypes.com.register import register, unregister

user32 = windll.user32
kernel32 = windll.kernel32

EXTCONN_STRONG = 0x0001

REGCLS_SINGLEUSE         = 0
REGCLS_MULTIPLEUSE       = 1
REGCLS_MULTI_SEPARATE    = 2
REGCLS_SUSPENDED         = 4
REGCLS_SURROGATE         = 8

################################################################

_quit_enabled = 1

</t>
<t tx="ekr.20050704170205.454">class IClassFactory(IUnknown):
	&lt;&lt; class IClassFactory declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.455">_iid_ = GUID("{00000001-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "CreateInstance", c_int, REFIID, POINTER(DWORD)),
    STDMETHOD(HRESULT, "LockServer", c_int)]

</t>
<t tx="ekr.20050704170205.456">class IExternalConnection(IUnknown):
	&lt;&lt; class IExternalConnection declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.457">_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "AddConnection", DWORD, DWORD),
    STDMETHOD(HRESULT, "ReleaseConnection", DWORD, DWORD, DWORD)]

################################################################

</t>
<t tx="ekr.20050704170205.458">def dprint(*args):
    parts = [str(arg) for arg in args] + ["\n"]
    kernel32.OutputDebugStringA(" ".join(parts))
</t>
<t tx="ekr.20050704170205.459">##    print " ".join(parts)

class Logger:
	@others
    install = classmethod(install)</t>
<t tx="ekr.20050704170205.460">def write(self, msg):
    kernel32.OutputDebugStringA(msg)
</t>
<t tx="ekr.20050704170205.461">def isatty(self):
    return False
</t>
<t tx="ekr.20050704170205.462">def install(cls):
    import sys
    sys.stdout = sys.stderr = cls()
</t>
<t tx="ekr.20050704170205.463">def inproc_find_class(clsid):
    key = _winreg.OpenKey(_winreg.HKEY_CLASSES_ROOT, "CLSID\\%s\\InprocServer32" % clsid)
    try:
        pathdir = _winreg.QueryValueEx(key, "PythonPath")[0]
    except WindowsError:
        pass
    else:
        if not pathdir in sys.path:
            sys.path.insert(0, str(pathdir))
##            dprint("appended %s to sys.path" % pathdir)
##            dprint("SYS.PATH", sys.path)
    pythonclass = _winreg.QueryValueEx(key, "PythonClass")[0]
    parts = pythonclass.split(".")
    modname = ".".join(parts[:-1])
    classname = parts[-1]
    __import__(modname)
    mod = sys.modules[modname]
##    dprint("imported", mod)

    # It was a nice idea to 'reload' the module, so that during
    # debugging we would always run uptodate versions of the code.
    # The problem is that super(type, obj) sometimes doesn't work
    # correctly anymore because 'obj' would not be an instance of
    # 'type' anymore.
    #
    # So, unfortuately, we cannot use this.
##    if __debug__:
##        reload(mod)

##    dprint("returning", getattr(mod, classname))
    return getattr(mod, classname)
</t>
<t tx="ekr.20050704170205.464">def DllGetClassObject(rclsid, riid, ppv):
    Logger.install()

    if __debug__:
        dprint("DllGetClassObject %s" % ((rclsid, riid, ppv),))

    # This function is called by C code, and receives C integers as
    # parameters. rcslid is a pointer to the CLSID for the coclass we
    # want to be created, riid is a pointer to the requested
    # interface.
    iid = GUID.from_address(riid)
    clsid = GUID.from_address(rclsid)
    p = POINTER(IUnknown).from_address(ppv)

    # Use the clsid to find additional info in the registry.
    cls = inproc_find_class(clsid)
##    dprint("DllGetClassObject", clsid, cls)

    # XXX Hm, does inproc_findclass return None, or raise an Exception?
    if not cls:
        return CLASS_E_CLASSNOTAVAILABLE
    factory = InprocClassFactory(cls)
    _active_objects.append(factory)

    obj = pointer(factory._com_pointers_[0][1])
    obj.AddRef()
    
    # XXX Why is this one needed?
    obj.AddRef()

    # QueryInterface, if successful, increments the refcount itself.
    return obj.QueryInterface(byref(iid), byref(p))
</t>
<t tx="ekr.20050704170205.465">_active_objects = []
g_locks = 0

def DllCanUnloadNow():
    # XXX TODO: Read about inproc server refcounting in Don Box
    if g_locks:
        if __debug__:
            dprint("* DllCanUnloadNow -&gt; S_FALSE", _active_objects)
        return S_FALSE
    else:
        if __debug__:
            dprint("* DllCanUnloadNow -&gt; S_OK", _active_objects)
        return S_OK
</t>
<t tx="ekr.20050704170205.466">    # Hm Call ole32.CoUnitialize here?


################################################################
class _ClassFactory(COMObject):
	&lt;&lt; class _ClassFactory declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.467">_com_interfaces_ = [IClassFactory]

</t>
<t tx="ekr.20050704170205.468">def __init__(self, objclass):
    COMObject.__init__(self)
    for itf in self._com_interfaces_:
        self._make_interface_pointer(itf)
    self.objclass = objclass
</t>
<t tx="ekr.20050704170205.469"># IClassFactory methods

def CreateInstance(self, this, pUnkOuter, riid, ppvObject):
    if pUnkOuter:
        return CLASS_E_NOAGGREGATION
    obj = self.objclass()
    obj._factory = self
    _active_objects.append(obj)
    return obj.QueryInterface(None, riid, ppvObject)
</t>
<t tx="ekr.20050704170205.470">
################################################################
class InprocClassFactory(_ClassFactory):
	@others
</t>
<t tx="ekr.20050704170205.471">def AddRef(self, this):
    self._refcnt += 1
##?##        self._factory.LockServer(None, 1)
    return self._refcnt
</t>
<t tx="ekr.20050704170205.472">def Release(self, this):
    self._refcnt -= 1
##?##        self._factory.LockServer(None, 0)
    return self._refcnt
</t>
<t tx="ekr.20050704170205.473">def LockServer(self, this, fLock):
    global g_locks
    if fLock:
        g_locks += 1
    else:
        g_locks -= 1
    if __debug__:
        dprint("LockServer", fLock, g_locks)
</t>
<t tx="ekr.20050704170205.474">            
################################################################
#
# Algorithm for the server lifetime taken from Don Box: Essential COM
# (German edition, chapter 6.3: Lebensdauer von Server-Prozessen)
#
class LocalServerClassFactory(_ClassFactory):
	&lt;&lt; class LocalServerClassFactory declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170205.475">_com_interfaces_ = [IClassFactory, IExternalConnection]

</t>
<t tx="ekr.20050704170205.476">def get_interface_pointer(self, interface=IUnknown):
    # XXX Should this be reworked to return itf instead of byref(itf)?
    # Or should it return pointer(itf)?
    for iid, itf in self._com_pointers_:
        if interface._iid_ == iid:
            return byref(itf)
</t>
<t tx="ekr.20050704170205.477">    # and shouldn't we raise an exception here?

def _register_class(self, regcls=REGCLS_MULTIPLEUSE):
    cookie = c_ulong()
    ole32.CoRegisterClassObject(byref(GUID(self.objclass._reg_clsid_)),
                                self.get_interface_pointer(),
                                CLSCTX_LOCAL_SERVER,
                                regcls,
                                byref(cookie))
    self.cookie = cookie
</t>
<t tx="ekr.20050704170205.478">def _revoke_class(self):
    ole32.CoRevokeClassObject(self.cookie)
    del self.cookie
</t>
<t tx="ekr.20050704170205.479"># IUnknown methods

def AddRef(self, this):
    return 2
</t>
<t tx="ekr.20050704170205.480">def Release(self, this):
    return 1
</t>
<t tx="ekr.20050704170205.481">def LockServer(self, this, fLock):
    if fLock:
        ole32.CoAddRefServerProcess()
    else:
        result = ole32.CoReleaseServerProcess()
        if result == 0 and _quit_enabled:
            user32.PostQuitMessage(0)
    return S_OK
</t>
<t tx="ekr.20050704170205.482"># IExternalConnection methods

def AddConnection(self, this, extconn, dwReserved):
    if extconn == EXTCONN_STRONG:
        self.LockServer(None, 1)
    return S_OK
</t>
<t tx="ekr.20050704170205.483">def ReleaseConnection(self, this, extconn, dwReserved, fLastReleaseCloses):
    if extconn == EXTCONN_STRONG:
        self.LockServer(None, 0)
    return S_OK
</t>
<t tx="ekr.20050704170205.484">################################################################

def pump_messages():
    from ctypes.wintypes import MSG
    msg = MSG()
    while user32.GetMessageA(byref(msg), 0, 0, 0):
        user32.TranslateMessage(byref(msg))
        user32.DispatchMessageA(byref(msg))
</t>
<t tx="ekr.20050704170205.485">def localserver(objclass):
    factory = LocalServerClassFactory(objclass)
    factory._register_class()
    pump_messages()
    factory._revoke_class()
</t>
<t tx="ekr.20050704170205.486">def UseCommandLine(cls):
    opts, args = w_getopt(sys.argv[1:], "regserver unregserver embedding".split())
    if not opts:
        sys.stderr.write("Usage: %s [-regserver] [-unregserver]\n" % sys.argv[0])
        return 0 # nothing for us to do

    for option, value in opts:
        if option == "regserver":
            register(cls)
        elif option == "unregserver":
            unregister(cls)
        elif option == "embedding":
            localserver(cls)

    return 1 # we have done something
</t>
<t tx="ekr.20050704170205.487">@ignore
@language python
&lt;&lt; shelllink declarations &gt;&gt;
@others
if __debug__:
    if __name__ == "__main__":
        from ctypes.com.persist import IPersistFile
        from ctypes.com import CLSCTX_INPROC_SERVER
        p = POINTER(IShellLinkA)()
        ole32.CoCreateInstance(byref(CLSID_ShellLink),
                               0,
                               CLSCTX_INPROC_SERVER,
                               byref(IShellLinkA._iid_),
                               byref(p))
        print p
        p.SetPath(r"c:\windows\system32\notepad.exe")
        p.SetDescription("Notepad Würg Röchel")
        p.SetArguments("c:\windows\upgrade.txt")
        p.SetWorkingDirectory("c:\\")


        pp = POINTER(IPersistFile)()
        p.QueryInterface(byref(IPersistFile._iid_), byref(pp))
        print pp.Save(ur"c:\XXX.lnk", True)

</t>
<t tx="ekr.20050704170205.488"># -*- coding: latin-1 -*-
from ctypes import *
from ctypes.com import IUnknown, STDMETHOD, HRESULT, GUID, ole32
from ctypes.wintypes import WORD, DWORD, FILETIME, LPSTR, LPCSTR, LPWSTR, LPCWSTR, HWND, WIN32_FIND_DATAA

</t>
<t tx="ekr.20050704170205.489">class SHITEMID(Structure):
	&lt;&lt; class SHITEMID declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.490">_fields_ = [("cb", c_ushort),
            ("abID", c_ubyte * 1)] # variable length, in reality

</t>
<t tx="ekr.20050704170205.491">class ITEMIDLIST(Structure):
	&lt;&lt; class ITEMIDLIST declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.492">_fields_ = [("mkid", SHITEMID)]

</t>
<t tx="ekr.20050704170205.493">class IShellLinkA(IUnknown):
	&lt;&lt; class IShellLinkA declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.494">_iid_ = GUID("{000214EE-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetPath", LPSTR, c_int, POINTER(WIN32_FIND_DATAA), DWORD),
    STDMETHOD(HRESULT, "GetIDList", POINTER(ITEMIDLIST)),
    STDMETHOD(HRESULT, "SetIDList",  POINTER(ITEMIDLIST)),
    STDMETHOD(HRESULT, "GetDescription", LPSTR, c_int),
    STDMETHOD(HRESULT, "SetDescription", LPCSTR),
    STDMETHOD(HRESULT, "GetWorkingDirectory", LPSTR, c_int),
    STDMETHOD(HRESULT, "SetWorkingDirectory", LPCSTR),
    STDMETHOD(HRESULT, "GetArguments", LPSTR, c_int),
    STDMETHOD(HRESULT, "SetArguments", LPCSTR),
    STDMETHOD(HRESULT, "GetHotkey", POINTER(WORD)),
    STDMETHOD(HRESULT, "SetHotkey", WORD),
    STDMETHOD(HRESULT, "GetShowCmd", POINTER(c_int)),
    STDMETHOD(HRESULT, "SetShowCmd", c_int),
    STDMETHOD(HRESULT, "GetIconLocation", LPSTR, c_int, POINTER(c_int)),
    STDMETHOD(HRESULT, "SetIconLocation", LPCSTR, c_int),
    STDMETHOD(HRESULT, "SetRelativePath", LPCSTR, DWORD),
    STDMETHOD(HRESULT, "Resolve", HWND, DWORD),
    STDMETHOD(HRESULT, "SetPath", LPCSTR)
    ]

</t>
<t tx="ekr.20050704170205.495">CLSID_ShellLink = GUID("{00021401-0000-0000-C000-000000000046}")

class IShellLinkW(IUnknown):
	&lt;&lt; class IShellLinkW declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.496">_iid_ = GUID("{000214F9-0000-0000-C000-000000000046}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "GetPath", LPWSTR, c_int, POINTER(WIN32_FIND_DATAA), DWORD),
    STDMETHOD(HRESULT, "GetIDList", POINTER(ITEMIDLIST)),
    STDMETHOD(HRESULT, "SetIDList",  POINTER(ITEMIDLIST)),
    STDMETHOD(HRESULT, "GetDescription", LPWSTR, c_int),
    STDMETHOD(HRESULT, "SetDescription", LPCWSTR),
    STDMETHOD(HRESULT, "GetWorkingDirectory", LPWSTR, c_int),
    STDMETHOD(HRESULT, "SetWorkingDirectory", LPCWSTR),
    STDMETHOD(HRESULT, "GetArguments", LPWSTR, c_int),
    STDMETHOD(HRESULT, "SetArguments", LPCWSTR),
    STDMETHOD(HRESULT, "GetHotkey", POINTER(WORD)),
    STDMETHOD(HRESULT, "SetHotkey", WORD),
    STDMETHOD(HRESULT, "GetShowCmd", POINTER(c_int)),
    STDMETHOD(HRESULT, "SetShowCmd", c_int),
    STDMETHOD(HRESULT, "GetIconLocation", LPWSTR, c_int, POINTER(c_int)),
    STDMETHOD(HRESULT, "SetIconLocation", LPCWSTR, c_int),
    STDMETHOD(HRESULT, "SetRelativePath", LPCWSTR, DWORD),
    STDMETHOD(HRESULT, "Resolve", HWND, DWORD),
    STDMETHOD(HRESULT, "SetPath", LPCWSTR)
    ]

</t>
<t tx="ekr.20050704170205.497">@ignore
@language python
&lt;&lt; storage declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170205.498"># storage interfaces
from ctypes import *
from ctypes.wintypes import DWORD, FILETIME, LPOLESTR, LPCOLESTR, BOOL, LARGE_INTEGER, ULARGE_INTEGER
from ctypes.com import IUnknown, GUID, HRESULT, STDMETHOD, ole32

</t>
<t tx="ekr.20050704170205.499">class STATSTG(Structure):
	&lt;&lt; class STATSTG declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.500">_fields_ = [("pwcsName", LPOLESTR),
            ("type", DWORD),
            ("cbSize", ULARGE_INTEGER),
            ("mtime", FILETIME),
            ("ctime", FILETIME),
            ("atime", FILETIME),
            ("grfMode", DWORD),
            ("grfLocksSupported", DWORD),
            ("clsid", GUID),
            ("grfStateBits", DWORD),
            ("reserved", DWORD)]

</t>
<t tx="ekr.20050704170205.501">STGTY_STORAGE   = 1
STGTY_STREAM    = 2
STGTY_LOCKBYTES = 3
STGTY_PROPERTY  = 4

STREAM_SEEK_SET = 0
STREAM_SEEK_CUR = 1
STREAM_SEEK_END = 2

LOCK_WRITE      = 1
LOCK_EXCLUSIVE  = 2
LOCK_ONLYONCE   = 4

################################################################

class IEnumSTATSTG(IUnknown):
	&lt;&lt; class IEnumSTATSTG declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.502">_iid_ = GUID("{0000000D-0000-0000-C000-000000000046}")
</t>
<t tx="ekr.20050704170205.503">IEnumSTATSTG._methods_ = IUnknown._methods_ + [
        STDMETHOD(HRESULT, "Next", c_ulong, POINTER(STATSTG), POINTER(c_ulong)),
        STDMETHOD(HRESULT, "Skip", c_ulong),
        STDMETHOD(HRESULT, "Reset"),
        STDMETHOD(HRESULT, "Clone", POINTER(POINTER(IEnumSTATSTG)))
        ]

class ISequentialStream(IUnknown):
	&lt;&lt; class ISequentialStream declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.504">_iid_ = GUID("{0c733a30-2a1c-11ce-ade5-00aa0044773d}")
_methods_ = IUnknown._methods_ + [
    STDMETHOD(HRESULT, "Read", c_void_p, c_ulong, POINTER(c_ulong)),
    STDMETHOD(HRESULT, "Write", c_void_p, c_ulong, POINTER(c_ulong)),
    ]

</t>
<t tx="ekr.20050704170205.505">class IStream(ISequentialStream):
	&lt;&lt; class IStream declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.506">_iid_ = GUID("{0000000C-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.507">IStream._methods_ = ISequentialStream._methods_ + [
    STDMETHOD(HRESULT, "Seek", LARGE_INTEGER, DWORD, POINTER(ULARGE_INTEGER)),
    STDMETHOD(HRESULT, "SetSize", ULARGE_INTEGER),
    STDMETHOD(HRESULT, "CopyTo", POINTER(IStream), ULARGE_INTEGER,
              POINTER(ULARGE_INTEGER), POINTER(ULARGE_INTEGER)),
    STDMETHOD(HRESULT, "Commit", DWORD),
    STDMETHOD(HRESULT, "Revert"),
    STDMETHOD(HRESULT, "LockRegion", ULARGE_INTEGER, ULARGE_INTEGER, DWORD),
    STDMETHOD(HRESULT, "UnlockRegion", ULARGE_INTEGER, ULARGE_INTEGER, DWORD),
    STDMETHOD(HRESULT, "Stat", POINTER(STATSTG), DWORD),
    STDMETHOD(HRESULT, "Clone", POINTER(POINTER(IStream)))]

################################################################

def CoMarshalInterThreadInterfaceInStream(punk, iid=None):
    if iid is None:
        iid = punk[0]._iid_
    pstream = POINTER(IStream)()
    ole32.CoMarshalInterThreadInterfaceInStream(byref(iid), punk, byref(pstream))
    return pstream
</t>
<t tx="ekr.20050704170205.508">def CoGetInterfaceAndReleaseStream(pstm, interface, iid=None):
    if iid is None:
        iid = interface._iid_
    result = POINTER(interface)()
    pstm.AddRef()
    # CoGetInterfaceAndReleaseStream will call Release(), but ctypes does it
    # automatically when pstm is deleted!
    ole32.CoGetInterfaceAndReleaseStream(pstm, byref(iid), byref(result))
    return result
</t>
<t tx="ekr.20050704170205.509">
SNB = c_void_p

class IStorage(IUnknown):
	&lt;&lt; class IStorage declarations &gt;&gt;
</t>
<t tx="ekr.20050704170205.510">_iid_ = GUID("{0000000B-0000-0000-C000-000000000046}")

</t>
<t tx="ekr.20050704170205.511">IStorage._methods_ = IUnknown._methods_ + [
        STDMETHOD(HRESULT, "CreateStream", c_wchar_p, DWORD, DWORD, DWORD,
                  POINTER(POINTER(IStream))),
        STDMETHOD(HRESULT, "OpenStream", c_wchar_p, c_void_p, DWORD, DWORD,
                  POINTER(POINTER(IStream))),
        STDMETHOD(HRESULT, "CreateStorage", c_wchar_p, DWORD, DWORD, DWORD,
                  POINTER(POINTER(IStorage))),
        STDMETHOD(HRESULT, "OpenStorage", c_wchar_p, POINTER(IStorage),
                  DWORD, SNB, DWORD, POINTER(POINTER(IStorage))),
        STDMETHOD(HRESULT, "CopyTo", DWORD, POINTER(GUID), SNB, POINTER(IStorage)),
        STDMETHOD(HRESULT, "MoveElementTo", c_wchar_p, POINTER(IStorage), c_wchar_p, DWORD),
        STDMETHOD(HRESULT, "Commit", DWORD),
        STDMETHOD(HRESULT, "Revert"),
        STDMETHOD(HRESULT, "EnumElements", DWORD, c_void_p, DWORD,
                  POINTER(POINTER(IEnumSTATSTG))),
        STDMETHOD(HRESULT, "DestroyElement", c_wchar_p),
        STDMETHOD(HRESULT, "RenameElement", c_wchar_p, c_wchar_p),
        STDMETHOD(HRESULT, "SetElementTimes", c_wchar_p,
                  POINTER(FILETIME), POINTER(FILETIME), POINTER(FILETIME)),
        STDMETHOD(HRESULT, "SetClass", POINTER(GUID)),
        STDMETHOD(HRESULT, "SetStateBits", DWORD, DWORD),
        STDMETHOD(HRESULT, "Stat", POINTER(STATSTG), DWORD),
        ]

##__all__ = []

if __debug__:
    if __name__ == "__main__":
        from ctypes.com import CLSCTX_INPROC_SERVER, CLSCTX_LOCAL_SERVER
        from ctypes.com.automation import IDispatch
        # InternetExplorer.Application
        clsid = GUID("{0002DF01-0000-0000-C000-000000000046}")
        punk = POINTER(IDispatch)()
        ole32.CoCreateInstance(byref(clsid),
                               None,
                               CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                               byref(IDispatch._iid_),
                               byref(punk))
        stm = CoMarshalInterThreadInterfaceInStream(punk)

        def run_in_thread():
            print "IN THREAD 1", stm
            if 1:
                # test code to read and seek back
                cbRead = c_ulong()
                buf = c_buffer(512)
                stm.Read(buf, sizeof(buf), byref(cbRead))
                print "read", cbRead
                stm.Seek(0, 0, None)
            from ctypes.com import ole32
            ole32.CoInitialize(0)
            p = CoGetInterfaceAndReleaseStream(stm, IDispatch)
            print p.AddRef(), p.Release()
            import time
            time.sleep(1)
            print p.AddRef(), p.Release()
            print "IN THREAD 2"
            ole32.CoUninitialize()

        import threading
        t = threading.Thread(target = run_in_thread)
        t.start()
        t.join()
</t>
<t tx="ekr.20050704170316"></t>
<t tx="ekr.20050704170316.1">@ignore
@language python
&lt;&lt; xml2py declarations &gt;&gt;
@others


if __name__ == "__main__":
    sys.exit(main())
</t>
<t tx="ekr.20050704170316.2">import sys, re
from optparse import OptionParser
from codegenerator import generate_code
import typedesc

################################################################
windows_dll_names = """\
imagehlp
user32
kernel32
gdi32
advapi32
oleaut32
ole32
imm32
comdlg32
shell32
version
winmm
mpr
winscard
winspool.drv
urlmon
crypt32
cryptnet
ws2_32
opengl32
glu32
mswsock
msvcrt
msimg32
netapi32
rpcrt4""".split()

##rpcndr
##ntdll

</t>
<t tx="ekr.20050704170316.3">def main(args=None):
    if args is None:
        args = sys.argv

    def windows_dlls(option, opt, value, parser):
        parser.values.dlls.extend(windows_dll_names)

    parser = OptionParser("usage: %prog xmlfile [options]")
    parser.add_option("-d",
                      action="store_true",
                      dest="use_decorators",
                      help="use Python 2.4 function decorators",
                      default=False)

    parser.add_option("-k",
                      action="store",
                      dest="kind",
                      help="kind of type descriptions to include: "
                      "d = #defines, "
                      "e = enumerations, "
                      "f = functions, "
                      "s = structures, "
                      "t = typedefs",
                      metavar="TYPEKIND",
                      default=None)

    parser.add_option("-l",
                      dest="dlls",
                      help="libraries to search for exported functions",
                      action="append",
                      default=[])

    parser.add_option("-o",
                      dest="output",
                      help="output filename (if not specified, standard output will be used)",
                      default="-")

    parser.add_option("-r",
                      dest="expressions",
                      metavar="EXPRESSION",
                      action="append",
                      help="regular expression for symbols to include "
                      "(if neither symbols nor expressions are specified,"
                      "everything will be included)",
                      default=None)

    parser.add_option("-s",
                      dest="symbols",
                      metavar="SYMBOL",
                      action="append",
                      help="symbol to include "
                      "(if neither symbols nor expressions are specified,"
                      "everything will be included)",
                      default=None)

    parser.add_option("-v",
                      action="store_true",
                      dest="verbose",
                      help="verbose output",
                      default=False)

    parser.add_option("-w",
                      action="callback",
                      callback=windows_dlls,
                      help="add all standard windows dlls to the searched dlls list")

##    try:
##        import comtypes
##    except ImportError:
##        default_modules = ["ctypes", "ctypes.com"]
##    else:
##        default_modules = ["ctypes", "comtypes"]
    default_modules = ["ctypes"]
        
    parser.add_option("-m",
                      dest="modules",
                      metavar="module",
                      help="Python module(s) containing symbols which will "
                      "be imported instead of generated",
                      action="append",
                      default=default_modules)

    options, files = parser.parse_args(args[1:])

    if len(files) != 1:
        parser.error("Exactly one input file must be specified")

    if options.output == "-":
        stream = sys.stdout
    else:
        stream = open(options.output, "w")

    if options.expressions:
        options.expressions = map(re.compile, options.expressions)

    stream.write("# generated by 'xml2py'\n")
    stream.write("# flags '%s'\n" % " ".join(sys.argv[1:]))

    known_symbols = {}

    from ctypes import CDLL
    dlls = [CDLL(name) for name in options.dlls]

    for name in options.modules:
        mod = __import__(name)
        for submodule in name.split(".")[1:]:
            mod = getattr(mod, submodule)
        for name in mod.__dict__:
            known_symbols[name] = mod.__name__

    if options.kind:
        types = []
        for char in options.kind:
            typ = {"a": [typedesc.Alias],
                   "d": [typedesc.Variable],
                   "e": [typedesc.Enumeration, typedesc.EnumValue],
                   "f": [typedesc.Function],
                   "m": [typedesc.Macro],
                   "s": [typedesc.Structure],
                   "t": [typedesc.Typedef],
                   }[char]
            types.extend(typ)
        options.kind = tuple(types)

    generate_code(files[0], stream,
                  symbols=options.symbols,
                  expressions=options.expressions,
                  verbose=options.verbose,
                  use_decorators=options.use_decorators,
                  known_symbols=known_symbols,
                  searched_dlls=dlls,
                  types=options.kind)
</t>
<t tx="ekr.20050704170316.4">@ignore
@language python
# ctypes.wrap package - tools for code generation
</t>
<t tx="ekr.20050704170316.5">@ignore
@language python
&lt;&lt; codegenerator declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170316.6"># Create ctypes wrapper code for abstract type descriptions.
# Type descriptions are collections of typedesc instances.

# $Log$
# Revision 1.2  2005/07/21 15:42:21  edream
# Synch.
#
# Revision 1.6  2005/03/16 07:51:19  theller
# _COMMETHOD_defined was never set to True.
#
# Revision 1.5  2005/03/11 15:40:44  theller
# Detect an 'Enum' com method, and create an __iter__ method in this class.
#
# Detect a COM enumerator by checking for the 4 Enum methods, in the
# correct order, and make this class a Python iterator by generating
# __iter__() and next() methods.  IMO it's better to do this in the
# generated code than to mix in another class.
#
# Revision 1.4  2005/03/11 10:18:02  theller
# Various fixes.  And autodetect whether to generate ctypes.com or
# comtypes wrapper code for com interfaces.
#
# Revision 1.3  2005/02/17 19:22:54  theller
# Refactoring for easier dynamic code generation.
#
# Revision 1.2  2005/02/04 18:04:24  theller
# The code generator now assumes decorators are present in the ctypes module.
#
# Revision 1.1  2005/02/04 17:01:24  theller
# Moved the code generation stuff from the sandbox to it's final location.
#

import typedesc, sys

try:
    set
except NameError:
    from sets import Set as set

try:
    import cStringIO as StringIO
except ImportError:
    import StringIO


# XXX Should this be in ctypes itself?
ctypes_names = {
    "unsigned char": "c_ubyte",
    "signed char": "c_byte",
    "char": "c_char",

    "wchar_t": "c_wchar",

    "short unsigned int": "c_ushort",
    "short int": "c_short",

    "long unsigned int": "c_ulong",
    "long int": "c_long",
    "long signed int": "c_long",

    "unsigned int": "c_uint",
    "int": "c_int",

    "long long unsigned int": "c_ulonglong",
    "long long int": "c_longlong",

    "double": "c_double",
    "float": "c_float",

    # Hm...
    "void": "None",
}

################

</t>
<t tx="ekr.20050704170316.7">def storage(t):
    # return the size and alignment of a type
    if isinstance(t, typedesc.Typedef):
        return storage(t.typ)
    elif isinstance(t, typedesc.ArrayType):
        s, a = storage(t.typ)
        return s * (int(t.max) - int(t.min) + 1), a
    return int(t.size), int(t.align)
</t>
<t tx="ekr.20050704170316.8">
class PackingError(Exception):
	&lt;&lt; class PackingError declarations &gt;&gt;
</t>
<t tx="ekr.20050704170316.9">pass

</t>
<t tx="ekr.20050704170316.10">def _calc_packing(struct, fields, pack, isStruct):
    # Try a certain packing, raise PackingError if field offsets,
    # total size ot total alignment is wrong.
    if struct.size is None: # incomplete struct
        return -1
    if struct.name in dont_assert_size:
        return None
    if struct.bases:
        size = struct.bases[0].size
        total_align = struct.bases[0].align
    else:
        size = 0
        total_align = 8 # in bits
    for i, f in enumerate(fields):
        if f.bits:
##            print "##XXX FIXME"
            return -2 # XXX FIXME
        s, a = storage(f.typ)
        if pack is not None:
            a = min(pack, a)
        if size % a:
            size += a - size % a
        if isStruct:
            if size != f.offset:
                raise PackingError, "field offset (%s/%s)" % (size, f.offset)
            size += s
        else:
            size = max(size, s)
        total_align = max(total_align, a)
    if total_align != struct.align:
        raise PackingError, "total alignment (%s/%s)" % (total_align, struct.align)
    a = total_align
    if pack is not None:
        a = min(pack, a)
    if size % a:
        size += a - size % a
    if size != struct.size:
        raise PackingError, "total size (%s/%s)" % (size, struct.size)
</t>
<t tx="ekr.20050704170316.11">def calc_packing(struct, fields):
    # try several packings, starting with unspecified packing
    isStruct = isinstance(struct, typedesc.Structure)
    for pack in [None, 16*8, 8*8, 4*8, 2*8, 1*8]:
        try:
            _calc_packing(struct, fields, pack, isStruct)
        except PackingError, details:
            continue
        else:
            if pack is None:
                return None
            return pack/8
    raise PackingError, "PACKING FAILED: %s" % details
</t>
<t tx="ekr.20050704170316.12">def decode_value(init):
    # decode init value from gccxml
    if init[0] == "0":
        return int(init, 16) # hex integer
    elif init[0] == "'":
        return eval(init) # character
    elif init[0] == '"':
        return eval(init) # string
    return int(init) # integer
</t>
<t tx="ekr.20050704170316.13">def get_real_type(tp):
    if type(tp) is typedesc.Typedef:
        return get_real_type(tp.typ)
    return tp
</t>
<t tx="ekr.20050704170316.14">
# XXX These should be filtered out in gccxmlparser.
dont_assert_size = set(
    [
    "__si_class_type_info_pseudo",
    "__class_type_info_pseudo",
    ]
    )

################################################################

class Generator(object):
	@others
</t>
<t tx="ekr.20050704170316.15">def __init__(self, output,
             use_decorators=False,
             known_symbols=None,
             searched_dlls=None):
    self.output = output
##        self.stream = StringIO.StringIO()
##        self.imports = StringIO.StringIO()
    self.stream = self.imports = self.output
    self.use_decorators = use_decorators
    self.known_symbols = known_symbols or {}
    self.searched_dlls = searched_dlls or []

    self.done = set() # type descriptions that have been generated
    self.names = set() # names that have been generated
</t>
<t tx="ekr.20050704170316.16">def init_value(self, t, init):
    tn = self.type_name(t, False)
    if tn in ["c_ulonglong", "c_ulong", "c_uint", "c_ushort", "c_ubyte"]:
        return decode_value(init)
    elif tn in ["c_longlong", "c_long", "c_int", "c_short", "c_byte"]:
        return decode_value(init)
    elif tn in ["c_float", "c_double"]:
        return float(init)
    elif tn == "POINTER(c_char)":
        if init[0] == '"':
            value = eval(init)
        else:
            value = int(init, 16)
        return value
    elif tn == "POINTER(c_wchar)":
        if init[0] == '"':
            value = eval(init)
        else:
            value = int(init, 16)
        if isinstance(value, str):
            value = value[:-1] # gccxml outputs "D\000S\000\000" for L"DS"
            value = value.decode("utf-16") # XXX Is this correct?
        return value
    elif tn == "c_void_p":
        if init[0] == "0":
            value = int(init, 16)
        else:
            value = int(init) # hm..
        # Hm, ctypes represents them as SIGNED int
        return value
    elif tn == "c_char":
        return decode_value(init)
    elif tn == "c_wchar":
        value = decode_value(init)
        if isinstance(value, int):
            return unichr(value)
        return value
    elif tn.startswith("POINTER("):
        # Hm, POINTER(HBITMAP__) for example
        return decode_value(init)
    else:
        raise ValueError, "cannot decode %s(%r)" % (tn, init)
</t>
<t tx="ekr.20050704170316.17">def type_name(self, t, generate=True):
    # Return a string, containing an expression which can be used to
    # refer to the type. Assumes the * namespace is available.
    if isinstance(t, typedesc.PointerType):
        result = "POINTER(%s)" % self.type_name(t.typ, generate)
        # XXX Better to inspect t.typ!
        if result.startswith("POINTER(WINFUNCTYPE"):
            return result[len("POINTER("):-1]
        if result.startswith("POINTER(CFUNCTYPE"):
            return result[len("POINTER("):-1]
        elif result == "POINTER(None)":
            return "c_void_p"
        return result
    elif isinstance(t, typedesc.ArrayType):
        return "%s * %s" % (self.type_name(t.typ, generate), int(t.max)+1)
    elif isinstance(t, typedesc.FunctionType):
        args = [self.type_name(x, generate) for x in [t.returns] + t.arguments]
        if "__stdcall__" in t.attributes:
            return "WINFUNCTYPE(%s)" % ", ".join(args)
        else:
            return "CFUNCTYPE(%s)" % ", ".join(args)
    elif isinstance(t, typedesc.CvQualifiedType):
        # const and volatile are ignored
        return "%s" % self.type_name(t.typ, generate)
    elif isinstance(t, typedesc.FundamentalType):
        return ctypes_names[t.name]
    elif isinstance(t, typedesc.Structure):
        return t.name
    elif isinstance(t, typedesc.Enumeration):
        if t.name:
            return t.name
        return "c_int" # enums are integers
    elif isinstance(t, typedesc.Typedef):
        return t.name
    return t.name
</t>
<t tx="ekr.20050704170316.18">################################################################

def Alias(self, alias):
    if alias.typ is not None: # we can resolve it
        self.generate(alias.typ)
        if alias.alias in self.names:
            print &gt;&gt; self.stream, "%s = %s # alias" % (alias.name, alias.alias)
            self.names.add(alias.name)
            return
    # we cannot resolve it
    print &gt;&gt; self.stream, "# %s = %s # alias" % (alias.name, alias.alias)
    print "# unresolved alias: %s = %s" % (alias.name, alias.alias)
</t>
<t tx="ekr.20050704170316.19">def Macro(self, macro):
    # We don't know if we can generate valid, error free Python
    # code All we can do is to try to compile the code.  If the
    # compile fails, we know it cannot work, so we generate
    # commented out code.  If it succeeds, it may fail at runtime.
    code = "def %s%s: return %s # macro" % (macro.name, macro.args, macro.body)
    try:
        compile(code, "&lt;string&gt;", "exec")
    except SyntaxError:
        print &gt;&gt; self.stream, "#", code
    else:
        print &gt;&gt; self.stream, code
        self.names.add(macro.name)
</t>
<t tx="ekr.20050704170316.20">def StructureHead(self, head):
    for struct in head.struct.bases:
        self.generate(struct.get_head())
        self.more.add(struct)
    if head.struct.location:
        print &gt;&gt; self.stream, "# %s %s" % head.struct.location
    basenames = [self.type_name(b) for b in head.struct.bases]
    if basenames:
        self.need_GUID()
        method_names = [m.name for m in head.struct.members if type(m) is typedesc.Method]
        print &gt;&gt; self.stream, "class %s(%s):" % (head.struct.name, ", ".join(basenames))
        print &gt;&gt; self.stream, "    _iid_ = GUID('{}') # please look up iid and fill in!"
        if "Enum" in method_names:
            print &gt;&gt; self.stream, "    def __iter__(self):"
            print &gt;&gt; self.stream, "        return self.Enum()"
        elif method_names == "Next Skip Reset Clone".split():
            print &gt;&gt; self.stream, "    def __iter__(self):"
            print &gt;&gt; self.stream, "        return self"
            print &gt;&gt; self.stream
            print &gt;&gt; self.stream, "    def next(self):"
            print &gt;&gt; self.stream, "         arr, fetched = self.Next(1)"
            print &gt;&gt; self.stream, "         if fetched == 0:"
            print &gt;&gt; self.stream, "             raise StopIteration"
            print &gt;&gt; self.stream, "         return arr[0]"
    else:
        methods = [m for m in head.struct.members if type(m) is typedesc.Method]
        if methods:
            # Hm. We cannot generate code for IUnknown...
            print &gt;&gt; self.stream, "assert 0, 'cannot generate code for IUnknown'"
            print &gt;&gt; self.stream, "class %s(_com_interface):" % head.struct.name
        elif type(head.struct) == typedesc.Structure:
            print &gt;&gt; self.stream, "class %s(Structure):" % head.struct.name
        elif type(head.struct) == typedesc.Union:
            print &gt;&gt; self.stream, "class %s(Union):" % head.struct.name
        print &gt;&gt; self.stream, "    pass"
    self.names.add(head.struct.name)
</t>
<t tx="ekr.20050704170316.21">_structures = 0
def Structure(self, struct):
    self._structures += 1
    self.generate(struct.get_head())
    self.generate(struct.get_body())
</t>
<t tx="ekr.20050704170316.22">Union = Structure
    
_typedefs = 0
def Typedef(self, tp):
    self._typedefs += 1
    if type(tp.typ) in (typedesc.Structure, typedesc.Union):
        self.generate(tp.typ.get_head())
        self.more.add(tp.typ)
    else:
        self.generate(tp.typ)
    if self.type_name(tp.typ) in self.known_symbols:
        stream = self.imports
    else:
        stream = self.stream
    if tp.name != self.type_name(tp.typ):
        print &gt;&gt; stream, "%s = %s" % \
              (tp.name, self.type_name(tp.typ))
    self.names.add(tp.name)
</t>
<t tx="ekr.20050704170316.23">_arraytypes = 0
def ArrayType(self, tp):
    self._arraytypes += 1
    self.generate(get_real_type(tp.typ))
    self.generate(tp.typ)
</t>
<t tx="ekr.20050704170316.24">_functiontypes = 0
def FunctionType(self, tp):
    self._functiontypes += 1
    self.generate(tp.returns)
    self.generate_all(tp.arguments)
</t>
<t tx="ekr.20050704170316.25">_pointertypes = 0
def PointerType(self, tp):
    self._pointertypes += 1
    if type(tp.typ) is typedesc.PointerType:
        self.generate(tp.typ)
    elif type(tp.typ) in (typedesc.Union, typedesc.Structure):
        self.generate(tp.typ.get_head())
        self.more.add(tp.typ)
    elif type(tp.typ) is typedesc.Typedef:
        self.generate(tp.typ)
    else:
        self.generate(tp.typ)
</t>
<t tx="ekr.20050704170316.26">def CvQualifiedType(self, tp):
    self.generate(tp.typ)
</t>
<t tx="ekr.20050704170316.27">_variables = 0
def Variable(self, tp):
    self._variables += 1
    if tp.init is None:
        # wtypes.h contains IID_IProcessInitControl, for example
        return
    try:
        value = self.init_value(tp.typ, tp.init)
    except (TypeError, ValueError), detail:
        print "Could not init", tp.name, tp.init, detail
        return
    print &gt;&gt; self.stream, \
          "%s = %r # Variable %s" % (tp.name,
                                     value,
                                     self.type_name(tp.typ, False))
    self.names.add(tp.name)
</t>
<t tx="ekr.20050704170316.28">_enumvalues = 0
def EnumValue(self, tp):
    value = int(tp.value)
    print &gt;&gt; self.stream, \
          "%s = %d" % (tp.name, value)
    self.names.add(tp.name)
    self._enumvalues += 1
</t>
<t tx="ekr.20050704170316.29">_enumtypes = 0
def Enumeration(self, tp):
    self._enumtypes += 1
    if tp.name:
        print &gt;&gt; self.stream
        print &gt;&gt; self.stream, "%s = c_int # enum" % tp.name
    for item in tp.values:
        self.generate(item)
</t>
<t tx="ekr.20050704170316.30">def StructureBody(self, body):
    fields = []
    methods = []
    for m in body.struct.members:
        if type(m) is typedesc.Field:
            fields.append(m)
            if type(m.typ) is typedesc.Typedef:
                self.generate(get_real_type(m.typ))
            self.generate(m.typ)
        elif type(m) is typedesc.Method:
            methods.append(m)
            self.generate(m.returns)
            self.generate_all(m.arguments)
        elif type(m) is typedesc.Constructor:
            pass

    # we don't need _pack_ on Unions (I hope, at least), and
    # not on COM interfaces:
    #
    # Hm, how to detect a COM interface with no methods? IXMLDOMCDATASection is such a beast...
##        if not isinstance(body.struct, typedesc.Union) and not methods:
    if not methods:
        pack = calc_packing(body.struct, fields)
        if pack is not None:
            print &gt;&gt; self.stream, "%s._pack_ = %s" % (body.struct.name, pack)

    if fields:
        if body.struct.bases:
            assert len(body.struct.bases) == 1
            self.generate(body.struct.bases[0].get_body())
        # field definition normally span several lines.
        # Before we generate them, we need to 'import' everything they need.
        # So, call type_name for each field once,
        for f in fields:
            self.type_name(f.typ)
        print &gt;&gt; self.stream, "%s._fields_ = [" % body.struct.name
        if body.struct.location:
            print &gt;&gt; self.stream, "    # %s %s" % body.struct.location
        # unnamed fields will get autogenerated names "_", "_1". "_2", "_3", ...
        unnamed_index = 0
        for f in fields:
            if not f.name:
                if unnamed_index:
                    fieldname = "_%d" % unnamed_index
                else:
                    fieldname = "_"
                unnamed_index += 1
                print &gt;&gt; self.stream, "    # Unnamed field renamed to '%s'" % fieldname
            else:
                fieldname = f.name
            if f.bits is None:
                print &gt;&gt; self.stream, "    ('%s', %s)," % (fieldname, self.type_name(f.typ))
            else:
                print &gt;&gt; self.stream, "    ('%s', %s, %s)," % (fieldname, self.type_name(f.typ), f.bits)
        print &gt;&gt; self.stream, "]"
        # generate assert statements for size and alignment
        if body.struct.size and body.struct.name not in dont_assert_size:
            size = body.struct.size // 8
            print &gt;&gt; self.stream, "assert sizeof(%s) == %s, sizeof(%s)" % \
                  (body.struct.name, size, body.struct.name)
            align = body.struct.align // 8
            print &gt;&gt; self.stream, "assert alignment(%s) == %s, alignment(%s)" % \
                  (body.struct.name, align, body.struct.name)

    if methods:
        # Ha! Autodetect ctypes.com or comtypes ;)
        if "COMMETHOD" in self.known_symbols:
            self.need_COMMETHOD()
        else:
            self.need_STDMETHOD()
        # method definitions normally span several lines.
        # Before we generate them, we need to 'import' everything they need.
        # So, call type_name for each field once,
        for m in methods:
            self.type_name(m.returns)
            for a in m.arguments:
                self.type_name(a)
        if "COMMETHOD" in self.known_symbols:
            print &gt;&gt; self.stream, "%s._methods_ = [" % body.struct.name
        else:
            # ctypes.com needs baseclass methods listed as well
            if body.struct.bases:
                basename = body.struct.bases[0].name
                print &gt;&gt; self.stream, "%s._methods_ = %s._methods + [" % \
                      (body.struct.name, body.struct.bases[0].name)
            else:
                print &gt;&gt; self.stream, "%s._methods_ = [" % body.struct.name
        if body.struct.location:
            print &gt;&gt; self.stream, "# %s %s" % body.struct.location

        if "COMMETHOD" in self.known_symbols:
            for m in methods:
                if m.location:
                    print &gt;&gt; self.stream, "    # %s %s" % m.location
                print &gt;&gt; self.stream, "    COMMETHOD([], %s, '%s'," % (
                    self.type_name(m.returns),
                    m.name)
                for a in m.arguments:
                    print &gt;&gt; self.stream, \
                          "               ( [], %s, )," % self.type_name(a)
                print &gt;&gt; self.stream, "             ),"
        else:
            for m in methods:
                args = [self.type_name(a) for a in m.arguments]
                print &gt;&gt; self.stream, "    STDMETHOD(%s, '%s', [%s])," % (
                    self.type_name(m.returns),
                    m.name,
                    ", ".join(args))
        print &gt;&gt; self.stream, "]"
</t>
<t tx="ekr.20050704170316.31">def find_dllname(self, func):
    if hasattr(func, "dllname"):
        return func.dllname
    name = func.name
    for dll in self.searched_dlls:
        try:
            getattr(dll, name)
        except AttributeError:
            pass
        else:
            return dll._name
##        if self.verbose:
    # warnings.warn, maybe?
##        print &gt;&gt; sys.stderr, "function %s not found in any dll" % name
    return None
</t>
<t tx="ekr.20050704170316.32">_loadedlibs = None
def get_sharedlib(self, dllname):
    if self._loadedlibs is None:
        self._loadedlibs = {}
    try:
        return self._loadedlibs[dllname]
    except KeyError:
        pass
    import os
    basename = os.path.basename(dllname)
    name, ext = os.path.splitext(basename)
    self._loadedlibs[dllname] = name
    # This should be handled in another way!
##        print &gt;&gt; self.stream, "%s = CDLL(%r)" % (name, dllname)
    return name
</t>
<t tx="ekr.20050704170316.33">_STDMETHOD_defined = False
def need_STDMETHOD(self):
    if self._STDMETHOD_defined:
        return
    print &gt;&gt; self.imports, "from ctypes.com import STDMETHOD"
    self._STDMETHOD_defined = True
</t>
<t tx="ekr.20050704170316.34">_COMMETHOD_defined = False
def need_COMMETHOD(self):
    if self._COMMETHOD_defined:
        return
    print &gt;&gt; self.imports, "from comtypes import COMMETHOD"
    self._COMMETHOD_defined = True
</t>
<t tx="ekr.20050704170316.35">_GUID_defined = False
def need_GUID(self):
    if self._GUID_defined:
        return
    self._GUID_defined = True
    modname = self.known_symbols.get("GUID")
    if modname:
        print &gt;&gt; self.imports, "from %s import GUID" % modname
</t>
<t tx="ekr.20050704170316.36">_functiontypes = 0
_notfound_functiontypes = 0
def Function(self, func):
    dllname = self.find_dllname(func)
    if dllname:
        self.generate(func.returns)
        self.generate_all(func.arguments)
        args = [self.type_name(a) for a in func.arguments]
        if "__stdcall__" in func.attributes:
            cc = "stdcall"
        else:
            cc = "cdecl"
        libname = self.get_sharedlib(dllname)
        print &gt;&gt; self.stream
        if self.use_decorators:
            print &gt;&gt; self.stream, "@ %s(%s, '%s', [%s])" % \
                  (cc, self.type_name(func.returns), libname, ", ".join(args))
        argnames = ["p%d" % i for i in range(1, 1+len(args))]
        # function definition
        print &gt;&gt; self.stream, "def %s(%s):" % (func.name, ", ".join(argnames))
        if func.location:
            print &gt;&gt; self.stream, "    # %s %s" % func.location
        print &gt;&gt; self.stream, "    return %s._api_(%s)" % (func.name, ", ".join(argnames))
        if not self.use_decorators:
            print &gt;&gt; self.stream, "%s = %s(%s, '%s', [%s]) (%s)" % \
                  (func.name, cc, self.type_name(func.returns), libname, ", ".join(args), func.name)
        print &gt;&gt; self.stream
        self.names.add(func.name)
        self._functiontypes += 1
    else:
        self._notfound_functiontypes += 1
</t>
<t tx="ekr.20050704170316.37">def FundamentalType(self, item):
    pass # we should check if this is known somewhere
</t>
<t tx="ekr.20050704170316.38">##        name = ctypes_names[item.name]
##        if name !=  "None":
##            print &gt;&gt; self.stream, "from ctypes import %s" % name
##        self.done.add(item)

########

def generate(self, item):
    if item in self.done:
        return
    if isinstance(item, typedesc.StructureHead):
        name = getattr(item.struct, "name", None)
    else:
        name = getattr(item, "name", None)
    if name in self.known_symbols:
        mod = self.known_symbols[name]
        print &gt;&gt; self.imports, "from %s import %s" % (mod, name)
        self.done.add(item)
        if isinstance(item, typedesc.Structure):
            self.done.add(item.get_head())
            self.done.add(item.get_body())
        return
    mth = getattr(self, type(item).__name__)
    # to avoid infinite recursion, we have to mark it as done
    # before actually generating the code.
    self.done.add(item)
    mth(item)
</t>
<t tx="ekr.20050704170316.39">def generate_all(self, items):
    for item in items:
        self.generate(item)
</t>
<t tx="ekr.20050704170316.40">def generate_code(self, items):
    print &gt;&gt; self.imports, "from ctypes import *"
    items = set(items)
    loops = 0
    while items:
        loops += 1
        self.more = set()
        self.generate_all(items)

        items |= self.more
        items -= self.done

##        self.output.write(self.imports.getvalue())
##        self.output.write("\n\n")
##        self.output.write(self.stream.getvalue())

    return loops
</t>
<t tx="ekr.20050704170316.41">def print_stats(self, stream):
    total = self._structures + self._functiontypes + self._enumtypes + self._typedefs +\
            self._pointertypes + self._arraytypes
    print &gt;&gt; stream, "###########################"
    print &gt;&gt; stream, "# Symbols defined:"
    print &gt;&gt; stream, "#"
    print &gt;&gt; stream, "# Variables:          %5d" % self._variables
    print &gt;&gt; stream, "# Struct/Unions:      %5d" % self._structures
    print &gt;&gt; stream, "# Functions:          %5d" % self._functiontypes
    print &gt;&gt; stream, "# Enums:              %5d" % self._enumtypes
    print &gt;&gt; stream, "# Enum values:        %5d" % self._enumvalues
    print &gt;&gt; stream, "# Typedefs:           %5d" % self._typedefs
    print &gt;&gt; stream, "# Pointertypes:       %5d" % self._pointertypes
    print &gt;&gt; stream, "# Arraytypes:         %5d" % self._arraytypes
    print &gt;&gt; stream, "# unknown functions:  %5d" % self._notfound_functiontypes
    print &gt;&gt; stream, "#"
    print &gt;&gt; stream, "# Total symbols: %5d" % total
    print &gt;&gt; stream, "###########################"
</t>
<t tx="ekr.20050704170316.42">################################################################

def generate_code(xmlfile,
                  outfile,
                  expressions=None,
                  symbols=None,
                  verbose=False,
                  use_decorators=False,
                  known_symbols=None,
                  searched_dlls=None,
                  types=None):
    # expressions is a sequence of compiled regular expressions,
    # symbols is a sequence of names
    from gccxmlparser import parse
    items = parse(xmlfile)

    # filter symbols to generate
    todo = []

    if types:
        items = [i for i in items if isinstance(i, types)]
    
    if symbols:
        syms = set(symbols)
        for i in items:
            if i.name in syms:
                todo.append(i)
                syms.remove(i.name)

        if syms:
            print "symbols not found", list(syms)

    if expressions:
        for i in items:
            for s in expressions:
                if i.name is None:
                    continue
                match = s.match(i.name)
                # we only want complete matches
                if match and match.group() == i.name:
                    todo.append(i)
                    break
    if symbols or expressions:
        items = todo

    ################
    gen = Generator(outfile,
                    use_decorators=use_decorators,
                    known_symbols=known_symbols,
                    searched_dlls=searched_dlls)

    loops = gen.generate_code(items)
    if verbose:
        gen.print_stats(sys.stderr)
        print &gt;&gt; sys.stderr, "needed %d loop(s)" % loops
</t>
<t tx="ekr.20050704170316.43">@ignore
@language python
&lt;&lt; cparser declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170316.44">import sys, os, re, tempfile
from cparser_config import C_KEYWORDS, EXCLUDED, EXCLUDED_RE
import gccxmlparser, typedesc
try:
    import subprocess
except ImportError:
    subprocess = None
try:
    set
except NameError:
    from sets import Set as set

if sys.platform == "win32":

</t>
<t tx="ekr.20050704170316.45">def _locate_gccxml():
    import _winreg
    for subkey in (r"Software\gccxml", r"Software\Kitware\GCC_XML"):
        for root in (_winreg.HKEY_CURRENT_USER, _winreg.HKEY_LOCAL_MACHINE):
            try:
                hkey = _winreg.OpenKey(root, subkey, 0, _winreg.KEY_READ)
            except WindowsError, detail:
                if detail.errno != 2:
                    raise
            else:
                return _winreg.QueryValueEx(hkey, "loc")[0] + r"\bin"
</t>
<t tx="ekr.20050704170316.46">
loc = _locate_gccxml()
if loc:
    os.environ["PATH"] = loc

class CompilerError(Exception):
	&lt;&lt; class CompilerError declarations &gt;&gt;
</t>
<t tx="ekr.20050704170316.47">pass

</t>
<t tx="ekr.20050704170316.48">class IncludeParser(object):
	@others
</t>
<t tx="ekr.20050704170316.49">def __init__(self, options):
    """
    options must be an object having these attributes:
      verbose - integer
      flags - sequence of strings
      keep_temporary_files - true if temporary files should not be deleted
      cpp_symbols - whether to include preprocessor symbols in the XML file
      excluded_symbols - collection of names for additional preprocessor symbols to exclude
      excluded_symbols_re - collection of regular expressions for names to exclude
      xml_file - pathname of output file (may be None)
    """
    self.options = options
    self.excluded = set()
    self.excluded.update(EXCLUDED)
    self.excluded.update(self.options.excluded_symbols)

    self.excluded_re = set()
    self.excluded_re.update(EXCLUDED_RE)
    self.excluded_re.update(self.options.excluded_symbols_re)
</t>
<t tx="ekr.20050704170316.50">def create_source_file(self, lines, ext=".cpp"):
    "Create a temporary file, write lines to it, and return the filename"
    fd, fname = tempfile.mkstemp(ext, text=True)
    stream = os.fdopen(fd, "w")
    if lines:
        for line in lines:
            stream.write("%s\n" % line)
    stream.close()
    return fname
</t>
<t tx="ekr.20050704170316.51">def compile_and_dump(self, lines=None):
    """Create a temporary source file, dump preprocessor
    definitions, and remove the source file again."""
    fname = self.create_source_file(lines)
    try:
        args = ["gccxml", "--preprocess", "-dM", fname]
        if lines and self.options.flags:
            args.extend(self.options.flags)
        if self.options.verbose:
            print &gt;&gt; sys.stderr, "running:", " ".join(args)
        if subprocess:
            proc = subprocess.Popen(args,
                                    stdout=subprocess.PIPE,
                                    stdin=subprocess.PIPE)
            data, err = proc.communicate()
        else:
            i, o = os.popen4(" ".join(args))
            i.close()
            data = o.read()
    finally:
        if not self.options.keep_temporary_files:
            os.remove(fname)
        else:
            print &gt;&gt; sys.stderr, "Info: file '%s' not removed" % fname
    return [line[len("#define "):]
            for line in data.splitlines()
            if line.startswith("#define ")]
</t>
<t tx="ekr.20050704170316.52">def create_xml(self, lines, xmlfile):
    """Create a temporary source file, 'compile' with gccxml to an
    xmlfile, and remove the source file again."""
    fname = self.create_source_file(lines)
    args = ["gccxml", fname, "-fxml=%s" % xmlfile]
    if self.options.flags:
        args.extend(self.options.flags)
    try:
        if self.options.verbose:
            print &gt;&gt; sys.stderr, "running:", " ".join(args)
        if subprocess:
            proc = subprocess.Popen(args,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE,
                                    stdin=subprocess.PIPE)
            data, err = proc.communicate()
            retcode = proc.wait()
            if retcode:
                self.display_compiler_errors(err.splitlines())
        else:
            retcode = os.system(" ".join(args))
        if retcode:
            raise CompilerError, "gccxml returned %s" % retcode
    finally:
        if not self.options.keep_temporary_files:
            os.remove(fname)
        else:
            print &gt;&gt; sys.stderr, "Info: file '%s' not removed" % fname
</t>
<t tx="ekr.20050704170316.53">def display_compiler_errors(self, lines):
    print &gt;&gt; sys.stderr, "Compiler errors on these source lines:"
    import re, linecache
    pat = re.compile(r"(.*\.cpp):(\d+):(.*)")
    output = []
    for line in lines:
        match = pat.search(line)
        if match:
            fnm, lineno, errmsg = match.groups()
            if re.match(r"\d+:", errmsg):
                errmsg = errmsg.split(":", 1)[1]
            text = "'%s' %s" % (linecache.getline(fnm, int(lineno)).rstrip(), errmsg)
            output.append(text)
        if line.startswith(" ") and output:
            output[-1] = output[-1] + line.strip()
    for line in output:
        print &gt;&gt; sys.stderr, line
</t>
<t tx="ekr.20050704170316.54">def get_defines(self, include_files):
    """'Compile' an include file with gccxml, and return a
    dictionary of preprocessor definitions.  Empty and compiler
    internal definitions are not included."""
    # compiler internal definitions
    lines = self.compile_and_dump()
    predefined = [line.split(None, 1)[0]
                  for line in lines]
    # all definitions
    code = ['#include "%s"' % fname for fname in include_files]
    lines = self.compile_and_dump(code)
    defined = [line.split(None, 1)
               for line in lines]
    # remove empty and compiler internal definitions
    defined = [pair for pair in defined
               if len(pair) == 2 and pair[0] not in predefined]

    return dict(defined)
</t>
<t tx="ekr.20050704170316.55">wordpat = re.compile("^[a-zA-Z_][a-zA-Z0-9_]*$")
def is_excluded(self, name, value):

    INVALID_CHARS = "=/{}&amp;;"
    if "(" in name:
        return "IS_FUNCTION"
    if value in C_KEYWORDS:
        return "value is keyword"
    if name in self.excluded:
        return "excluded"
    for pat in self.excluded_re:
        if pat.match(name):
            return "excluded (regex)"
    if value[0] in INVALID_CHARS or value[-1] in INVALID_CHARS:
        return "cannot be a value"
    if self.wordpat.match(name) and self.wordpat.match(value):
        # aliases are handled later, when (and if!) the rhs is known
        return "IS_ALIAS"
    return False
</t>
<t tx="ekr.20050704170316.56">def filter_definitions(self, defines):
    """Return a dict of aliases, a dict of fucntion-like macros, and
    another dict of constants and literals"""
    result = {}
    aliases = {}
    functions = {}
    excluded = {}
    for name, value in defines.iteritems():
        why = self.is_excluded(name, value)
        if not why:
            result[name] = value
        elif why == "IS_ALIAS":
            aliases[name] = value
        elif why == "IS_FUNCTION":
            functions[name] = value
        else:
            excluded[name] = value
    return aliases, functions, excluded, result
</t>
<t tx="ekr.20050704170316.57">################################################################

def find_types(self, include_files, defines):
    source = []
    for fname in include_files:
        source.append('#include "%s"' % fname)
    source.append("#define DECLARE(sym) template &lt;typename T&gt; T symbol_##sym(T) {}")
    source.append("#define DEFINE(sym) symbol_##sym(sym)")
    for name in defines:
        # create a function template for each value
        source.append("DECLARE(%s)" % name)
    source.append("int main() {")
    for name in defines:
        # instantiate a function template.
        # The return type of the function is the symbol's type.
        source.append("  DEFINE(%s);" % name)
    source.append("}")

    fd, fname = tempfile.mkstemp(".xml")
    os.close(fd)
    self.create_xml(source, fname)
    try:
        items = gccxmlparser.parse(fname)
    finally:
        # make sure the temporary file is removed after using it
        if not self.options.keep_temporary_files:
            os.remove(fname)
        else:
            print &gt;&gt; sys.stderr, "Info: file '%s' not removed" % fname

    types = {}
    for i in items:
        name = getattr(i, "name", None)
        if name and name.startswith("symbol_"):
            name = name[len("symbol_"):]
            typ = i.returns
            try:
                typ = self.c_type_name(i.returns)
            except TypeError, detail:
                # XXX Warning?
                print &gt;&gt; sys.stderr,  "skipped #define %s %s" % (name, defines[name]), detail
            else:
                types[name] = typ
    return types
</t>
<t tx="ekr.20050704170316.58">def create_final_xml(self, include_files, types):
    source = []
    for fname in include_files:
        source.append('#include "%s"' % fname)
    for name, value in types.iteritems():
        source.append("const %s cpp_sym_%s = %s;" % (types[name], name, name))
    fname = self.options.xmlfile
    self.create_xml(source, fname)
</t>
<t tx="ekr.20050704170316.59">def c_type_name(self, tp):
    "Return the C type name for this type."
    if isinstance(tp, typedesc.FundamentalType):
        return tp.name
    elif isinstance(tp, typedesc.PointerType):
        return "%s *" % self.c_type_name(tp.typ)
    elif isinstance(tp, typedesc.CvQualifiedType):
        return self.c_type_name(tp.typ)
    elif isinstance(tp, typedesc.Typedef):
        return self.c_type_name(tp.typ)
    elif isinstance(tp, typedesc.Structure):
        return tp.name
    raise TypeError, type(tp).__name__
</t>
<t tx="ekr.20050704170316.60">def dump_as_cdata(self, f, mapping, name):
        f.write('  &lt;CPP_DUMP name="%s"&gt;&lt;![CDATA[' % name)
        names = mapping.keys()
        names.sort()
        for n in names:
            v = mapping[n]
            f.write("%s %s\n" % (n, v))
        f.write("]]&gt;&lt;/CPP_DUMP&gt;\n")
</t>
<t tx="ekr.20050704170316.61">################################################################

def parse(self, include_files):
    """Parse include files."""
    options = self.options
    
    if options.cpp_symbols:
        if options.verbose:
            print &gt;&gt; sys.stderr, "finding definitions ..."
        defines = self.get_defines(include_files)
        if options.verbose:
            print &gt;&gt; sys.stderr, "%d found" % len(defines)

            print &gt;&gt; sys.stderr, "filtering definitions ..."
        aliases, functions, excluded, defines = self.filter_definitions(defines)
        if options.verbose:
            print &gt;&gt; sys.stderr, "%d values, %d aliases" % (len(defines), len(aliases))

        if options.verbose:
            print &gt;&gt; sys.stderr, "finding definitions types ..."
            # invoke C++ template magic
        types = self.find_types(include_files, defines)
        if options.verbose:
            print &gt;&gt; sys.stderr, "found %d types ..." % len(types)
    else:
        types = {}
        functions = {}
        aliases = {}
        excluded = {}

    if options.verbose:
        print &gt;&gt; sys.stderr, "creating xml output file ..."
    self.create_final_xml(include_files, types)

    # Include additional preprecessor definitions into the XML file.

    if self.options.xmlfile:
        f = open(self.options.xmlfile, "r+")
        f.seek(-12, 2)
        data = f.read()
        if len(data) == 11:
            # text mode on windows is strange.  You read 12
            # characters, but get 11.
            assert data == "&lt;/GCC_XML&gt;\n"
            f.seek(-12, 2)
        else:
            # linux, ...
            assert data == "\n&lt;/GCC_XML&gt;\n"
            f.seek(-11, 2)
        f.flush()

        self.dump_as_cdata(f, functions, "functions")
        self.dump_as_cdata(f, aliases, "aliases")
        self.dump_as_cdata(f, excluded, "excluded")

        f.write("&lt;/GCC_XML&gt;\n")
        f.close()
</t>
<t tx="ekr.20050704170316.62">@ignore
@language python
# cparser_config.py - configuration items for cparser.py
#
# XXX Should this be converted to the h2xml.cfg style?
import re, sys, os

# C keywords, according to MSDN, plus some additional
# names like __forceinline, near, far.

# Skip all definitions where the rhs is a keyword
# Example: #define CALLBACK __stdcall
#
# Hm, should types be handled differently?
# Example: #define VOID void
C_KEYWORDS = """__asm else main struct __assume enum
__multiple_inheritance switch auto __except __single_inheritance
template __based explicit __virtual_inheritance this bool extern
mutable thread break false naked throw case __fastcall namespace true
catch __finally new try __cdecl float noreturn __try char for operator
typedef class friend private typeid const goto protected typename
const_cast if public union continue inline register unsigned
__declspec __inline default int return uuid delete __int8 short
__uuidof dllexport __int16 signed virtual dllimport __int32 sizeof
void do __int64 static volatile double __leave static_cast wmain
dynamic_cast long __stdcall while far near __forceinline __w64
__noop""".split()
C_KEYWORDS.append("long long")

# defines we know that won't work
# for windows.h
EXCLUDED_win32 = """
TTTOOLINFOA_V3_SIZE
TTTOOLINFOW_V3_SIZE
NMLVCUSTOMDRAW_V3_SIZE
NOTIFYICONDATAA_V1_SIZE
NOTIFYICONDATAA_V2_SIZE
PROPSHEETHEADERA_V1_SIZE
PROPSHEETHEADERA_V2_SIZE
PROPSHEETHEADERW_V2_SIZE
NOTIFYICONDATAW_V2_SIZE
s_imp
s_host
s_lh
s_net
s_addr
h_addr
s_impno
_VARIANT_BOOL
MIDL_uhyper
WINSCARDDATA
__MIDL_DECLSPEC_DLLIMPORT
__MIDL_DECLSPEC_DLLEXPORT
NCB_POST
STDAPI
STDAPIV
WINAPI
SHDOCAPI
WINOLEAUTAPI
WINOLEAPI
APIENTRY
EXTERN_C
FIRMWARE_PTR
STDMETHODIMPV
STDMETHODIMP
DEFAULT_UNREACHABLE
MAXLONGLONG
IMAGE_ORDINAL_FLAG64
SECURITY_NT_AUTHORITY
LLONG_MAX
LLONG_MIN
ULLONG_MAX
""".strip().split()
# The ..LONG_MIN and ..LONG_MAX symbols are in MSVC 7.1 limits.h,
# gccxml complains: integer constant is too large for "long" type

EXCLUDED_linux = """
_IOT_termios
""".strip().split()

if sys.platform == "win32":
    EXCLUDED = EXCLUDED_win32
elif sys.platform.startswith("linux"):
    EXCLUDED = EXCLUDED_linux
else:
    EXCLUDED = []

EXCLUDED = [text for text in EXCLUDED
            if not text.startswith("#")]

EXCLUDED_RE_win32 = r"""
^DECLSPEC\w*$
""".strip().split()

EXCLUDED_RE_linux = r"""
^__\w*$
^__attribute_\w*_$
^_G_HAVE_ST_BLKSIZE$
""".strip().split()

if sys.platform == "win32":
    EXCLUDED_RE = EXCLUDED_RE_win32
elif sys.platform.startswith("linux"):
    EXCLUDED_RE = EXCLUDED_RE_linux
else:
    EXCLUDED_RE = []

EXCLUDED_RE = [re.compile(pat) for pat in EXCLUDED_RE
               if not pat.startswith("#")]
</t>
<t tx="ekr.20050704170316.63">@ignore
@language python
&lt;&lt; gccxmlparser declarations &gt;&gt;
@others
</t>
<t tx="ekr.20050704170316.64">"""gccxmlparser - parse a gccxml created XML file into a sequence type descriptions"""
import xml.sax
import typedesc
import sys
try:
    set
except NameError:
    from sets import Set as set
import re

################################################################

</t>
<t tx="ekr.20050704170316.65">def MAKE_NAME(name):
    name = name.replace("$", "DOLLAR")
    name = name.replace(".", "DOT")
    if name.startswith("__"):
        return "_X" + name
    elif name[0] in "01234567879":
        return "_" + name
    return name
</t>
<t tx="ekr.20050704170316.66">WORDPAT = re.compile("^[a-zA-Z_][a-zA-Z0-9_]*$")

def CHECK_NAME(name):
    if WORDPAT.match(name):
        return name
    return None
</t>
<t tx="ekr.20050704170316.67">
class GCCXML_Handler(xml.sax.handler.ContentHandler):
	&lt;&lt; class GCCXML_Handler declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.68">has_values = set(["Enumeration", "Function", "FunctionType",
                  "OperatorFunction", "Method", "Constructor",
                  "Destructor", "OperatorMethod"])

</t>
<t tx="ekr.20050704170316.69">def __init__(self, *args):
    xml.sax.handler.ContentHandler.__init__(self, *args)
    self.context = []
    self.all = {}
    self.cpp_data = {}
</t>
<t tx="ekr.20050704170316.70">def startElement(self, name, attrs):
    # find and call the handler for this element
    mth = getattr(self, name)
    result = mth(attrs)
    if result is not None:
        location = attrs.get("location", None)
        if location is not None:
            result.location = location
        # record the result
        _id = attrs.get("id", None)
        # The '_id' attribute is used to link together all the
        # nodes, in the _fixup_ methods.
        if _id is not None:
            self.all[_id] = result
        else:
            # EnumValue, for example, has no "_id" attribute.
            # Invent our own...
            self.all[id(result)] = result
    # if this element has children, push onto the context
    if name in self.has_values:
        self.context.append(result)
</t>
<t tx="ekr.20050704170316.71">cdata = None
def endElement(self, name):
    # if this element has children, pop the context
    if name in self.has_values:
        self.context.pop()
    self.cdata = None
</t>
<t tx="ekr.20050704170316.72">################################
# do-nothing element handlers

def Class(self, attrs): pass
</t>
<t tx="ekr.20050704170316.73">def Destructor(self, attrs): pass
</t>
<t tx="ekr.20050704170316.74">def GCC_XML(self, attrs): pass
</t>
<t tx="ekr.20050704170316.75">def Namespace(self, attrs): pass
</t>
<t tx="ekr.20050704170316.76">def Base(self, attrs): pass
</t>
<t tx="ekr.20050704170316.77">def Ellipsis(self, attrs): pass
</t>
<t tx="ekr.20050704170316.78">def OperatorMethod(self, attrs): pass
</t>
<t tx="ekr.20050704170316.79">################################
# real element handlers

def CPP_DUMP(self, attrs):
    name = attrs["name"]
    # Insert a new list for each named section into self.cpp_data,
    # and point self.cdata to it.  self.cdata will be set to None
    # again at the end of each section.
    self.cpp_data[name] = self.cdata = []
</t>
<t tx="ekr.20050704170316.80">def characters(self, content):
    if self.cdata is not None:
        self.cdata.append(content)
</t>
<t tx="ekr.20050704170316.81">def File(self, attrs):
    name = attrs["name"]
    if sys.platform == "win32" and " " in name:
        # On windows, convert to short filename if it contains blanks
        from ctypes import windll, create_unicode_buffer, sizeof, WinError
        buf = create_unicode_buffer(512)
        if windll.kernel32.GetShortPathNameW(name, buf, sizeof(buf)):
            name = buf.value
    return typedesc.File(name)
</t>
<t tx="ekr.20050704170316.82">def _fixup_File(self, f): pass
</t>
<t tx="ekr.20050704170316.83"># simple types and modifiers

def Variable(self, attrs):
    name = attrs["name"]
    if name.startswith("cpp_sym_"):
        # XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx fix me!
        name = name[len("cpp_sym_"):]
    init = attrs.get("init", None)
    typ = attrs["type"]
    return typedesc.Variable(name, typ, init)
</t>
<t tx="ekr.20050704170316.84">def _fixup_Variable(self, t):
    t.typ = self.all[t.typ]
</t>
<t tx="ekr.20050704170316.85">def Typedef(self, attrs):
    name = attrs["name"]
    typ = attrs["type"]
    return typedesc.Typedef(name, typ)
</t>
<t tx="ekr.20050704170316.86">def _fixup_Typedef(self, t):
    t.typ = self.all[t.typ]
</t>
<t tx="ekr.20050704170316.87">def FundamentalType(self, attrs):
    name = attrs["name"]
    if name == "void":
        size = ""
    else:
        size = attrs["size"]
    align = attrs["align"]
    return typedesc.FundamentalType(name, size, align)
</t>
<t tx="ekr.20050704170316.88">def _fixup_FundamentalType(self, t): pass
</t>
<t tx="ekr.20050704170316.89">def PointerType(self, attrs):
    typ = attrs["type"]
    size = attrs["size"]
    align = attrs["align"]
    return typedesc.PointerType(typ, size, align)
</t>
<t tx="ekr.20050704170316.90">def _fixup_PointerType(self, p):
    p.typ = self.all[p.typ]
</t>
<t tx="ekr.20050704170316.91">ReferenceType = PointerType
_fixup_ReferenceType = _fixup_PointerType

def ArrayType(self, attrs):
    # type, min?, max?
    typ = attrs["type"]
    min = attrs["min"]
    max = attrs["max"]
    if max == "ffffffffffffffff":
        max = "-1"
    return typedesc.ArrayType(typ, min, max)
</t>
<t tx="ekr.20050704170316.92">def _fixup_ArrayType(self, a):
    a.typ = self.all[a.typ]
</t>
<t tx="ekr.20050704170316.93">def CvQualifiedType(self, attrs):
    # id, type, [const|volatile]
    typ = attrs["type"]
    const = attrs.get("const", None)
    volatile = attrs.get("volatile", None)
    return typedesc.CvQualifiedType(typ, const, volatile)
</t>
<t tx="ekr.20050704170316.94">def _fixup_CvQualifiedType(self, c):
    c.typ = self.all[c.typ]
</t>
<t tx="ekr.20050704170316.95"># callables

def Function(self, attrs):
    # name, returns, extern, attributes
    name = attrs["name"]
    returns = attrs["returns"]
    attributes = attrs.get("attributes", "").split()
    extern = attrs.get("extern")
    return typedesc.Function(name, returns, attributes, extern)
</t>
<t tx="ekr.20050704170316.96">def _fixup_Function(self, func):
    func.returns = self.all[func.returns]
    func.arguments = [self.all[a] for a in func.arguments]
</t>
<t tx="ekr.20050704170316.97">def FunctionType(self, attrs):
    # id, returns, attributes
    returns = attrs["returns"]
    attributes = attrs.get("attributes", "").split()
    return typedesc.FunctionType(returns, attributes)
</t>
<t tx="ekr.20050704170316.98">def _fixup_FunctionType(self, func):
    func.returns = self.all[func.returns]
    func.arguments = [self.all[a] for a in func.arguments]
</t>
<t tx="ekr.20050704170316.99">def OperatorFunction(self, attrs):
    # name, returns, extern, attributes
    name = attrs["name"]
    returns = attrs["returns"]
    return typedesc.OperatorFunction(name, returns)
</t>
<t tx="ekr.20050704170316.100">def _fixup_OperatorFunction(self, func):
    func.returns = self.all[func.returns]
</t>
<t tx="ekr.20050704170316.101">def Constructor(self, attrs):
    name = attrs["name"]
    return typedesc.Constructor(name)
</t>
<t tx="ekr.20050704170316.102">def _fixup_Constructor(self, const): pass
</t>
<t tx="ekr.20050704170316.103">def Method(self, attrs):
    # name, virtual, pure_virtual, returns
    name = attrs["name"]
    returns = attrs["returns"]
    return typedesc.Method(name, returns)
</t>
<t tx="ekr.20050704170316.104">def _fixup_Method(self, m):
    m.returns = self.all[m.returns]
    m.arguments = [self.all[a] for a in m.arguments]
</t>
<t tx="ekr.20050704170316.105">def Argument(self, attrs):
    typ = attrs["type"]
    parent = self.context[-1]
    if parent is not None:
        parent.add_argument(typ) # name?
</t>
<t tx="ekr.20050704170316.106"># enumerations

def Enumeration(self, attrs):
    # id, name
    name = attrs["name"]
    # If the name isn't a valid Python identifier, create an unnamed enum
    name = CHECK_NAME(name)
    size = attrs["size"]
    align = attrs["align"]
    return typedesc.Enumeration(name, size, align)
</t>
<t tx="ekr.20050704170316.107">def _fixup_Enumeration(self, e): pass
</t>
<t tx="ekr.20050704170316.108">def EnumValue(self, attrs):
    name = attrs["name"]
    value = attrs["init"]
    v = typedesc.EnumValue(name, value, self.context[-1])
    self.context[-1].add_value(v)
    return v
</t>
<t tx="ekr.20050704170316.109">def _fixup_EnumValue(self, e): pass
</t>
<t tx="ekr.20050704170316.110"># structures, unions

def Struct(self, attrs):
    # id, name, members
    name = attrs.get("name")
    if name is None:
        name = MAKE_NAME(attrs["mangled"])
    bases = attrs.get("bases", "").split()
    members = attrs.get("members", "").split()
    align = attrs["align"]
    size = attrs.get("size")
    return typedesc.Structure(name, align, members, bases, size)
</t>
<t tx="ekr.20050704170316.111">def _fixup_Structure(self, s):
    s.members = [self.all[m] for m in s.members]
    s.bases = [self.all[b] for b in s.bases]
</t>
<t tx="ekr.20050704170316.112">_fixup_Union = _fixup_Structure

def Union(self, attrs):
    name = attrs.get("name")
    if name is None:
        name = MAKE_NAME(attrs["mangled"])
    bases = attrs.get("bases", "").split()
    members = attrs.get("members", "").split()
    align = attrs["align"]
    size = attrs.get("size")
    return typedesc.Union(name, align, members, bases, size)
</t>
<t tx="ekr.20050704170316.113">def Field(self, attrs):
    # name, type
    name = attrs["name"]
##        if name.startswith("__") and not name.endswith("__"):
##            print "INVALID FIELD NAME", name
    typ = attrs["type"]
    bits = attrs.get("bits", None)
    offset = attrs.get("offset")
    return typedesc.Field(name, typ, bits, offset)
</t>
<t tx="ekr.20050704170316.114">def _fixup_Field(self, f):
    f.typ = self.all[f.typ]
</t>
<t tx="ekr.20050704170316.115">################

def _fixup_Macro(self, m):
    pass
</t>
<t tx="ekr.20050704170316.116">def get_macros(self, text):
    if text is None:
        return
    text = "".join(text)
    # preprocessor definitions that look like macros with one or more arguments
    for m in text.splitlines():
        name, body = m.split(None, 1)
        name, args = name.split("(", 1)
        args = "(%s" % args
        self.all[name] = typedesc.Macro(name, args, body)
</t>
<t tx="ekr.20050704170316.117">def get_aliases(self, text, namespace):
    if text is None:
        return
    # preprocessor definitions that look like aliases:
    #  #define A B
    text = "".join(text)
    aliases = {}
    for a in text.splitlines():
        name, value = a.split(None, 1)
        a = typedesc.Alias(name, value)
        aliases[name] = a
        self.all[name] = a

    for name, a in aliases.items():
        value = a.alias
        # the value should be either in namespace...
        if value in namespace:
            # set the type
            a.typ = namespace[value]
        # or in aliases...
        elif value in aliases:
            a.typ = aliases[value]
        # or unknown.
        else:
            # not known
##                print "skip %s = %s" % (name, value)
            pass
</t>
<t tx="ekr.20050704170316.118">def get_result(self):
    interesting = (typedesc.Typedef, typedesc.Enumeration, typedesc.EnumValue,
                   typedesc.Function, typedesc.Structure, typedesc.Union,
                   typedesc.Variable, typedesc.Macro, typedesc.Alias)

    self.get_macros(self.cpp_data.get("functions"))

    remove = []
    for n, i in self.all.items():
        location = getattr(i, "location", None)
        if location:
            fil, line = location.split(":")
            i.location = self.all[fil].name, line
        # link together all the nodes (the XML that gccxml generates uses this).
        mth = getattr(self, "_fixup_" + type(i).__name__)
        try:
            mth(i)
        except KeyError: # XXX better exception catching
            remove.append(n)

    for n in remove:
        del self.all[n]

    # Now we can build the namespace.
    namespace = {}
    for i in self.all.values():
        if not isinstance(i, interesting):
            continue  # we don't want these
        name = getattr(i, "name", None)
        if name is not None:
            namespace[name] = i

    self.get_aliases(self.cpp_data.get("aliases"), namespace)

    result = []
    for i in self.all.values():
        if isinstance(i, interesting):
            result.append(i)

    return result
</t>
<t tx="ekr.20050704170316.119">################################################################

def parse(xmlfile):
    # parse an XML file into a sequence of type descriptions
    handler = GCCXML_Handler()
    xml.sax.parse(xmlfile, handler)
    return handler.get_result()
</t>
<t tx="ekr.20050704170316.120">@ignore
@language python
&lt;&lt; h2xml declarations &gt;&gt;
@others

    excluded = get_option("excluded", "").split()
    excluded_re = get_option("excluded_re", "").split()
    
    parser = OptionParser("usage: %prog includefile ... [options]")
    parser.add_option("-q", "--quiet",
                      dest="quiet",
                      action="store_true",
                      default=False)

    parser.add_option("-D",
                      type="string",
                      action="callback",
                      callback=add_option,
                      dest="gccxml_options",
                      help="macros to define",
                      metavar="NAME[=VALUE]",
                      default=[])

    parser.add_option("-U",
                      type="string",
                      action="callback",
                      callback=add_option,
                      help="macros to undefine",
                      metavar="NAME")

    parser.add_option("-I",
                      type="string",
                      action="callback",
                      callback=add_option,
                      dest="gccxml_options",
                      help="additional include directories",
                      metavar="DIRECTORY")

    parser.add_option("-o",
                      dest="xmlfile",
                      help="XML output filename",
                      default=None)

    parser.add_option("-c", "--cpp-symbols",
                      dest="cpp_symbols",
                      action="store_true",
                      help="try to find #define symbols - this may give compiler errors, " \
                      "so it's off by default.",
                      default=False)

    parser.add_option("-k",
                      dest="keep_temporary_files",
                      action="store_true",
                      help="don't delete the temporary files created "\
                      "(useful for finding problems)",
                      default=False)

    parser.add_option("-s",
                      dest="excluded_symbols",
                      action="append",
                      help="specify preprocessor symbol name to exclude",
                      default=excluded)

    parser.add_option("-r",
                      dest="excluded_symbols_re",
                      action="append",
                      help="regular expression for preprocessor symbol names to exclude",
                      default=[])

    options, files = parser.parse_args()

    if not files:
        print "Error: no files to process"
        print &gt;&gt; sys.stderr, __doc__
        return 1

    options.flags = options.gccxml_options

    options.verbose = not options.quiet

    options.excluded_symbols_re = [re.compile(pat) for pat in options.excluded_symbols_re]

    try:
        parser = cparser.IncludeParser(options)
        parser.parse(files)
    except cparser.CompilerError, detail:
        print &gt;&gt; sys.stderr, "CompilerError:", detail
        return 1

if __name__ == "__main__":
    main()
</t>
<t tx="ekr.20050704170316.121">"""h2xml - convert C include file(s) into an xml file by running gccxml."""
import sys, os, tempfile, re, ConfigParser
import cparser
from optparse import OptionParser

if sys.platform == "win32":

</t>
<t tx="ekr.20050704170316.122">def _locate_gccxml():
    import _winreg
    for subkey in (r"Software\gccxml", r"Software\Kitware\GCC_XML"):
        for root in (_winreg.HKEY_CURRENT_USER, _winreg.HKEY_LOCAL_MACHINE):
            try:
                hkey = _winreg.OpenKey(root, subkey, 0, _winreg.KEY_READ)
            except WindowsError, detail:
                if detail.errno != 2:
                    raise
            else:
                return _winreg.QueryValueEx(hkey, "loc")[0] + r"\bin"
</t>
<t tx="ekr.20050704170316.123">loc = _locate_gccxml()
if loc:
    os.environ["PATH"] = loc

################################################################

def main():
</t>
<t tx="ekr.20050704170316.124">def add_option(option, opt, value, parser):
    parser.values.gccxml_options.extend((opt, value))
</t>
<t tx="ekr.20050704170316.125"># Hm, should there be a way to disable the config file?
# And then, this should be done AFTER the parameters are processed.
config = ConfigParser.ConfigParser()
try:
    config.read("h2xml.cfg")
except ConfigParser.ParsingError, detail:
    print &gt;&gt; sys.stderr, detail
    return 1

def get_option(option, default_value):
    # return an option from the platform specific section of the
    # config file, or return the default_value if either the
    # section or the option is not present.
    try:
        return config.get(sys.platform, option)
    except (ConfigParser.NoOptionError, ConfigParser.NoSectionError):
        return default_value
</t>
<t tx="ekr.20050704170316.126">@ignore
@language python
&lt;&lt; typedesc declarations &gt;&gt;
@others

################################################################
</t>
<t tx="ekr.20050704170316.127"># typedesc.py - classes representing C type descriptions
try:
    set
except NameError:
    from sets import Set as set

</t>
<t tx="ekr.20050704170316.128">class _HasArgs(object):
	@others
</t>
<t tx="ekr.20050704170316.129">def add_argument(self, arg):
    self.arguments.append(arg)
</t>
<t tx="ekr.20050704170316.130">
################

class Alias(object):
	&lt;&lt; class Alias declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.131">    # a C preprocessor alias, like #define A B
</t>
<t tx="ekr.20050704170316.132">def __init__(self, name, alias, typ=None):
    self.name = name
    self.alias = alias
    self.typ = typ
</t>
<t tx="ekr.20050704170316.133">
class Macro(object):
	&lt;&lt; class Macro declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.134">    # a C preprocessor definition with arguments
</t>
<t tx="ekr.20050704170316.135">def __init__(self, name, args, body):
    # all arguments are strings, args is the literal argument list
    # *with* the parens around it:
    # Example: Macro("CD_INDRIVE", "(status)", "((int)status &gt; 0)")
    self.name = name
    self.args = args
    self.body = body
</t>
<t tx="ekr.20050704170316.136">
class File(object):
	@others
</t>
<t tx="ekr.20050704170316.137">def __init__(self, name):
    self.name = name
</t>
<t tx="ekr.20050704170316.138">
class Function(_HasArgs):
	&lt;&lt; class Function declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.139">location = None
</t>
<t tx="ekr.20050704170316.140">def __init__(self, name, returns, attributes, extern):
    self.name = name
    self.returns = returns
    self.attributes = attributes # dllimport, __stdcall__, __cdecl__
    self.arguments = []
    self.extern = extern
</t>
<t tx="ekr.20050704170316.141">
class Constructor(_HasArgs):
	&lt;&lt; class Constructor declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.142">location = None
</t>
<t tx="ekr.20050704170316.143">def __init__(self, name):
    self.name = name
    self.arguments = []
</t>
<t tx="ekr.20050704170316.144">
class OperatorFunction(_HasArgs):
	&lt;&lt; class OperatorFunction declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.145">location = None
</t>
<t tx="ekr.20050704170316.146">def __init__(self, name, returns):
    self.name = name
    self.returns = returns
    self.arguments = []
</t>
<t tx="ekr.20050704170316.147">
class FunctionType(_HasArgs):
	&lt;&lt; class FunctionType declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.148">location = None
</t>
<t tx="ekr.20050704170316.149">def __init__(self, returns, attributes):
    self.returns = returns
    self.attributes = attributes
    self.arguments = []
</t>
<t tx="ekr.20050704170316.150">
class Method(_HasArgs):
	&lt;&lt; class Method declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.151">location = None
</t>
<t tx="ekr.20050704170316.152">def __init__(self, name, returns):
    self.name = name
    self.returns = returns
    self.arguments = []
</t>
<t tx="ekr.20050704170316.153">
class FundamentalType(object):
	&lt;&lt; class FundamentalType declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.154">location = None
</t>
<t tx="ekr.20050704170316.155">def __init__(self, name, size, align):
    self.name = name
    if name != "void":
        self.size = int(size)
        self.align = int(align)
</t>
<t tx="ekr.20050704170316.156">        
class PointerType(object):
	&lt;&lt; class PointerType declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.157">location = None
</t>
<t tx="ekr.20050704170316.158">def __init__(self, typ, size, align):
    self.typ = typ
    self.size = int(size)
    self.align = int(align)
</t>
<t tx="ekr.20050704170316.159">
class Typedef(object):
	&lt;&lt; class Typedef declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.160">location = None
</t>
<t tx="ekr.20050704170316.161">def __init__(self, name, typ):
    self.name = name
    self.typ = typ
</t>
<t tx="ekr.20050704170316.162">
class ArrayType(object):
	&lt;&lt; class ArrayType declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.163">location = None
</t>
<t tx="ekr.20050704170316.164">def __init__(self, typ, min, max):
    self.typ = typ
    self.min = min
    self.max = max
</t>
<t tx="ekr.20050704170316.165">
class StructureHead(object):
	&lt;&lt; class StructureHead declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.166">location = None
</t>
<t tx="ekr.20050704170316.167">def __init__(self, struct):
    self.struct = struct
</t>
<t tx="ekr.20050704170316.168">
class StructureBody(object):
	&lt;&lt; class StructureBody declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.169">location = None
</t>
<t tx="ekr.20050704170316.170">def __init__(self, struct):
    self.struct = struct
</t>
<t tx="ekr.20050704170316.171">
class _Struct_Union_Base(object):
	&lt;&lt; class _Struct_Union_Base declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.172">location = None
</t>
<t tx="ekr.20050704170316.173">def get_body(self):
    return self.struct_body
</t>
<t tx="ekr.20050704170316.174">def get_head(self):
    return self.struct_head
</t>
<t tx="ekr.20050704170316.175">
class Structure(_Struct_Union_Base):
	@others
</t>
<t tx="ekr.20050704170316.176">def __init__(self, name, align, members, bases, size, artificial=None):
    self.name = name
    self.align = int(align)
    self.members = members
    self.bases = bases
    self.artificial = artificial
    if size is not None:
        self.size = int(size)
    else:
        self.size = None
    self.struct_body = StructureBody(self)
    self.struct_head = StructureHead(self)
</t>
<t tx="ekr.20050704170316.177">
class Union(_Struct_Union_Base):
	@others
</t>
<t tx="ekr.20050704170316.178">def __init__(self, name, align, members, bases, size, artificial=None):
    self.name = name
    self.align = int(align)
    self.members = members
    self.bases = bases
    self.artificial = artificial
    if size is not None:
        self.size = int(size)
    else:
        self.size = None
    self.struct_body = StructureBody(self)
    self.struct_head = StructureHead(self)
</t>
<t tx="ekr.20050704170316.179">
class Field(object):
	@others
</t>
<t tx="ekr.20050704170316.180">def __init__(self, name, typ, bits, offset):
    self.name = name
    self.typ = typ
    self.bits = bits
    self.offset = int(offset)
</t>
<t tx="ekr.20050704170316.181">
class CvQualifiedType(object):
	@others
</t>
<t tx="ekr.20050704170316.182">def __init__(self, typ, const, volatile):
    self.typ = typ
    self.const = const
    self.volatile = volatile
</t>
<t tx="ekr.20050704170316.183">
class Enumeration(object):
	&lt;&lt; class Enumeration declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.184">location = None
</t>
<t tx="ekr.20050704170316.185">def __init__(self, name, size, align):
    self.name = name
    self.size = int(size)
    self.align = int(align)
    self.values = []
</t>
<t tx="ekr.20050704170316.186">def add_value(self, v):
    self.values.append(v)
</t>
<t tx="ekr.20050704170316.187">
class EnumValue(object):
	@others
</t>
<t tx="ekr.20050704170316.188">def __init__(self, name, value, enumeration):
    self.name = name
    self.value = value
    self.enumeration = enumeration
</t>
<t tx="ekr.20050704170316.189">
class Variable(object):
	&lt;&lt; class Variable declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20050704170316.190">location = None
</t>
<t tx="ekr.20050704170316.191">def __init__(self, name, typ, init=None):
    self.name = name
    self.typ = typ
    self.init = init
</t>
<t tx="ekr.20050707185105">#---------------------------------------------------------------------------
# Log replay

# if -logplay, we need to 'become' the other session. That basically means
# replacing the current command line environment with that of the old
# session and moving on.

# this is needed so that later we know we're in session reload mode, as
# opts_all will get overwritten:
load_logplay = 0

if opts_all.logplay:
    load_logplay = opts_all.logplay 
    opts_debug_save = opts_all.debug
    try:
        logplay = open(opts_all.logplay)
    except IOError:
        if opts_all.debug: IP.InteractiveTB()
        warn('Could not open logplay file '+`opts_all.logplay`)
        # restore state as if nothing had happened and move on, but make
        # sure that later we don't try to actually load the session file
        logplay = None
        load_logplay = 0
        del opts_all.logplay
    else:
        try: 
            logplay.readline()
            logplay.readline();
            # this reloads that session's command line
            cmd = logplay.readline()[6:] 
            exec cmd
            # restore the true debug flag given so that the process of
            # session loading itself can be monitored.
            opts.debug = opts_debug_save
            # save the logplay flag so later we don't overwrite the log
            opts.logplay = load_logplay
            # now we must update our own structure with defaults
            opts_all.update(opts)
            # now load args
            cmd = logplay.readline()[6:] 
            exec cmd
            logplay.close()
        except:
            logplay.close()
            if opts_all.debug: IP.InteractiveTB()
            warn("Logplay file lacking full configuration information.\n"
                 "I'll try to read it, but some things may not work.")</t>
<t tx="ekr.20050707185105.1">#-------------------------------------------------------------------------
# set up output traps: catch all output from files, being run, modules
# loaded, etc. Then give it to the user in a clean form at the end.

#EKR: This only traps stuff during this function, so it should be ok.

msg_out = 'Output messages. '
msg_err = 'Error messages. '
msg_sep = '\n'
msg = Struct(
    config    = OutputTrap('Configuration Loader',msg_out,msg_err,msg_sep,debug,quiet_out=1),
    user_exec = OutputTrap('User File Execution', msg_out,msg_err,msg_sep,debug),
    logplay   = OutputTrap('Log Loader',          msg_out,msg_err,msg_sep,debug),
    summary = ''
)</t>
<t tx="ekr.20050707185105.2">#-------------------------------------------------------------------------
# Process user ipythonrc-type configuration files

# turn on output trapping and log to msg.config
# remember that with debug on, trapping is actually disabled
msg.config.trap_all()

# look for rcfile in current or default directory
try:
    opts_all.rcfile = filefind(opts_all.rcfile,opts_all.ipythondir)
except IOError:
    if opts_all.debug:  IP.InteractiveTB()
    warn('Configuration file %s not found. Ignoring request.'
         % (opts_all.rcfile) )

# 'profiles' are a shorthand notation for config filenames
if opts_all.profile:
    try:
        opts_all.rcfile = filefind('ipythonrc-' + opts_all.profile
                                   + rc_suffix,
                                   opts_all.ipythondir)
    except IOError:
       if opts_all.debug:  IP.InteractiveTB()
       opts.profile = ''  # remove profile from options if invalid
       warn('Profile configuration file %s not found. Ignoring request.'
            % (opts_all.profile) )

# load the config file
rcfiledata = None
if opts_all.quick:
    print 'Launching IPython in quick mode. No config file read.'
elif opts_all.classic:
    print 'Launching IPython in classic mode. No config file read.'
elif opts_all.rcfile:
    try:
        cfg_loader = ConfigLoader(conflict)
        rcfiledata = cfg_loader.load(opts_all.rcfile,typeconv,
                                     'include',opts_all.ipythondir,
                                     purge = 1,
                                     unique = conflict['preserve'])
    except:
        IP.InteractiveTB()
        warn('Problems loading configuration file '+
             `opts_all.rcfile`+
             '\nStarting with default -bare bones- configuration.')
else:
    warn('No valid configuration file found in either currrent directory\n'+
         'or in the IPython config. directory: '+`opts_all.ipythondir`+
         '\nProceeding with internal defaults.')</t>
<t tx="ekr.20050707185105.3">#------------------------------------------------------------------------
# Execute user config

# first, create a valid config structure with the right precedence order:
# defaults &lt; rcfile &lt; command line
IP.rc = rc_def.copy()
IP.rc.update(opts_def)
if rcfiledata:
    # now we can update 
    IP.rc.update(rcfiledata)
IP.rc.update(opts)
IP.rc.update(rc_override)

# Store the original cmd line for reference:
IP.rc.opts = opts
IP.rc.args = args

# create a *runtime* Struct like rc for holding parameters which may be
# created and/or modified by runtime user extensions.
IP.runtime_rc = Struct()

# from this point on, all config should be handled through IP.rc,
# opts* shouldn't be used anymore.

# add personal .ipython dir to sys.path so that users can put things in
# there for customization
sys.path.append(IP.rc.ipythondir)
sys.path.insert(0, '') # add . to sys.path. Fix from Prabhu Ramachandran

# update IP.rc with some special things that need manual
# tweaks. Basically options which affect other options. I guess this
# should just be written so that options are fully orthogonal and we
# wouldn't worry about this stuff!

if IP.rc.classic:
    IP.rc.quick = 1
    IP.rc.cache_size = 0
    IP.rc.pprint = 0
    IP.rc.prompt_in1 = '&gt;&gt;&gt; '
    IP.rc.prompt_in2 = '... '
    IP.rc.prompt_out = ''
    IP.rc.separate_in = IP.rc.separate_out = IP.rc.separate_out2 = '0'
    IP.rc.colors = 'NoColor'
    IP.rc.xmode = 'Plain'

# configure readline
# Define the history file for saving commands in between sessions
if IP.rc.profile:
    histfname = 'history-%s' % IP.rc.profile
else:
    histfname = 'history'
IP.histfile = os.path.join(opts_all.ipythondir,histfname)
# Load readline proper
if IP.rc.readline:
    IP.init_readline()

# update exception handlers with rc file status
otrap.trap_out()  # I don't want these messages ever.
IP.magic_xmode(IP.rc.xmode)
otrap.release_out()

# activate logging if requested and not reloading a log
if IP.rc.logplay:
    IP.magic_logstart(IP.rc.logplay + ' append')
elif  IP.rc.logfile:
    IP.magic_logstart(IP.rc.logfile)
elif IP.rc.log:
    IP.magic_logstart()

# find user editor so that it we don't have to look it up constantly
if IP.rc.editor.strip()=='0':
    try:
        ed = os.environ['EDITOR']
    except KeyError:
        if os.name == 'posix':
            ed = 'vi'  # the only one guaranteed to be there!
        else:
            ed = 'notepad' # same in Windows!
    IP.rc.editor = ed

# Recursive reload
try:
    from IPython import deep_reload
    if IP.rc.deep_reload:
        __builtin__.reload = deep_reload.reload
    else:
        __builtin__.dreload = deep_reload.reload
    del deep_reload
except ImportError:
    pass

# Save the current state of our namespace so that the interactive shell
# can later know which variables have been created by us from config files
# and loading. This way, loading a file (in any way) is treated just like
# defining things on the command line, and %who works as expected.

# DON'T do anything that affects the namespace beyond this point!
IP.internal_ns = __main__.__dict__.copy()

#IP.internal_ns.update(locals()) # so our stuff doesn't show up in %who

# Now run through the different sections of the users's config
if IP.rc.debug:
    print 'Trying to execute the following configuration structure:'
    print '(Things listed first are deeper in the inclusion tree and get'
    print 'loaded first).\n'
    pprint(IP.rc.__dict__)
    
for mod in IP.rc.import_mod:
    try:
        exec 'import '+mod in IP.user_ns
    except :
        IP.InteractiveTB()
        import_fail_info(mod)

for mod_fn in IP.rc.import_some:
    if mod_fn == []: break
    mod,fn = mod_fn[0],','.join(mod_fn[1:])
    try:
        exec 'from '+mod+' import '+fn in IP.user_ns
    except :
        IP.InteractiveTB()
        import_fail_info(mod,fn)

for mod in IP.rc.import_all:
    try:
        exec 'from '+mod+' import *' in IP.user_ns
    except :
        IP.InteractiveTB()
        import_fail_info(mod)

for code in IP.rc.execute:
    try:
        exec code in IP.user_ns
    except:
        IP.InteractiveTB()
        warn('Failure executing code: ' + `code`)

# Execute the files the user wants in ipythonrc
for file in IP.rc.execfile:
    try:
        file = filefind(file,sys.path+[IPython_dir])
    except IOError:
        warn(itpl('File $file not found. Skipping it.'))
    else:
        IP.safe_execfile(os.path.expanduser(file),IP.user_ns)

# Load user aliases
for alias in IP.rc.alias:
    IP.magic_alias(alias)

# release stdout and stderr and save config log into a global summary
msg.config.release_all()
if IP.rc.messages:
    msg.summary += msg.config.summary_all()</t>
<t tx="ekr.20050707185105.4">#------------------------------------------------------------------------
# Setup interactive session

# Now we should be fully configured. We can then execute files or load
# things only needed for interactive use. Then we'll open the shell.

# Take a snapshot of the user namespace before opening the shell. That way
# we'll be able to identify which things were interactively defined and
# which were defined through config files.
IP.user_config_ns = IP.user_ns.copy()

# Force reading a file as if it were a session log. Slower but safer.
if load_logplay:
    print 'Replaying log...'
    try:
        if IP.rc.debug:
            logplay_quiet = 0
        else:
             logplay_quiet = 1

        msg.logplay.trap_all()
        IP.safe_execfile(load_logplay,IP.user_ns,
                         islog = 1, quiet = logplay_quiet)
        msg.logplay.release_all()
        if IP.rc.messages:
            msg.summary += msg.logplay.summary_all()
    except:
        warn('Problems replaying logfile %s.' % load_logplay)
        IP.InteractiveTB()

# Load remaining files in command line
msg.user_exec.trap_all()

# Do NOT execute files named in the command line as scripts to be loaded
# by embedded instances.  Doing so has the potential for an infinite
# recursion if there are exceptions thrown in the process.

# XXX FIXME: the execution of user files should be moved out to after
# ipython is fully initialized, just as if they were run via %run at the
# ipython prompt.  This would also give them the benefit of ipython's
# nice tracebacks.

if not embedded and IP.rc.args:
    name_save = IP.user_ns['__name__']
    IP.user_ns['__name__'] = '__main__'
    try:
        # Set our own excepthook in case the user code tries to call it
        # directly. This prevents triggering the IPython crash handler.
        old_excepthook,sys.excepthook = sys.excepthook, IP.excepthook
        for run in args:
            IP.safe_execfile(run,IP.user_ns)
    finally:
        # Reset our crash handler in place
        sys.excepthook = old_excepthook
        
    IP.user_ns['__name__'] = name_save
    
msg.user_exec.release_all()
if IP.rc.messages:
    msg.summary += msg.user_exec.summary_all()

# since we can't specify a null string on the cmd line, 0 is the equivalent:
if IP.rc.nosep:
    IP.rc.separate_in = IP.rc.separate_out = IP.rc.separate_out2 = '0'
if IP.rc.separate_in == '0': IP.rc.separate_in = ''
if IP.rc.separate_out == '0': IP.rc.separate_out = ''
if IP.rc.separate_out2 == '0': IP.rc.separate_out2 = ''
IP.rc.separate_in = IP.rc.separate_in.replace('\\n','\n')
IP.rc.separate_out = IP.rc.separate_out.replace('\\n','\n')
IP.rc.separate_out2 = IP.rc.separate_out2.replace('\\n','\n')

# Determine how many lines at the bottom of the screen are needed for
# showing prompts, so we can know wheter long strings are to be printed or
# paged:
num_lines_bot = IP.rc.separate_in.count('\n')+1
IP.rc.screen_length = IP.rc.screen_length - num_lines_bot
# Initialize cache, set in/out prompts and printing system
IP.outputcache = CachedOutput(IP.rc.cache_size,
                              IP.rc.pprint,
                              input_sep = IP.rc.separate_in,
                              output_sep = IP.rc.separate_out,
                              output_sep2 = IP.rc.separate_out2,
                              ps1 = IP.rc.prompt_in1,
                              ps2 = IP.rc.prompt_in2,
                              ps_out = IP.rc.prompt_out,
                              user_ns = IP.user_ns,
                              input_hist = IP.input_hist,
                              pad_left = IP.rc.prompts_pad_left)

# Set user colors (don't do it in the constructor above so that it doesn't
# crash if colors option is invalid)
IP.magic_colors(IP.rc.colors)

# user may have over-ridden the default print hook:
try:
    IP.outputcache.__class__.display = IP.hooks.display
except AttributeError:
    pass

# Set calling of pdb on exceptions
IP.InteractiveTB.call_pdb = IP.rc.pdb

# I don't like assigning globally to sys, because it means when embedding
# instances, each embedded instance overrides the previous choice. But
# sys.displayhook seems to be called internally by exec, so I don't see a
# way around it.
sys.displayhook = IP.outputcache

# we need to know globally if we're caching i/o or not
IP.do_full_cache = IP.outputcache.do_full_cache

# configure startup banner
if IP.rc.c:  # regular python doesn't print the banner with -c
    IP.rc.banner = 0
if IP.rc.banner:
    IP.BANNER = '\n'.join(IP.BANNER_PARTS)
else:
    IP.BANNER = ''

if IP.rc.profile: IP.BANNER += '\nIPython profile: '+IP.rc.profile+'\n'

# add message log (possibly empty)
IP.BANNER += msg.summary

IP.post_config_initialization()

return IP</t>
<t tx="ekr.20050707185105.5">#-------------------------------------------------------------------------
# Command line handling

# Valid command line options (uses DPyGetOpt syntax, like Perl's
# GetOpt::Long)

# Any key not listed here gets deleted even if in the file (like session
# or profile). That's deliberate, to maintain the rc namespace clean.

# Each set of options appears twice: under _conv only the names are
# listed, indicating which type they must be converted to when reading the
# ipythonrc file. And under DPyGetOpt they are listed with the regular
# DPyGetOpt syntax (=s,=i,:f,etc).

# Make sure there's a space before each end of line (they get auto-joined!)
cmdline_opts = ('autocall! autoindent! automagic! banner! cache_size|cs=i '
                'c=s classic|cl color_info! colors=s confirm_exit! '
                'debug! deep_reload! editor=s log|l messages! nosep pdb! '
                'pprint! prompt_in1|pi1=s prompt_in2|pi2=s prompt_out|po=s '
                'quick screen_length|sl=i prompts_pad_left=i '
                'logfile|lf=s logplay|lp=s profile|p=s '
                'readline! readline_merge_completions! '
                'readline_omit__names! '
                'rcfile=s separate_in|si=s separate_out|so=s '
                'separate_out2|so2=s xmode=s '
                'magic_docstrings system_verbose! '
                'multi_line_specials!')

# Options that can *only* appear at the cmd line (not in rcfiles).

# The "ignore" option is a kludge so that Emacs buffers don't crash, since
# the 'C-c !' command in emacs automatically appends a -i option at the end.
cmdline_only = ('help ignore|i ipythondir=s Version upgrade '
                'gthread! qthread! wthread! pylab! tk!')

# Build the actual name list to be used by DPyGetOpt
opts_names = qw(cmdline_opts) + qw(cmdline_only)

&lt;&lt; Set sensible command line defaults &gt;&gt;

# Things that will *only* appear in rcfiles (not at the command line).
# Make sure there's a space before each end of line (they get auto-joined!)
rcfile_opts = { qwflat: 'include import_mod import_all execfile ',
                qw_lol: 'import_some ',
                # for things with embedded whitespace:
                list_strings:'execute alias readline_parse_and_bind ',
                # Regular strings need no conversion:
                None:'readline_remove_delims ',
                }
# Default values for these
rc_def = Struct(include = [],
                import_mod = [], 
                import_all = [],
                import_some = [[]],
                execute = [],
                execfile = [],
                alias = [],
                readline_parse_and_bind = [],
                readline_remove_delims = '',
                )

# Build the type conversion dictionary from the above tables:
typeconv = rcfile_opts.copy()
typeconv.update(optstr2types(cmdline_opts))

# FIXME: the None key appears in both, put that back together by hand. Ugly!
typeconv[None] += ' ' + rcfile_opts[None]

# Remove quotes at ends of all strings (used to protect spaces)
typeconv[unquote_ends] = typeconv[None]
del typeconv[None]

# Build the list we'll use to make all config decisions with defaults:
opts_all = opts_def.copy()
opts_all.update(rc_def)

# Build conflict resolver for recursive loading of config files:
# - preserve means the outermost file maintains the value, it is not
# overwritten if an included file has the same key.
# - add_flip applies + to the two values, so it better make sense to add
# those types of keys. But it flips them first so that things loaded
# deeper in the inclusion chain have lower precedence.
conflict = {'preserve': ' '.join([ typeconv[int],
                                   typeconv[unquote_ends] ]),
            'add_flip': ' '.join([ typeconv[qwflat],
                                   typeconv[qw_lol],
                                   typeconv[list_strings] ])
            }

# Now actually process the command line
getopt = DPyGetOpt.DPyGetOpt()
getopt.setIgnoreCase(0)

getopt.parseConfiguration(opts_names)

try:
    getopt.processArguments(argv)
except:
    print cmd_line_usage
    warn('\nError in Arguments: ' + `sys.exc_value`)
    sys.exit()

# convert the options dict to a struct for much lighter syntax later
opts = Struct(getopt.optionValues)
args = getopt.freeValues

# this is the struct (which has default values at this point) with which
# we make all decisions:
opts_all.update(opts)

# Options that force an immediate exit
if opts_all.help:
    page(cmd_line_usage)
    sys.exit()

if opts_all.Version:
    print __version__
    sys.exit()

if opts_all.magic_docstrings:
    IP.magic_magic('-latex')
    sys.exit()

# Create user config directory if it doesn't exist. This must be done
# *after* getting the cmd line options.
if not os.path.isdir(opts_all.ipythondir):
    IP.user_setup(opts_all.ipythondir,rc_suffix,'install')

# upgrade user config files while preserving a copy of the originals
if opts_all.upgrade:
    IP.user_setup(opts_all.ipythondir,rc_suffix,'upgrade')

# check mutually exclusive options in the *original* command line
mutex_opts(opts,[qw('log logfile'),qw('rcfile profile'),
                 qw('classic profile'),qw('classic rcfile')])

# default logfilename used when -log is called.
IP.LOGDEF = 'ipython.log'</t>
<t tx="ekr.20050707185105.6"># This should have everything from  cmdline_opts and cmdline_only
opts_def = Struct(autocall = 1,
                  autoindent=0,
                  automagic = 1,
                  banner = 1,
                  cache_size = 1000,
                  c = '',
                  classic = 0,
                  colors = 'NoColor',
                  color_info = 0,
                  confirm_exit = 1,
                  debug = 0,
                  deep_reload = 0,
                  editor = '0',
                  help = 0,
                  ignore = 0,
                  ipythondir = ipythondir,
                  log = 0,
                  logfile = '',
                  logplay = '',
                  multi_line_specials = 1,
                  messages = 1,
                  nosep = 0,
                  pdb = 0,
                  pprint = 0,
                  profile = '',
                  prompt_in1 = 'In [\\#]:',
                  prompt_in2 = '   .\\D.:',
                  prompt_out = 'Out[\\#]:',
                  prompts_pad_left = 1,
                  quick = 0,
                  readline = 1,
                  readline_merge_completions = 1,
                  readline_omit__names = 0,
                  rcfile = 'ipythonrc' + rc_suffix,
                  screen_length = 0,
                  separate_in = '\n',
                  separate_out = '\n',
                  separate_out2 = '',
                  system_verbose = 0,
                  gthread = 0,
                  qthread = 0,
                  wthread = 0,
                  pylab = 0,
                  tk = 0,
                  upgrade = 0,
                  Version = 0,
                  xmode = 'Verbose',
                  magic_docstrings = 0,  # undocumented, for doc generation
                  )</t>
<t tx="ekr.20050707185729">otrap = OutputTrap(trap_out=1)  # trap messages from magic_xmode
IP.magic_xmode(opts_all.xmode)
otrap.release_out()</t>
<t tx="ekr.20050707185729.1"># Platform-dependent suffix and directory names
if os.name == 'posix':
    rc_suffix = ''
    ipdir_def = '.ipython'
else:
    rc_suffix = '.ini'
    ipdir_def = '_ipython'

# default directory for configuration
ipythondir = os.path.abspath(os.environ.get('IPYTHONDIR',
                             os.path.join(IP.home_dir,ipdir_def)))

# we need the directory where IPython itself is installed
import IPython
IPython_dir = os.path.dirname(IPython.__file__)
del IPython</t>
<t tx="ekr.20050707212426"># Put a reference to self in builtins so that any form of embedded or
# imported code can test for being inside IPython.
__builtin__.__IPYTHON__ = self

# And load into builtins ipmagic/ipalias as well
__builtin__.ipmagic = ipmagic
__builtin__.ipalias = ipalias

# Add to __builtin__ other parts of IPython's public API
__builtin__.ip_set_hook = self.set_hook

# Keep in the builtins a flag for when IPython is active.  We set it
# with setdefault so that multiple nested IPythons don't clobber one
# another.  Each will increase its value by one upon being activated,
# which also gives us a way to determine the nesting level.
__builtin__.__dict__.setdefault('__IPYTHON__active',0)

# Inform the user of ipython's fast exit magics.
_exit = ' Use %Exit or %Quit to exit without confirmation.'
__builtin__.exit += _exit
__builtin__.quit += _exit</t>
<t tx="ekr.20050707212426.1"># FIXME. For some strange reason, __builtins__ is showing up at user
# level as a dict instead of a module. This is a manual fix, but I
# should really track down where the problem is coming from. Alex
# Schmolck reported this problem first.

# A useful post by Alex Martelli on this topic:
# Re: inconsistent value from __builtins__
# Von: Alex Martelli &lt;aleaxit@yahoo.com&gt;
# Datum: Freitag 01 Oktober 2004 04:45:34 nachmittags/abends
# Gruppen: comp.lang.python
# Referenzen: 1

# Michael Hohn &lt;hohn@hooknose.lbl.gov&gt; wrote:
# &gt; &gt;&gt;&gt; print type(builtin_check.get_global_binding('__builtins__'))
# &gt; &lt;type 'dict'&gt;
# &gt; &gt;&gt;&gt; print type(__builtins__)
# &gt; &lt;type 'module'&gt;
# &gt; Is this difference in return value intentional?

# Well, it's documented that '__builtins__' can be either a dictionary
# or a module, and it's been that way for a long time. Whether it's
# intentional (or sensible), I don't know. In any case, the idea is that
# if you need to access the built-in namespace directly, you should start
# with "import __builtin__" (note, no 's') which will definitely give you
# a module. Yeah, it's somewhatÂ confusing:-(.

if user_ns is None:
    # Set __name__ to __main__ to better match the behavior of the
    # normal interpreter.
    self.user_ns = {'__name__'     :'__main__',
                    '__builtins__' : __builtin__,
                    }
else:
    self.user_ns = user_ns

# The user namespace MUST have a pointer to the shell itself.
self.user_ns[name] = self

# We need to insert into sys.modules something that looks like a
# module but which accesses the IPython namespace, for shelve and
# pickle to work interactively. Normally they rely on getting
# everything out of __main__, but for embedding purposes each IPython
# instance has its own private namespace, so we can't go shoving
# everything into __main__.

try:
    main_name = self.user_ns['__name__']
except KeyError:
    raise KeyError,'user_ns dictionary MUST have a "__name__" key'
else:
    #print "pickle hack in place"  # dbg
    sys.modules[main_name] = FakeModule(self.user_ns)</t>
<t tx="ekr.20050707212426.2"># List of input with multi-line handling.
# Fill its zero entry, user counter starts at 1
self.input_hist = InputList(['\n'])

# list of visited directories
self.dir_hist = [os.getcwd()]

# dict of output history
self.output_hist = {}

# dict of names to be treated as system aliases.  Each entry in the
# alias table must be a 2-tuple of the form (N,name), where N is the
# number of positional arguments of the alias.
self.alias_table = {}

# dict of things NOT to alias (keywords and builtins)
self.no_alias = {}
for key in keyword.kwlist:
    self.no_alias[key] = 1
self.no_alias.update(__builtin__.__dict__)

# make global variables for user access to these
self.user_ns['_ih'] = self.input_hist
self.user_ns['_oh'] = self.output_hist
self.user_ns['_dh'] = self.dir_hist

# user aliases to input and output histories
self.user_ns['In']  = self.input_hist
self.user_ns['Out'] = self.output_hist

# Store the actual shell's name
self.name = name

# Object variable to store code object waiting execution.  This is
# used mainly by the multithreaded shells, but it can come in handy in
# other situations.  No need to use a Queue here, since it's a single
# item which gets cleared once run.
self.code_to_run = None
self.code_to_run_src = ''  # corresponding source</t>
<t tx="ekr.20050707212426.3"># escapes for automatic behavior on the command line
self.ESC_SHELL = '!'
self.ESC_HELP  = '?'
self.ESC_MAGIC = '%'
self.ESC_QUOTE = ','
self.ESC_QUOTE2 = ';'
self.ESC_PAREN = '/'

# And their associated handlers
self.esc_handlers = {
    self.ESC_PAREN: self.handle_auto,
    self.ESC_QUOTE: self.handle_auto,
    self.ESC_QUOTE2:self.handle_auto,
    self.ESC_MAGIC: self.handle_magic,
    self.ESC_HELP:  self.handle_help,
    self.ESC_SHELL: self.handle_shell_escape,
}</t>
<t tx="ekr.20050707224615">def set_custom_exc(self,exc_tuple,handler):
    """set_custom_exc(exc_tuple,handler)

    Set a custom exception handler, which will be called if any of the
    exceptions in exc_tuple occur in the mainloop (specifically, in the
    runcode() method.

    Inputs:

      - exc_tuple: a *tuple* of valid exceptions to call the defined
      handler for.  It is very important that you use a tuple, and NOT A
      LIST here, because of the way Python's except statement works.  If
      you only want to trap a single exception, use a singleton tuple:

        exc_tuple == (MyCustomException,)

      - handler: this must be defined as a function with the following
      basic interface: def my_handler(self,etype,value,tb).

      This will be made into an instance method (via new.instancemethod)
      of IPython itself, and it will be called if any of the exceptions
      listed in the exc_tuple are caught.  If the handler is None, an
      internal basic one is used, which just prints basic info.

    WARNING: by putting in your own exception handler into IPython's main
    execution loop, you run a very good chance of nasty crashes.  This
    facility should only be used if you really know what you are doing."""

    assert type(exc_tuple)==type(()) , \
           "The custom exceptions must be given AS A TUPLE."

    def dummy_handler(self,etype,value,tb):
        print '*** Simple custom exception handler ***'
        print 'Exception type :',etype
        print 'Exception value:',value
        print 'Traceback      :',tb
        print 'Source code    :',self.code_to_run_src

    if handler is None: handler = dummy_handler

    self.CustomTB = new.instancemethod(handler,self,self.__class__)
    self.custom_exceptions = exc_tuple</t>
<t tx="ekr.20050707224710">def set_custom_completer(self,completer,pos=0):
    """set_custom_completer(completer,pos=0)

    Adds a new custom completer function.

    The position argument (defaults to 0) is the index in the completers
    list where you want the completer to be inserted."""

    newcomp = new.instancemethod(completer,self.Completer,
                                 self.Completer.__class__)
    self.Completer.matchers.insert(pos,newcomp)</t>
<t tx="ekr.20050707224710.1">def post_config_initialization(self):
    """Post configuration init method

    This is called after the configuration files have been processed to
    'finalize' the initialization."""
    
    # dynamic data that survives through sessions
    # XXX make the filename a config option?
    persist_base = 'persist'
    if self.rc.profile:
        persist_base += '_%s' % self.rc.profile
    self.persist_fname =  os.path.join(self.rc.ipythondir,persist_base)

    try:
        self.persist = pickle.load(file(self.persist_fname))
    except:
        self.persist = {}</t>
<t tx="ekr.20050707224710.2">def init_auto_alias(self):
    """Define some aliases automatically.

    These are ALL parameter-less aliases"""
    for alias,cmd in self.auto_alias:
        self.alias_table[alias] = (0,cmd)</t>
<t tx="ekr.20050707224710.3">def alias_table_validate(self,verbose=0):
    """Update information about the alias table.

    In particular, make sure no Python keywords/builtins are in it."""

    no_alias = self.no_alias
    for k in self.alias_table.keys():
        if k in no_alias:
            del self.alias_table[k]
            if verbose:
                print ("Deleting alias &lt;%s&gt;, it's a Python "
                       "keyword or builtin." % k)</t>
<t tx="ekr.20050707224710.4">def set_autoindent(self,value=None):
    """Set the autoindent flag, checking for readline support.

    If called with no arguments, it acts as a toggle."""

    if not self.has_readline:
        if os.name == 'posix':
            warn("The auto-indent feature requires the readline library")
        self.autoindent = 0
        return
    if value is None:
        self.autoindent = not self.autoindent
    else:
        self.autoindent = value</t>
<t tx="ekr.20050707224710.5">def rc_set_toggle(self,rc_field,value=None):
    """Set or toggle a field in IPython's rc config. structure.

    If called with no arguments, it acts as a toggle.

    If called with a non-existent field, the resulting AttributeError
    exception will propagate out."""

    rc_val = getattr(self.rc,rc_field)
    if value is None:
        value = not rc_val
    setattr(self.rc,rc_field,value)</t>
<t tx="ekr.20050707224710.6">def user_setup(self,ipythondir,rc_suffix,mode='install'):
    """Install the user configuration directory.

    Can be called when running for the first time or to upgrade the user's
    .ipython/ directory with the mode parameter. Valid modes are 'install'
    and 'upgrade'."""

    def wait():
        try:
            raw_input("Please press &lt;RETURN&gt; to start IPython.")
        except EOFError:
            print &gt;&gt; Term.cout
        print '*'*70

    cwd = os.getcwd()  # remember where we started
    glb = glob.glob
    print '*'*70
    if mode == 'install':
        print \
"""Welcome to IPython. I will try to create a personal configuration directory
where you can customize many aspects of IPython's functionality in:\n"""
    else:
        print 'I am going to upgrade your configuration in:'

    print ipythondir

    rcdirend = os.path.join('IPython','UserConfig')
    cfg = lambda d: os.path.join(d,rcdirend)
    try:
        rcdir = filter(os.path.isdir,map(cfg,sys.path))[0]
    except IOError:
        warning = """
Installation error. IPython's directory was not found.

Check the following:

The ipython/IPython directory should be in a directory belonging to your
PYTHONPATH environment variable (that is, it should be in a directory
belonging to sys.path). You can copy it explicitly there or just link to it.

IPython will proceed with builtin defaults.
"""
        warn(warning)
        wait()
        return

    if mode == 'install':
        try:
            shutil.copytree(rcdir,ipythondir)
            os.chdir(ipythondir)
            rc_files = glb("ipythonrc*")
            for rc_file in rc_files:
                os.rename(rc_file,rc_file+rc_suffix)
        except:
            warning = """

There was a problem with the installation:
%s
Try to correct it or contact the developers if you think it's a bug.
IPython will proceed with builtin defaults.""" % sys.exc_info()[1]
            warn(warning)
            wait()
            return

    elif mode == 'upgrade':
        try:
            os.chdir(ipythondir)
        except:
            print """
Can not upgrade: changing to directory %s failed. Details:
%s
""" % (ipythondir,sys.exc_info()[1])
            wait()
            return
        else:
            sources = glb(os.path.join(rcdir,'[A-Za-z]*'))
            for new_full_path in sources:
                new_filename = os.path.basename(new_full_path)
                if new_filename.startswith('ipythonrc'):
                    new_filename = new_filename + rc_suffix
                # The config directory should only contain files, skip any
                # directories which may be there (like CVS)
                if os.path.isdir(new_full_path):
                    continue
                if os.path.exists(new_filename):
                    old_file = new_filename+'.old'
                    if os.path.exists(old_file):
                        os.remove(old_file)
                    os.rename(new_filename,old_file)
                shutil.copy(new_full_path,new_filename)
    else:
        raise ValueError,'unrecognized mode for install:',`mode`

    # Fix line-endings to those native to each platform in the config
    # directory.
    try:
        os.chdir(ipythondir)
    except:
        print """
Problem: changing to directory %s failed.
Details:
%s

Some configuration files may have incorrect line endings.  This should not
cause any problems during execution.  """ % (ipythondir,sys.exc_info()[1])
        wait()
    else:
        for fname in glb('ipythonrc*'):
            try:
                native_line_ends(fname,backup=0)
            except IOError:
                pass

    if mode == 'install':
        print """
Successful installation!

Please read the sections 'Initial Configuration' and 'Quick Tips' in the
IPython manual (there are both HTML and PDF versions supplied with the
distribution) to make sure that your system environment is properly configured
to take advantage of IPython's features."""
    else:
        print """
Successful upgrade!

All files in your directory:
%(ipythondir)s
which would have been overwritten by the upgrade were backed up with a .old
extension.  If you had made particular customizations in those files you may
want to merge them back into the new files.""" % locals()
    wait()
    os.chdir(cwd)
    # end user_setup()</t>
<t tx="ekr.20050707224710.7">def atexit_operations(self):
    """This will be executed at the time of exit.

    Saving of persistent data should be performed here. """

    # input history
    self.savehist()

    # Cleanup all tempfiles left around
    for tfile in self.tempfiles:
        try:
            os.unlink(tfile)
        except OSError:
            pass

    # save the "persistent data" catch-all dictionary
    try:
        pickle.dump(self.persist, open(self.persist_fname,"w"))
    except:
        print "*** ERROR *** persistent data saving failed."</t>
<t tx="ekr.20050707230243.1">def savehist(self):
    """Save input history to a file (via readline library)."""
    try:
        self.readline.write_history_file(self.histfile)
    except:
        print 'Unable to save IPython command history to file: ' + \
              `self.histfile`</t>
<t tx="ekr.20050707230243.2">def pre_readline(self):
    """readline hook to be used at the start of each line.

    Currently it handles auto-indent only."""
    
    self.readline.insert_text(' '* self.readline_indent)</t>
<t tx="ekr.20050707230243.3">def init_readline(self):
    """Command history completion/saving/reloading."""
    try:
        import readline
        self.Completer = MagicCompleter(self,
                                        self.user_ns,
                                        self.rc.readline_omit__names,
                                        self.alias_table)
    except ImportError,NameError:
        # If FlexCompleter failed to import, MagicCompleter won't be 
        # defined.  This can happen because of a problem with readline
        self.has_readline = 0
        # no point in bugging windows users with this every time:
        if os.name == 'posix':
            warn('Readline services not available on this platform.')
    else:
        import atexit

        # Platform-specific configuration
        if os.name == 'nt':
            # readline under Windows modifies the default exit behavior
            # from being Ctrl-Z/Return to the Unix Ctrl-D one.
            __builtin__.exit = __builtin__.quit = \
                 ('Use Ctrl-D (i.e. EOF) to exit. '
                  'Use %Exit or %Quit to exit without confirmation.')
            self.readline_startup_hook = readline.set_pre_input_hook
        else:
            self.readline_startup_hook = readline.set_startup_hook

        # Load user's initrc file (readline config)
        inputrc_name = os.environ.get('INPUTRC')
        if inputrc_name is None:
            home_dir = get_home_dir()
            if home_dir is not None:
                inputrc_name = os.path.join(home_dir,'.inputrc')
        if os.path.isfile(inputrc_name):
            try:
                readline.read_init_file(inputrc_name)
            except:
                warn('Problems reading readline initialization file &lt;%s&gt;'
                     % inputrc_name)
        
        self.has_readline = 1
        self.readline = readline
        self.readline_indent = 0  # for auto-indenting via readline
        # save this in sys so embedded copies can restore it properly
        sys.ipcompleter = self.Completer.complete
        readline.set_completer(self.Completer.complete)

        # Configure readline according to user's prefs
        for rlcommand in self.rc.readline_parse_and_bind:
            readline.parse_and_bind(rlcommand)

        # remove some chars from the delimiters list
        delims = readline.get_completer_delims()
        delims = delims.translate(string._idmap,
                                  self.rc.readline_remove_delims)
        readline.set_completer_delims(delims)
        # otherwise we end up with a monster history after a while:
        readline.set_history_length(1000)
        try:
            #print '*** Reading readline history'  # dbg
            readline.read_history_file(self.histfile)
        except IOError:
            pass  # It doesn't exist yet.

        atexit.register(self.atexit_operations)
        del atexit

    # Configure auto-indent for all platforms
    self.set_autoindent(self.rc.autoindent)</t>
<t tx="ekr.20050707230243.4">def showsyntaxerror(self, filename=None):
    """Display the syntax error that just occurred.

    This doesn't display a stack trace because there isn't one.

    If a filename is given, it is stuffed in the exception instead
    of what was there before (because Python's parser always uses
    "&lt;string&gt;" when reading from a string).
    """
    type, value, sys.last_traceback = sys.exc_info()
    sys.last_type = type
    sys.last_value = value
    if filename and type is SyntaxError:
        # Work hard to stuff the correct filename in the exception
        try:
            msg, (dummy_filename, lineno, offset, line) = value
        except:
            # Not the format we expect; leave it alone
            pass
        else:
            # Stuff in the right filename
            try:
                # Assume SyntaxError is a class exception
                value = SyntaxError(msg, (filename, lineno, offset, line))
            except:
                # If that failed, assume SyntaxError is a string
                value = msg, (filename, lineno, offset, line)
    self.SyntaxTB(type,value,[])

</t>
<t tx="ekr.20050707230243.5">def debugger(self):
    """Call the pdb debugger."""

    if not self.rc.pdb:
        return
    pdb.pm()</t>
<t tx="ekr.20050707230243.6">def showtraceback(self,exc_tuple = None):
    """Display the exception that just occurred."""

    # Though this won't be called by syntax errors in the input line,
    # there may be SyntaxError cases whith imported code.
    if exc_tuple is None:
        type, value, tb = sys.exc_info()
    else:
        type, value, tb = exc_tuple
    if type is SyntaxError:
        self.showsyntaxerror()
    else:
        sys.last_type = type
        sys.last_value = value
        sys.last_traceback = tb
        self.InteractiveTB()
        if self.InteractiveTB.call_pdb and self.has_readline:
            # pdb mucks up readline, fix it back
            self.readline.set_completer(self.Completer.complete)</t>
<t tx="ekr.20050707230243.7">def update_cache(self, line):
    
    """puts line into cache"""

    self.inputcache.insert(0, line) # This copies the cache every time ... :-(
    if len(self.inputcache) &gt;= self.CACHELENGTH:
        self.inputcache.pop()    # This not :-)</t>
<t tx="ekr.20050707230243.8">def name_space_init(self):
    """Create local namespace."""
    # We want this to be a method to facilitate embedded initialization.
    code.InteractiveConsole.__init__(self,self.user_ns)</t>
<t tx="ekr.20050707230243.9">def mainloop(self,banner=None):
    """Creates the local namespace and starts the mainloop.

    If an optional banner argument is given, it will override the
    internally created default banner."""
    
    self.name_space_init()
    if self.rc.c:  # Emulate Python's -c option
        self.exec_init_cmd()
    if banner is None:
        if self.rc.banner:
            banner = self.BANNER+self.banner2
        else:
            banner = ''
    self.interact(banner)</t>
<t tx="ekr.20050707230243.10">def exec_init_cmd(self):

    """Execute a command given at the command line.

    This emulates Python's -c option."""

    sys.argv = ['-c']
    self.push(self.rc.c)</t>
<t tx="ekr.20050707230243.11">def embed_mainloop(self,header='',local_ns=None,global_ns=None,stack_depth=0):
    """Embeds IPython into a running python program.

    Input:

      - header: An optional header message can be specified.

      - local_ns, global_ns: working namespaces. If given as None, the
      IPython-initialized one is updated with __main__.__dict__, so that
      program variables become visible but user-specific configuration
      remains possible.

      - stack_depth: specifies how many levels in the stack to go to
      looking for namespaces (when local_ns and global_ns are None).  This
      allows an intermediate caller to make sure that this function gets
      the namespace from the intended level in the stack.  By default (0)
      it will get its locals and globals from the immediate caller.

    Warning: it's possible to use this in a program which is being run by
    IPython itself (via %run), but some funny things will happen (a few
    globals get overwritten). In the future this will be cleaned up, as
    there is no fundamental reason why it can't work perfectly."""

    # Patch for global embedding to make sure that things don't overwrite
    # user globals accidentally. Thanks to Richard &lt;rxe@renre-europe.com&gt;
    # FIXME. Test this a bit more carefully (the if.. is new)
    if local_ns is None and global_ns is None:
        self.user_ns.update(__main__.__dict__)

    # Get locals and globals from caller
    if local_ns is None or global_ns is None:
        call_frame = sys._getframe(stack_depth).f_back

        if local_ns is None:
            local_ns = call_frame.f_locals
        if global_ns is None:
            global_ns = call_frame.f_globals

    # Update namespaces and fire up interpreter
    self.user_ns.update(local_ns)
    self.interact(header)

    # Remove locals from namespace
    for k in local_ns.keys():
        del self.user_ns[k]

</t>
<t tx="ekr.20050707230243.12">def interact(self, banner=None):
    """Closely emulate the interactive Python console.

    The optional banner argument specify the banner to print
    before the first interaction; by default it prints a banner
    similar to the one printed by the real Python interpreter,
    followed by the current class name in parentheses (so as not
    to confuse this with the real interpreter -- since it's so
    close!).

    """
    cprt = 'Type "copyright", "credits" or "license" for more information.'
    if banner is None:
        self.write("Python %s on %s\n%s\n(%s)\n" %
                   (sys.version, sys.platform, cprt,
                    self.__class__.__name__))
    else:
        sys.stdout.write(banner)

    more = 0

    # Mark activity in the builtins
    __builtin__.__dict__['__IPYTHON__active'] += 1
    while 1:
        # This is set by a call to %Exit or %Quit
        if self.exit_now:
            break
        try:
            if more:
                prompt = self.outputcache.prompt2
                if self.autoindent:
                    self.readline_startup_hook(self.pre_readline)
            else:
                prompt = self.outputcache.prompt1
            try:
                line = self.raw_input(prompt)
                if self.autoindent:
                    self.readline_startup_hook(None)
            except EOFError:
                if self.autoindent:
                    self.readline_startup_hook(None)
                self.write("\n")
                if self.rc.confirm_exit:
                    if ask_yes_no('Do you really want to exit ([y]/n)?','y'):
                        break
                else:
                    break
            else:
                more = self.push(line)
                # Auto-indent management
                if self.autoindent:
                    if line:
                        ini_spaces = re.match('^(\s+)',line)
                        if ini_spaces:
                            nspaces = ini_spaces.end()
                        else:
                            nspaces = 0
                        self.readline_indent = nspaces

                        if line[-1] == ':':
                            self.readline_indent += 4
                        elif re.match(r'^\s+raise|^\s+return',line):
                            self.readline_indent -= 4
                    else:
                        self.readline_indent = 0

        except KeyboardInterrupt:
            self.write("\nKeyboardInterrupt\n")
            self.resetbuffer()
            more = 0
            # keep cache in sync with the prompt counter:
            self.outputcache.prompt_count -= 1

            if self.autoindent:
                self.readline_indent = 0

        except bdb.BdbQuit:
            warn("The Python debugger has exited with a BdbQuit exception.\n"
                 "Because of how pdb handles the stack, it is impossible\n"
                 "for IPython to properly format this particular exception.\n"
                 "IPython will resume normal operation.")
        except:
            # We should never get here except in fairly bizarre situations
            # (or b/c of an IPython bug). One reasonable exception is if
            # the user sets stdin/out/err to a broken object (or closes
            # any of them!)

            fixed_in_out_err = 0

            # Call the Term I/O class and have it reopen any stream which
            # the user might have closed.
            Term.reopen_all()

            # Do the same manually for sys.stderr/out/in
            
            # err first, so we can print at least warnings
            if sys.__stderr__.closed:
                sys.__stderr__ = os.fdopen(os.dup(2),'w',0)
                fixed_err_err = 1
                print &gt;&gt; sys.__stderr__,"""
WARNING:
sys.__stderr__ was closed!
I've tried to reopen it, but bear in mind that things may not work normally
from now.  In particular, readline support may have broken.
"""
            # Next, check stdin/out    
            if sys.__stdin__.closed:
                sys.__stdin__ = os.fdopen(os.dup(0),'r',0)
                fixed_in_out_err = 1
                print &gt;&gt; sys.__stderr__,"""
WARNING:
sys.__stdin__ was closed!
I've tried to reopen it, but bear in mind that things may not work normally
from now.  In particular, readline support may have broken.
"""
            if sys.__stdout__.closed:
                sys.__stdout__ = os.fdopen(os.dup(1),'w',0)
                fixed_in_out_err = 1
                print &gt;&gt; sys.__stderr__,"""
WARNING:
sys.__stdout__ was closed!
I've tried to reopen it, but bear in mind that things may not work normally
from now.  In particular, readline support may have broken.
"""

            # Now, check mismatch of objects
            if sys.stdin is not sys.__stdin__:
                sys.stdin = sys.__stdin__
                fixed_in_out_err = 1
                print &gt;&gt; sys.__stderr__,"""
WARNING:
sys.stdin has been reset to sys.__stdin__.
There seemed to be a problem with your sys.stdin.
"""
            if sys.stdout is not sys.__stdout__:
                sys.stdout = sys.__stdout__
                fixed_in_out_err = 1
                print &gt;&gt; sys.__stderr__,"""
WARNING:
sys.stdout has been reset to sys.__stdout__.
There seemed to be a problem with your sys.stdout.
"""

            if sys.stderr is not sys.__stderr__:
                sys.stderr = sys.__stderr__
                fixed_in_out_err = 1
                print &gt;&gt; sys.__stderr__,"""
WARNING:
sys.stderr has been reset to sys.__stderr__.
There seemed to be a problem with your sys.stderr.
"""
            # If the problem wasn't a broken out/err, it's an IPython bug
            # I wish we could ask the user whether to crash or not, but
            # calling any function at this point messes up the stack.
            if not fixed_in_out_err:
                raise
            
    # We are off again...
    __builtin__.__dict__['__IPYTHON__active'] -= 1</t>
<t tx="ekr.20050707230243.13">def excepthook(self, type, value, tb):
  """One more defense for GUI apps that call sys.excepthook.

  GUI frameworks like wxPython trap exceptions and call
  sys.excepthook themselves.  I guess this is a feature that
  enables them to keep running after exceptions that would
  otherwise kill their mainloop. This is a bother for IPython
  which excepts to catch all of the program exceptions with a try:
  except: statement.

  Normally, IPython sets sys.excepthook to a CrashHandler instance, so if
  any app directly invokes sys.excepthook, it will look to the user like
  IPython crashed.  In order to work around this, we can disable the
  CrashHandler and replace it with this excepthook instead, which prints a
  regular traceback using our InteractiveTB.  In this fashion, apps which
  call sys.excepthook will generate a regular-looking exception from
  IPython, and the CrashHandler will only be triggered by real IPython
  crashes.

  This hook should be used sparingly, only in places which are not likely
  to be true IPython errors.
  """
  
  self.InteractiveTB(type, value, tb, tb_offset=0)
  if self.InteractiveTB.call_pdb and self.has_readline:
      self.readline.set_completer(self.Completer.complete)</t>
<t tx="ekr.20050707230243.14">def call_alias(self,alias,rest=''):
    """Call an alias given its name and the rest of the line.

    This function MUST be given a proper alias, because it doesn't make
    any checks when looking up into the alias table.  The caller is
    responsible for invoking it only with a valid alias."""

    #print 'ALIAS: &lt;%s&gt;+&lt;%s&gt;' % (alias,rest) # dbg
    nargs,cmd = self.alias_table[alias]
    # Expand the %l special to be the user's input line
    if cmd.find('%l') &gt;= 0:
        cmd = cmd.replace('%l',rest)
        rest = ''
    if nargs==0:
        # Simple, argument-less aliases
        cmd = '%s %s' % (cmd,rest)
    else:
        # Handle aliases with positional arguments
        args = rest.split(None,nargs)
        if len(args)&lt; nargs:
            error('Alias &lt;%s&gt; requires %s arguments, %s given.' %
                  (alias,nargs,len(args)))
            return
        cmd = '%s %s' % (cmd % tuple(args[:nargs]),' '.join(args[nargs:]))
    # Now call the macro, evaluating in the user's namespace
    try:
        self.system(cmd)
    except:
        self.showtraceback()</t>
<t tx="ekr.20050707230243.15">def runlines(self,lines):
    """Run a string of one or more lines of source.

    This method is capable of running a string containing multiple source
    lines, as if they had been entered at the IPython prompt.  Since it
    exposes IPython's processing machinery, the given strings can contain
    magic calls (%magic), special shell access (!cmd), etc."""

    # We must start with a clean buffer, in case this is run from an
    # interactive IPython session (via a magic, for example).
    self.resetbuffer()
    lines = lines.split('\n')
    more = 0
    for line in lines:
        # skip blank lines so we don't mess up the prompt counter, but do
        # NOT skip even a blank line if we are in a code block (more is
        # true)
        if line or more:
            more = self.push((self.prefilter(line,more)))
            # IPython's runsource returns None if there was an error
            # compiling the code.  This allows us to stop processing right
            # away, so the user gets the error message at the right place.
            if more is None:
                break
    # final newline in case the input didn't have it, so that the code
    # actually does get executed
    if more:
        self.push('\n')</t>
<t tx="ekr.20050707230243.16">def runsource(self, source, filename="&lt;input&gt;", symbol="single"):
    """Compile and run some source in the interpreter.

    Arguments are as for compile_command().

    One several things can happen:

    1) The input is incorrect; compile_command() raised an
    exception (SyntaxError or OverflowError).  A syntax traceback
    will be printed by calling the showsyntaxerror() method.

    2) The input is incomplete, and more input is required;
    compile_command() returned None.  Nothing happens.

    3) The input is complete; compile_command() returned a code
    object.  The code is executed by calling self.runcode() (which
    also handles run-time exceptions, except for SystemExit).

    The return value is:

      - True in case 2

      - False in the other cases, unless an exception is raised, where
      None is returned instead.  This can be used by external callers to
      know whether to continue feeding input or not.

    The return value can be used to decide whether to use sys.ps1 or
    sys.ps2 to prompt the next line."""
    try:
        code = self.compile(source, filename, symbol)
    except (OverflowError, SyntaxError, ValueError):
        # Case 1
        self.showsyntaxerror(filename)
        return None

    if code is None:
        # Case 2
        return True

    # Case 3
    # We store the code source and object so that threaded shells and
    # custom exception handlers can access all this info if needed.
    self.code_to_run_src = source
    self.code_to_run = code
    # now actually execute the code object
    if self.runcode(code) == 0:
        return False
    else:
        return None</t>
<t tx="ekr.20050707230243.17">def runcode(self,code_obj):
    """Execute a code object.

    When an exception occurs, self.showtraceback() is called to display a
    traceback.

    Return value: a flag indicating whether the code to be run completed
    successfully:

      - 0: successful execution.
      - 1: an error occurred.
    """

    # Set our own excepthook in case the user code tries to call it
    # directly, so that the IPython crash handler doesn't get triggered
    old_excepthook,sys.excepthook = sys.excepthook, self.excepthook
    outflag = 1  # happens in more places, so it's easier as default
    try:
        try:
            exec code_obj in self.locals
        finally:
            # Reset our crash handler in place
            sys.excepthook = old_excepthook
    except SystemExit:
        self.resetbuffer()
        self.showtraceback()
        warn( __builtin__.exit,level=1)
    except self.custom_exceptions:
        etype,value,tb = sys.exc_info()
        self.CustomTB(etype,value,tb)
    except:
        self.showtraceback()
    else:
        outflag = 0
        if code.softspace(sys.stdout, 0):
            print
    # Flush out code object which has been run (and source)
    self.code_to_run = None
    self.code_to_run_src = ''
    return outflag</t>
<t tx="ekr.20050707230243.18">def raw_input(self, prompt=""):
    """Write a prompt and read a line.

    The returned line does not include the trailing newline.
    When the user enters the EOF key sequence, EOFError is raised.

    The base implementation uses the built-in function
    raw_input(); a subclass may replace this with a different
    implementation.
    """
    return self.prefilter(raw_input_original(prompt),
                          prompt==self.outputcache.prompt2)
</t>
<t tx="ekr.20050707230243.19">def split_user_input(self,line):

    """Split user input into pre-char, function part and rest."""

    lsplit = self.line_split.match(line)  # EKR: line_split is a regular expression.

    if lsplit is None:  # no regexp match returns None
        try:
            iFun,theRest = line.split(None,1)
        except ValueError:
            iFun,theRest = line,''
        pre = re.match('^(\s*)(.*)',line).groups()[0]
    else:
        pre,iFun,theRest = lsplit.groups()

    #print 'line:&lt;%s&gt;' % line # dbg
    #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun.strip(),theRest) # dbg

    return pre,iFun.strip(),theRest</t>
<t tx="ekr.20050707230243.20">def _prefilter(self, line, continue_prompt):
    """Calls different preprocessors, depending on the form of line."""
    
    &lt;&lt; about this function &gt;&gt;

    #if line.startswith('%crash'): raise RuntimeError,'Crash now!'  # dbg

    # save the line away in case we crash, so the post-mortem handler can record it
    self._last_input_line = line

    #print '***line: &lt;%s&gt;' % line # dbg
    if not line.strip():
        &lt;&lt; handle empty line &gt;&gt;

    # print '***cont',continue_prompt  # dbg
    # special handlers are only allowed for single line statements
    if continue_prompt and not self.rc.multi_line_specials:
        return self.handle_normal(line,continue_prompt)

    # Get the structure of the input
    pre,iFun,theRest = self.split_user_input(line)
    #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg
    
    &lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;
    &lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;
    &lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;
    &lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;

    # If we get here, we have a normal Python line. Log and return.
    return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050707230243.21">def _prefilter_dumb(self, line, continue_prompt):

    """simple prefilter function, for debugging"""
    return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050707230243.22">def handle_normal(self,line,continue_prompt=None,
                  pre=None,iFun=None,theRest=None):
    """Handle normal input lines. Use as a template for handlers."""

    self.log(line,continue_prompt)
    self.update_cache(line)
    return line</t>
<t tx="ekr.20050707230243.23">def handle_alias(self,line,continue_prompt=None,
                 pre=None,iFun=None,theRest=None):
    """Handle alias input lines. """

    theRest = esc_quotes(theRest)
    line_out = "%s%s.call_alias('%s','%s')" % (pre,self.name,iFun,theRest)
    self.log(line_out,continue_prompt)
    self.update_cache(line_out)
    return line_out</t>
<t tx="ekr.20050707230243.24">def handle_shell_escape(self, line, continue_prompt=None,
                        pre=None,iFun=None,theRest=None):
    """Execute the line in a shell, empty return value"""

    # Example of a special handler. Others follow a similar pattern.
    if continue_prompt:  # multi-line statements
        if iFun.startswith('!!'):
            print 'SyntaxError: !! is not allowed in multiline statements'
            return pre
        else:
            cmd = ("%s %s" % (iFun[1:],theRest)).replace('"','\\"')
            line_out = '%s%s.system("%s")' % (pre,self.name,cmd)
    else: # single-line input
        if line.startswith('!!'):
            # rewrite iFun/theRest to properly hold the call to %sx and
            # the actual command to be executed, so handle_magic can work
            # correctly
            theRest = '%s %s' % (iFun[2:],theRest)
            iFun = 'sx'
            return self.handle_magic('%ssx %s' % (
                self.ESC_MAGIC,line[2:]),
                continue_prompt,pre,iFun,theRest)
        else:
            cmd = esc_quotes(line[1:])
            line_out = '%s.system("%s")' % (self.name,cmd)
    # update cache/log and return
    self.log(line_out,continue_prompt)
    self.update_cache(line_out)   # readline cache gets normal line
    return line_out
</t>
<t tx="ekr.20050707230243.25">def handle_magic(self, line, continue_prompt=None,
                 pre=None,iFun=None,theRest=None):
    """Execute magic functions.

    Also log them with a prepended # so the log is clean Python."""

    cmd = '%sipmagic("%s")' % (pre,esc_quotes('%s %s' % (iFun,theRest)))
    self.log(cmd,continue_prompt)
    self.update_cache(line)
    #print 'in handle_magic, cmd=&lt;%s&gt;' % cmd  # dbg
    return cmd</t>
<t tx="ekr.20050707230243.26">def handle_auto(self, line, continue_prompt=None,
                pre=None,iFun=None,theRest=None):
    """Hande lines which can be auto-executed, quoting if requested."""

    #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg
    
    # This should only be active for single-line input!
    if continue_prompt:
        return line

    if pre == self.ESC_QUOTE:
        # Auto-quote splitting on whitespace
        newcmd = '%s("%s")\n' % (iFun,'", "'.join(theRest.split()) )
    elif pre == self.ESC_QUOTE2:
        # Auto-quote whole string
        newcmd = '%s("%s")\n' % (iFun,theRest)
    else:
        # Auto-paren
        if theRest[0:1] in ('=','['):
            # Don't autocall in these cases.  They can be either
            # rebindings of an existing callable's name, or item access
            # for an object which is BOTH callable and implements
            # __getitem__.
            return '%s %s\n' % (iFun,theRest)
        if theRest.endswith(';'):
            newcmd = '%s(%s);\n' % (iFun.rstrip(),theRest[:-1])
        else:
            newcmd = '%s(%s)\n' % (iFun.rstrip(),theRest)

    print &gt;&gt;Term.cout, self.outputcache.prompt1.auto_rewrite() + newcmd,
    # log what is now valid Python, not the actual user input (without the
    # final newline)
    self.log(newcmd.strip(),continue_prompt)
    return newcmd</t>
<t tx="ekr.20050707230243.27">def handle_help(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Try to get some help for the object.

    obj? or ?obj   -&gt; basic information.
    obj?? or ??obj -&gt; more details.
    """

    # We need to make sure that we don't process lines which would be
    # otherwise valid python, such as "x=1 # what?"
    try:
        code.compile_command(line)
    except SyntaxError:
        # We should only handle as help stuff which is NOT valid syntax
        if line[0]==self.ESC_HELP:
            line = line[1:]
        elif line[-1]==self.ESC_HELP:
            line = line[:-1]
        self.log('#?'+line)
        self.update_cache(line)
        if line:
            self.magic_pinfo(line)
        else:
            page(self.usage,screen_lines=self.rc.screen_length)
        return '' # Empty string is needed here!
    except:
        # Pass any other exceptions through to the normal handler
        return self.handle_normal(line,continue_prompt)
    else:
        # If the code compiles ok, we should handle it normally
        return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050707230243.28">def handle_emacs(self,line,continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Handle input lines marked by python-mode."""

    # Currently, nothing is done.  Later more functionality can be added
    # here if needed.

    # The input cache shouldn't be updated

    return line</t>
<t tx="ekr.20050707230243.29">def safe_execfile(self,fname,*where,**kw):
    fname = os.path.expanduser(fname)

    # find things also in current directory
    dname = os.path.dirname(fname)
    if not sys.path.count(dname):
        sys.path.append(dname)

    try:
        xfile = open(fname)
    except:
        print &gt;&gt; Term.cerr, \
              'Could not open file &lt;%s&gt; for safe execution.' % fname
        return None

    kw.setdefault('islog',0)
    kw.setdefault('quiet',1)
    kw.setdefault('exit_ignore',0)
    first = xfile.readline()
    _LOGHEAD = str(self.LOGHEAD).split('\n',1)[0].strip()
    xfile.close()
    # line by line execution
    if first.startswith(_LOGHEAD) or kw['islog']:
        print 'Loading log file &lt;%s&gt; one line at a time...' % fname
        if kw['quiet']:
            stdout_save = sys.stdout
            sys.stdout = StringIO.StringIO()
        try:
            globs,locs = where[0:2]
        except:
            try:
                globs = locs = where[0]
            except:
                globs = locs = globals()
        badblocks = []

        # we also need to identify indented blocks of code when replaying
        # logs and put them together before passing them to an exec
        # statement. This takes a bit of regexp and look-ahead work in the
        # file. It's easiest if we swallow the whole thing in memory
        # first, and manually walk through the lines list moving the
        # counter ourselves.
        indent_re = re.compile('\s+\S')
        xfile = open(fname)
        filelines = xfile.readlines()
        xfile.close()
        nlines = len(filelines)
        lnum = 0
        while lnum &lt; nlines:
            line = filelines[lnum]
            lnum += 1
            # don't re-insert logger status info into cache
            if line.startswith('#log#'):
                continue
            elif line.startswith('#%s'% self.ESC_MAGIC):
                self.update_cache(line[1:])
                line = magic2python(line)
            elif line.startswith('#!'):
                self.update_cache(line[1:])
            else:
                # build a block of code (maybe a single line) for execution
                block = line
                try:
                    next = filelines[lnum] # lnum has already incremented
                except:
                    next = None
                while next and indent_re.match(next):
                    block += next
                    lnum += 1
                    try:
                        next = filelines[lnum]
                    except:
                        next = None
                # now execute the block of one or more lines
                try:
                    exec block in globs,locs
                    self.update_cache(block.rstrip())
                except SystemExit:
                    pass
                except:
                    badblocks.append(block.rstrip())
        if kw['quiet']:  # restore stdout
            sys.stdout.close()
            sys.stdout = stdout_save
        print 'Finished replaying log file &lt;%s&gt;' % fname
        if badblocks:
            print &gt;&gt; sys.stderr, \
                  '\nThe following lines/blocks in file &lt;%s&gt; reported errors:' \
                  % fname
            for badline in badblocks:
                print &gt;&gt; sys.stderr, badline
    else:  # regular file execution
        try:
            execfile(fname,*where)
        except SyntaxError:
            etype, evalue = sys.exc_info()[0:2]
            self.SyntaxTB(etype,evalue,[])
            warn('Failure executing file: &lt;%s&gt;' % fname)
        except SystemExit,status:
            if not kw['exit_ignore']:
                self.InteractiveTB()
                warn('Failure executing file: &lt;%s&gt;' % fname)
        except:
            self.InteractiveTB()
            warn('Failure executing file: &lt;%s&gt;' % fname)</t>
<t tx="ekr.20050708071222">@nocolor

3.23.2 Interactive Console Objects

The InteractiveConsole class is a subclass of InteractiveInterpreter, and so offers all the methods of the interpreter objects as well as the following additions. 

interact( [banner]) 

Closely emulate the interactive Python console. The optional banner argument specify the banner to print before the first interaction; by default it prints a banner similar to the one printed by the standard Python interpreter, followed by the class name of the console object in parentheses (so as not to confuse this with the real interpreter - since it's so close!). 


raw_input( [prompt]) 

Write a prompt and read a line. The returned line does not include the trailing newline. When the user enters the EOF key sequence, EOFError is raised. The base implementation uses the built-in function raw_input(); a subclass may replace this with a different implementation.

@color
</t>
<t tx="ekr.20050708072233.1">@nocolor

3.23.1 Interactive Interpreter Objects 

runsource( source[, filename[, symbol]]) 

Compile and run some source in the interpreter. Arguments are the same as for compile_command(); the default for filename is '&lt;input&gt;', and for symbol is 'single'. One several things can happen: 

The input is incorrect; compile_command() raised an exception (SyntaxError or OverflowError). A syntax traceback will be printed by calling the showsyntaxerror() method. runsource() returns False. 

The input is incomplete, and more input is required; compile_command() returned None. runsource() returns True. 

The input is complete; compile_command() returned a code object. The code is executed by calling the runcode() (which also handles run-time exceptions, except for SystemExit). runsource() returns False. 
The return value can be used to decide whether to use sys.ps1 or sys.ps2 to prompt the next line. 

runcode( code) 

Execute a code object. When an exception occurs, showtraceback() is called to display a traceback. All exceptions are caught except SystemExit, which is allowed to propagate. 
A note about KeyboardInterrupt: this exception may occur elsewhere in this code, and may not always be caught. The caller should be prepared to deal with it. 

showsyntaxerror( [filename]) 

Display the syntax error that just occurred. This does not display a stack trace because there isn't one for syntax errors. If filename is given, it is stuffed into the exception instead of the default filename provided by Python's parser, because it always uses '&lt;string&gt;' when reading from a string. The output is written by the write() method. 

showtraceback( ) 

Display the exception that just occurred. We remove the first stack item because it is within the interpreter object implementation. The output is written by the write() method. 

@color
</t>
<t tx="ekr.20050708072233.2">write( data) 

Write a string to the standard error stream (sys.stderr). Derived classes should override this to provide the appropriate output handling as needed.</t>
<t tx="ekr.20050708072233.3">@nocolor

push( line) 

Push a line of source text to the interpreter. The line should not have a trailing newline; it may have internal newlines. The line is appended to a buffer and the interpreter's runsource() method is called with the concatenated contents of the buffer as source. If this indicates that the command was executed or invalid, the buffer is reset; otherwise, the command is incomplete, and the buffer is left as it was after the line was appended. The return value is True if more input is required, False if the line was dealt with in some way (this is the same as runsource()). 
</t>
<t tx="ekr.20050708072233.4">@nocolor

resetbuffer( ) 

Remove any unhandled source text from the input buffer. </t>
<t tx="ekr.20050708074118"># All handlers *must* return a value, even if it's blank ('').

# Lines are NOT logged here. Handlers should process the line as
# needed, update the cache AND log it (so that the input cache array
# stays synced).

# This function is _very_ delicate, and since it's also the one which
# determines IPython's response to user input, it must be as efficient
# as possible.  For this reason it has _many_ returns in it, trying
# always to exit as quickly as it can figure out what it needs to do.

# This function is the main responsible for maintaining IPython's
# behavior respectful of Python's semantics.  So be _very_ careful if
# making changes to anything here.</t>
<t tx="ekr.20050708074118.1"># the input history needs to track even empty lines

if not continue_prompt:
    self.outputcache.prompt_count -= 1

return self.handle_normal('',continue_prompt)</t>
<t tx="ekr.20050708074118.2">handler = None
if line[-1] == self.ESC_HELP:
    handler = self.esc_handlers.get(line[-1])  # the ? can be at the end
    
if handler is None:
    # look at the first character of iFun, NOT of line, so we skip
    # leading whitespace in multiline input
    handler = self.esc_handlers.get(iFun[0:1])

if handler is not None:
    return handler(line,continue_prompt,pre,iFun,theRest)

# Emacs ipython-mode tags certain input lines
if line.endswith('# PYTHON-MODE'):
    return self.handle_emacs(line,continue_prompt)</t>
<t tx="ekr.20050708074118.3"># Allow ! in multi-line statements if multi_line_specials is on:
if (
    continue_prompt and self.rc.multi_line_specials and iFun.startswith(self.ESC_SHELL)
):
    return self.handle_shell_escape(line,continue_prompt,
            pre=pre,iFun=iFun,theRest=theRest)</t>
<t tx="ekr.20050708074118.4">oinfo = None

if hasattr(self,'magic_'+iFun):
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic
    if oinfo['ismagic']:
        # Be careful not to call magics when a variable assignment is
        # being made (ls='hi', for example)
        if (
            self.rc.automagic and
            (len(theRest)==0 or theRest[0] not in '!=()&lt;&gt;,') and 
            (self.rc.multi_line_specials or not continue_prompt)
        ):
            return self.handle_magic(line,continue_prompt,pre,iFun,theRest)
        else:
            return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708074118.5"># If the rest of the line begins with an (in)equality, assginment or
# function call, we should not call _ofind but simply execute it.
# This avoids spurious geattr() accesses on objects upon assignment.
#
# It also allows users to assign to either alias or magic names true
# python variables (the magic/alias systems always take second seat to
# true python code).
if theRest and theRest[0] in '!=()':
    return self.handle_normal(line,continue_prompt)

if oinfo is None:
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic

if not oinfo['found']:
    return self.handle_normal(line,continue_prompt)
else:
    #print 'iFun &lt;%s&gt; rest &lt;%s&gt;' % (iFun,theRest) # dbg
    if oinfo['isalias']:
        return self.handle_alias(line,continue_prompt,
                                     pre,iFun,theRest)

    if self.rc.autocall and \
           not self.re_exclude_auto.match(theRest) and \
           self.re_fun_name.match(iFun) and \
           callable(oinfo['obj']) :
        #print 'going auto'  # dbg
        return self.handle_auto(line,continue_prompt,pre,iFun,theRest)
    else:
        #print 'was callable?', callable(oinfo['obj'])  # dbg
        return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708074118.6"># Set the default prefilter() function (this can be user-overridden)
prefilter = _prefilter</t>
<t tx="ekr.20050708080420"># Job manager (for jobs run as background threads)
self.jobs = BackgroundJobManager()

# Put the job manager into builtins so it's always there.
__builtin__.jobs = self.jobs</t>
<t tx="ekr.20050708080420.1"># class initializations
code.InteractiveConsole.__init__(self,locals = self.user_ns)
Logger.__init__(self,log_ns = self.user_ns)
Magic.__init__(self,self)

# an ugly hack to get a pointer to the shell, so I can start writing
# magic code via this pointer instead of the current mixin salad.
Magic.set_shell(self,self)</t>
<t tx="ekr.20050708080420.2">hooks = IPython.hooks
for hook_name in hooks.__all__:
    self.set_hook(hook_name,getattr(hooks,hook_name))</t>
<t tx="ekr.20050708080420.3">self.usage_min =  """\
An enhanced console for Python.
Some of its features are:
- Readline support if the readline library is present.
- Tab completion in the local namespace.
- Logging of input, see command-line options.
- System shell escape via ! , eg !ls.
- Magic commands, starting with a % (like %ls, %pwd, %cd, etc.)
- Keeps track of locally defined variables via %who, %whos.
- Show object information with a ? eg ?x or x? (use ?? for more info).
"""
if usage: self.usage = usage
else: self.usage = self.usage_min</t>
<t tx="ekr.20050708080420.4">
    # utility to expand user variables via Itpl
    self.var_expand = lambda cmd: str(ItplNS(cmd.replace('#','\#'),self.user_ns))
    # The first is similar to os.system, but it doesn't return a value,
    # and it allows interpolation of variables in the user's namespace.
    self.system = lambda cmd: shell(self.var_expand(cmd),
                                    header='IPython system call: ',
                                    verbose=self.rc.system_verbose)
    # These are for getoutput and getoutputerror:
    self.getoutput = lambda cmd: \
                     getoutput(self.var_expand(cmd),
                               header='IPython system call: ',
                               verbose=self.rc.system_verbose)
    self.getoutputerror = lambda cmd: \
                          getoutputerror(str(ItplNS(cmd.replace('#','\#'),
                                                    self.user_ns)),
                                         header='IPython system call: ',
                                         verbose=self.rc.system_verbose)</t>
<t tx="ekr.20050708080420.5">
    # RegExp for splitting line contents into pre-char//first
    # word-method//rest.  For clarity, each group in on one line.

    # WARNING: update the regexp if the above escapes are changed, as they
    # are hardwired in.

    # Don't get carried away with trying to make the autocalling catch too
    # much:  it's better to be conservative rather than to trigger hidden
    # evals() somewhere and end up causing side effects.

    self.line_split = re.compile(r'^([\s*,;/])'
                                 r'([\?\w\.]+\w*\s*)'
                                 r'(\(?.*$)')

    # Original re, keep around for a while in case changes break something
    #self.line_split = re.compile(r'(^[\s*!\?%,/]?)'
    #                             r'(\s*[\?\w\.]+\w*\s*)'
    #                             r'(\(?.*$)')

    # RegExp to identify potential function names
    self.re_fun_name = re.compile(r'[a-zA-Z_]([a-zA-Z0-9_.]*) *$')
    # RegExp to exclude strings with this start from autocalling
    self.re_exclude_auto = re.compile('^[!=()&lt;&gt;,\*/\+-]|^is ')
    # try to catch also methods for stuff in lists/tuples/dicts: off
    # (experimental). For this to work, the line_split regexp would need
    # to be modified so it wouldn't break things at '['. That line is
    # nasty enough that I shouldn't change it until I can test it _well_.
    #self.re_fun_name = re.compile (r'[a-zA-Z_]([a-zA-Z0-9_.\[\]]*) ?$')</t>
<t tx="ekr.20050708080420.6">self._dolog = 0
self.LOG = ''
self.LOGDEF = '.InteractiveShell.log'
self.LOGMODE = 'over'
self.LOGHEAD = Itpl(
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = $self.rc.opts
#log# args = $self.rc.args
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
""")</t>
<t tx="ekr.20050708080420.7">self.CACHELENGTH = 5000  # this is cheap, it's just text
self.BANNER = "Python %(version)s on %(platform)s\n" % sys.__dict__
self.banner2 = banner2</t>
<t tx="ekr.20050708080420.8"># Need two, one for syntax errors and one for other exceptions.
self.SyntaxTB = ultraTB.ListTB(color_scheme='NoColor')
# This one is initialized with an offset, meaning we always want to
# remove the topmost item in the traceback, which is our own internal
# code. Valid modes: ['Plain','Context','Verbose']
self.InteractiveTB = ultraTB.AutoFormattedTB(mode = 'Plain',
                                             color_scheme='NoColor',
                                             tb_offset = 1)
# and add any custom exception handlers the user may have specified
self.set_custom_exc(*custom_exceptions)</t>
<t tx="ekr.20050708080420.9">ins_colors = OInspect.InspectColors
code_colors = PyColorize.ANSICodeColors
self.inspector = OInspect.Inspector(ins_colors,code_colors,'NoColor')
self.autoindent = 0</t>
<t tx="ekr.20050708080420.10"># Prepare list of shell aliases to auto-define
if os.name == 'posix':            
    auto_alias = ('mkdir mkdir', 'rmdir rmdir',
                  'mv mv -i','rm rm -i','cp cp -i',
                  'cat cat','less less','clear clear',
                  # a better ls
                  'ls ls -F',
                  # long ls
                  'll ls -lF',
                  # color ls
                  'lc ls -F -o --color',
                  # ls normal files only
                  'lf ls -F -o --color %l | grep ^-',
                  # ls symbolic links 
                  'lk ls -F -o --color %l | grep ^l',
                  # directories or links to directories,
                  'ldir ls -F -o --color %l | grep /$',
                  # things which are executable
                  'lx ls -F -o --color %l | grep ^-..x',
                  )
elif os.name in ['nt','dos']:
    auto_alias = ('dir dir /on', 'ls dir /on',
                  'ddir dir /ad /on', 'ldir dir /ad /on',
                  'mkdir mkdir','rmdir rmdir','echo echo',
                  'ren ren','cls cls','copy copy')
else:
    auto_alias = ()
    
self.auto_alias = map(lambda s:s.split(None,1),auto_alias)</t>
<t tx="ekr.20050708080420.11">self.rc = rc   # This will hold all configuration information
self.inputcache = []
self._boundcache = []
self.pager = 'less'
# temporary files used for various purposes.  Deleted at exit.
self.tempfiles = []</t>
<t tx="ekr.20050708080420.12">try:
    self.home_dir = get_home_dir()
except HomeDirError,msg:
    fatal(msg)

self.dir_stack = [os.getcwd().replace(self.home_dir,'~')]</t>
<t tx="ekr.20050708080420.13">#***************************************************************************
# Utility functions
</t>
<t tx="ekr.20050708080512.1">#*****************************************************************************
#       Copyright (C) 2001 Janko Hauser &lt;jhauser@zscout.de&gt; and
#       Copyright (C) 2001-2004 Fernando Perez &lt;fperez@colorado.edu&gt;
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#*****************************************************************************</t>
<t tx="ekr.20050708080801">@

These sources are for stufy only.

There is NO particular guarantee of accuracy.</t>
<t tx="ekr.20050708081540"></t>
<t tx="ekr.20050708082932"></t>
<t tx="ekr.20050708082932.1"></t>
<t tx="ekr.20050708082932.2"></t>
<t tx="ekr.20050708082932.3"></t>
<t tx="ekr.20050708084235"></t>
<t tx="ekr.20050708084235.1"></t>
<t tx="ekr.20050708084235.2"></t>
<t tx="ekr.20050708084235.3"></t>
<t tx="ekr.20050708084235.4">@nocolor

InteractiveShell.prefilter handles ipython lines.

@color</t>
</tnodes>
</leo_file>
