#@+leo-ver=4-thin
#@+node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@@nocolor

#@+all
#@+node:ekr.20061116060847:@url http://www.jhorman.org/wikidPad/
#@-node:ekr.20061116060847:@url http://www.jhorman.org/wikidPad/
#@+node:ekr.20050123161408:ExamDiff files & scripts
0 leo.py
1 leoApp.py
2 leoAtFile.py
3 leoColor.py
4 leoCommands.py
5 leoCompare.py
6 leoConfig.py
7 leoFileCommands.py
8 leoFind.py
9 leoFrame.py
10 leoGlobals.py
11 leoGui.py
12 leoImport.py
13 leoKeys.py
14 leoMenu.py
15 leoNodes.py
16 leoPlugins.py
17 leoTangle.py
18 leoTkinterComparePanel.py
19 leoTkinterDialog.py
20 leoTkinterFind.py
21 leoTkinterFontPanel.py
22 leoTkinterFrame.py
23 leoTkinterGui.py
24 leoTkinterKeys.py
25 leoTkinterMenu.py
26 leoTkinterTree.py
27 leoUndo.py
#@nonl
#@+node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
print '-' * 20
d = []

for p in c.allNodes_iter():
    s = p.headString()
    if s.startswith('@thin'):
        d.append(s[5:].strip())
        
d.sort()

for s in d:
    print s
    

        
#@-node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
#@-node:ekr.20050123161408:ExamDiff files & scripts
#@+node:ekr.20031218072017.365:How to...
#@+node:ekr.20060208112908:CVS stuff...
#@+node:ekr.20060331094112:How to generate keys using putty
To generate a SSH key using PuTTY:

Execute c:\"Program Files"\tortoiseCVS\PUTTYGEN.EXE

Select "SSH2 DSA", within the "Parameters" section.

Click on the "Generate" button. Follow the instruction to move the mouse over
the blank area of the program in order to create random data used by PUTTYGEN to
generate secure keys. Key generation will occur once PUTTYGEN has collected
sufficient random data.

Enter edream@cvs.sourceforge.net for the key comment (depends on what host the
key is for)

(Omit) Enter the desired passphrase in the "Key passphrase" and "Confirm passphrase"
fields. If the key will be used for automation of operations (i.e. as part of a
script), you may choose to omit this step from the key generation process.

Click on the "Save private key" button. Use the resulting dialog to save your
private key data for future use. You may use a filename such as
"SourceForge-Shell.ppk" or "SourceForge-CF.ppk". The .ppk extension is used for
PuTTY Private Key files.

Go to the SSH key posting page on the SourceForge.net site: http://sourceforge.net/account/

Copy your public key data from the "Public key for pasting into OpenSSH
authorized_keys2 file" section of the PuTTY Key Generator, and paste the key
data to the provided form on the SourceForge.net site. Click on the "Update"
button to complete the posting process.

Exit the PuTTY Key Generator (PUTTYGEN).

Key data sync to hosts from the SourceForge.net site occurs on regular
intervals. Your key data will be synchronized to the designated servers (either
shell and CVS, or the Compile Farm) after a short delay.
#@nonl
#@-node:ekr.20060331094112:How to generate keys using putty
#@+node:ekr.20060208112908.1:How to check out leo from SourceForge
The Tortoise cvs params:

:ext:edream@cvs.sourceforge.net:/cvsroot/leo

That is...

Protocol: pserver
Server: cvs.sourceforge.net
Repository folder: /cvsroot/leo
User name: your cvs name

### :pserver:anonymous@cvs.sourceforge.net:/cvsroot/leo
#@nonl
#@-node:ekr.20060208112908.1:How to check out leo from SourceForge
#@+node:ekr.20031218072017.366:How to add and remove files from CVS repository
use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
	cvs add leoConfig.txt
	cvs add leoConfig.py
	(then do commit)

remove readme*.doc
	remove files from working area (done)
	cvs remove readme1.doc
	cvs remove readme2.doc
	...
	(then do commit)
#@nonl
#@-node:ekr.20031218072017.366:How to add and remove files from CVS repository
#@+node:ekr.20031218072017.391:How to use CVS branches
@nocolor

I have a fair bit of expertise on CVS branches. It's late at night, so I don't have time for a long soapbox spiel at the moment. I will try to post something tomorrow. 

The brief picture is: 

* Check out code from CVS at the point you want to create the branch. 

* Make sure none of the files in your sandbox is modified. 

* Create the branch (cvs tag -b branchname). The branch name must start with a letter (upper or lower case) and thereafter can have alphanumeric characters, hyphens, and underscores (no periods or spaces). 

* The branch is created on the repository, but your sandbox is still checked out on the main branch. To check out on the new branch, do "cvs up -r branchname". 

When you want to merge changes back into the main branch, you can use "cvs up -r MAIN" to retrieve the main branch, then "cvs up -j branchname" to merge changes, then "cvs commit" to commit the merged version to the main branch AFTER YOU HAVE VERIFIED IT. 

I would recommend caution with merging because as you have noted, leo files are not well set up for CVS. They don't merge well because of inconsistent sentinel values. 

You may want to look at manually merging changes back into the main branch until leo implements invariant unique (UUID) sentinel indices. 

This will not hurt your ability to use branches, only your ability to automatically merge changes from one branch onto another.
#@nonl
#@-node:ekr.20031218072017.391:How to use CVS branches
#@-node:ekr.20060208112908:CVS stuff...
#@+node:ekr.20031218072017.367:How to add support for a new language
@nocolor

- Add a new entries in << define global data structures >> app

- Add a new Tk.Radiobutton in <<create the Target Language frame>>

- Add an entry to the languages list in <<configure language-specific settings>>

- Add a list of the keywords of the language to << define colorizer keywords >>

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.
  
- If the language is case insensitive, add it to the list of
case_insensitiveLanguages found in  << define global colorizer data >>

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the <preferences> tag (near the top) contains an entry like this:

<preferences allow_rich_text="0" defaultTargetLanguage="Python">
</preferences>

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color
#@nonl
#@+node:EKR.20040623090054:<< define global colorizer data >>
case_insensitiveLanguages = ['plsql',]
#@-node:EKR.20040623090054:<< define global colorizer data >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */", # C#
    "cpp" : "// /* */",# C++.
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "lua" : "--",  # ddm 13/02/06
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "cpp" : "cpp",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "pascal" : "p",
    # "perl" : "perl",
    # "perlpod" : "perl",
    "perl" : "pl",      # 11/7/05
    "perlpod" : "pod",  # 11/7/05
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "lua" : "lua",  # ddm 13/02/06
    "noweb" : "nw",
    "p"     : "pascal",
    # "perl"  : "perl",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex","lua",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords
#@+node:ekr.20031218072017.372:actionscript keywords
actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
#@-node:ekr.20031218072017.372:actionscript keywords
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20040206072057:c# keywords
csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]
#@-node:ekr.20040206072057:c# keywords
#@+node:ekr.20031218072017.373:c/c++ keywords
c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]
#@-node:ekr.20031218072017.373:c/c++ keywords
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.374:elisp keywords
# EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]
#@-node:ekr.20031218072017.374:elisp keywords
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20031218072017.375:html keywords
# No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "<%","%>" ]
#@-node:ekr.20031218072017.375:html keywords
#@+node:ekr.20031218072017.376:java keywords
java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]
#@-node:ekr.20031218072017.376:java keywords
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx", "\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap",
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus",
    "\\bigvee", "\\bigwedge", "\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter",
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage",
    "\\cline", "\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh",
    "\\cot", "\\coth", "csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl",
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj",
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath",
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote",
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing",
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright", "\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill", "\\hspace", "\\huge", "\\Huge", "\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota", "\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", "\\linebreak", 
    "\\linethickness", "\\linewidth", "\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow", "longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength", "\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox", "\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", "\\phi", "\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi", "\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", "\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow", "\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow", "\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone", "\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark", "\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title", "\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow", "\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", "\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]
#@-node:ekr.20031218072017.377:latex keywords
#@+node:ekr.20060328110802:lua keywords
# ddm 13/02/06
lua_keywords = [
    "and", "break", "do", "else", "elseif", "end",
    "false", "for", "function", "if", "in", "local",
    "nil", "not", "or", "repeat", "return", "then",
    "true", "until", "while",
]
#@-node:ekr.20060328110802:lua keywords
#@+node:ekr.20031218072017.378:pascal keywords
pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]
#@-node:ekr.20031218072017.378:pascal keywords
#@+node:ekr.20031218072017.379:perl keywords
perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 & FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 & f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]
#@-node:ekr.20031218072017.379:perl keywords
#@+node:ekr.20031218072017.380:php keywords
php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "<?php", "?>"
#@-node:ekr.20031218072017.380:php keywords
#@+node:ekr.20050618052653:plsql keywords
plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
#@-node:ekr.20050618052653:plsql keywords
#@+node:ekr.20031218072017.381:python keywords
python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]
#@-node:ekr.20031218072017.381:python keywords
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@-node:ekr.20040331145826:rapidq keywords
#@+node:ekr.20031218072017.382:rebol keywords
rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
#@-node:ekr.20031218072017.382:rebol keywords
#@+node:ekr.20040401111125:shell keywords
shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]
#@-node:ekr.20040401111125:shell keywords
#@+node:ekr.20031218072017.383:tcl/tk keywords
tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]
#@-node:ekr.20031218072017.383:tcl/tk keywords
#@-node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
#@+node:ekr.20050618052621:Add the language name to @language default_target_language entry in leoSettings.leo
#@-node:ekr.20050618052621:Add the language name to @language default_target_language entry in leoSettings.leo
#@-node:ekr.20031218072017.367:How to add support for a new language
#@+node:ekr.20031218072017.384:How to export syntax colored code preserving colors
Scite has the option to "Export as html" and "export as rtf", and it will be
full of colour and fonts - and you can define them in properties, so it will be
the same as during editing.
#@nonl
#@-node:ekr.20031218072017.384:How to export syntax colored code preserving colors
#@+node:ekr.20031218072017.385:How to Increase environment space
To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.
Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.
On Me you set the registry somehow.
No information on XP.
#@nonl
#@-node:ekr.20031218072017.385:How to Increase environment space
#@+node:ekr.20051203084725:How to expand java .jar files
- Put whatever.jar in c:\prog
- cd: c:\prog
- jar xvf whatever.jar
#@nonl
#@-node:ekr.20051203084725:How to expand java .jar files
#@+node:ekr.20051129084430:How to install jython
@nocolor

- Download jython_Release_2_2alpha1.jar and put it anywhere (say on the desktop)

- Double-click the file.  This brings up an installer.  Follow the direction.
  (I installed to c:\jython-2.2a1

- Using the Control Panel, System, Advanced tab, environment variables,
  add c:\jython-2.2a1\jython.jar to CLASSPATH (in user variables)
#@nonl
#@+node:ekr.20051129084430.1:@url http://www.jython.org/install.html
#@-node:ekr.20051129084430.1:@url http://www.jython.org/install.html
#@-node:ekr.20051129084430:How to install jython
#@+node:ekr.20051203084725.1:How to install and run jythonShell
Install:

Put JythonShellEA.jar in c:\prog\JythonShell

(optional) Expand the jar so you can see the code:

jar xvf JythonShellEA.jar

Run:

Here is the contents of jythonShell.bat:

cd c:\prog\jythonShell
java -cp c:\jython-2.2a1\jython.jar;c:\prog\jythonShell\JythonShellEA2.1.jar org.leo.shell.JythonShell
#@nonl
#@-node:ekr.20051203084725.1:How to install and run jythonShell
#@+node:ekr.20050316092232:How to install jyLeo
- Unpack the .zip file, placing the result somewhere, say in c:\prog\jyleo-Jan-11-06

- Edit jleo.bat so it refers to jyleo-Jan-11-06.  For example:

rem open jyLeo
set ARGS= 
:loop 
if [%1] == [] goto end 
set ARGS=%ARGS% %1 
shift 
goto loop 
:end 

cd c:\prog\jyleo-Jan-11-06
java -jar c:\jython-2.2a1\jython.jar src\leo.py
#@nonl
#@+node:ekr.20050716104357:Old instructions
@nocolor

- put the jyleo-nnn.jar file in c:\prog

- Execute the following command in a console window
    cd c:\prog
    jar xvf j-leo-nnn.jar

This creates a folder called j-leo-nnn

- Do the following, or execute jleo.bat

cd c:\prog\j-leo-nnn\src
java -jar c:\jython22a0\jython.jar leo.py

Note:  at present this gives KeyError: HOME

In leo.py, in computeHomeDir, I changed:
@color

home = os.getenv('HOME' )#,default=dotDir)

to:

try:
    home = os.getenv('HOME' )#,default=dotDir)
except Exception:
    home = ''
#@-node:ekr.20050716104357:Old instructions
#@+node:ekr.20050317153447:jy-Leo install instructions by Paul Paterson
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3053534
By: paulpaterson

Very interesting indeed - great work! 
 
I didn't have Java/Jython installed so for others in the same boat here's what I had to do to get it work on my platform (Win2k). Some of this is in the README but I had to do some extra but I'm not sure why. 
 
1. Install 1.5 JDK  
http://java.sun.com/j2se/1.5.0/download.jsp 
 
2. Install Jython 
http://www.jython.org/jython22a1.zip 
 
3. Edit Jython.bat file - the part that calls Java.exe to ... 
"C:\Program Files\Java\jdk1.5.0_02\jre\bin\java" -cp "C:\Program Files\Java\jdk1.5.0_02\jre\lib";"c:\Apps\Python23\Jython";"C:\Apps\jLeo\j-leo-MAR15\Icons";"C:\Apps\jLeo\j-leo-MAR15\skins";"C:\Apps\jLeo\j-leo-MAR15\src";"C:\Apps\jLeo\j-leo-MAR15\skinimages" -Dpython.home="c:\Apps\Python23\Jython" -jar jython.jar %ARGS% 
 
Where  
- Java installed at C:\Program Files\Java\jdk1.5.0_02 
- Jython at c:\Apps\Python23\Jython 
- jLeo at C:\Apps\jLeo\j-leo-MAR15 
 
Change your paths as appropriate! There must be a better way to do this - Java confuses me! 
 
4. Edit leo.py in jleo/src directory to fix failure to find HOME env variable. 
 
line 241 becomes ... 
 
....try:home = os.getenv('HOME' )#,default=dotDir) 
....except KeyError:home="" 
 
 
Then, from the Jython install directory ... 
 
Jython " 
C:\Apps\jLeo\j-leo-MAR15\src\leo.py" 
 
Works a treat!  
 
Paul
#@-node:ekr.20050317153447:jy-Leo install instructions by Paul Paterson
#@-node:ekr.20050316092232:How to install jyLeo
#@+node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
> I am plowing through old bug reports, and I found the following, from whom 
> I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

>> - Source files still have the dreaded \r in them. Why don't you switch 
>> to \n only, once and for all, and live happily ever after? ;^) 

> I sure whould like to do that, and I'm not sure how to do this. All 
> versions of the read code attempt to remove '\r' characters, and all 
> versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 
 
#@+node:ekr.20031218072017.387:The solution
Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

> Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward
#@nonl
#@-node:ekr.20031218072017.387:The solution
#@+node:ekr.20031218072017.388:cursed newline answer
In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> f = open("crlf.txt")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
>>> f = open("crlf.txt", "rU")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline" problem,\n'

#@-node:ekr.20031218072017.388:cursed newline answer
#@+node:ekr.20031218072017.389:cursed newline answer 2
> You can open the file in 'binary' mode (adding 'b' to the mode string) and
> the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
#@-node:ekr.20031218072017.389:cursed newline answer 2
#@-node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
#@+node:ekr.20061023153133:How to run patch
patch -p1 < patchfile
#@-node:ekr.20061023153133:How to run patch
#@+node:ekr.20031218072017.390:How to run Pychecker
Do the following in Idle:

import pychecker.checker ; import leo

To run Idle(Python2.3 version) directly:

cd c:\prog\leoCvs\leo\src
c:\python23\python c:\python23\Lib\idlelib\idle.py

The HOME var must be set to c:\prog\leoCVS for .pycheckrc to be effective.

To suppress warnings from the standard library set ignoreStandardLibrary=1 in .pycheckrc
#@nonl
#@-node:ekr.20031218072017.390:How to run Pychecker
#@+node:ekr.20050510071834:How to use a temp file with pdb
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3137690
By: nobody

I dont know if anyone has solved this for regular Leo, but in the JyLeo JythonShell,
when the user executes a script with Pdb it:
1. dumps the script in a tmp file system's tmp directory.
2. Executes pdb based off of that tmp file.

that way you get all the goodness that pdb can offer.
#@-node:ekr.20050510071834:How to use a temp file with pdb
#@+node:ekr.20041214135556:How to use Tile
@nocolor
https://sourceforge.net/forum/message.php?msg_id=2882718
By: nobody

if anyone is interested here is some code that Tilefied my Leo instance, its
does some patching in the LeoGui program.

@color

def createRootWindow(self):

    """Create a hidden Tk root window."""
    #import Tix
    self.root = root = Tk.Tk()
    root.tk.call( 'package', 'require', 'tile' )
    #root.tk.call( 'namespace', 'import', '-force', 'ttk::*' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::scrollbar' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::label' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::entry' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menu' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::button' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::frame' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menubutton' )
    root.tk.call( 'tile::setTheme', 'clam' )
    #self.root = root = Tix.Tk()
    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    self.getDefaultConfigFont(g.app.config)
    self.createGlobalWindows()

    return root
#@nonl
#@-node:ekr.20041214135556:How to use Tile
#@-node:ekr.20031218072017.365:How to...
#@+node:ekr.20070215183046:IronPython notes
@nocolor

- IronPython does not accept 'from __future__ import x'
  I could work around this, but perhaps it is time to abandon Python 2.2.2.
  
- Amazingly, it is possible to add Python24\Lib to IronPython's path!
  Almost all of those modules import correct.

- IronPython has troubles with the xml modules.
  It complains about a missing 'strict' codec.
  
- IronPython has trouble with the pdb module, so some other way must be found to debug IronPython programs.
#@nonl
#@-node:ekr.20070215183046:IronPython notes
#@+node:ekr.20050214055018:Mac Notes
#@+node:ekr.20050221054932:How to make monolithic Leo app on MacOS X
 @killcolor
http://sourceforge.net/forum/message.php?msg_id=3007062
By: jgleeson

Sorry to take so long to reply.  I've been buried in work and haven't kept up
with some email.

Here's the link to the site where I posted the folder you have:
<http://homepage.mac.com/jdgleeson/>  It's the small file named "Leo.zip" (23
KB), not the large file "Leo-4.3-alpha-2.dmg" (20 MB).

I agree that I did not write very clear instructions, beginnng with the first
step, where I should have also said:  "It is important to use version 1.1.8
of py2app, which is only available through svn.  The version on the py2app website
is 1.1.7, which creates buggy Tkinter apps. If you try to use version 1.1.7,
the Leo app it creates will give you a message saying that Tkinter is not properly
installed.  Your installation is fine; otherwise you could not have even built
Leo.app with py2app, because py2app copies the essential parts of Tcl/Tk into
the application bundle to make the app completely standalone."

I haven't tried intalling the Fink subversion -- I'm using DarwinPorts
<http://darwinports.opendarwin.org/>.  But there's a simpler alternative than
DarwinPorts. Metissian releases OS X packages of Subversion clients
<http://metissian.com/projects/macosx/subversion/>

AFAIK, the command "python setup.py bdist_mpkg --open" only applies to the py2app
1.1.8 distribution.  By the way, bdist_mpkg is distributed with py2app. It creates
a package around the setup.py script (more specialized than Platypus).  I don't
have any experience with bdist_mpkg yet.

'Copy the leo folder into this directory' is horrible. I'm glad you figured
it out -- I'm not sure I could have.

"python setup.py py2app -a" should be run in the folder with the readme file,
which also contains the setup.py file that the command refers to.  Most importantly,
the folder in which this command is run must contain the leo folder -- which
it does only if you are brilliant enough to decode my instructions.   ;) 

HTH

-John
#@nonl
#@-node:ekr.20050221054932:How to make monolithic Leo app on MacOS X
#@+node:ekr.20050214055018.4:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@-node:ekr.20050214055018.4:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@+node:ekr.20050214055018.5:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@-node:ekr.20050214055018.5:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@+node:ekr.20050513164506:Problems with run script command on Mac x11
@killcolor

Jon Schull <jschull@softlock.com>  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 
             
I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations:
- Leo runs under X11 as well as under OS X.
- My X11 python configuration was created using the recipe at XXX (which enables vpython).
- The OS X configuration is vanilla MacPython from MacPython.org, along with AquaTclTk batteries included XXX.

In both environments I can run leo under python leo.py and under idle.
Under OS X we get font smoothing, but we can't run visual python programs (python crashes;  this is a known incompatibility with  MacPython.)
    
- Under X11 we can run visual python programs like this one
    #box.py
    from visual import *
    box()
            
And we can even run them under leo (under X11). HOWEVER, when the visual python program is terminated, leo vanishes (leo and the vp program apparently run in the same space)
    
Under x11, we can keep leo alive by putting the vp program in its own space:
    
    os.popen3('/sw/bin/python /Users/jis/box.py')
    
However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...
        
    def do(cmd='ls'):
        from os import popen3
        pIn,pOut,pErr=0,1,2
        popenResults=popen3(cmd)
        print popenResults[pOut].read()
        print popenResults[pErr].read()
    
    import os	
    do('/sw/bin/python /Users/jis/box.py')
        
...but only when the vpython program terminates.
    
Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).
    
    import os	
    os.chdir('/sw/lib/python2.3/idlelib')
    os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')
        
#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.
    
Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.
    
It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
#@nonl
#@-node:ekr.20050513164506:Problems with run script command on Mac x11
#@+node:ekr.20040104162835.8:Linux/Mac notes: Dan Winkler
#@+node:ekr.20040104162835.13:Fink & aqua
Yes, fink does have pre-built Pythons, both 2.1 and 2.2.  (If you don't 
see them it probably means you don't have the right servers listed in 
your /sw/etc/apt/sources.list file.)  However, the versions of Python 
you'd get through fink are set up to run under X Windows, which I don't 
think is what you want.

I think what you want is MacPython which can run Tk programs like Leo 
under Aqua.  That's what I use these days.

I can tell from your question that you don't understand the following 
differences between the versions of Python available:

1) The version that comes with OS X is a text only one which doesn't 
have Tk.  Leo can't run under that.  Also, I hate Apple for including 
this instead of one that does have Tk and I hope they'll fix it some 
day.

2) You can get a version of Python from fink with has Tk but which runs 
under X Windows.  I don't think you want that.

3). You can also get MacPython which has Tk but it's a version of Tk 
that uses the Aqua windowing system, not X Windows.

So Tk can either be present or not and if it is present it can use 
either X Windows or Aqua.  You want it present and using Aqua, I think.


#@-node:ekr.20040104162835.13:Fink & aqua
#@+node:ekr.20040104162835.14:Mac, Fink, etc.
> 1. The python that FC installs is MacPython.  I think that because the
> MacPython docs talk about Fink.

Nope.  The python installed by FC knows nothing about the Mac.  It 
thinks it's running on a Unix machine.  And it uses a version of Tk 
which thinks it's running on a Unix machine.  The window standard on 
Unix is called X (or X11 or XFree86, all the same thing).  So the main 
reason to run Leo this way would be to get an idea of how it works for 
Unix/Linux users.  But when programs run under X, they don't look like 
Mac programs.  They don't get all those glossy, translucent widgets 
that Aqua provides.  They really look like they would on a Unix/Linux 
machine.

Aqua is the native windowing system on Mac.  MacPython is set up to 
work with it.  Most Mac users will want Leo to work this way.  That's 
what I do.

>
>
> I have the TkTclAquBI (Batteries included) installer.  Is installing 
> this
> enough to get Leo to work with Aqua?  Do I have to de-install the
> present tk stuff that I installed with FC?

Yes, I think that's all I installed to get Tk to work under Aqua.  You 
don't have to deinstall the FC stuff.  All the FC stuff lives in its 
own world under /sw and runs under X.  It won't conflict with the Mac 
world.

#@-node:ekr.20040104162835.14:Mac, Fink, etc.
#@+node:ekr.20040104162835.15:Double clicking on Linux
Double-clickable things (i.e. Macintosh applications) are usually 
actually folders with a name that ends in .app.  The file you found is 
probably executable only from the command line, not by double clicking 
it.  So I think if you run it from the command line it will work but 
will not know about Tk because Apple's version was built without Tk 
support.

You can also execute the .app programs from the command line by using 
the open command, so "open foo.app" will do the same thing as double 
clicking on foo in the finder (the .app extension is suppressed).  The 
idea behind this is that an application can look like just one opaque 
icon in the finder but actually have all its resources nicely organized 
in subfolders.
#@-node:ekr.20040104162835.15:Double clicking on Linux
#@-node:ekr.20040104162835.8:Linux/Mac notes: Dan Winkler
#@-node:ekr.20050214055018:Mac Notes
#@+node:ekr.20060111112513.1:New jyLeo notes
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3516227
By: nobody

Some highlights:
* simpler startup:
jyleo leo.py
should be sufficient to start it up.
* new editor colorization
* the JythonShell is much more powerful and cooler
* new plugins
* Chapters support
* mod_script is in place.
* dyna-menu was converted.  I guess 'e' will have to judge the conversion.
* multi-language script support.
* drag and drop
* some powerful new editor commands.  Try keyword completing on the language
in effect.  Say if it is python:
se(Tab)
becomes
self

Some warnings:
1. Be careful about reading your regular leo files into jyleo and saving them.
Its quite conceivable that jyleo will write it out to an XML format that regular
leo can't handle.  Why?  Well jyleo is using an XML library to spit its XML
out while leo uses a home grown method.  The library can handle leo's XML, but
Ive seen regular leo not be able to handle jyleo's XML.  Its based around <tag/>
I believe.

2. If you move jyleo after executing it you will need to clear out your compiled
py files as the __file__ attribute is hard compiled into the resulting objects.
Not what we want.  We want it to be set at runtime.  Ive been waiting a long
time for jython to release again and hopefully fix this, but Im not holding
my breath anymore.

----------
Its hard to give this thing a number, I want to call it jyleo2, but jyleo is
sufficient.  Dependent upon bug reports the next release could be much sooner
than before, maybe even weeks.  I hope one thing, that the dreaded "I can't
get it to start" problems are gone.  I took the snapshot and expanded it in
Windows XP.  Went to the src directory and typed: jython leo.py
and it started.  That's what I wanted to see.  I didn't have to mess with the
CLASSPATH or anything.

things needed:
java 5
a jython2.2a1 or beyond.  jython2.2a1 is the most recent snapshot.

Beyond bug fixing, I will be planning to add more SwingMacs command as time
goes along.  But I think most major features are in place.  Of course the 3D
experiments in the future could change that... :D

A NOTE ON STARTUP TIMES: In my experience it takes awhile for jyleo to start.
It will take much longer the first time you execute it because the py files
are being compiled.  Ive haven't been able to figure out what eats the time,
it may just have a slow startup in the aggregate.  So don't think its not doing
anything, it probably is.

leouser
#@nonl
#@-node:ekr.20060111112513.1:New jyLeo notes
#@+node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20031218072017.398:How to call any Python method from the C API
In general, everything you can do in Python is accessible through the C API.

	lines = block.split('\n');
 
> That will be
 
	lines = PyObject_CallMethod(block, "split", "s", "\n");
#@-node:ekr.20031218072017.398:How to call any Python method from the C API
#@+node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@+node:ekr.20031218072017.400:setting the PATHEXT env var
It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\>set PATH=%PATH%;c:\python22\tools\Scripts

C:\>google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\>google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\>
#@-node:ekr.20031218072017.400:setting the PATHEXT env var
#@+node:ekr.20031218072017.401:Yet another Python .bat wrapper
>> It has a header of just one line. All the ugly stuff is at the end.
>>
>> -------------------------------------------------------------------
>> goto ="python"
>>
>> # Python code goes here
>>
>> ''' hybrid python/batch footer:
>> @:="python"
>> @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
>> @if errorlevel 9009 echo Python may be downloaded from
>www.python.org/download
>> @rem '''
>> -------------------------------------------------------------------
>>
>>         Oren
>>
>

It's for running python scripts on windows, without having to type:

[<path to python>\]python[.exe] <scriptname> [<arguments>*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

#@-node:ekr.20031218072017.401:Yet another Python .bat wrapper
#@-node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@-node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20050306070535:Tk Notes
@killcolor
#@nonl
#@+node:ekr.20050306070535.3:How to detect changes in text
http://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:

>This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to <Alt-KeyPress>,
<Shift-KeyPress>, etc.  Tk chooses the most specific event it can find, so the
more general <KeyPress> handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

Brian Theado
#@nonl
#@-node:ekr.20050306070535.3:How to detect changes in text
#@-node:ekr.20050306070535:Tk Notes
#@+node:ekr.20070308062440:Thread notes
#@+node:ekr.20070308062440.1:Posting 2
On 2/26/07, Edward Ream <edreamleo@charter.net> wrote:

> threads will swap after sys.getcheckinterval() bytecodes have been
> processed for that thread.

Many thanks for this detailed summary.  I think this is the guarantee I need
a) to experiment with threads and b) to fiddle with settings should that 
appear to be necessary.

Just be careful.  Test your assumptions before you rely on them, especially regarding threads.  Generally threading is seen as a "hard" problem.  If you want to help make them easier, use Queues to handle inter-thread communication. 


> you can use a technique known as 'cooperative multithreading with 
> generators'.

Googling this leads directly to an entry in the Python Cookbook.  The site
is down at present.  I'll study this entry when it's back up.

The basic idea is to have each task be a generator, with each generator giving up control after some amount of work.  Here's a variant of the recipe in the cookbook... 

 - Josiah

import collections

tasks = collections.deque()

def busy():
    while 1:
        yield None

def delay(v):
    import time
    while 1:
        time.sleep(v)
        yield None 

def xpasses(x):
    while x > 0:
        x -= 1
        yield None

def runtasks():
    while 1:
        task = tasks.popleft()
        try:
            task.next()
        except StopIteration: 
            pass
        else:
            tasks.append(task)
#@nonl
#@-node:ekr.20070308062440.1:Posting 2
#@-node:ekr.20070308062440:Thread notes
#@+node:ekr.20031218072017.434:Unused code
@ignore
@language python
@color
#@nonl
#@+node:ekr.20070317085508:Not used from chapters.py
if 0:
    @others
#@nonl
#@+node:ekr.20070320090557:From tabController
#@+node:ekr.20070317085437.81:tt.renumber
# def renumber (self):
    
    # '''Renumber all numbered chapters.'''
    
    # nb = self.nb
        
    # i = 0
    # for name in nb.pagenames():
        # if name.isdigit():
            # i += 1
            # b = nb.tab(name) # A Tk.button.
            # b.configure(text=str(i))
#@nonl
#@-node:ekr.20070317085437.81:tt.renumber
#@-node:ekr.20070320090557:From tabController
#@+node:ekr.20070317085608:From chapterController
#@+node:ekr.20070317085437.3:Create widgets
#@+node:ekr.20070317085437.4:constructTree
def constructTree (self,frame,pageName):
    
    # g.trace(pageName)

    cc = self ; c = self.c ; nb = self.nb
    canvas = treeBar = tree = None
    if frame.canvas:
        canvas = frame.canvas
        treeBar = frame.treeBar
        tree = frame.tree
    
    frame.canvas = canvas = frame.createCanvas(parentFrame=None,pageName=pageName)
    frame.tree = leoTkinterTree.leoTkinterTree(frame.c,frame,frame.canvas)
    frame.tree.setColorFromConfig()

    return tree, cc.newPage
#@nonl
#@-node:ekr.20070317085437.4:constructTree
#@+node:ekr.20070317085437.5:createBalloon
def createBalloon (self,tab,sv):

    '''Create a balloon showing the present chapter name for a tab.'''
    
    # g.trace(tab,sv.get())

    balloon = Pmw.Balloon(tab,initwait=100)
    balloon.bind(tab,'')
    hull = balloon.component('hull')
    def blockExpose (event):
        if sv.get() == '':
             hull.withdraw()
    hull.bind('<Expose>',blockExpose,'+')
    balloon._label.configure(textvariable=sv)
#@nonl
#@-node:ekr.20070317085437.5:createBalloon
#@+node:ekr.20070317085437.6:createEditorPane
def createEditorPane (self):
    
    '''Create a new pane with a unique name.'''

    cc = self
    cc.numberOfEditors += 1
    name = str(cc.numberOfEditors)
    pane = self.panedBody.add(name)
    
    # g.trace(pane)
    return pane
#@nonl
#@-node:ekr.20070317085437.6:createEditorPane
#@+node:ekr.20070317085437.7:createNoteBook
def createNoteBook (self,parentFrame):

    '''Construct a NoteBook widget for a frame.'''

    c = self.c
    self.nb = nb = Pmw.NoteBook(parentFrame,borderwidth=1,pagemargin=0)
    hull = nb.component('hull')
    self.makeTabMenu(hull)
    
    def lowerCallback(name,self=self):
        return self.lowerPage(name)
    nb.configure(lowercommand=lowerCallback)
    
    def raiseCallback(name,self=self):
        return self.raisePage(name)
    nb.configure(raisecommand=raiseCallback)

    nb.pack(fill='both',expand=1)
    return nb
#@nonl
#@-node:ekr.20070317085437.7:createNoteBook
#@+node:ekr.20070317085437.8:createPanedWidget
def createPanedWidget (self,parentFrame):

    '''Construct a new panedwidget for a frame.'''

    c = self.c
    self.panedBody = panedBody = Pmw.PanedWidget(parentFrame,orient='horizontal')
    # g.trace('creating',panedBody)
    panedBody.pack(expand=1,fill='both')
#@nonl
#@-node:ekr.20070317085437.8:createPanedWidget
#@+node:ekr.20070317085437.9:createTab
def createTab (self,tabName):
    
    cc = self ; nb = cc.nb

    page = nb.add(tabName) # page is a Tk.Frame.
    button = nb.tab(tabName) # tab is a Tk.Button.

    button.configure(
        background=cc.selectedTabBackgroundColor,
        foreground=cc.selectedTabForegroundColor)
    
    # g.trace(tabName,page,button)
    return page,button
#@nonl
#@-node:ekr.20070317085437.9:createTab
#@-node:ekr.20070317085437.3:Create widgets
#@+node:ekr.20070317085437.10:makeTabMenu & helpers
def makeTabMenu (self,widget):
    
    '''Create a tab menu.'''


    cc = self
    tmenu = Tk.Menu(widget,tearoff=0)
    widget.bind('<Button-3>',lambda event: tmenu.post(event.x_root,event.y_root))
    widget.tmenu = tmenu
    
    # Huh?
    # tmenu.add_command(command=tmenu.unpost)

    cc.createTopLevelMenuItems(tmenu)
    tmenu.add_separator()

    cc.createConvertMenu(tmenu)
    cc.createEditorMenu(tmenu)
    cc.createImportExportMenu(tmenu)
    cc.createIndexMenu(tmenu)
    cc.createNodeMenu(tmenu)
    cc.createTrashMenu(tmenu)
#@nonl
#@+node:ekr.20070317085437.11:createTopLevelMenuItems
def createTopLevelMenuItems (self,tmenu):
    
    cc = self ; tt = self.tt
    tmenu.add_command(label='Add Chapter',command=cc.addChapter)
    
    if 1: # 'Remove This Chapter'
        def removeChapterCallback(event=None,cc=cc):
            return cc.removeChapter(cc.nb.getcurselection())
        tmenu.add_command(label='Remove This Chapter',command=removeChapterCallback)
    else: # Create submenu of all chapters.
        cc.rmenu = rmenu = Tk.Menu(tmenu,tearoff=0)
        rmenu.configure(postcommand=cc.createRemoveChapterMenu)
        tmenu.add_cascade(menu=rmenu,label="Remove This Chapter")

    tmenu.add_command(
        label="Rename This Chapter",
        command=cc.renameChapter)
        
    swapmenu = Tk.Menu(tmenu,tearoff=0)
    tmenu.add_cascade(menu=swapmenu,label='Swap With Chapter')
        
    def swapChaptersCallback  (cc=cc,menu=swapmenu):
        tt.setupChaptersMenu(menu,cc.swapChapters)
    swapmenu.configure(postcommand=swapChaptersCallback)
    
    tmenu.add_command(
        label="Clone Find All",
        command=cc.regexClone)
#@nonl
#@-node:ekr.20070317085437.11:createTopLevelMenuItems
#@+node:ekr.20070317085437.12:createConvertMenu
def createConvertMenu (self,tmenu):

    cc = self ; m = Tk.Menu(tmenu,tearoff=0)
    tmenu.add_cascade(menu=m,label='Convert')

    m.add_command(
        label="Convert Node To Chapter",
        command=cc.makeNodeIntoChapter)
    m.add_command(
        label = "Convert Chapters To Simple Outline",
        command=cc.conversionToSimple)
    m.add_command(
        label = "Convert Top Nodes to Chapters",
        command=cc.convertTopLevelToChapters)
    try:
        import reportlab
        tmenu.add_command(label='Convert To PDF',command=cc.doPDFConversion)
    except Exception:
        pass
        # g.es("no reportlab")
#@nonl
#@-node:ekr.20070317085437.12:createConvertMenu
#@+node:ekr.20070317085437.13:createEditorMenu
def createEditorMenu (self,tmenu):

    cc = self

    m = Tk.Menu(tmenu,tearoff=0)
    tmenu.add_cascade(label="Editor",menu=m)

    m.add_command(label="Add Editor",command=cc.newEditor)
    m.add_command(label="Remove Editor",command=cc.removeEditor)
#@nonl
#@-node:ekr.20070317085437.13:createEditorMenu
#@+node:ekr.20070317085437.14:createImportExportMenu
def createImportExportMenu (self,tmenu):

    cc = self

    m = Tk.Menu(tmenu,tearoff=0)
    tmenu.add_cascade(label='Import/Export',menu=m)

    m.add_command(label="Import Leo File To Chapter",command=cc.importLeoFile)
    m.add_command(label="Export Chapter to Leo File",command=cc.exportLeoFile)
#@nonl
#@-node:ekr.20070317085437.14:createImportExportMenu
#@+node:ekr.20070317085437.15:createIndexMenu
def createIndexMenu (self,tmenu):

    cc = self

    m = Tk.Menu(tmenu,tearoff=0)
    tmenu.add_cascade(label='Index',menu=m)

    m.add_command(label='Make Index',command=cc.viewIndex)
    m.add_command(label='Make Regex Index',command=cc.regexViewIndex)
#@-node:ekr.20070317085437.15:createIndexMenu
#@+node:ekr.20070317085437.16:createNodeMenu
def createNodeMenu (self,tmenu):

    cc = self
    opmenu = Tk.Menu(tmenu,tearoff=0)
    tmenu.add_cascade(menu=opmenu,label='Node')
    
    cmenu = Tk.Menu(opmenu,tearoff=0)
    movmenu = Tk.Menu(opmenu,tearoff=0)
    copymenu = Tk.Menu(opmenu,tearoff=0)
    searchmenu = Tk.Menu(opmenu,tearoff=0)
    
    opmenu.add_cascade(menu=cmenu,label='Clone To Chapter')
    opmenu.add_cascade(menu=movmenu,label='Move To Chapter')
    opmenu.add_cascade(menu=copymenu,label='Copy To Chapter')

    def cloneToChapterCallback (cc=cc,menu=cmenu):
        cc.setupMenu(menu,cc.cloneToChapter)
    cmenu.configure(postcommand=cloneToChapterCallback)

    def moveToChapterCallback(cc=cc,menu=movmenu):
        cc.setupMenu(menu,cc.moveToChapter)
    movmenu.configure(postcommand=moveToChapterCallback)
    
    def copyToChapterCallback(cc=cc,menu=copymenu):
        cc.setupMenu(menu,cc.copyToChapter)
    copymenu.configure(postcommand=copyToChapterCallback)
#@nonl
#@-node:ekr.20070317085437.16:createNodeMenu
#@+node:ekr.20070317085437.17:createTrashMenu
def createTrashMenu (self,tmenu):

    cc = self

    m = Tk.Menu(tmenu,tearoff=0)
    tmenu.add_cascade(menu=m,label='Trash')
    
    m.add_command(label="Add Trash Barrel",command=cc.addTrashBarrel)
    m.add_command(label='Empty Trash Barrel',command=cc.emptyTrash)
#@nonl
#@-node:ekr.20070317085437.17:createTrashMenu
#@+node:ekr.20070317085437.18:setupMenu
def setupMenu (self,menu,command,all=False):

    '''Create a menu.'''
    
    cc = self ; nb = cc.nb

    menu.delete(0,'end')
    current = nb.getcurselection()

    i = 0
    for name in nb.pagenames():
        i = i + 1
        if name == current and not all: continue
        menu.add_command(
            label=str(i),command=lambda name=name: command(name))
#@nonl
#@-node:ekr.20070317085437.18:setupMenu
#@-node:ekr.20070317085437.10:makeTabMenu & helpers
#@+node:ekr.20070317085437.55:Editor
#@+node:ekr.20070317085437.56:...Heading
#@+node:ekr.20070317085437.57:addHeading
def addHeading (self,parentFrame):
    '''Create a two-part editor label.
    - The left label tracks the chapter name using a chapter.sv.
    - The right label is the node's healine.'''
    
    cc = self
    f = Tk.Frame(parentFrame) ; f.pack(side='top')
    lt_label = Tk.Label(f)    ; lt_label.pack(side='left')
    rt_label = Tk.Label(f)    ; rt_label.pack(side='right')
    
    # The lt_label tracks the present chapter name.
    # chapter.updateHeadingSV changes this textvariable when chapters change.
    chapter = cc.getChapter()
    lt_label.configure(textvariable=chapter.sv)
    
    for w in (lt_label,rt_label,f,parentFrame):
        w.configure(bg=cc.editorLabelBackgroundColor)
    for w in (lt_label,rt_label):
         w.configure(fg=cc.editorLabelForegroundColor)

    return lt_label, rt_label, f
#@nonl
#@-node:ekr.20070317085437.57:addHeading
#@+node:ekr.20070317085437.58:hide/showHeading
def showHeading (self,body):
    if 0:
        body.editorLeftLabel.pack(side='left')
        body.editorRightLabel.pack(side='right')

def hideHeading (self,body):
    if 0:
        # If we unpack the frame we won't be able to repack it easily.
        # Setting the height to zero also does not seem to work.
        body.editorLabel.pack_forget()
#@nonl
#@-node:ekr.20070317085437.58:hide/showHeading
#@-node:ekr.20070317085437.56:...Heading
#@+node:ekr.20070317085437.59:activateEditor
def activateEditor (self,body):

    '''Activate an editor.'''

    p = body.lastPosition
    h = p and p.headString() or ''
    body.editorRightLabel.configure(text=h)
    ip = body.lastPosition.t.insertSpot
    body.deleteAllText()
    body.insertAtEnd(p.bodyString())
    if ip: body.setInsertionPoint(ip)
    body.colorizer.colorize(p)
    # g.trace(id(body.bodyCtrl),p.headString())
#@nonl
#@-node:ekr.20070317085437.59:activateEditor
#@+node:ekr.20070317085437.60:newEditor
def newEditor (self):

    cc = self ; c = cc.c
    
    pane = self.createEditorPane()
    body = leoTkinterBody(self.frame,pane)
    c.frame.bodyCtrl = body.bodyCtrl # Make body the 'official' body.
    body.setFontFromConfig()
    body.setColorFromConfig()
    body.createBindings()
    c.k.completeAllBindingsForWidget(body.bodyCtrl)
    body.bodyCtrl.focus_set()
    body.lastPosition = c.currentPosition()
    cc.activateEditor(body)

    # Configure the generic editor label for this chapter and position.
    chapter = cc.getChapter()
    body.editorLeftLabel.configure(textvariable=chapter.sv)
    body.editorRightLabel.configure(text=c.currentPosition().headString())
#@nonl
#@-node:ekr.20070317085437.60:newEditor
#@+node:ekr.20070317085437.61:removeEditor
def removeEditor (self):
    
    cc = self ; c = cc.c
    panedBody = cc.panedBody
    panes = panedBody.panes()
    if not panes: return
    
    pane = panes[0]
    frame = panedBody.pane(pane)
    panedBody.delete(pane)
    panedBody.updatelayout()
    del cc.editorBodies[frame]
    
    # Hide the label if there is only one editor left.
    if len(cc.editorBodies.keys())==1:
        panes = panedBody.panes()
        frame = panedBody.pane(panes[0])
        body = cc.editorBodies.get(frame)
        cc.hideHeading(body)
#@nonl
#@-node:ekr.20070317085437.61:removeEditor
#@-node:ekr.20070317085437.55:Editor
#@+node:ekr.20070317085437.69:Overrides
#@+node:ekr.20070317085437.70:createCanvas (injects ivars for treeInit)
def createCanvas (self,frame,parentFrame,pageName):
    
    cc = self
            
    # Set ivars for cc.treeInit.
    page,button = cc.createTab(pageName)
    cc.newPageName = pageName
    cc.newPage = page

    # Create the canvas with page as the parentFrame.
    cc.newCanvas = canvas = old_createCanvas(frame,page) 

    # g.trace(pageName,id(canvas))
    return canvas
#@nonl
#@-node:ekr.20070317085437.70:createCanvas (injects ivars for treeInit)
#@+node:ekr.20070317085437.71:createControl (tkBody)
def createControl(self,body,frame,parentFrame):
    
    '''Override for tkBody.createControl.
    
    This called for the 'main' body and once for each added editor. '''

    cc = self ; c = cc.c ; nb = cc.nb
    # assert(body == frame.body)
    
    if self.panedBody:
        pane = parentFrame
    else:
        self.createPanedWidget(parentFrame)
        pane = self.createEditorPane()
    panedBody = self.panedBody
    
    # **Important**: addHeading creates a heading that works for *all* chapters.
    lt_label,rt_label,label_frame = cc.addHeading(pane)

    # Inject editor ivars into the leoTkinterBody.
    body.editorRightLabel = rt_label
    body.editorLeftLabel =  lt_label
    body.editorLabelFrame = label_frame

    ctrl = old_createControl(body,frame,pane)
    
    # Create a focus-in event to keep the generic label widget in synch.
    def focusInCallback(event,self=self,frame=frame):
        return self.onFocusIn(event,body,ctrl)
    ctrl.bind("<FocusIn>",focusInCallback,'+')
    
    i = 1.0 / len(panedBody.panes())
    for z in panedBody.panes():
        panedBody.configurepane(z,size=i)
    panedBody.updatelayout()
    
    cc.editorBodies [pane] = body

    if len(panedBody.panes()) > 1:
        # Show the labels of all frames.
        for pane in cc.editorBodies.keys():
            body = cc.editorBodies.get(pane)
            cc.showHeading(body)

    return ctrl
#@nonl
#@-node:ekr.20070317085437.71:createControl (tkBody)
#@+node:ekr.20070317085437.72:doDelete
def doDelete (self,p):
    
    '''Override p.doDelete to add nodes to the trash if it exists.'''
    
    cc = self ; c = cc.c ; nb = cc.nb ;  trash = 'Trash'
    
    # Do nothing if the node can't be deleted.
    newNode = p and (p.visBack() or p.next()) # *not* p.visNext()
    if not newNode: return
    
    name = nb.getcurselection()
    if name != trash and trash in nb.pagenames():
        chapter = self.getChapter(trash)
        trashnode = chapter.rp
        chapter.setVariables()
        p.moveAfter(trashnode)
        cc.currentChapter.setVariables()
        c.selectPosition(newNode)
        return p
    else:
        return old_doDelete(p)
#@nonl
#@-node:ekr.20070317085437.72:doDelete
#@+node:ekr.20070317085437.73:getLeoFile
def getLeoFile (self,fc,fileName,readAtFileNodesFlag=True,silent=False):
    
    global iscStringIO # For communication with g.os_path_dirname

    if iscStringIO:
        def dontSetReadOnly (self,name,value):
            if name not in ('read_only','tnodesDict'):
                self.__dict__ [name] = value

        self.read_only = False
        self.__class__.__setattr__ = dontSetReadOnly

    rt = old_getLeoFile(fc,fileName,readAtFileNodesFlag,silent)

    if iscStringIO:
        del self.__class__.__setattr__

    return rt
#@nonl
#@-node:ekr.20070317085437.73:getLeoFile
#@+node:ekr.20070317085437.74:select
def select (self,tree,p,updateBeadList=True):

    cc = self ; c = p.v.c ; h = p.headString() ; nb = cc.nb

    c.frame.body.lastPosition = p.copy()
    return_val = old_select(tree,p,updateBeadList)

    c.frame.body.lastChapter = n = nb.getcurselection()
    chapter = cc.getChapter(n)
    chapter._saveInfo()

    if hasattr(p.c.frame.body,'editorRightLabel'):
        h = p.headString() or ''
        c.frame.body.editorRightLabel.configure(text=h)

    return return_val
#@nonl
#@-node:ekr.20070317085437.74:select
#@+node:ekr.20070317085437.75:open
def open (self,fc,file,fileName,readAtFileNodesFlag=True,silent=False):

    cc = self ; c = cc.c

    if zipfile.is_zipfile(fileName):
        c.beginUpdate()
        try:
            # Set globals for g.os_path_dirname
            global iscStringIO, stringIOCommander
            iscStringIO = True ; stringIOCommander = c
            chapters = cc.openChaptersFile(fileName)
            g.es(str(len(chapters))+" Chapters To Read",color='blue')
            cc.insertChapters(chapters)
            g.es("Finished Reading Chapters",color='blue')
            iscStringIO = False
        finally:
            c.endUpdate()
        return True
    else:
        return old_open(fc,file,fileName,readAtFileNodesFlag,silent)
#@nonl
#@-node:ekr.20070317085437.75:open
#@+node:ekr.20070317085437.76:treeInit (creates Chapter)
def treeInit (self,tree,c,frame,canvas):
    
    cc = self
    
    assert canvas == cc.newCanvas
    
    # These ivars are set in cc.createCanvas.
    pageName = cc.newPageName
    page = cc.newPage
    canvas = cc.newCanvas
    
    old_tree_init(tree,c,frame,canvas)
    cc.chapters [pageName] = chapter(cc,c,tree,frame,canvas,page,pageName)
    
    # g.trace(pageName,id(canvas),cc.chapters.keys())
#@-node:ekr.20070317085437.76:treeInit (creates Chapter)
#@+node:ekr.20070317085437.77:write_Leo_file
def write_Leo_file (self,fc,fileName,outlineOnlyFlag,singleChapter=False):

    cc = self ; c = cc.c ; nb = cc.nb ; pagenames = nb.pagenames()

    if len(pagenames) > 1 and not singleChapter:
        rv,chapterList = cc.writeChapters(fc,fileName,pagenames,outlineOnlyFlag)
        if rv: cc.zipChapters(fileName,pagenames,chapterList)
        return rv
    else:
        global old_write_Leo_file
        return old_write_Leo_file(fc,fileName,outlineOnlyFlag)
#@nonl
#@-node:ekr.20070317085437.77:write_Leo_file
#@-node:ekr.20070317085437.69:Overrides
#@+node:ekr.20070317125913.1:Commands
#@+node:ekr.20070317085437.34:doPDFConversion & helper
# Requires reportlab toolkit at http://www.reportlab.org

def doPDFConversion (self,event=None):
    cc = self ; c = cc.c ; nb = cc.nb
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
    from reportlab.lib.styles import getSampleStyleSheet
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    PAGE_HEIGHT = defaultPageSize [1]
    PAGE_WIDTH = defaultPageSize [0]
    maxlen = 100
    styles = getSampleStyleSheet()
    pinfo = c.frame.shortFileName()
    pinfo1 = pinfo.rstrip('.leo')
    cs = cStringIO.StringIO()
    doc = SimpleDocTemplate(cs,showBoundary=1)
    Story = [Spacer(1,2*inch)]
    pagenames = nb.pagenames()
    cChapter = cc.currentChapter
    n = 0
    for z in pagenames:
        chapter = self.getChapter(z)
        chapter.setVariables()
        p = chapter.rp
        if p:
            self._changeTreeToPDF(chapter.sv.get(),n,p,c,Story,styles,maxlen)
        n += 1
    << define otherPages callback >>
    cChapter.setVariables()
        # This sets the nodes back to the cChapter.
        # If we didnt the makeCurrent would point to the wrong positions
    cChapter.makeCurrent()
    doc.build(Story,onLaterPages=otherPages)
    f = open('%s.pdf' % pinfo1,'w')
    cs.seek(0)
    f.write(cs.read())
    f.close()
    cs.close()
#@nonl
#@+node:ekr.20070317085437.35:<< define otherPages callback >>
def otherPages (canvas,doc,pageinfo=pinfo):

    canvas.saveState()
    canvas.setFont('Times-Roman',9)
    canvas.drawString(inch,0.75*inch,"Page %d %s" % (doc.page,pageinfo))
    canvas.restoreState()
#@nonl
#@-node:ekr.20070317085437.35:<< define otherPages callback >>
#@+node:ekr.20070317085437.36:_changeTreeToPDF
def _changeTreeToPDF (self,name,num,p,Story,styles,maxlen):
    
    c = self.c ; nb = self.nb
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak, XPreformatted
    from reportlab.lib.units import inch
    from reportlab.rl_config import defaultPageSize
    enc = c.importCommands.encoding
    hstyle = styles ['title']
    Story.append(Paragraph('Chapter %s: %s' % (num,name),hstyle))
    style = styles ['Normal']
    for p in p.allNodes_iter():
        head = p.moreHead(0)
        head = g.toEncodedString(head,enc,reportErrors=True)
        s = head + '\n'
        body = p2.moreBody() # Inserts escapes.
        if len(body) > 0:
            body = g.toEncodedString(body,enc,reportErrors=True)
            s = s + body
            s = s.split('\n')
            s2 = []
            for z in s:
                if len(z) < maxlen:
                    s2.append(z)
                else:
                    while 1:
                        s2.append(z[: maxlen])
                        if len(z[maxlen:]) > maxlen:
                            z = z [maxlen:]
                        else:
                            s2.append(z[maxlen:])
                            break
            s = '\n'.join(s2)
            s = s.replace('&','&amp;')
            s = s.replace('<','&lt;')
            s = s.replace('>','&gt;')
            s = s.replace('"','&quot;')
            s = s.replace("`",'&apos;')
            Story.append(XPreformatted(s,style))
            Story.append(Spacer(1,0.2*inch))

    Story.append(PageBreak())
#@nonl
#@-node:ekr.20070317085437.36:_changeTreeToPDF
#@-node:ekr.20070317085437.34:doPDFConversion & helper
#@+node:ekr.20070317085437.32:convertTopLevelToChapters
def convertTopLevelToChapters (self):
    
    cc = self ; c = cc.c

    # It's more intuitive to leave the root position where it is.
    p = c.rootPosition().next()
    
    # Dont' use an iterator here! makeNodeIntoChapter deletes nodes.
    while p:
        next = p.next()
        # g.trace(p.headString())
        self.makeNodeIntoChapter(p=p,redraw=False)
        p = next

    cc.setTree(cc.nb.pagenames()[0])
    c.redraw_now()
#@nonl
#@-node:ekr.20070317085437.32:convertTopLevelToChapters
#@+node:ekr.20070317085437.33:conversionToSimple
def conversionToSimple (self):
    
    cc = self ; c = cc.c ; nb = cc.nb
    
    # Set last to the last top-level node.
    for p in c.rootPosition().self_and_siblings_iter():
        last = p.copy()

    pagenames = nb.pagenames()
    current = nb.getcurselection()
    pagenames.remove(current)
   
    for pageName in pagenames:
        chapter = self.getChapter(pageName)
        # We can't use an iterator here because we are moving nodes.
        p = chapter.rp
        while p:
            next = p.next()
            p.moveAfter(last)
            last = p.copy() ; p = next
        nb.delete(pageName)
    
    nb.selectpage(current)
    c.redraw_now()
#@nonl
#@-node:ekr.20070317085437.33:conversionToSimple
#@+node:ekr.20070317085437.37:exportLeoFile
def exportLeoFile (self,event=None):

    c = self.c

    name = tkFileDialog.asksaveasfilename()

    if name:
        if not name.endswith('.leo'): name = name + '.leo'
        c.fileCommands.write_Leo_file(name,False,singleChapter=True)
#@nonl
#@-node:ekr.20070317085437.37:exportLeoFile
#@+node:ekr.20070317085437.38:importLeoFile
def importLeoFile (self,event=None):
    
    cc = self ; c = cc.c ; nb = cc.nb

    fileName = tkFileDialog.askopenfilename()

    if fileName:
        cc.addPage()
        c.fileCommands.open(file(fileName,'r'),fileName)
        cc.currentChapter.makeCurrent()
#@-node:ekr.20070317085437.38:importLeoFile
#@+node:ekr.20070317085437.42:swapChapters
def swapChapters (self,name):

    cc = self ; c = cc.c ; nb = cc.nb
    cselection = nb.getcurselection()
    tab1 = nb.tab(cselection)
    tab2 = nb.tab(name)
    tval1 = tab1.cget('text')
    tval2 = tab2.cget('text')
    tv1 = cc.getChapter(cselection).sv
    tv2 = cc.getChapter(name).sv
    chap1 = cc.currentChapter
    chap2 = self.getChapter(name)
    rp, tp, cp = chap2.rp, chap2.tp, chap2.cp
    chap2.rp, chap2.tp, chap2.cp = chap1.rp, chap1.tp, chap1.cp
    chap1.rp, chap1.tp, chap1.cp = rp, tp, cp
    chap1.setVariables()
    c.redraw_now()
    val1 = tv1.get()
    val2 = tv2.get()
    if val2.isdigit():
        tv1.set(nb.index(cselection)+1)
    else: tv1.set(val2)
    if val1.isdigit():
        tv2.set(nb.index(name)+1)
    else: tv2.set(val1)
#@nonl
#@-node:ekr.20070317085437.42:swapChapters
#@+node:ekr.20070317085437.43:Indexing
@
Indexing is complementary to find, it provides a gui Index of nodes.

In comparison to regular find which bounces you around the tree,
you can preview the node before you go to it.
#@+node:ekr.20070317085437.44:viewIndex
def viewIndex (self,nodes=None,tle=''):
    c = self.c
    if nodes == None:
        nodes = [x for x in self.walkChapters(chapname=True)]
    nodes = [(a[0].headString(),a[0],a[1]) for a in nodes]
    nodes.sort()
    if 1:
        tl = Tk.Toplevel()
        title = "%s Index of %s created at %s" % (tle,c.frame.shortFileName(),time.ctime())
        tl.title(title)
        f = Tk.Frame(tl)
        f.pack(side='bottom')
        l = Tk.Label(f,text='ScrollTo:')
        e = Tk.Entry(f,bg='white',fg='blue')
        l.pack(side='left')
        e.pack(side='left')
        b = Tk.Button(f,text='Close')
        b.pack(side='left')
        def rm (tl=tl):
            tl.withdraw()
            tl.destroy()
        b.configure(command=rm)
        sve = Tk.StringVar()
        e.configure(textvariable=sve)
        ms = tl.maxsize()
        tl.geometry('%sx%s+0+0' % (ms[0],(ms[1]/4)*3))
        sc = Pmw.ScrolledCanvas(
            tl,vscrollmode='static',hscrollmode='static',
            usehullsize = 1, borderframe = 1, hull_width = ms [0],
            hull_height = (ms[1]/4) * 3)
        sc.pack()
        can = sc.interior()
        can.configure(background='white')
        bal = Pmw.Balloon(can)
        tags = {}
        self.buildIndex(nodes,can,tl,bal,tags)
        sc.resizescrollregion()
        << define scTo callback >>
        e.bind('<Key>',scTo)
        e.focus_set()
#@nonl
#@+node:ekr.20070317085437.45:<< define scTo callback >>
def scTo (event,nodes=nodes,sve=sve,can=can,tags=tags):

    t = sve.get()
    if event.keysym == 'BackSpace':
        t = t [: -1]
    else:
        t = t + event.char
    if t:
        for z in nodes:
            if z [0].startswith(t) and tags.has_key(z[1]):
                tg = tags [z [1]]
                eh = can.bbox(self.ltag) [1]
                eh = (eh*1.0) / 100
                bh = can.bbox(tg) [1]
                ncor = (bh/eh) * .01
                can.yview('moveto',ncor)
                return
#@nonl
#@-node:ekr.20070317085437.45:<< define scTo callback >>
#@-node:ekr.20070317085437.44:viewIndex
#@+node:ekr.20070317085437.46:buildIndex
def buildIndex (self,nodes,can,tl,bal,tags):

    cc = self ; c = cc.c ; nb = cc.nb
    f = tkFont.Font()
    f.configure(size=-20)
    ltag = None
    i = 0
    for z in nodes:
        i += 1
        tg = 'abc' + str(i)
        parent = z [1].parent()
        if parent: parent = parent.headString()
        else: parent = 'No Parent'
        sv = cc.getChapter(z[2]).sv
        if sv.get(): sv = ' - ' + sv.get()
        else: sv = ''
        tab = nb.tab(z[2])
        tv = tab.cget('text')
        isClone = z [1].isCloned()
        if isClone: clone = ' (Clone) '
        else:       clone = ''
        txt = '%s  , parent: %s , chapter: %s%s%s' % (z[0],parent,tv,sv,clone)
        self.ltag = ltag = tags [z [1]] = can.create_text(
            20,i*20+20,text=txt,fill='blue',font=f,anchor=Tk.W,tag=tg)
        bs = z [1].bodyString()
        if bs.strip() != '':
            bal.tagbind(can,tg,bs)
        << def callbacks >>
        can.tag_bind(tg,'<Button-1>',goto)
        can.tag_bind(tg,'<Enter>',colorRd,'+')
        can.tag_bind(tg,'<Leave>',colorBl,'+')
#@nonl
#@+node:ekr.20070317085437.47:<< def callbacks >>
def goto (event,self=self,z=z,tl=tl):
    c = self.c ; nb = self.nb
    nb.selectpage(z[2])
    c.selectPosition(z[1])
    c.frame.outerFrame.update_idletasks()
    c.frame.outerFrame.event_generate('<Button-1>')
    c.frame.bringToFront()
    return 'break'

def colorRd (event,tg=ltag,can=can):
    can.itemconfig(tg,fill='red')

def colorBl (event,tg=ltag,can=can):
    can.itemconfig(tg,fill='blue')
#@nonl
#@-node:ekr.20070317085437.47:<< def callbacks >>
#@-node:ekr.20070317085437.46:buildIndex
#@+node:ekr.20070317085437.48:regexViewIndex
def regexViewIndex (self):
    
    c = self.c ; nb = self.nb

    def regexWalk (result,entry,widget):
        txt = entry.get()
        widget.deactivate()
        widget.destroy()
        if result == 'Cancel': return None
        nodes = [x for x in self.walkChapters(chapname=True)]
        import re
        regex = re.compile(txt)
        def search (nd,regex=regex):
            return regex.search(nd[0].bodyString())
        nodes = filter(search,nodes)
        self.viewIndex(nodes,'Regex( %s )' % txt)
        return

    sd = Pmw.PromptDialog(c.frame.top,
        title = 'Regex Index',
        buttons = ('Search','Cancel'),
        command = regexWalk,
    )
    entry = sd.component('entry')
    sd.configure(command=
        lambda result, entry = entry, widget = sd:
            regexWalk(result,entry,widget))
    sd.activate(geometry='centerscreenalways')
#@nonl
#@-node:ekr.20070317085437.48:regexViewIndex
#@-node:ekr.20070317085437.43:Indexing
#@+node:ekr.20070317085437.53:regexClone & helper (replace by clone-find-all)
def regexClone (self,name=None):

    cc = self ; c = cc.c ; nb = cc.nb

    chapter = self.getChapter(name)

    d = Pmw.PromptDialog(c.frame.top,
        title = 'Search and Clone',
        buttons = ('Search','Cancel'),
        defaultbutton = 'Search',
    )
    e = d.component('entry')
    e.bind

    def regexCloneCallback (result,cc=cc,e=e,d=d,chapter=chapter):
        s = e.get() # Do this before destroying d.d
        d.deactivate() ; d.destroy()
        if result != 'Cancel':
            cc.cloneWalk(chapter,s)

    d.configure(command=regexCloneCallback)
    d.activate(geometry='centerscreenalways')
#@+node:ekr.20070317085437.54:cloneWalk
def cloneWalk (self,chapter,s):
    cc = self ; c = cc.c ; nb = cc.nb
    regex = re.compile(s)
    root = chapter.cp
    chapter.setVariables()
    t = leoNodes.tnode('',s)
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    p.moveAfter(root)
    ignorelist = [p.v.t]
    it = self.walkChapters(ignorelist=ignorelist)
    for z in it:
        f = regex.search(z.bodyString())
        if f:
            clone = z.clone(z)
            i = p.numberOfChildren()
            clone.moveToNthChildOf(p,i)
            ignorelist.append(clone.v.t)
    cc.currentChapter.setVariables()
    nb.selectpage(chapter.pageName)
    c.beginUpdate()
    try:
        p.moveToRoot(root)
        c.setChanged(True)
        c.selectPosition(p)
        p.expand()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20070317085437.54:cloneWalk
#@-node:ekr.20070317085437.53:regexClone & helper (replace by clone-find-all)
#@-node:ekr.20070317125913.1:Commands
#@+node:ekr.20070317085437.62:Files
@ We need to decorate and be tricky here, since a Chapters leo file is a zip file.

These functions are easy to break in my experience. :)
#@nonl
#@+node:ekr.20070317085437.63:Reading
#@+node:ekr.20070317085437.64:openChaptersFile
def openChaptersFile (self,fileName):

    zf = zipfile.ZipFile(fileName)
    file = cStringIO.StringIO()
    name = zf.namelist()
    csfiles = [[], []]
    for x in name:
        zi = zf.getinfo(x)
        csfiles [0].append(zi.comment)
        cs = cStringIO.StringIO()
        csfiles [1].append(cs)
        cs.write(zf.read(x))
        cs.seek(0)
    zf.close()
    csfiles = zip(csfiles[0],csfiles[1])
    return csfiles

#@-node:ekr.20070317085437.64:openChaptersFile
#@+node:ekr.20070317085437.65:insertChapters
def insertChapters (self,chapters):

    cc = self ; c = cc.c ; nb = cc.nb ; pagenames = nb.pagenames()
    flipto = None
    c.beginUpdate()
    try:
        i = 0
        for tup in chapters:
            x, y = tup
            if i > 0:
                page,pageName = self.addPage(x)
                sv = cc.getChapter(pageName).sv
                nb.nextpage()
                cselection = nb.getcurselection()
            else:
                cselection = nb.getcurselection()
                sv = cc.getChapter(cselection).sv
            sv.set(x)
            next = cselection
            self.setTree(next)
            c.fileCommands.open(y,sv.get())
            if i == 0: flipto = cselection
            i += 1
        self.setTree(flipto)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20070317085437.65:insertChapters
#@-node:ekr.20070317085437.63:Reading
#@+node:ekr.20070317085437.66:Writing
#@+node:ekr.20070317085437.67:writeChapters
def writeChapters (self,fc,fileName,pagenames,outlineOnlyFlag):

    '''Writes Chapters to StringIO instances.'''
    
    cc = self ; chapterList = []
    global old_write_Leo_file

    for z in pagenames:
        chapter = self.getChapter(z)
        chapter.setVariables()
        rv = old_write_Leo_file(fc,fileName,outlineOnlyFlag,toString=True)
        chapterList.append(g.app.write_Leo_file_string)
        # g.trace(len(g.app.write_Leo_file_string))

    cc.currentChapter.setVariables()
    return rv,chapterList
#@nonl
#@-node:ekr.20070317085437.67:writeChapters
#@+node:ekr.20070317085437.68:zipChapters
def zipChapters (self,fileName,pagenames,chapList):

    '''Writes StringIO instances to a zipped file.'''
    
    cc = self

    zf = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)

    i = 0
    for pageName in pagenames:
        sv = cc.getChapter(pageName).sv
        zif = zipfile.ZipInfo(str(i))
        zif.comment = sv.get() or ''
        zif.compress_type = zipfile.ZIP_DEFLATED
        zf.writestr(zif,chapList[i])
        i += 1

    zf.close()
#@nonl
#@-node:ekr.20070317085437.68:zipChapters
#@-node:ekr.20070317085437.66:Writing
#@-node:ekr.20070317085437.62:Files
#@+node:ekr.20070317085437.78:Utils
#@+node:ekr.20070317085437.79:addPage
def addPage (self,pageName=None):

    cc = self ; c = cc.c
    if not pageName:
        pageName = str(len(cc.nb.pagenames()) + 1)
    
    # g.trace(pageName,cc.chapters.keys())
    
    old_chapter = cc.currentChapter
    junk, page = cc.constructTree(self.frame,pageName)
        # Creates a canvas, new tab and a new tree.

    old_chapter.makeCurrent() # Essential to capture the present values.
    chapter = cc.getChapter(cc.newPageName)
    chapter.makeCurrent()
    return page,pageName
#@nonl
#@-node:ekr.20070317085437.79:addPage
#@+node:ekr.20070317085437.80:getChapter
def getChapter (self,pageName=None):
    
    cc = self

    return self.chapters.get(pageName or cc.nb.getcurselection())
#@nonl
#@-node:ekr.20070317085437.80:getChapter
#@+node:ekr.20070317085437.82:walkChapters
def walkChapters (self,ignorelist=[],chapname=False):

    '''A generator that allows one to walk the chapters as one big tree.'''

    for z in self.nb.pagenames():
        chapter = self.getChapter(z)
        for p in chapter.rp.allNodes_iter():
            if chapname:
                if p not in ignorelist: yield p.copy(), z
            else:
                if p.v.t not in ignorelist: yield p.copy()
#@nonl
#@-node:ekr.20070317085437.82:walkChapters
#@-node:ekr.20070317085437.78:Utils
#@-node:ekr.20070317085608:From chapterController
#@+node:ekr.20070317131205:From chapter
#@+node:ekr.20070317085708.5:_saveInfo
def _saveInfo (self):

    c = self.c
    self.cp = c._currentPosition and c._currentPosition.copy() or c.nullPosition()
    self.rp = c._rootPosition and c._rootPosition.copy() or c.nullPosition()
    self.tp = c._topPosition and c._topPosition.copy() or c.nullPosition()
    
    # g.trace(self.cp)
#@nonl
#@-node:ekr.20070317085708.5:_saveInfo
#@+node:ekr.20070317085708.4:initTree
def initTree (self):
    
    '''Initialize the tree for this chapter.'''
    
    cc = self.cc ; c = cc.c
    
    if cc.currentChapter:
        # g.trace()
        # We are creating a *second* or following chapter.
        t = leoNodes.tnode('','New Headline')
        v = leoNodes.vnode(c,t)
        # v.linkAsRoot(oldRoot=None)
        p = leoNodes.position(c,v,[])
        self.cp = p.copy()
        self.rp = p.copy()
        self.tp = p.copy()
    else:
        cc.currentChapter = self
        self.cp = c._currentPosition and c._currentPosition.copy() or c.nullPosition()
        self.tp = c._topPosition and c._topPosition.copy() or c.nullPosition()
        self.rp = c._rootPosition and c._rootPosition.copy() or c.nullPosition()
#@nonl
#@-node:ekr.20070317085708.4:initTree
#@+node:ekr.20070317085708.3:init
def init (self):
    
    '''Complete the initialization of a chapter
    by creating bindings and injecting ivars.
    
    Doing this here greatly simplifies the init logic.'''

    c = self.c ; cc = self.cc ; nb = cc.nb
    pageName = self.pageName ; page = self.page
    
    hull = nb.component('hull')
    tab = nb.tab(pageName)
    tab.bind('<Button-3>',lambda event,hull=hull: hull.tmenu.post(event.x_root,event.y_root))
    cc.createBalloon(tab,self.sv)
 
    # The keyhandler won't be defined for the first chapter,
    # but that's ok: we only need to do this for later chapters.
    if c.k:
        # Same logic as in k.completeAllBindings, but for the new tree.
        c.k and self.tree.setBindings()
        for w in (self.canvas,self.tree.bindingWidget):
            c.k.completeAllBindingsForWidget(w)
#@nonl
#@-node:ekr.20070317085708.3:init
#@+node:ekr.20070317085708.6:setVariables
def setVariables (self):
    
    '''Switch variables in Leo's core to represent this chapter.'''

    c = self.c

    # g.trace(self.pageName,'canvas:',id(self.canvas),self.cp.headString())

    frame = self.frame
    frame.tree = self.tree
    frame.canvas = self.canvas
    frame.treeBar = self.treeBar

    c._currentPosition = self.cp and self.cp.copy() or c.nullPosition()
    c._rootPosition    = self.rp and self.rp.copy() or c.nullPosition()
    c._topPosition     = self.tp and self.tp.copy() or c.nullPosition()
    
    # g.trace(self.cp)
#@nonl
#@-node:ekr.20070317085708.6:setVariables
#@+node:ekr.20070317085708.7:makeCurrent
def makeCurrent (self):

    c = self.c ; cc = self.cc
    
    # g.trace(self.pageName)
    cc.nb.selectpage(self.pageName)
    cc.currentChapter._saveInfo()
    cc.currentChapter = self
    self.setVariables()
    self.updateHeadingSV(self.sv)
    self.rp.v.linkAsRoot(oldRoot=self.rp.v._next)
    c.redraw()
    c.bodyWantsFocusNow()
#@nonl
#@-node:ekr.20070317085708.7:makeCurrent
#@+node:ekr.20070317085708.8:updateHeadingSV
def updateHeadingSV (self,sv):
    
    body = self.c.frame.body
    
    if hasattr(body,'editorLeftLabel'):
        # g.trace(self)
        body.editorLeftLabel.configure(textvariable=sv)
#@nonl
#@-node:ekr.20070317085708.8:updateHeadingSV
#@+node:ekr.20070317085437.28:addTrashBarrel
# def addTrashBarrel (self,event=None):
    
    # self.selectChapter('trash')

    # c = self.c ; trash = 'Trash'
    
    # if self.getChapter(trash):
        # return

    # self.addPage(trash)
    # chapter = self.getChapter(trash)
    # chapter.sv.set(trash)
    # chapter.rp.setHeadString(trash+' barrel')
#@-node:ekr.20070317085437.28:addTrashBarrel
#@+node:ekr.20070317075059.5:cc.raisePage
def raisePage (self,name):
    
    tt = self ; c = tt.c ; tab = tt.nb.tab(name)

    tab.configure(
        background=tt.selectedTabBackgroundColor,
        foreground=tt.selectedTabForegroundColor)
    
    # This must be called before queuing up the callback.
    self.setTree(name)
    
    # This can not be called immediately
    def idleCallback(event=None,c=c):
        c.invalidateFocus()
        c.bodyWantsFocusNow()
        
    w = c.frame.body and c.frame.body.bodyCtrl
    w and w.after_idle(idleCallback)
#@-node:ekr.20070317075059.5:cc.raisePage
#@-node:ekr.20070317131205:From chapter
#@-node:ekr.20070317085508:Not used from chapters.py
#@+node:ekr.20070325155208.2:Not used from chapter
#@+node:ekr.20070317075059.2:chapter.onFocusIn & helpers (NOT USED)
def onFocusIn (self,event,body,bodyCtrl):

    '''Set the focus to the proper body and bodyCtrl.'''

    tt = self ; c = tt.c ; nb = tt.nb

    # g.trace(event,id(body),id(bodyCtrl))

    changeCtrl = body.frame.bodyCtrl != bodyCtrl

    # Switch the injected ivars.
    body.frame.body = body
    body.frame.bodyCtrl = body.bodyCtrl

    if not hasattr(body,'lastChapter'):
        body.lastChapter = nb.getcurselection()

    # Select body.lastChapter if it exists, or the present chapter otherwise.
    pageName = tt.getValidChapterName(body.lastChapter)
    changePage = pageName != nb.getcurselection()
    if changePage:
        body.lastChapter = pageName
        nb.selectpage(pageName)

    tt.selectNodeForEditor(body)
    if changePage or changeCtrl:
        # Do this only if necessary: it interferes with the Find command.
        tt.activateEditor(body)
#@nonl
#@+node:ekr.20070317075059.3:getValidChapterName
def getValidChapterName (self,name):

    '''Return name if its chapter still exists.
    Otherwise return the name of the presently selected tab.'''

    tt = self ; nb = tt.nb

    try:
        nb.index(name)
    except:
        name = nb.getcurselection()

    # g.trace(name)
    return name
#@nonl
#@-node:ekr.20070317075059.3:getValidChapterName
#@+node:ekr.20070317075059.4:selectNodeForEditor
def selectNodeForEditor (self,body):

    '''Select the next node for the editor.'''

    tt = self ; c = tt.c

    if not hasattr(body,'lastPosition'):
        body.lastPosition = c.currentPosition()

    if body.lastPosition == c.currentPosition():
        pass
    elif body.lastPosition.exists(c):
        c.selectPosition(body.lastPosition)
    else:
        g.trace('last position does not exist',color='red')
        c.selectPosition(c.rootPosition())

    body.lastPosition = c.currentPosition()
    # g.trace(body.lastPosition.headString())
#@nonl
#@-node:ekr.20070317075059.4:selectNodeForEditor
#@-node:ekr.20070317075059.2:chapter.onFocusIn & helpers (NOT USED)
#@+node:ekr.20070317075059.6:chapter.setTree (NOT USED )
def setTree (self,name):

    tt = self ; c = tt.c
    chapter = self.getChapter(name)
    sv = chapter and chapter.sv

    # g.trace(name,g.callers())

    if not sv:
        # The page hasn't been fully created yet.  This is *not* an error.
        return None

    chapter.makeCurrent()

    # Set body ivars.
    body = c.frame.body
    body.lastChapter = name
    body.lastPosition = chapter.cp

    # Configure the tab.
    tab = tt.nb.tab(name)
    self.activateEditor(c.frame.body)
#@nonl
#@-node:ekr.20070317075059.6:chapter.setTree (NOT USED )
#@+node:ekr.20070317130648.1:chapter.findRootPosition (use nodeController method instead)
def findPositionAnywhere (self,v):
    
    '''Return a valid position p such that p.v == v.'''
    
    root = c.rootPosition()
    if not root: return None
   
    for p in p.self_and_siblings_iter():
        if p.v == v:
                return p

    return None
#@nonl
#@-node:ekr.20070317130648.1:chapter.findRootPosition (use nodeController method instead)
#@-node:ekr.20070325155208.2:Not used from chapter
#@-node:ekr.20031218072017.434:Unused code
#@-all
#@nonl
#@-node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@-leo
