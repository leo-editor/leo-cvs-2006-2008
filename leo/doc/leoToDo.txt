#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20070325052041:To do: 4.4.4 (@auto & resolve-cvs-conflicts)
#@+node:ekr.20070729105604:Fix bugs
#@+node:ekr.20070808090641:Clear all coloring tags in tag range
#@-node:ekr.20070808090641:Clear all coloring tags in tag range
#@+node:ekr.20070803081137:bug in rst plugin
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4437036
By: plumloco

Backslash in file names in @rst nodes etc. do not work with linux. I could not
get the rst to produce html from leoDocs until I changed all backslashes
(html\etc) to forward slashes. In addition I had to change all ..\doc refs to
../doc refs so rst could find the .css file.

You could do as I did and make the changes to leoDocs.leo, but it would
be much better if you could make the program do the right thing regardless of
\ or /.

leoBridge only works properly for me if I run from the leo/src, which is
inconvenient.

I have put leo on my python path and put a __init__.py in src so I can import
leoBridge as 'from leo import leoBridge'. This works except that leoBridge
produces lots of errors when I leoBridge.controller().

Of course, if I am in leo/src I cant use import leo as there is a leo.py in
that directory.

It would be good if you are going to make a .deb to put leo on the python path
and make it a proper package.

In addition if leo is to be a debian package, it should have a .leo dir in the
users home dir which contains myLeoSettings and also a users plugin directory.
Obviously as a debian package it will be installed read only. All those settings
files in Plugins will also have to be moved out.
#@nonl
#@-node:ekr.20070803081137:bug in rst plugin
#@+node:ekr.20070803081137.1:bug in http plugin
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4437415
By: xet7

it seems that bug is in leo. It doesn't show nodes with scandinavian characters
(ä) on node. At some point I also got this traceback:

Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoGlobals.py", line 2559, in doHook
    return f(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 71, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Program Files\Leo\src\leoPlugins.py", line 50, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Program Files\Leo\plugins\mod_http.py", line 856, in plugin_wrapper
    while loop(config.http_timeout):
  File "C:\Program Files\Leo\plugins\mod_http.py", line 847, in loop
    return poll(timeout)
  File "C:\Program Files\Leo\plugins\mod_http.py", line 835, in poll
    asyncore.write(obj)
  File "C:\Python25\lib\asyncore.py", line 80, in write
    obj.handle_error()
  File "C:\Python25\lib\asyncore.py", line 418, in handle_error
    'error'
  File "C:\Python25\lib\asyncore.py", line 376, in log_info
    print '%s: %s' % (type, message)
IOError: [Errno 9] Bad file descriptor

The actual leo file that I'm trying to use, when I exported flatten outline,
is 29143 lines long, and many nodes have ä/ö in them. Nodes that are just
ascii show fine.
#@nonl
#@-node:ekr.20070803081137.1:bug in http plugin
#@+node:ekr.20070803115653:Support @path in headlines
#@-node:ekr.20070803115653:Support @path in headlines
#@-node:ekr.20070729105604:Fix bugs
#@+node:ekr.20051202094427:resolve-cvs-conflicts and write-resolved-conflicts commands
@killcolor

http://sourceforge.net/forum/message.php?msg_id=4224589

There a simple way of handling cvs conflict markers (>>>>). If an import parser
discovers cvs conflict markers, the parser will just put the entire raw text in
a node that contains something like::

    @ignore
    @ The child of this node contains all text of <filename> 
    This file contains cvs conflicts markers. 
    Please resolve the conflicts by hand, remove the @ignore directive above, 
    and execute the write-resolved-conflict-file command. 
    This command will write <filename> and re-import the file. 

In other words, parsers should not try to resolve conflicts. Programmers
typically resolve conflicts in 'flat' editors--doing so in a single Leo node
would be natural.

Leo sentinels are relatively simple, so users can handle any sentinels that may
appear between conflict markers. Telling Leo users how to handle such sentinels
should be easier (and more reliable) than trying to resolve such conflicts
automatically.

The write-resolved-conflicts command will check sentinels for consistency. If
problems are found, the derived file will not be written, but instead the tree
will be saved in the .leo file.
#@-node:ekr.20051202094427:resolve-cvs-conflicts and write-resolved-conflicts commands
#@+node:ekr.20070729093951.1:Update docs re @enabled-plugins
#@-node:ekr.20070729093951.1:Update docs re @enabled-plugins
#@+node:ekr.20070615063616.1:Create Debian package
#@-node:ekr.20070615063616.1:Create Debian package
#@+node:ekr.20061006165447:Let import commands decide what kind of import to do
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

>the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
#@nonl
#@-node:ekr.20061006165447:Let import commands decide what kind of import to do
#@+node:ekr.20070801071851:print-docstring command
#@-node:ekr.20070801071851:print-docstring command
#@-node:ekr.20070325052041:To do: 4.4.4 (@auto & resolve-cvs-conflicts)
#@+node:ekr.20070703111455:To do: 4.4.5 (@menu, vim bindings, translation, etc)
# Leo 4.4.5 will complete several projects that are long overdue.

#@+node:ekr.20070703111455.1:Most important
#@+node:ekr.20060306194040:**ASAP** Video and more screen shots on Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.

-------------------

https://sourceforge.net/forum/message.php?msg_id=4396251
By: ktenney

2 good screencasts on making screencasts;

http://murl.se/26296
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:**ASAP** Video and more screen shots on Leo's web site
#@+node:ekr.20070625091423:Add translation services
@nocolor

*Many* calls to g.es and g.es_print have a mix of translated and untranslated items.
Untranslated items should include file names, directories, gnx's, leo_id's etc.

**Don't bother to do clone-find-all: there are 666 many matches!**

Regardless of the chosen scheme:

- g.translate will do the actual translation.

- Some simple string, like tr, will be an abbreviation for g.translate.
  The typical import will be::

    import leoGlobals as g ; tr = g.translate

The easiest scheme seems to be:

- g.es and g.es_print translate all arguments.
- g.esx and g.es_printx do no translation.

g.esx and g.es_printx allow a mix on translated and untranslated arguments::

    g.esx(tr('abc'),fileName)
#@-node:ekr.20070625091423:Add translation services
#@+node:ekr.20070626092228:@menu nodes for leoSettings.leo
#@-node:ekr.20070626092228:@menu nodes for leoSettings.leo
#@+node:ekr.20070623144302:vim-like bindings
#@-node:ekr.20070623144302:vim-like bindings
#@+node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20070521100324.1:Using Leo as a notebook
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4314394
By: duanekaufman

I am starting a kinda 'stream-of-thought' document, one in which I can put down
a paragraph of thought (perhaps in a pretty fashion, using ReST markup), develop
some code, to do some calculations, run the code and display the results...rinse,
repeat.

The document, in pseudo-form, would look like:

<Development of thought #1>
<Code to calculate something>
<Results from code execution>
<Discussion of results>

Each of the above would probably be a node, and I have already put together
things that look like the above, all except for the <results> part. I can run
the code, but how can I get the output automatically in my node? I can cut-and-paste
from the underlying command window (I run under Linux and Windows XP), but I
would like o automate it as much as possible.

Does anyone have any ideas on how to accomodate this workflow?

------ Reply

A most interesting and important question--with such a capability one could make Leo into a full-fledged engineering notebook, e.g., as envisaged by the IPython Notebook project: 

http://projects.scipy.org/ipython/ipython/wiki/NbshellManual 

I can think of several possible approaches: 

1. Create a custom version of the execute script command that would put script output in a particular node. Perhaps the headline of the node could be an argument to the enhanced command. 

2. Have your script write to some 'standard place', and create a command to put that script in the presently selected node. Something like insert-script-output. 

3. Create a script button that executes the script in the presently selected node and puts the result in the node *following* the selected node. You can then either move the node by hand, or use another script button to move the node to a 'standard place', say the last child of the <<results>> node. 

As I write this I think the script-button approach is likely to be the simplest, most flexible and most powerful. I'll look into this myself soon... 

Edward
#@nonl
#@-node:ekr.20070521100324.1:Using Leo as a notebook
#@-node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20070629081309:Support common buttons
# Any @button or @command nodes defined in myLeoSettings.leo should appear in all .leo files.
#@-node:ekr.20070629081309:Support common buttons
#@-node:ekr.20070703111455.1:Most important
#@+node:ekr.20070630143345:Easy and useful
#@+node:ekr.20070521105645:Improve api docs with epidoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@-node:ekr.20070521105645:Improve api docs with epidoc?
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20070629070639:Add command: toggle-collapse_nodes_during_finds
val = c.config.getBool('collapse_nodes_during_finds')
c.config.set(p,'collapse_nodes_during_finds',not val)
g.es_print('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
#@nonl
#@-node:ekr.20070629070639:Add command: toggle-collapse_nodes_during_finds
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20070627151457:--runCommand option
@ --runCommand "leo-command-name" runs the command at idle-time after loading the file.
#@nonl
#@-node:ekr.20070627151457:--runCommand option
#@-node:ekr.20070630143345:Easy and useful
#@+node:ekr.20070703111455.2:Bugs
#@+node:ekr.20070627211815:Fix problems with 'permanent updates' in clones
@

One clone is in a derived file: it's trailing whitespace gets deleted.

@bool write_strips_blank_lines = True

@string trailing_body_newlines = one

At present, I can not duplicate the problem.  I'll fix it when I can.
#@nonl
#@+node:ekr.20070529083836:cleanLines
def cleanLines (self,p,s):

    '''Return a copy of s, with all trailing whitespace removed.
    If a change was made, update p's body text and set c dirty.'''

    c = self.c ; cleanLines = [] ; changed = False
    lines = g.splitLines(s)
    for line in lines:
        if line.strip():
            cleanLines.append(line)
        elif line.endswith('\n'):
            cleanLines.append('\n')
            if line != '\n': changed = True
        else:
            cleanLines.append('')
            if line != '': changed = True
    s = g.joinLines(cleanLines)

    if changed and not g.app.unitTesting:
        p.setTnodeText(s)
        c.setBodyString(p,s)
        c.setChanged(True)

    return s
#@nonl
#@-node:ekr.20070529083836:cleanLines
#@+node:ekr.20070627211053.1:(done, but keep the clone) Post: @testcase not needed
#@+node:ekr.20070627204038.1:@@suite example of using plain unittest.TestCase
if g.unitTesting:

    @others

    g.app.scriptDict['suite'] = exampleTestCase(c)
#@+node:ekr.20070627204038.2:class exampleTestCase
import unittest

class exampleTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''

    def __init__ (self,c):
        unittest.TestCase.__init__(self)
        self.c = c

    def runTest(self):
        assert self.c
        print 'exampleTestCase'
#@nonl
#@-node:ekr.20070627204038.2:class exampleTestCase
#@-node:ekr.20070627204038.1:@@suite example of using plain unittest.TestCase
#@-node:ekr.20070627211053.1:(done, but keep the clone) Post: @testcase not needed
#@-node:ekr.20070627211815:Fix problems with 'permanent updates' in clones
#@+node:ekr.20060609070148:Fix hung windows
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3768494
By: ktenney

I'm using current CVS, W2k

1 open a Leo file (I'm using a batch file / console)

2 click Edit->Open   <-- Having this dialog open is the problem.

3 return focus to the Leo window

4 click Help->Open leoDocs.leo

Zombie!
#@-node:ekr.20060609070148:Fix hung windows
#@+node:ekr.20060116173818:Fix vampire nodes
@nocolor

Vampire nodes from cvs

I've just discovered a major problem with cvs updates.  It is a subtle consequence of how Leo writes outlines and reads derived files.  This is a big bug in Leo, not cvs.  The effect of the bug is that nodes can appear in derived files that were never written to them!

The discovery of this 'big bug' came about as the result of the following Aha:

**@thin files that contain @all directives should be a cvs binary (-kb) files.**

The reason is straightforward:  cvs doesn't know enough to merge such files.  Maybe all @thin derived files should be -kb files, but Leo's users will never agree to that!

Anyway, leoProjects.txt is now a binary file as far as cvs is concerned.  Other .txt files, like leoScripts.txt, should also be binary files.  As we shall see, the fact that leoProjects.txt is now a -kb file means that we can not possibly blame the cvs merge algorithm for what is about to happen.

Ok, back to the 'big bug'.  Here is how I got bitten:

- I changed leoProjects.txt in two sandboxes 1 and 2.  In sandbox 1 I added a node called 'changed in the main line'.  In sandbox 2 I added a node called 'changed2'.

- I changed LeoPyRef.leo in sandbox 2, but *not* in sandbox 1.

- I did a update in sandbox 2.

As expected (now that leoProjects.txt is a binary file) I got the following from cvs:

M src/LeoPyRef.leo
...
cvs update: nonmergeable file needs merge
cvs update: revision 1.448 from repository is now in src/leoProjects.txt
cvs update: file from working directory is now in .#leoProjects.txt.1.447

To summarize the update:

- LeoPyRef.leo has been marked as modified (M), but it has **not** been changed by cvs.

- As expected, leoProjects.txt contains the version from sandbox **1**.

So far, so good.  But when I opened LeoPyRef.leo I got a huge surprise: the outline contains **both** the node 'changed in main-line' and the node 'changed2'.  Whoa Nellie!

How did this happen?  Well, obviously the 'changed in main-line' node came from the cvs update.  I expected that.  The 'changed2' line must have come from the local copy of LeoPyRef.leo.

Once I knew what to look for it wasn't too hard to discover what had happened.  The 'changed2' is a descendent of a cloned node called '4.4 projects'.

- One clone of '4.4 projects' node is a descendent of the @thin leoProjects.txt node.

- Another clone of the '4.4 project' is in the LeoPyRef.leo file but outside of any @thin node.

So the 'resurrection' of the 'changed2' node happened while Leo was reading leoProjects.txt into LeoPyRef.leo.  The '4.4 projects' node **already existed in the outline** before Leo read leoProjects.txt, and the present atFile read logic only **adds** nodes, it never deletes nodes.  Thus, the 'changed2' node 'survived' the atFile read logic.  The 'changed2' node became a 'vampire' node that couldn't be killed.

The problem is far from benign.  Because of clones, the vampire node became an orphan node in **another** file, namely leoKeys.py.  I tried two or three times to remove the vampire/orphan node before realizing what had happened.

The fix (there is *always* a fix) will require some care.  The present atFile.read logic is robust because it *doesn't* delete nodes.  It is essential that the read logic remain robust.  I suspect the solutions will be as follows:

A. The atFile.read code can not delete the subtree of @thin nodes initially, because it doesn't know whether there will be read errors later.  If there are read errors absolutely nothing must change.  This ensures that read errors never destroy information.

B. A new post-pass will look for vampire nodes: nodes that were not actually read from the derived file.  I think (but haven't proven) that all descendents of vampire nodes are also vampire nodes.  If that is so the post-pass will simply delete vampire nodes without worrying about whether they have descendents.

Warning: the new scheme will mean that cvs update can destroy information that previously existed in the outline.  I believe this is correct: we assume that derived files are the 'truly meaningful' files.  Hey, if we are wrong we can always get the old info from cvs :-)

Edward
#@-node:ekr.20060116173818:Fix vampire nodes
#@-node:ekr.20070703111455.2:Bugs
#@+node:ekr.20070703111455.3:Other
# some of these can wait till much later.
#@nonl
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@+node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@-node:ekr.20070226075816.1:Update plugin manager to handle @enabled-plugins nodes
#@+node:ekr.20070626092228.1:minor
#@+node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@-node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20070619161413:Finish support for hidden windows
@

*** Important ***

The new code is just barely enough to open a window with a nullGui for @button dynamic-tests.
**However**, it is just the start of what would be required to open a window and execute most operations on it.
In particular, throughout leoEditCommands.py we should substitute c.frame.gui (or self.gui) for g.app.gui.
But it's way too late in the Leo 4.4.3 release cycle to do that.
#@nonl
#@+node:ekr.20031218072017.3679:  leoFrame.__init__
def __init__ (self,gui):

    self.c = None # Must be created by subclasses.
    self.title = None # Must be created by subclasses.
    self.gui = gui

    # Objects attached to this frame.
    self.colorPanel = None 
    self.comparePanel = None
    self.findPanel = None
    self.fontPanel = None
    self.iconBar = None
    self.isNullFrame = False
    self.keys = None
    self.menu = None
    self.miniBufferWidget = None # New in 4.4.
    self.prefsPanel = None
    self.statusLine = None
    self.useMiniBufferWidget = False # New in 4.4

    # Gui-independent data
    self.componentsDict = {} # Keys are names, values are componentClass instances.
    self.es_newlines = 0 # newline count for this log stream
    self.openDirectory = ""
    self.requestRecolorFlag = False
    self.saved=False # True if ever saved
    self.splitVerticalFlag,self.ratio, self.secondary_ratio = True,0.5,0.5 # Set by initialRatios later.
    self.startupWindow=False # True if initially opened window
    self.stylesheet = None # The contents of <?xml-stylesheet...?> line.
    self.tab_width = 0 # The tab width in effect in this pane.

#@+node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Icon bar convenience methods.    
    'addIconButton',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'hideIconBar',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
#@nonl
#@-node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
#@nonl
#@-node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3679:  leoFrame.__init__
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,fileName=None,gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ""
    if not gui: gui = g.app.gui
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20070302095121:createTextWidget
def createTextWidget (self,parentFrame=None):

    self.logNumber += 1

    c = self.c

    gui = c and c.frame and c.frame.gui or g.app.gui

    log = gui.plainTextWidget( ### was g.app.gui.
        c = self.c,
        name="log-%d" % self.logNumber,
    )

    return log
#@-node:ekr.20070302095121:createTextWidget
#@+node:ekr.20070302171509.2: nullStatusLineClass.ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame

    gui = c and c.frame and c.frame.gui or g.app.gui

    self.textWidget = w = gui.plainTextWidget(c,name='status-line')

    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText  = self.textWidget
#@-node:ekr.20070302171509.2: nullStatusLineClass.ctor
#@-node:ekr.20070619161413:Finish support for hidden windows
#@+node:ekr.20070627110422:create leoStartup.py
# This will have common startup code.
#@nonl
#@-node:ekr.20070627110422:create leoStartup.py
#@+node:ekr.20070613103409:Improve marks/recent buttons
- Arrow keys must move up/down.
- Should be commands to show the marks/recent dialogs.
#@nonl
#@-node:ekr.20070613103409:Improve marks/recent buttons
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20070605114358:Improve how recent files works??
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4347116
By: terry_n_brown

This is just a nit I guess, but I move between two machines all the time, and
Leo keeps changing the paths I open from /home/tbrown/project/project.leo to
/media/hda8/project/project.leo, so that when I switch to the other machine,
where /home/tbrown/project/project.leo is actually /media/hdb2/project/project.leo,
the recent files link is wrong.

If it would be trivial for Leo to not do this, I'd like that feature.  If it's
a big deal, then not to worry, I can always navigate to the file of course.
#@-node:ekr.20070605114358:Improve how recent files works??
#@+node:ekr.20070613181147:(maybe) Improve key handling
# The idea is to use a single <Key binding> and
# use w.event_generate(key) to create a table
# that associates Tk key numbers with bindings:

    if event.char:
        if 0:
            import Tkinter as Tk
            w = Tk.Text()
            def foo (event):
                g.trace(event)
            w.bind('<Key>',foo)
            for prefix in ('Alt-Key-','Shift-Key-'):
                key = '<%s%s>' % (prefix,event.char.strip())
                g.trace(key)
                w.event_generate('a')
        if 0:
            for z in ('char','keysym','keycode','keysym_num','state',):
                a = getattr(event,z)
                print z,repr(a)
#@-node:ekr.20070613181147:(maybe) Improve key handling
#@+node:ekr.20070624135822:Templates for common code fragments
#@-node:ekr.20070624135822:Templates for common code fragments
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20061024093525:Create settings menu
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3977681

How about having a menu Edit -> Settings with the submenu-items 'LeoSettings.leo',
'myLeoSettings.leo', 'this file's settings'?

The menu-items 'Open myLeoSettings.leo' and 'Open LeoSettings.leo' under the
Help-menu seem out-of-place.

#@-node:ekr.20061024093525:Create settings menu
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070626092228.1:minor
#@+node:ekr.20070613193516:Maybe
#@+node:ekr.20061207073104:Convert bottlenecks to pyrex code
# To do:  actually generate Leo's bottlenecks.
#@nonl
#@+node:ekr.20061207073104.1:gcc build docs
@nocolor

To build your module using GCC is a three step process on Unix. (I have know
idea how many steps it is on Windows™.)

Start by running the Pyrex compiler over your code as follows, where
mymodule.pyx is the name of the Pyrex module you are writing. python2.2 pyrexc
mymodule.pyx Next, compile the resulting C file into a .o file. The call to gcc
looks like this:

gcc -c -fPIC -I/usr/include/python2.2/ mymodule.c
The arguments to gcc are explained below.

-c 
Produces a .o file instead of an executable. 
-fPIC 
Produces position independent code, so we can dynamically link against it later. 
-I/usr/include/python2.2/ 
is the location of the Python 2.2 include file. The location of your Python include file may differ from /usr/include/python2.2/. 
mymodule.c 
is the name of the C file produced by Pyrex. 
Finally, link the .o into a .so: gcc -shared mymodule.o -lxosd -o mymodule.so
-shared 
produces a shared-object file, instead of an executable. 
mymodule.o 
is the name of the module you wish to compile. 
-lxosd 
links against a C-library, with the name of the library given as the argument. 
-o mymodule.so 
causes gcc to put the output into a file called mymodule.so 
The C library that you are wrapping will probably differ from mymodule. 
#@-node:ekr.20061207073104.1:gcc build docs
#@+node:ekr.20061207073104.2:pyrexc command-line options
@nocolor

The pyrexc command supports the following options:

  Short Long              Argument    Description
  -----------------------------------------------------------------------------
  -v    --version                     Display version number of pyrex compiler
  -l    --create-listing              Write error messages to a .lis file
  -I    --include-dir     <directory> Search for include files in named 
                                       directory (may be repeated)
  -o    --output-file     <filename>  Specify name of generated C file (only
                                       one source file allowed if this is used)

Anything else is taken as the name of a Pyrex source file and compiled
to a C source file. Multiple Pyrex source files can be specified
(unless -o is used), in which case each source file is treated as the
source of a distinct extension module and compiled separately to
produce its own C file.
#@-node:ekr.20061207073104.2:pyrexc command-line options
#@+node:ekr.20061207073104.3:@file myModule.pyx
def spam(int i, char *s):
    if 1:
        print i,s
#@nonl
#@-node:ekr.20061207073104.3:@file myModule.pyx
#@+node:ekr.20061207073104.4:Make myModule.c
# Use pyrexc to create myModule.c from myModule.pyx.
import os,sys
python = sys.executable
theFile = r'C:\prog\tigris-cvs\leo\test\myModule.pyx'
pyrexc = r'c:\prog\Pyrex-0.9.4.1\pyrexc.py'
os.system(r'%s %s %s' % (python,pyrexc,theFile))

if 0: # Build myModule library using distutils.
    from distutils.core import setup, Extension

    # Make the extension module ("mymodule") link against xosd
    xosdExtn = Extension("mymodule", ["mymodule.c"], libraries=["xosd"])

    # Compile the extension module
    setup(name="mymodule", ext_modules=[xosdExtn])

@ Save the above code in a file called setup.py and run the following code
to build and install your module.

    python setup.py build
    python setup.py install
#@nonl
#@-node:ekr.20061207073104.4:Make myModule.c
#@-node:ekr.20061207073104:Convert bottlenecks to pyrex code
#@-node:ekr.20070613193516:Maybe
#@-node:ekr.20070703111455.3:Other
#@-node:ekr.20070703111455:To do: 4.4.5 (@menu, vim bindings, translation, etc)
#@+node:ekr.20070703111913:To do: 4.4.6: (Swing gui)
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@+node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20070307082814:Create g.startupController class
#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@-node:ekr.20070703111913:To do: 4.4.6: (Swing gui)
#@+node:ekr.20070105135713:To do: 5.0 (The graph world)
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.

# Important: the new vnode class implies that the read code must be rewritten to be similar to the opml read code.
#@nonl
#@+node:ekr.20070512131018:Thoughts about positions 1
http://sourceforge.net/forum/message.php?msg_id=4308503

@nocolor

After more thought I am ready to back off my earlier post. Positions are perfectly reasonable things to support. Indeed, they can be, and probably should be, coequal with iterators. 

My 'revulsion' to positions stems from their present implementation--the 'optimization' of positions to avoid adding items to p.stack is certainly the worst optimization presently in Leo. It dates from the days when I was obsessing about reducing the amount of positions created. That was a valid concern then, but Leo now does an excellent job of not generating excess positions. Thus, there is no reason not to have p.stack contain all the parent vnodes at the present spot in a traversal. 

The idea of representing a position by a count in a traversal is cute, but of no practical importance. Indeed, why should Leo be forced to stupidly step through an entire traversal when a list of vnodes in p.stack would get to the proper spot in exponentially shorter time. Moreover, a list of vnodes in p.stack is great information to have, while a count N is almost exactly useless :-) 

Still, it is good to emphasize that *any* position, no matter how it is represented, makes sense *only* for a particular outline, that is, for a particular set of vnodes. In short, positions will stay, but will be reimplemented for the graph world. 
#@nonl
#@-node:ekr.20070512131018:Thoughts about positions 1
#@+node:ekr.20070512130855:Thoughts about positions 2
@nocolor

There will be some significant changes to the position and vnode classes for the graph world (Leo 4.5).  These changes will be common to both the graph and clone worlds:

Only vnode methods will be allowed to alter outline/graph data.  This would have been a good rule to following earlier, but up until now Leo has allowed 'confused' scripts--script that treat positions like vnodes.  This confusion will not be allowed in Leo 4.5.  The need for strict separation between vnodes and positions has become apparent in the recent chapters work.

It would be best to think of a position as a *path* to a particular vnode.  In the present (clone) world, the path is used exclusively by the tree drawing logic.  That logic tests whether the node being drawn matches (has the same position) as c.currentPosition.  In the graph world it probably makes sense to speak only of the current *vnode*, say v, so a position p is *a* current position if p.v == v.

The (renewed) focus on vnodes will be necessary.  For example, there will be no such things as p.back() or v._back in the graph world.  That is, a vnode v will have no *intrinsic* siblings.  Instead, siblings are relative to a parent: the order of vnodes in the parent.children links implicitly define sibling relationships, but a vnode v may have many 'parents', i.e. there may be many nodes that point to v.  We could speak of 'siblings with respect to a particular parent', but I suspect that will not be a particularly useful concept.  Rather, it will probably be more natural simply to define node relationships using iterators.  We shall see...
#@-node:ekr.20070512130855:Thoughts about positions 2
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False

    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')

    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061029093342.75:linkParentAndChildren (changed)
def linkParentAndChildren (self, parent_v, children):

    # if children: g.trace(parent_v,len(children))

    if self.use_new_positions:
        parent_v.t.links = children
    else:
        firstChild_v = children and children[0] or None
        parent_v.t._firstChild = firstChild_v
        for child in children:
            child._parent = parent_v

    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20061029093342.75:linkParentAndChildren (changed)
#@+node:ekr.20061029093342.76:linkSiblings (changed)
def linkSiblings (self, sibs):

    '''Set the v._back and v._next links for all vnodes v in sibs.'''

    if self.use_new_positions:
        pass
    else:
        n = len(sibs)
        for i in xrange(n):
            v = sibs[i]
            v._back = (i-1 >= 0 and sibs[i-1]) or None
            v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20061029093342.76:linkSiblings (changed)
#@-node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.5:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):

        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20061028211424.5:v.__cmp__ (not used)
#@+node:ekr.20061028211424.6:v.__init__
def __init__ (self,t):

    assert(t)

    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits

    # Structure links.
    #### self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20061028211424.6:v.__init__
#@+node:ekr.20061028211424.7:v.__repr__ & v.__str__
def __repr__ (self):

    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))

__str__ = __repr__
#@-node:ekr.20061028211424.7:v.__repr__ & v.__str__
#@+node:ekr.20061028211424.8:v.dump (to be deleted)
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):

    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)

    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20061028211424.8:v.dump (to be deleted)
#@+node:ekr.20061028211424.9:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20061028211424.9:v.__hash__ (only for zodb)
#@-node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):

    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()

    if not g.match(h,0,'@'):
        return ""

    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20061028211424.12:anyAtFileNodeName
def anyAtFileNodeName (self):

    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20061028211424.12:anyAtFileNodeName
#@+node:ekr.20061028211424.13:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20061028211424.13:at...FileNodeName
#@+node:ekr.20061028211424.14:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:ekr.20061028211424.14:isAtAllNode
#@+node:ekr.20061028211424.15:isAnyAtFileNode good
def isAnyAtFileNode (self):

    """Return True if v is any kind of @file or related node."""

    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20061028211424.15:isAnyAtFileNode good
#@+node:ekr.20061028211424.16:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)

def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20061028211424.16:isAt...FileNode (vnode)
#@+node:ekr.20061028211424.17:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20061028211424.17:isAtIgnoreNode
#@+node:ekr.20061028211424.18:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20061028211424.18:isAtOthersNode
#@+node:ekr.20061028211424.19:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern."""

    v = self

    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')

    return h.startswith(pattern)
#@-node:ekr.20061028211424.19:matchHeadline
#@-node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.22:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20061028211424.22:v.back
#@+node:ekr.20061028211424.23:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20061028211424.23:v.next
#@-node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.25:v.childIndex
def childIndex(self):

    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20061028211424.25:v.childIndex
#@+node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
def firstChild (self):

    return self.t._firstChild
#@-node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
#@+node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
def hasChildren (self):

    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
#@+node:ekr.20061028211424.28:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20061028211424.28:v.lastChild
#@+node:ekr.20061028211424.29:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20061028211424.29:v.nthChild
#@+node:ekr.20061028211424.30:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20061028211424.30:v.numberOfChildren (n)
#@-node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.32:v.isCloned (4.2)
def isCloned (self):

    return len(self.t.vnodeList) > 1
#@-node:ekr.20061028211424.32:v.isCloned (4.2)
#@+node:ekr.20061028211424.33:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20061028211424.33:isDirty
#@+node:ekr.20061028211424.34:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20061028211424.34:isExpanded
#@+node:ekr.20061028211424.35:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20061028211424.35:isMarked
#@+node:ekr.20061028211424.36:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20061028211424.36:isOrphan
#@+node:ekr.20061028211424.37:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20061028211424.37:isSelected
#@+node:ekr.20061028211424.38:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20061028211424.38:isTopBitSet
#@+node:ekr.20061028211424.39:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20061028211424.39:isVisited
#@+node:ekr.20061028211424.40:status
def status (self):

    return self.statusBits
#@-node:ekr.20061028211424.40:status
#@-node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.41:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20061028211424.41:v.bodyString
#@+node:ekr.20061028211424.42:v.headString & v.cleanHeadString
def headString (self):

    """Return the headline string."""

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):

    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20061028211424.42:v.headString & v.cleanHeadString
#@+node:ekr.20061028211424.43:v.directParents (new method in 4.2)
def directParents (self):

    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.

    This is NOT the same as the list of ancestors of the vnode."""

    v = self

    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20061028211424.43:v.directParents (new method in 4.2)
#@-node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20061028211424.45:v.detach
def detach (self):

    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''

    v = self

    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())

    return vnode(t2)
#@nonl
#@-node:ekr.20061028211424.45:v.detach
#@+node:ekr.20061028211424.46:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20061028211424.46:v.insertAfter
#@+node:ekr.20061028211424.47:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20061028211424.47:v.insertAsNthChild
#@+node:ekr.20061028211424.48:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""

    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20061028211424.48:v.linkAfter
#@+node:ekr.20061028211424.49:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20061028211424.49:v.linkAsNthChild
#@+node:ekr.20061028211424.50:v.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot

    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20061028211424.50:v.linkAsRoot
#@+node:ekr.20061028211424.51:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.

    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)

    return v
#@nonl
#@-node:ekr.20061028211424.51:v.moveToRoot
#@+node:ekr.20061028211424.52:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20061028211424.52:v.unlink
#@-node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
#@+node:ekr.20061028211424.53:Setters (no change)
#@+node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.55:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.55:clearClonedBit
#@+node:ekr.20061028211424.56:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20061028211424.56:v.clearDirty (no change needed)
#@+node:ekr.20061028211424.57:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20061028211424.57:v.clearMarked
#@+node:ekr.20061028211424.58:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20061028211424.58:clearOrphan
#@+node:ekr.20061028211424.59:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20061028211424.59:clearVisited
#@+node:ekr.20061028211424.60:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit

    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit

    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20061028211424.60:contract & expand & initExpandedBit
#@+node:ekr.20061028211424.61:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20061028211424.61:initStatus
#@+node:ekr.20061028211424.62:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.62:setClonedBit & initClonedBit
#@+node:ekr.20061028211424.63:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20061028211424.63:v.setMarked & initMarkedBit
#@+node:ekr.20061028211424.64:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20061028211424.64:setOrphan
#@+node:ekr.20061028211424.65:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20061028211424.65:setSelected (vnode)
#@+node:ekr.20061028211424.66:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20061028211424.66:t.setVisited
#@-node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.67:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val

def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20061028211424.67:v.computeIcon & setIcon
#@+node:ekr.20061028211424.68:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):

    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s

    # g.trace(g.callers(5))
#@-node:ekr.20061028211424.68:v.initHeadString
#@+node:ekr.20061028211424.69:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20061028211424.69:v.setSelection
#@+node:ekr.20061028211424.70:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):

    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20061028211424.70:v.setTnodeText
#@-node:ekr.20061028211424.53:Setters (no change)
#@-node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.1:position class
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__ (changed)
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__ (changed)
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex

    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):

    """Return True if a position is valid."""

    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):

    p = self

    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))

__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):

    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual (changed)
def equal(self,p2):

    """Return True if two postions are equivalent.

    Use this method when the speed comparisons is crucial

    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )

isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual (changed)
#@+node:ekr.20061028070057.11:p.key
def key (self):

    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):

    '''Move position p to its previous sibling.'''

    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen: no links')
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):

    '''Move a position to it's last child's position.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):

    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""

    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):

    """Move a position to the node after the position's tree."""

    p = self

    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):

    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):

    '''Move a position to its parent position.'''

    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p

    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):

    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self,c):

    """Move a position to the position of the previous visible node."""

    p = self

    if p:
        p.moveToThreadBack()
        while p and not p.isVisible(c):
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):

    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()

    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):

    return self.v.bodyString()

def headString (self):

    return self.v.headString()

def cleanHeadString (self):

    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):

    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):

    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):

    p = self

    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):

    if p.v:
        return len(p.v.t.links)
    else:
        return 0

    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack (self,c): return self.copy().moveToVisBack(c)
def getVisNext (self,c): return self.copy().moveToVisNext(c)

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren

def hasNext(self):
    p = self
    if p.stack:
        parent_v,junk = self.stack[-1]
        links = parent_v.t.links
        return p._childIndex + 1 < len(parent.v.t.links)
    else:
        return False
    # return self.v and self.v._next

def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None

def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.

hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):

    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
def isAncestorOf (self, p2):

    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False

    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):

    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):

    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):

    """Return True if all of a position's parents are expanded."""

    p = self
    for v in p.stack:
        if not v.isExpanded():
            return False
    return True

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)

simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):

    """A utility that allows the computation of p.v without calling p.copy().

    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""

    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):

    """Delete and otherwise adjust links when deleting node."""

    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):

    root = p = self

    assert(parent)

    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]

    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""

    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return

    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New

    #### p.v._parent = after.v._parent

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""

    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):

    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None

    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)

    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode

    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.

    The p.v.t.links does NOT change."""

    p = self ; v = p.v

    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)

    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)

    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028211424.1:position class
#@-node:ekr.20061028070132:New positions
#@-node:ekr.20070105135713:To do: 5.0 (The graph world)
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
