#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20071113093057:To do: 4.4.6: last major projects
#@+node:ekr.20071115111719:Fix pylint problems
#@-node:ekr.20071115111719:Fix pylint problems
#@+node:ekr.20071116061520:Study rope & pyxides auto-completion
#@-node:ekr.20071116061520:Study rope & pyxides auto-completion
#@+node:ekr.20071114063047:First
#@+node:ekr.20071031113657:Always use sax parser to read .leo files
# Are there proper unit tests?
# Do global settings and find-panel settings get set properly.
#@nonl
#@-node:ekr.20071031113657:Always use sax parser to read .leo files
#@+node:ekr.20071003104917:Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace
xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"
#@nonl
#@-node:ekr.20071003104917:Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace
#@+node:ekr.20071115055315:Add toggle-collapse-outline-when-moving
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent (self,event=None):

    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()

    if p.hasChildren() and p.isExpanded():
        # g.trace('contract',p.headString())
        c.contractNode()
    elif p.hasParent() and p.parent().isVisible(c):
        # g.trace('goto parent',p.headString())
        c.goToParent()

    c.treeFocusHelper()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@-node:ekr.20071115055315:Add toggle-collapse-outline-when-moving
#@+node:ekr.20071115111719.2:Remove hard-coded menu tables
#@+node:ekr.20031218072017.3785:createMenusFromTables & helpers
def createMenusFromTables (self):

    c = self.c

    aList = c.config.getMenusList()
    if aList:
        self.createMenusFromConfigList(aList)
    else:
        self.defineMenuTables()

        self.createFileMenuFromTable()
        self.createEditMenuFromTable()
        self.createOutlineMenuFromTable()

        g.doHook("create-optional-menus",c=c)

        if self.useCmdMenu:
            self.createCmndsMenuFromTable()

        self.createWindowMenuFromTable()
        self.createHelpMenuFromTable()
#@+node:ekr.20031218072017.3790:createFileMenuFromTable
def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("Tan&gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:createFileMenuFromTable
#@+node:ekr.20031218072017.3786:createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:createEditMenuFromTable
#@+node:ekr.20031218072017.3797:createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:createOutlineMenuFromTable
#@+node:ekr.20050921103736:createCmndsMenuFromTable
def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&Cmds')

    if 0: # Now in the minibuffer table.
        # Used in top table: q,u,x
        self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Chapters...',        self.cmdsMenuChaptersTable),
        ('C&ursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('M&inibuffer',         self.cmdsMenuMinibufferTable),
        #('&Panes...',           self.cmdsMenuPanesTable),
        ('&Pickers...',         self.cmdsMenuPickersTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('R&un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,t,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &To...',                self.cursorMenuExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
#@nonl
#@-node:ekr.20050921103736:createCmndsMenuFromTable
#@+node:ekr.20031218072017.3802:createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
#@-node:ekr.20031218072017.3802:createWindowMenuFromTable
#@+node:ekr.20031218072017.3803:createHelpMenuFromTable
def createHelpMenuFromTable (self,table):

    if sys.platform == 'darwin':
        self.getMacHelpMenu(table)
    else:
        helpMenu = self.createNewMenu("&Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)
#@nonl
#@-node:ekr.20031218072017.3803:createHelpMenuFromTable
#@+node:ekr.20070926135612:createMenusFromConfigList & helpers
def createMenusFromConfigList (self,aList):

    '''Create menus from dictionary d instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))
#@+node:ekr.20070927082205:createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
#@nonl
#@-node:ekr.20070927082205:createMenuFromConfigList
#@+node:ekr.20070927172712:handleSpecialMenus
def handleSpecialMenus (self,name,parentName,table=[]):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.  createRecentFilesMenuItems will be called later.
        self.createNewMenu(name,parentName)
        c.recentFiles = c.config.getRecentFiles()
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
#@-node:ekr.20070927172712:handleSpecialMenus
#@-node:ekr.20070926135612:createMenusFromConfigList & helpers
#@-node:ekr.20031218072017.3785:createMenusFromTables & helpers
#@-node:ekr.20071115111719.2:Remove hard-coded menu tables
#@+node:ekr.20070625091423:Add translation services
@nocolor

*Many* calls to g.es and g.es_print have a mix of translated and untranslated items.
Untranslated items should include file names, directories, gnx's, leo_id's etc.

**Don't bother to do clone-find-all: there are 666 many matches!**

Regardless of the chosen scheme:

- g.translate will do the actual translation.

- Some simple string, like tr, will be an abbreviation for g.translate.
  The typical import will be::

    import leoGlobals as g ; tr = g.translate

The easiest scheme seems to be:

- g.es and g.es_print translate all arguments.
- g.esx and g.es_printx do no translation.

g.esx and g.es_printx allow a mix on translated and untranslated arguments::

    g.esx(tr('abc'),fileName)

@color
#@nonl
#@+node:ekr.20071115111719.1:Script to print all g.es statements
@first # -*- coding: utf-8 -*-

# To do: match parens to get entire multi-line statements.

for p in p.self_and_subtree_iter():
    s = p.bodyString()
    h = p.headString()
    if h.startswith('@thin'):
        print ; print h
    lines = g.splitlines(s)
    for line in lines:
        line = line.strip()
        if g.match_word(line,0,'g.es') or g.match_word(line,0,'g.es_print'):
            print g.toEncodedString(line.strip(),'ascii')

#@-node:ekr.20071115111719.1:Script to print all g.es statements
#@+node:ekr.20071115113231:Results
@color

# Idea: g.et translates only the first arg.
# But this means we can use g.es and g.es *as is*!  (change s1 + s2 to s1,s2)
# Standard messages: 'done', 'not found', 'can not open', 'can not create', '%s: %s'

@thin leo.py
g.et("disabling save commands",color="red")
g.es("File not found: " + fileName)
g.es_print("can not open script file: " + name, color="red")
g.es("%s dir: %s" % (kind,theDir),color="blue")
g.es("psyco now logging to",theFile,color="blue")
g.et("psyco now running",color="blue")

@thin leoApp.py
g.es_print("leoID = " + g.app.leoID, color='red')
g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
g.es("empty %s (in %s)" % (tag,theDir), color = "red")
g.et_print('Unexpected exception in app.setLeoID',color='red')
g.es("using os.getenv('USER'): %s " % (repr(theId)),color='red')
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
g.et_print(s, color="red")
g.es(cant,color='red')
g.es(cant,color='red')
g.es(s,color=color,newline=0) # The caller must write the newlines.

@thin leoAtFile.py
g.et_print('check-derived-file passed',color='blue')
g.es("read only: " + fn,color="red")
g.es("reading: " + root.headString())
g.es('resurrected node: %s' % (p.headString()),color='blue')
g.es('in file: %s' % (fileName),color='blue')
g.et('you may want to delete ressurected nodes')
g.et("no @file nodes in the selected tree")
g.es_print('Errors inhibited read @auto %s' % (fileName),color='red')
g.es("dummy created")
g.es("using " + s)
g.es(len(lines), " lines" + m)
g.et("Write the @file node or use the Import Derived File command")
g.es("Warning: updating changed text in %s" %
g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
g.es("changed: " + p.headString(),color="blue")
g.es("bad encoding in derived file:",encoding)
g.es("Not written: " + at.outputFileName)
g.et("finished")
g.et("no @file nodes in the selected tree")
g.es("no dirty @file nodes")
g.es("finished")
g.et("no dirty @auto nodes in the selected tree")
g.et("no @auto nodes in the selected tree")
g.es("Not written: " + at.outputFileName)
g.es_print('@auto node not written:\n') ### continued
g.et("finished")
g.et("no @file node in the selected tree")
g.es('dubious brackets in %s' % line)
g.es("Ignoring bad @language directive: %s" % line,color="blue")
g.es("Ignoring bad @comment directive: %s" % line,color="blue")
g.es('%-10s %s' % ('unchanged:',self.shortFileName))
g.es('%-10s %s' % ('wrote:',self.shortFileName))
g.es('%-10s %s' % ('created:',self.targetFileName))
g.es("correcting line endings in: " + self.targetFileName,color="blue")
g.es("parent node: " + p.parent().headString(),color="blue")
g.es("exception writing:" + self.targetFileName,color="red")
g.es("exception deleting:" + self.outputFileName,color="red")
g.et("conflicting @header and @noheader directives")
g.et("Unknown language: using Python comment delimiters")
g.es("c.target_language:",c.target_language)
g.es("delim1,delim2,delim3:",delim1,delim2,delim3)

@thin leoBridge.py
g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
g.es("empty %s (in %s)" % (tag,theDir), color = "red")
g.et('Unexpected exception in app.setLeoID',color='red')
g.es('%s dir: %s' % (kind,theDir),color="blue")

@thin leoChapters.py
g.es_print(s,color='red')

@thin leoColor.py

@thin leoCommands.py
g.es(c.disableCommandsMessage,color='blue')
g.et('Ignoring command: already executing a command.',color='red')
g.et("exception executing command")
g.et("Leo Log Window...",color=color)
g.es(signon)
g.es("Python %d.%d.%d, %s\n%s" % (n1,n2,n3,g.app.gui.getFullVersion(c),version))
g.et("unexpected exception in c.openWith")
g.es("reopening: " + g.shortFileName(path),color="blue")
g.es("exception executing: "+command)
g.es("recreating:  " + g.shortFileName(path),color="red")
g.es("creating:  " + g.shortFileName(path),color="blue")
g.es("exception creating temp file",color="red")
g.es("Could not retrieve your user name.")
g.es("Temporary files will be stored in: %s" % leoTempDir)
g.es("Save commands disabled",color="purple")
g.es("Save commands disabled",color="purple")
g.es("Save commands disabled",color="purple")
g.es("can not open:" + fileName)
g.es("can not open:" + fileName)
g.es_print('wrote: %s' % (fileName),color='blue')
g.es('can not write %s' % (fileName),color='red')
g.es("end of script",color="purple",tabName=tabName)
g.es("no script selected",color="blue",tabName=tabName)
g.es("error handling: " + root.headString())
g.es("No ancestor @file node: using script line numbers", color="blue")
g.es("not found: " + fileName)
g.es("not found: " + vnodeName, color="red")
g.es_print(s, color="red")
g.es_print(s, color="red") ; ok = False
g.es_print(s, color="red")
g.es_print(s, color = "red")
g.es_print(s, color="red")
g.es("not found: " + vnodeName, color="red")
g.es("%d lines" % len(lines), color="blue")
g.es("bad @+leo sentinel")
g.es("line "+str(n)+" is a sentinel line")
g.es("bad @+node sentinel")
g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
g.es("tabs converted to blanks in %d nodes" % count)
g.es("Nothing follows section name",color="blue")
g.es("Nothing follows section name",color="blue")
g.es("Selected text should start with a section name",color="blue")
g.es("Selected text should contain one or more section names",color="blue")
g.es_print("head_lines: ",head_lines)
g.es_print("ins: ",ins)
g.es_print("tail_lines: ",tail_lines)
g.es("unmatched %s" % repr(ch))
g.es("time.strftime not available on this platform",color="blue")
g.es('No text selected',color='blue')
g.es('No text selected',color='blue')
g.es("'%s' not found" % (d2),color='blue')
g.es("'%s' not found" % (d3),color='blue')
g.es("%s command is not valid in batch mode" % commandName)
g.es("all tests enabled: this may take awhile",color="blue")
g.es('.',newline=False)
g.es_print(s,color="red")
g.es(s,color="green")
g.es("Check complete",color="blue")
g.es('.',newline=False)
g.es("checking Python code   ")
g.es("surprise in checkPythonNode")
g.es("Check complete",color="blue")
g.es('.',newline=False)
g.es_print(s,color="blue")
g.es("ParserError in %s" % headline,color="blue")
g.es(str(msg))
g.es("TokenError in %s" % headline,color="blue")
g.es(str(msg))
g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
g.es(message)
g.es("offending line:\n%s" % repr(str(line))[1:-1])
g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
g.es("done",color="blue")
g.es("done",color="blue")
g.es('The current node is not a clone',color='blue')
g.es("Can't move node out of %s" % (kind),color="blue")
g.es("%s not found in %s" % (name,configDir))
g.es("%s not found in %s or %s" % (name,configDir,homeDir))
g.es('not found: %s' % fileName)
g.es("not found: %s" % name)
g.es("not found: " + url)
g.es("not found: %s" % name)
g.es("not found: " + url)
g.es("not found: " + url)
g.es("bad %s: %s" % (encodingName,encoding))

@thin leoConfig.py
g.es(s,color="blue")
g.es_print(s,color='blue')
g.es("over-riding setting: %s from %s" % (name,path))
g.es_print(s,color='blue')
g.es("bad %s: %s" % (encodingName,encoding))
g.es("g.app.config: bad encoding: %s: %s" % (ivar,encoding))
g.es_print(s % (bunch.kind,setting,requestedType),color='red')
g.es_print('created %s' % (fileName),color='red')
g.es_print('can not create %s' % (fileName),color='red')
g.es('unexpected exception writing %s' % fileName,color='red')
g.es('%s %s = %s' % (letter,key,val))

@thin leoEditCommands.py
g.es('%s=%s' % (z,self.abbrevs[z]))
g.es('Can not open',fileName)
g.es('Can not create',fileName)
g.es('Buffers...')
g.es(name)
g.es('Buffers...')
g.es(name)
g.es('Debugger does not exist: %s' % (debugger),color='blue')
g.es('No debugger found.')
g.es('enabled verbose gc stats',color='blue')
g.es('enabled brief gc stats',color='blue')
g.es_print('      hasFocusWidget: %s' % c.widget_name(c.hasFocusWidget))
g.es_print('requestedFocusWidget: %s' % c.widget_name(c.requestedFocusWidget))
g.es_print('           get_focus: %s' % c.widget_name(c.get_focus()))
g.es('can not load image: %s' % (path))
g.es_print('bad open/close_flash_brackets setting: using defaults')
g.es('Lossage...')
g.es(stroke or d.get(ch) or ch or 'None')
g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
g.es('Can not open',fileName)
g.es('Can not create',fileName)
g.es_print(s)
g.es('%s:%s\n%s\n' % (commandName,bindings,s),color='blue')
g.es_print(s)
g.es_print(s)
g.es_print(s)
g.es_print(s)
g.es('Can not open',fileName)
g.es('Can not create',fileName)
g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))
g.es_print('Can not open dictionary file: %s' % (
g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
g.es("Adding ", color= "blue", newline= False)
g.es('%s' % self.currentWord)
g.es("Can not add %s to dictionary" % self.currentWord, color="red")
g.es("no more misspellings")
g.es(message,color='blue')
g.es("Ignoring ", color= "blue", newline= False)
g.es('%s' % self.currentWord)
g.es_print(message,color='blue')

@thin leoFileCommands.py
g.es('%s: %s' % (target,data),color='blue')
g.es("reading: " + self.fileName)
g.es_print('check-leo-file passed',color='blue')
g.es_print('check-leo-file failed: %s' % str(message),color='red')
g.es("Invalid Paste As Clone",color="blue")
g.es("The clipboard is not valid ",color="blue")
g.es("read only: " + fileName,color="red")
g.es("bad tnode index: %s. Using empty text." % str(index))
g.es("newTnode: unexpected index type:",type(index),index,color="red")
g.es("reading: " + fileName)
g.es("default tangle directory not found:" + c.tangle_directory)
g.es("no tnode with index: %s.  The text will be discarded" % str(index))
g.es_print(s, color = "blue")
g.es_print(s)
g.es_print(s,color="blue")
g.es_print(s)
g.es("Missing vnode:",headline,color="red")
g.es("Probably an outline topology error.")
g.es("invalid encoding in .leo file: " + encoding, color="red")
g.es_print('Unexpected exception converting hexlified string to string')
g.es_print('Error parsing %s' % (inputFileName),color='red')
g.es_print('Unexpected exception parsing %s' % (inputFileName),color='red')
g.es("clearing undo")
g.es("saved: %s%s" % (zipMark,g.shortFileName(fileName)))
g.es("read only",color="red")
g.es("exception deleting backup file:" + fileName)
g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
g.es("ignoring non-string attribute %s in %s" % (
g.es('putUaHelper: unexpected pickling exception',color='red')
g.es("ignoring non-pickleable attribute %s in %s" % (
g.es("deleting tnode list for %s" % p.headString(),color="blue")
g.es("Writing erroneous: %s" % p.headString(),color="blue")
g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
g.es("ignoring bad unknownAttributes key %s in %s" % (
g.es('putDescendentUnknownAttributes: unexpected pickling exception',color='red')
g.es("putDescendentUnknownAttributes can't happen 2",color='red')
g.es("exception writing: " + fileName)
g.es("can not create: read only: " + fileName,color="red")
g.es("read only",color="red")
g.es("restoring " + fileName + " from " + backupName)
g.es("auto-saving outline",color="blue")
g.es("auto-saving outline",color="blue")
g.es("auto-saving outline",color="blue")

@thin leoGlobals.py
g.es("ignoring: " + g.get_line(s,i))
g.es(g.angleBrackets("*") + "= requires @root in the headline")
g.es("invalid @encoding: "+encoding,color="red")
g.es("ignoring " + s,color="red")
g.es("Ignoring " + s,color="red")
g.es(message)
g.es_print(title)
g.es_print(''.join(['%2x ' % (ord(ch)) for ch in s[i:i+n]]))
g.es(s,color=color)
g.es("exception handling ", eventName, " event")
g.es(i)
g.es_print('%s, %s' % (exctype.__name__, value),color=color)
g.es("%s %6.3f" % (message,(time.clock()-start)))
g.es('Unexpected exception in g.create_temp_file',color='red')
g.es("Can't happen: is_sentinel",color="red")
g.es("created directory: "+path)
g.es("exception creating directory: "+path)
g.es("can not open: %s" % (fileName),color="blue")
g.es('%12s: %s' % (kind,file_name))
g.es("rename failed: no file created!",color="red")
g.es(file_name," may be read-only or in use")
g.es("exception removing:" + fileName)
g.es('Exception renaming %s to %s' % (src,dst),color='red')
g.es("exception in os.chmod(%s)" % (fileName))
g.es('Can not import gc module',color='blue')
g.es_print(s,color="blue")
g.es("...%s.py v%s: %s" % (
g.es(s)
g.es_print(s)
g.es(s,*args,**keys)
g.es_print('\ntest of es_print: ?',color='red',newline=False)
g.es_print('after')
g.es_print('done')
g.es(s,*args,**keys)
g.es("using -asis option in:" + h)
g.es("ignoring redundant -noref in:" + h)
g.es("ignoring redundant -nosent in:" + h)
g.es("using -thin option in:" + h)
g.es("unknown option:" + h[err:i] + " in " + h)
g.es("unknown option:" + s[err:i] + " in " + g.get_line(s,i))
g.es(s)
g.es("#if and #else parts have different braces: " + start_line)
g.es("no matching #endif: " + start_line)
g.es("no Find script node",color="red")
g.es("exception executing script",color='blue')
g.es_print(s)
g.es(s,newline=False)
g.es(s2,color='red')
g.es(s2,color='red')
g.es("Exception executing " + name,color="red")
g.es_print(s)
g.es_print(s,color="blue")
g.es_print("Exception in g.importFromPath",color='blue')
g.es_print("unexpected exception in g.importFromPath(%s)" %
g.es('g.init_zodb: can not import ZODB')
g.es('g.init_zodb: exception creating ZODB.DB instance')

@thin leoImport.py
g.es("Can not open " + fileName,color="blue")
g.es("Can not open " + fileName,color="blue")
g.es("Can not open " + fileName,color="blue")
g.es("can not open " + fileName, color="blue")
g.es("created: " + newFileName)
g.es("exception creating: " + newFileName)
g.es("exception opening:" + filename)
g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
g.es_print('ignoring %s' % (p.headString()),color='blue')
g.es(g.choose(found,'finished','no @auto nodes in the selected tree'),color='blue')
g.es("imported " + fileName,color="blue")
g.es(fileName + " is not a valid MORE file.")
g.es("Can not open " + fileName, color="blue")
g.es("Can not import " + fileName, color="blue")
g.es("****** " + target + ": is also a prefix of: " + s)
g.es_print(color='blue',*args,**keys)
g.es_print('missing lines')
g.es_print(repr(line))
g.es_print('first mismatched line at line %d' % (i+1))
g.es_print('original line:  %s' % line1)
g.es_print('generated line: %s' % line2)
g.es_print('*** first mismatch at line %d' % (i+1))
g.es_print('original line:  %s' % line1)
g.es_print('generated line: %s' % line2)
g.es_print('line: %s' % (repr(line)),color='red')
g.es_print(color='blue',*args,**keys)
g.es_print(color='blue',*args,**keys)
g.es_print('inserting @ignore',color='blue')
g.es_print(s,color='red')
g.es_print('error: %s' % (s),color='red')
g.es_print('warning: %s' % (s),color='red')
g.es_print('%s seems to be mixed HTML and PHP.' % fileName)

@thin leoNodes.py
g.es_print(s,color="red")
g.es_print(s,color="red")
g.es("scanGnx: unexpected index type:",type(s),s,color="red")

@thin leoPlugins.py
g.es_print(*args,**keys)
g.es_print(s,color="blue")
g.es_print('loadOnePlugin: loading module %s failed' % (moduleName),color="red")
g.es('Exception loading plugin',color='red')
g.es_print(s,color="red")
g.es_print(s,color="blue")
g.es_print('handlers for %s...' % (moduleName))
g.es_print('all plugin handlers...')
g.es_print('%25s %s' % (tag,key))
g.es_print('Enabled plugins...')
g.es_print(key)
g.es("*** Two exclusive handlers for '%s'" % tag)

@thin leoPymacs.py
g.es_print('leoPymacs.open: no file name')
g.es_print('leoPymacs.open: %s' % c)
g.es_print('leoPymacs.open: Can not open %s' % fileName)

@thin leoTangle.py
g.es("Can not execute tangle_done.run()")
g.es("Can not execute tangle_done.run()")
g.es("Tangling...")
g.es("Untangling...")
g.es("looking for a parent to tangle...")
g.es("tangling parent")
g.es("tangle complete")
g.es("Tangle complete")
g.es("Tangle complete")
g.es("Untangle complete")
g.es("Untangle complete")
g.es("Untangle complete")
g.es("@root " + path)
g.es("@comment disables Untangle for " + path, color="blue")
g.es("@" + self.print_mode +  " inhibits Untangle for " + path, color="blue")
g.es("error reading: " + path)
g.es("Can not create temp file")
g.es("unchanged:  " + file_name)
g.es(' ' * 4 + "Warning: " +
g.es("Warning: possible duplicate definition of: <<" +
g.es("Warning: " +
g.es("***Updating: " + p.headString())
g.es("ignoring: @comment " + z)
g.es("relative_path_base_directory: " + base)
g.es("relative path in @path directive: " + relative_path)
g.es("conflicting @header and @noheader directives")
g.es("relative_path_base_directory: " + base)
g.es(kind + " directory: " + dir2)

@thin leoTest.py
g.es_print("count: %d time/count: %f %s" % (count,result/count,p.headString()))
g.es('Running %sunit tests' % (g.choose(self.all,'all ','')),color='blue')
g.es_print('no @test or @suite nodes in selected outline')
g.es("Syntax error in: %s" % fileName,color="blue")
g.es("path does not exist: %s" % path)

@thin leoUndo.py
g.es('Exception in setUndoRedoTypingParams',color='blue')
g.es("redo %d instances" % count)
g.es("undo %d instances" % count)

@thin leoCompare.py
g.es(s)

@thin leoFind.py
g.es("changed: %d instances" % (count))
g.es("No text selected") ; return False
g.es("exception executing change script")
g.es("exception executing find script")
g.es("found: %d matches" % (count))
g.es("end of wrapped search")
g.es("not found: " + "'" + self.find_text + "'")
g.es('Invalid regular expression: %s' % (pattern),color='blue')
g.es('Wrap disabled in hoisted outlines',color='blue')
g.es('Found match outside of hoisted outline',color='blue')
g.es("not searching headline or body")
g.es("empty find patttern")
g.es('-' * 20,self.p.headString())
g.es(theType + line)
g.es('-' * 20,self.p.headString())
g.es(line)
g.es(line)

@thin leoFrame.py
g.es("Truncating headline to one line",color="blue")
g.es("Truncating headline to %d characters" % (limit),color="blue")
g.es("ignoring characters after space in url:"+url[i:])
g.es("use %20 instead of spaces")
g.es("no url following @url")
g.es("invalid url: "+url)
g.es("exception opening " + url)

@thin leoGui.py

@thin leoKeys.py
g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')
g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
g.es('%s' % (name),tabName=self.tabName)
g.es('No docstring for %s' % (word),color='blue')
g.es(doc,tabName='Info')
g.es('No docstring for %s' % (word),color='blue')
g.es_print('\nauto-completer scan complete',color='blue')
g.es_print('unexpected exception in computeProxyObject')
g.es_print('Syntax error in class node: can not continue')
g.es_print('Exception binding %s to %s' % (shortcut,commandName))
g.es_print('Ignoring invalid key binding: %s = %s' % (
g.es_print('redefining %s in %s to %s in %s' % (
g.es_print('bad abbrev: %s: unknown command name: %s' %
g.es_print('exception binding %s to %s' % (
g.es_print('no state function for %s' % (k.state.kind),color='red')
g.es('Minibuffer hidden',color='red')
g.es('%s is bound to: %s' % (commandName,shortcut))
g.es('%s %s' % (sep, prefix),tabName=tabName)
g.es('%s %s' % (sep, 'Plain Keys',),tabName=tabName)
g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName='Bindings')
g.es('%*s %*s %s' % (-n1,s1,-(min(12,n2)),s2,s3),tabName=tabName)
g.es('No previous command',color='blue')
g.es_print('Redefining %s' % (commandName), color='red')
g.es_print('@command: %s = %s' % (
g.es_print('@command: %s' % (commandName),color='blue')
g.es_print('No such command: %s. Referenced from %s' % (
g.es('%s mode\n\n' % modeName,tabName=tabName)
g.es('%*s %s' % (n,s1,s2),tabName=tabName)
g.es('%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3),tabName=tabName)
g.es(s,tabName=tabName)

@thin leoMenu.py
g.es("exception updating File menu")
g.es("exception updating Edit menu")
g.es("exception updating Outline menu")
g.es("menu does not exist: ",menuName)
g.es_print(s)
g.es("menu already exists: " + menuName,color="red")
g.es("exception creating " + menuName + " menu")
g.es("createOpenWithMenuFromTable: invalid data",color="red")
g.es("can't delete menu: " + menuName)
g.es("exception deleting " + menuName + " menu")
g.es("menu not found: " + menuName)
g.es("exception deleting " + itemName + " from " + menuName + " menu")
g.es("exception in setRealMenuNamesFromTable")

@thin leoSwingDialog.py
g.es("not found: " + self.email)
g.es("not found: " + self.url)

@thin leoSwingFrame.py
g.es("exception setting outline pane background color")
g.es("exception in user configuration for splitbar")
g.es("exception in user configuration for splitbar")
g.es("exception dowloading sbooks.chm")
g.es("exception setting body text background color")
g.es("exception setting body textforeground color")
g.es("exception setting body pane cursor color")
g.es("exception setting body pane text selection background color")
g.es("exception setting body pane text selection foreground color")
g.es("exception setting log pane background color")
g.es('can not rename %s tab' % (tabName),color='blue')
g.es("exception setting font")
g.es("family,size,slant,weight:",family,size,slant,weight)
g.es_print('\n' + '\n'.join(z))
g.es("Exception loading: " + fullname)
g.es_print('oops: eventToPosition failed')
g.es("dragged node will be cloned")
g.es("dragged node will be moved")

@thin leoSwingGui.py
g.es("LeoApp16.ico not in Icons directory", color="red")
g.es("Icons directory not found: "+path, color="red")
g.es("exception setting font from ",family_name)
g.es("family,size,slant,weight:",family,size,slant,weight)
g.es(c.disableCommandsMessage,color='blue')
g.es("Removing '%s' button at its request" % buttonText)
g.es_print('Bound @button %s to %s' % (buttonText,shortcut),color='blue')

@thin leoSwingUtils.py

@thin leoTkinterComparePanel.py

@thin leoTkinterDialog.py
g.es("not found: " + self.email)
g.es("not found: " + self.url)

@thin leoTkinterFind.py

@thin leoTkinterFrame.py
g.es("exception setting body text background color")
g.es("exception setting body textforeground color")
g.es("exception setting body pane cursor color")
g.es("exception setting body pane text selection background color")
g.es("exception setting body pane text selection foreground color")
g.es("exception setting outline pane background color")
g.es("exception in user configuration for splitbar")
g.es("exception in user configuration for splitbar")
g.es("exception dowloading sbooks.chm")
g.es("exception setting log pane background color")
g.es('can not rename %s tab' % (tabName),color='blue')
g.es("exception setting font")
g.es("family,size,slant,weight:",family,size,slant,weight)

@thin leoTkinterGui.py
g.es("LeoApp16.ico not in Icons directory", color="red")
g.es("Icons directory not found: "+path, color="red")
g.es("exception setting font from ",family_name)
g.es("family,size,slant,weight:",family,size,slant,weight)
g.es(c.disableCommandsMessage,color='blue')
g.es("Removing '%s' button at its request" % buttonText)
g.es_print('Bound @button %s to %s' % (buttonText,shortcut),color='blue')

@thin leoTkinterKeys.py

@thin leoTkinterMenu.py

@thin leoTkinterTree.py
g.es_print('\n' + '\n'.join(z))
g.es("exception setting outline line height")
g.es("Exception loading: " + fullname)
g.es_print('oops: eventToPosition failed')
g.es("dragged node will be cloned")
g.es("dragged node will be moved")
#@-node:ekr.20071115113231:Results
#@-node:ekr.20070625091423:Add translation services
#@+node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20070220082124:Make sure Leo can generate Latex
#@-node:ekr.20071114063047:First
#@+node:ekr.20070703111455.1:Most important
#@+node:ekr.20071105160956:*** auto-change panes
@nocolor

The idea: if a key binding is only in effect for one pane, and we get the
binding, maybe we should change to the pane first!

Examples:

copy-node: auto-select tree pane.
copy_text (when not editing a headline): auto-select body text.
#@nonl
#@-node:ekr.20071105160956:*** auto-change panes
#@+node:ekr.20071105145643:Clean up config mess
#@-node:ekr.20071105145643:Clean up config mess
#@+node:ekr.20071025160653.1:Support @command nodes in @buttons tree
#@-node:ekr.20071025160653.1:Support @command nodes in @buttons tree
#@+node:ekr.20070623144302:vim-like bindings
#@+node:ekr.20070824094005:Requests
@nocolor

> Some of the features I've grown to like with VIM are search-and-replace within the current selection, easy keyboard navigation, and to some extent macro recording and running.

Thanks for these comments.  I'll keep them in mind as I design the vim-like code.

Edward
#@nonl
#@-node:ekr.20070824094005:Requests
#@+node:ekr.20070814083528.1:Design post
@nocolor

http://sourceforge.net/forum/forum.php?thread_id=1800079&forum_id=10226

Recent posts have discussed @menu trees and resolving cvs conflicts. The third of my recent ruminations concerns adding support for vim-like key bindings. 

Earlier work involving input modes (@mode nodes in settings file) probably is not completely sufficient to implement plain-key key bindings in a way that would truly be vim-like. 

Most of the issues are implementation issues: Leo's key-handling code is very complicated. The trick is to handle both vim and emacs styles compatibly. 

The user must be able to specify vim-like key bindings without using @mode nodes. That is, top-level vim key bindings must always be available. Vim has an enormous number of key bindings: the user must be able to specify which are in effect. 

My strategy will be as follows: 

1. Create enter-vim-mode and exit-vim-mode commands, and create the setting: 

@bool vim-mode-by-default = False 

This will allow the user to specify vim mode as the default mode if desired. 

2. Create **vim-edit** commands as needed in order to handler user interaction. For example, dd deletes the present line while d5 deletes 5 lines. Rather than trying to simulate this effect using the present mechanisms, the vim-delete command will prompt for the number of characters or lines to delete. 

Give the complex nature of vims c and d commands (and others) it will probably be necessary to create a vim-edit class in leoEditCommands.py. This class will handle all the ways of specifying a range of characters to which the various commands will apply. It's not clear exactly how much work will be needed, but my guess is that it will, in fact, be easiest to handle vim-like interactions with new code. 

3. Vim's ':' command will simply invoke Leo's minibuffer. This isn't precisely the same as Vim's status line: it is significantly better. Otoh, we will want a way to simulate the actual spelling of vim's ':' commands. Possible @abbreviation nodes can be pressed into service. 

4. Internally, it will be quite a trick to allow top-level vim-like plain-key bindings in all text widgets. I'm not sure how to do this, but it is essential. 

I am quite eager to get something truly vim-like working. It promises to increase my editing speed substantially. It also should appeal strongly to present vim users. 
#@nonl
#@-node:ekr.20070814083528.1:Design post
#@+node:ekr.20071026140857:Posting re vim bindings
@nocolor

> I'm looking forward to this.

Excellent.  You can help with the testing :-)

Leo looks like a perfect match for the vim approach.  Indeed, vim typically uses a 1 or 2 level concatenation scheme (preceded by a repeat count).  This is kinda like a utf-8 encoding :-)  That is, it is a variable-length encoding of the command.

This is a very powerful approach, one that vim doesn't really exploit (because it doesn't need to). But Leo absolutely needs this power of some extra levels.  Something like this:

i input mode

f focus commands
..fb focus to body
..fo focus to outline
..fl focus to log
..ft toggle body pane focus

o outline commands
..om outline move, i.e., actually move the nodes.
..og outline go, i.e., select nodes without changing the outline
..od outline delete
..oh outline edit headline

s search commands
..so search options
...soi toggle ignore-case checkbox
...sow toggle word checkbox
...etc!
..st search using search tab
..sf forward incremental search
..sb backward incremental search

x minibuffer commands

w file commands
..ws save outline
..wq quit

escape: universal escape, like ctrl-g now.

Do you see?  Just one extra level allows 10+ times the number of key bindings.  This is a perfect match for Leo's complex environment.

Naturally, Leo will allow the user to specify these bindings using nodes in the @settings tree. Indeed, this is truly an exciting prospect.

Edward

P.S.  I've glossed over the details of which single characters (like d for delete character) should be reserved for common editing and cursor-movement commands.  That's the beauty of creating these bindings with user settings: no need to argue :-)  And that's the beauty of arbitrarily deep key binding trees: there are plenty of keys to go around.

EKR
#@-node:ekr.20071026140857:Posting re vim bindings
#@-node:ekr.20070623144302:vim-like bindings
#@+node:ekr.20071001052501:Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
#@nonl
#@-node:ekr.20071001052501:Versioning for nodes
#@+node:ekr.20060530085844:Improve autocompletion
# Study rope:  http://rope.sourceforge.net/
#@nonl
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@+node:ekr.20071106083149:Recent posts
@killcolor

I'm a little confused about the intended behaviour of autocomplete. I tried to test it using: 

@language python  

s = [1,2] 

I expected s. to yield a list of methods one might apply to a list (like append
etc...) instead it seems to give me a list of methods for a string. If one
replaces s with l, you don't get much of anything.

My responses 

The present autocompletion code is mostly a hack for working on Leo's own source
code. If your var is called s, the autocompleter assumes s is a string.

For the conventions used, see this node in leoPy.leo:

Code-->Gui Base classes-->@thin leoKeys.py-->class autoCompleterClass--> ctor
(autocompleter)-->defineObjectDict

Clearly, this is not good in general. I may generalize the code this week. Leo
will scan an @file tree (in a separate thread?) the first time you asked for
autocompletion in that tree.

-----

The issues involving autocompletion are coming back to my memory. In general,
this is a tricky problem. Consider:

- There may be no 'clean' version of the source code that you want to
auto-complete: you may be creating a new node, or a new file, and the source
code, being incomplete, will not parse correctly.

- Except in special circumstances, there is no 'real' object corresponding to s,
so there is no way to use Python's inspect module on s. Modules are an
exception: the autocompleter can handle existing modules fairly well. Try "os."
or "os.path." for example.

So I was a bit hasty in condemning the present approach. If your var is called
aList instead of s, Leo will suggest autocompletions for a list. Similarly for
s, s2 for strings, d, d1 and d2 for dictionaries, etc.

I'll look at the pyxides project for discussion of autocompleter code that might
be useful, but there are no guarantees that something better is coming soon.

-----

Scanning the pyxides thread about autocompletion, it seems the most promising tool is called rope: http://rope.sourceforge.net/ 

But to repeat: autocompletion is not easy. I have some long-delayed bugs to fix before turning my attention to an improved autocompleter. So probably not this week... 

----- 

1. It might be possible to generalize c.k.defineObjectDict so that the user
could specify autocompleter conventions, say in an @autocompleter node in an
@settings tree.

However, Python is not lisp, to actually specifying the object to use as the
base of the completion may not be trivial. See the code for
c.k.defineObjectDict.

2. Brian (LeoUser) used another kind of autocompleter scheme in his now-defunct
emacs plugin. When an outline was opened a scan (in a separate thread) found all
pairs x.y in the code. Typing x. would then give you all the y's associated with
x. It's clever, but it has obvious problems: it does not suggest completions
that are not in the file, and it suggests too much for 'self.'.

BTW, I actually did a lot of work on autocompletion that is not presently
active. In particular, leoKeys.py contains a 'forgiving' parser that attempts to
understand what 'self' means. Iirc, I disabled this code because it was too slow.
#@-node:ekr.20071106083149:Recent posts
#@+node:ekr.20071106135937:Study the pydev code in c:\prog\pydev
#@-node:ekr.20071106135937:Study the pydev code in c:\prog\pydev
#@+node:ekr.20071106135937.1:Study the rope code in c:\prog\rope
#@-node:ekr.20071106135937.1:Study the rope code in c:\prog\rope
#@-node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20071110071126:Better searching
#@+node:ekr.20071110071126.1:Force the insert point to beginning (or end) of text when selecting during finds?
Something not-quite-right is happening presently.
#@nonl
#@-node:ekr.20071110071126.1:Force the insert point to beginning (or end) of text when selecting during finds?
#@+node:ekr.20071110071126.2:Better isearch
#@-node:ekr.20071110071126.2:Better isearch
#@-node:ekr.20071110071126:Better searching
#@-node:ekr.20070703111455.1:Most important
#@+node:ekr.20070703111455.3:Minor
# some of these can wait till much later.
#@nonl
#@+node:ekr.20070521105645:Improve api docs with epidoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@-node:ekr.20070521105645:Improve api docs with epidoc?
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """

    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"

if ext[0] != ".":
    ext = "."+ext

# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None

body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed

if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):

    """Return the path to the temp file corresponding to p and ext."""

    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)

        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)

        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)

        name = g.toUnicode(name,g.app.tkEncoding)

        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))

        path = g.os_path_join(td,name)

        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):

    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save (commands)
def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    c.beginUpdate()
    try:
        if c.mFileName != "":
            # Calls c.setChanged(False) if no error.
            c.fileCommands.save(c.mFileName)
        else:
            fileName = g.app.gui.runSaveFileDialog(
                initialfile = c.mFileName,
                title="Save",
                filetypes=[("Leo files", "*.leo")],
                defaultextension=".leo")
            c.bringToFront()

            if fileName:
                # Don't change mFileName until the dialog has suceeded.
                c.mFileName = g.ensure_extension(fileName, ".leo")
                c.frame.title = c.mFileName
                c.frame.setTitle(g.computeWindowTitle(c.mFileName))
                c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
                c.fileCommands.save(c.mFileName)
                c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@nonl
#@-node:ekr.20031218072017.2834:save (commands)
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):

    '''Save a Leo outline to a file with a new filename.'''

    c = self ;  w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # 7/2/02: don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            # Calls c.setChanged(False) if no error.
            c.fileCommands.saveAs(c.mFileName)
            c.updateRecentFiles(c.mFileName)
    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
def saveAsUnzipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is not compressed.'''
    self.saveAsZippedHelper(False)

def saveAsZipped (self,event=None):

    '''Save a Leo outline to a file with a new filename,
    ensuring that the file is compressed.'''
    self.saveAsZippedHelper(True)

def saveAsZippedHelper (self,isZipped):

    c = self
    oldZipped = c.isZipped
    c.isZipped = isZipped
    try:
        c.saveAs()
    finally:
        c.isZipped = oldZipped
#@-node:ekr.20070413045221:saveAsUnzipped & saveAsZipped
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):

    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''

    c = self ; w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    c.beginUpdate()
    try:
        # Make sure we never pass None to the ctor.
        if not c.mFileName:
            c.frame.title = ""

        # set local fileName, _not_ c.mFileName
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            fileName = g.ensure_extension(fileName, ".leo")
            c.fileCommands.saveTo(fileName)
            c.updateRecentFiles(fileName)

    finally:
        c.endUpdate()
        c.widgetWantsFocus(w)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20071027121956:Fix javaScript scanner
# Javascript syntax is truly bizarre.
#@nonl
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent,atAuto=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        << Read file into s >>

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        c.beginUpdate()
        try:
            p.setTnodeText('')
        finally:
            c.endUpdate(False)
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()
        if self.treeType == "@file" and not s1:
            p.initHeadString("@nosent " + fileName)
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p,atAuto=atAuto)
    elif ext == '.c#':
        self.scanCSharpText(s,p,atAuto=atAuto)
    elif ext == ".el":
        self.scanElispText(s,p,atAuto=atAuto)
    elif ext == ".java":
        self.scanJavaText(s,p,atAuto=atAuto)
    elif ext == ".js":
        self.scanJavaScriptText(s,p,atAuto=atAuto)
    elif ext == ".pas":
        self.scanPascalText(s,p,atAuto=atAuto)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p,atAuto=atAuto)
    elif ext == ".php":
        self.scanPHPText(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    fileName = g.os_path_normpath(fileName)
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open %s%s" % (g.choose(atAuto,'@auto ',''),fileName),color='red')
    leoTest.fail()
    return None
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20070713075450:Unit tests
# atAuto must be False for unit tests: otherwise the test gets wiped out.

def cUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c')

def cSharpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest(p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.c#')

def elispUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.el')

def htmlUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.htm')

def javaUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.java')

def javaScriptUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.js')

def pascalUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.pas')

def phpUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.php')

def pythonUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.py')

def textUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.txt')

def defaultImporterUnitTest(self,p,fileName=None,s=None,showTree=False):
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,ext='.xxx')
#@+node:ekr.20070713082220:scannerUnitTest
def scannerUnitTest (self,p,atAuto=False,ext=None,fileName=None,s=None,showTree=False):

    '''Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.'''

    c = self.c ; h = p.headString() ; old_root = p.copy()
    oldChanged = c.changed
    c.beginUpdate()
    try:
        d = g.app.unitTestDict
        expectedErrors = d.get('expectedErrors')
        expectedErrorMessage = d.get('expectedErrorMessage')
        expectedMismatchLine = d.get('expectedMismatchLine')
        g.app.unitTestDict = {
            'expectedErrors':expectedErrors,
            'expectedErrorMessage':expectedErrorMessage,
            'expectedMismatchLine':expectedMismatchLine,
        }
        if not fileName: fileName = p.headString()
        if not s: s = self.removeSentinelsCommand([fileName],toString=True)
        title = g.choose(h.startswith('@test'),h[5:],h)
        self.createOutline(title.strip(),p.copy(),atAuto=atAuto,s=s,ext=ext)
        d = g.app.unitTestDict
        ok = ((d.get('result') and expectedErrors in (None,0)) or
            (
                # checkTrialWrite returns *True* if the following match.
                # d.get('result') == False and
                d.get('actualErrors') == d.get('expectedErrors') and
                d.get('actualMismatchLine') == d.get('expectedMismatchLine') and
                (expectedErrorMessage is None or d.get('actualErrorMessage') == d.get('expectedErrorMessage'))
            ))
        if not ok:
            g.trace('result',d.get('result'),
                'actualErrors',d.get('actualErrors'),
                'expectedErrors',d.get('expectedErrors'),
                'actualMismatchLine',d.get('actualMismatchLine'),
                'expectedMismatchLine', d.get('expectedMismatchLine'),
                '\nactualErrorMessage  ',d.get('actualErrorMessage'),
                '\nexpectedErrorMessage',d.get('expectedErrorMessage'),
            )
        if not showTree and ok:
            while old_root.hasChildren():
                old_root.firstChild().doDelete()
            c.setChanged(oldChanged)

    finally:
        c.selectPosition(old_root)
        c.endUpdate()

    if g.app.unitTesting:
        assert ok

    return ok
#@-node:ekr.20070713082220:scannerUnitTest
#@-node:ekr.20070713075450:Unit tests
#@+node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20070703122141.65: class baseScannerClass
class baseScannerClass:

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
#@+node:ekr.20070703122141.66:baseScannerClass.__init__
def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c

    self.atAutoWarnsAboutLeadingWhitespace = c.config.getBool('at_auto_warns_about_leading_whitespace')
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.language = language
    self.methodName = ic.methodName # x, as in < < x methods > > =
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'  

    # Compute language ivars.
    delim1,delim2,delim3 = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
#@-node:ekr.20070703122141.66:baseScannerClass.__init__
#@+node:ekr.20070808115837:Checking
#@+node:ekr.20070703122141.102:check
def check (self,s,parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
#@-node:ekr.20070703122141.102:check
#@+node:ekr.20070703122141.104:checkTrialWrite
def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True,
            write_strips_blank_lines=False)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in xrange(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
#@-node:ekr.20070703122141.104:checkTrialWrite
#@+node:ekr.20070730093735:compareHelper
def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')

    if i >= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i >= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print(repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]
    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif (not strict and not g.unitTesting) and line1.lstrip() == line2.lstrip():
        if not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            g.es_print('first mismatched line at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        return True # A match excluding leading whitespace.
    else:
        if not g.unitTesting or i+1 != expectedMismatch:
            # g.trace('unitTesting',g.unitTesting)
            g.es_print('*** first mismatch at line %d' % (i+1))
            g.es_print('original line:  %s' % line1)
            g.es_print('generated line: %s' % line2)
        d ['actualMismatchLine'] = i+1
        # g.trace('lines 1...\n',repr(lines1),'\nlines2...\n',repr(lines2))
        return False
#@-node:ekr.20070730093735:compareHelper
#@+node:ekr.20071110144948:checkLeadingWhitespace
def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line: %s' % (repr(line)),color='red')

    return ok
#@-node:ekr.20071110144948:checkLeadingWhitespace
#@+node:ekr.20070911110507:reportMismatch
def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import the file perfectly\nfirst mismatched line: %d\n%s' % (
            kind,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) < 100:
        pr('input...')
        for i in xrange(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in xrange(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
#@+node:ekr.20070913084008:minitest of pr
if False: # Don't clutter the unit tests.

    def pr(*args,**keys): # reportMismatch test
        g.es_print(color='blue',*args,**keys)

    pr('input...')
    pr('newline=False:',newline=False)
    pr('after')
    pr('done')
#@-node:ekr.20070913084008:minitest of pr
#@-node:ekr.20070911110507:reportMismatch
#@-node:ekr.20070808115837:Checking
#@+node:ekr.20070706084535:Code generation
@ None of these methods should ever need to be overridden in subclasses.

#@+node:ekr.20070707073044.1:addRef
def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    # g.trace(parent.headString())

    if self.treeType == '@file':
        c.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        c.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
#@-node:ekr.20070707073044.1:addRef
#@+node:ekr.20070705144309:createDeclsNode
def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
#@-node:ekr.20070705144309:createDeclsNode
#@+node:ekr.20070707085612:createFunctionNode
def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20070707085612:createFunctionNode
#@+node:ekr.20070703122141.77:createHeadline
def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent.headString(),headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.c.setBodyString(p,body,self.encoding)
    return p
#@-node:ekr.20070703122141.77:createHeadline
#@+node:ekr.20070703122141.79:getLeadingIndent
def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i < len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
#@-node:ekr.20070703122141.79:getLeadingIndent
#@+node:ekr.20070709094002:indentBody
def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
#@-node:ekr.20070709094002:indentBody
#@+node:ekr.20070705085335:insertIgnoreDirective
def insertIgnoreDirective (self,parent):

    self.c.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
#@-node:ekr.20070705085335:insertIgnoreDirective
#@+node:ekr.20070703122141.81:massageComment
def massageComment (self,s):

    '''Return s with leading and trailing whitespace removed and all other
    runs of whitespace and newlines converted to a single blank.'''

    s = s.strip()
    s = s.replace('\n',' ')
    s = s.replace('\r',' ')
    s = s.replace('\t',' ')
    s = s.replace('  ',' ')
    s = s.strip()
    return s
#@-node:ekr.20070703122141.81:massageComment
#@+node:ekr.20070707113832.1:putClass & helpers
def putClass (self,s,i,sigStart,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.classLines = []
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(s,i,codeEnd,class_name,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
#@+node:ekr.20070707190351:appendTextToClassNode
def appendTextToClassNode (self,class_node,s):

    c = self.c

    c.appendStringToBody(class_node,s) 
#@-node:ekr.20070707190351:appendTextToClassNode
#@+node:ekr.20070703122141.105:createClassNodePrefix
def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
#@-node:ekr.20070703122141.105:createClassNodePrefix
#@+node:ekr.20070703122141.106:getClassNodeRef
def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
#@-node:ekr.20070703122141.106:getClassNodeRef
#@+node:ekr.20070707171329:putClassHelper
def putClassHelper(self,s,i,end,class_name,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
#@-node:ekr.20070707171329:putClassHelper
#@-node:ekr.20070707113832.1:putClass & helpers
#@+node:ekr.20070707082432:putFunction
def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = s[start:sigStart]
    # Bug fix: 2007/20/31: adjust start backwards to get a better undent.
    if body1.strip():
        while start > 0 and s[start-1] in (' ','\t'):
            start -= 1

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    if not body.endswith('\n'):
        self.error(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
#@-node:ekr.20070707082432:putFunction
#@+node:ekr.20070705094630:putRootText
def putRootText (self,p):

    c = self.c

    c.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
#@-node:ekr.20070705094630:putRootText
#@+node:ekr.20070703122141.88:undentBody & undentBy
def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        # result = ''.join([
            # g.removeLeadingWhitespace(line,undent,self.tab_width)
                # for line in g.splitLines(s)])
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result

def undentBy (self,s,undentVal):
    return ''.join(
        [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            for line in g.splitLines(s)])
#@-node:ekr.20070703122141.88:undentBody & undentBy
#@+node:ekr.20070801074524:underindentedComment & underindentedLine
def underindentedComment (self,line):

    self.error(
        'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
#@-node:ekr.20070801074524:underindentedComment & underindentedLine
#@-node:ekr.20070706084535:Code generation
#@+node:ekr.20070703122141.78:error, oops, report and warning
def error (self,s):
    self.errors += 1
    self.importCommands.errors += 1
    if g.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict ['actualErrorMessage'] = s
        g.app.unitTestDict ['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print(s,color='red')
    else:
        g.es_print('error: %s' % (s),color='red')

def oops (self):
    print 'baseScannerClass oops: %s must be overridden in subclass' % g.callers()

def report (self,message):
    if self.strict: self.error(message)
    else:           self.warning(message)

def warning (self,s):
    if not g.unitTesting:
        g.es_print('warning: %s' % (s),color='red')
#@-node:ekr.20070703122141.78:error, oops, report and warning
#@+node:ekr.20070706084535.1:Parsing
@ Scan and skipDecls would typically not be overridden.
#@+node:ekr.20070707150022:extendSignature
def extendSignature(self,s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
#@-node:ekr.20070707150022:extendSignature
#@+node:ekr.20071017132056:getIndent
def getIndent (self,s,i):

    j,j2 = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    # g.trace('%d %s' % (indent,s[j:j2]))
    return indent
#@nonl
#@-node:ekr.20071017132056:getIndent
#@+node:ekr.20070706101600:scan & scanHelper
def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start < len(s):
        self.c.appendStringToBody(parent,s[start:]) 
#@+node:ekr.20071018084830:scanHelper
def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigStart,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd & codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i);
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress < i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
#@-node:ekr.20071018084830:scanHelper
#@-node:ekr.20070706101600:scan & scanHelper
#@+node:ekr.20070712075148:skipArgs
def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i >= len(s):
        return start,False
    else:
        return i,True 
#@-node:ekr.20070712075148:skipArgs
#@+node:ekr.20070707073859:skipBlock
def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i < len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent < startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            if level <= 0:
                if trace: g.trace('returns\n',repr(s[start:i]))
                return i

        else: i += 1
        assert progress < i

    self.error('no block')
    if 1:
        i,j = g.getLine(s,start)
        g.trace(s[max(0,i-20):i+20])
    if trace: g.trace('** no block')
    return start
#@-node:ekr.20070707073859:skipBlock
#@+node:ekr.20070712091019:skipCodeBlock
def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i > start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
#@-node:ekr.20070712091019:skipCodeBlock
#@+node:ekr.20070711104014:skipComment & helper
def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
#@+node:ekr.20070707074541:skipBlockComment
def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    # Skip the opening delim.
    assert(g.match(s,i,self.blockCommentDelim1))
    start = i ; i += len(self.blockCommentDelim1)

    # Find the closing delim.
    k = string.find(s,self.blockCommentDelim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(self.blockCommentDelim2)
#@-node:ekr.20070707074541:skipBlockComment
#@-node:ekr.20070711104014:skipComment & helper
#@+node:ekr.20070707080042:skipDecls
def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i < end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            if self.outerBlockEndsDecls:
                break
            else:
                i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else:
            i += 1 ;  prefix = None
        assert(progress < i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
#@-node:ekr.20070707080042:skipDecls
#@+node:ekr.20070707094858.1:skipId
def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)
#@nonl
#@-node:ekr.20070707094858.1:skipId
#@+node:ekr.20070730134936:skipNewline
def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i < len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i >= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
#@-node:ekr.20070730134936:skipNewline
#@+node:ekr.20070712081451:skipParens
def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
#@-node:ekr.20070712081451:skipParens
#@+node:ekr.20070707073627.2:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
#@-node:ekr.20070707073627.2:skipString
#@+node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
# We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
#@+node:ekr.20070712112008:startsHelper
def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
    i, sigId = self.skipSigId(s,i,ids)
    if not sigId:
        if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
        return False

    if self.output_indent < self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Isue this warning only if we have a real class or function.
    if 0: ### wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
#@-node:ekr.20070712112008:startsHelper
#@+node:ekr.20070711140703:skipSigStart
def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    # __pychecker__ = '--no-argsused' # tags not used in the base class.

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i < len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i < len(s) and s[i],ids,classId)
    return i, ids, classId
#@-node:ekr.20070711140703:skipSigStart
#@+node:ekr.20070712082913:skipSigTail
def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i < len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
#@-node:ekr.20070712082913:skipSigTail
#@+node:ekr.20070711134534:skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    return i, ids and ids[-1]
#@-node:ekr.20070711134534:skipSigId
#@-node:ekr.20070711132314:startsClass/Function (baseClass) & helpers
#@+node:ekr.20070711104014.1:startsComment
def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1))
#@-node:ekr.20070711104014.1:startsComment
#@+node:ekr.20070707094858.2:startsId
def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
#@-node:ekr.20070707094858.2:startsId
#@+node:ekr.20070707172732.1:startsString
def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
#@-node:ekr.20070707172732.1:startsString
#@-node:ekr.20070706084535.1:Parsing
#@+node:ekr.20070707072749:run (baseScannerClass)
def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width < 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
#@+node:ekr.20071110105107:checkBlanksAndTabs
def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank & tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
#@-node:ekr.20071110105107:checkBlanksAndTabs
#@+node:ekr.20070808115837.1:regularizeWhitespace
def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width < 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width > 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        s = g.choose(self.tab_width < 0,'tabs converted to blanks','blanks converted to tabs')
        message = '%s: inconsistent leading whitespace. %s' % (kind,s)
        self.report(message)

    return ''.join(result)
#@-node:ekr.20070808115837.1:regularizeWhitespace
#@-node:ekr.20070707072749:run (baseScannerClass)
#@-node:ekr.20070703122141.65: class baseScannerClass
#@+node:edreamleo.20070710110114.1:C scanner
#@+node:edreamleo.20070710110153:scanCText
def scanCText (self,s,parent,atAuto=False):

    scanner = self.cScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110153:scanCText
#@+node:edreamleo.20070710093042:class cScanner (baseScannerClass)
class cScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = '#' # A hack: treat preprocess directives as comments(!)
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.outerBlockEndsDecls = False # To handle extern statement.
        self.sigHeadExtraTokens = ['*']
        self.sigFailTokens = [';','=']
#@-node:edreamleo.20070710093042:class cScanner (baseScannerClass)
#@-node:edreamleo.20070710110114.1:C scanner
#@+node:ekr.20071008130845:C# scanner
#@+node:ekr.20071008130845.1:scanCSharpText
def scanCSharpText (self,s,parent,atAuto=False):

    scanner = self.cSharpScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071008130845.1:scanCSharpText
#@+node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
class cSharpScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='c')

        # Set the parser delims.
        self.blockCommentDelim1 = '/*'
        self.blockCommentDelim2 = '*/'
        self.blockDelim1 = '{'
        self.blockDelim2 = '}'
        self.classTags = ['class','interface','namespace',]
        self.extraIdChars = ':'
        self.functionTags = []
        self.lineCommentDelim = '//'
        self.lineCommentDelim2 = None
        self.outerBlockDelim1 = '{'
        self.outerBlockDelim2 = '}'
        self.sigHeadExtraTokens = []
        self.sigFailTokens = [';','='] # Just like C.
#@-node:ekr.20071008130845.2:class cSharpScanner (baseScannerClass)
#@-node:ekr.20071008130845:C# scanner
#@+node:ekr.20070711060107:Elisp scanner
#@+node:ekr.20070711060107.1:scanElispText
def scanElispText (self,s,parent,atAuto=False):

    scanner = self.elispScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070711060107.1:scanElispText
#@+node:ekr.20070711060113:class elispScanner (baseScannerClass)
class elispScanner (baseScannerClass):

    @others
#@+node:ekr.20070711060113.1: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='elisp')

    # Set the parser delims.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.lineCommentDelim = ';'
    self.lineCommentDelim2 = None
    self.blockDelim1 = '('
    self.blockDelim2 = ')'
    self.extraIdChars = '-'

#@-node:ekr.20070711060113.1: __init__
#@+node:ekr.20070711060113.2:Overrides
# skipClass/Function/Signature are defined in the base class.
#@nonl
#@+node:ekr.20070711060113.3:startsClass/Function & skipSignature
def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    return False

def startsFunction(self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    self.sigStart = i
    self.codeEnd = self.sigEnd = self.sigId = None
    if not g.match(s,i,'('): return False
    end = self.skipBlock(s,i)
    if not g.match(s,end,')'): return False

    i = g.skip_ws(s,i+1)
    if not g.match_word(s,i,'defun'): return False

    i += len(key)
    sigEnd = i = g.skip_ws_and_nl(s,i)
    j = g.skip_id(s,i)
    word = s[i:j]
    if not word: return False

    self.codeEnd = end + 1
    self.sigEnd = sigEnd
    self.sigId = word
    return True
#@-node:ekr.20070711060113.3:startsClass/Function & skipSignature
#@+node:ekr.20070711063339:startsString
def startsString(self,s,i):

    # Single quotes are not strings.
    return g.match(s,i,'"')
#@-node:ekr.20070711063339:startsString
#@-node:ekr.20070711060113.2:Overrides
#@-node:ekr.20070711060113:class elispScanner (baseScannerClass)
#@-node:ekr.20070711060107:Elisp scanner
#@+node:edreamleo.20070710110114:Java scanner
#@+node:edreamleo.20070710110114.2:scanJavaText
def scanJavaText (self,s,parent,atAuto=False):

    scanner = self.javaScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:edreamleo.20070710110114.2:scanJavaText
#@+node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
class javaScanner (baseScannerClass):

    @others
#@+node:ekr.20071019171430:javaScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = '{'
    self.classTags = ['class','interface']
    self.functionTags = []
    self.sigFailTokens = [';','='] # Just like c.
#@-node:ekr.20071019171430:javaScanner.__init__
#@+node:ekr.20071019170943:javaScanner.skipSigId
def skipSigId (self,s,i,ids):

    '''Return (i, id) where id is the signature's id.

    By default, this is the last id in the ids list.'''

    # Remove 'public' and 'private'
    ids2 = [z for z in ids if z not in ('public','private','final',)]

    # Remove 'extends' and everything after it.
    ids = []
    for z in ids2:
        if z == 'extends': break
        ids.append(z)

    return i, ids and ids[-1]
#@-node:ekr.20071019170943:javaScanner.skipSigId
#@-node:edreamleo.20070710085115:class javaScanner (baseScannerClass)
#@-node:edreamleo.20070710110114:Java scanner
#@+node:ekr.20071027111225:JavaScript scanner (not ready yet)
# The syntax for patterns causes all kinds of problems...
#@nonl
#@+node:ekr.20071027111225.1:scanJavaScriptText
def scanJavaScriptText (self,s,parent,atAuto=False):

    scanner = self.javaScriptScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071027111225.1:scanJavaScriptText
#@+node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
class javaScriptScanner (baseScannerClass):

    @others
#@+node:ekr.20071027111225.3:javaScriptScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java') # Used to set comment delims.

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.hasClasses = False
    self.hasFunctions = True
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None # For now, ignore outer blocks.
    self.outerBlockDelim2 = None
    self.classTags = []
    self.functionTags = ['function']
    self.sigFailTokens = [';',] # ','=',] # Just like Java.
#@-node:ekr.20071027111225.3:javaScriptScanner.__init__
#@+node:ekr.20071102150937:startsString
def startsString(self,s,i):

    if g.match(s,i,'"') or g.match(s,i,"'"):
        # Count the number of preceding backslashes:
        n = 0 ; j = i-1
        while j >= 0 and s[j] == '\\':
            n += 1
            j -= 1
        return (n % 2) == 0
    # elif g.match(s,i,'/'):
        # return i == 0 or s[i-1] != '/'
    else:
        return False
#@-node:ekr.20071102150937:startsString
#@+node:ekr.20071102161115:skipString
# Not ready: '/' is also the division operator!


# def skipString (self,s,i):

    # # Returns len(s) on unterminated string.
    # if s[i] in ('"',"'"):
        # return g.skip_string(s,i,verbose=False)
    # else:
        # # Match a pattern.
        # delim = '/'
        # g.pdb()
        # assert(s[i] == delim)
        # i += 1
        # n = len(s)
        # while i < n:
            # if s[i] == delim and s[i-1] != '\\':
                # return i + 1
            # else:
                # i += 1
        # return i
#@nonl
#@-node:ekr.20071102161115:skipString
#@-node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
#@-node:ekr.20071027111225:JavaScript scanner (not ready yet)
#@+node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711104241.2:scanPascalText
def scanPascalText (self,s,parent,atAuto=False):

    scanner = self.pascalScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@nonl
#@-node:ekr.20070711104241.2:scanPascalText
#@+node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
class pascalScanner (baseScannerClass):

    def __init__ (self,importCommands,atAuto):

        # Init the base class.
        importCommands.baseScannerClass.__init__(self,importCommands,
            atAuto=atAuto,language='pascal')

        # Set the parser delims.
        self.blockCommentDelim1 = '(*'
        self.blockCommentDelim2 = '*)'
        self.lineCommentDelim = '//'
        self.blockDelim1 = 'begin'
        self.blockDelim2 = 'end'
        self.classTags = []
        self.functionTags = ['function','procedure','constructor','destructor',]
#@-node:ekr.20070711104241.3:class pascalScanner (baseScannerClass)
#@-node:ekr.20070711104241:Pascal scanner
#@+node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070711090122:scanPHPText
def scanPHPText (self,s,parent,atAuto=False):

    scanner = self.phpScanner(importCommands=self,atAuto=atAuto)

    if scanner.isPurePHP(s):
        scanner.run(s,parent)
    else:
        fileName = scanner.fileName
        if not atAuto:
            g.es_print('%s seems to be mixed HTML and PHP.' % fileName)
        scanner.createHeadline(
            parent,body=s,headline=fileName)
#@-node:ekr.20070711090122:scanPHPText
#@+node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
class phpScanner (baseScannerClass):

    @others
#@+node:ekr.20070711090052.2: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='php')

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = '#'

    # The valid characters in an id
    self.chars = list(string.ascii_letters + string.digits)
    extra = [chr(z) for z in xrange(127,256)]
    self.chars.extend(extra)
#@-node:ekr.20070711090052.2: __init__
#@+node:ekr.20070711094850:isPurePHP
def isPurePHP (self,s):

    '''Return True if the file begins with <?php or ends with ?>'''

    s = s.strip()

    return (
        s.startswith('<?') and
        s[2:3] in ('P','p','=','\n','\r',' ','\t') and
        s.endswith('?>'))

#@-node:ekr.20070711094850:isPurePHP
#@+node:ekr.20070711090052.3:Overrides
# Does not create @first/@last nodes
#@+node:ekr.20070711090807:startsString skipString
def startsString(self,s,i):
    return g.match(s,i,'"') or g.match(s,i,"'") or g.match(s,i,'<<<')

def skipString (self,s,i):
    if g.match(s,i,'"') or g.match(s,i,"'"):
        return self.skipString()
    else:
        return g.skip_heredoc_string(s,i)
#@-node:ekr.20070711090807:startsString skipString
#@-node:ekr.20070711090052.3:Overrides
#@-node:ekr.20070711090052.1:class phpScanner (baseScannerClass)
#@-node:ekr.20070711090052:PHP scanner
#@+node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070703122141.99:scanPythonText
def scanPythonText (self,s,parent,atAuto=False):

    scanner = self.pythonScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20070703122141.99:scanPythonText
#@+node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
class pythonScanner (baseScannerClass):

    @others
#@+node:ekr.20070703122141.101: __init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

#@-node:ekr.20070703122141.101: __init__
#@+node:ekr.20070707113839:extendSignature
def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j < len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
#@-node:ekr.20070707113839:extendSignature
#@+node:ekr.20070707073627.4:skipString
def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
#@-node:ekr.20070707073627.4:skipString
#@+node:ekr.20070712090019.1:skipCodeBlock (python) & helper
def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = False
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i < len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = i > 0 and g.match(s,i-1,'\\\n')
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress < i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 < i < len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False
    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
#@+node:ekr.20070801080447:pythonNewlineHelper
def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace('startIndent',startIndent,'indent',indent,'line',repr(g.get_line(s,j)))
    if indent <= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent <= startIndent:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
#@-node:ekr.20070801080447:pythonNewlineHelper
#@-node:ekr.20070712090019.1:skipCodeBlock (python) & helper
#@+node:ekr.20070803101619:skipSigTail
# This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i):

    '''Skip from the end of the arg list to the start of the block.'''

    while i < len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
#@-node:ekr.20070803101619:skipSigTail
#@-node:ekr.20070703122141.100:class pythonScanner (baseScannerClass)
#@-node:ekr.20070703123334.2:Python scanner
#@+node:ekr.20070713075352:Default scanner
def scanUnknownFileType (self,s,p,ext,atAuto=False):

    c = self.c
    changed = c.isChanged()
    body = g.choose(atAuto,'','@ignore\n')
    if ext in ('.html','.htm'): body += '@language html\n'
    if ext in ('.txt','.text'): body += '@nocolor\n'
    c.setBodyString(p,body + self.rootLine + s)
    if atAuto:
        for p in p.self_and_subtree_iter():
            p.clearDirty()
        if not changed:
            c.setChanged(False)

    g.app.unitTestDict = {'result':True}
#@-node:ekr.20070713075352:Default scanner
#@-node:ekr.20031218072017.3241:Scanners for createOutline
#@+node:ekr.20071027111225:JavaScript scanner (not ready yet)
# The syntax for patterns causes all kinds of problems...
#@nonl
#@+node:ekr.20071027111225.1:scanJavaScriptText
def scanJavaScriptText (self,s,parent,atAuto=False):

    scanner = self.javaScriptScanner(importCommands=self,atAuto=atAuto)

    scanner.run(s,parent)
#@-node:ekr.20071027111225.1:scanJavaScriptText
#@+node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
class javaScriptScanner (baseScannerClass):

    @others
#@+node:ekr.20071027111225.3:javaScriptScanner.__init__
def __init__ (self,importCommands,atAuto):

    # Init the base class.
    importCommands.baseScannerClass.__init__(self,importCommands,
        atAuto=atAuto,language='java') # Used to set comment delims.

    # Set the parser delims.
    self.blockCommentDelim1 = '/*'
    self.blockCommentDelim2 = '*/'
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.hasClasses = False
    self.hasFunctions = True
    self.lineCommentDelim = '//'
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None # For now, ignore outer blocks.
    self.outerBlockDelim2 = None
    self.classTags = []
    self.functionTags = ['function']
    self.sigFailTokens = [';',] # ','=',] # Just like Java.
#@-node:ekr.20071027111225.3:javaScriptScanner.__init__
#@+node:ekr.20071102150937:startsString
def startsString(self,s,i):

    if g.match(s,i,'"') or g.match(s,i,"'"):
        # Count the number of preceding backslashes:
        n = 0 ; j = i-1
        while j >= 0 and s[j] == '\\':
            n += 1
            j -= 1
        return (n % 2) == 0
    # elif g.match(s,i,'/'):
        # return i == 0 or s[i-1] != '/'
    else:
        return False
#@-node:ekr.20071102150937:startsString
#@+node:ekr.20071102161115:skipString
# Not ready: '/' is also the division operator!


# def skipString (self,s,i):

    # # Returns len(s) on unterminated string.
    # if s[i] in ('"',"'"):
        # return g.skip_string(s,i,verbose=False)
    # else:
        # # Match a pattern.
        # delim = '/'
        # g.pdb()
        # assert(s[i] == delim)
        # i += 1
        # n = len(s)
        # while i < n:
            # if s[i] == delim and s[i-1] != '\\':
                # return i + 1
            # else:
                # i += 1
        # return i
#@nonl
#@-node:ekr.20071102161115:skipString
#@-node:ekr.20071027111225.2:class javaScriptScanner (baseScannerClass)
#@-node:ekr.20071027111225:JavaScript scanner (not ready yet)
#@-node:ekr.20071027121956:Fix javaScript scanner
#@+node:ekr.20071004120359.2:Do expand-region-abbrevs from
#@+node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
# def regionalExpandAbbrev (self,event):

    # '''Exapand abbreviations throughout a region.'''

    # k = self.k ; w = self.editWidget(event)
    # if not w or not self._chckSel(event): return

    # i1,i2 = w.getSelectionRange()
    # ins = w.getInsertPoint()
    # << define a new generator searchXR >>

    # # EKR: the 'result' of calling searchXR is a generator object.
    # k.regx.iter = searchXR(i1,i2,ins,event)
    # k.regx.iter.next() # Call it the first time.
#@nonl
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
# @ This is a generator (it contains a yield).
# To make this work we must define a new generator for each call to regionalExpandAbbrev.
# @c
# def searchXR (i1,i2,ins,event):
    # k = self.k
    # w = self.editWidget(event)
    # if not w: return

    # w.tag_add('sXR',i1,i2)
    # while i1:
        # tr = w.tag_ranges('sXR')
        # if not tr: break
        # i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        # if i1:
            # word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_delete('found')
            # w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            # w.tag_config('found',background='yellow')
            # if self.abbrevs.has_key(word):
                # k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                # yield None
                # if k.regXKey == 'y':
                    # ind = w.index('%s wordstart' % i1)
                    # w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    # w.insert(ind,self.abbrevs[word])
            # i1 = '%s wordend' % i1
    # w.setInsertPoint(ins,ins,insert=ins)
    # w.tag_delete('sXR')
    # w.tag_delete('found')
    # k.setLabelGrey('')
    # self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >> LATER
#@-node:ekr.20050920084036.21:regionalExpandAbbrev (TK code)
#@-node:ekr.20071004120359.2:Do expand-region-abbrevs from
#@+node:ekr.20070905072809.1:Mulder post re svn
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4484641
By: bwmulder

Actually we are talking about two plugins here: a bazaar plugin, and a
Leo plugin.

The bazaar plugin would do special things for Leo files during checkout, status
and checkin. After checkout, for example, it would delete the sentinels in the
user visible files.

The Leo plugin would know to go to the repository for reading (and writing?).

One open question is to where to store new sentinels: can they be hidden away
in the Source Control System (SCS) directories?

Another open question: Could Leo sentinels be used as an identity marker, which
unambiguously identifies a piece of text? With that, the SCS system might have
enough information to make statements like:

Lines 10-100 where in file x where moved from file y, in other words: the SCS
could track code at the function level.

The whole process could then work like this:

1. You check out your sources.
2. After checkout, the bazaar plugin would delete all sentinels from the checked-out
files.
3. If you start Leo, Leo would read the (full) file from the SCS.
4. If you make modifications, the full file would be hidden in SCS directories,
and the disk file would (again) show no sentinels.
5. I don't know how the bazaar status command works. We must make sure that
status works correctly for Leo files as it does for any other files.
6. For checkin, the SCS system would have to use the information hidden in step
4.

Open questions:

1. Can the Leo sentinels be used as a permanent identity markers for text? If
they can't be right now, would Edward be willing to modify them so that they
can?
2. Can / should we make the full files available somehow (probably)
2. How would conflict resolution work? Can / should we hide the sentinels even
then? (probably not)

So the answer to your question is: yes, I am thinking about such plugins, though
I am not (yet) thinking of writing such plugins myself.

______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit:
https://sourceforge.net/forum/unmonitor.php?forum_id=10226
#@-node:ekr.20070905072809.1:Mulder post re svn
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20070605114358:Improve how recent files works?
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4347116
By: terry_n_brown

This is just a nit I guess, but I move between two machines all the time, and
Leo keeps changing the paths I open from /home/tbrown/project/project.leo to
/media/hda8/project/project.leo, so that when I switch to the other machine,
where /home/tbrown/project/project.leo is actually /media/hdb2/project/project.leo,
the recent files link is wrong.

If it would be trivial for Leo to not do this, I'd like that feature.  If it's
a big deal, then not to worry, I can always navigate to the file of course.
#@-node:ekr.20070605114358:Improve how recent files works?
#@+node:ekr.20070619161413:Finish support for hidden windows
@

*** Important ***

The new code is just barely enough to open a window with a nullGui for @button dynamic-tests.
**However**, it is just the start of what would be required to open a window and execute most operations on it.
In particular, throughout leoEditCommands.py we should substitute c.frame.gui (or self.gui) for g.app.gui.
But it's way too late in the Leo 4.4.3 release cycle to do that.
#@nonl
#@+node:ekr.20031218072017.3679:  leoFrame.__init__
def __init__ (self,gui):

    self.c = None # Must be created by subclasses.
    self.title = None # Must be created by subclasses.
    self.gui = gui

    # Objects attached to this frame.
    self.colorPanel = None 
    self.comparePanel = None
    self.findPanel = None
    self.fontPanel = None
    self.iconBar = None
    self.isNullFrame = False
    self.keys = None
    self.menu = None
    self.miniBufferWidget = None # New in 4.4.
    self.prefsPanel = None
    self.statusLine = None
    self.useMiniBufferWidget = False # New in 4.4

    # Gui-independent data
    self.componentsDict = {} # Keys are names, values are componentClass instances.
    self.es_newlines = 0 # newline count for this log stream
    self.openDirectory = ""
    self.requestRecolorFlag = False
    self.saved=False # True if ever saved
    self.splitVerticalFlag,self.ratio, self.secondary_ratio = True,0.5,0.5 # Set by initialRatios later.
    self.startupWindow=False # True if initially opened window
    self.stylesheet = None # The contents of <?xml-stylesheet...?> line.
    self.tab_width = 0 # The tab width in effect in this pane.

#@+node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Icon bar convenience methods.    
    'addIconButton',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'hideIconBar',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
#@nonl
#@-node:ekr.20061109120726:leoFrame.mustBeDefinedOnlyInBaseClass
#@+node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
#@nonl
#@-node:ekr.20061109120704:leoFrame.mustBeDefinedInSubclasses
#@-node:ekr.20031218072017.3679:  leoFrame.__init__
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))
    # g.trace(relativeFileName,'-->',fileName)

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    if old_c:
        # New in 4.4: We must read the file *twice*.
        # The first time sets settings for the later call to c.finishCreate.
        # g.trace('***** prereading',fileName)
        c2 = g.app.config.openSettingsFile(fileName)
        if c2: g.app.config.updateSettings(c2,localFlag=True)
        g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies & headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile: return False, None
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    c.beginUpdate()
    try:
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            c.setLog()
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if frame.c.chapterController:
            frame.c.chapterController.finishCreate()
        k = c.k
        k and k.setInputState(k.unboundKeyAction)
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return True, frame
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
def newLeoCommanderAndFrame(self,
    fileName=None,
    relativeFileName=None,
    gui=None,initEditCommanders=True,updateRecentFiles=True):

    """Create a commander and its view frame for the Leo main window."""

    app = self

    import leoCommands

    if not fileName: fileName = ''
    if not relativeFileName: relativeFileName = ''
    if not gui: gui = g.app.gui
    << compute the window title >>

    # g.trace(fileName,relativeFileName)

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)

    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName,relativeFileName=relativeFileName)

    if not app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.

    frame.finishCreate(c)
    c.finishCreate(initEditCommanders)

    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.

    if updateRecentFiles:
        c.updateRecentFiles(relativeFileName or fileName)

    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1
#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:app.newLeoCommanderAndFrame
#@+node:ekr.20031218072017.1623:new
def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        # chapterController.finishCreate must be called after the first real redraw
        # because it requires a valid value for c.rootPosition().
        if c.config.getBool('use_chapters') and c.chapterController:
            c.chapterController.finishCreate()
            frame.c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20070302095121:createTextWidget
def createTextWidget (self,parentFrame=None):

    self.logNumber += 1

    c = self.c

    gui = c and c.frame and c.frame.gui or g.app.gui

    log = gui.plainTextWidget(
        c = self.c,
        name="log-%d" % self.logNumber,
    )

    return log
#@-node:ekr.20070302095121:createTextWidget
#@+node:ekr.20070302171509.2: nullStatusLineClass.ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.enabled = False
    self.parentFrame = parentFrame

    gui = c and c.frame and c.frame.gui or g.app.gui

    self.textWidget = w = gui.plainTextWidget(c,name='status-line')

    # Set the official ivars.
    c.frame.statusFrame = None
    c.frame.statusLabel = None
    c.frame.statusText  = self.textWidget
#@-node:ekr.20070302171509.2: nullStatusLineClass.ctor
#@-node:ekr.20070619161413:Finish support for hidden windows
#@+node:ekr.20070613181147:(maybe) Improve key handling
# The idea is to use a single <Key binding> and
# use w.event_generate(key) to create a table
# that associates Tk key numbers with bindings:

    if event.char:
        if 0:
            import Tkinter as Tk
            w = Tk.Text()
            def foo (event):
                g.trace(event)
            w.bind('<Key>',foo)
            for prefix in ('Alt-Key-','Shift-Key-'):
                key = '<%s%s>' % (prefix,event.char.strip())
                g.trace(key)
                w.event_generate('a')
        if 0:
            for z in ('char','keysym','keycode','keysym_num','state',):
                a = getattr(event,z)
                print z,repr(a)
#@-node:ekr.20070613181147:(maybe) Improve key handling
#@+node:ekr.20070624135822:Templates for common code fragments
#@-node:ekr.20070624135822:Templates for common code fragments
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@-node:ekr.20070703111455.3:Minor
#@+node:ekr.20071105155631.1:Plugins
#@+node:ekr.20071021125124:Revise plugins manager plugin
Remove all references to pluginsManager.txt.
#@nonl
#@-node:ekr.20071021125124:Revise plugins manager plugin
#@+node:ekr.20071010162003:Add @rclick-menus trees to specify rclick popup menus
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4562648
By: rogererens

Maybe I may use this thread to make another suggestion for Leo 4.4.5, related
to @menus: have the menu-options for right-clicking in the various panes also
in the @settings-tree.

Regards, Roger
#@nonl
#@-node:ekr.20071010162003:Add @rclick-menus trees to specify rclick popup menus
#@+node:ekr.20071026052111:Fix cursesGui  plugin
#@+node:ekr.20071026051956:crash in cursesGui.py
reading settings in C:\prog\tigris-cvs\leo\config\leoSettings.leo
reading settings in C:\Documents and Settings\HP_Administrator\My Documents\Edward\myLeoSettings.leo
reading settings in C:\prog\tigris-cvs\leo\test\test.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leoRecentFiles.txt
reading C:\prog\tigris-cvs\leo\config\.leoRecentFiles.txt
@enabled-plugins found in test.leo
textGui oops <module>,run,createFrame,openWithFileName,newLeoCommanderAndFrame,finishCreate,createKeyHandlerClass should be implem
ented
Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 401, in <module>
    run(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 144, in run
    c,frame = createFrame(fileName)
  File "c:\prog\tigris-cvs\leo\src\leo.py", line 213, in createFrame
    ok, frame = g.openWithFileName(fileName,None)
  File "C:\prog\tigris-cvs\leo\src\leoGlobals.py", line 1908, in openWithFileName
    c,frame = app.newLeoCommanderAndFrame(fileName=fileName,gui=gui)
  File "C:\prog\tigris-cvs\leo\src\leoApp.py", line 577, in newLeoCommanderAndFrame
    c.finishCreate(initEditCommanders)
  File "c:\prog\tigris-cvs\leo\src\leoCommands.py", line 216, in finishCreate
    c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 247, in finishCreateEditCommanders
    d2 = theInstance.getPublicCommands()
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 1022, in getPublicCommands
    'keyboard-quit':                k.keyboardQuit,
AttributeError: 'NoneType' object has no attribute 'keyboardQuit'
>>>
#@nonl
#@-node:ekr.20071026051956:crash in cursesGui.py
#@-node:ekr.20071026052111:Fix cursesGui  plugin
#@+node:ekr.20071105155631.2:Fix script_io_to_body plugin
#@-node:ekr.20071105155631.2:Fix script_io_to_body plugin
#@+node:ekr.20070613103409:Improve marks/recent buttons
- Arrow keys must move up/down.
- Should be commands to show the marks/recent dialogs.
#@nonl
#@-node:ekr.20070613103409:Improve marks/recent buttons
#@-node:ekr.20071105155631.1:Plugins
#@-node:ekr.20071113093057:To do: 4.4.6: last major projects
#@+node:ekr.20070923103337:Not associated with any release
#@+node:ekr.20071111053028:Move to svn
@nocolor

http://subversion.tigris.org/faq.html#cvs2svn
#@nonl
#@-node:ekr.20071111053028:Move to svn
#@+node:ekr.20060306194040:Video and more screen shots on Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.

-------------------

https://sourceforge.net/forum/message.php?msg_id=4396251
By: ktenney

2 good screencasts on making screencasts;

http://murl.se/26296
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:Video and more screen shots on Leo's web site
#@+node:ekr.20071029082025:Improve distribution
* Convert to svn  (use py_svn)
* Enable sax option.
* Proper xml namespace in .leo files.  Is this Leo 5.0??
#@nonl
#@+node:ekr.20070929125944:Emulate Orange's download philosophy
@nocolor

http://sourceforge.net/forum/message.php?msg_id=4543089
By: billp9619

from the download page:

If it's the first time you hear about Python, this is the installation for you.
The packages includes complete Orange, Python, Windows Extensions for Python
(PythonWin), Numeric Python, Qt 2.2 non-commercial, PyQt, PyQwt and GraphViz.

Leo should copy this download philosophy.



#@-node:ekr.20070929125944:Emulate Orange's download philosophy
#@+node:ekr.20070615063616.1:Create Debian package
#@-node:ekr.20070615063616.1:Create Debian package
#@-node:ekr.20071029082025:Improve distribution
#@+node:ekr.20071102191642:Other guis
#@+node:ekr.20071030191227:Emacs/Pymacs gui
#@-node:ekr.20071030191227:Emacs/Pymacs gui
#@+node:ekr.20070824093611:Improve wxGui plugin
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4480477
By: plumloco

Sorry to here about your injury, Edward. Hope its not RSI from working too hard
on Leo.  Get well soon.

When your fit and well again you might like to have a look at this.

I have been playing with custom tree widgets for leo, first with pyGTK then
with wxPython.  I had thought about doing a  pyGTK plugin until I realized how
much work was involved :)

I have adapted the __wx_gui.py plugin to work with my custom widget and called
it __wx_alt_gui.py. You, or anyone else who is interested, can download the
plugin from http://plumloco.co.uk/scratch/__wx_alt_gui.py.gz.

The great benefit of using this custom widget is that it has no secondary data
structures to keep in synch, this makes it faster and more efficient in terms
of resources. It also eliminates the problem of complicated glue code.

All that is needed is to call update whenever a change is made and the widget
will get all its data directly from the leo outline itself.  A good test for
the widget is to load a large outline and do an expand-all-nodes on it (try
the same with __wx_gui and tkLeo).

The widget still needs a lot of work but it works well enough for its usefulness
and viability to be tested.

I would be interested to know your intentions towards wxLeo.  My impression
is that you do not plan on being very active in its development, seeing as how
you are talking about doing a java swing version.

If you have no objections, I would like to do some work on wxLeo myself, partly
for its own sake and partly to gain experience for a possible pyGTK port.  Obviously
I do not want to be treading on your toes, so please tell me if I am intruding.


#@-node:ekr.20070824093611:Improve wxGui plugin
#@+node:ekr.20070703111913:Swing gui
#@-node:ekr.20070703111913:Swing gui
#@-node:ekr.20071102191642:Other guis
#@+node:ekr.20070307082503:Make Leo an IPython notebook
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20070521100324.1:Using Leo as a notebook
@nocolor
https://sourceforge.net/forum/message.php?msg_id=4314394
By: duanekaufman

I am starting a kinda 'stream-of-thought' document, one in which I can put down
a paragraph of thought (perhaps in a pretty fashion, using ReST markup), develop
some code, to do some calculations, run the code and display the results...rinse,
repeat.

The document, in pseudo-form, would look like:

<Development of thought #1>
<Code to calculate something>
<Results from code execution>
<Discussion of results>

Each of the above would probably be a node, and I have already put together
things that look like the above, all except for the <results> part. I can run
the code, but how can I get the output automatically in my node? I can cut-and-paste
from the underlying command window (I run under Linux and Windows XP), but I
would like o automate it as much as possible.

Does anyone have any ideas on how to accomodate this workflow?

------ Reply

A most interesting and important question--with such a capability one could make Leo into a full-fledged engineering notebook, e.g., as envisaged by the IPython Notebook project: 

http://projects.scipy.org/ipython/ipython/wiki/NbshellManual 

I can think of several possible approaches: 

1. Create a custom version of the execute script command that would put script output in a particular node. Perhaps the headline of the node could be an argument to the enhanced command. 

2. Have your script write to some 'standard place', and create a command to put that script in the presently selected node. Something like insert-script-output. 

3. Create a script button that executes the script in the presently selected node and puts the result in the node *following* the selected node. You can then either move the node by hand, or use another script button to move the node to a 'standard place', say the last child of the <<results>> node. 

As I write this I think the script-button approach is likely to be the simplest, most flexible and most powerful. I'll look into this myself soon... 

Edward
#@nonl
#@-node:ekr.20070521100324.1:Using Leo as a notebook
#@-node:ekr.20070307082503:Make Leo an IPython notebook
#@-node:ekr.20070923103337:Not associated with any release
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
