#@+leo-ver=4-thin
#@+node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@+all
#@+node:ekr.20061101021054:To do First
@nocolor

- It's not clear what to do about k.shortcutFromSetting.
- Move Tk tables to Tk gui.

@color
#@nonl
#@+node:ekr.20061130084909:Priorities
@nocolor

py2cpp: execute hello world c script, create mockup of desired code.

- Improve What's special whitepaper.
    - Answer the question: how can Leo help me with programming.
    
- Finish wx plugin.
#@-node:ekr.20061130084909:Priorities
#@+node:ekr.20061204120501:Fix bugs
#@+node:ekr.20061127171128:Fix wiki markup bug
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3994218
By: rich_ries

Leo 4.4.2.1 (also seen in 4.4 final)

I was commenting some code, using the markup marks for various emphases. When
I went back and moved the cursor over the first two characters (the hidden markup
characters) of the line, I got the following error message:

===========================================================
exception executing command
Traceback (most recent call last):

  File "...leoCommands.py",line 264, in doCommand
    val = command(event)

  File "...leoEditCommands.py", line 3703, in nextLine
    g.app.gui.setSelectionRange(w,'end-%dc' % (len(selected)+1),'end-1c') # works

  File "...leoEditCommands.py", line 3314, in moveUpOrDownHelper
    txt = w.get( 'insert linestart', 'insert lineend' )

TypeError: unpack non-sequence
===========================================================

I did not get this when moving the cursor over the visible characters.
#@+node:ekr.20060113105246.1:moveUpOrDownHelper (revise)
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # Make the insertion cursor visible so bbox won't return an empty list.
    w.seeInsertPoint()
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y <= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y >= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x > newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        # g.trace('row,col,moveCol',row,col,self.moveCol)
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col >= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.seeInsertPoint()
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
#@-node:ekr.20060113105246.1:moveUpOrDownHelper (revise)
#@-node:ekr.20061127171128:Fix wiki markup bug
#@+node:ekr.20061202145309:New bug: section references aren't colored properly (if no previous blank line??)
#@-node:ekr.20061202145309:New bug: section references aren't colored properly (if no previous blank line??)
#@+node:ekr.20061202145309.1:New bug: select all text in headline *still* does not work
#@-node:ekr.20061202145309.1:New bug: select all text in headline *still* does not work
#@+node:ekr.20061204120501.1:Search scripts with \n select too much
#@-node:ekr.20061204120501.1:Search scripts with \n select too much
#@-node:ekr.20061204120501:Fix bugs
#@+node:ekr.20061127170002:Requests
#@+node:ekr.20061127171616:Experiment with Kent's idea for relative paths
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4005750
By: ktenney

I like the option @string relative_path_base_directory = .

which puts @file nodes in the same directory as the current Leo file.

I would like it if 
open('file.txt','w').close()

put file.txt in the same directory as the current Leo file.

in g.getBaseDirectory I changed::
    if base and len(base) > 0 and g.os_path_isabs(base):
        return base # base need not exist yet.

to::
    if base and len(base) > 0 and g.os_path_isabs(base):
        os.chdir(base)
        return base # base need not exist yet.

it should probably be configurable::

    if base and len(base) > 0 and g.os_path_isabs(base):
        if app.config.python_cwd_is_leo_base:
            os.chdir(base)
        return base # base need not exist yet.
#@-node:ekr.20061127171616:Experiment with Kent's idea for relative paths
#@+node:ekr.20061127170002.1:Allow multiple lines on the button bar
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3993176
By: rich_ries

How can the button bar be enlarged to take a second (or third!) row of icons? Or maybe the Scripting buttons can have
their own section, like the NodeBar plugin did/does?

add-new-icon-row command?
#@nonl
#@-node:ekr.20061127170002.1:Allow multiple lines on the button bar
#@+node:ekr.20061127170820.1:Allow spaces in new filenames (a Mac problem?)
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3992390

The 'username' in the path is just edited by me: in the original error message
it is my login name, of course.

What was happening is the following. 
Yesterday I was playing with Leo 4.4.2.1 and I often could not create *new*
Leo files in certain directories.
Leo would just give me the above error message. After some experimentation,
I found out that when there was a space somewhere in the path from where I started
Leo (and planned to save the file), Leo would give me the above error message.
When the path would not contain a space, Leo would happily save the file.

Note that I only have this problem with *new* files. Leo files that have already
been created can be opened and saved everywhere.

Perhaps this is only a problem for Mac OS X, but earlier versions of Leo (and
Mac OS X) did not have this behaviour.

Theo
#@nonl
#@-node:ekr.20061127170820.1:Allow spaces in new filenames (a Mac problem?)
#@+node:ekr.20061127181712:Make sure that the uA docs mention str_ attributes (and other escapes?)
#@-node:ekr.20061127181712:Make sure that the uA docs mention str_ attributes (and other escapes?)
#@-node:ekr.20061127170002:Requests
#@+node:ekr.20061115111353:(Remove special tk indices)
@nocolor

To do:
    
- remove calls to w.search

- need wrapper for tag_remove

@color
#@nonl
#@+node:ekr.20051025071455.47:findNextWord (tkSpell)
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""

    c = self.c ; w = self.workCtrl ; s = w.getAllText() ; p = p.copy()
    while 1:
        i = w.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and g.isWordChar(s[j]):
                j += 1
            word = s[i:j]
            # g.trace(repr(word)) # This trace verifies that all words have been checked.
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w2.setSelectionRange(i,j,insert=j)
            return p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            w.delete(0,'end')
            w.insert(0,p.bodyString())
            for w2 in (w,c.frame.body.bodyCtrl):
                c.widgetWantsFocusNow(w2)
                w.setSelectionRange(0,0,insert=0)
    return None,None
#@nonl
#@-node:ekr.20051025071455.47:findNextWord (tkSpell)
#@+node:ekr.20050920084036.27:expandAbbrev
def expandAbbrev (self,event):
    
    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.'''

    k = self.k ; c = self.c ; ch = event.char.strip()
    w = self.editWidget(event)
    if not w: return

    word = w.get('insert -1c wordstart','insert -1c wordend')
    g.trace('ch',repr(ch),'word',repr(word))
    if ch:
        # We must do this: expandAbbrev is called from Alt-x and Control-x,
        # we get two differnt types of data and w states.
        word = '%s%s'% (word,ch)
        
    val = self.abbrevs.get(word)
    if val is not None:
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Typing')
        
    return val is not None
#@-node:ekr.20050920084036.27:expandAbbrev
#@+node:ekr.20050920084036.22:<< define a new generator searchXR >>
@ This is a generator (it contains a yield).
To make this work we must define a new generator for each call to regionalExpandAbbrev.
@c
def searchXR (i1,i2,ins,event):
    k = self.k
    w = self.editWidget(event)
    if not w: return

    w.tag_add('sXR',i1,i2)
    while i1:
        tr = w.tag_ranges('sXR')
        if not tr: break
        i1 = w.search(r'\w',i1,stopindex=tr[1],regexp=True)
        if i1:
            word = w.get('%s wordstart' % i1,'%s wordend' % i1)
            w.tag_delete('found')
            w.tag_add('found','%s wordstart' % i1,'%s wordend' % i1)
            w.tag_config('found',background='yellow')
            if self.abbrevs.has_key(word):
                k.setLabel('Replace %s with %s? y/n' % (word,self.abbrevs[word]))
                yield None
                if k.regXKey == 'y':
                    ind = w.index('%s wordstart' % i1)
                    w.delete('%s wordstart' % i1,'%s wordend' % i1)
                    w.insert(ind,self.abbrevs[word])
            i1 = '%s wordend' % i1
    w.mark_set('insert',ins)
    w.selection_clear()
    w.tag_delete('sXR')
    w.tag_delete('found')
    k.setLabelGrey('')
    self.k.regx = g.bunch(iter=None,key=None)
#@-node:ekr.20050920084036.22:<< define a new generator searchXR >>
#@+node:ekr.20050920084036.134:indentToCommentColumn (test)
def indentToCommentColumn (self,event):

    '''Insert whitespace to indent to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    ###i = w.index('insert lineend')
    junk,i = g.getLine(s,w.getInsertPoint()) 
    ###i1, i2 = i.split('.')
    i1,i2 = g.convertPythonIndexToRowCol(s,i)
    ###i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 < c1:
        wsn = c1- i2
        ###w.insert('insert lineend',' '*wsn)
        w.insert(i,' '*wsn)
    if i2 >= c1:
        ###w.insert('insert lineend',' ')
        w.insert(i,' ')
    ###w.mark_set('insert','insert lineend')
    w.setInsertPoint(i)
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.134:indentToCommentColumn (test)
#@+node:ekr.20050920084036.59:dynamicExpansion (to do)
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion (to do)
#@+node:ekr.20050920084036.60:dynamicExpansion2 (to do)
def dynamicExpansion2 (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)
#@-node:ekr.20050920084036.60:dynamicExpansion2 (to do)
#@+node:ekr.20050920084036.67:centerLine (pass)
def centerLine (self,event):

    '''Centers line within current fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) >= self.fillColumn: return
    
    self.beginCommand(undoType='center-line')
    n = (self.fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k > i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.67:centerLine (pass)
#@+node:ekr.20050920084036.69:centerRegion (passed)
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= self.fillColumn:
            ind = j
        else:
            n = (self.fillColumn-len(line)) / 2
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.69:centerRegion (passed)
#@+node:ekr.20050920084036.70:setFillPrefix (test)
def setFillPrefix( self, event ):
    
    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    ###txt = w.get( 'insert linestart', 'insert' )
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,junk = g.getLine(s,ins)
    txt = s[i:ins]
    self.fillPrefix = txt
#@-node:ekr.20050920084036.70:setFillPrefix (test)
#@+node:ekr.20050920084036.75:backToIndentation (test)
def backToIndentation (self,event):
    
    '''Position the point at the first non-blank character on the line.'''
    
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    ###i = w.index('insert linestart')
    s = w.getAllText()
    i = w.getInsertPoint()
    i,j = g.getLine(s,i)
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    ###i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    i2 = w.search(r'\w',i,j,regexp=True)
    ###w.mark_set('insert',i2)
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.75:backToIndentation (test)
#@+node:ekr.20050920084036.76:deleteIndentation (test)
def deleteIndentation (self,event):
    
    '''Delete indentation in the presently line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    self.beginCommand(undoType='delete-indentation')

    ###txt = w.get('insert linestart','insert lineend')
    ###txt = ' %s' % txt.lstrip()
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    txt = s[i:j].strip()
    ###w.delete('insert linestart','insert lineend +1c')
    w.delete(i,j)
    ###i = w.index('insert - 1c')
    ###w.insert('insert -1c',txt)
    w.insert(ins-1,txt)
    ###w.mark_set('insert',i)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.76:deleteIndentation (test)
#@+node:ekr.20050920084036.78:indentRelative
def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'indent-relative' ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    oldYview = w.yview()
    # Find the previous non-blank line
    i,j = g.getLine(s,ins)
    while 1:
        if i <= 0: return
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(undoType=undoType)
    try:
        k = g.skip_ws(s,i)
        ws = s[i:k]
        i2,j2 = g.getLine(s,ins)
        k = g.skip_ws(s,i2)
        line = ws + s[k:j2]
        w.delete(i2,j2)
        w.insert(i2,line)
        w.setInsertPoint(i2+len(ws))
        c.frame.body.onBodyChanged(undoType,oldSel=oldSel,oldText=s,oldYview=oldYview)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.78:indentRelative
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@+node:ekr.20050920084036.135:deleteSpaces (to do)
def deleteSpaces (self,event,insertspace=False):
    
    '''Delete all whitespace surrounding the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    self.beginCommand(undoType=undoType)

    i = w.getInsertPoint()
    wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
    if '' not in (wf,wb):
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.135:deleteSpaces (to do)
#@+node:ekr.20050920084036.77:splitLine (test)
def splitLine (self,event):
    
    '''Split a line at the cursor position.'''

    w = self.editWidget(event)
    if not w: return

    s = w.get('insert linestart','insert lineend')
    
    self.beginCommand(undoType='split-line')
    s = self.getWSString(s)
    i = w.getInsertPoint()
    w.insert(i,s + '\n')
    # w.mark_set('insert',i)
    # w.insert('insert','\n')
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.77:splitLine (test)
#@+node:ekr.20060113105246.1:moveUpOrDownHelper (revise)
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # Make the insertion cursor visible so bbox won't return an empty list.
    w.seeInsertPoint()
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y <= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y >= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x > newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        # g.trace('row,col,moveCol',row,col,self.moveCol)
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col >= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.seeInsertPoint()
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
#@-node:ekr.20060113105246.1:moveUpOrDownHelper (revise)
#@+node:ekr.20051218133207.1:forwardParagraphHelper (passed)
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1
        
    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper (passed)
#@+node:ekr.20051218133207:backwardParagraphHelper (passed)
def backwardParagraphHelper (self,event,extend):
    
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper (passed)
#@+node:ekr.20051218141237:lines (test)
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    ###self.moveToHelper(event,'insert linestart',extend=False)
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)
    
def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    ###self.moveToHelper(event,'insert linestart',extend=True)
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)
    
def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)
    
def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:lines (test)
#@+node:ekr.20050920084036.99:backwardKillParagraph (passed)
def backwardKillParagraph (self,event):
    
    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i > 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.99:backwardKillParagraph (passed)
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):
    
    '''Fill the selected paragraph'''
    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.strip()
    if txt:
        self.beginCommand(undoType='fill-paragraph')
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == 0:
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.strip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.strip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''
    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region')

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == 0:
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        ###if w.compare('insert','>',s2):
        if w.getInsertPoint() > s2:
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):
    
    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region-as-paragraph')

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20050920084036.98:killParagraph (passed)
def killParagraph (self,event):
    
    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.98:killParagraph (passed)
#@+node:ekr.20050920084036.96:extend-to-paragraph & helper (passed)
def extendToParagraph (self,event):
    
    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i > 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j < len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):
    
    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j < len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break
        
    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:extend-to-paragraph & helper (passed)
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):
    
    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j < len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break
        
    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@+node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
def indentRegion (self,event):
    w = self.editWidget(event)
    if not w: return

    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) > 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
    # self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
#@+node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
def tabIndentRegion (self,event):
    
    '''Insert a hard tab at the start of each line of the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='indent-rigidly')

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)
#@-node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
#@+node:ekr.20060417183606:moveLinesDown (pass hand test)
def moveLinesDown (self,event):
    
    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            w.focus_force()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606:moveLinesDown (pass hand test)
#@+node:ekr.20060417183606.1:moveLinesUp (pass hand test)
def moveLinesUp (self,event):
    
    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            w.focus_force()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606.1:moveLinesUp (pass hand test)
#@+node:ekr.20050920084036.110:reverseRegion
def reverseRegion (self,event):
    
    '''Reverse the order of lines in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.110:reverseRegion
#@+node:ekr.20050920084036.118:sortLines
def sortLines (self,event,which=None):
    
    '''Sort lines of the selected text by comparing the entire text of a line.
    A prefix argument means sort in descending order.'''

    c = self.c ; k = c.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):
    
    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-columns')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i <= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):
    
    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.120:sortFields
#@+node:ekr.20060529184652:swapHelper
def swapHelper (self,w,find,ftext,lind,ltext):

    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20060529184652:swapHelper
#@+node:ekr.20050920084036.122:transposeLines (pass)
def transposeLines (self,event):
    
    '''Transpose the line containing the cursor with the preceding line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    if not s.strip(): return

    i,j = g.getLine(s,ins)
    line1 = s[i:j]
    
    self.beginCommand(undoType='transpose-lines')
    
    if i == 0: # Transpose the next line.
        i2,j2 = g.getLine(s,j+1)
        line2 = s[i2:j2]
        w.delete(0,j2)
        w.insert(0,line2+line1)
        w.setInsertPoint(j2-1)
    else: # Transpose the previous line.
        i2,j2 = g.getLine(s,i-1)
        line2 = s[i2:j2]
        w.delete(i2,j)
        w.insert(i2,line1+line2)
        w.setInsertPoint(j-1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.122:transposeLines (pass)
#@+node:ekr.20050920084036.123:swapWords
def swapWords (self,event,swapspots):
    
    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return

    txt = w.get('insert wordstart','insert wordend')
    if not txt: return
    
    i = w.index('insert wordstart')
    
    self.beginCommand(undoType='swap-words')

    if len(swapspots) != 0:
        if w.compare(i,'>',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'<',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.123:swapWords
#@+node:ekr.20050920084036.180:backwardKillWord & killWord
def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20050920084036.180:backwardKillWord & killWord
#@+node:ekr.20050920084036.229:yankRectangle
def yankRectangle (self,event,killRect=None):
    
    '''Yank into the rectangle defined by the start and end of selected text.'''
    
    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    killRect = killRect or self.theKillRectangle
    if not killRect:
        k.setLabelGrey('No kill rect')
        return
        
    w,r1,r2,r3,r4 = self.beginCommand('yank-rectangle')
    
    # Change the text.
    txt = w.get('insert linestart','insert')
    txt = self.getWSString(txt)
    i = w.getInsertPoint()
    i1, i2 = i.split('.')
    i1 = int(i1)
    for z in killRect:
        txt2 = w.get('%s.0 linestart' % i1,'%s.%s' % (i1,i2))
        if len(txt2) != len(txt):
            amount = len(txt) - len(txt2)
            z = txt [-amount:] + z
        w.insert('%s.%s' % (i1,i2),z)
        if w.index('%s.0 lineend +1c' % i1) == w.index('end'):
            w.insert('%s.0 lineend' % i1,'\n')
        i1 += 1

    self.endCommand()
#@-node:ekr.20050920084036.229:yankRectangle
#@-node:ekr.20061115111353:(Remove special tk indices)
#@+node:ekr.20061116054917.4:Improve body widget
#@+node:ekr.20061114122858.2:Test for i != j in w.replace
#@-node:ekr.20061114122858.2:Test for i != j in w.replace
#@+node:ekr.20061114122858.1:Define w.name method
#@-node:ekr.20061114122858.1:Define w.name method
#@+node:ekr.20061113171540:create nullTextWidget for nullGui
#@-node:ekr.20061113171540:create nullTextWidget for nullGui
#@+node:ekr.20061116054917.5:Move gui.get/set_focus to body widget
#@-node:ekr.20061116054917.5:Move gui.get/set_focus to body widget
#@-node:ekr.20061116054917.4:Improve body widget
#@+node:ekr.20061117140836:New features
#@+node:ekr.20061116054917.3:Add 'escape \t and \n option to all find commands 
#@-node:ekr.20061116054917.3:Add 'escape \t and \n option to all find commands 
#@+node:ekr.20061110214440:Make sure all ancestors expanded when select a body editor with multiple body editors
#@-node:ekr.20061110214440:Make sure all ancestors expanded when select a body editor with multiple body editors
#@+node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
#@-node:ekr.20061108100143:Create '*open-&test.leo' command that t.bat or test.leo
#@+node:ekr.20061116054917.6:Remove blanks in calltips
#@-node:ekr.20061116054917.6:Remove blanks in calltips
#@+node:ekr.20061116064523:Make copied nodes valid Leo files
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4014079
By: ktenney

I've been looking at the Leo file format and discovered that a copied node is
nearly a valid Leo file, just add;

<globals/>
<preferences/>
<find_panel_settings/>

Would it be possible to drop the requirement for these tags or
add them when copying a node?

I think it would be nice if copied nodes were valid Leo files.
#@-node:ekr.20061116064523:Make copied nodes valid Leo files
#@-node:ekr.20061117140836:New features
#@-node:ekr.20061101021054:To do First
#@+node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20061028065955:To do first
#@+node:ekr.20061105134302:Crasher
Typed '(' in canvas pane.

Traceback (most recent call last):
  File "c:\prog\tigris-cvs\leo\src\leoCommands.py", line 268, in doCommand
    val = command(event)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 348, in showCalltips
    self.leadinWord = self.findCalltipWord(w)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 722, in findCalltipWord
    s = gui.getAllText(w)
  File "c:\prog\tigris-cvs\leo\src\leoTkinterGui.py", line 809, in getAllText
    s = w.get("1.0","end-1c") # New in 4.4.1: use end-1c.
AttributeError: Canvas instance has no attribute 'get'
#@nonl
#@-node:ekr.20061105134302:Crasher
#@+node:ekr.20061101174435:Fix clone-drag problem
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3991369
By: rich_ries

The mousal Ctrl+Left Button does NOT result in a cloning of the chosen node.
When I do a Ctrl+Left Click, the drag message is "dragged node will be moved",
and move -- not clone -- it does.

@bool allow_clone_drags = True
@bool enable_drag_messages = True
@bool look_for_control_drag_on_mouse_down = True
#@nonl
#@-node:ekr.20061101174435:Fix clone-drag problem
#@+node:ekr.20061030054124.1:Create method to encapsulate url code for bookmarks plugin
#@+node:ekr.20061030054934:Request
@nocolor

Email from Terry Brown.

I've written a simple plugin such that double clicking any 
headline in a tree with '@bookmarks' as its root will grab the 
url from the first line of the body text.

My problem is that I had to duplicate a lot of code from here:

Code-->Gui Base classes-->@thin leoFrame.py-->class 
leoTree-->tree.OnIconDoubleClick (@url)

specifically this whole piece:

@color
     if not g.doHook("@url1",c=c,p=p,v=p,url=url):
         # Note: the UNL plugin has its own notion of what a good url is.
         << check the url; return if bad >>
         << pass the url to the web browser >>
     g.doHook("@url2",c=c,p=p,v=p)
@nocolor

So I'm wondering if that could be split of to a different function, 
i.e. the first part of leoTree.OnIconDoubleClick gets the url, and 
the second part handles the url, and I want to be able to call just 
the second part.

It's important that this solution will trigger UNL if it's loaded, 
and similar animals.

So, if it's not too tricky, could the handle url part of 
leoTree.OnIconDoubleClick be split out for calling?
#@nonl
#@-node:ekr.20061030054934:Request
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        if url.lstrip().startswith('--'):
            # Get the url from the first body line.
            lines = p.bodyString().split('\n')
            url = lines and lines[0] or ''
        else:
            << stop the url after any whitespace >>
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            self.handleUrlInUrlNode(url)
        g.doHook("@url2",c=c,p=p,v=p)

    return 'break' # 11/19/06
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20061030161842:handleUrlInUrlNode
def handleUrlInUrlNode(self,url):
    
    # Note: the UNL plugin has its own notion of what a good url is.
    
    c = self.c
    # g.trace(url)
    << check the url; return if bad >>
    << pass the url to the web browser >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url or len(url) == 0:
    g.es("no url following @url")
    return

# Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@nonl
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)
    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
    else:
        import webbrowser
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()
#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20061030161842:handleUrlInUrlNode
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url) & helper
#@-node:ekr.20061030054124.1:Create method to encapsulate url code for bookmarks plugin
#@+node:ekr.20061030074731:Create standard pluginsManager.txt only if it does not exist
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3987635
By: rogererens

At present I have to go through the list in the Plugin Manager again, trying to
remember which plugins I had enabled in the previous version.

Possibly the .leoRecentFiles.txt construct analogue may be used?
#@nonl
#@-node:ekr.20061030074731:Create standard pluginsManager.txt only if it does not exist
#@+node:ekr.20061029100330.1:Better pymacs docs & examples
- Better install notes.

- Better Python scripting examples (multi-line scripts).
#@nonl
#@-node:ekr.20061029100330.1:Better pymacs docs & examples
#@+node:ekr.20061022190904:use g.globalDirectiveDict rather than leoColor.leoKeywords in at.directiveKind4
@nocolor

Having two lists for the same thing is very bad.
When this is fixed we will be able to simplify the multifile plugin.
#@nonl
#@-node:ekr.20061022190904:use g.globalDirectiveDict rather than leoColor.leoKeywords in at.directiveKind4
#@+node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061014050154.2:Binding to None clears all bindings
#@-node:ekr.20061014050154.2:Binding to None clears all bindings
#@+node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@-node:ekr.20060927173836.6:Don't abort mode if there are problems with bindings
#@+node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061015160449:log font size setting in myLeoSettings.leo are not overriding previous settings
#@-node:ekr.20061028065955.2:Fix binding nits
#@+node:ekr.20061020155051:Simplify and fix undo
#@+node:ekr.20061020155051.1:Notes
@nocolor

Several things became clearer after a short walk in the woods:

- It's a little late in the release cycle to mess with undo, so I'm going to put
off work until Leo 4.4.3. The present code is complex, and should be simplified
if possible. However, the potential for harm is too great to make substantial
change now. Given the complexity of the code, *any* change is a substantial
change :-)

- Some problems with undo may actually be just unexpected results. In
particular, undo typing should 'coalesce', only for actual typing: all other
commands that affect body text (cut, copy, yank and kill in particular) should
be independently undoable regardless of undo granularity. Thus, if you cut,
copy, yank or kill text an immediate undo command should restore the text to
what it was before those commands. This probably doesn't happen now, and that
could be the source of some (all??) undo problems.

Edward

P.S. I recently uncovered some more hard bindings in the yank command. Such
bindings must somehow be removed, and certainly are a symptom that yank does not
yet work as in Emacs. This is a separate issue from undo, so discovering this
problem actually simplifies the undo task to come.
#@-node:ekr.20061020155051.1:Notes
#@+node:ekr.20061009152210.1:yank/kill/undo do not work as expected
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3924236

Added unit tests for yank and all kill commands.

@color
#@nonl
#@+node:ekr.20061020080610:How to reproduce undo bug
@nocolor

https://sourceforge.net/forum/message.php?msg_id=3972170
By: oculog

Step 1 - add some lines...
line 1
line 2
line 3

Step 2 - cut and paste first line to the end
line 2
line 3
line 1

Step 3 - *Copy* and paste first line to the end x2
line 2
line 3
line 1
line 2
line 2

That's it!  The fourth undo doesn't work right.
#@-node:ekr.20061020080610:How to reproduce undo bug
#@+node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
class killBufferCommandsClass (baseEditCommandsClass):
    
    '''A class to manage the kill buffer.'''

    @others
#@+node:ekr.20050920084036.175: ctor & finishCreate
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    self.killBuffer = [] # May be changed in finishCreate.
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None # For interacting with system clipboard.
    self.reset = False

def finishCreate (self):
    
    baseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
    
    if self.k.useGlobalKillbuffer:
        self.killBuffer = leoKeys.keyHandlerClass.global_killbuffer
#@-node:ekr.20050920084036.175: ctor & finishCreate
#@+node:ekr.20050920084036.176: getPublicCommands
def getPublicCommands (self):
    
    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
#@-node:ekr.20050920084036.176: getPublicCommands
#@+node:ekr.20050920084036.183:addToKillBuffer
def addToKillBuffer (self,text):
    
    killKeys =(
        '<Control-k>', '<Control-w>',
        '<Alt-d>', '<Alt-Delete', '<Alt-z>', '<Delete>',
        '<Control-Alt-w>')

    k = self.k
    self.reset = True

    # g.trace(repr(text))

    if self.killBuffer and k.stroke in killKeys:
        self.killBuffer [0] = self.killBuffer [0] + text
    else:
        self.killBuffer.insert(0,text)
#@-node:ekr.20050920084036.183:addToKillBuffer
#@+node:ekr.20050920084036.181:backwardKillSentence
def backwardKillSentence (self,event):
    
    '''Kill the previous sentence.'''
    
    w = self.editWidget(event)
    if not w: return

    i = w.search('.','insert',backwards=True,stopindex='1.0')

    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='',0,i2+1) ### '1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='backward-kill-sentence')
#@-node:ekr.20050920084036.181:backwardKillSentence
#@+node:ekr.20050920084036.180:backwardKillWord & killWord
def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c
    self.beginCommand(undoType='backward-kill-word')
    c.editCommands.backwardWord(event)
    self.killWs(event)
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    c = self.c
    self.beginCommand(undoType='kill-word')
    self.kill(event,'insert wordstart','insert wordend',undoType=None)
    self.killWs(event)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20050920084036.180:backwardKillWord & killWord
#@+node:ekr.20051216151811:clearKillRing
def clearKillRing (self,event=None):
    
    '''Clear the kill ring.'''
    
    self.killBuffer = []
#@-node:ekr.20051216151811:clearKillRing
#@+node:ekr.20050920084036.185:getClipboard
def getClipboard (self,w):

    try:
        ctxt = w.selection_get(selection='CLIPBOARD')
        if not self.killBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not self.killBuffer or self.killBuffer [0] != ctxt:
                return ctxt
    except: pass

    return None
#@-node:ekr.20050920084036.185:getClipboard
#@+node:ekr.20050920084036.184:iterateKillBuffer
def iterateKillBuffer (self):

    while 1:
        if self.killBuffer:
            self.last_clipboard = None
            for z in self.killBuffer:
                if self.reset:
                    self.reset = False
                    break
                yield z
#@-node:ekr.20050920084036.184:iterateKillBuffer
#@+node:ekr.20050920084036.178:kill, killLine
def kill (self,event,frm,to,undoType=None):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.get(frm,to)
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    w.delete(frm,to)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)

def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(i,j,ins,len(s),repr(s[i:j]))
    if ins >= len(s) and g.match(s,j-1,'\n'): # Kill the trailing newline.
        i = max(0,len(s)-1)
        j = len(s)
    elif j > i+1 and g.match(s,j-1,'\n'): # Kill the line, but not the newline.
        j -= 1
    else: # Kill the newline.
        pass
    self.kill(event,i,j,undoType='kill-line')
#@-node:ekr.20050920084036.178:kill, killLine
#@+node:ekr.20050920084036.182:killRegion & killRegionSave & helper
def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)
    
def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    theRange = w.tag_ranges('sel')
    if not theRange: return
    
    s = w.get(theRange[0],theRange[-1])
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(theRange[0],theRange[-1])
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    w.clipboard_clear()
    w.clipboard_append(s)
    # self.removeRKeys(w)
#@-node:ekr.20050920084036.182:killRegion & killRegionSave & helper
#@+node:ekr.20050930095323.1:killSentence
def killSentence (self,event):
    
    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return

    i  = w.search('.','insert',stopindex='end')
    if i:
        self.beginCommand(undoType='kill-sentence')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
        i2 = g.choose(i2=='',0,i2+1) ### '1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i,undoType='kill-sentence')
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930095323.1:killSentence
#@+node:ekr.20050930100733:killWs
def killWs (self,event,undoType=None):
    
    ws = ''
    w = self.editWidget(event)
    if not w: return

    while 1:
        s = w.get('insert')
        if s in (' ','\t'):
            w.delete('insert')
            ws = ws + s
        else:
            break
   
    if ws:
        if undoType: self.beginCommand(undoType=undoType)
        self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930100733:killWs
#@+node:ekr.20050930091642.1:yank
def yank (self,event):
    
    '''Insert the next entry in the kill ring at the insert point.'''

    c = self.c ; k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        self.beginCommand(undoType='yank')
        self.reset = True
        s = clip_text or self.kbiterator.next()
        w.tag_delete('kb')
        ###w.insert(i,s,('kb'))
        w.insert(i,s) # Insert the text, marked with the 'kb' tag.
        w.tag_add('kb',w.toGuiIndex(i),w.toGuiIndex(i+len(s)))
        w.setInsertPoint(i+len(s))
        c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050930091642.1:yank
#@+node:ekr.20050930091642.2:yankPop
def yankPop (self,event):
    
    '''Replaces the just-yanked kill buffer with the contents of the previous kill buffer.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert') ; t, t1 = i.split('.')
    clip_text = self.getClipboard(w)

    if self.killBuffer or clip_text:
        if clip_text: s = clip_text
        else:         s = self.kbiterator.next()
        t1 = str(int(t1)+len(s))
        r = w.tag_ranges('kb')
        if r and r [0] == i:
            w.delete(r[0],r[-1])
        w.tag_delete('kb')
        w.insert('insert',s,('kb'))
        w.mark_set('insert',i)
#@-node:ekr.20050930091642.2:yankPop
#@+node:ekr.20050920084036.128:zapToCharacter
def zapToCharacter (self,event):
    
    '''Kill characters from the insertion point to a given character.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ',protect=True)
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        c = k.c
        ch = event and event.char
        k.resetLabel()
        k.clearState()
        if len(event.char) != 0 and not ch.isspace():
            i = w.search(ch,'insert',stopindex='end')
            if i != -1:
                s = w.get('insert','%s' % i)
                self.addToKillBuffer(s)
                w.delete('insert','%s' % i)
#@-node:ekr.20050920084036.128:zapToCharacter
#@-node:ekr.20050920084036.174:killBufferCommandsClass (add docstrings)
#@+node:EKR.20040526090701.4:undoTyping
def undoTyping (self):
    
    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so don't do this unless needed.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ("Cut","Paste",'Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.oldMiddleLines,u.newMiddleLines,
        u.oldNewlines,u.newNewlines,
        tag="undo",undoType=u.undoType)

    for v in u.dirtyVnodeList: # New in 4.4b3.
        v.t.clearDirty()

    if u.oldSel:
        c.bodyWantsFocusNow()
        i,j = u.oldSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526090701.4:undoTyping
#@+node:EKR.20040526075238.5:redoTyping
def redoTyping (self):

    u = self ; c = u.c ; current = c.currentPosition()
    w = c.frame.body.bodyCtrl

    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    elif u.undoType in ('Cut','Paste','Clear Recent Files'):
        c.frame.body.forceFullRecolor()

    self.undoRedoText(
        u.p,u.leading,u.trailing,
        u.newMiddleLines,u.oldMiddleLines,
        u.newNewlines,u.oldNewlines,
        tag="redo",undoType=u.undoType)
        
    for v in u.dirtyVnodeList:
        v.t.setDirty()
    
    if u.newSel:
        c.bodyWantsFocusNow()
        i,j = u.newSel
        w.setSelectionRange(i,j,insert=j)
    if u.yview:
        c.bodyWantsFocusNow()
        c.frame.body.setYScrollPosition(u.yview)
#@-node:EKR.20040526075238.5:redoTyping
#@+node:ekr.20031218072017.1493:undoRedoText (passed)
def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.
    
    '''Handle text undo and redo: converts _new_ text into _old_ text.'''

    u = self ; c = u.c ; w = c.frame.body.bodyCtrl
    
    << Compute the result using p's body text >>
    p.setTnodeText(result)
    w.setAllText(result)
    c.frame.body.recolor(p,incremental=False)
#@+node:ekr.20061106105812.1:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s

if u.debug_print:
    print "body:  ",body
    print "result:",result
#@-node:ekr.20061106105812.1:<< Compute the result using p's body text >>
#@-node:ekr.20031218072017.1493:undoRedoText (passed)
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20051011072903.2:copyText
def copyText (self,event=None):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    # Set the clipboard text.
    i,j = w.getSelectionRange()
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText
#@-node:ekr.20051011072903.2:copyText
#@+node:ekr.20051011072049.2:cutText
def cutText (self,event=None):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i,j = w.getSelectionRange()
    
    # Update the widget and set the clipboard text.
    s = w.get(i,j)
    if i != j:
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.forceFullRecolor()
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText
#@-node:ekr.20051011072049.2:cutText
#@+node:ekr.20051011072903.5:pasteText (passed) (contains Tk code)
def pasteText (self,event=None,middleButton=False):

    '''Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    i,j = oldSel = w.getSelectionRange()  # Returns insert point if no selection.
    oldText = w.getAllText()
    
    # print 'pasteText',i,j,middleButton,wname,repr(c.k.previousSelection)
    
    if middleButton and c.k.previousSelection is not None:
        start,end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = s1 = g.app.gui.getTextFromClipboard()
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.forceFullRecolor()
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.getAllText()
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText
#@-node:ekr.20051011072903.5:pasteText (passed) (contains Tk code)
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20061009152210.1:yank/kill/undo do not work as expected
#@-node:ekr.20061020155051:Simplify and fix undo
#@+node:ekr.20061028070132:New positions
# None of this code is part of Leo's core yet: it is all highly experimental.

# Important: the new vnode class implies that the read code must be rewritten to be similar to the opml read code.
#@nonl
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

    # g.trace("__init__", "fileCommands.__init__")
    self.c = c
    self.frame = c.frame

    self.use_new_positions = False
    
    # New positions require the sax-based read code.
    self.use_sax = self.use_new_positions or c.config.getBool('use_sax_based_read')
    
    self.nativeTnodeAttributes = ('tx',)
    self.nativeVnodeAttributes = (
        'a','descendentTnodeUnknownAttributes',
        'expanded','marks','t','tnodeList',
        # 'vtag',
    )
    self.initIvars()

def initIvars(self):

    # General
    c = self.c
    self.mFileName = ""
    self.fileDate = -1
    self.leo_file_encoding = c.config.new_leo_file_encoding
    # For reading
    self.checking = False # True: checking only: do *not* alter the outline.
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.forbiddenTnodes = []
    self.descendentUnknownAttributesDictList = []
    self.ratio = 0.5
    if self.use_sax:
        self.currentVnode = None
        self.rootVnode = None
    else:
        self.fileBuffer = None
        self.fileIndex = 0
        self.currentVnodeStack = [] # A stack of vnodes giving the current position.
        self.topVnodeStack     = [] # A stack of vnodes giving the top position.
        self.topPosition = None
    # For writing
    self.read_only = False
    self.outputFile = None
    self.openDirectory = None
    self.putCount = 0
    self.topVnode = None
    self.toString = False
    self.usingClipboard = False
    self.currentPosition = None
    # New in 3.12
    self.copiedTree = None
    self.tnodesDict = {}
        # keys are gnx strings as returned by canonicalTnodeIndex.
        # Values are gnx's.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061029093342.75:linkParentAndChildren (changed)
def linkParentAndChildren (self, parent_v, children):
    
    # if children: g.trace(parent_v,len(children))
    
    if self.use_new_positions:
        parent_v.t.links = children
    else:
        firstChild_v = children and children[0] or None
        parent_v.t._firstChild = firstChild_v
        for child in children:
            child._parent = parent_v
            
    v = parent_v
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
#@nonl
#@-node:ekr.20061029093342.75:linkParentAndChildren (changed)
#@+node:ekr.20061029093342.76:linkSiblings (changed)
def linkSiblings (self, sibs):
    
    '''Set the v._back and v._next links for all vnodes v in sibs.'''
    
    if self.use_new_positions:
        pass
    else:
        n = len(sibs)
        for i in xrange(n):
            v = sibs[i]
            v._back = (i-1 >= 0 and sibs[i-1]) or None
            v._next = (i+1 <  n and sibs[i+1]) or None
#@nonl
#@-node:ekr.20061029093342.76:linkSiblings (changed)
#@-node:ekr.20061029093342:Reading (sax)
#@+node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.5:v.__cmp__ (not used)
if 0: # not used
    def __cmp__(self,other):
        
        g.trace(self,other)
        return not (self is other) # Must return 0, 1 or -1
#@-node:ekr.20061028211424.5:v.__cmp__ (not used)
#@+node:ekr.20061028211424.6:v.__init__
def __init__ (self,t):

    assert(t)
    
    # To support ZODB the code must set v._p_changed = 1 whenever
    # v.unknownAttributes or any mutable vnode object changes.

    self.t = t # The tnode.
    self.statusBits = 0 # status bits
    
    # Structure links.
    #### self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20061028211424.6:v.__init__
#@+node:ekr.20061028211424.7:v.__repr__ & v.__str__
def __repr__ (self):
    
    if self.t:
        return "<vnode %d:'%s'>" % (id(self),self.cleanHeadString())
    else:
        return "<vnode %d:NULL tnode>" % (id(self))
        
__str__ = __repr__
#@-node:ekr.20061028211424.7:v.__repr__ & v.__str__
#@+node:ekr.20061028211424.8:v.dump (to be deleted)
def dumpLink (self,link):
    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    v = self

    if label:
        print '-'*10,label,v
    else:
        print "self    ",v.dumpLink(v)
        print "len(vnodeList)",len(v.t.vnodeList)

    print "_back   ",v.dumpLink(v._back)
    print "_next   ",v.dumpLink(v._next)
    print "_parent ",v.dumpLink(v._parent)
    print "t._child",v.dumpLink(v.t._firstChild)
    
    if 1:
        print "t",v.dumpLink(v.t)
        print "vnodeList"
        for v in v.t.vnodeList:
            print v
#@-node:ekr.20061028211424.8:v.dump (to be deleted)
#@+node:ekr.20061028211424.9:v.__hash__ (only for zodb)
if use_zodb and ZODB:
    def __hash__(self):
        return self.t.__hash__()
#@nonl
#@-node:ekr.20061028211424.9:v.__hash__ (only for zodb)
#@-node:ekr.20061028211424.4:Birth & death
#@+node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""
#@-node:ekr.20061028211424.11:v.findAtFileName (new in 4.2 b3)
#@+node:ekr.20061028211424.12:anyAtFileNodeName
def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)
#@-node:ekr.20061028211424.12:anyAtFileNodeName
#@+node:ekr.20061028211424.13:at...FileNodeName
# These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@-node:ekr.20061028211424.13:at...FileNodeName
#@+node:ekr.20061028211424.14:isAtAllNode
def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag
#@-node:ekr.20061028211424.14:isAtAllNode
#@+node:ekr.20061028211424.15:isAnyAtFileNode good
def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()
#@-node:ekr.20061028211424.15:isAnyAtFileNode good
#@+node:ekr.20061028211424.16:isAt...FileNode (vnode)
def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@-node:ekr.20061028211424.16:isAt...FileNode (vnode)
#@+node:ekr.20061028211424.17:isAtIgnoreNode
def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag
#@-node:ekr.20061028211424.17:isAtIgnoreNode
#@+node:ekr.20061028211424.18:isAtOthersNode
def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag
#@-node:ekr.20061028211424.18:isAtOthersNode
#@+node:ekr.20061028211424.19:matchHeadline
def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""
    
    v = self
    
    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')
    
    return h.startswith(pattern)
#@-node:ekr.20061028211424.19:matchHeadline
#@-node:ekr.20061028211424.10:v.Comparisons (no change)
#@+node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.22:v.back
# Compatibility routine for scripts

def back (self):

    return self._back
#@-node:ekr.20061028211424.22:v.back
#@+node:ekr.20061028211424.23:v.next
# Compatibility routine for scripts
# Used by p.findAllPotentiallyDirtyNodes.

def next (self):

    return self._next
#@-node:ekr.20061028211424.23:v.next
#@-node:ekr.20061028211424.21:Tree Traversal getters (to be deleted)
#@+node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.25:v.childIndex
def childIndex(self):
    
    v = self

    if not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back
    return n
#@-node:ekr.20061028211424.25:v.childIndex
#@+node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
def firstChild (self):
    
    return self.t._firstChild
#@-node:ekr.20061028211424.26:v.firstChild (changed for 4.2)
#@+node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
def hasChildren (self):
    
    v = self
    return v.firstChild()

hasFirstChild = hasChildren
#@-node:ekr.20061028211424.27:v.hasChildren & hasFirstChild
#@+node:ekr.20061028211424.28:v.lastChild
def lastChild (self):

    child = self.firstChild()
    while child and child.next():
        child = child.next()
    return child
#@-node:ekr.20061028211424.28:v.lastChild
#@+node:ekr.20061028211424.29:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

    child = self.firstChild()
    if not child: return None
    while n > 0 and child:
        n -= 1
        child = child.next()
    return child
#@-node:ekr.20061028211424.29:v.nthChild
#@+node:ekr.20061028211424.30:v.numberOfChildren (n)
def numberOfChildren (self):

    n = 0
    child = self.firstChild()
    while child:
        n += 1
        child = child.next()
    return n
#@-node:ekr.20061028211424.30:v.numberOfChildren (n)
#@-node:ekr.20061028211424.24:Children (to be deleted)
#@+node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.32:v.isCloned (4.2)
def isCloned (self):
    
    return len(self.t.vnodeList) > 1
#@-node:ekr.20061028211424.32:v.isCloned (4.2)
#@+node:ekr.20061028211424.33:isDirty
def isDirty (self):

    return self.t.isDirty()
#@-node:ekr.20061028211424.33:isDirty
#@+node:ekr.20061028211424.34:isExpanded
def isExpanded (self):

    return ( self.statusBits & self.expandedBit ) != 0
#@-node:ekr.20061028211424.34:isExpanded
#@+node:ekr.20061028211424.35:isMarked
def isMarked (self):

    return ( self.statusBits & vnode.markedBit ) != 0
#@-node:ekr.20061028211424.35:isMarked
#@+node:ekr.20061028211424.36:isOrphan
def isOrphan (self):

    return ( self.statusBits & vnode.orphanBit ) != 0
#@-node:ekr.20061028211424.36:isOrphan
#@+node:ekr.20061028211424.37:isSelected
def isSelected (self):

    return ( self.statusBits & vnode.selectedBit ) != 0
#@-node:ekr.20061028211424.37:isSelected
#@+node:ekr.20061028211424.38:isTopBitSet
def isTopBitSet (self):

    return ( self.statusBits & self.topBit ) != 0
#@-node:ekr.20061028211424.38:isTopBitSet
#@+node:ekr.20061028211424.39:isVisited
def isVisited (self):

    return ( self.statusBits & vnode.visitedBit ) != 0
#@-node:ekr.20061028211424.39:isVisited
#@+node:ekr.20061028211424.40:status
def status (self):

    return self.statusBits
#@-node:ekr.20061028211424.40:status
#@-node:ekr.20061028211424.31:Status Bits (no chnage)
#@+node:ekr.20061028211424.41:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.bodyString):
        s = "v.bodyString: Leo internal error: not unicode:" + repr(self.t.bodyString)
        g.es_print(s,color="red")

    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20061028211424.41:v.bodyString
#@+node:ekr.20061028211424.42:v.headString & v.cleanHeadString
def headString (self):
    
    """Return the headline string."""
    
    # This message should never be printed and we want to avoid crashing here!
    if not g.isUnicode(self.t.headString):
        s = "Leo internal error: not unicode:" + repr(self.t.headString)
        g.es_print(s,color="red")
        
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
    
    s = self.headString()
    return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@-node:ekr.20061028211424.42:v.headString & v.cleanHeadString
#@+node:ekr.20061028211424.43:v.directParents (new method in 4.2)
def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@-node:ekr.20061028211424.43:v.directParents (new method in 4.2)
#@-node:ekr.20061028211424.20:Getters (vnode)
#@+node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
# These remain in 4.2: the file read logic calls these before creating positions.
#@+node:ekr.20061028211424.45:v.detach
def detach (self):
    
    '''Return a standalone copy of a vnode,
    detached from all other nodes and with a new tnode.'''
    
    v = self
    
    # Create a completely separate tnode.
    t2 = tnode(
        bodyString=v.bodyString(),
        headString=v.headString())
    
    return vnode(t2)
#@nonl
#@-node:ekr.20061028211424.45:v.detach
#@+node:ekr.20061028211424.46:v.insertAfter
def insertAfter (self,t=None):

    """Inserts a new vnode after self"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAfter(self)

    return v
#@-node:ekr.20061028211424.46:v.insertAfter
#@+node:ekr.20061028211424.47:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of the receiver.
    The receiver must have at least n-1 children"""

    if not t:
        t = tnode(headString="NewHeadline")

    v = vnode(t)
    v.linkAsNthChild(self,n)

    return v
#@-node:ekr.20061028211424.47:v.insertAsNthChild
#@+node:ekr.20061028211424.48:v.linkAfter
def linkAfter (self,v):

    """Link self after v."""
    
    self._parent = v._parent
    self._back = v
    self._next = v._next
    v._next = self
    if self._next:
        self._next._back = self
#@-node:ekr.20061028211424.48:v.linkAfter
#@+node:ekr.20061028211424.49:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

    """Links self as the n'th child of vnode pv"""

    v = self
    # g.trace(v,pv,n)
    v._parent = pv
    if n == 0:
        v._back = None
        v._next = pv.t._firstChild
        if pv.t._firstChild:
            pv.t._firstChild._back = v
        pv.t._firstChild = v
    else:
        prev = pv.nthChild(n-1) # zero based
        assert(prev)
        v._back = prev
        v._next = prev._next
        prev._next = v
        if v._next:
            v._next._back = v
#@-node:ekr.20061028211424.49:v.linkAsNthChild
#@+node:ekr.20061028211424.50:v.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link a vnode as the root node and set the root _position_."""

    v = self

    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRoot
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot: oldRoot._back = v
#@nonl
#@-node:ekr.20061028211424.50:v.linkAsRoot
#@+node:ekr.20061028211424.51:v.moveToRoot
def moveToRoot (self,oldRoot=None):

    '''Moves a vnode to the root position.
    
    Important: oldRoot must the previous root vnode if it exists.'''

    v = self

    v.unlink()
    v.linkAsRoot(oldRoot)
    
    return v
#@nonl
#@-node:ekr.20061028211424.51:v.moveToRoot
#@+node:ekr.20061028211424.52:v.unlink
def unlink (self):

    """Unlinks a vnode from the tree."""

    v = self

    # g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)

    # Clear the links in other nodes.
    if v._back:
        v._back._next = v._next
    if v._next:
        v._next._back = v._back

    if v._parent and v == v._parent.t._firstChild:
        v._parent.t._firstChild = v._next

    # Clear the links in this node.
    v._parent = v._next = v._back = None
    # v.parentsList = []
#@nonl
#@-node:ekr.20061028211424.52:v.unlink
#@-node:ekr.20061028211424.44:v.Link/Unlink/Insert methods (used by file read logic) (not used in sax-based read)
#@+node:ekr.20061028211424.53:Setters (no change)
#@+node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.55:clearClonedBit
def clearClonedBit (self):

    self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.55:clearClonedBit
#@+node:ekr.20061028211424.56:v.clearDirty (no change needed)
def clearDirty (self):

    v = self
    v.t.clearDirty()
#@nonl
#@-node:ekr.20061028211424.56:v.clearDirty (no change needed)
#@+node:ekr.20061028211424.57:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20061028211424.57:v.clearMarked
#@+node:ekr.20061028211424.58:clearOrphan
def clearOrphan (self):

    self.statusBits &= ~ self.orphanBit
#@-node:ekr.20061028211424.58:clearOrphan
#@+node:ekr.20061028211424.59:clearVisited
def clearVisited (self):

    self.statusBits &= ~ self.visitedBit
#@-node:ekr.20061028211424.59:clearVisited
#@+node:ekr.20061028211424.60:contract & expand & initExpandedBit
def contract(self):

    self.statusBits &= ~ self.expandedBit
    
    # g.trace(self.statusBits)

def expand(self):

    self.statusBits |= self.expandedBit
    
    # g.trace(self.statusBits)

def initExpandedBit (self):

    self.statusBits |= self.expandedBit
#@-node:ekr.20061028211424.60:contract & expand & initExpandedBit
#@+node:ekr.20061028211424.61:initStatus
def initStatus (self, status):

    self.statusBits = status
#@-node:ekr.20061028211424.61:initStatus
#@+node:ekr.20061028211424.62:setClonedBit & initClonedBit
def setClonedBit (self):

    self.statusBits |= self.clonedBit

def initClonedBit (self, val):

    if val:
        self.statusBits |= self.clonedBit
    else:
        self.statusBits &= ~ self.clonedBit
#@-node:ekr.20061028211424.62:setClonedBit & initClonedBit
#@+node:ekr.20061028211424.63:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20061028211424.63:v.setMarked & initMarkedBit
#@+node:ekr.20061028211424.64:setOrphan
def setOrphan (self):

    self.statusBits |= self.orphanBit
#@-node:ekr.20061028211424.64:setOrphan
#@+node:ekr.20061028211424.65:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

    self.statusBits |= self.selectedBit
#@-node:ekr.20061028211424.65:setSelected (vnode)
#@+node:ekr.20061028211424.66:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

    self.statusBits |= self.visitedBit
#@-node:ekr.20061028211424.66:t.setVisited
#@-node:ekr.20061028211424.54: v.Status bits
#@+node:ekr.20061028211424.67:v.computeIcon & setIcon
def computeIcon (self):

    val = 0 ; v = self
    if v.t.hasBody(): val += 1
    if v.isMarked(): val += 2
    if v.isCloned(): val += 4
    if v.isDirty(): val += 8
    return val
    
def setIcon (self):

    pass # Compatibility routine for old scripts
#@-node:ekr.20061028211424.67:v.computeIcon & setIcon
#@+node:ekr.20061028211424.68:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):
    
    v = self
    s = g.toUnicode(s,encoding,reportErrors=True)
    v.t.headString = s
    
    # g.trace(g.callers(5))
#@-node:ekr.20061028211424.68:v.initHeadString
#@+node:ekr.20061028211424.69:v.setSelection
def setSelection (self, start, length):

    self.t.setSelection ( start, length )
#@-node:ekr.20061028211424.69:v.setSelection
#@+node:ekr.20061028211424.70:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
    
    return self.t.setTnodeText(s,encoding)
#@-node:ekr.20061028211424.70:v.setTnodeText
#@-node:ekr.20061028211424.53:Setters (no change)
#@-node:ekr.20061028211424:vnode class
#@+node:ekr.20061028211424.1:position class
#@+node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.2:p.__cmp__ (changed)
def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self
    
    # g.trace(p1.headString(),p2 and p2.headString())

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal
    elif p1.v == p2.v and p2._childIndex == p2._childIndex and p1.stack == p2.stack:
        return 0 # equal
    else:
        return 1 # not equal

    # # Check entire stack quickly.
    # # The stack contains vnodes, so this is not a recursive call.
    # if p1.v != p2.v or p1.stack != p2.stack:
        # return 1 # notEqual
    # # This is slow: do this last!
    # if p1.childIndex() != p2.childIndex():
        # # Disambiguate clones having the same parents.
        # return 1 # notEqual
    # return 0 # equal
#@nonl
#@-node:ekr.20061028070057.2:p.__cmp__ (changed)
#@+node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20061028070057.3:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20061028070057.4:p.__init__
def __init__ (self,v,childIndex=0,stack=None):

    '''Create a new position.'''

    # To support ZODB the code must set vort._p_changed = 1 whenever
    # t.vnodeList (or any mutable tnode or vnode object) changes.

    self.v = v
    self._childIndex = childIndex
    
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []
    
    g.app.positions += 1
    
    # Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20061028070057.4:p.__init__
#@+node:ekr.20061028070057.5:p.__nonzero__
@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None
#@-node:ekr.20061028070057.5:p.__nonzero__
#@+node:ekr.20061028070057.6:p.__str__ and p.__repr__
def __str__ (self):
    
    p = self
    
    if p.v:
        return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "<pos %d        [%d] None>" % (id(p),len(p.stack))
        
__repr__ = __str__
#@-node:ekr.20061028070057.6:p.__str__ and p.__repr__
#@+node:ekr.20061028070057.7:p.archivedPosition
def archivedPosition (self):
    
    '''Return a representation of a position suitable for use in .leo files.'''
    
    p = self
    aList = [p2.v.childIndex() for p2 in p.self_and_parents_iter()]
    aList.reverse()
    return aList
#@nonl
#@-node:ekr.20061028070057.7:p.archivedPosition
#@+node:ekr.20061028070057.8:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""

    return position(self.v,self.stack)
#@-node:ekr.20061028070057.8:p.copy
#@+node:ekr.20061028070057.9:p.dump & p.vnodeListIds
def dumpLink (self,link):

    return g.choose(link,link,"<none>")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]
#@-node:ekr.20061028070057.9:p.dump & p.vnodeListIds
#@+node:ekr.20061028070057.10:p.equal & isEqual (changed)
def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    """

    p1 = self

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack
    )
        
isEqual = equal
#@-node:ekr.20061028070057.10:p.equal & isEqual (changed)
#@+node:ekr.20061028070057.11:p.key
def key (self):
    
    p = self

    return '%s:%d.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(v)) for v in p.stack])
    )
#@-node:ekr.20061028070057.11:p.key
#@-node:ekr.20061028070057.1: ctor & other special methods...
#@+node:ekr.20061028070057.12:p.moveToX (many changes)
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
#@+node:ekr.20061028070057.13:p.moveToBack (new)
def moveToBack (self):
    
    '''Move position p to its previous sibling.'''
    
    p = self
    if p.stack and p._childIndex > 0:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex -= 1
            p.v = links[p._childIndex]
        else:
            g.trace('Can not happen: no links')
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._back
    # return p
#@nonl
#@-node:ekr.20061028070057.13:p.moveToBack (new)
#@+node:ekr.20061028070057.14:p.moveToFirstChild (new)
def moveToFirstChild (self):

    '''Move a position to it's first child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = 0
            p.v = links[0]
        else:
            p.v = None
    else:
        p.v = None
    return p

    # p = self
    # if p:
        # child = p.v.t._firstChild
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.14:p.moveToFirstChild (new)
#@+node:ekr.20061028070057.15:p.moveToLastChild (new)
def moveToLastChild (self):
    
    '''Move a position to it's last child's position.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links:
            p._childIndex = len(links)-1
            p.v = links[p._childIndex]
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # child = p.v.lastChild()
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.15:p.moveToLastChild (new)
#@+node:ekr.20061028070057.16:p.moveToLastNode (no change)
def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    while p.hasChildren():
        p.moveToLastChild()
    return p
#@-node:ekr.20061028070057.16:p.moveToLastNode (no change)
#@+node:ekr.20061028070057.17:p.moveToNext (new)
def moveToNext (self):

    '''Move position p to its next sibling.'''
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if p._childIndex + 1 < len(links):
            p._childIndex += 1
            p.v = links[p._childIndex]
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # p.v = p.v and p.v._next
    # return p
#@-node:ekr.20061028070057.17:p.moveToNext (new)
#@+node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.18:p.moveToNodeAfterTree (no change)
#@+node:ekr.20061028070057.19:p.moveToNthChild (new)
def moveToNthChild (self,n):
    
    p = self
    if p.stack:
        parent_v,junk = p.stack[-1]
        links = parent_v.t.links
        if links and n < len(links)
            p.v = links[n]
            p.childIndex = n
        else:
            p.v = None
    else:
        p.v = None
    return p
    
    # p = self
    # if p:
        # child = p.v.nthChild(n) # Must call vnode method here!
        # if child:
            # if p.isCloned():
                # p.stack.append(p.v)
            # p.v = child
        # else:
            # p.v = None
    # return p
#@-node:ekr.20061028070057.19:p.moveToNthChild (new)
#@+node:ekr.20061028070057.20:p.moveToParent (new)
def moveToParent (self):
    
    '''Move a position to its parent position.'''
    
    if p.stack:
        p.v,p._childIndex = p.stack.pop()
    else:
        p.v = None
    return p
    
    # p = self
    # if not p: return p
    # if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        # p.v = p.v._parent
    # elif p.stack:
        # p.v = p.stack.pop()
    # else:
        # p.v = None
    # return p
#@nonl
#@-node:ekr.20061028070057.20:p.moveToParent (new)
#@+node:ekr.20061028070057.21:p.moveToThreadBack (no change)
def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p
#@-node:ekr.20061028070057.21:p.moveToThreadBack (no change)
#@+node:ekr.20061028070057.22:p.moveToThreadNext (little change)
def moveToThreadNext (self):
    '''Move a position to the next a position in threading order.'''
    p = self
    if p.hasChildren():
        p.moveToFirstChild()
    elif p.hasNext()
        p.moveToNext()
    else:
        p.moveToParent()
        while p:
            if p.hasNext():
                p.moveToNext()
                break #found
            p.moveToParent()
        # not found.
    return p

# def moveToThreadNext (self):
    # """Move a position to the next a position in threading order."""
    # p = self
    # if p:
        # if p.v.t._firstChild:
            # p.moveToFirstChild()
        # elif p.v._next:
            # p.moveToNext()
        # else:
            # p.moveToParent()
            # while p:
                # if p.v._next:
                    # p.moveToNext()
                    # break #found
                # p.moveToParent()
            # # not found. 
    # return p
#@nonl
#@-node:ekr.20061028070057.22:p.moveToThreadNext (little change)
#@+node:ekr.20061028070057.23:p.moveToVisBack (no change)
def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p
#@-node:ekr.20061028070057.23:p.moveToVisBack (no change)
#@+node:ekr.20061028070057.24:p.moveToVisNext (no change)
def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p
#@-node:ekr.20061028070057.24:p.moveToVisNext (no change)
#@-node:ekr.20061028070057.12:p.moveToX (many changes)
#@+node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.27:p.Comparisons (no change)
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@-node:ekr.20061028070057.27:p.Comparisons (no change)
#@+node:ekr.20061028070057.28:p.Headline & body strings (no change)
def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
#@-node:ekr.20061028070057.28:p.Headline & body strings (no change)
#@+node:ekr.20061028070057.29:p.Status bits (no change)
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@-node:ekr.20061028070057.29:p.Status bits (no change)
#@+node:ekr.20061028070057.30:p.directParents (new, faster)
def directParents (self):
    
    p = self
    return p and p.stack or []

    # return self.v.directParents()
#@-node:ekr.20061028070057.30:p.directParents (new, faster)
#@+node:ekr.20061028070057.31:p.childIndex (new, much faster)
# This is time-critical code!

def childIndex(self):
    
    return p and p._childIndex or 0

    # p = self ; v = p.v
    # if not v or not v._back:
        # return 0
    # n = 0 ; v = v._back
    # while v:
        # n += 1
        # v = v._back
    # return n
#@nonl
#@-node:ekr.20061028070057.31:p.childIndex (new, much faster)
#@-node:ekr.20061028070057.26: vnode proxies
#@+node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.33:p.hasChildren (new)
def hasChildren(self):
    
    p = self
    
    if p.v and p.v.t:
        return len(p.v.t.links) > 0
    else:
        return False

    # return p.v and p.v.t and p.v.t._firstChild
#@-node:ekr.20061028070057.33:p.hasChildren (new)
#@+node:ekr.20061028070057.34:p.numberOfChildren (new)
def numberOfChildren (self):
    
    if p.v:
        return len(p.v.t.links)
    else:
        return 0
    
    # return self.v.numberOfChildren()
#@-node:ekr.20061028070057.34:p.numberOfChildren (new)
#@-node:ekr.20061028070057.32:children (slightly new)
#@+node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@-node:ekr.20061028070057.35:p.getX & vnode compatibility traversal routines (no change)
#@+node:ekr.20061028070057.36:p.hasX (new)
def hasBack(self):
    return self._childIndex > 0
    # return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    p = self
    if p.stack:
        parent_v,junk = self.stack[-1]
        links = parent_v.t.links
        return p._childIndex + 1 < len(parent.v.t.links)
    else:
        return False
    # return self.v and self.v._next
    
def hasParent(self):
    return len(self.stack) > 1 # The first item of each stack is the dummy parent.
    # return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack
#@-node:ekr.20061028070057.36:p.hasX (new)
#@+node:ekr.20061028070057.37:hasThreadNext (big change)
def hasThreadNext(self):
    
    p = self ; v = p.v
    if not p.v: return False

    if p.hasChildren() or p.hasNext():
        return True
    else:
        # Simulate this code without copying p.
        # p2 = p.copy()
        # p2.moveToParent()
        # while p2:
            # if p2.hasNext():
                # return True
            # p2.moveToParent()
        # return False
        if not p.stack: return False
        n = len(p.stack)-1
        v,childIndex = p.stack[n]
        n -= 1
        while n >= 0:
            # v2,childIndex2 represent v's parent.
            v2,childIndex2 = parent.stack[n]
            links = v2.t.links
            if childIndex + 1 < len(links):
                return True
            # v.moveToParent
            v,childIndex = v2,childIndex2
            n -= 1
        return False

    # p = self ; v = p.v
    # if not p.v: return False
    # if v.t._firstChild or v._next:
        # return True
    # else:
        # n = len(p.stack)-1
        # v,n = p.vParentWithStack(v,p.stack,n)
        # while v:
            # if v._next:
                # return True
            # v,n = p.vParentWithStack(v,p.stack,n)
        # return False

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20061028070057.37:hasThreadNext (big change)
#@+node:ekr.20061028070057.38:p.findRootPosition (unchanged)
def findRootPosition (self):
    
    p = self.copy()
    while p.hasParent():
        p.moveToParent()
    while p.hasBack():
        p.moveToBack()
    return p
#@nonl
#@-node:ekr.20061028070057.38:p.findRootPosition (unchanged)
#@+node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
def isAncestorOf (self, p2):
    
    p = self
    if not p.stack:
        return False
    elif p2 is None or not p2.stack:
        return False
    else:
        for v,junk in p2.stack:
            if v == p.v:
                return True
        else:
            return False
    
    # p = self
    # # Avoid calling p.copy() or copying the stack.
    # v2 = p2.v ; n = len(p2.stack)-1
        # # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # while v2:
        # if v2 == p.v:
            # return True
        # v2,n = p2.vParentWithStack(v2,p2.stack,n)
    # return False
#@nonl
#@-node:ekr.20061028070057.39:p.isAncestorOf (new)(test thoroughly)
#@+node:ekr.20061028070057.40:p.isCloned (unchanged)
def isCloned (self):
    
    return len(self.v.t.vnodeList) > 1
#@-node:ekr.20061028070057.40:p.isCloned (unchanged)
#@+node:ekr.20061028070057.41:p.isRoot (unchanged)
def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()
#@-node:ekr.20061028070057.41:p.isRoot (unchanged)
#@+node:ekr.20061028070057.42:p.isVisible (new)
def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""
    
    p = self
    for v in p.stack:
        if not v.isExpanded():
            return False
    return True

    # p = self
    # v = p.v ; n = len(p.stack)-1
    # v,n = p.vParentWithStack(v,p.stack,n)
    # while v:
        # if not v.isExpanded():
            # return False
        # v,n = p.vParentWithStack(v,p.stack,n)
    # return True
#@nonl
#@-node:ekr.20061028070057.42:p.isVisible (new)
#@+node:ekr.20061028070057.43:p.level & simpleLevel (new)
def level(self):
    return len(self.stack)
    
simpleLevel = level

# def simpleLevel(self):
    # 
    # return len([p for p in self.parents_iter()])

# def level(self,verbose=False):
    # 
    # p = self ; level = 0
    # if not p: return level
        # 
    # # Avoid calling p.copy() or copying the stack.
    # v = p.v ; n = len(p.stack)-1
    # while 1:
        # assert(p)
        # v,n = p.vParentWithStack(v,p.stack,n)
        # if v:
            # level += 1
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        # else:
            # if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # # if g.app.debug: assert(level==self.simpleLevel())
            # break
    # return level
#@-node:ekr.20061028070057.43:p.level & simpleLevel (new)
#@-node:ekr.20061028070057.25:Getters (some changes)
#@+node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@+node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)
#@-node:ekr.20061028070057.46:<< about the vParentWithStack utility method >>
#@-node:ekr.20061028070057.45:p.vParentWithStack (no longer used)
#@+node:ekr.20061028070057.47:p.restoreLinksInTree
def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    for p in root.children_iter():
        p.restoreLinksInTree()
#@-node:ekr.20061028070057.47:p.restoreLinksInTree
#@+node:ekr.20061028070057.48:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()

    # for p in root.children_iter():
        # p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20061028070057.49:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        # g.trace('**** remove p.v from %s' % p.headString())
        p.v.t.vnodeList.remove(p.v)
        p.v.t._p_changed = 1  # Support for tnode class.
        assert(p.v not in p.v.t.vnodeList)
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()
#@-node:ekr.20061028070057.49:p.deleteLinksInSubtree
#@+node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        # g.trace('**** adjust parent in %s' % p.headString())
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)
#@-node:ekr.20061028070057.50:p.adjustParentLinksInSubtree (no longer used)
#@-node:ekr.20061028070057.48:p.deleteLinksInTree & allies
#@-node:ekr.20061028070057.44:p.utils...
#@+node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@+node:ekr.20061028070057.52:p.linkAfter
def linkAfter (self,after):

    """Link self after position 'after'."""
    
    p = self
    if not after.stack:
        g.trace('Can not happen: no dummy root.',after)
        return
    
    p.stack = after.stack[:]
    p._childIndex = after._childIndex + 1 #### New
    parent_v,junk = p.stack[-1] #### New
    links = parent_v.t.links #### New
    links.insert(p._childIndex,p.v) #### New
        
    #### p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.
    
    #### p.v._back = after.v
    #### p.v._next = after.v._next
    #### after.v._next = p.v
    #### if p.v._next:
        #### p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")
#@-node:ekr.20061028070057.52:p.linkAfter
#@+node:ekr.20061028070057.53:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of parent position 'parent'."""
    
    # g.trace(self,parent,n,parent.v)

    p = self
    links = parent.v.t.links
    if n <= len(links):
        links.insert(n,p.v)
    else:
        g.trace('Can not happen: n too large.',n,p)
        return
        
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        p.v.t._p_changed = 1 # Support for tnode class.

    # # Recreate the stack using the parent.
    # p.stack = parent.stack[:]
    # if parent.isCloned():
        # p.stack.append(parent.v)
    # p.v._parent = parent.v
    # # Add v to it's tnode's vnodeList.
    # if p.v not in p.v.t.vnodeList:
        # p.v.t.vnodeList.append(p.v)
        # p.v.t._p_changed = 1 # Support for tnode class.
    # if n == 0:
        # child1 = parent.v.t._firstChild
        # p.v._back = None
        # p.v._next = child1
        # if child1:
            # child1._back = p.v
        # parent.v.t._firstChild = p.v
    # else:
        # prev = parent.nthChild(n-1) # zero based
        # assert(prev)
        # p.v._back = prev.v
        # p.v._next = prev.v._next
        # prev.v._next = p.v
        # if p.v._next:
            # p.v._next._back = p.v
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.53:p.linkAsNthChild
#@+node:ekr.20061028070057.54:p.linkAsRoot
def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    root_v,junk = p.stack[0]
    links = root_v.t.links
    p.stack = [root_v] # Clear the stack, except for the dummy root.
    links = [p.v]
    if oldRoot:
        links.append(oldRoot.v)
    
    # p.stack = [] # Clear the stack.
    # # Clear all links except the child link.
    # v._parent = None
    # v._back = None
    # v._next = oldRootVnode
    
    # Add v to it's tnode's vnodeList.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)
        v.t._p_changed = 1 # Support for tnode class.

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    # if oldRoot:
        # oldRoot.v._back = v
    # p.dump(label="root")
#@nonl
#@-node:ekr.20061028070057.54:p.linkAsRoot
#@+node:ekr.20061028070057.55:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v.t.links does NOT change."""

    p = self ; v = p.v
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
        v.t._p_changed = 1 # Support for tnode class.
    assert(v not in vnodeList)
    
    if p.stack:
        parent,junk = p.stack[-1]
        links = parent.t.links
        if v in links:
            links.remove(v)
        else:
            g.trace("Can not happen: not its father's child.",p)
    else:
        g.trace('Can not happen: missing root.',p)
    
    # Reset the firstChild link in its direct father.
    # if p.v._parent:
        # if 0: # This can fail.  I have no idea why it was present.
            # assert(p.v and p.v._parent in p.v.directParents())
        # if p.v._parent.t._firstChild == v:
            # #g.trace('resetting _parent.v.t._firstChild to',v._next)
            # p.v._parent.t._firstChild = v._next
    # else:
        # parent = p.parent()
        # if parent:
            # if 0: # This can fail.  I have no idea why it was present.
                # assert(parent.v in p.v.directParents())
            # if parent.v.t._firstChild == v:
                # #g.trace('resetting parent().v.t._firstChild to',v._next)
                # parent.v.t._firstChild = v._next
    # # Do NOT delete the links in any child nodes.
    # # Clear the links in other nodes.
    # if v._back: v._back._next = v._next
    # if v._next: v._next._back = v._back
    # # Unlink _this_ node.
    # v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20061028070057.55:p.unlink
#@-node:ekr.20061028070057.51:p.Link/Unlink methods (all new)
#@-node:ekr.20061028211424.1:position class
#@-node:ekr.20061028070132:New positions
#@-node:ekr.20061028065955:To do first
#@+node:ekr.20061028065955.3:Testing
#@+node:ekr.20061009153206:Install pylint
@nocolor


- (Problem installing the common libraries) Install pylint.
#@nonl
#@-node:ekr.20061009153206:Install pylint
#@+node:ekr.20061013082443:Unit tests for all edit commands
@nocolor

- Unit tests for forward/backward move commands.
  The must work with unicode characters.  (They do now.)

@color
#@nonl
#@+node:ekr.20061008140603:runEditCommandTest
def runEditCommandTest (c,p):
    
    u = testUtils(c) ; atTest = p.copy()
    w = c.frame.body.bodyCtrl

    h = atTest.headString()
    assert h.startswith('@test '),'expected head: %s, got: %s' % ('@test',h)
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, 'no command: %s' % (commandName)
    
    work,before,after = u.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node,h in ((work,'work'),(before,before_h),(after,after_h)):
        h2 = node.headString()
        assert h2.startswith(h),'expected head: %s, got: %s' % (h,h2)

    sels = []
    for node,h in ((before,before_h),(after,after_h)):
        sel = node.headString()[len(h):].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    sel1,sel2 = sels
    #g.trace(repr(sels))
    
    c.beginUpdate()
    try:
        c.selectPosition(work)
        c.setBodyString(work,before.bodyString())
        #g.trace(repr(sel1[0]),repr(sel1[1]))
        w.setSelectionRange(sel1[0],sel1[1],insert=sel1[1])
        c.k.simulateCommand(commandName)
        s1 = work.bodyString() ; s2 = after.bodyString()
        assert s1 == s2, 'mismatch in body\nexpected: %s\n     got: %s' % (repr(s1),repr(s2))
        sel3 = w.getSelectionRange()
        ins = w.toGuiIndex(w.getInsertPoint())
        # The selection range is specified as Tk indices.
        i,j = sel3
        #g.trace('ins',ins,'s1[j:...]',repr(s1[j:j+10]))
        i,j = w.toGuiIndex(i),w.toGuiIndex(j)
        sel3 = i,j
        assert sel2 == sel3, 'mismatch in sel\nexpected: %s\n     got: %s' % (sel2,sel3)
        c.selectPosition(atTest)
        atTest.contract()
    finally:
        c.endUpdate(False) # Don't redraw.
#@nonl
#@-node:ekr.20061008140603:runEditCommandTest
#@+node:ekr.20051214132256:begin/endCommand
#@+node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)
#@+node:ekr.20051215102349:beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
    else:
        self.undoData = None

    return w
#@-node:ekr.20051215102349:beingCommandHelper
#@-node:ekr.20051214133130:beginCommand  & beginCommandWithEvent
#@+node:ekr.20051214133130.1:endCommand
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@-node:ekr.20051214133130.1:endCommand
#@-node:ekr.20051214132256:begin/endCommand
#@+node:ekr.20050920084036.53:editCommandsClass
class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others
#@+node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.54: ctor (editCommandsClass)
def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.
    
    # Settings...
    self.autocompleteBrackets   = c.config.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = c.config.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = c.config.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = c.config.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = c.config.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = c.config.getBool('flash-matching-brackets')
    self.smartAutoIndent        = c.config.getBool('smart_auto_indent')
    
    self.initBracketMatcher(c)
#@-node:ekr.20050920084036.54: ctor (editCommandsClass)
#@+node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
def getPublicCommands (self):        

    c = self.c ; k = self.k 

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-lines':                          self.cleanLines,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'cycle-all-focus':                      self.cycleAllFocus,
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-all':                           self.selectAllText,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@-node:ekr.20050920084036.55: getPublicCommands (editCommandsClass)
#@+node:ekr.20061012113455:doNothing
def doNothing (self,event):
    
    '''A placeholder command, useful for testing bindings.'''

    # g.trace()
    pass
#@nonl
#@-node:ekr.20061012113455:doNothing
#@-node:ekr.20050929155208: birth
#@+node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051015114221:capitalizeWord & up/downCaseWord
def capitalizeWord (self,event):
    '''Capitalize the word at the cursor.'''
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    '''Convert all characters of the word at the cursor to lower case.'''
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    '''Convert all characters of the word at the cursor to UPPER CASE.'''
    self.capitalizeHelper(event,'up','upcase-word')
#@-node:ekr.20051015114221:capitalizeWord & up/downCaseWord
#@+node:ekr.20050920084036.145:changePreviousWord (not used)
def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; gui = g.app.gui
    w = self.editWidget(event)
    if not w: return

    i = w.getInsertPoint()
    self.beginCommand(undoType='change-previous-word')
    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == gui.keysym('<Alt-c>'):
        self.capitalizeWord(event)
    elif stroke == gui.keysym('<Alt-u>'):
         self.upCaseWord(event)
    elif stroke == gui.keysym('<Alt-l>'):
        self.downCaseWord(event)

    w.setInsertPoint(i)
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.145:changePreviousWord (not used)
#@+node:ekr.20051015114221.1:capitalizeHelper (passed)
def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i1 = w.getInsertPoint()
    i,j = g.getWord(s,i1)
    word = s[i:j]
    if not word.strip(): return
    
    self.beginCommand(undoType=undoType)
    
    if which == 'cap':  word = word.capitalize()
    if which == 'low':  word = word.lower()
    if which == 'up':   word = word.upper()
    
    w.delete(i,j)
    w.insert(i,word)
    w.setInsertPoint(i1)
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20051015114221.1:capitalizeHelper (passed)
#@-node:ekr.20050920084036.57:capitalization & case
#@+node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
def activateCmdsMenu    (self,event=None):
    '''Activate Leo's Cmnds menu.'''
    self.activateMenu('Cmds')

def activateEditMenu    (self,event=None):
    '''Activate Leo's Edit menu.'''
    self.activateMenu('Edit')

def activateFileMenu    (self,event=None):
    '''Activate Leo's File menu.'''
    self.activateMenu('File')

def activateHelpMenu    (self,event=None):
    '''Activate Leo's Help menu.'''
    self.activateMenu('Help')

def activateOutlineMenu (self,event=None):
    '''Activate Leo's Outline menu.'''
    self.activateMenu('Outline')

def activatePluginsMenu (self,event=None):
    '''Activate Leo's Plugins menu.'''
    self.activateMenu('Plugins')

def activateWindowMenu  (self,event=None):
    '''Activate Leo's Window menu.'''
    self.activateMenu('Window')

def activateMenu (self,menuName):
    c = self.c
    c.frame.menu.activateMenu(menuName)
#@-node:ekr.20060211100905:activate-x-menu & activateMenu (editCommandsClass)
#@+node:ekr.20051022144825.1:cycleFocus
def cycleFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''

    c = self.c ;  w = event.widget
   
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    panes = [body,log,tree]

    if w in panes:
        i = panes.index(w) + 1
        if i >= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body
    
    # Warning: traces mess up the focus
    # print g.app.gui.widget_name(w),g.app.gui.widget_name(pane)
    
    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    c.k.newMinibufferWidget = pane
#@nonl
#@-node:ekr.20051022144825.1:cycleFocus
#@+node:ekr.20060613090701:cycleAllFocus
editWidgetCount = 0
logWidgetCount = 0

def cycleAllFocus (self,event):
    
    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    c = self.c ; k = c.k
    w = event and event.widget # Does **not** require a text widget.

    pane = None ; w_name = g.app.gui.widget_name
    trace = False
    if trace: print (
        '---- w',w_name(w),id(w),
        '#tabs',c.frame.log.numberOfVisibleTabs(),
        'bodyCtrl',w_name(c.frame.body.bodyCtrl),id(c.frame.body.bodyCtrl))

    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).startswith('body'):
        n = c.frame.body.numberOfEditors
        # g.trace(self.editWidgetCount,n)
        if n > 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.bodyCtrl
            elif self.editWidgetCount > n:
                self.editWidgetCount = 0 ; self.logWidgetCount = 1
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event) ; pane = None
        else:
            self.editWidgetCount = 0 ; self.logWidgetCount = 1
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif w_name(w).startswith('log'):
        n = c.frame.log.numberOfVisibleTabs()
        if n > 1:
            self.logWidgetCount += 1
            if self.logWidgetCount == 1:
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            elif self.logWidgetCount > n:
                self.logWidgetCount = 0
                pane = c.frame.tree.canvas
            else:
                c.frame.log.cycleTabFocus()
                pane = c.frame.log.logCtrl
        else:
            self.logWidgetCount = 0
            pane = c.frame.tree.canvas
    else:
        pane = c.frame.body.bodyCtrl
        self.editWidgetCount = 1 ; self.logWidgetCount = 0
        
    if trace: print 'old: %10s new: %10s' % (w_name(w),w_name(pane))

    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)
#@nonl
#@-node:ekr.20060613090701:cycleAllFocus
#@+node:ekr.20051022144825:focusTo...
def focusToBody (self,event):
    '''Put the keyboard focus in Leo's body pane.'''
    self.c.bodyWantsFocusNow()

def focusToLog (self,event):
    '''Put the keyboard focus in Leo's log pane.'''
    self.c.logWantsFocusNow()
    
def focusToMinibuffer (self,event):
    '''Put the keyboard focus in Leo's minibuffer.'''
    self.c.minibufferWantsFocusNow()

def focusToTree (self,event):
    '''Put the keyboard focus in Leo's outline pane.'''
    self.c.treeWantsFocusNow()
#@-node:ekr.20051022144825:focusTo...
#@+node:ekr.20060211063744.1:clicks in the headline
# These call the actual event handlers so as to trigger hooks.

def clickHeadline (self,event=None):
    '''Simulate a click in the headline of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineClick(event,p=p)
    
def doubleClickHeadline (self,event=None):
    '''Simulate a double click in headline of the presently selected node.'''
    return self.clickHeadline(event)

def rightClickHeadline (self,event=None):
    '''Simulate a right click in the headline of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onHeadlineRightClick(event,p=p)
#@-node:ekr.20060211063744.1:clicks in the headline
#@+node:ekr.20060211055455:clicks in the icon box
# These call the actual event handlers so as to trigger hooks.

def clickIconBox (self,event=None):
    '''Simulate a click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):
    '''Simulate a double-click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.onIconBoxRightClick(event,p=p)
#@-node:ekr.20060211055455:clicks in the icon box
#@+node:ekr.20060211062025:clickClickBox
# Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected node.'''

    c = self.c ; p = c.currentPosition()
    c.frame.tree.onClickBoxClick(event,p=p)
#@-node:ekr.20060211062025:clickClickBox
#@+node:ekr.20060211063744.2:simulate...Drag
# These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected node.'''
    c = self.c ; p = c.currentPosition()
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected node.'''
    c = self.c
    
    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
#@-node:ekr.20060211063744.2:simulate...Drag
#@-node:ekr.20051022142249:clicks and focus (editCommandsClass)
#@+node:ekr.20051019183105:color & font
#@+node:ekr.20051019183105.1:show-colors
def showColors (self,event):
    
    '''Open a tab in the log pane showing various color pickers.'''
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    << define colors >>
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        w = log.textDict.get(tabName)
        w.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
#@+node:ekr.20051019183105.2:<< define colors >>
colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@-node:ekr.20051019183105.2:<< define colors >>
#@+node:ekr.20051019183105.3:createColorPicker
def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = g.app.gui.leoTextWidgetClass(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    << create optionMenu and callback >>
    << create picker button and callback >>
#@+node:ekr.20051019183105.4:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@-node:ekr.20051019183105.4:<< create optionMenu and callback >>
#@+node:ekr.20051019183105.5:<< create picker button and callback >>
def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
#@-node:ekr.20051019183105.5:<< create picker button and callback >>
#@-node:ekr.20051019183105.3:createColorPicker
#@-node:ekr.20051019183105.1:show-colors
#@+node:ekr.20051019201809:show-fonts & helpers
def showFonts (self,event):
    
    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        w = log.textDict.get(tabName)
        w.pack_forget()
        self.createFontPicker(f)
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
    self.createBindings()
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

self.familyBox = familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4)
sizeEntry.insert(0,'12')
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
self.sampleWidget = sample = g.app.gui.leoTextWidgetClass(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert(0,s)
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('<Return>',fontCallback)
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20060726133852:createBindings (fontPicker)
def createBindings (self):
    
    c = self.c ; k = c.k
    
    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       k.masterKeyHandler),
        ("<Escape>",    self.hideTab),
    )

    w = self.sampleWidget
    for event, callback in table:
        w.bind(event,callback)
        
    k.completeAllBindingsForWidget(w)
#@-node:ekr.20060726133852:createBindings (fontPicker)
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@-node:ekr.20051019201809.7:setFont
#@+node:ekr.20060726134339:hideTab
def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@-node:ekr.20060726134339:hideTab
#@-node:ekr.20051019201809:show-fonts & helpers
#@-node:ekr.20051019183105:color & font
#@+node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.133:setCommentColumn
def setCommentColumn (self,event):
    
    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    cc = w.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2
#@-node:ekr.20050920084036.133:setCommentColumn
#@+node:ekr.20050920084036.134:indentToCommentColumn (test)
def indentToCommentColumn (self,event):

    '''Insert whitespace to indent to the comment column.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    self.beginCommand(undoType='indent-to-comment-column')

    s = w.getAllText()
    ###i = w.index('insert lineend')
    junk,i = g.getLine(s,w.getInsertPoint()) 
    ###i1, i2 = i.split('.')
    i1,i2 = g.convertPythonIndexToRowCol(s,i)
    ###i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 < c1:
        wsn = c1- i2
        ###w.insert('insert lineend',' '*wsn)
        w.insert(i,' '*wsn)
    if i2 >= c1:
        ###w.insert('insert lineend',' ')
        w.insert(i,' ')
    ###w.mark_set('insert','insert lineend')
    w.setInsertPoint(i)
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.134:indentToCommentColumn (test)
#@-node:ekr.20050920084036.132:comment column...
#@+node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.59:dynamicExpansion (to do)
def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
#@-node:ekr.20050920084036.59:dynamicExpansion (to do)
#@+node:ekr.20050920084036.60:dynamicExpansion2 (to do)
def dynamicExpansion2 (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)
#@-node:ekr.20050920084036.60:dynamicExpansion2 (to do)
#@+node:ekr.20050920084036.61:getDynamicList (helper)
def getDynamicList (self,w,txt,rlist):

     ttext = w.getAllText()
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)
#@-node:ekr.20050920084036.61:getDynamicList (helper)
#@-node:ekr.20050920084036.58:dynamic abbreviation...
#@+node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.63:watchEscape (Revise)
def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = leoKeys.keyHandlerClass.lossage[0]
        data2 = leoKeys.keyHandlerClass.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2
        
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)
#@-node:ekr.20050920084036.63:watchEscape (Revise)
#@+node:ekr.20050920084036.64:escEvaluate (Revise)
def escEvaluate (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
#@-node:ekr.20050920084036.64:escEvaluate (Revise)
#@-node:ekr.20050920084036.62:esc methods for Python evaluation
#@+node:ekr.20050920084036.65:evalExpression
def evalExpression (self,event):
    
    '''Evaluate a Python Expression entered in the minibuffer.'''

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
#@-node:ekr.20050920084036.65:evalExpression
#@+node:ekr.20050920084036.66:fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap

after an center-region command via Alt-x.
@c

@others
#@+node:ekr.20050920084036.67:centerLine (pass)
def centerLine (self,event):

    '''Centers line within current fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) >= self.fillColumn: return
    
    self.beginCommand(undoType='center-line')
    n = (self.fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k > i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.67:centerLine (pass)
#@+node:ekr.20050920084036.68:setFillColumn
def setFillColumn (self,event):
    
    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@-node:ekr.20050920084036.68:setFillColumn
#@+node:ekr.20050920084036.69:centerRegion (passed)
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    self.beginCommand(undoType='center-region')

    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= self.fillColumn:
            ind = j
        else:
            n = (self.fillColumn-len(line)) / 2
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.69:centerRegion (passed)
#@+node:ekr.20050920084036.70:setFillPrefix (test)
def setFillPrefix( self, event ):
    
    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    ###txt = w.get( 'insert linestart', 'insert' )
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,junk = g.getLine(s,ins)
    txt = s[i:ins]
    self.fillPrefix = txt
#@-node:ekr.20050920084036.70:setFillPrefix (test)
#@+node:ekr.20050920084036.71:_addPrefix
def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@-node:ekr.20050920084036.71:_addPrefix
#@-node:ekr.20050920084036.66:fill column and centering
#@+node:ekr.20060417194232:find (quick)
#@+node:ekr.20060925151926:backward/findCharacter & helper
def backwardFindCharacter (self,event):
    return self.findCharacterHelper(event,backward=True,extend=False)
    
def backwardFindCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=True,extend=True)
    
def findCharacter (self,event):
    return self.findCharacterHelper(event,backward=False,extend=False)
    
def findCharacterExtendSelection (self,event):
    return self.findCharacterHelper(event,backward=False,extend=True)
#@nonl
#@+node:ekr.20060417194232.1:findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward ; self.extend = extend ;
        self.insert = w.index('insert')
        s = '%s character %s' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        c.frame.clearStatusLine()
        c.frame.putStatusLine(s,color='blue')
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward ; extend = self.extend
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = s.rfind('\n',0,i)
            if start == -1: start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = s.find('\n',i)
            if end == -1: end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        c.frame.clearStatusLine()
        k.clearState()
#@nonl
#@-node:ekr.20060417194232.1:findCharacterHelper
#@-node:ekr.20060925151926:backward/findCharacter & helper
#@+node:ekr.20060417194232.2:findWord (passed)
def findWord (self,event):
    
    '''Put the cursor at the next word (on a line) that starts with a character.'''

    k = self.k ; tag = 'find-word-on-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Find word: ')
        k.getArg(event,tag,1,self.findWord)
    else:        
        word = k.arg ; w = self.w ; c = k.c
        if word:
            i = w.getInsertPoint()
            s = w.getAllText()
            j = s.find('\n',i) # Limit to this line.
            if j > -1: s = s[:j]
            while i < len(s):
                if g.match_word(s,i,word) and (i == 0 or not g.isWordChar(s[i-1])):
                    w.setSelectionRange(i,i+len(word))
                    break
                else:
                    i += 1
        k.resetLabel()
        k.clearState()
#@-node:ekr.20060417194232.2:findWord (passed)
#@-node:ekr.20060417194232:find (quick)
#@+node:ekr.20050920084036.72:goto...
#@+node:ekr.20050929115226:gotoCharacter
def gotoCharacter (self,event):
    
    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929115226:gotoCharacter
#@+node:ekr.20060417181052:gotoGlobalLine
def gotoGlobalLine (self,event):
    
    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            self.c.goToLineNumber (n=int(n))
#@-node:ekr.20060417181052:gotoGlobalLine
#@+node:ekr.20050929124234:gotoLine
def gotoLine (self,event):
    
    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
#@-node:ekr.20050929124234:gotoLine
#@-node:ekr.20050920084036.72:goto...
#@+node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.75:backToIndentation (test)
def backToIndentation (self,event):
    
    '''Position the point at the first non-blank character on the line.'''
    
    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='back-to-indentation')

    ###i = w.index('insert linestart')
    s = w.getAllText()
    i = w.getInsertPoint()
    i,j = g.getLine(s,i)
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    ###i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    i2 = w.search(r'\w',i,j,regexp=True)
    ###w.mark_set('insert',i2)
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.75:backToIndentation (test)
#@+node:ekr.20050920084036.76:deleteIndentation (test)
def deleteIndentation (self,event):
    
    '''Delete indentation in the presently line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return
    
    self.beginCommand(undoType='delete-indentation')

    ###txt = w.get('insert linestart','insert lineend')
    ###txt = ' %s' % txt.lstrip()
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    txt = s[i:j].strip()
    ###w.delete('insert linestart','insert lineend +1c')
    w.delete(i,j)
    ###i = w.index('insert - 1c')
    ###w.insert('insert -1c',txt)
    w.insert(ins-1,txt)
    ###w.mark_set('insert',i)
    w.setInsertPoint(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.76:deleteIndentation (test)
#@+node:ekr.20050920084036.78:indentRelative
def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'indent-relative' ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    oldYview = w.yview()
    # Find the previous non-blank line
    i,j = g.getLine(s,ins)
    while 1:
        if i <= 0: return
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(undoType=undoType)
    try:
        k = g.skip_ws(s,i)
        ws = s[i:k]
        i2,j2 = g.getLine(s,ins)
        k = g.skip_ws(s,i2)
        line = ws + s[k:j2]
        w.delete(i2,j2)
        w.insert(i2,line)
        w.setInsertPoint(i2+len(ws))
        c.frame.body.onBodyChanged(undoType,oldSel=oldSel,oldText=s,oldYview=oldYview)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.78:indentRelative
#@-node:ekr.20050920084036.74:indent...
#@+node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')
    
def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')
    
def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')
    
def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@+node:ekr.20060417172056:addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()
    if not s: return
    
    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = g.scanDirectives(c) ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)
    self.beginCommand(undoType=undoType)
    if add:
        result = [ch + line for line in g.splitLines(s)]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in g.splitLines(s)]
    result = ''.join(result)
    
    # g.trace(w.getSelectionRange(),'len(result)',len(result))
    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
        w.insert(i,result)
        w.setSelectionRange(i,j+len(result))
    else:
        w.delete(0,'end')
        w.insert(0,result)
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20060417172056:addRemoveHelper
#@-node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
#@+node:ekr.20051026092433.1:backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):
    
    '''Delete the character to the left of the cursor.'''
    
    c = self.c ; p = c.currentPosition()
    w = self.editWidget(event)
    if not w: return
    
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    #g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = g.scanDirectives(c,p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        j = max(i,min(j,len(s)-1))
        if i != j:
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746:<< backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@-node:ekr.20051026092746:<< backspace with negative tab_width >>
#@-node:ekr.20051026092433.1:backwardDeleteCharacter
#@+node:ekr.20060415112257:clean-lines
def cleanLines (self,event):
    
    '''Removes leading whitespace from otherwise blanks lines.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return
    
    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()

    lines = [] ; changed = False
    for line in g.splitlines(s):
        if line.strip():
            lines.append(line)
        else:
            if line.endswith('\n'):
                lines.append('\n')
            changed = '\n' != line

    if changed:
        self.beginCommand(undoType='clean-lines')
        result = ''.join(lines)
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            w.delete(0,'end')
            w.insert(0,result)
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060415112257:clean-lines
#@+node:ekr.20060414085834:clearSelectedText
def clearSelectedText (self,event):
    
    '''Delete the selected text.'''
    
    c = self.c ; w = self.editWidget(event)
    if not w: return

    i,j = w.getSelectionRange()
    if i == j: return

    self.beginCommand(undoType='clear-selected-text')
    w.replace(i,j,'')
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060414085834:clearSelectedText
#@+node:ekr.20050920084036.87:deleteNextChar
def deleteNextChar (self,event):
    
    '''Delete the character to the right of the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    i,j = w.getSelectionRange()
    end = w.index('end-1c')
    
    self.beginCommand(undoType='delete-char')

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    self.endCommand(changed=changed,setLabel=False)
#@-node:ekr.20050920084036.87:deleteNextChar
#@+node:ekr.20050920084036.135:deleteSpaces (to do)
def deleteSpaces (self,event,insertspace=False):
    
    '''Delete all whitespace surrounding the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    undoType = g.choose(insertspace,'insert-space','delete-spaces')
    self.beginCommand(undoType=undoType)

    i = w.getInsertPoint()
    wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
    if '' not in (wf,wb):
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.135:deleteSpaces (to do)
#@+node:ekr.20050920084036.138:insertNewLine
def insertNewLine (self,event):
    
    '''Insert a newline at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('head'):
        self.beginCommand(undoType='insert-newline')
        w.insert('insert','\n')
        self.endCommand(changed=True,setLabel=False)

insertNewline = insertNewLine
#@-node:ekr.20050920084036.138:insertNewLine
#@+node:ekr.20050920084036.86:insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    wname = g.app.gui.widget_name(w)
    
    if not wname.startswith('head'):
        self.beginCommand(undoType='insert-newline-and-indent')
        w.insert('insert','\n\t')
        self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.86:insertNewLineAndTab
#@+node:ekr.20050920084036.139:insertParentheses
def insertParentheses (self,event):
    
    '''Insert () at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='insert-parenthesis')
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')
    self.endCommand(changed=True,setLabel=False)
#@-node:ekr.20050920084036.139:insertParentheses
#@+node:ekr.20050920084036.141:removeBlankLines (pass)
def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@-node:ekr.20050920084036.141:removeBlankLines (pass)
#@+node:ekr.20051125080855:selfInsertCommand & helpers (passed)
def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''
    
    w = self.editWidget(event)
    if not w: return 'break'
    << set local vars >>
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    # g.trace(changed)
    if changed:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
#@nonl
#@+node:ekr.20061103114242:<< set local vars >>
c = self.c
p = c.currentPosition()
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
if keysym == gui.keysym('Return'):
    ch = '\n' # This fixes the MacOS return bug.
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.bodyString() or ''
undoType = 'Typing'
trace = c.config.getBool('trace_masterCommand')
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = g.toUnicode(ch,g.app.tkEncoding) in brackets
if trace: g.trace(name,repr(ch),ch in brackets)
#@nonl
#@-node:ekr.20061103114242:<< set local vars >>
#@+node:ekr.20051026171121:insertNewlineHelper (passed)
def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.currentPosition()
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        allow_in_nocolor = c.config.getBool('autoindent_in_nocolor_mode')
        if (
            (allow_in_nocolor or c.frame.body.colorizer.useSyntaxColoring(p)) and
            undoType != "Change"
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)
    
    w.seeInsertPoint()
#@nonl
#@-node:ekr.20051026171121:insertNewlineHelper (passed)
#@+node:ekr.20060804095512:initBracketMatcher
def initBracketMatcher (self,c):

    self.openBracketsList  = c.config.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList = c.config.getString('close_flash_brackets') or ')]}'
    
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@-node:ekr.20060804095512:initBracketMatcher
#@+node:ekr.20060627083506:flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in xrange(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in xrange(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@-node:ekr.20060627083506:flashMatchingBracketsHelper
#@+node:ekr.20060627091557:flashCharacter
def flashCharacter(self,w,i):
    
    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 2
    delay   = self.bracketsFlashDelay or 75
    
    w.flashCharacter(i,bg,fg,flashes,delay)
#@-node:ekr.20060627091557:flashCharacter
#@+node:ekr.20051027172949:updateAutomatchBracket (passed)
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
                                                            
#@nonl
#@-node:ekr.20051027172949:updateAutomatchBracket (passed)
#@+node:ekr.20051026171121.1:udpateAutoIndent (passed)
def updateAutoIndent (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s[i:j]))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
#@-node:ekr.20051026171121.1:udpateAutoIndent (passed)
#@+node:ekr.20051026092433:updateTab (passed)
def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.
    

    if i != j:
        w.delete(i,j)

    if tab_width > 0:
        w.insert(i,'\t')
    else:
        # Get the preceeding characters.
        s = w.getAllText()
        start = g.skip_to_start_of_line(s,i)
        s2 = s[start:i]
        
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s2,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
#@-node:ekr.20051026092433:updateTab (passed)
#@-node:ekr.20051125080855:selfInsertCommand & helpers (passed)
#@-node:ekr.20050920084036.85:insert & delete...
#@+node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.80:howMany
def howMany (self,event):
    
    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''
    
    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@-node:ekr.20050920084036.80:howMany
#@+node:ekr.20050920084036.81:lineNumber
def lineNumber (self,event):
    
    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.getAllText()
    txt2 = w.get(0,'insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)

    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))
#@-node:ekr.20050920084036.81:lineNumber
#@+node:ekr.20050920084036.83:viewLossage
def viewLossage (self,event):
    
    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k
    
    g.es('Lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es(stroke or d.get(ch) or ch or 'None')
#@-node:ekr.20050920084036.83:viewLossage
#@+node:ekr.20050920084036.84:whatLine
def whatLine (self,event):
    
    '''Print the line number of the line containing the cursor.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)

    k.setLabel("Line %s" % i1)
#@-node:ekr.20050920084036.84:whatLine
#@-node:ekr.20050920084036.79:info...
#@+node:ekr.20050920084036.88:line...
#@+node:ekr.20050920084036.90:flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
#@-node:ekr.20050920084036.90:flushLines
#@+node:ekr.20051002095724:keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
#@-node:ekr.20051002095724:keepLines
#@+node:ekr.20050920084036.92:linesHelper
def linesHelper (self,event,pattern,which):

    k = self.k
    w = self.editWidget(event)
    if not w: return
   
    self.beginCommand(undoType=which+'-lines')
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.92:linesHelper
#@+node:ekr.20050920084036.77:splitLine (test)
def splitLine (self,event):
    
    '''Split a line at the cursor position.'''

    w = self.editWidget(event)
    if not w: return

    s = w.get('insert linestart','insert lineend')
    
    self.beginCommand(undoType='split-line')
    s = self.getWSString(s)
    i = w.getInsertPoint()
    w.insert(i,s + '\n')
    # w.mark_set('insert',i)
    # w.insert('insert','\n')
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.77:splitLine (test)
#@-node:ekr.20050920084036.88:line...
#@+node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: helpers
#@+node:ekr.20060113130510:extendHelper (passed)
def extendHelper (self,w,extend,ins1,spot,setSpot=True):

    '''Handle the details of extending the selection.
    This method is called for all cursor moves.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    extend = extend or self.extendMode
    # g.trace(ins1,spot,moveSpot,extend,setSpot)
    if extend:
        i,j = w.getSelectionRange()
        # Reset the move spot if needed.
        if (moveSpot is None or p.v.t != self.moveSpotNode or (
            i == j or # A cute trick
            (moveSpot != i and moveSpot != j)
        )):
            self.moveSpotNode = p.v.t
            self.moveSpot = ins1
            self.setMoveCol(w,ins1)
        moveSpot = self.moveSpot
        if spot < moveSpot:
            w.setSelectionRange(spot,moveSpot,insert=None)
        else:
            w.setSelectionRange(moveSpot,spot,insert=None)
    else:
        if setSpot is not None or moveSpot is None:
            self.setMoveCol(w,spot)
        w.setSelectionRange(spot,spot,insert=None)
        
    c.frame.updateStatusLine()
#@nonl
#@-node:ekr.20060113130510:extendHelper (passed)
#@+node:ekr.20060113105246.1:moveUpOrDownHelper (revise)
def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # Make the insertion cursor visible so bbox won't return an empty list.
    w.seeInsertPoint()
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y <= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y >= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x > newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        # g.trace('row,col,moveCol',row,col,self.moveCol)
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col >= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.seeInsertPoint()
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
#@-node:ekr.20060113105246.1:moveUpOrDownHelper (revise)
#@+node:ekr.20051218122116:moveToHelper (passed)
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    ins1 = w.getInsertPoint() # This may become the moveSpot.
    w.setInsertPoint(spot)
    self.extendHelper(w,extend,ins1,spot,setSpot=False)
    w.see(spot)
#@nonl
#@-node:ekr.20051218122116:moveToHelper (passed)
#@+node:ekr.20051218171457:movePastCloseHelper (revise)
def movePastCloseHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'<',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'>',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)
#@-node:ekr.20051218171457:movePastCloseHelper (revise)
#@+node:ekr.20051218121447:moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()
    
    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 <= i < n and g.isWordChar(s[i]):
                i += 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
        while 0 <= i < n and g.isWordChar(s[i]):
            i -= 1
        i += 1
    
    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218121447:moveWordHelper
#@+node:ekr.20051213094517:backSentenceHelper (revise)
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = 0
    else:
        ins = 0
    if ins:
        self.moveToHelper(event,ins,extend)
#@-node:ekr.20051213094517:backSentenceHelper (revise)
#@+node:ekr.20050920084036.137:forwardSentenceHelper (revise)
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    ins = w.getInsertPoint()
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)
#@-node:ekr.20050920084036.137:forwardSentenceHelper (revise)
#@+node:ekr.20051218133207.1:forwardParagraphHelper (passed)
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1
        
    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@-node:ekr.20051218133207.1:forwardParagraphHelper (passed)
#@+node:ekr.20051218133207:backwardParagraphHelper (passed)
def backwardParagraphHelper (self,event,extend):
    
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@nonl
#@-node:ekr.20051218133207:backwardParagraphHelper (passed)
#@+node:ekr.20060209095101:setMoveCol (passed)
def setMoveCol (self,w,spot):
    
    '''Set the column to which an up or down arrow will attempt to move.'''

    s = w.getAllText()
    i = w.toPythonIndex(spot)
    row,col = g.convertPythonIndexToRowCol(s,i)
    # g.trace('spot,i',spot,i)

    self.moveSpot = i
    self.moveCol = col
#@nonl
#@-node:ekr.20060209095101:setMoveCol (passed)
#@-node:ekr.20051218170358: helpers
#@+node:ekr.20050920084036.148:buffers (passed)
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)
    
def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
#@-node:ekr.20050920084036.148:buffers (passed)
#@+node:ekr.20051213080533:characters (passed)
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)
    
def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
#@-node:ekr.20051213080533:characters (passed)
#@+node:ekr.20051218174113:clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('Extend mode %s' % (g.choose(val,'on','off')), color='red')
    c.widgetWantsFocusNow(w)
#@-node:ekr.20051218174113:clear/set/ToggleExtendMode
#@+node:ekr.20050920084036.136:exchangePointMark (revise)
def exchangePointMark (self,event):
    
    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''
    
    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
#@-node:ekr.20050920084036.136:exchangePointMark (revise)
#@+node:ekr.20061007082956:extend-to-line (revise)
def extendToLine (self,event):
    
    '''Select the line at the cursor.'''
    
    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@-node:ekr.20061007082956:extend-to-line (revise)
#@+node:ekr.20061007214835.4:extend-to-sentence (revise)
def extendToSentence (self,event):
    
    '''Select the line at the cursor.'''
    
    c = self.c
    w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@nonl
#@-node:ekr.20061007214835.4:extend-to-sentence (revise)
#@+node:ekr.20060116074839.2:extend-to-word (revise)
def extendToWord (self,event):
    
    '''Select the word at the cursor.'''
    
    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not g.isWordChar(s[i]):
        i -= 1
    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1

    # Move to the end of the word.
    i1 = i
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)
#@nonl
#@-node:ekr.20060116074839.2:extend-to-word (revise)
#@+node:ekr.20051218141237:lines (test)
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    ###self.moveToHelper(event,'insert linestart',extend=False)
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=False)
    
def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    ###self.moveToHelper(event,'insert linestart',extend=True)
    w = self.editWidget(event)
    i,junk = g.getLine(w.getAllText(),w.getInsertPoint())
    self.moveToHelper(event,i,extend=True)
    
def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)
    
def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText()
    junk,i = g.getLine(s,w.getInsertPoint())
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)
    
def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)
    
def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)
    
def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@-node:ekr.20051218141237:lines (test)
#@+node:ekr.20050920084036.140:movePastClose (test)
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@-node:ekr.20050920084036.140:movePastClose (test)
#@+node:ekr.20050920084036.102:paragraphs
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@-node:ekr.20050920084036.102:paragraphs
#@+node:ekr.20050920084036.131:sentences
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@-node:ekr.20050920084036.131:sentences
#@+node:ekr.20050920084036.149:words
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)
    
def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)
        
def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
#@-node:ekr.20050920084036.149:words
#@-node:ekr.20050929114218:move cursor... (leoEditCommands)
#@+node:ekr.20050920084036.95:paragraph...
@others
#@+node:ekr.20050920084036.99:backwardKillParagraph (passed)
def backwardKillParagraph (self,event):
    
    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i > 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.99:backwardKillParagraph (passed)
#@+node:ekr.20050920084036.103:fillParagraph
def fillParagraph( self, event ):
    
    '''Fill the selected paragraph'''
    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.strip()
    if txt:
        self.beginCommand(undoType='fill-paragraph')
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == 0:
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.strip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.strip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.103:fillParagraph
#@+node:ekr.20050920084036.100:fillRegion
def fillRegion (self,event):

    '''Fill all paragraphs in the selected text.'''
    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region')

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == 0:
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        ###if w.compare('insert','>',s2):
        if w.getInsertPoint() > s2:
            break
        self.fillParagraph(event)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.100:fillRegion
#@+node:ekr.20050920084036.104:fillRegionAsParagraph
def fillRegionAsParagraph (self,event):
    
    '''Fill the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='fill-region-as-paragraph')

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.104:fillRegionAsParagraph
#@+node:ekr.20050920084036.98:killParagraph (passed)
def killParagraph (self,event):
    
    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.98:killParagraph (passed)
#@+node:ekr.20050920084036.96:extend-to-paragraph & helper (passed)
def extendToParagraph (self,event):
    
    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i > 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j < len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
#@+node:ekr.20050920084036.97:selectParagraphHelper
def selectParagraphHelper (self,w,start):
    
    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j < len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break
        
    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
#@-node:ekr.20050920084036.97:selectParagraphHelper
#@-node:ekr.20050920084036.96:extend-to-paragraph & helper (passed)
#@-node:ekr.20050920084036.95:paragraph...
#@+node:ekr.20050920084036.105:region...
@others
#@+node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
def indentRegion (self,event):
    w = self.editWidget(event)
    if not w: return

    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) > 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
    # self.removeRKeys(w)
#@nonl
#@-node:ekr.20050920084036.107:indentRegion (not used: use c.indentBody instead)
#@+node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
def tabIndentRegion (self,event):
    
    '''Insert a hard tab at the start of each line of the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return
    
    self.beginCommand(undoType='indent-rigidly')

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)
#@-node:ekr.20050920084036.108:tabIndentRegion (indent-rigidly)
#@+node:ekr.20050920084036.109:countRegion
def countRegion (self,event):
    
    '''Print the number of lines and characters in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))
#@-node:ekr.20050920084036.109:countRegion
#@+node:ekr.20060417183606:moveLinesDown (pass hand test)
def moveLinesDown (self,event):
    
    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j+1)
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            w.insert(i,next_line+lines)
            w.setSelectionRange(i+n2,i+n2+n,insert=i+n2+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadNext(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadNext()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            w.focus_force()
            s = w.getAllText()
            w.insert(0,lines)
            if not lines.endswith('\n'): w.insert(len(lines),'\n')
            s = w.getAllText()
            w.setSelectionRange(0,n,insert=n)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606:moveLinesDown (pass hand test)
#@+node:ekr.20060417183606.1:moveLinesUp (pass hand test)
def moveLinesUp (self,event):
    
    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    
    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    n = i2-i 
    # g.trace('lines',repr(lines))
    
    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i > 0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            w.delete(prev_i,j)
            w.insert(prev_i,lines+prev_line)
            w.setSelectionRange(prev_i,prev_i+n,insert=prev_i+n)
            changed = True
        elif g.app.gui.widget_name(w).startswith('body'):
            p = c.currentPosition()
            if not p.hasThreadBack(): return
            w.delete(i,j)
            c.setBodyString(p,w.getAllText())
            p = p.threadBack()
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            w.focus_force()
            s = w.getAllText()
            if not s.endswith('\n'): w.insert('end','\n')
            w.insert('end',lines)
            s = w.getAllText()
            ins = len(s)-len(lines)+n
            w.setSelectionRange(len(s)-len(lines),ins,insert=ins)
            changed = True
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@-node:ekr.20060417183606.1:moveLinesUp (pass hand test)
#@+node:ekr.20050920084036.110:reverseRegion
def reverseRegion (self,event):
    
    '''Reverse the order of lines in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()
    
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.110:reverseRegion
#@+node:ekr.20050920084036.111:up/downCaseRegion & helper
def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')
    
def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')
    
def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w: return

    trange = w.tag_ranges('sel')
    if len(trange) != 0:
        self.beginCommand(undoType=undoType)
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)
        self.endCommand(changed=True,setLabel=True)

    # self.removeRKeys(w)
#@-node:ekr.20050920084036.111:up/downCaseRegion & helper
#@-node:ekr.20050920084036.105:region...
#@+node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.116:scrollUp/Down/extendSelection
def scrollDown (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text down one page.'''
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    '''Extend the text selection by scrolling the body text up one page.'''
    self.scrollHelper(event,'up',extend=True)
#@+node:ekr.20060113082917:scrollHelper (passed)
def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; gui = g.app.gui
    w = gui.eventWidget(event)
    if not w: return #  This does **not** require a text widget.

    if gui.isTextWidget(w):
        c.widgetWantsFocusNow(w)
        # Remember the original insert point.  This may become the moveSpot.
        ins1 = w.getInsertPoint()
        s = w.getAllText()
        row,col = g.convertPythonIndexToRowCol(s,ins1)
        # Compute the spot.
        chng = self.measure(w) ; delta = chng [0]
        row1 = g.choose(direction=='down',row+delta,row-delta)
        row1 = max(0,row1)
        spot = g.convertRowColToPythonIndex(s,row1,col)
        # g.trace('spot',spot,'row1',row1)
        w.setInsertPoint(spot)
        self.extendHelper(w,extend,ins1,spot,setSpot=False)
        w.seeInsertPoint()
    elif gui.widget_name(w).startswith('canvas'):
        if direction=='down':
            self.scrollOutlineDownPage()
        else:
            self.scrollOutlineUpPage()
#@-node:ekr.20060113082917:scrollHelper (passed)
#@+node:ekr.20050920084036.147:measure
def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart < 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom
#@-node:ekr.20050920084036.147:measure
#@-node:ekr.20050920084036.116:scrollUp/Down/extendSelection
#@+node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    a,b = self.c.frame.treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"unit")
    
def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    a,b = self.c.frame.treeBar.get()
    if b < 1.0:
        self.c.frame.tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    a,b = self.c.frame.treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    a,b = self.c.frame.treeBar.get()
    if a > 0.0:
        self.c.frame.tree.canvas.yview_scroll(-1,"page")
#@-node:ekr.20060309060654.1:scrollOutlineUp/Down/Line/Page
#@+node:ekr.20060726154531:scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(1,"unit")
    
def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    self.c.frame.tree.canvas.xview_scroll(-1,"unit")
#@-node:ekr.20060726154531:scrollOutlineLeftRight
#@-node:ekr.20060309060654:scrolling...
#@+node:ekr.20050920084036.117:sort...
'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
#@+node:ekr.20050920084036.118:sortLines
def sortLines (self,event,which=None):
    
    '''Sort lines of the selected text by comparing the entire text of a line.
    A prefix argument means sort in descending order.'''

    c = self.c ; k = c.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-lines')
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.118:sortLines
#@+node:ekr.20050920084036.119:sortColumns
def sortColumns (self,event):
    
    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-columns')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i <= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.119:sortColumns
#@+node:ekr.20050920084036.120:sortFields
def sortFields (self,event,which=None):
    
    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    k = self.k
    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')
    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.120:sortFields
#@-node:ekr.20050920084036.117:sort...
#@+node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20060529184652:swapHelper
def swapHelper (self,w,find,ftext,lind,ltext):

    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
#@-node:ekr.20060529184652:swapHelper
#@+node:ekr.20050920084036.122:transposeLines (pass)
def transposeLines (self,event):
    
    '''Transpose the line containing the cursor with the preceding line.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    if not s.strip(): return

    i,j = g.getLine(s,ins)
    line1 = s[i:j]
    
    self.beginCommand(undoType='transpose-lines')
    
    if i == 0: # Transpose the next line.
        i2,j2 = g.getLine(s,j+1)
        line2 = s[i2:j2]
        w.delete(0,j2)
        w.insert(0,line2+line1)
        w.setInsertPoint(j2-1)
    else: # Transpose the previous line.
        i2,j2 = g.getLine(s,i-1)
        line2 = s[i2:j2]
        w.delete(i2,j)
        w.insert(i2,line1+line2)
        w.setInsertPoint(j-1)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.122:transposeLines (pass)
#@+node:ekr.20050920084036.123:swapWords
def swapWords (self,event,swapspots):
    
    '''Transpose the word at the cursor with the preceding word.'''

    w = self.editWidget(event)
    if not w: return

    txt = w.get('insert wordstart','insert wordend')
    if not txt: return
    
    i = w.index('insert wordstart')
    
    self.beginCommand(undoType='swap-words')

    if len(swapspots) != 0:
        if w.compare(i,'>',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'<',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.123:swapWords
#@+node:ekr.20060529184652.1:transposeWords (doesn't work)
def transposeWords (self,event):
    
    '''Transpose the word at the cursor with the preceding word.'''
    
    w = self.editWidget(event)
    if not w: return
    
    self.beginCommand(undoType='transpose-words')
    self.swapWords(event,self.swapSpots)
    self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20060529184652.1:transposeWords (doesn't work)
#@+node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
def swapCharacters (self,event):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    
    self.beginCommand(undoType='swap-characters')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)
    self.endCommand(changed=True,setLabel=True)

transposeCharacters = swapCharacters
#@-node:ekr.20050920084036.124:swapCharacters & transeposeCharacters
#@-node:ekr.20050920084036.121:swap/transpose...
#@+node:ekr.20050920084036.126:tabify & untabify
def tabify (self,event):
    '''Convert 4 spaces to tabs in the selected text.'''
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    '''Convert tabs to 4 spaces in the selected text.'''
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k
    w = self.editWidget(event)
    if not w: return

    if w.tag_ranges('sel'):
        self.beginCommand(undoType=which)
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)
        self.endCommand(changed=True,setLabel=True)
#@-node:ekr.20050920084036.126:tabify & untabify
#@+node:ekr.20061111223516:selectAllText (leoEditCommands)
def selectAllText (self,event):
   
    c = self.c 
    w = g.app.gui.eventWidget(event) or c.frame.body.bodyCtrl
    return w.selectAllText()
#@-node:ekr.20061111223516:selectAllText (leoEditCommands)
#@-node:ekr.20050920084036.53:editCommandsClass
#@+node:ekr.20061023104714:Failed unit tests
#@+node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')
    
def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')
    
def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')
    
def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@+node:ekr.20060417172056:addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c ; k = self.k ; w = self.editWidget(event)
    if not w: return

    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()
    if not s: return
    
    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = g.scanDirectives(c) ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)
    self.beginCommand(undoType=undoType)
    if add:
        result = [ch + line for line in g.splitLines(s)]
    else:
        result = [g.choose(line.startswith(ch),line[len(ch):],line) for line in g.splitLines(s)]
    result = ''.join(result)
    
    # g.trace(w.getSelectionRange(),'len(result)',len(result))
    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
        w.insert(i,result)
        w.setSelectionRange(i,j+len(result))
    else:
        w.delete(0,'end')
        w.insert(0,result)
    self.endCommand(changed=True,setLabel=True)

#@-node:ekr.20060417172056:addRemoveHelper
#@-node:ekr.20060417171125:addSpace/TabToLines & removeSpace/TabFromLines & helper
#@+node:ekr.20061023161510:Crasher
TclError Exception in Tk callback
  Function: <function masterBindKeyCallback at 0x01764A70> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x01A0A468>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\tigris-cvs\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1752, in __call__
    return apply(self.func, args)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 2125, in masterBindKeyCallback
    return k.masterKeyHandler(event,stroke=stroke)
  File "c:\prog\tigris-cvs\leo\src\leoKeys.py", line 3175, in masterKeyHandler
    handler(event)
  File "c:\prog\tigris-cvs\leo\src\leoEditCommands.py", line 5525, in zapToCharacter
    s = w.get('insert','%s' % i)
  File "c:\python25\lib\lib-tk\Tkinter.py", line 2962, in get
    return self.tk.call(self._w, 'get', index1, index2)
TclError: bad text index ""

================================================
  Event contents:
    char: →
    delta: 90
    height: ??
    keycode: 90
    keysym: z
    keysym_num: 122
    num: ??
    serial: 65314
    state: 4
    time: 9010246
    type: 2
    widget: .21424808.21425288.23849880.23850040.24335824.24336144.body-pane
    width: ??
    x: 485
    x_root: 805
    y: 90
    y_root: 615

#@-node:ekr.20061023161510:Crasher
#@-node:ekr.20061023104714:Failed unit tests
#@-node:ekr.20061013082443:Unit tests for all edit commands
#@-node:ekr.20061028065955.3:Testing
#@+node:ekr.20061028065955.4:Minor
#@+node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20031218072017.2820:top level (file menu)
#@+node:ekr.20031218072017.1623:new
def new (self,event=None):
    
    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot(oldRoot=None)
        c.setRootVnode(v) # New in Leo 4.4.2.
        c.editPosition(p)
    finally:
        c.endUpdate()
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
    return c # For unit test.
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open (self,event=None):
    
    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.setGlobalOpenDir(fileName)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
            
    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            g.enableIdleTimeHook(idleTimeDelay=100)
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close (self,event=None):
    
    '''Close the Leo window, prompting to save it if it has been changed.'''

    g.app.closeLeoWindow(self.frame)
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save
def save (self,event=None):
    
    '''Save a Leo outline to a file.'''

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
#@-node:ekr.20031218072017.2834:save
#@+node:ekr.20031218072017.2835:saveAs
def saveAs (self,event=None):
    
    '''Save a Leo outline to a file with a new filename.'''
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo (self,event=None):
    
    '''Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged.'''
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")
    c.bringToFront()

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert (self,event=None):
    
    '''Revert the contents of a Leo outline to last saved contents.'''
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level (file menu)
#@-node:ekr.20061002093442:Add opml support to new,open, save commands
#@+node:ekr.20060927173836.4:New move outline commands
- move-to-last-sibling
- move-to-first-sibling
#@nonl
#@-node:ekr.20060927173836.4:New move outline commands
#@+node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@-node:ekr.20060914090030:add sort-lines-ignoring-case commad
#@+node:ekr.20061024093525:Create settings menu
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3977681

How about having a menu Edit -> Settings with the submenu-items 'LeoSettings.leo',
'myLeoSettings.leo', 'this file's settings'?

The menu-items 'Open myLeoSettings.leo' and 'Open LeoSettings.leo' under the
Help-menu seem out-of-place.

#@-node:ekr.20061024093525:Create settings menu
#@-node:ekr.20061028065955.4:Minor
#@-node:ekr.20060531161030:To do: 4.4.3
#@+node:ekr.20060822174843:Most important
#@+node:ekr.20051202094427:Resolve cvs conflicts
Investigate meld:  http://meld.sourceforge.net/
#@nonl
#@+node:ekr.20060823105514:Simulate cvs conflicts by using 2 repositories simultaneously
#@-node:ekr.20060823105514:Simulate cvs conflicts by using 2 repositories simultaneously
#@+node:ekr.20060601073503:Postings
@nocolor
#@nonl
#@+node:ekr.20031218072017.658:Stepen Schaefer 1
@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
#@-node:ekr.20031218072017.658:Stepen Schaefer 1
#@+node:ekr.20050501111900:Stephen Schaefer 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."
#@nonl
#@-node:ekr.20050501111900:Stephen Schaefer 2
#@+node:ekr.20031218072017.659:Jonathon 1
@nocolor

http://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", <<bar>>
***end tnode
...<<bar>>
****begin tnode
"bar"
****end tnode

In the .leo, if I edit <<bar>>, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@verbatim
#@+leo
#@verbatim
#@+node:0::@file foo.py
#@verbatim
#@+body
#@verbatim
#@+others
#@verbatim
#@+node:1::definition of a
#@verbatim
#@+body
print "a:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"bar"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:1::definition of a
#@verbatim
#@+node:2::definition of b
#@verbatim
#@+body
print "b:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation b"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:2::definition of b
#@verbatim
#@+node:3::definition of c
#@verbatim
#@+body
print "c:", 
#@verbatim
#@<<bar>>
#@verbatim
#@+node:1::<<bar>>
#@verbatim
#@+body
"variation c"
#@verbatim
#@-body
#@verbatim
#@-node:1::<<bar>>
#@verbatim
#@-body
#@verbatim
#@-node:3::definition of c
#@verbatim
#@-others
#@verbatim
#@-body
#@verbatim
#@-node:0::@file foo.py
#@verbatim
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
#@-node:ekr.20031218072017.659:Jonathon 1
#@+node:ekr.20031218072017.660:Jonathan 2
@nocolor

By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

<<<<<<< 
blah blah blah? 
======= 
blah blah blah! 
>>>>>>> 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  
#@-node:ekr.20031218072017.660:Jonathan 2
#@+node:ekr.20031218072017.661:Gil 1
http://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
#@-node:ekr.20031218072017.661:Gil 1
#@+node:ekr.20031218072017.662:Gil 2
http://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?
#@nonl
#@-node:ekr.20031218072017.662:Gil 2
#@-node:ekr.20060601073503:Postings
#@-node:ekr.20051202094427:Resolve cvs conflicts
#@+node:ekr.20060823105514.1:Really solid perfect import
@nocolor

- Make sure whitespace is preserved properly.

- Make sure perfect import works.
#@nonl
#@-node:ekr.20060823105514.1:Really solid perfect import
#@-node:ekr.20060822174843:Most important
#@+node:ekr.20060527164612:Important 1-2 day projects
#@+node:ekr.20060531161030.1:Make body editors persistant
#@-node:ekr.20060531161030.1:Make body editors persistant
#@+node:ekr.20061006165447:Let import commands decide what kind of import to do
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3940843
By: ktenney

>the distiction between importing 'foreign' text files and importing derived
files created by Leo.

Couldn't Leo make this distinction by looking at
the file being imported? If so, I think it should.

This could eliminate a lot of confusion IMO, if
I want to bring a file into a node, just
'import' it, and the right thing happens.

An emergency measure could be available in a 
'File Special' menu.
#@nonl
#@-node:ekr.20061006165447:Let import commands decide what kind of import to do
#@+node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20050428062312:Request 1
@nocolor

By: samcollett ( Sam Collett ) 
 Compressed LEO files   
2003-01-07 16:57


Would it be possible to have a new file format that was basically a compressed
version of LEO files? Maybe using the gzip compression method. You could then
save a lot of space when you do large files. Not being a professional
programmer myself (I mainly dabble in web design - HTML and Active Server
Pages) how difficult would this be to implement? You would just output using a
different file extension so users of the older versions can still use files
with the LEO extension.
#@-node:ekr.20050428062312:Request 1
#@+node:ekr.20040226092546:Request 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2442772
By: ejoy

I made an experiment last night. I replaced the call to open()in leofilecommand.py
with a call to gzip.open().

The LeoPy.leo file saved this way is only 600K! And there is no significant
speed down in saving.

I think it is a good idea to add compression support for load/save .leo files.
When reading or writing file with name ending with ".leo.gz", leo can call gzip
module to uncompress/compress the file, saving a lot of disk space.

What do you think of this?
#@nonl
#@-node:ekr.20040226092546:Request 2
#@+node:ekr.20031218072017.2297:open (leoFileCommands)
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    if not self.use_sax: # Read the entire file into the buffer
        self.fileBuffer = theFile.read() ; theFile.close()
        self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    ok, ratio = self.getLeoFile(
        theFile,fileName,
        readAtFileNodesFlag=readAtFileNodesFlag,
        silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    if not self.use_sax: # Delete the file buffer
        self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open (leoFileCommands)
#@+node:ekr.20050428063105:newOpen (From chapters.py)
oldOpen = leoFileCommands.fileCommands.open

def newOpen( self,file,fileName,readAtFileNodesFlag=True,silent=False):

    global iscStringIO
    c = self.c
    
    if zipfile.is_zipfile( fileName ):
        iscStringIO = True
        chapters = openChaptersFile( fileName )
        g.es( str( len( chapters ) ) + " Chapters To Read", color = 'blue' )
        insertChapters( chapters, c.frame, c )
        g.es( "Finished Reading Chapters", color = 'blue' )
        iscStringIO = False
        return True

    return oldOpen(self,file,fileName,readAtFileNodesFlag,silent)
#@nonl
#@-node:ekr.20050428063105:newOpen (From chapters.py)
#@-node:ekr.20031218072017.801:Support .leo.gz or .leo.zip files
#@+node:ekr.20060530130736.2:Customize Open With menu without writing code
http://sourceforge.net/forum/message.php?msg_id=3737745

Desparately needs a way to modify the Open-With menu other than going
in and changing the code.
#@+node:ekr.20060619101345:@open-with settings
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3785897

From: Rich

Would it be possible to have the table of "Open With" editors to be part of
the config system? I find myself patching the list every time I D/L a new Leo
version to add the editor I use. This would also help isolate the user from
the "guts" of Leo, theereby being less intimidating.

Yes, it would be possible because everything in the table is a string (and not,
e.g., a reference to a method). This would require support for @open-with in
@settings trees.
#@-node:ekr.20060619101345:@open-with settings
#@-node:ekr.20060530130736.2:Customize Open With menu without writing code
#@+node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
@nocolor

Disabled these binding:

auto-complete-force         = None # This command needs work before it is useful. Ctrl-period
show-calltips-force         = None # This command needs work before it is useful. Alt-parenleft

The problem is that autocompletion depends on state: self.leadinWord,
prevObjects, etc. Thus, it's not presently possible to start the proces
anywhere. Similar remarks apply to calltips, which relies on autocompleter
state.

This is a complex problem, and not very serious now that there is an easy way of
toggling autocompleter and calltips on and off.

@color
#@nonl
#@+node:ekr.20051126123249:class autoCompleterClass
class autoCompleterClass:
    
    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.
    
    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
#@+node:ekr.20051126123759.1: ctor (autocompleter)
def __init__ (self,k):
    
    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.object = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
#@+node:ekr.20060223085549:defineClassesDict
def defineClassesDict (self):
    
    self.allClassesDict = {}
    
    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('<class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z
        
    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
#@-node:ekr.20060223085549:defineClassesDict
#@+node:ekr.20060219171914:defineObjectDict
def defineObjectDict (self):
    
    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'),    # An actual string object.
        (['c','old_c','new_c'], 'object',c),            # 'leoCommands','Commands'),
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), # 'leoTkinterFrame','leoTkinterFrame'),
        (['g'],                 'object',g),       # 'leoGlobals',None),
        (['p','p1','p2'],       'object',p),       # 'leoNodes','position'),         
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string),     # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),   # 'leoNodes','tnode'),  
        (['v','v1','v2'],       'object',p.v),     # 'leoNodes','vnode'),
        (['w','widget'],        'Tkinter','Text'),
    ]
    
    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)
    
    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        if not obj:
            g.trace('bad object',obj)
            continue
        for z in idList:
            self.objectDict[z]=obj
            # g.trace(obj)
#@-node:ekr.20060219171914:defineObjectDict
#@-node:ekr.20051126123759.1: ctor (autocompleter)
#@+node:ekr.20060219103046:Top level
#@+node:ekr.20051126122952.1:autoComplete
def autoComplete (self,event=None,force=False):
    
    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k
    w = event and event.widget or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)
    
    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.currentPosition())
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
#@-node:ekr.20051126122952.1:autoComplete
#@+node:ekr.20060219103822:autoCompleteForce
def autoCompleteForce (self,event=None):
    
    '''Show autocompletion, even if autocompletion is not presently enabled.'''
    
    return self.autoComplete(event,force=True)
#@-node:ekr.20060219103822:autoCompleteForce
#@+node:ekr.20051126124705:autoCompleterStateHandler
def autoCompleterStateHandler (self,event):
    
    c = self.c ; k = self.k
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = event and event.keysym
    ch = event and event.char or ''
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in ('space','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == 'period':
        self.chain()
    elif keysym == 'question':
        self.info()
    elif keysym == 'exclam':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
#@-node:ekr.20051126124705:autoCompleterStateHandler
#@+node:ekr.20060219170612:enable/disable/toggleAutocompleter/Calltips
def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()
    
def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()
    
def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()
    
def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()
    
def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()
    
def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@-node:ekr.20060219170612:enable/disable/toggleAutocompleter/Calltips
#@+node:ekr.20060219103046.1:showCalltips
def showCalltips (self,event=None,force=False):
    
    '''Show the calltips at the cursor.'''
    
    c = self.c ; k = c.k
    
    w = event and event.widget or c.get_focus()
    
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = g.app.gui.getSelectionRange(w)
        self.selectedText = g.app.gui.getSelectedText(w)
        self.leadinWord = self.findCalltipWord(w)
        self.object = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)
        
    return 'break'
#@-node:ekr.20060219103046.1:showCalltips
#@+node:ekr.20060219170043:showCalltipsForce
def showCalltipsForce (self,event=None):
    
    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''
    
    return self.showCalltips(event,force=True)
#@-node:ekr.20060219170043:showCalltipsForce
#@+node:ekr.20060609171919:showAutocompleter/CalltipsStatus
def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''
    
    k = self.k
    
    if 1:
        g.es('Autocompleter %s' % (g.choose(k.enable_autocompleter,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Autocompleter ',color='blue')
        frame.putStatusLine(g.choose(k.enable_autocompleter,'On','Off'))
    
def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    if 1:
        g.es('Calltips %s' % (g.choose(k.enable_calltips,'On','Off')),color='red')
    else:
        frame = k.c.frame
        frame.clearStatusLine()
        frame.putStatusLine('Calltips ',color='blue')
        frame.putStatusLine(g.choose(k.enable_calltips,'On','Off'))
#@nonl
#@-node:ekr.20060609171919:showAutocompleter/CalltipsStatus
#@-node:ekr.20060219103046:Top level
#@+node:ekr.20060216160332.2:Helpers
#@+node:ekr.20051127105431:abort & exit
def abort (self):
    
    k = self.k
    k.keyboardQuit(event=None)
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.
    
    c = self.c ; w = self.widget
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = g.app.gui.getSelectionRange(w)
    if restore:
        w.delete(i,j)
        w.insert(i,self.selectedText)
    g.app.gui.setSelectionRange(w,j,j,insert=j)
    
    self.clear()
    self.object = None
#@-node:ekr.20051127105431:abort & exit
#@+node:ekr.20060219180034:append/begin/popTabName
def appendTabName (self,word):
    
    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')
    
def clearTabName (self):
    
    self.setTabName('AutoComplete ')
    
def popTabName (self):
    
    s = self.tabName
    i = s.rfind('.',0,-1)
    if i > -1:
        self.setTabName(s[0:i])
    
# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)
#@-node:ekr.20060219180034:append/begin/popTabName
#@+node:ekr.20060221131304:appendToKnownObjects
def appendToKnownObjects (self,obj):
    
    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
#@-node:ekr.20060221131304:appendToKnownObjects
#@+node:ekr.20060220110302:calltip (changed)
def calltip (self,obj=None):
    
    c = self.c ; w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        << try to set s from a Python global function >>

    if not s:
        << get s using inspect >>
        
    << remove 'self' from s, but not from args >>
    if isStringMethod:
        << remove 's' from s *and* args >>

    s = s.rstrip(')') # Convenient.
    << insert the text and set j1 and j2 >>

    # End autocompletion mode, restoring the selection.
    self.finish()
    c.widgetWantsFocusNow(w)
    g.app.gui.setSelectionRange(w,j1,j2,insert=j2)
    << put the status line >>
#@+node:ekr.20060224103829:<< try to set s from a Python global function >>
# The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i > -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
#@-node:ekr.20060224103829:<< try to set s from a Python global function >>
#@+node:ekr.20060224103829.1:<< get s using inspect >>
isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    # g.es('inspect failed:',repr(obj))
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
#@-node:ekr.20060224103829.1:<< get s using inspect >>
#@+node:ekr.20060224103829.2:<< remove 'self' from s, but not from args >>
if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
#@-node:ekr.20060224103829.2:<< remove 'self' from s, but not from args >>
#@+node:ekr.20060224103829.3:<< remove 's' from s *and* args >>
if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
#@-node:ekr.20060224103829.3:<< remove 's' from s *and* args >>
#@+node:ekr.20060224103829.4:<< insert the text and set j1 and j2 >> (changed)
if g.app.gui.hasSelection(w):
    i,j = g.app.gui.getSelectionRange(w)
else:
    i = j = g.app.gui.getInsertPoint(w)
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')

if 1:
    j1 = w.index('%s + 1c' % j)
    j2 = w.index('%s + %sc' % (j,len(s)))
else:
    j1 = j2 = w.index('%s + 2c' % j)
#@-node:ekr.20060224103829.4:<< insert the text and set j1 and j2 >> (changed)
#@+node:ekr.20060224103829.5:<< put the status line >>
c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
#@-node:ekr.20060224103829.5:<< put the status line >>
#@-node:ekr.20060220110302:calltip (changed)
#@+node:ekr.20060220085402:chain
def chain (self):
    
    c = self.c ; w = self.widget
    word = g.app.gui.getSelectedText(w)
    old_obj = self.object

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.object = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.object = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = g.app.gui.getInsertPoint(w)
        g.app.gui.setSelectionRange(w,i,i,insert=i)
        # g.trace('chaining to',word,self.object)
        # Similar to start logic.
        self.prefix = ''
        self.selection = g.app.gui.getSelectionRange(w)
        self.selectedText = g.app.gui.getSelectedText(w)
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
#@-node:ekr.20060220085402:chain
#@+node:ekr.20051126123149:computeCompletionList
def computeCompletionList (self,verbose=False):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) < 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList
       
    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        g.es('%s' % (name),tabName=self.tabName)
#@-node:ekr.20051126123149:computeCompletionList
#@+node:ekr.20051126131103:doBackSpace (autocompleter) (changed)
def doBackSpace (self):

    '''Cut back to previous prefix.'''
    
    # g.trace(self.prefix,self.object,self.prevObjects)
    
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.object:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.object
        # g.trace(self.object,obj)
        w = self.widget
        i,j = g.app.gui.getSelectionRange(w)
        ch = w.get(i+'-1c')
        # g.trace(ch)
        if ch == '.':
            self.object = obj
            w.delete(i+'-1c')
            i = w.index(i+'-1c wordstart')
            j = w.index(i+' wordend')
            word = w.get(i,j)
            g.app.gui.setSelectionRange(w,i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()
#@-node:ekr.20051126131103:doBackSpace (autocompleter) (changed)
#@+node:ekr.20051126123249.1:doTabCompletion
def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex >= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
#@-node:ekr.20051126123249.1:doTabCompletion
#@+node:ekr.20051127065601:extendSelection (changed)
def extendSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
    else:
        i = j = g.app.gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    g.app.gui.setSelectionRange(w,i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')
#@-node:ekr.20051127065601:extendSelection (changed)
#@+node:ekr.20060221104137:findAnchor (changed)
def findAnchor (self,w):
    
    i = g.app.gui.getInsertPoint(w)
    
    while w.get(i + '-1c') == '.' and w.compare(i,'>','1.0'):
        i = w.index(i + '-2c wordstart')

    j = w.index(i+' wordend')
    word = w.get(i,j)
    
    if word == '.': word = None
    
    # g.trace(i,j,repr(word),w.get(j))
    return j,word
#@-node:ekr.20060221104137:findAnchor (changed)
#@+node:ekr.20060224094501:findCalltipWord (changed)
def findCalltipWord (self,w):
    
    i = g.app.gui.getInsertPoint(w)
    
    if w.compare(i,'>','1.0'):
        return w.get(i+'-1c wordstart',i+'-1c wordstart wordend')
    else:
        return ''
#@-node:ekr.20060224094501:findCalltipWord (changed)
#@+node:ekr.20051127105102:finish
def finish (self):
    
    c = self.c ; k = self.k
    
    k.keyboardQuit(event=None)
    
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
        
    c.frame.body.onBodyChanged('Typing')
    self.clear()
    self.object = None
#@-node:ekr.20051127105102:finish
#@+node:ekr.20060223081914:getAttr and hasAttr
# The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):
    
    '''Simulate getattr function, regardless of langauge.'''
    
    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):
    
    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
#@-node:ekr.20060223081914:getAttr and hasAttr
#@+node:ekr.20060219111416:getLeadinWord (changed)
def getLeadinWord (self,w):
    
    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = g.app.gui.getInsertPoint(w)
    start = w.index(start+'-1c')
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    
    # g.trace(word,self.object,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.object:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while w.compare(i,'<',start):
            if w.get(i) != '.':
                g.trace('oops: %s' % (repr(w.get(i))))
                return False
            i = w.index(i+'+1c')
            j = w.index(i+' wordend')
            word = w.get(i,j)
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.object:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
#@-node:ekr.20060219111416:getLeadinWord (changed)
#@+node:ekr.20060219174642:getMembersList
def getMembersList (self,obj):
    
    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
#@-node:ekr.20060219174642:getMembersList
#@+node:ekr.20060220132026:info
def info (self):
    
    c = self.c ; doc = None ; obj = self.object ; w = self.widget

    word = g.app.gui.getSelectedText(w)
    
    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word): return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es(doc,tabName='Info')
#@-node:ekr.20060220132026:info
#@+node:ekr.20060220104902:insertNormalChar
def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget ; gui = g.app.gui

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = gui.getSelectedText(w) + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = g.app.gui.getSelectedText(w)
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = gui.getSelectedText(w)
        if keysym == gui.keysym('parenleft'):
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
#@-node:ekr.20060220104902:insertNormalChar
#@+node:ekr.20060222092243:push, pop, clear, stackNames
def push (self,obj):
    
    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())
        
def pop (self):
    
    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj
    
def clear (self):
    
    self.prevObjects = []
    # g.trace(g.callers())
    
def stackNames (self):
    
    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
#@-node:ekr.20060222092243:push, pop, clear, stackNames
#@+node:ekr.20060221112937:setObjectAndMembersList & helpers
def setObjectAndMembersList (self,word):
    
    c = self.c
    
    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.object = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.object)
        self.object = 'aString'
        self.membersList = self.getMembersList(self.object)
    elif self.object:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.object,len(self.membersList))
#@+node:ekr.20060223124014:getObjectFromAttribute
def getObjectFromAttribute (self,word):
    
    obj = self.object

    if obj and self.hasAttr(obj,word):
        self.push(self.object)
        self.object = self.getAttr(obj,word)
        self.appendToKnownObjects(self.object)
        self.membersList = self.getMembersList(self.object)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.object = None
#@-node:ekr.20060223124014:getObjectFromAttribute
#@+node:ekr.20060223124014.2:completeSelf
def completeSelf (self):
    
    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.object = None
        self.clear()
        self.membersList = []
#@-node:ekr.20060223124014.2:completeSelf
#@+node:ekr.20060223124014.3:completeFromObject
def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.object = None
        self.clear()
        self.membersList = []
#@-node:ekr.20060223124014.3:completeFromObject
#@-node:ekr.20060221112937:setObjectAndMembersList & helpers
#@+node:ekr.20051127070018:setSelection
def setSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = g.app.gui.getInsertPoint(w)
        
    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n > -1: s = s[:n]
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    # g.trace(i,j)
    g.app.gui.setSelectionRange(w,i,j,insert=j)
    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor_now(c.currentPosition(),incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
#@-node:ekr.20051127070018:setSelection
#@+node:ekr.20060220062710:start
def start (self,event=None,w=None):
    
    if w: self.widget = w
    else: w = self.widget
    
    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = g.app.gui.getSelectionRange(w)
    self.selectedText = g.app.gui.getSelectedText(w)
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = g.app.gui.getInsertPoint(w)
            if w.get(i+'-1c') == '.':
                w.delete(i+'-1c')
                
        self.autoCompleterStateHandler(event)
    else:
        self.abort()
#@-node:ekr.20060220062710:start
#@-node:ekr.20060216160332.2:Helpers
#@+node:ekr.20060216160332.1:Scanning
# Not used at present, but soon.
#@+node:ekr.20060217132329:initialScan
# Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):
    
    g.trace(g.callers())
    
    self.scan(thread=True)
#@-node:ekr.20060217132329:initialScan
#@+node:ekr.20060216155558.1:scan
def scan (self,event=None,verbose=True,thread=True):
    
    __pychecker__ = '--no-argsused' # thread arg not used at present.
    
    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return
    
    # g.trace('autocompleter')
    
    if 0: ## thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)
    
        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
#@-node:ekr.20060216155558.1:scan
#@+node:ekr.20060216163305:definePatterns
def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
#@nonl
#@-node:ekr.20060216163305:definePatterns
#@+node:ekr.20060216161220:scanOutline
def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''
    
    if verbose: g.es_print('Scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        keys = self.watchwords.keys() ; keys.sort()
        for key in keys:
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        keys = self.calltips.keys() ; keys.sort()
        for key in keys:
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))
        
    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
#@-node:ekr.20060216161220:scanOutline
#@+node:ekr.20060216161234:scanForCallTip
def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')
    
    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, b = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList
    
    self.calltips [language] = d
#@-node:ekr.20060216161234:scanForCallTip
#@+node:ekr.20060216161247:scanForAutoCompleter
def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')
    
    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i < n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
#@+node:ekr.20051025144611.20:makeAutocompletionList
def makeAutocompletionList (self,a,b,glist):
    
    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''
    
    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i >= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a
            
        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)
            
        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
#@+node:ekr.20060216161258:reverseFindWhitespace
def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i >= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
#@-node:ekr.20060216161258:reverseFindWhitespace
#@+node:ekr.20060216161253:getCleanString
def getCleanString (self,s):
    
    '''Return the prefix of s containing only chars in okchars.'''
    
    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
#@-node:ekr.20060216161253:getCleanString
#@-node:ekr.20051025144611.20:makeAutocompletionList
#@-node:ekr.20060216161247:scanForAutoCompleter
#@-node:ekr.20060216160332.1:Scanning
#@+node:ekr.20060223114802:Proxy classes and objects
#@+node:ekr.20060223114802.1:createProxyObjectFromClass
def createProxyObjectFromClass (self,className,theClass):
    
    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in xrange(n)]
        
    def dummyCtor (self):
        pass
        
    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')
        
    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
#@-node:ekr.20060223114802.1:createProxyObjectFromClass
#@+node:ekr.20060223093358:createClassObjectFromString
def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec s

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in computeProxyObject')
            g.es_exception()
        return None
#@-node:ekr.20060223093358:createClassObjectFromString
#@-node:ekr.20060223114802:Proxy classes and objects
#@+node:ekr.20060223093117:class forgivingParserClass
class forgivingParserClass:
    
    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''
    
    @others
#@+node:ekr.20060223093117.1:ctor (forgivingParserClass)
def __init__ (self,c):
    
    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
#@-node:ekr.20060223093117.1:ctor (forgivingParserClass)
#@+node:ekr.20060223093117.2:parse
def parse (self,p):
    
    '''The top-level parser method.
    
    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''
    
    c = self.c
    
    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody
    
    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody
    
    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody
        return s
#@-node:ekr.20060223093117.2:parse
#@+node:ekr.20060223093117.3:forgivingParser
def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('Syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('Syntax error: deleting %s' % p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
#@-node:ekr.20060223093117.3:forgivingParser
#@+node:ekr.20060223093117.4:computeErrorNode
def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n >= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
#@-node:ekr.20060223093117.4:computeErrorNode
#@+node:ekr.20060223093117.5:newPutBody
def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
#@-node:ekr.20060223093117.5:newPutBody
#@-node:ekr.20060223093117:class forgivingParserClass
#@+node:ekr.20060222082041:class classScannerClass
class classScannerClass:
    
    '''A class to find class definitions in a node or its parents.'''
    
    @others
#@+node:ekr.20060222082041.1:ctor
def __init__ (self,c):
    
    self.c = c
    
    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
#@-node:ekr.20060222082041.1:ctor
#@+node:ekr.20060223120755:scan
def scan (self):
    
    c = self.c

    className,obj,p = self.findParentClass(c.currentPosition())
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None
        
    return className,obj,p,s
#@-node:ekr.20060223120755:scan
#@+node:ekr.20060222082041.2:findParentClass
def findParentClass (self,root):
    
    autoCompleter = self.c.k.autoCompleter
    
    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.headString())
            return None,obj,p
    
    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.headString())
            return className,None,p
    
    return None,None,None
#@-node:ekr.20060222082041.2:findParentClass
#@+node:ekr.20060222082041.3:findClass & helpers
def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
#@+node:ekr.20060222082041.4:endsDoc
def endsDoc (self,s):
    
    return s.startswith('@c')
#@-node:ekr.20060222082041.4:endsDoc
#@+node:ekr.20060222082041.5:startsClass
def startsClass (self,s):
    
    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
#@-node:ekr.20060222082041.5:startsClass
#@+node:ekr.20060222082041.6:startsDoc
def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
#@-node:ekr.20060222082041.6:startsDoc
#@-node:ekr.20060222082041.3:findClass & helpers
#@-node:ekr.20060222082041:class classScannerClass
#@-node:ekr.20051126123249:class autoCompleterClass
#@-node:ekr.20060927173836.1:Make calltips and autocompleter 'stateless'
#@-node:ekr.20060530085844:Improve autocompletion
#@+node:ekr.20060306194040:Video and more screen shots Leo's web site
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3615177
By: ktenney

High on my ToLearn list is vnc2swf
http://www.unixuser.org/~euske/vnc2swf/


http://sourceforge.net/forum/message.php?msg_id=3615278
By: James

A lot of people are now using Wink for demonstrations
(http://www.debugmode.com/wink/), it's is free and seems to work well.

Check out http://murl.se/11332
At the bottom they talk about tools and techniques.
http://showmedo.com seems like it would be a good
place to host vids also.

I've listened/watched a fair number of things like this;
my recomendation is to get a good microphone and
pre-amp to record your voice, and prepare the audio
track carefully. It is so aggravating when
it's hard to discern the words being spoken.

Thanks,
Kent
#@nonl
#@+node:ekr.20060531134434:Tutorials
http://sourceforge.net/forum/message.php?msg_id=3758271

From: Rich

Tutorials would be great. I use Liberty BASIC, (http://libertybasic.conforums.com)
and it has a very good tutorial -- leads the beginner by the hand through much
of the language. Also the help file has working code snippets
to cut-n-paste-n-play-with. I'd like to see something like:

[Buttons]
...[What are Buttons good for?]
...[How do I make my own buttons?]
......[Some commands you can use with buttons]
......[Where to find button commands]
#@nonl
#@-node:ekr.20060531134434:Tutorials
#@+node:ekr.20060531134434.1:Screencasts
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3758303
By: ktenney

My sense is that documentation/screencasts has the
greatest potential for expanding Leo's mindshare.

I really like those produced by the good folks
at Dabo;
http://leafe.com/screencasts/
http://leafe.com/screencasts/populategrid.html

The TurboGears people have taken this to the extreme;
http://www.turbogears.org/ultimate.html

Leo is different enough that it warrants a 
demonstration of it's advantages.
#@nonl
#@-node:ekr.20060531134434.1:Screencasts
#@+node:ekr.20060829103523:Render Leo slideshows
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3889246
By: terry_n_brown

Three packages that might be candidates for "rendering" slides authored in Leo:

MagicPoint: http://member.wide.ad.jp/wg/mgp/

  uses a text file format that leo could produce

Slidy: http://www.w3.org/Talks/Tools/Slidy/

  uses XHTML / canned Java script

S5: http://meyerweb.com/eric/tools/s5/

  Similar to Slidy I think, haven't looked at it
#@nonl
#@-node:ekr.20060829103523:Render Leo slideshows
#@-node:ekr.20060306194040:Video and more screen shots Leo's web site
#@+node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
@nocolor

We could allow uses to define Leo menus.
To do this, we must use minibuffer names for all menu entries

@color
#@nonl
#@-node:ekr.20060202231708.1:@menu nodes in leoSettings.leo
#@-node:ekr.20060527164612:Important 1-2 day projects
#@+node:ekr.20060527182117:Important 1-2 week projects
#@+node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060603085719.1:Use IPython autocompleter?
#@-node:ekr.20060603085719.1:Use IPython autocompleter?
#@+node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@-node:ekr.20060603090445.8:Add newline history (like Iptyon history?)
#@+node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@-node:ekr.20060601150940.1:Investigate Ipython support in Scripting plugin
#@+node:ekr.20060603090445.9:Script button that saves environment between runs
This would allow IPython-like operation.
#@nonl
#@-node:ekr.20060603090445.9:Script button that saves environment between runs
#@-node:ekr.20060603090445.7:Ipython stuff
#@+node:ekr.20060629154112:Merge Leo & jyLeo
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3799470
By: leouser

I guess its hard to say what pieces must merge and what can stay different.
Id like it if the blasted nodes were the same.  I guess there is progress again
on a jython 2.2 being complete and work starting on 2.3.  So there is hope that
the nodes will be the same code, at least it will be possible.

At the top of my head the big differences outside of the position changes are:
1. Some modifications to the read/write code so that Chapters can work and also
Serialized positions.
2. Commander has some things different, it looks to the Chapters instance to
determine what is the curentPosition, top Position etc... instead of keeping
track of it itself.
3. GUI layers are very different.  Interesting tidbit here: the work I did to
get the JTree to use positions to determine if a node is expanded or not looks
like it has provided the outline for enhancing the JTree for Java itself to
be able to do this.  We will have to see, but maybe in Java 7 you can say: "Positions
lead to user controled tree expansion models".

There is a tremendous amount that is the same. Im sure you could make an interesting
evening out of comparing the codebases to see where things change.


#@-node:ekr.20060629154112:Merge Leo & jyLeo
#@-node:ekr.20060527182117:Important 1-2 week projects
#@-all
#@nonl
#@-node:ekr.20040117181936:@thin ../doc/leoToDo.txt
#@-leo
